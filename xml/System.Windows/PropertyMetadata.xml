<Type Name="PropertyMetadata" FullName="System.Windows.PropertyMetadata">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5c5dfef7a02e9b858a22854c1ef79b198ef1d9bc" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class PropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyMetadata extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="6f377-101">Definiuje zachowanie niektórych aspektów właściwości zależności, ponieważ jest ono stosowane do określonego typu, w tym warunki, który został zarejestrowany.</span>
      <span class="sxs-lookup">
        <span data-stu-id="6f377-101">Defines certain behavior aspects of a dependency property as it is applied to a specific type, including conditions it was registered with.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6f377-102">Metadane właściwości mogą być definiowane i używanych podczas rejestrowania właściwości zależności, podczas wywoływania metody <xref:System.Windows.DependencyProperty.Register%2A> — metoda (lub odchyleń dla właściwości tylko do odczytu zależności lub dołączone właściwości) lub po pierwotnej rejestracji właściciel podczas wywoływania metody <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="6f377-102">Property metadata can be defined and used during dependency property registration when calling the <xref:System.Windows.DependencyProperty.Register%2A> method (or variations for attached properties or read-only dependency properties), or after original owner registration when calling the <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> method.</span></span> <span data-ttu-id="6f377-103"><xref:System.Windows.DependencyProperty.AddOwner%2A> ma również metadane właściwości.</span><span class="sxs-lookup"><span data-stu-id="6f377-103"><xref:System.Windows.DependencyProperty.AddOwner%2A> also takes property metadata.</span></span>  
  
 <span data-ttu-id="6f377-104">Ta klasa jest klasą bazową konkretnych mogą być używane w każdej z tych wywołań.</span><span class="sxs-lookup"><span data-stu-id="6f377-104">This class is a concrete base class that can be used in each of these calls.</span></span> <span data-ttu-id="6f377-105">Jednak często zdarza się, aby określić przy użyciu jednej z klas pochodnych takich jak metadanych <xref:System.Windows.FrameworkPropertyMetadata>.</span><span class="sxs-lookup"><span data-stu-id="6f377-105">However, it is very common to specify metadata using one of the derived classes such as <xref:System.Windows.FrameworkPropertyMetadata>.</span></span> <span data-ttu-id="6f377-106">Te klasy pochodnej obsługuje bardziej szczegółowe metadanych jako wartości właściwości typu Boolean, które są przydatne w przypadku wykrycia albo włączenie niektórych właściwości systemu i układu zachowania, które są implementowane tylko na [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] poziom framework.</span><span class="sxs-lookup"><span data-stu-id="6f377-106">These derived classes support more detailed metadata carried as Boolean property values, which are useful for either detecting or enabling some property system and layout behaviors that are only implemented at the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] framework level.</span></span>  
  
 <span data-ttu-id="6f377-107">Kilka właściwości tej klasy są odczytu i zapisu do modelu obiektu, ale można zapisywać tylko przed wystąpienia, takich jak używane w ramach operacji systemu właściwość <xref:System.Windows.DependencyProperty.Register%2A> lub <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>.</span><span class="sxs-lookup"><span data-stu-id="6f377-107">Several properties of this class are read-write to the object model, but can only be written prior to the instance being used in a property system operation such as <xref:System.Windows.DependencyProperty.Register%2A> or <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>.</span></span> <span data-ttu-id="6f377-108">Każdej z tych właściwości można również zostały ustawione przez konstruktora, ale są dostępne, aby <xref:System.Windows.PropertyMetadata.Merge%2A> implementacje metod można włączyć dla nich.</span><span class="sxs-lookup"><span data-stu-id="6f377-108">Each of these properties could also have been set by the constructor but are exposed so that <xref:System.Windows.PropertyMetadata.Merge%2A> method implementations can set them.</span></span>  
  
<a name="xamlTextUsage_PropertyMetadata"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="6f377-109">Użycie tekstu w języku XAML</span><span class="sxs-lookup"><span data-stu-id="6f377-109">XAML Text Usage</span></span>  
 <span data-ttu-id="6f377-110">Ten typ i elementy członkowskie tego typu nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="6f377-110">This type, and members of this type, are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="6f377-111">Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.PropertyMetadata" /> klasy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-111">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="6f377-112">Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.PropertyMetadata" /> klasy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-112">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="6f377-113">Wartość domyślna, aby określić dla właściwości zależności, zwykle dostarczonych jako wartość określonego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-113">The default value to specify for a dependency property, usually provided as a value of some specific type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6f377-114">Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.PropertyMetadata" /> klasy z określoną wartość domyślną dla właściwości zależności, który będzie dotyczyć tych metadanych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-114">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with a specified default value for the dependency property that this metadata will be applied to.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6f377-115">Typ wartości podanej dla `defaultValue` muszą być zgodne, lub być związane z typem określonym w pierwotnej rejestracji właściwości zależności, która będzie dotyczyć tych metadanych.</span><span class="sxs-lookup"><span data-stu-id="6f377-115">The type of the value provided for `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="6f377-116">Niezgodność między typ wartości domyślnej metadanych i typu właściwości zależności, który jest stosowany do może być trudne do debugowania, ponieważ niezgodność nie jest wykrywalny podczas kompilacji (niezgodność zgłosi wyjątek czasu wykonywania).</span><span class="sxs-lookup"><span data-stu-id="6f377-116">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="6f377-117">Chociaż jest to wartość domyślna dla konstruktora bez parametrów, `defaultValue` z <xref:System.Windows.DependencyProperty.UnsetValue> nie może zostać określony.</span><span class="sxs-lookup"><span data-stu-id="6f377-117">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="6f377-118">Takie próby zgłosi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="6f377-118">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6f377-119">
            <paramref name="defaultValue" /> Nie można ustawić na wartość <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-119">
              <paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">
          <span data-ttu-id="6f377-120">Odwołanie do implementacji programu obsługi, która jest wywoływana przez system właściwości przy każdej zmianie efektywną wartość właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-120">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6f377-121">Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.PropertyMetadata" /> klasy z określonym <see cref="T:System.Windows.PropertyChangedCallback" /> odwołanie do implementacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-121">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="6f377-122">Wartość domyślna właściwości zależności, zwykle dostarczonych jako wartość określonego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-122">The default value of the dependency property, usually provided as a value of some specific type.</span>
          </span>
        </param>
        <param name="propertyChangedCallback">
          <span data-ttu-id="6f377-123">Odwołanie do implementacji programu obsługi, która jest wywoływana przez system właściwości przy każdej zmianie efektywną wartość właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-123">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6f377-124">Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.PropertyMetadata" /> klasy z wartością określoną wartość domyślną i <see cref="T:System.Windows.PropertyChangedCallback" /> odwołanie do implementacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-124">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified default value and <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6f377-125">Typ podanej wartości `defaultValue` muszą być zgodne, lub być związane z typem określonym w pierwotnej rejestracji właściwości zależności, która będzie dotyczyć tych metadanych.</span><span class="sxs-lookup"><span data-stu-id="6f377-125">The type of the value provided `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="6f377-126">Niezgodność między typ wartości domyślnej metadanych i typu właściwości zależności, który jest stosowany do może być trudne do debugowania, ponieważ niezgodność nie jest wykrywalny podczas kompilacji (niezgodność zgłosi wyjątek czasu wykonywania).</span><span class="sxs-lookup"><span data-stu-id="6f377-126">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="6f377-127">Chociaż jest to wartość domyślna dla konstruktora bez parametrów, `defaultValue` z <xref:System.Windows.DependencyProperty.UnsetValue> nie może zostać określony.</span><span class="sxs-lookup"><span data-stu-id="6f377-127">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="6f377-128">Takie próby zgłosi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="6f377-128">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6f377-129">
            <paramref name="defaultValue" /> Nie można ustawić na wartość <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-129">
              <paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="6f377-130">Wartość domyślna właściwości zależności, zwykle dostarczonych jako wartość określonego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-130">The default value of the dependency property, usually provided as a value of some specific type.</span>
          </span>
        </param>
        <param name="propertyChangedCallback">
          <span data-ttu-id="6f377-131">Odwołanie do implementacji programu obsługi, która jest wywoływana przez system właściwości przy każdej zmianie efektywną wartość właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-131">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span>
          </span>
        </param>
        <param name="coerceValueCallback">
          <span data-ttu-id="6f377-132">Odwołanie do implementacji programu obsługi, który ma być wywoływana, gdy wywołań systemowych właściwości <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> względem tej właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-132">Reference to a handler implementation that is to be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> against this property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6f377-133">Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.PropertyMetadata" /> z określoną wartość domyślną i wywołania zwrotne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-133">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified default value and callbacks.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6f377-134">Jeśli chcesz określić <xref:System.Windows.CoerceValueCallback> , ale nie <xref:System.Windows.PropertyChangedCallback>, można przekazać `null` dla `propertyChangedCallback` parametru.</span><span class="sxs-lookup"><span data-stu-id="6f377-134">If you want to specify a <xref:System.Windows.CoerceValueCallback> but not a <xref:System.Windows.PropertyChangedCallback>, you can pass `null` for the `propertyChangedCallback` parameter.</span></span>  
  
 <span data-ttu-id="6f377-135">Typ wartości podanej dla `defaultValue` muszą być zgodne, lub być związane z typem określonym w pierwotnej rejestracji właściwości zależności, która będzie dotyczyć tych metadanych.</span><span class="sxs-lookup"><span data-stu-id="6f377-135">The type of the value provided for `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="6f377-136">Niezgodność między typ wartości domyślnej metadanych i typu właściwości zależności, który jest stosowany do może być trudne do debugowania, ponieważ niezgodność nie jest wykrywalny podczas kompilacji (niezgodność zgłosi wyjątek czasu wykonywania).</span><span class="sxs-lookup"><span data-stu-id="6f377-136">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="6f377-137">Chociaż jest to wartość domyślna dla konstruktora bez parametrów, `defaultValue` z <xref:System.Windows.DependencyProperty.UnsetValue> nie może zostać określony.</span><span class="sxs-lookup"><span data-stu-id="6f377-137">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="6f377-138">Takie próby zgłosi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="6f377-138">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6f377-139">
            <paramref name="defaultValue" /> Nie można ustawić na wartość <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-139">
              <paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback CoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback CoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property CoerceValueCallback As CoerceValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::CoerceValueCallback ^ CoerceValueCallback { System::Windows::CoerceValueCallback ^ get(); void set(System::Windows::CoerceValueCallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6f377-140">Pobiera lub ustawia odwołanie do <see cref="T:System.Windows.CoerceValueCallback" /> implementacji określony w metadanych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-140">Gets or sets a reference to a <see cref="T:System.Windows.CoerceValueCallback" /> implementation specified in this metadata.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6f377-141">A <see cref="T:System.Windows.CoerceValueCallback" /> odwołanie do implementacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-141">A <see cref="T:System.Windows.CoerceValueCallback" /> implementation reference.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6f377-142">Wywołania zwrotne w metadanych właściwości nie są zwykle publicznych elementów członkowskich w typie zawierającym, więc wartość tej właściwości nie jest ważna w przypadku większości scenariuszy używające tylko metadane istniejącej właściwości zależności.</span><span class="sxs-lookup"><span data-stu-id="6f377-142">The callbacks in property metadata are not typically public members on the containing type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</span></span> <span data-ttu-id="6f377-143">Jedną z przyczyn jest uwidaczniana, ta właściwość jest tak, aby podklasy metadanych można wykonać ich logiki żądaną scalania, jeśli zarówno podstawowe, jak i zastępowanie Dodawanie metadanych określ <xref:System.Windows.CoerceValueCallback>.</span><span class="sxs-lookup"><span data-stu-id="6f377-143">One reason this property is exposed is so that metadata subclasses can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <xref:System.Windows.CoerceValueCallback>.</span></span> <span data-ttu-id="6f377-144">Jednak domyślnie scalania logikę <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> jest zastąpienie poprzedniej.</span><span class="sxs-lookup"><span data-stu-id="6f377-144">However, the default merge logic for a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is to replace the previous one.</span></span>  
  
 <span data-ttu-id="6f377-145"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> jest zdefiniowany w modelu obiektów w trybie odczytu i zapisu.</span><span class="sxs-lookup"><span data-stu-id="6f377-145"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="6f377-146">Dzieje się tak <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> można dostosować po zainicjowaniu elementu <xref:System.Windows.PropertyMetadata> samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="6f377-146">This is so <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="6f377-147">Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwość zostanie zapieczętować tego wystąpienia metadanych i właściwości są teraz uważany za niezmienialny.</span><span class="sxs-lookup"><span data-stu-id="6f377-147">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="6f377-148">Trwa próba skonfigurowania <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="6f377-148">Attempting to set <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6f377-149">Nie można ustawić właściwości metadanych, po zastosowaniu ich do operacji właściwości zależności.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-149">Cannot set a metadata property once it is applied to a dependency property operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultValue">
      <MemberSignature Language="C#" Value="public object DefaultValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.DefaultValue" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DefaultValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6f377-150">Pobiera lub ustawia wartość domyślna właściwości zależności.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-150">Gets or sets the default value of the dependency property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6f377-151">Wartość domyślna właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-151">The default value of the property.</span>
          </span>
          <span data-ttu-id="6f377-152">Wartość domyślna dla <see cref="T:System.Windows.PropertyMetadata" /> wystąpienia utworzone za pomocą konstruktora bez parametrów zostaną <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-152">The default value on a <see cref="T:System.Windows.PropertyMetadata" /> instance created with the parameterless constructor will be <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6f377-153"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> jest zdefiniowany w modelu obiektów w trybie odczytu i zapisu.</span><span class="sxs-lookup"><span data-stu-id="6f377-153"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="6f377-154">Dzieje się tak <xref:System.Windows.PropertyMetadata.DefaultValue%2A> można dostosować po zainicjowaniu elementu <xref:System.Windows.PropertyMetadata> samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="6f377-154">This is so <xref:System.Windows.PropertyMetadata.DefaultValue%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="6f377-155">Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwość zostanie zapieczętować tego wystąpienia metadanych i właściwości są teraz uważany za niezmienialny.</span><span class="sxs-lookup"><span data-stu-id="6f377-155">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="6f377-156">Trwa próba skonfigurowania <xref:System.Windows.PropertyMetadata.DefaultValue%2A> po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="6f377-156">Attempting to set <xref:System.Windows.PropertyMetadata.DefaultValue%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 <span data-ttu-id="6f377-157">Chociaż jest to wartość domyślna dla konstruktora bez parametrów, `defaultValue` z <xref:System.Windows.DependencyProperty.UnsetValue> nie można ustawić za pomocą <xref:System.Windows.PropertyMetadata.DefaultValue%2A> lub konstruktora.</span><span class="sxs-lookup"><span data-stu-id="6f377-157">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be set using either <xref:System.Windows.PropertyMetadata.DefaultValue%2A> or the constructor.</span></span> <span data-ttu-id="6f377-158">Takie próby zgłosi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="6f377-158">Attempting to do so will raise an exception.</span></span>  
  
<a name="xamlTextUsage_PropertyChangedCallback"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="6f377-159">Użycie tekstu w języku XAML</span><span class="sxs-lookup"><span data-stu-id="6f377-159">XAML Text Usage</span></span>  
 <span data-ttu-id="6f377-160">Elementy członkowskie tego typu nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="6f377-160">Members of this type are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6f377-161">Nie można ustawić na wartość <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> raz utworzony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-161">Cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> once created.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6f377-162">Nie można ustawić właściwości metadanych, po zastosowaniu ich do operacji właściwości zależności.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-162">Cannot set a metadata property once it is applied to a dependency property operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="protected bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsSealed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6f377-163">Pobiera wartość określającą, czy metadane zostały zastosowane do właściwości w sposób, co w stanie modyfikować tego wystąpienia metadanych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-163">Gets a value that determines whether the metadata has been applied to a property in some way, resulting in the immutable state of that metadata instance.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6f377-164">
            <see langword="true" /> Jeśli wystąpienie metadanych jest niezmienialny; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-164">
              <see langword="true" /> if the metadata instance is immutable; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6f377-165">Różne właściwości <xref:System.Windows.PropertyMetadata>, takich jak <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, są zdefiniowane w modelu obiektów w trybie odczytu i zapisu.</span><span class="sxs-lookup"><span data-stu-id="6f377-165">Various properties of <xref:System.Windows.PropertyMetadata>, such as <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, are defined in the object model as read-write.</span></span> <span data-ttu-id="6f377-166">Jest więc te właściwości można dostosować po zainicjowaniu elementu <xref:System.Windows.PropertyMetadata> samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="6f377-166">This is so those properties can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="6f377-167">Jednak po metadanych jest stosowany do właściwości zależności w ramach wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwość zostanie zapieczętować tego wystąpienia metadanych i właściwości są teraz uważany za niezmienialny.</span><span class="sxs-lookup"><span data-stu-id="6f377-167">However, once the metadata is applied to a dependency property as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="6f377-168">W czasie jednej z tych wywołań <xref:System.Windows.PropertyMetadata.OnApply%2A> nosi nazwę, a wartość tej właściwości jest równa `true`.</span><span class="sxs-lookup"><span data-stu-id="6f377-168">At the time of one of these calls, <xref:System.Windows.PropertyMetadata.OnApply%2A> is called, and the value of this property is set to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6f377-169">Następujące testy przykład <xref:System.Windows.PropertyMetadata.IsSealed%2A> przed operacją zestaw właściwości niestandardowych metadanych.</span><span class="sxs-lookup"><span data-stu-id="6f377-169">The following example  checks <xref:System.Windows.PropertyMetadata.IsSealed%2A> prior to a set operation of a custom metadata property.</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected virtual void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">
          <span data-ttu-id="6f377-170">Podstawowy metadanych do scalenia z wartościami tego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-170">The base metadata to merge with this instance's values.</span>
          </span>
        </param>
        <param name="dp">
          <span data-ttu-id="6f377-171">Właściwości zależności, do którego stosowana jest metadanych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-171">The dependency property to which this metadata is being applied.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6f377-172">Scala te metadane z metadanymi podstawowej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-172">Merges this metadata with the base metadata.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6f377-173">Ta metoda jest używana wewnętrznie, gdy metadane są zastępowane (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> metody).</span><span class="sxs-lookup"><span data-stu-id="6f377-173">This method is used internally when metadata is being overridden (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6f377-174">Poniższy przykład implementuje scalania dla typu niestandardowych metadanych, który dodaje właściwość dodatkowe metadane właściwości.</span><span class="sxs-lookup"><span data-stu-id="6f377-174">The following example implements a merge for a custom metadata type that adds an additional property to the property metadata.</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="6f377-175">Klasa implementacji, które pochodzą z <see cref="T:System.Windows.PropertyMetadata" /> powinny przesłaniać tę metodę, aby uwzględnić wszystkie właściwości metadanych dodali do ich implementacji.</span>
            <span class="sxs-lookup">
              <span data-stu-id="6f377-175">Class implementations that derive from <see cref="T:System.Windows.PropertyMetadata" /> should override this method to account for any metadata properties they have added in their implementations.</span>
            </span>
            <span data-ttu-id="6f377-176">Na przykład implementacji może dodano nową wartość wyliczenia flagwise i <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementacji następnie powinny mieć możliwość łączenia tych flag poprawnie.</span>
            <span class="sxs-lookup">
              <span data-stu-id="6f377-176">For instance, your implementation might have added a new flagwise enumeration value, and the <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementation should then be able to combine those flags correctly.</span>
            </span>
            <span data-ttu-id="6f377-177">Zawsze wywoływać implementację podstawową przed kod implementacji, ponieważ Podstawowa implementacja zajmuje się wszystkie właściwości, które są już zdefiniowane na scalanie <see cref="T:System.Windows.PropertyMetadata" /> typu.</span>
            <span class="sxs-lookup">
              <span data-stu-id="6f377-177">Always call the base implementation prior to your implementation code, because the base implementation takes care of merging all the properties already defined on the <see cref="T:System.Windows.PropertyMetadata" /> type.</span>
            </span>
            <span data-ttu-id="6f377-178">Dokładne zachowanie scalania zależy od użytkownika.</span>
            <span class="sxs-lookup">
              <span data-stu-id="6f377-178">The exact behavior of the merge is up to you.</span>
            </span>
            <span data-ttu-id="6f377-179">Można wybrać wartości połączone, przywrócić wartości podstawowej Jeśli pochodnej metadanych pozostawiono domyślne lub wielu innych zachowań na podstawie typów właściwości, które zostały dodane do metadanych konkretnej klasy i ich znaczenie.</span>
            <span class="sxs-lookup">
              <span data-stu-id="6f377-179">You could choose to have values combined, revert to base value if the derived metadata were left at the default, or many other behaviors based on the types of properties you have added to your particular metadata class, and their meanings.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected virtual void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="6f377-180">Właściwości zależności, do którego zastosowano metadanych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-180">The dependency property to which the metadata has been applied.</span>
          </span>
        </param>
        <param name="targetType">
          <span data-ttu-id="6f377-181">Typ skojarzony z metadanych, jeśli jest to metadanych określonego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-181">The type associated with this metadata if this is type-specific metadata.</span>
          </span>
          <span data-ttu-id="6f377-182">Jeśli jest to domyślny metadanych, ta wartość jest odwołanie o wartości null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-182">If this is default metadata, this value is a null reference.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6f377-183">Wywoływane, gdy zastosowano te metadane dla właściwości, co oznacza, że metadane jest zapieczętowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-183">Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6f377-184">Podklasy powinny zapewnić, że wszystkie zmienność struktury danych <xref:System.Windows.PropertyMetadata> podklasy powinien być oznaczony jako niezmienialny raz <xref:System.Windows.PropertyMetadata.OnApply%2A> jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="6f377-184">Subclasses should assure that any mutability of the data structure of a <xref:System.Windows.PropertyMetadata> subclass should be marked as immutable once <xref:System.Windows.PropertyMetadata.OnApply%2A> is called.</span></span> <span data-ttu-id="6f377-185">To będzie wywoływana po zastosowaniu metadanych dla działania systemu właściwości (rejestrowanie, dodawanie właściciela, zastępowanie metadanych).</span><span class="sxs-lookup"><span data-stu-id="6f377-185">This will be called once the metadata is applied to a property system operation (register, add owner, override metadata).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChangedCallback">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyChangedCallback PropertyChangedCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyChangedCallback PropertyChangedCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyChangedCallback As PropertyChangedCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyChangedCallback ^ PropertyChangedCallback { System::Windows::PropertyChangedCallback ^ get(); void set(System::Windows::PropertyChangedCallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6f377-186">Pobiera lub ustawia odwołanie do <see cref="T:System.Windows.PropertyChangedCallback" /> implementacji określony w metadanych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-186">Gets or sets a reference to a <see cref="T:System.Windows.PropertyChangedCallback" /> implementation specified in this metadata.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6f377-187">A <see cref="T:System.Windows.PropertyChangedCallback" /> odwołanie do implementacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-187">A <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6f377-188">Wywołania zwrotne w metadanych właściwości nie są zwykle publiczne elementy członkowskie na typ definiujący, dlatego wartość tej właściwości nie jest ważna w przypadku większości scenariuszy używające tylko metadane istniejącej właściwości zależności.</span><span class="sxs-lookup"><span data-stu-id="6f377-188">The callbacks in property metadata are not typically public members on the defining type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</span></span> <span data-ttu-id="6f377-189">Jedną z przyczyn jest uwidaczniana, ta właściwość jest tak, aby klasy metadanych można wykonać ich logiki żądaną scalania, jeśli zarówno podstawowe, jak i zastępowanie Dodawanie metadanych określ <xref:System.Windows.PropertyChangedCallback>.</span><span class="sxs-lookup"><span data-stu-id="6f377-189">One reason this property is exposed is so that metadata classes can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <xref:System.Windows.PropertyChangedCallback>.</span></span> <span data-ttu-id="6f377-190">Domyślna logika scalania dla jest obsługa wszystkich <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> implementacje w tabeli i połączenie ich z ustanowiono przez klasę najgłębszym w hierarchii z pierwszego.</span><span class="sxs-lookup"><span data-stu-id="6f377-190">The default merge logic for is to maintain all <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> implementations in a table and call each of them, with callbacks established by the deepest class in hierarchy running first.</span></span>  
  
 <span data-ttu-id="6f377-191"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> jest zdefiniowany w modelu obiektów w trybie odczytu i zapisu.</span><span class="sxs-lookup"><span data-stu-id="6f377-191"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="6f377-192">Dzieje się tak <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> można dostosować po zainicjowaniu elementu <xref:System.Windows.PropertyMetadata> samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="6f377-192">This is so <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="6f377-193">Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwość zostanie zapieczętować tego wystąpienia metadanych i właściwości są teraz uważany za niezmienialny.</span><span class="sxs-lookup"><span data-stu-id="6f377-193">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="6f377-194">Trwa próba skonfigurowania <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="6f377-194">Attempting to set <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6f377-195">Nie można ustawić właściwości metadanych, po zastosowaniu ich do operacji właściwości zależności.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6f377-195">Cannot set a metadata property once it is applied to a dependency property operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>
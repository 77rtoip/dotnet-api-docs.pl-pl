<Type Name="Application" FullName="System.Windows.Application">
  <Metadata><Meta Name="ms.openlocfilehash" Value="49de4dab9ea26712375d19c72600f630203d96ad" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65004150" /></Metadata><TypeSignature Language="C#" Value="public class Application : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Application extends System.Windows.Threading.DispatcherObject implements class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Application" />
  <TypeSignature Language="VB.NET" Value="Public Class Application&#xA;Inherits DispatcherObject&#xA;Implements IQueryAmbient" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application : System::Windows::Threading::DispatcherObject, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type Application = class&#xA;    inherit DispatcherObject&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Hermetyzuje aplikacji Windows Presentation Foundation.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> jest klasą, która hermetyzuje [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] funkcje specyficzne dla aplikacji, w tym następujące czynności:  
  
-   **Okres istnienia aplikacji**: <xref:System.Windows.Application.Activated>, <xref:System.Windows.Application.Current%2A>, <xref:System.Windows.Application.Deactivated>, <xref:System.Windows.Application.DispatcherUnhandledException>, <xref:System.Windows.Application.Exit>, <xref:System.Windows.Application.Run%2A>, <xref:System.Windows.Application.SessionEnding>, <xref:System.Windows.Application.Shutdown%2A>, <xref:System.Windows.Application.ShutdownMode%2A>, <xref:System.Windows.Application.Startup>.  
  
-   **Okno zakresu aplikacji, właściwości i zarządzanie zasobami**: <xref:System.Windows.Application.FindResource%2A>, <xref:System.Windows.Application.GetContentStream%2A>, <xref:System.Windows.Application.GetResourceStream%2A>, <xref:System.Windows.Application.LoadComponent%2A>, <xref:System.Windows.Application.MainWindow%2A>, <xref:System.Windows.Application.Properties%2A>, <xref:System.Windows.Application.Resources%2A>, <xref:System.Windows.Application.StartupUri%2A>, <xref:System.Windows.Application.Windows%2A>.  
  
-   **Parametr wiersza polecenia i zakończenia kodu przetwarzania**: <xref:System.Windows.Application.Startup?displayProperty=nameWithType>, <xref:System.Windows.Application.Exit?displayProperty=nameWithType>, <xref:System.Windows.Application.Shutdown%2A?displayProperty=nameWithType>.  
  
-   **Nawigacja**: <xref:System.Windows.Application.FragmentNavigation>, <xref:System.Windows.Application.LoadCompleted>, <xref:System.Windows.Application.Navigated>, <xref:System.Windows.Application.Navigating>, <xref:System.Windows.Application.NavigationProgress>, <xref:System.Windows.Application.NavigationStopped>, <xref:System.Windows.Application.NavigationFailed>, <xref:System.Windows.Application.SetCookie%2A>, <xref:System.Windows.Application.GetCookie%2A>.  
  
 <xref:System.Windows.Application> implementuje wzorzec singleton w celu zapewnienia dostępu współdzielonego do jej okna, właściwości i usługi w zakresie zasobów. W związku z tym, tylko jedno wystąpienie <xref:System.Windows.Application> klasy mogą być tworzone na <xref:System.AppDomain>.  
  
 Możesz zaimplementować <xref:System.Windows.Application> przy użyciu znaczników, znaczników i związane z kodem lub kodu. Jeśli <xref:System.Windows.Application> jest implementowany przy użyciu znaczników, czy znaczników lub znaczników i kodu powiązanego pliku znaczników musi być skonfigurowany jako [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] `ApplicationDefinition` elementu.  
  
> [!NOTE]
>  Aplikacja autonomiczna nie wymaga <xref:System.Windows.Application> obiektu można zaimplementować niestandardowy `static` metody punktu wejścia (`Main`) który powoduje otwarcie okna bez tworzenia wystąpienia obiektu <xref:System.Windows.Application>. Jednak [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] wymagają <xref:System.Windows.Application> obiektu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak standardowej aplikacji są definiowane przy użyciu tylko kod znaczników:  
  
 [!code-xaml[ApplicationSnippets#ApplicationMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppMarkup.xaml#applicationmarkup)]  
  
 W poniższym przykładzie przedstawiono sposób standardowej aplikacji jest definiowana za pomocą tylko kodu:  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppCode.cs#applicationcode)]
 [!code-vb[ApplicationSnippets#ApplicationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/appcode.vb#applicationcode)]  
  
 W poniższym przykładzie pokazano, jak standardowej aplikacji są definiowane przy użyciu kombinacji znaczników i związane z kodem.  
  
 [!code-xaml[ApplicationSnippets#ApplicationXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml#applicationxaml)]  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml.cs#applicationcodebehind)]
 [!code-vb[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/application.xaml.vb#applicationcodebehind)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Publicznie <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) elementy członkowskie tego typu są bezpieczne dla wątków. Ponadto <see cref="M:System.Windows.Application.FindResource(System.Object)" /> i <see cref="M:System.Windows.Application.TryFindResource(System.Object)" /> metod i <see cref="P:System.Windows.Application.Properties" /> i <see cref="P:System.Windows.Application.Resources" /> właściwości są bezpieczne dla wątków.</threadsafe>
    <altmember cref="T:System.Windows.Window" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Application ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Application();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Application" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tylko jedno wystąpienie <xref:System.Windows.Application> klasy mogą być tworzone na <xref:System.AppDomain>, aby zapewnić dostęp do jednego zestawu danych okien, właściwości i zasobów zakresu aplikacji. W związku z tym, domyślny konstruktor obiektu <xref:System.Windows.Application> klasy wykrywa, czy wystąpienie, inicjowany jest pierwszego wystąpienia w <xref:System.AppDomain>; Jeśli nie jest dostępna, <xref:System.InvalidOperationException> zgłaszany.  
  
 <xref:System.Windows.Application> Obiektu dla bieżącego <xref:System.AppDomain> jest uwidaczniany ze statycznej <xref:System.Windows.Application.Current%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Więcej niż jedno wystąpienie <see cref="T:System.Windows.Application" /> klasy jest tworzony na <see cref="T:System.AppDomain" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy aplikacja staje się aplikacja pierwszego planu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aktywowano aplikację Windows Presentation Foundation, który ma co najmniej jeden otwarte okna (staje się aplikacja pierwszego planu) po jest okien aktywowany po raz pierwszy, ponieważ aplikacja została uruchomiona lub gdy jeden z systemu windows aktywowane gdy Aplikacja jest aktywna: W szczególności aktywacji występuje, gdy:  
  
-   Aplikacja zostanie otwarta jego pierwszym oknie.  
  
-   Użytkownik przełączy się do aplikacji za pomocą klawiszy ALT + TAB lub przy użyciu Menedżera zadań.  
  
-   Użytkownik klika przycisk paska zadań dla jednego z okien w aplikacji.  
  
 Aplikacje wymagające do wykrycia podczas aktywacji mogły obsługiwać <xref:System.Windows.Application.Activated> zdarzeń.  
  
 Po uaktywnieniu aplikacji może być wyłączone i ponownie aktywować wiele razy w okresie istnienia. Jeśli zachowanie lub stan aplikacji jest zależna od jego stanu aktywacji, może obsługiwać zarówno <xref:System.Windows.Application.Activated> i <xref:System.Windows.Application.Deactivated> zdarzenia w celu określenia, które aktywacji stanie jej użytkownika.  
  
 Gdy aplikacja stanie się aktywny, <xref:System.Windows.Application.Activated> nie zostaną wywołane ponownie dopóki aplikacja jest aktywna, niezależnie od tego, jak wiele okien aplikacji są aktywowane, gdy aplikacja jest aktywna.  
  
 <xref:System.Windows.Application.Activated> nie jest inicjowane dla [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wykryć, kiedy aplikacja autonomiczna aktywuje i dezaktywuje.  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Windows.Application Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Application Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Application ^ Current { System::Windows::Application ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Windows.Application" Usage="System.Windows.Application.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.Application" /> obiektu dla bieżącego <see cref="T:System.AppDomain" />.</summary>
        <value><see cref="T:System.Windows.Application" /> Obiektu dla bieżącego <see cref="T:System.AppDomain" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> jest na-<xref:System.AppDomain> typ Jednoelementowy, który implementuje statycznej <xref:System.Windows.Application.Current%2A> właściwości w celu zapewnienia dostępu współdzielonego do <xref:System.Windows.Application> wystąpienia dla bieżącego <xref:System.AppDomain>. W tym projekcie gwarantuje tego stanu zarządzanego przez <xref:System.Windows.Application>, łącznie z zasobów udostępnionych i stanu, jest dostępna z lokalizacji pojedynczy, Współdzielony.  
  
 Ta właściwość jest bezpieczny dla wątków i jest dostępny w żadnym z wątków.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy aplikacja przestaje jest aplikacja pierwszego planu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja Windows Presentation Foundation, która ma co najmniej jeden otwarte okna dezaktywuje (przestanie być pierwszoplanowych) po użytkownik wykonuje następujące czynności:  
  
-   Przełącza do innej aplikacji, za pomocą klawiszy ALT + TAB lub przy użyciu Menedżera zadań.  
  
-   Kliknięcie przycisku na pasku zadań dla okna w innej aplikacji.  
  
 Aplikacje wymagające do wykrywania, może obsługiwać dezaktywacji <xref:System.Windows.Application.Deactivated> zdarzeń.  
  
 Po uaktywnieniu aplikacji może być wyłączone i ponownie aktywować wiele razy w okresie istnienia. Jeśli zachowanie lub stan aplikacji jest zależna od jego stanu aktywacji, może obsługiwać zarówno <xref:System.Windows.Application.Deactivated> i <xref:System.Windows.Application.Activated> zdarzenia w celu określenia, które stanowią użytkownika.  
  
 <xref:System.Windows.Application.Deactivated> nie jest inicjowane dla [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wykryć, kiedy aplikacja autonomiczna dezaktywuje i aktywuje.  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Activated" />
      </Docs>
    </Member>
    <Member MemberName="DispatcherUnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.DispatcherUnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DispatcherUnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ DispatcherUnhandledException;" />
      <MemberSignature Language="F#" Value="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " Usage="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wyjątek jest generowany przez aplikację, ale nie jest obsługiwane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie Windows Presentation Foundation przechwytuje nieobsłużone wyjątki, powiadamia użytkowników wyjątek z okna dialogowego (z których mogą zgłosić wyjątek) i automatycznie zamyka aplikację.  
  
 Jednakże, jeśli aplikacja musi wykonać niestandardowe nieobsługiwany wyjątek podczas przetwarzania z centralnej lokalizacji, należy obsługiwać <xref:System.Windows.Application.DispatcherUnhandledException>.  
  
 <xref:System.Windows.Application.DispatcherUnhandledException> jest wywoływane przez <xref:System.Windows.Application> dla każdego wyjątku, który jest nieobsługiwany przez kod działający w głównym wątku interfejsu użytkownika.  
  
 Jeśli wyjątek nie jest obsługiwany w dowolnym tła wątku interfejsu użytkownika (wątku za pomocą własnego <xref:System.Windows.Threading.Dispatcher>) lub wątku w tle proces roboczy (wątek bez <xref:System.Windows.Threading.Dispatcher>), wyjątek nie był kierowany do głównego wątku interfejsu użytkownika. W związku z tym <xref:System.Windows.Application.DispatcherUnhandledException> nie jest inicjowane. W takiej sytuacji należy napisać kod, aby wykonać następujące czynności:  
  
1.  Obsługa wyjątków w wątku tła.  
  
2.  Wysyłanie tych wyjątków do głównego wątku interfejsu użytkownika.  
  
3.  Zgłoś je ponownie w głównym wątku interfejsu użytkownika bez ich, aby umożliwić obsługę <xref:System.Windows.Application.DispatcherUnhandledException> zgłoszenie.  
  
 Aby uzyskać więcej informacji, zobacz [Model wątkowy](~/docs/framework/wpf/advanced/threading-model.md) Przegląd.  
  
 <xref:System.Windows.Application.DispatcherUnhandledException> Programu obsługi zdarzeń jest przekazywany <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs> argument, który zawiera informacje kontekstowe dotyczące wyjątku, w tym:  
  
-   Wyjątek (<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A>).  
  
-   <xref:System.Windows.Threading.Dispatcher> z którego pochodzi (<xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A>).  
  
 Można użyć tych informacji do określenia, czy wyjątek jest możliwe do odzyskania. Może być możliwe do odzyskania wyjątek <xref:System.IO.FileNotFoundException>, na przykład może być niemożliwy do odzyskania wyjątek <xref:System.StackOverflowException>, na przykład.  
  
 Podczas przetwarzania nieobsługiwany wyjątek z <xref:System.Windows.Application.DispatcherUnhandledException>, i nie chcesz [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] aby kontynuować, jego przetwarzania, musisz ustawić <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A> właściwość `true`.  
  
 W odróżnieniu od innych zdarzeń, <xref:System.Windows.Application> wywołuje, <xref:System.Windows.Application.DispatcherUnhandledException> jest nie mieć pasujący obiekt typu chronione wirtualnego implementacji (OnDispatcherUnhandledException). W związku z tym, klasy, pochodzić od <xref:System.Windows.Application> zawsze należy zarejestrować program obsługi zdarzeń za pomocą <xref:System.Windows.Application.DispatcherUnhandledException> do przetwarzania nieobsługiwanych wyjątków.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak do przetwarzania nieobsługiwanych wyjątków, obsługa <xref:System.Windows.Application.DispatcherUnhandledException> zdarzeń.  
  
 [!code-csharp[handling-unhandled-exceptions](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs)]
 [!code-vb[handling-unhandled-exceptions](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public event System.Windows.ExitEventHandler Exit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.ExitEventHandler Exit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exit As ExitEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::ExitEventHandler ^ Exit;" />
      <MemberSignature Language="F#" Value="member this.Exit : System.Windows.ExitEventHandler " Usage="member this.Exit : System.Windows.ExitEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ExitEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje zaraz przed aplikacja zostaje wyłączony i nie można anulować.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikację można zamknąć dla jednej z następujących powodów:  
  
-   <xref:System.Windows.Application.Shutdown%2A> Metody <xref:System.Windows.Application> obiektu jest wywołana, jawnie lub określone przez <xref:System.Windows.Application.ShutdownMode%2A> właściwości.  
  
-   Użytkownik kończy sesję przez wylogowanie lub zamykania.  
  
 Można wykryć przy zamykaniu aplikacji obsługi <xref:System.Windows.Application.Exit> zdarzenia i wykonywać żadnych dodatkowych czynności, zgodnie z potrzebami.  
  
 Może również obsługiwać <xref:System.Windows.Application.Exit> sprawdzić lub zmienić kod zakończenia aplikacji, jeśli nie potrzebujesz wywołać <xref:System.Windows.Application.Shutdown%2A> jawnie. Kod zakończenia jest uwidaczniany z <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> właściwość <xref:System.Windows.ExitEventArgs> argument, który jest przekazywany do <xref:System.Windows.Application.Exit> programu obsługi zdarzeń. Gdy aplikacja przestanie działać, kod zakończenia jest przekazywany do systemu operacyjnego do dalszego przetwarzania.  
  
 Jeśli aplikacja obsługuje <xref:System.Windows.Application.SessionEnding> zdarzeń i później go anuluje, <xref:System.Windows.Application.Exit> nie jest inicjowane i aplikacja będzie nadal działać zgodnie z trybem zamknięcia.  
  
 Kod zakończenia można ustawić w [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)], mimo że wartość jest ignorowana.  
  
 Aby uzyskać [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)], <xref:System.Windows.Application.Exit> jest zgłaszany w następujących okolicznościach:  
  
-   [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] Jest opuszczeniu.  
  
-   W [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)], gdy karta, która jest hostem [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] jest zamknięty.  
  
-   Po zamknięciu przeglądarki.  
  
 We wszystkich przypadkach wartość <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> właściwość jest ignorowana.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak:  
  
-   Obsługa <xref:System.Windows.Application.Exit> zdarzeń.  
  
-   Sprawdzanie i zaktualizuj <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> właściwość <xref:System.Windows.ExitEventArgs>.  
  
-   Zapisywanie wpis w rejestrze aplikacji w magazynie izolowanym.  
  
-   Utrwalanie stanu aplikacji do wydzielonej pamięci masowej.  
  
 [!code-xaml[ApplicationExitSnippets#HandleExitXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml#handleexitxaml)]  
  
 [!code-csharp[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml.cs#handleexitcodebehind)]
 [!code-vb[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationExitSnippets/visualbasic/application.xaml.vb#handleexitcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
        <altmember cref="T:System.IO.IsolatedStorage.IsolatedStorage" />
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="application.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Nazwa zasobu, aby znaleźć.</param>
        <summary>Wyszukuje [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] zasobów, takich jak <see cref="T:System.Windows.Style" /> lub <see cref="T:System.Windows.Media.Brush" />z określonym kluczem i zgłasza wyjątek, jeśli nie odnaleziono żądanego zasobu (zobacz [zasoby XAML](~/docs/framework/wpf/advanced/xaml-resources.md)).</summary>
        <returns>Obiekt żądanego zasobu. Jeśli żądany zasób nie zostanie znaleziony, <see cref="T:System.Windows.ResourceReferenceKeyNotFoundException" /> zgłaszany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.FindResource%2A> najpierw sprawdza się w zakresie aplikacji zasobów dla określonego zasobu. Zasobów zakresu aplikacji są zarządzane przez <xref:System.Windows.Application>i są uwidaczniane z <xref:System.Windows.Application.Resources%2A> właściwości. Jeśli określony zasób nie zostanie znaleziony w zestawie zasobów zakresu aplikacji <xref:System.Windows.Application.FindResource%2A> następnie wyszukuje zasobów systemowych. Zasoby systemu są shell zasoby zdefiniowane przez użytkownika i obejmują kolory, czcionki i konfiguracje powłoki. Są one udostępniane z <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, i <xref:System.Windows.SystemParameters> typy odpowiednio właściwości statyczne. Aby użyć <xref:System.Windows.Application.FindResource%2A> je pozyskać te typy również ujawnić właściwości klucza zasobów, które są przeznaczone do przekazania do <xref:System.Windows.Application.FindResource%2A>, na przykład <xref:System.Windows.SystemParameters.IconWidthKey%2A>.  
  
 Ponieważ <xref:System.Windows.Application.FindResource%2A> zwraca obiekt, należy rzutować zwrócona wartość w odpowiednim typem, jeśli zasób zostanie znaleziony.  
  
> [!IMPORTANT]
>  Jeśli chcesz wywołać tę metodę dla klucza, którego nie można odnaleźć jest zgłaszany wyjątek. Jeśli nie chcesz obsługiwać wyjątki, które wynikają z wywołaniem <xref:System.Windows.Application.FindResource%2A>, wywołaj <xref:System.Windows.Application.TryFindResource%2A> zamiast; <xref:System.Windows.Application.TryFindResource%2A> zwraca `null` odwoływać się do żądanego zasobu nie można odnaleźć, gdy nie zgłasza wyjątku.  
  
 Ta metoda jest bezpieczny dla wątków i może zostać wywołana z żadnym z wątków.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Windows.Application.FindResource%2A> można znaleźć zasobu, a także do obsługi <xref:System.Windows.ResourceReferenceKeyNotFoundException> Jeśli zasób nie zostanie znaleziony.  
  
 [!code-csharp[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcallfindresourcecodebehind)]
 [!code-vb[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcallfindresourcecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">Nie można odnaleźć zasobu.</exception>
        <altmember cref="M:System.Windows.Application.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Event FragmentNavigation As FragmentNavigationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberSignature Language="F#" Value="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " Usage="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy Nawigatora w aplikacji rozpoczęciu nawigacji do fragmentu zawartości nawigacji następuje natychmiast po żądanego fragmentu w bieżącej zawartości lub po źródła [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] zawartości został załadowany, jeśli żądany fragment znajduje się w różnych zawartość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nawigator jest <xref:System.Windows.Navigation.NavigationWindow> lub <xref:System.Windows.Controls.Frame>.  
  
 Zobacz <xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetContentStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetContentStream (Uri uriContent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetContentStream(class System.Uri uriContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetContentStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetContentStream (uriContent As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetContentStream(Uri ^ uriContent);" />
      <MemberSignature Language="F#" Value="static member GetContentStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetContentStream uriContent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriContent" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriContent">Względny <see cref="T:System.Uri" /> mapuje luźne zasobów.</param>
        <summary>Zwraca strumień zasobów dla pliku danych zawartości, który znajduje się w określonym <see cref="T:System.Uri" /> (zobacz [zasoby aplikacji WPF, zawartość i pliki danych](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).</summary>
        <returns>A <see cref="T:System.Windows.Resources.StreamResourceInfo" /> zawierający plik zawartości danych, który znajduje się w określonym <see cref="T:System.Uri" />. Jeśli nie będzie zasobów nie zostanie znaleziony, zostanie zwrócona wartość null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest bezpieczny dla wątków.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Uri" /> Przekazana do <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Uri" /> Przekazana do <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> jest ścieżką bezwzględną <see cref="T:System.Uri" />.</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetCookie">
      <MemberSignature Language="C#" Value="public static string GetCookie (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCookie(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetCookie(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCookie(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="static member GetCookie : Uri -&gt; string" Usage="System.Windows.Application.GetCookie uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri"><see cref="T:System.Uri" /> , Który określa lokalizację, dla którego utworzono plik cookie.</param>
        <summary>Pobiera plik cookie dla lokalizacji określonej przez <see cref="T:System.Uri" />.</summary>
        <returns>A <see cref="T:System.String" /> wartość, jeśli istnieje plik cookie; w przeciwnym razie <see cref="T:System.ComponentModel.Win32Exception" /> zgłaszany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.GetCookie%2A> pobiera plik cookie w określonym <xref:System.Uri>. Jeśli nie można pobrać pliku cookie, <xref:System.ComponentModel.Win32Exception> zgłaszany. Należy napisać kod, aby przeanalizować ciąg w pliku cookie na listę par nazwa/wartość.  
  
 Aby uzyskać przegląd plików cookie w [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)], zobacz [Nawigacja — omówienie](~/docs/framework/wpf/app-development/navigation-overview.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">A [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] błąd jest zgłaszany przez <see langword="InternetGetCookie" /> funkcji (wywołana przez <see cref="M:System.Windows.Application.GetCookie(System.Uri)" />) Jeśli wystąpi problem podczas próby pobrania określonego pliku cookie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania pliku cookie na podstawie pliku <see cref="T:System.Uri" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">w celu uzyskania plików cookie dla pliku nieopartych <see cref="T:System.Uri" />. Wyliczenie skojarzone: <see cref="P:System.Net.WebPermission.ConnectList" /></permission>
        <altmember cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRemoteStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetRemoteStream (Uri uriRemote);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetRemoteStream(class System.Uri uriRemote) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRemoteStream (uriRemote As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetRemoteStream(Uri ^ uriRemote);" />
      <MemberSignature Language="F#" Value="static member GetRemoteStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetRemoteStream uriRemote" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriRemote" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriRemote"><see cref="T:System.Uri" /> Mapuje luźne zasobów w miejscu pochodzenia.</param>
        <summary>Zwraca strumień zasobów dla pliku witryny pochodzenia danych, który znajduje się w określonym <see cref="T:System.Uri" /> (zobacz [zasoby aplikacji WPF, zawartość i pliki danych](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).</summary>
        <returns>A <see cref="T:System.Windows.Resources.StreamResourceInfo" /> zawierający strumień zasobów dla pliku witryny pochodzenia danych, który znajduje się w określonym <see cref="T:System.Uri" />. Jeśli nie można odnaleźć zasobu luźne, <see langword="null" /> jest zwracana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest bezpieczny dla wątków.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Uri" /> Przekazana do <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Uri" /> Przekazana do <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> albo nie względną lub bezwzględną, ale nie <c>pack://siteoforigin :,,,/</c> formularza.</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetResourceStream (Uri uriResource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetResourceStream(class System.Uri uriResource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetResourceStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetResourceStream (uriResource As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetResourceStream(Uri ^ uriResource);" />
      <MemberSignature Language="F#" Value="static member GetResourceStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetResourceStream uriResource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriResource" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriResource"><see cref="T:System.Uri" /> Mapujący osadzonego zasobu.</param>
        <summary>Zwraca strumień zasobów dla pliku danych zasobów, który jest umieszczony pod określonym <see cref="T:System.Uri" /> (zobacz [zasoby aplikacji WPF, zawartość i pliki danych](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).</summary>
        <returns>A <see cref="T:System.Windows.Resources.StreamResourceInfo" /> zawierający strumień zasobów dla pliku danych zasobów, który jest umieszczony pod określonym <see cref="T:System.Uri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest bezpieczny dla wątków.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Uri" /> Przekazana do <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Uri" /> Przekazana do <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> albo nie względną lub bezwzględną, ale nie <c>pack://application :,,,/</c> formularza.</exception>
        <exception cref="T:System.IO.IOException"><see cref="T:System.Uri" /> Przekazana do <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> nie można odnaleźć.</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zawartość, która została przejście przez nawigatora w aplikacji został załadowany, analizowane, a rozpoczął renderowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nawigator jest <xref:System.Windows.Navigation.NavigationWindow> lub <xref:System.Windows.Controls.Frame>.  
  
 Zobacz <xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Nasłuchiwanie zdarzeń, które nawigować zawartości, takich jak <xref:System.Windows.FrameworkElement.Loaded> zdarzenie na <xref:System.Windows.Controls.Page> przed dostępu właściwości treści nawigować.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadComponent">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ładunki [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] pliku, który znajduje się w określonym [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] Plik może być plik kodu aplikacji (skonfigurowany jako [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] elementu strony) lub pliku danych aplikacji (pliku zasobów, plik zawartości lub witryny pochodzenia pliku; zobacz [zasoby aplikacji WPF, zawartość i pliki danych](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  Ta metoda nie jest metodą o bezpiecznych wątkach.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static object LoadComponent (Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object LoadComponent(class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadComponent (resourceLocator As Uri) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ LoadComponent(Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : Uri -&gt; obj" Usage="System.Windows.Application.LoadComponent resourceLocator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="resourceLocator">A <see cref="T:System.Uri" /> mapuje względna [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] pliku.</param>
        <summary>Ładunki [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] pliku, który znajduje się w określonym [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]i konwertuje ją na wystąpienie obiektu, który jest określony przez element główny [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] pliku.</summary>
        <returns>Wystąpienie elementu głównego, określone przez plik XAML załadowane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy jawnie przekonwertować wartość zwracana w taki sam jak element główny [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] pliku.  
  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] Plik może być plik kodu aplikacji (skonfigurowany jako [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] elementu strony) lub pliku danych aplikacji (pliku zasobów, plik zawartości lub witryny pochodzenia pliku; zobacz [zasoby aplikacji WPF, zawartość i pliki danych](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  Ta metoda nie jest metodą o bezpiecznych wątkach.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceLocator" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="resourceLocator" /> Jest ścieżką bezwzględną [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.Exception">Plik nie jest [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] pliku.</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static void LoadComponent (object component, Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LoadComponent(object component, class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Object,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LoadComponent (component As Object, resourceLocator As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LoadComponent(System::Object ^ component, Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : obj * Uri -&gt; unit" Usage="System.Windows.Application.LoadComponent (component, resourceLocator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="component">Obiekt tego samego typu co element główny [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] pliku.</param>
        <param name="resourceLocator">A <see cref="T:System.Uri" /> mapuje względna [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] pliku.</param>
        <summary>Ładunki [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] pliku, który znajduje się w określonym [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] i konwertuje ją na wystąpienie obiektu, który jest określony przez element główny [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] Plik może być plik kodu aplikacji (skonfigurowany jako [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] elementu strony) lub pliku danych aplikacji (pliku zasobów, plik zawartości lub witryny pochodzenia pliku; zobacz [zasoby aplikacji WPF, zawartość i pliki danych](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  Ta metoda nie jest metodą o bezpiecznych wątkach.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceLocator" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="resourceLocator" /> Jest ścieżką bezwzględną [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.Exception"><paramref name="component" /> Typ, który nie jest zgodny z elementem głównym jest [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] pliku.</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="MainWindow">
      <MemberSignature Language="C#" Value="public System.Windows.Window MainWindow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window MainWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.MainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Property MainWindow As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ MainWindow { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MainWindow : System.Windows.Window with get, set" Usage="System.Windows.Application.MainWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia głównego okna aplikacji.</summary>
        <value>A <see cref="T:System.Windows.Window" /> , wyznaczony jako okna głównego aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.MainWindow%2A> zostanie automatycznie ustawiony z odwołaniem do pierwszego <xref:System.Windows.Window> obiekt do użycia w <xref:System.AppDomain>.  
  
 Można określić różne okno główne, ustawiając <xref:System.Windows.Application.MainWindow%2A> przypisywanie innego <xref:System.Windows.Application.Windows%2A> obiekt <xref:System.Windows.Application.MainWindow%2A> właściwości.  
  
 Jeśli <xref:System.Windows.Application.ShutdownMode%2A> właściwość <xref:System.Windows.Application> obiekt jest ustawiony na <xref:System.Windows.ShutdownMode.OnMainWindowClose>, zamknięcie okna głównego powoduje, że aplikacja jest zamykana.  
  
 Istnieje możliwość ustawić <xref:System.Windows.Application.MainWindow%2A> właściwość [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)], gdy okno główne aplikacji nie jest okna, które są generowane przez ustawienie <xref:System.Windows.Application.StartupUri%2A> właściwość [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]. Dwa ograniczenia [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] podejścia są:  
  
-   Można określić [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]— tylko <xref:System.Windows.Window> lub [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]— tylko <xref:System.Windows.Navigation.NavigationWindow> jako głównego okna.  
  
-   Należy ustawić <xref:System.Windows.UIElement.Visibility%2A> określić właściwości okna, w przeciwnym razie nie będą wyświetlane.  
  
 Odwołanie do pierwszego <xref:System.Windows.Window> można utworzyć wystąpienia obiektu również jest dodawany jako pierwszy element do <xref:System.Windows.Application.Windows%2A> kolekcji. Jeśli <xref:System.Windows.Application.MainWindow%2A> zostanie ustawiony z odwołaniem do innego <xref:System.Windows.Window>, podczas kolejność elementów w pozycji elementu z odwołaniem do głównego okna zmieni <xref:System.Windows.Application.Windows%2A> pozostają bez zmian. W związku z tym, należy zawsze używać <xref:System.Windows.Application.MainWindow%2A> do odwoływania się do okna głównego zamiast pierwszy element <xref:System.Windows.Application.Windows%2A>.  
  
> [!NOTE]
>  Jeśli okno główne jest <xref:System.Windows.Navigation.NavigationWindow>, i potrzebny określonych dostęp do <xref:System.Windows.Navigation.NavigationWindow> członków, należy rzutować wartość <xref:System.Windows.Application.MainWindow%2A> do <xref:System.Windows.Navigation.NavigationWindow>.  
>   
>  Ta właściwość jest dostępna tylko z wątek, który utworzył <xref:System.Windows.Application> obiektu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak można znaleźć okna głównego aplikacji.  
  
 [!code-csharp[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationMainWindowSnippets/CSharp/App.xaml.cs#getapplicationmainwindowcode)]
 [!code-vb[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationMainWindowSnippets/visualbasic/application.xaml.vb#getapplicationmainwindowcode)]  
  
 Poniższy przykład pokazuje, jak ustawić <xref:System.Windows.Application.MainWindow%2A> przy użyciu [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)].  
  
 [!code-xaml[ApplicationMainWindowSnippets#SetApplicationMainWindowXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/ApplicationMainWindowSnippets/XAML/App.xaml#setapplicationmainwindowxaml)]  
  
 Poniższy przykład pokazuje, jak utworzyć wystąpienie <xref:System.Windows.Application.MainWindow%2A> w kodzie podczas uruchamiania aplikacji.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/App.xaml.cs#firstwindowusingcodecodebehind)]
 [!code-vb[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/application.xaml.vb#firstwindowusingcodecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Application.MainWindow" /> ustawiono z aplikacji, która jest hostowana w przeglądarce, takie jak [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].</exception>
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po znalezieniu zawartości, która jest trwa przejście przez nawigatora w aplikacji, mimo że nie może zakończyć się ładowanie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nawigator jest <xref:System.Windows.Navigation.NavigationWindow> lub <xref:System.Windows.Controls.Frame>.  
  
 Zobacz <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy nowa Nawigacja jest wymagany przez nawigatora w aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nawigator jest <xref:System.Windows.Navigation.NavigationWindow> lub <xref:System.Windows.Controls.Frame>.  
  
 Zobacz <xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberSignature Language="F#" Value="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " Usage="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wystąpi błąd, podczas gdy Nawigatora w aplikacji jest nawigowania do żądanej zawartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nawigator jest <xref:System.Windows.Navigation.NavigationWindow> lub <xref:System.Windows.Controls.Frame>.  
  
 Zobacz <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationProgress As NavigationProgressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberSignature Language="F#" Value="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " Usage="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje okresowo podczas pobierania, który jest zarządzany przez nawigatora w aplikacji, aby podać informacje o postępie nawigacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nawigator jest <xref:System.Windows.Navigation.NavigationWindow> lub <xref:System.Windows.Controls.Frame>.  
  
 Zobacz <xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationStopped As NavigationStoppedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberSignature Language="F#" Value="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " Usage="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see langword="StopLoading" /> zostanie wywołana metoda Nawigatora w aplikacji lub gdy nowa Nawigacja zażądał Nawigatora w trakcie bieżącego nawigacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nawigator jest <xref:System.Windows.Navigation.NavigationWindow> lub <xref:System.Windows.Controls.Frame>.  
  
 Zobacz <xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="application.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Application.Activated" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnActivated%2A> wywołuje <xref:System.Windows.Application.Activated> zdarzeń.  
  
 Typ, który pochodzi od klasy <xref:System.Windows.Application> mogą zastępować <xref:System.Windows.Application.OnActivated%2A>. Zastąpione metody należy wywołać <xref:System.Windows.Application.OnActivated%2A> w klasie bazowej Jeśli <xref:System.Windows.Application.Activated> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="application.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Application.Deactivated" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnDeactivated%2A> wywołuje <xref:System.Windows.Application.Deactivated> zdarzeń.  
  
 Typ, który pochodzi od klasy <xref:System.Windows.Application> mogą zastępować <xref:System.Windows.Application.OnDeactivated%2A>. Zastąpione metody należy wywołać <xref:System.Windows.Application.OnDeactivated%2A> w klasie bazowej Jeśli <xref:System.Windows.Application.Deactivated> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnExit">
      <MemberSignature Language="C#" Value="protected virtual void OnExit (System.Windows.ExitEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnExit(class System.Windows.ExitEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnExit (e As ExitEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnExit(System::Windows::ExitEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnExit : System.Windows.ExitEventArgs -&gt; unit&#xA;override this.OnExit : System.Windows.ExitEventArgs -&gt; unit" Usage="application.OnExit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.ExitEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.ExitEventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Application.Exit" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnExit%2A> wywołuje <xref:System.Windows.Application.Exit> zdarzeń.  
  
 Typ, który pochodzi od klasy <xref:System.Windows.Application> mogą zastępować <xref:System.Windows.Application.OnExit%2A> metody. Zastąpione metody należy wywołać <xref:System.Windows.Application.OnExit%2A> w klasie bazowej Jeśli <xref:System.Windows.Application.Exit> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFragmentNavigation">
      <MemberSignature Language="C#" Value="protected virtual void OnFragmentNavigation (System.Windows.Navigation.FragmentNavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFragmentNavigation(class System.Windows.Navigation.FragmentNavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFragmentNavigation (e As FragmentNavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFragmentNavigation(System::Windows::Navigation::FragmentNavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit&#xA;override this.OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit" Usage="application.OnFragmentNavigation e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.FragmentNavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Element <see cref="T:System.Windows.Navigation.FragmentNavigationEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Application.FragmentNavigation" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnFragmentNavigation%2A> wywołuje <xref:System.Windows.Application.FragmentNavigation> zdarzeń.  
  
 Typ, który pochodzi od klasy <xref:System.Windows.Application> mogą zastępować <xref:System.Windows.Application.OnFragmentNavigation%2A>. Zastąpione metody należy wywołać <xref:System.Windows.Application.OnFragmentNavigation%2A> w klasie bazowej Jeśli <xref:System.Windows.Application.FragmentNavigation> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnLoadCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadCompleted (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadCompleted(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoadCompleted (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoadCompleted(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnLoadCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Element <see cref="T:System.Windows.Navigation.NavigationEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Application.LoadCompleted" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnLoadCompleted%2A> wywołuje <xref:System.Windows.Application.LoadCompleted> zdarzeń.  
  
 Typ, który pochodzi od klasy <xref:System.Windows.Application> mogą zastępować <xref:System.Windows.Application.OnLoadCompleted%2A>. Zastąpione metody należy wywołać <xref:System.Windows.Application.OnLoadCompleted%2A> w klasie bazowej Jeśli <xref:System.Windows.Application.LoadCompleted> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigated">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigated (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigated(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigated (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigated(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Element <see cref="T:System.Windows.Navigation.NavigationEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Application.Navigated" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigated%2A> wywołuje <xref:System.Windows.Application.Navigated> zdarzeń.  
  
 Typ, który pochodzi od klasy <xref:System.Windows.Application> mogą zastępować <xref:System.Windows.Application.OnNavigated%2A>. Zastąpione metody należy wywołać <xref:System.Windows.Application.OnNavigated%2A> w klasie bazowej Jeśli <xref:System.Windows.Application.Navigated> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigating">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigating (System.Windows.Navigation.NavigatingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigating(class System.Windows.Navigation.NavigatingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigating (e As NavigatingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigating(System::Windows::Navigation::NavigatingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit&#xA;override this.OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit" Usage="application.OnNavigating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigatingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Element <see cref="T:System.Windows.Navigation.NavigatingCancelEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Application.Navigating" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigating%2A> wywołuje <xref:System.Windows.Application.Navigating> zdarzeń.  
  
 Typ, który pochodzi od klasy <xref:System.Windows.Application> mogą zastępować <xref:System.Windows.Application.OnNavigating%2A>. Zastąpione metody należy wywołać <xref:System.Windows.Application.OnNavigating%2A> w klasie bazowej Jeśli <xref:System.Windows.Application.Navigating> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationFailed">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationFailed (System.Windows.Navigation.NavigationFailedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationFailed(class System.Windows.Navigation.NavigationFailedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationFailed (e As NavigationFailedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationFailed(System::Windows::Navigation::NavigationFailedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit&#xA;override this.OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit" Usage="application.OnNavigationFailed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationFailedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Element <see cref="T:System.Windows.Navigation.NavigationFailedEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Application.NavigationFailed" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationFailed%2A> wywołuje <xref:System.Windows.Application.NavigationFailed> zdarzeń.  
  
 Typ, który pochodzi od klasy <xref:System.Windows.Application> mogą zastępować <xref:System.Windows.Application.OnNavigationFailed%2A>. Zastąpione metody należy wywołać <xref:System.Windows.Application.OnNavigationFailed%2A> w klasie bazowej Jeśli <xref:System.Windows.Application.NavigationFailed> musi zostać wywołane.  
  
   
  
## Examples  
 <xref:System.Windows.Application.OnFragmentNavigation%2A>  
  
 <xref:System.Windows.Application.OnLoadCompleted%2A>  
  
 <xref:System.Windows.Application.OnNavigating%2A>  
  
 <xref:System.Windows.Application.OnNavigated%2A>  
  
 <xref:System.Windows.Application.OnNavigationProgress%2A>  
  
 <xref:System.Windows.Application.OnNavigationStopped%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNavigationProgress">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationProgress (System.Windows.Navigation.NavigationProgressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationProgress(class System.Windows.Navigation.NavigationProgressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationProgress (e As NavigationProgressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationProgress(System::Windows::Navigation::NavigationProgressEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit&#xA;override this.OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit" Usage="application.OnNavigationProgress e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationProgressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Element <see cref="T:System.Windows.Navigation.NavigationProgressEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Application.NavigationProgress" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationProgress%2A> wywołuje <xref:System.Windows.Application.NavigationProgress> zdarzeń.  
  
 Typ, który pochodzi od klasy <xref:System.Windows.Application> mogą zastępować <xref:System.Windows.Application.OnNavigationProgress%2A>. Przeciążonej należy jawnie wywołać <xref:System.Windows.Application.OnNavigationProgress%2A> w klasie bazowej Jeśli <xref:System.Windows.Application.NavigationProgress> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationStopped">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationStopped (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationStopped(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationStopped (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationStopped(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigationStopped e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Element <see cref="T:System.Windows.Navigation.NavigationEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Application.NavigationStopped" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationStopped%2A> wywołuje <xref:System.Windows.Application.NavigationStopped> zdarzeń.  
  
 Typ, który pochodzi od klasy <xref:System.Windows.Application> mogą zastępować <xref:System.Windows.Application.OnNavigationStopped%2A>. Zastąpione metody należy wywołać <xref:System.Windows.Application.OnNavigationStopped%2A> w klasie bazowej Jeśli <xref:System.Windows.Application.NavigationStopped> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionEnding">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionEnding (System.Windows.SessionEndingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionEnding(class System.Windows.SessionEndingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionEnding (e As SessionEndingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionEnding(System::Windows::SessionEndingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit&#xA;override this.OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit" Usage="application.OnSessionEnding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.SessionEndingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Element <see cref="T:System.Windows.SessionEndingCancelEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Application.SessionEnding" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnSessionEnding%2A> wywołuje <xref:System.Windows.Application.SessionEnding> zdarzeń.  
  
 Typ, który pochodzi od klasy <xref:System.Windows.Application> mogą zastępować <xref:System.Windows.Application.OnSessionEnding%2A>. Zastąpione metody należy wywołać <xref:System.Windows.Application.OnSessionEnding%2A> w klasie bazowej Jeśli <xref:System.Windows.Application.SessionEnding> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStartup">
      <MemberSignature Language="C#" Value="protected virtual void OnStartup (System.Windows.StartupEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStartup(class System.Windows.StartupEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStartup (e As StartupEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStartup(System::Windows::StartupEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStartup : System.Windows.StartupEventArgs -&gt; unit&#xA;override this.OnStartup : System.Windows.StartupEventArgs -&gt; unit" Usage="application.OnStartup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.StartupEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Element <see cref="T:System.Windows.StartupEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Application.Startup" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnStartup%2A> wywołuje <xref:System.Windows.Application.Startup> zdarzeń.  
  
 Typ, który pochodzi od klasy <xref:System.Windows.Application> mogą zastępować <xref:System.Windows.Application.OnStartup%2A>. Zastąpione metody należy wywołać <xref:System.Windows.Application.OnStartup%2A> w klasie bazowej Jeśli <xref:System.Windows.Application.Startup> zdarzenia musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Properties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Properties { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Collections.IDictionary" Usage="System.Windows.Application.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję właściwości zakresu aplikacji.</summary>
        <value><see cref="T:System.Collections.IDictionary" /> Zawierający właściwości zakresu aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> udostępnia słownik za pośrednictwem <xref:System.Windows.Application.Properties%2A> używane do przechowywania właściwości zakresu aplikacji. Pozwala na udostępnianie stanu między całego kodu w <xref:System.AppDomain> w sposób wątkowo, bez konieczności pisania kodu stanu.  
  
 Właściwości przechowywanych we właściwości <xref:System.Windows.Application.Properties%2A> muszą zostać skonwertowane do odpowiedniego typu, które są zwracane.  
  
 <xref:System.Windows.Application.Properties%2A> Właściwość jest bezpieczny dla wątków i jest dostępny w żadnym z wątków.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć i używać właściwości zakresu aplikacji przy użyciu <xref:System.Windows.Application.Properties%2A>.  
  
 [!code-xaml[ApplicationPropertiesSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml1)]  
[!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml2)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml.cs#mainwindowgetpropertycodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/mainwindow.xaml.vb#mainwindowgetpropertycodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="ResourceAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ResourceAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Assembly ResourceAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ResourceAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ResourceAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Assembly ^ ResourceAssembly { System::Reflection::Assembly ^ get(); void set(System::Reflection::Assembly ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResourceAssembly : System.Reflection.Assembly with get, set" Usage="System.Windows.Application.ResourceAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Reflection.Assembly" /> zapewniający pakietowi [!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] dla zasobów w [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] aplikacji.</summary>
        <value>Odwołanie do <see cref="T:System.Reflection.Assembly" /> zapewniający pakietowi [!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] dla zasobów w [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] zasoby są rozwiązywane w czasie wykonywania w odniesieniu do zestawu wpis, który jest identyfikowany przez wartość zwracana z <xref:System.Reflection.Assembly.GetEntryAssembly%2A> metody.  
  
 Zestaw wpis jest zestaw, który jest zwracany przez <xref:System.Reflection.Assembly.GetEntryAssembly%2A> i mogą być następujące:  
  
-   Zestawu pliku wykonywalnego w domyślnej domeny aplikacji.  
  
-   Pierwszy zestawie, który ma być wykonywana przez wywołanie <xref:System.AppDomain.ExecuteAssembly%2A>.  
  
 W następujących przypadkach jednak [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] zestawu nie można pobrać odwołania do zestawu wpis:  
  
-   Niezarządzana aplikacja (natywna) hosty [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] zestawu.  
  
-   Hosty aplikacji zarządzanej [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] zestawu przez załadowanie go do nowej domeny aplikacji innej niż przy użyciu metody <xref:System.AppDomain.ExecuteAssembly%2A>.  
  
 W obu tych przypadkach <xref:System.Reflection.Assembly.GetEntryAssembly%2A> zwraca `null`i [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] zasobów zestawu nie można go rozpoznać. W takich przypadkach <xref:System.Windows.Application.ResourceAssembly%2A> można ustawić, tylko raz, w odniesieniu do zestawu, który powinien być używany do rozpoznania zasobów.  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> można ustawić tylko raz, ponieważ jest mało prawdopodobne, że zestaw zasobów ulegnie zmianie po [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] zestaw jest ładowany.  
  
> [!NOTE]
>  <xref:System.Windows.Application.ResourceAssembly%2A> Nie można ustawić podczas [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] zestawu może odnaleźć wpisu zestawu — to znaczy, gdy <xref:System.Reflection.Assembly.GetEntryAssembly%2A> zwraca odwołanie do zestawu, zamiast `null`.  
  
 Ta właściwość jest bezpieczny dla wątków i jest dostępny w żadnym z wątków.  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> został wprowadzony w .NET Framework w wersji 3.5.  Aby uzyskać więcej informacji, zobacz [wersje i zależności](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] aplikacja ma zestaw wpisu lub <see cref="P:System.Windows.Application.ResourceAssembly" /> została już ustawiona.</exception>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.Application.Resources" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolekcję zasobów zakresu aplikacji, takich jak style i pędzle.</summary>
        <value>A <see cref="T:System.Windows.ResourceDictionary" /> obiekt, który zawiera zero lub więcej zasobów zakresu aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Resources%2A> Właściwość może służyć do udostępniania zasobów w systemach windows i elementy aplikacji. Ponadto <xref:System.Windows.Application.Resources%2A> właściwość znajduje się w ścieżce wyszukiwania zasobów, o ile w następującej kolejności:  
  
1.  Elementy  
  
2.  Windows  
  
3.  <xref:System.Windows.Application.Resources%2A?displayProperty=nameWithType>  
  
4.  System  
  
 W związku z tym [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] elementy można powiązać zasobów zakresu aplikacji. Ponadto w przypadku zmiany zasobów, system zasobów zapewnia tego elementu właściwości, które są powiązane z tych zasobów są automatycznie aktualizowane w celu odzwierciedlenia zmiany.  
  
 Zasobów zakresu aplikacji zapewniają prosty sposób obsługi spójne motywu w aplikacji. Możesz łatwo tworzyć motywu w [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] przy użyciu `Application.Resources` tagu. Jednak jeśli aplikacja obsługuje wielu motywów, które mogą zawierać dużą liczbę elementów motywu, może być łatwiej nimi zarządzać przy użyciu jednej <xref:System.Windows.ResourceDictionary> wystąpienia dla każdej kompozycji. W ten sposób można zastosować nowy motyw, ustawiając właściwość zasobów do odpowiedniego <xref:System.Windows.ResourceDictionary>.  
  
 Istnieją dwie kwestie podczas korzystania z <xref:System.Windows.Application.Resources%2A>. Po pierwsze, słownika *klucza* jest obiektem, więc należy użyć dokładnie tego samego wystąpienia obiektu podczas ustawiania i pobierania wartości właściwości (należy zauważyć, że klucz jest rozróżniana wielkość liter, przy użyciu ciągu). Drugi, słownika *wartość* jest obiektem, więc będzie trzeba przekonwertować wartości na żądany typ podczas pobierania wartości właściwości.  
  
 <xref:System.Windows.Application.Resources%2A> jest bezpieczny dla wątków i jest dostępny w żadnym z wątków.  
  
   
  
## Examples  
Ten przykład ilustruje sposób używania XAML wraz z zasobów zakresu aplikacji do tworzenia spójnego wyglądu. Pierwszy przykład jest z *App.xaml*; drugi z *MainWindow.xaml*. 
  
[!code-xaml[ApplicationResourcesSnippets#ResourcesPropertyXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/App.xaml#resourcespropertyxaml)]  
  
[!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml?highlight=7)]  
  
 Poniższy przykład pokazuje, jak ustawić zasobu aplikacji w kodzie i XAML (w pliku App.xaml w C# projekt WPF lub Application.xaml pliku w projekcie WPF w języku Visual Basic).  
  
 [!code-csharp[Setting-an-application-resource-in-code](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#setapplicationscoperesourcecode)]
 [!code-vb[Setting-an-application-resource-in-code](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#setapplicationscoperesourcecode)]  
  
 [!code-xaml[Setting-an-application-resource-in-XAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/App.xaml?highlight=8-10)]  
  
 Poniższy przykład pokazuje, jak można pobrać zasobu aplikacji w kodzie.  
  
 [!code-csharp[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#getapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#getapplicationscoperesourcecode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uruchamia aplikację Windows Presentation Foundation.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Function Run () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run();" />
      <MemberSignature Language="F#" Value="member this.Run : unit -&gt; int" Usage="application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia aplikację Windows Presentation Foundation.</summary>
        <returns><see cref="T:System.Int32" /> Kod zakończenia aplikacji, które są zwracane do systemu operacyjnego, podczas zamykania aplikacji. Domyślnie wartość kodu zakończenia to 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Run%2A> jest wywoływana, aby uruchomić [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] aplikacji. Jeśli zdefiniujesz swoje <xref:System.Windows.Application> przy użyciu znaczników, lub znaczników i kodu powiązanego <xref:System.Windows.Application.Run%2A> będzie wywoływana niejawnie. Jednakże jeśli zdefiniujesz swoje <xref:System.Windows.Application> przy użyciu kodu, należy jawnie wywołać <xref:System.Windows.Application.Run%2A>.  
  
 Gdy <xref:System.Windows.Application.Run%2A> jest wywoływana, <xref:System.Windows.Application> dołącza nowe <xref:System.Windows.Threading.Dispatcher> wystąpienie do wątku interfejsu użytkownika. Następnie <xref:System.Windows.Threading.Dispatcher> obiektu <xref:System.Windows.Threading.Dispatcher.Run%2A> metoda jest wywoływana, co spowoduje włączenie pompy komunikatów do przetwarzania komunikatów systemu windows. Na koniec <xref:System.Windows.Threading.Dispatcher> obiektu wywołania <xref:System.Windows.Application> obiektu <xref:System.Windows.Application.OnStartup%2A> metodę, aby podnieść <xref:System.Windows.Application.Startup> zdarzeń. W związku z tym, model wykonywania aplikacji zostało ustanowione przez czas obsługi <xref:System.Windows.Application.Startup>, w tym momencie aplikacji jest traktowane jako uruchomione.  
  
 Przerwanie podczas działania aplikacji <xref:System.Windows.Application.Shutdown%2A> nosi nazwę; wartość <xref:System.Windows.Application.ShutdownMode%2A> właściwość określa, kiedy <xref:System.Windows.Application.Shutdown%2A> nosi nazwę i czy odbywa się automatycznie, czy należy jawnie wywołać go.  
  
 <xref:System.Windows.Application.Run%2A> może być wywołana tylko z wątku, który tworzy <xref:System.Windows.Application> obiektu. Ponadto <xref:System.Windows.Application.Run%2A> nie można wywołać z [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)].  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono aplikację, która używa niestandardowego <xref:System.Windows.Application> i w związku z tym należy jawnie wywołać <xref:System.Windows.Application.Run%2A>.  
  
 [!code-csharp[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunSnippets/CSharp/App.cs#customentrypointandruncode)]
 [!code-vb[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunSnippets/visualbasic/app.vb#customentrypointandruncode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Application.Run" /> jest wywoływana z poziomu aplikacji hostowanej w przeglądarce (na przykład [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]).</exception>
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run (System.Windows.Window window);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run(class System.Windows.Window window) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run(System.Windows.Window)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run(System::Windows::Window ^ window);" />
      <MemberSignature Language="F#" Value="member this.Run : System.Windows.Window -&gt; int" Usage="application.Run window" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="window" Type="System.Windows.Window" />
      </Parameters>
      <Docs>
        <param name="window">A <see cref="T:System.Windows.Window" /> , jest otwierany automatycznie podczas uruchamiania aplikacji.</param>
        <summary>Uruchamia aplikację Windows Presentation Foundation i otwiera określone okno.</summary>
        <returns><see cref="T:System.Int32" /> Kod zakończenia aplikacji, które są zwracane do systemu operacyjnego, podczas zamykania aplikacji. Domyślnie wartość kodu zakończenia to 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie rozszerza <xref:System.Windows.Application.Run%2A> metoda otwierania określonego okna, po uruchomieniu aplikacji.  
  
 Po zdefiniowaniu kodu <xref:System.Windows.Application> otwiera okno, kiedy rozpoczyna działanie, należy jawnie wywołać <xref:System.Windows.Application.Run%2A>.  
  
 Jeśli tworzysz swoje <xref:System.Windows.Application> przy użyciu znaczników, lub znaczników i związane z kodem, możesz automatycznie otworzyć okno podczas przy użyciu jednej z następujących technik:  
  
-   Deklaratywne, ustawiając <xref:System.Windows.Application.StartupUri%2A>.  
  
-   Programowo, obsługując <xref:System.Windows.Application.Startup>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano aplikację za pomocą metody punktu ręcznie utworzyć wpis statyczny, który tworzy <xref:System.Windows.Application>, przed wywołaniem <xref:System.Windows.Application.Run%2A>.  
  
 [!code-csharp[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunOL1Snippets/CSharp/App.cs#customentrypointandrunol1code)]
 [!code-vb[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunOL1Snippets/visualbasic/app.vb#customentrypointandrunol1code)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Application.Run" /> jest wywoływana z poziomu aplikacji hostowanej w przeglądarce (na przykład [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]).</exception>
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public event System.Windows.SessionEndingCancelEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SessionEndingCancelEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SessionEnding As SessionEndingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SessionEndingCancelEventHandler ^ SessionEnding;" />
      <MemberSignature Language="F#" Value="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " Usage="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SessionEndingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik kończy sesję Windows wylogowania lub zamykania systemu operacyjnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie aplikacja zostaje wyłączony podczas zakończenia sesji Windows, które występuje, gdy użytkownik wylogowuje się lub kończy pracę. W takim przypadku Windows pyta, czy każdy otwarty aplikacja jest zamykana. Jednak jest możliwe, że aplikacja może nie być gotowy do zamykania w takiej sytuacji. Na przykład aplikacja może mieć danych, który jest w stanie niespójnym lub wykonywania długotrwałych operacji. W takich przypadkach go może być pożądane, aby uniemożliwić zakończenie sesji i może być bardziej pożądane, aby umożliwić użytkownikom możliwość zdecydować, czy zezwolić sesji, aby zakończyć.  
  
 Wykryć, kiedy sesja zostanie zakończona Obsługa <xref:System.Windows.Application.SessionEnding> zdarzeń. Jeśli aplikacja musi uniemożliwić sesji zakończenia, <xref:System.Windows.SessionEndingCancelEventArgs> udostępnia argument, który jest przekazywany do narzędzia obsługi zdarzeń <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> ustawionej dla `true` (wartość domyślna to `false`).  
  
 Jeśli <xref:System.Windows.Application.SessionEnding> jest nieobsługiwany lub odbywa się bez Trwa anulowanie <xref:System.Windows.Application.Shutdown%2A> nosi nazwę i <xref:System.Windows.Application.Exit> zdarzenie jest wywoływane.  
  
 Aby uzyskać więcej informacji na temat przyczyny kończy się sesja, aplikację można sprawdzić <xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>, które jest jednym z <xref:System.Windows.ReasonSessionEnding> wartości (<xref:System.Windows.ReasonSessionEnding.Logoff?displayProperty=nameWithType> i <xref:System.Windows.ReasonSessionEnding.Shutdown?displayProperty=nameWithType>).  
  
 <xref:System.Windows.Application.SessionEnding> nie jest inicjowane przez aplikacje konsolowe.  
  
 <xref:System.Windows.Application.SessionEnding> jest wywoływane tylko w wątku, który tworzy <xref:System.Windows.Application> obiektu.  
  
 <xref:System.Windows.Application.SessionEnding> nie jest inicjowane dla aplikacji przeglądarki XAML (XBAP).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób obsługi <xref:System.Windows.Application.SessionEnding> zdarzeń i umożliwia użytkownikowi anulować.  
  
 [!code-xaml[ApplicationSessionEndingSnippets#HandlingSessionEndingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml#handlingsessionendingxaml)]  
  
 [!code-csharp[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml.cs#handlingsessionendingcodebehind)]
 [!code-vb[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/visualbasic/application.xaml.vb#handlingsessionendingcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public static void SetCookie (Uri uri, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCookie(class System.Uri uri, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCookie(Uri ^ uri, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetCookie : Uri * string -&gt; unit" Usage="System.Windows.Application.SetCookie (uri, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri"><see cref="T:System.Uri" /> , Który określa lokalizację, dla którego można utworzyć pliku cookie.</param>
        <param name="value"><see cref="T:System.String" /> Zawierający dane pliku cookie.</param>
        <summary>Tworzy plik cookie do lokalizacji określonej przez <see cref="T:System.Uri" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plik cookie jest dowolne dane, które mogą być przechowywane przez aplikację na komputerze klienckim podczas sesji aplikacji (pliki cookie z sesji) lub między sesjami aplikacji (trwałe pliki cookie). Oba typy plików cookie można utworzyć przez wywołanie metody <xref:System.Windows.Application.SetCookie%2A>.  
  
 Dane pliku cookie ma zwykle postać pary nazwa/wartość w następującym formacie:  
  
 `Name=Value`  
  
 Ciąg formatu w celu przekazania <xref:System.Windows.Application.SetCookie%2A>, wraz z <xref:System.Uri> lokalizacji, dla którego plik cookie powinna być ustawiona (zazwyczaj domeny aplikacji).  
  
 Czy plik cookie to plik cookie sesji trwały plik cookie zależy od tego, czy plik cookie ciągów, które są przekazywane do <xref:System.Windows.Application.SetCookie%2A> ma datę wygaśnięcia. Ciąg dla pliku cookie sesji nie ma datę wygaśnięcia. Ciąg dla trwały plik cookie ma, a musi być w następującym formacie:  
  
 `NAME=VALUE; expires=DAY, DD-MMM-YYYY HH:MM:SS GMT`  
  
 Trwałe pliki cookie są przechowywane w bieżącym [!INCLUDE[TLA#tla_mswin](~/includes/tlasharptla-mswin-md.md)] katalogu Temporary Internet Files instalacji, dopóki nie wygasną, w którym to przypadku zostaną usunięte. Możesz usunąć trwały plik cookie z aplikacji przez ustawienie daty wygaśnięcia na wartości daty/godziny, który jest w przeszłości.  
  
 Aby uzyskać przegląd plików cookie w [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)], zobacz [Nawigacja — omówienie](~/docs/framework/wpf/app-development/navigation-overview.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">A [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] błąd jest zgłaszany przez <see langword="InternetSetCookie" /> funkcji (wywołana przez <see cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />) Jeśli wystąpi problem podczas próby utworzenia określony plik cookie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania pliku cookie na podstawie pliku <see cref="T:System.Uri" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">w celu uzyskania plików cookie dla pliku nieopartych <see cref="T:System.Uri" />. Wyliczenie skojarzone: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Windows.Application.GetCookie(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Shutdown">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zamyka aplikację.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown();" />
      <MemberSignature Language="F#" Value="member this.Shutdown : unit -&gt; unit" Usage="application.Shutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka aplikację.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.Application.Shutdown%2A> jest wywoływana aplikacja przestaje działać. Może obsługiwać <xref:System.Windows.Application.Exit> zdarzenie, aby wykryć, kiedy aplikacja jest około przestanie działać, wykonywać żadnego przetwarzania odpowiednie.  
  
 <xref:System.Windows.Application.Shutdown%2A> jest wywoływany niejawnie przez Windows Presentation Foundation w następujących sytuacjach:  
  
-   Gdy <xref:System.Windows.Application.ShutdownMode%2A> ustawiono <xref:System.Windows.ShutdownMode.OnLastWindowClose>.  
  
-   Gdy <xref:System.Windows.Application.ShutdownMode%2A> ustawiono <xref:System.Windows.ShutdownMode.OnMainWindowClose>.  
  
-   Gdy użytkownik kończy sesję i <xref:System.Windows.Application.SessionEnding> zdarzeń jest nieobsługiwane albo bez anulowania.  
  
 Wywoływanie <xref:System.Windows.Application.Shutdown%2A> jawnie powoduje, że aplikacja jest zamykana, niezależnie od wartości <xref:System.Windows.Application.ShutdownMode%2A> ustawienie. Jednak jeśli <xref:System.Windows.Application.ShutdownMode%2A> ustawiono <xref:System.Windows.ShutdownMode.OnExplicitShutdown>, należy wywołać <xref:System.Windows.Application.Shutdown%2A> do zamykania aplikacji.  
  
> [!IMPORTANT]
>  Gdy <xref:System.Windows.Application.Shutdown%2A> jest wywoływana, aplikacja zostanie zamknięty niezależnie od tego, czy <xref:System.Windows.Window.Closing> zdarzeń wszelkie otwarte okna zostało anulowane.  
  
 Ta metoda może być wywołana tylko z wątek, który utworzył <xref:System.Windows.Application> obiektu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">uprawnienia do użycia, wszystkich okien i zdarzenia wejściowe użytkownika bez ograniczeń. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
        <altmember cref="M:System.Windows.Application.Run" />
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(int exitCode);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : int -&gt; unit" Usage="application.Shutdown exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">Kod zakończenia liczby całkowitej dla aplikacji. Domyślny kod wyjścia to 0.</param>
        <summary>Zamyka aplikację, która zwraca określony kod zakończenia systemowi operacyjnemu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Może obsługiwać <xref:System.Windows.Application.Exit> zdarzenie, aby ustawić kod zakończenia. Jednak jeśli jawnie wywołać <xref:System.Windows.Application.Shutdown%2A>, i możesz obsłużyć <xref:System.Windows.Application.Exit> tylko można ustawić kod zakończenia, można wywołać <xref:System.Windows.Application.Shutdown%2A> zamiast tego.  
  
 Ta metoda może być wywołana tylko z wątek, który utworzył <xref:System.Windows.Application> obiektu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">uprawnienia do użycia, wszystkich okien i zdarzenia wejściowe użytkownika bez ograniczeń. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="Overload:System.Windows.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownMode">
      <MemberSignature Language="C#" Value="public System.Windows.ShutdownMode ShutdownMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ShutdownMode ShutdownMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ShutdownMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ShutdownMode As ShutdownMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ShutdownMode ShutdownMode { System::Windows::ShutdownMode get(); void set(System::Windows::ShutdownMode value); };" />
      <MemberSignature Language="F#" Value="member this.ShutdownMode : System.Windows.ShutdownMode with get, set" Usage="System.Windows.Application.ShutdownMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ShutdownMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia warunek, który powoduje, że <see cref="M:System.Windows.Application.Shutdown" /> wywoływanej metody.</summary>
        <value>A <see cref="T:System.Windows.ShutdownMode" /> wartość wyliczenia. Wartość domyślna to <see cref="F:System.Windows.ShutdownMode.OnLastWindowClose" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacje zatrzymać tylko wtedy, gdy <xref:System.Windows.Application.Shutdown%2A> zostanie wywołana metoda aplikacji. Zamknij może wystąpić niejawnie lub jawnie określony przez wartość <xref:System.Windows.Application.ShutdownMode%2A> właściwości.  
  
 Jeśli ustawisz <xref:System.Windows.Application.ShutdownMode%2A> do <xref:System.Windows.ShutdownMode.OnLastWindowClose>, wywołuje niejawnie Windows Presentation Foundation (WPF) <xref:System.Windows.Application.Shutdown%2A> po zamknięciu ostatniego okna w aplikacji, nawet wtedy, gdy wszystkie obecnie wystąpień systemu windows są ustawione jako główne okno (zobacz <xref:System.Windows.Application.MainWindow%2A>).  
  
 A <xref:System.Windows.Application.ShutdownMode%2A> z <xref:System.Windows.ShutdownMode.OnMainWindowClose> powoduje, że WPF niejawnie wywołać <xref:System.Windows.Application.Shutdown%2A> podczas <xref:System.Windows.Application.MainWindow%2A> zamykane, nawet jeśli inne okna są obecnie otwarte.  
  
 Okres istnienia niektóre aplikacje nie może być zależny od kiedy okno główne lub ostatnie okno został zamknięty lub może nie być zależny od systemu windows na wszystkich. Dla tych scenariuszy należy ustawić <xref:System.Windows.Application.ShutdownMode%2A> właściwości <xref:System.Windows.ShutdownMode.OnExplicitShutdown>, co wymaga jawnego <xref:System.Windows.Application.Shutdown%2A> wywołania metody, aby zatrzymać aplikację. W przeciwnym razie aplikacja nadal uruchomione w tle.  
  
 <xref:System.Windows.Application.ShutdownMode%2A> można skonfigurować w sposób deklaratywny z [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] lub programowo z kodu.  
  
 Ta właściwość jest dostępna tylko z wątek, który utworzył <xref:System.Windows.Application> obiektu.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób konfigurowania <xref:System.Windows.Application.ShutdownMode%2A> do określenia, czy aplikacji musi być jawnie zamknięty.  
  
 [!code-xaml[ApplicationShutdownModeSnippets#SetShutdownModeXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationShutdownModeSnippets/CS/App.xaml#setshutdownmodexaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Startup">
      <MemberSignature Language="C#" Value="public event System.Windows.StartupEventHandler Startup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.StartupEventHandler Startup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Startup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Startup As StartupEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::StartupEventHandler ^ Startup;" />
      <MemberSignature Language="F#" Value="member this.Startup : System.Windows.StartupEventHandler " Usage="member this.Startup : System.Windows.StartupEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.StartupEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="M:System.Windows.Application.Run" /> metody <see cref="T:System.Windows.Application" /> nosi nazwę obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typowa aplikacja Windows Presentation Foundation może wykonywać różne zadania inicjowania podczas uruchamiania, w tym:  
  
-   Parametry wiersza polecenia przetwarzania.  
  
-   Otwieranie okna głównego.  
  
-   Inicjowanie zasobów zakresu aplikacji.  
  
-   Inicjowanie właściwości zakresu aplikacji.  
  
 Sposób deklaratywny można określić główne okno i zasobów zakresu aplikacji przy użyciu [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] (<xref:System.Windows.Application.StartupUri%2A> i <xref:System.Windows.Application.Resources%2A>odpowiednio). Czasami jednak zasobów lub okna głównego aplikacji można tylko określić programowo w czasie wykonywania. Ponadto właściwości zakresu aplikacji i parametry wiersza polecenia należy używać tylko programowo. Inicjowanie programistyczny może zostać wykonana przez obsługi <xref:System.Windows.Application.Startup> zdarzeń, w tym następujące:  
  
-   Uzyskiwanie i przetwarzania parametrów wiersza polecenia, które są dostępne z <xref:System.Windows.StartupEventArgs.Args%2A> właściwość <xref:System.Windows.StartupEventArgs> klasę, która jest przekazywana do <xref:System.Windows.Application.Startup> programu obsługi zdarzeń.  
  
-   Inicjowanie zasobów zakresu aplikacji za pomocą <xref:System.Windows.Application.Resources%2A> właściwości.  
  
-   Inicjowanie właściwości zakresu aplikacji za pomocą <xref:System.Windows.Application.Properties%2A> właściwości.  
  
-   Utwórz wystąpienie i Pokaż okna (przynajmniej jeden).  
  
> [!NOTE]
>  Parametry wiersza polecenia można również kupić przez wywołanie statycznego <xref:System.Environment.GetCommandLineArgs%2A> metody <xref:System.Environment> obiektu. Jednak <xref:System.Environment.GetCommandLineArgs%2A> wymaga pełnego zaufania do wykonania.  
  
 Jeśli ustawisz <xref:System.Windows.Application.StartupUri%2A> przy użyciu [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)], nie jest dostępny z poziomu głównego okna, który jest tworzony <xref:System.Windows.Application.MainWindow%2A> właściwości lub <xref:System.Windows.Application.Windows%2A> właściwość <xref:System.Windows.Application> obiektu, dopóki nie po <xref:System.Windows.Application.Startup> zdarzeń jest przetwarzany. Jeśli potrzebujesz dostępu do głównego okna podczas uruchamiania, należy ręcznie utworzyć obiekt window z Twojej <xref:System.Windows.Application.Startup> programu obsługi zdarzeń.  
  
> [!NOTE]
>  Jeśli aplikacja używa <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> Aby określić zasady dostępu do poświadczeń, należy ustawić <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> po <xref:System.Windows.Application.Startup> jest podniesione; w przeciwnym razie [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] ustawia ją na wewnętrzne zasady domyślne bezpośrednio po <xref:System.Windows.Application.Startup> spowodował zdarzenie.  
  
 Argumenty wiersza polecenia, które są przekazywane do <xref:System.Windows.Application.Startup> program obsługi zdarzeń nie są takie same, jak [!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)] parametry ciągu, które są przekazywane do zapytania [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)].  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak uzyskać i przetwarzać opcje wiersza polecenia aplikacji autonomicznych. Jeśli **/StartMinimized** podano parametr wiersza polecenia, aplikacja zostanie otwarta w stanie zminimalizowanym głównego okna.  
  
 [!code-xaml[ApplicationStartupSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationStartupSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] Nie można pobrać i przetworzyć argumenty wiersza polecenia, ponieważ ich na rynek z [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)] wdrożenia (zobacz [wdrażanie aplikacji WPF (WPF)](~/docs/framework/wpf/app-development/deploying-a-wpf-application-wpf.md)). Jednakże można pobrać i przetworzyć parametry ciągu zapytania z adresów URL, które są używane do ich uruchamiania.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="StartupUri">
      <MemberSignature Language="C#" Value="public Uri StartupUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri StartupUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.StartupUri" />
      <MemberSignature Language="VB.NET" Value="Public Property StartupUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ StartupUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartupUri : Uri with get, set" Usage="System.Windows.Application.StartupUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia interfejs użytkownika, który jest automatycznie wyświetlana podczas uruchamiania aplikacji.</summary>
        <value>A <see cref="T:System.Uri" /> odwołujący się do interfejsu użytkownika, który jest automatycznie otwierane po uruchomieniu aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Windows.Application.StartupUri%2A> ma automatycznie ładować zasobów interfejsu użytkownika podczas uruchamiania aplikacji.  
  
 W poniższej tabeli przedstawiono typy zasobów interfejsu użytkownika, które mogą zostać załadowane, typie okna są otwarte w i typu aplikacji, które te zasoby można ustawić jako <xref:System.Windows.Application.StartupUri%2A>.  
  
|Typ|Okno|Typ aplikacji|  
|----------|------------|----------------------|  
|<xref:System.Windows.Window>|<xref:System.Windows.Window>|Tylko autonomicznej|  
|<xref:System.Windows.Navigation.NavigationWindow>|<xref:System.Windows.Navigation.NavigationWindow>|Tylko autonomicznej|  
|<xref:System.Windows.Controls.Page>|<xref:System.Windows.Navigation.NavigationWindow>|Autonomiczny /-hostowana w przeglądarce|  
|<xref:System.Windows.Controls.UserControl>|<xref:System.Windows.Navigation.NavigationWindow>|Autonomiczny /-hostowana w przeglądarce|  
|<xref:System.Windows.Documents.FlowDocument>|<xref:System.Windows.Navigation.NavigationWindow>|Autonomiczny /-hostowana w przeglądarce|  
|<xref:System.Windows.Navigation.PageFunction%601>|<xref:System.Windows.Navigation.NavigationWindow>|Autonomiczny /-hostowana w przeglądarce|  
  
 Zwykle ustawiasz <xref:System.Windows.Application.StartupUri%2A> właściwości w sposób deklaratywny [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]. Jednak można ustawić <xref:System.Windows.Application.StartupUri%2A> programowo, takich jak z <xref:System.Windows.Application.Startup> program obsługi zdarzeń, co jest przydatne, jeśli w aplikacji, która może ładować wyłącznie niezbędne zasoby interfejsu użytkownika w czasie wykonywania. Aplikacja może na przykład trzeba odczekać do czasu wykonywania ładowanie jej zasobów, jeśli nazwa zasobu interfejsu użytkownika jest przechowywana w pliku konfiguracji.  
  
 Określa, czy ustawić <xref:System.Windows.Application.StartupUri%2A> deklaratywne lub programowo, odpowiadający jej zasób interfejsu użytkownika nie został załadowany do momentu po <xref:System.Windows.Application.Startup> zdarzenie jest obsługiwane. W związku z tym, nie masz dostępu do okna wynikowe albo <xref:System.Windows.Application.Windows%2A> właściwości lub <xref:System.Windows.Application.MainWindow%2A> właściwości podczas obsługi <xref:System.Windows.Application.Startup>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Windows.Application.StartupUri" /> ustawiono o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nazwa żądanej właściwości otoczenia.</param>
        <summary>Zapytania dotyczące tego, czy określona właściwość otoczenia jest dostępny w bieżącym zakresie.</summary>
        <returns><see langword="true" /> Jeśli żądana właściwość otoczenia jest dostępna; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Application> wystąpienia jest rzutowany na <xref:System.Windows.Markup.IQueryAmbient> interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.IQueryAmbient" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="application.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Nazwa zasobu, aby znaleźć.</param>
        <summary>Wyszukuje określonego zasobu.</summary>
        <returns>Obiekt żądanego zasobu. Jeśli żądany zasób nie zostanie znaleziony, zwracany jest odwołanie o wartości null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.TryFindResource%2A> najpierw sprawdza się w zakresie aplikacji zasobów dla określonego zasobu. Zasobów zakresu aplikacji są zarządzane przez <xref:System.Windows.Application>i są uwidaczniane z <xref:System.Windows.Application.Resources%2A> właściwości. Jeśli określony zasób nie zostanie znaleziony w zestawie zasobów zakresu aplikacji <xref:System.Windows.Application.TryFindResource%2A> następnie wyszukuje zasobów systemowych. Zasoby systemu są shell zasoby zdefiniowane przez użytkownika i obejmują kolory, czcionki i konfiguracje powłoki. Są one udostępniane z <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, i <xref:System.Windows.SystemParameters> typy odpowiednio właściwości statyczne. Aby użyć <xref:System.Windows.Application.TryFindResource%2A> je pozyskać te typy również ujawnić właściwości klucza zasobów, które są przeznaczone do przekazania do <xref:System.Windows.Application.TryFindResource%2A>, na przykład <xref:System.Windows.SystemParameters.IconWidthKey%2A>.  
  
 Ponieważ <xref:System.Windows.Application.TryFindResource%2A> zwraca obiekt, należy rzutować zwrócona wartość w odpowiednim typem, jeśli zasób zostanie znaleziony.  
  
 Ta metoda jest bezpieczny dla wątków i może zostać wywołana z żadnym z wątków.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Windows.Application.TryFindResource%2A> można uzyskać zasobu.  
  
 [!code-xaml[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/App.xaml#applicationcalltryfindresourcexaml)]  
  
 [!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind1)]
 [!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind1)]  
[!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind2)]
[!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Windows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection Windows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection Windows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Windows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Windows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ Windows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Windows : System.Windows.WindowCollection" Usage="System.Windows.Application.Windows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wystąpień systemu windows w aplikacji.</summary>
        <value>A <see cref="T:System.Windows.WindowCollection" /> zawierający odniesienia do wszystkich obiektów okien w bieżącym <see cref="T:System.AppDomain" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Window> odwołanie jest automatycznie dodawany do <xref:System.Windows.Application.Windows%2A> tak szybko, jak okno zostanie uruchomiony na [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] wątku; system windows, które są tworzone przez proces roboczy wątki nie są dodawane. A <xref:System.Windows.Window> odwołanie jest automatycznie usuwany po jego <xref:System.Windows.Window.Closing> zdarzeń został obsłużony i przed jej <xref:System.Windows.Window.Closed> zdarzenie jest wywoływane.  
  
 Domyślnie pierwszy element jest dodawany do <xref:System.Windows.Application.Windows%2A> staje się właściwość <xref:System.Windows.Application.MainWindow%2A>.  
  
 Ta właściwość jest dostępna tylko z wątek, który utworzył <xref:System.Windows.Application> obiektu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wyliczyć <xref:System.Windows.Application.Windows%2A> właściwość, aby utworzyć menu najwyższego poziomu w Windows, który jest wspólny dla [!INCLUDE[TLA#tla_mdi](~/includes/tlasharptla-mdi-md.md)] aplikacje, takie jak [!INCLUDE[TLA#tla_xl](~/includes/tlasharptla-xl-md.md)], lub wieloma wystąpieniami interfejs dokumentu pojedynczego (SDI) aplikacje, takie jak [!INCLUDE[TLA#tla_word](~/includes/tlasharptla-word-md.md)].  
  
 [!code-csharp[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/WindowMenuItem.cs#windowmenuitemcode)]
 [!code-vb[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/windowmenuitem.vb#windowmenuitemcode)]  
  
 [!code-xaml[ApplicationWindowsSnippets#MainWindowSetWindowsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml#mainwindowsetwindowsxaml)]  
  
 [!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind1)]
 [!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind1)]  
[!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind2)]
[!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Window" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="Application" FullName="System.Windows.Application">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8e75a480723246236f66eb8b31a4594cd0c132e8" /><Meta Name="ms.sourcegitcommit" Value="74239f3977d28923e5020663db2c4e91601bea79" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/24/2019" /><Meta Name="ms.locfileid" Value="68439819" /></Metadata><TypeSignature Language="C#" Value="public class Application : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Application extends System.Windows.Threading.DispatcherObject implements class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Application" />
  <TypeSignature Language="VB.NET" Value="Public Class Application&#xA;Inherits DispatcherObject&#xA;Implements IQueryAmbient" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application : System::Windows::Threading::DispatcherObject, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type Application = class&#xA;    inherit DispatcherObject&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Hermetyzuje Windows Presentation Foundation aplikacji.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application>jest klasą, która hermetyzuje [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] funkcje specyficzne dla aplikacji, w tym następujące:  
  
-   **Okres**istnienia <xref:System.Windows.Application.Activated>aplikacji <xref:System.Windows.Application.Current%2A>: <xref:System.Windows.Application.Deactivated> <xref:System.Windows.Application.DispatcherUnhandledException> ,<xref:System.Windows.Application.Run%2A>,,,, ,<xref:System.Windows.Application.Shutdown%2A>,,, .<xref:System.Windows.Application.Startup> <xref:System.Windows.Application.Exit> <xref:System.Windows.Application.SessionEnding> <xref:System.Windows.Application.ShutdownMode%2A>  
  
-   **Zarządzanie oknem zakresu aplikacji, właściwością i zasobami** <xref:System.Windows.Application.FindResource%2A>: <xref:System.Windows.Application.MainWindow%2A>, <xref:System.Windows.Application.GetContentStream%2A>, <xref:System.Windows.Application.Properties%2A> <xref:System.Windows.Application.LoadComponent%2A> <xref:System.Windows.Application.GetResourceStream%2A> <xref:System.Windows.Application.Resources%2A> <xref:System.Windows.Application.Windows%2A>,,,,, ,.<xref:System.Windows.Application.StartupUri%2A>  
  
-   **Parametry wiersza polecenia i przetwarzanie kodu zakończenia**: <xref:System.Windows.Application.Startup?displayProperty=nameWithType>, <xref:System.Windows.Application.Exit?displayProperty=nameWithType>, <xref:System.Windows.Application.Shutdown%2A?displayProperty=nameWithType>.  
  
-   **Nawigacja**: <xref:System.Windows.Application.FragmentNavigation> <xref:System.Windows.Application.LoadCompleted> ,<xref:System.Windows.Application.Navigating>, ,,<xref:System.Windows.Application.Navigated>,,, .<xref:System.Windows.Application.GetCookie%2A> <xref:System.Windows.Application.NavigationProgress> <xref:System.Windows.Application.NavigationStopped> <xref:System.Windows.Application.NavigationFailed> <xref:System.Windows.Application.SetCookie%2A>  
  
 <xref:System.Windows.Application>implementuje wzorzec singleton, aby zapewnić współużytkowany dostęp do jego okna, właściwości i usług zakresu zasobów. W związku z tym można utworzyć tylko jedno <xref:System.Windows.Application> wystąpienie klasy na. <xref:System.AppDomain>  
  
 Można zaimplementować <xref:System.Windows.Application> przy użyciu znaczników, znaczników i kodu. Jeśli <xref:System.Windows.Application> jest zaimplementowany przy użyciu znacznika, niezależnie od tego, czy Adiustacja lub znaczniki i kod są powiązane, plik znaczników [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] musi być skonfigurowany `ApplicationDefinition` jako element.  
  
> [!NOTE]
>  Aplikacja autonomiczna nie wymaga <xref:System.Windows.Application> obiektu; istnieje możliwość zaimplementowania niestandardowej `static` metody punktu wejścia (`Main`) <xref:System.Windows.Application>otwierającej okno bez tworzenia wystąpienia. [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] Jednak<xref:System.Windows.Application> wymaga obiektu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak aplikacja standardowa jest definiowana przy użyciu tylko znaczników:  
  
 [!code-xaml[ApplicationSnippets#ApplicationMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppMarkup.xaml#applicationmarkup)]  
  
 Poniższy przykład pokazuje, jak aplikacja standardowa jest definiowana przy użyciu tylko kodu:  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppCode.cs#applicationcode)]
 [!code-vb[ApplicationSnippets#ApplicationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/appcode.vb#applicationcode)]  
  
 Poniższy przykład pokazuje, jak aplikacja standardowa jest definiowana przy użyciu kombinacji znaczników i kodu.  
  
 [!code-xaml[ApplicationSnippets#ApplicationXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml#applicationxaml)]  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml.cs#applicationcodebehind)]
 [!code-vb[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/application.xaml.vb#applicationcodebehind)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Publiczne <see langword="static" /> (<see langword="Shared" /> w Visual Basic) członkowie tego typu są bezpieczne wątkowo. Ponadto <see cref="M:System.Windows.Application.FindResource(System.Object)" /> <see cref="M:System.Windows.Application.TryFindResource(System.Object)" /> metody i<see cref="P:System.Windows.Application.Properties" />i właściwości i są bezpieczne wątkowo <see cref="P:System.Windows.Application.Resources" /> .</threadsafe>
    <altmember cref="T:System.Windows.Window" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Application ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Application();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Application" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> Można<xref:System.AppDomain>utworzyć tylko jedno wystąpienie klasy w celu zapewnienia dostępu współdzielonego do pojedynczego zestawu okna zakresu aplikacji, właściwości i danych zasobów. W związku z tym, Konstruktor <xref:System.Windows.Application> bez parametrów klasy wykrywa, czy inicjowane wystąpienie jest pierwszym wystąpieniem <xref:System.AppDomain>w. Jeśli <xref:System.InvalidOperationException> tak nie jest, jest zgłaszany.  
  
 Obiekt dla bieżącego <xref:System.AppDomain> elementu jest narażony na podstawie właściwości <xref:System.Windows.Application.Current%2A>statycznej. <xref:System.Windows.Application>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Utworzono więcej niż jedno wystąpienie <see cref="T:System.Windows.Application" /> klasy na. <see cref="T:System.AppDomain" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy aplikacja stanie się aplikacją pierwszego planu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja Windows Presentation Foundation, która ma co najmniej jedno otwarte okno (stanie się aplikacją pierwszego planu), gdy jedno z okien jest aktywowane po raz pierwszy od momentu uruchomienia aplikacji lub gdy jedno z okien jest aktywowane w czasie Aplikacja jest nieaktywna: W przypadku aktywacji występuje, gdy:  
  
-   Aplikacja otwiera swoje pierwsze okno.  
  
-   Użytkownik przełącza się do aplikacji przy użyciu kombinacji klawiszy ALT + TAB lub Menedżera zadań.  
  
-   Użytkownik klika przycisk paska zadań dla jednego z okien w aplikacji.  
  
 Aplikacje, które muszą wykryć, gdy aktywują, mogą <xref:System.Windows.Application.Activated> obsłużyć zdarzenie.  
  
 Po pierwszym aktywowaniu aplikacji można ją dezaktywować i ponownie uaktywnić w okresie istnienia. Jeśli zachowanie lub stan aplikacji zależy od jej stanu aktywacji, może obsługiwać oba <xref:System.Windows.Application.Activated> i <xref:System.Windows.Application.Deactivated> zdarzenia, aby określić, który stan aktywacji jest używany.  
  
 Gdy aplikacja stanie się aktywna, <xref:System.Windows.Application.Activated> program nie będzie ponownie uruchamiany, dopóki aplikacja nie zostanie zdezaktywowana, niezależnie od liczby aktywacji systemu Windows w aplikacji, gdy aplikacja jest aktywna.  
  
 <xref:System.Windows.Application.Activated>nie jest wywoływany [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]dla.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wykryć, kiedy aplikacja autonomiczna zostanie aktywowana i zdezaktywowana.  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Windows.Application Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Application Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Application ^ Current { System::Windows::Application ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Windows.Application" Usage="System.Windows.Application.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt dla bieżącego <see cref="T:System.AppDomain" />elementu. <see cref="T:System.Windows.Application" /></summary>
        <value>Obiekt dla bieżącego <see cref="T:System.AppDomain" />elementu. <see cref="T:System.Windows.Application" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application>jest typu pojedynczego, który implementuje Właściwość statyczną <xref:System.Windows.Application.Current%2A> w celu <xref:System.Windows.Application> zapewnienia dostępu współdzielonego do wystąpienia dla bieżącego <xref:System.AppDomain>.<xref:System.AppDomain> Ten projekt gwarantuje, że stan zarządzany <xref:System.Windows.Application>przez, w tym udostępnione zasoby i stan, jest dostępny z jednej udostępnionej lokalizacji.  
  
 Ta właściwość jest bezpieczna wątkowo i jest dostępna z dowolnego wątku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy aplikacja przestaje być aplikacją pierwszego planu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja Windows Presentation Foundation, która ma co najmniej jeden otwarty system Windows dezaktywuje (kończy działanie aplikacji pierwszego planu), gdy użytkownik wykonuje następujące czynności:  
  
-   Przełącza do innej aplikacji przy użyciu kombinacji klawiszy ALT + TAB lub Menedżera zadań.  
  
-   Klika przycisk paska zadań dla okna w innej aplikacji.  
  
 Aplikacje, które muszą wykrywać dezaktywację, <xref:System.Windows.Application.Deactivated> mogą obsłużyć zdarzenie.  
  
 Po pierwszym aktywowaniu aplikacji można ją dezaktywować i ponownie uaktywnić w okresie istnienia. Jeśli zachowanie lub stan aplikacji zależy od jej stanu aktywacji, może obsłużyć oba <xref:System.Windows.Application.Deactivated> i <xref:System.Windows.Application.Activated> zdarzenia, aby określić, który stan znajduje się w.  
  
 <xref:System.Windows.Application.Deactivated>nie jest wywoływany [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]dla.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wykryć, kiedy aplikacja autonomiczna zostanie zdezaktywowana i aktywowana.  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Activated" />
      </Docs>
    </Member>
    <Member MemberName="DispatcherUnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.DispatcherUnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DispatcherUnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ DispatcherUnhandledException;" />
      <MemberSignature Language="F#" Value="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " Usage="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy aplikacja zgłasza wyjątek, ale nie jest obsługiwana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie Windows Presentation Foundation przechwytuje Nieobsłużone wyjątki, powiadamia użytkowników o wyjątku z okna dialogowego (z którego mogą zgłosić wyjątek) i automatycznie zamyka aplikację.  
  
 Jeśli jednak aplikacja musi wykonać niestandardowe nieobsłużone przetwarzanie wyjątku z centralnej lokalizacji, należy obsłużyć <xref:System.Windows.Application.DispatcherUnhandledException>.  
  
 <xref:System.Windows.Application.DispatcherUnhandledException>jest wywoływany przez <xref:System.Windows.Application> dla każdego wyjątku, który jest nieobsługiwany przez kod uruchomiony w głównym wątku interfejsu użytkownika.  
  
 Jeśli wyjątek nie jest obsługiwany przez wątek interfejsu użytkownika w tle (wątek ze swoim własnym <xref:System.Windows.Threading.Dispatcher>) lub wątek roboczy w tle (wątek <xref:System.Windows.Threading.Dispatcher>bez), wyjątek nie jest przekazywany do głównego wątku interfejsu użytkownika. W związku z <xref:System.Windows.Application.DispatcherUnhandledException> tym nie zostanie zgłoszony. W takich sytuacjach należy napisać kod, aby wykonać następujące czynności:  
  
1.  Obsługa wyjątków w wątku w tle.  
  
2.  Wysyłaj te wyjątki do głównego wątku interfejsu użytkownika.  
  
3.  Należy je ponownie zgłosić w głównym wątku interfejsu użytkownika bez obsługi ich, <xref:System.Windows.Application.DispatcherUnhandledException> aby można było je wywoływać.  
  
 Aby uzyskać więcej informacji, zobacz Omówienie [modelu wątkowości](~/docs/framework/wpf/advanced/threading-model.md) .  
  
 <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs> Program obsługi <xref:System.Windows.Application.DispatcherUnhandledException> zdarzeń przeszedł do argumentu, który zawiera informacje kontekstowe dotyczące wyjątku, w tym:  
  
-   Wyjątek (<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A>).  
  
-   Z której pochodzi (<xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A>). <xref:System.Windows.Threading.Dispatcher>  
  
 Korzystając z tych informacji, można określić, czy wyjątek jest możliwy do odzyskania. Możliwy do odzyskania wyjątek <xref:System.IO.FileNotFoundException>może być na przykład, podczas gdy wyjątek nieodwracalny może <xref:System.StackOverflowException>być na przykład.  
  
 <xref:System.Windows.Application.DispatcherUnhandledException>Gdy przetwarzasz nieobsługiwany wyjątek z programu i nie chcesz [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] kontynuować przetwarzania go, musisz ustawić <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A> właściwość na `true`.  
  
 W przeciwieństwie do innych zdarzeń <xref:System.Windows.Application> , które <xref:System.Windows.Application.DispatcherUnhandledException> wystąpiły, nie ma zgodnej implementacji chronionej wirtualnej (OnDispatcherUnhandledException). W związku z tym klasy, które <xref:System.Windows.Application> pochodzą od, muszą zawsze rejestrować procedurę <xref:System.Windows.Application.DispatcherUnhandledException> obsługi zdarzeń w programie, aby przetwarzać Nieobsłużone wyjątki.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak przetwarzać Nieobsłużone wyjątki przez obsługę <xref:System.Windows.Application.DispatcherUnhandledException> zdarzenia.  
  
 [!code-csharp[handling-unhandled-exceptions](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs)]
 [!code-vb[handling-unhandled-exceptions](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public event System.Windows.ExitEventHandler Exit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.ExitEventHandler Exit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exit As ExitEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::ExitEventHandler ^ Exit;" />
      <MemberSignature Language="F#" Value="member this.Exit : System.Windows.ExitEventHandler " Usage="member this.Exit : System.Windows.ExitEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ExitEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje tuż przed zamknięciem aplikacji i nie można jej anulować.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja może zostać ZAMKNIĘTA z jednego z następujących powodów:  
  
-   Metoda obiektu jest wywoływana, jawnie lub zgodnie z <xref:System.Windows.Application.ShutdownMode%2A> określoną właściwością. <xref:System.Windows.Application> <xref:System.Windows.Application.Shutdown%2A>  
  
-   Użytkownik kończy sesję, logując się lub wyłączając.  
  
 Możesz wykryć, kiedy wystąpiło wyłączenie aplikacji przez <xref:System.Windows.Application.Exit> obsługę zdarzenia, i przeprowadź dodatkowe przetwarzanie zgodnie z potrzebami.  
  
 Można także obsłużyć <xref:System.Windows.Application.Exit> sprawdzanie lub zmianę kodu zakończenia aplikacji, gdy nie trzeba jawnie wywoływać <xref:System.Windows.Application.Shutdown%2A> . Kod zakończenia jest ujawniany na podstawie <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> właściwości <xref:System.Windows.ExitEventArgs> argumentu <xref:System.Windows.Application.Exit> , który jest przesyłany do procedury obsługi zdarzeń. Gdy aplikacja przestanie działać, kod zakończenia jest przenoszona do systemu operacyjnego w celu późniejszego przetwarzania.  
  
 Jeśli aplikacja obsługuje <xref:System.Windows.Application.SessionEnding> zdarzenie, a następnie anuluje je, nie <xref:System.Windows.Application.Exit> zostanie zgłoszona, a aplikacja będzie działać zgodnie z trybem zamykania.  
  
 Kod zakończenia można ustawić z [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)], chociaż wartość jest ignorowana.  
  
 W przypadku [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)]programu jestzgłaszanewnastępującychokolicznościach:<xref:System.Windows.Application.Exit>  
  
-   [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] Odchodzi od.  
  
-   W [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]programie, gdy karta [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] obsługująca program jest zamknięta.  
  
-   Gdy przeglądarka zostanie zamknięta.  
  
 We wszystkich przypadkach wartość <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> właściwości jest ignorowana.  
  
   
  
## Examples  
 Poniższy przykład ilustruje, jak:  
  
-   Obsłuż <xref:System.Windows.Application.Exit> zdarzenie.  
  
-   Sprawdź i zaktualizuj <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> Właściwość <xref:System.Windows.ExitEventArgs>.  
  
-   Napisz wpis do dziennika aplikacji w magazynie izolowanym.  
  
-   Utrwalaj stan aplikacji w magazynie izolowanym.  
  
 [!code-xaml[ApplicationExitSnippets#HandleExitXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml#handleexitxaml)]  
  
 [!code-csharp[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml.cs#handleexitcodebehind)]
 [!code-vb[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationExitSnippets/visualbasic/application.xaml.vb#handleexitcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
        <altmember cref="T:System.IO.IsolatedStorage.IsolatedStorage" />
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="application.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Nazwa zasobu do wyszukania.</param>
        <summary>Wyszukuje <see cref="T:System.Windows.Style" /> <see cref="T:System.Windows.Media.Brush" />zasób, taki jak lub, z określonym kluczem, i zgłasza wyjątek, jeśli nie odnaleziono żądanego zasobu (zobacz [zasoby XAML](~/docs/framework/wpf/advanced/xaml-resources.md)). [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</summary>
        <returns>Żądany obiekt zasobu. Jeśli żądany zasób nie zostanie znaleziony, <see cref="T:System.Windows.ResourceReferenceKeyNotFoundException" /> zostanie zgłoszony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.FindResource%2A>najpierw Przyjrzyj się zasobom zakresu aplikacji dla określonego zasobu. Zasoby zakresu aplikacji są zarządzane przez <xref:System.Windows.Application>program i są dostępne <xref:System.Windows.Application.Resources%2A> z poziomu właściwości. Jeśli określony zasób nie zostanie znaleziony w zestawie zasobów zakresu aplikacji, <xref:System.Windows.Application.FindResource%2A> następnie następnym szuka zasobów systemu. Zasoby systemowe są zasobami powłoki zdefiniowanymi przez użytkownika i obejmują kolory, czcionki i konfiguracje powłoki. Są one udostępniane z <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, i <xref:System.Windows.SystemParameters> , odpowiednio, jako właściwości statyczne. Aby skorzystać <xref:System.Windows.Application.FindResource%2A> z programu w celu uzyskania tych typów, należy również uwidocznić właściwości klucza zasobu, które są <xref:System.Windows.Application.FindResource%2A>przeznaczone do przekazywania; <xref:System.Windows.SystemParameters.IconWidthKey%2A>na przykład.  
  
 Ponieważ <xref:System.Windows.Application.FindResource%2A> zwraca obiekt, należy rzutować zwróconą wartość na odpowiedni typ, jeśli zasób zostanie znaleziony.  
  
> [!IMPORTANT]
>  W przypadku wywołania tej metody dla klucza, którego nie można znaleźć, zostanie zgłoszony wyjątek. Jeśli nie chcesz obsługiwać wyjątków, które wynikają z wywołania <xref:System.Windows.Application.FindResource%2A>, zamiast tego wywołaj. <xref:System.Windows.Application.TryFindResource%2A> <xref:System.Windows.Application.TryFindResource%2A> zwraca odwołanie,gdyniemożnaznaleźćżądanegozasobuiniezgłaszawyjątku.`null`  
  
 Ta metoda jest bezpieczna wątkowo i może być wywoływana z dowolnego wątku.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Windows.Application.FindResource%2A> do znajdowania zasobu oraz do obsługi <xref:System.Windows.ResourceReferenceKeyNotFoundException> , jeśli nie można odnaleźć zasobu.  
  
 [!code-csharp[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcallfindresourcecodebehind)]
 [!code-vb[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcallfindresourcecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">Nie można znaleźć zasobu.</exception>
        <altmember cref="M:System.Windows.Application.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Event FragmentNavigation As FragmentNavigationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberSignature Language="F#" Value="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " Usage="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy Nawigator w aplikacji rozpoczyna nawigację do fragmentu zawartości, Nawigacja odbywa się natychmiast, jeśli żądany fragment znajduje się w bieżącej zawartości lub po załadowaniu [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] zawartości źródłowej, jeśli żądany fragment znajduje się w innym treści.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nawigator jest <xref:System.Windows.Navigation.NavigationWindow> <xref:System.Windows.Controls.Frame>albo.  
  
 Zobacz <xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetContentStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetContentStream (Uri uriContent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetContentStream(class System.Uri uriContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetContentStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetContentStream (uriContent As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetContentStream(Uri ^ uriContent);" />
      <MemberSignature Language="F#" Value="static member GetContentStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetContentStream uriContent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriContent" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriContent">Względne <see cref="T:System.Uri" /> mapowanie na luźny zasób.</param>
        <summary>Zwraca strumień zasobów dla pliku danych zawartości, który znajduje się w określonej <see cref="T:System.Uri" /> lokalizacji (zobacz [zasób aplikacji WPF, zawartość i pliki danych](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).</summary>
        <returns>A <see cref="T:System.Windows.Resources.StreamResourceInfo" /> , który zawiera plik danych zawartości, który znajduje się w określonym <see cref="T:System.Uri" />. Jeśli nie odnaleziono swobodnego zasobu, zwracana jest wartość null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest bezpieczna wątkowo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Uri" /> Jest<see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> to wartość null.</exception>
        <exception cref="T:System.ArgumentException">Jest to wartość bezwzględna <see cref="T:System.Uri" />. <see cref="T:System.Uri" /> <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /></exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetCookie">
      <MemberSignature Language="C#" Value="public static string GetCookie (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCookie(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetCookie(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCookie(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="static member GetCookie : Uri -&gt; string" Usage="System.Windows.Application.GetCookie uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">Określa <see cref="T:System.Uri" /> lokalizację, dla której został utworzony plik cookie.</param>
        <summary>Pobiera plik cookie dla lokalizacji określonej przez <see cref="T:System.Uri" />.</summary>
        <returns>Wartość, jeśli plik cookie istnieje; w przeciwnym razie <see cref="T:System.ComponentModel.Win32Exception" /> jest zgłaszany. <see cref="T:System.String" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.GetCookie%2A>Pobiera plik cookie dla określonego <xref:System.Uri>elementu. Jeśli plik cookie nie może zostać pobrany, <xref:System.ComponentModel.Win32Exception> jest zgłaszany. Musisz napisać kod, aby przeanalizować ciąg cookie w postaci listy par nazwa/wartość.  
  
 Aby zapoznać się z omówieniem plików [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]cookie w programie, zobacz [Omówienie nawigacji](~/docs/framework/wpf/app-development/navigation-overview.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Błąd jest wywoływany przez funkcję <see langword="InternetGetCookie" /> (wywoływaną przez <see cref="M:System.Windows.Application.GetCookie(System.Uri)" />), jeśli wystąpi problem podczas próby pobrania określonego pliku cookie. [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)]</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do pobierania pliku cookie na podstawie <see cref="T:System.Uri" />plików. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">w celu pobrania pliku cookie dla nieopartego na <see cref="T:System.Uri" />plikach. Skojarzone Wyliczenie:<see cref="P:System.Net.WebPermission.ConnectList" /></permission>
        <altmember cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRemoteStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetRemoteStream (Uri uriRemote);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetRemoteStream(class System.Uri uriRemote) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRemoteStream (uriRemote As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetRemoteStream(Uri ^ uriRemote);" />
      <MemberSignature Language="F#" Value="static member GetRemoteStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetRemoteStream uriRemote" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriRemote" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriRemote"><see cref="T:System.Uri" /> To mapowanie do swobodnego zasobu w lokacji pochodzenia.</param>
        <summary>Zwraca strumień zasobów dla pliku danych lokacji, który znajduje się w określonej <see cref="T:System.Uri" /> lokalizacji (zobacz [zasób aplikacji WPF, zawartość i pliki danych](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).</summary>
        <returns>A <see cref="T:System.Windows.Resources.StreamResourceInfo" /> , który zawiera strumień zasobów dla pliku danych lokacji, który znajduje się w określonym <see cref="T:System.Uri" />. Jeśli nie odnaleziono swobodnego zasobu, <see langword="null" /> jest zwracany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest bezpieczna wątkowo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Uri" /> Jest<see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> to wartość null.</exception>
        <exception cref="T:System.ArgumentException">Parametr, który jest przesyłany do <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> nie jest względny albo jest bezwzględny, ale nie należy do <c>Pack://siteoforigin:,,,/</c> form. <see cref="T:System.Uri" /></exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetResourceStream (Uri uriResource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetResourceStream(class System.Uri uriResource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetResourceStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetResourceStream (uriResource As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetResourceStream(Uri ^ uriResource);" />
      <MemberSignature Language="F#" Value="static member GetResourceStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetResourceStream uriResource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriResource" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriResource"><see cref="T:System.Uri" /> To mapowanie do zasobu osadzonego.</param>
        <summary>Zwraca strumień zasobów dla pliku danych zasobu, który znajduje się w określonej <see cref="T:System.Uri" /> lokalizacji (zobacz [zasób aplikacji WPF, zawartość i pliki danych](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).</summary>
        <returns>A <see cref="T:System.Windows.Resources.StreamResourceInfo" /> , który zawiera strumień zasobów dla pliku danych zasobu, który znajduje się w określonej <see cref="T:System.Uri" />lokalizacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest bezpieczna wątkowo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Uri" /> Jest<see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> to wartość null.</exception>
        <exception cref="T:System.ArgumentException">Parametr, który jest przesyłany do <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> nie jest względny albo jest bezwzględny, ale nie należy do <c>Pack://Application:,,,/</c> form. <see cref="T:System.Uri" /></exception>
        <exception cref="T:System.IO.IOException">Nie można znaleźć przekazaną do <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />. <see cref="T:System.Uri" /></exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zawartość, która została przetworzona przez Nawigator w aplikacji, została załadowana, przeanalizowana i rozpoczęto renderowanie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nawigator jest <xref:System.Windows.Navigation.NavigationWindow> <xref:System.Windows.Controls.Frame>albo.  
  
 Zobacz <xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Nasłuchiwanie zdarzeń dotyczących zawartości z nawigacją, np <xref:System.Windows.FrameworkElement.Loaded> . <xref:System.Windows.Controls.Page> zdarzenia, przed uzyskaniem dostępu do właściwości zawartości z nawigacją.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadComponent">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ładuje plik, który znajduje się w określonym [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]pliku. [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plik może być plikiem kodu aplikacji (skonfigurowanym [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] jako element strony) lub plikiem danych aplikacji (plik zasobów, plik zawartości lub plik lokalizacji pochodzenia), zobacz temat [zasób aplikacji WPF, zawartość i pliki danych](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)). [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]  
  
> [!NOTE]
>  Ta metoda nie jest metodą o bezpiecznych wątkach.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static object LoadComponent (Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object LoadComponent(class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadComponent (resourceLocator As Uri) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ LoadComponent(Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : Uri -&gt; obj" Usage="System.Windows.Application.LoadComponent resourceLocator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="resourceLocator">Element <see cref="T:System.Uri" /> , który jest mapowany do [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] pliku względnego.</param>
        <summary>Ładuje plik, który znajduje się w określonym [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]i konwertuje go na wystąpienie obiektu, który jest określony przez element [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] główny pliku. [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]</summary>
        <returns>Wystąpienie elementu głównego określonego przez załadowany plik XAML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy jawnie przekonwertować wartość zwracaną na ten sam typ co element [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] główny pliku.  
  
 Plik może być plikiem kodu aplikacji (skonfigurowanym [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] jako element strony) lub plikiem danych aplikacji (plik zasobów, plik zawartości lub plik lokalizacji pochodzenia), zobacz temat [zasób aplikacji WPF, zawartość i pliki danych](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)). [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]  
  
> [!NOTE]
>  Ta metoda nie jest metodą o bezpiecznych wątkach.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceLocator" />ma wartość null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="resourceLocator" /> Jest bezwzględny [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.Exception">Plik nie [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] jest plikiem.</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static void LoadComponent (object component, Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LoadComponent(object component, class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Object,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LoadComponent (component As Object, resourceLocator As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LoadComponent(System::Object ^ component, Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : obj * Uri -&gt; unit" Usage="System.Windows.Application.LoadComponent (component, resourceLocator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="component">Obiekt tego samego typu, który jest elementem [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] głównym pliku.</param>
        <param name="resourceLocator">Element <see cref="T:System.Uri" /> , który jest mapowany do [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] pliku względnego.</param>
        <summary>Ładuje plik, który znajduje się w określonym [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] i konwertuje go na wystąpienie obiektu, który jest określony przez element [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] główny pliku. [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plik może być plikiem kodu aplikacji (skonfigurowanym [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] jako element strony) lub plikiem danych aplikacji (plik zasobów, plik zawartości lub plik lokalizacji pochodzenia), zobacz temat [zasób aplikacji WPF, zawartość i pliki danych](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)). [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]  
  
> [!NOTE]
>  Ta metoda nie jest metodą o bezpiecznych wątkach.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceLocator" />ma wartość null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="resourceLocator" /> Jest bezwzględny [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.Exception"><paramref name="component" />jest typu, który nie jest zgodny z elementem [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] głównym pliku.</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="MainWindow">
      <MemberSignature Language="C#" Value="public System.Windows.Window MainWindow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window MainWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.MainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Property MainWindow As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ MainWindow { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MainWindow : System.Windows.Window with get, set" Usage="System.Windows.Application.MainWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia okno główne aplikacji.</summary>
        <value>Element <see cref="T:System.Windows.Window" /> , który jest wyznaczono jako główne okno aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.MainWindow%2A>jest automatycznie ustawiany z odwołaniem do pierwszego <xref:System.Windows.Window> obiektu, który ma zostać utworzony <xref:System.AppDomain>w.  
  
 Możesz określić inne okno główne przez ustawienie <xref:System.Windows.Application.MainWindow%2A> przypisywania innego <xref:System.Windows.Application.Windows%2A> obiektu do <xref:System.Windows.Application.MainWindow%2A> właściwości.  
  
 <xref:System.Windows.Application.ShutdownMode%2A> Jeśli właściwość <xref:System.Windows.Application> obiektu jest ustawiona na <xref:System.Windows.ShutdownMode.OnMainWindowClose>, zamknięcie okna głównego powoduje wyłączenie aplikacji.  
  
 Można ustawić <xref:System.Windows.Application.MainWindow%2A> właściwość z [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)], jeśli okno główne aplikacji nie jest oknem, które <xref:System.Windows.Application.StartupUri%2A> jest tworzone przez ustawienie właściwości w [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]. Istnieją dwa ograniczenia [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] podejścia:  
  
-   Możesz [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]określić zarówno <xref:System.Windows.Window> jako okno główne, jak i [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]tylko <xref:System.Windows.Navigation.NavigationWindow> jako.  
  
-   Należy ustawić <xref:System.Windows.UIElement.Visibility%2A> Właściwość określonego okna, w przeciwnym razie nie będzie wyświetlana.  
  
 Odwołanie do pierwszego <xref:System.Windows.Window> obiektu do utworzenia wystąpienia jest również dodawane jako pierwszy element <xref:System.Windows.Application.Windows%2A> do kolekcji. Jeśli <xref:System.Windows.Application.MainWindow%2A> jest następnie ustawiona z odwołaniem do innego <xref:System.Windows.Window>, pozycja elementu z odwołaniem do okna głównego zmieni się, a kolejność elementów w <xref:System.Windows.Application.Windows%2A> pozostałej części. W związku z tym zawsze <xref:System.Windows.Application.MainWindow%2A> Używaj, aby odwołać się do głównego okna zamiast pierwszego elementu <xref:System.Windows.Application.Windows%2A>w.  
  
> [!NOTE]
>  Jeśli <xref:System.Windows.Navigation.NavigationWindow>okno główne jest i potrzebujesz określonego dostępu do <xref:System.Windows.Navigation.NavigationWindow> elementów członkowskich, należy rzutować wartość <xref:System.Windows.Application.MainWindow%2A> na <xref:System.Windows.Navigation.NavigationWindow>.  
>   
>  Ta właściwość jest dostępna tylko w wątku, który utworzył <xref:System.Windows.Application> obiekt.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak znaleźć okno główne aplikacji.  
  
 [!code-csharp[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationMainWindowSnippets/CSharp/App.xaml.cs#getapplicationmainwindowcode)]
 [!code-vb[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationMainWindowSnippets/visualbasic/application.xaml.vb#getapplicationmainwindowcode)]  
  
 Poniższy przykład pokazuje, jak ustawić <xref:System.Windows.Application.MainWindow%2A> przy użyciu. [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]  
  
 [!code-xaml[ApplicationMainWindowSnippets#SetApplicationMainWindowXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/ApplicationMainWindowSnippets/XAML/App.xaml#setapplicationmainwindowxaml)]  
  
 Poniższy przykład pokazuje, <xref:System.Windows.Application.MainWindow%2A> jak utworzyć wystąpienie kodu podczas uruchamiania aplikacji.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/App.xaml.cs#firstwindowusingcodecodebehind)]
 [!code-vb[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/application.xaml.vb#firstwindowusingcodecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Application.MainWindow" />jest ustawiany na podstawie aplikacji hostowanej w przeglądarce, takiej jak [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].</exception>
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy znaleziono zawartość, do której przejdzie Nawigator w aplikacji, chociaż może nie zakończył ładowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nawigator jest <xref:System.Windows.Navigation.NavigationWindow> <xref:System.Windows.Controls.Frame>albo.  
  
 Zobacz <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy w aplikacji zostanie zlecona Nowa nawigacja.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nawigator jest <xref:System.Windows.Navigation.NavigationWindow> <xref:System.Windows.Controls.Frame>albo.  
  
 Zobacz <xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberSignature Language="F#" Value="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " Usage="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wystąpi błąd, gdy Nawigator w aplikacji przejdzie do żądanej zawartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nawigator jest <xref:System.Windows.Navigation.NavigationWindow> <xref:System.Windows.Controls.Frame>albo.  
  
 Zobacz <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationProgress As NavigationProgressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberSignature Language="F#" Value="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " Usage="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje okresowo podczas pobierania, który jest zarządzany przez Nawigator w aplikacji w celu udostępnienia informacji o postępie nawigacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nawigator jest <xref:System.Windows.Navigation.NavigationWindow> <xref:System.Windows.Controls.Frame>albo.  
  
 Zobacz <xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationStopped As NavigationStoppedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberSignature Language="F#" Value="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " Usage="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see langword="StopLoading" /> wywoływana jest metoda nawigatora w aplikacji lub gdy jest wymagana Nowa Nawigacja w trakcie bieżącego nawigowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nawigator jest <xref:System.Windows.Navigation.NavigationWindow> <xref:System.Windows.Controls.Frame>albo.  
  
 Zobacz <xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="application.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Application.Activated" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnActivated%2A><xref:System.Windows.Application.Activated> podnosi zdarzenie.  
  
 Typ, który pochodzi od <xref:System.Windows.Application> może przesłonić. <xref:System.Windows.Application.OnActivated%2A> Przesłonięta Metoda musi <xref:System.Windows.Application.OnActivated%2A> wywołać w klasie bazowej, <xref:System.Windows.Application.Activated> Jeśli trzeba ją podwyższyć.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="application.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Application.Deactivated" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnDeactivated%2A><xref:System.Windows.Application.Deactivated> podnosi zdarzenie.  
  
 Typ, który pochodzi od <xref:System.Windows.Application> może przesłonić. <xref:System.Windows.Application.OnDeactivated%2A> Przesłonięta Metoda musi <xref:System.Windows.Application.OnDeactivated%2A> wywołać w klasie bazowej, <xref:System.Windows.Application.Deactivated> Jeśli trzeba ją podwyższyć.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnExit">
      <MemberSignature Language="C#" Value="protected virtual void OnExit (System.Windows.ExitEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnExit(class System.Windows.ExitEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnExit (e As ExitEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnExit(System::Windows::ExitEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnExit : System.Windows.ExitEventArgs -&gt; unit&#xA;override this.OnExit : System.Windows.ExitEventArgs -&gt; unit" Usage="application.OnExit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.ExitEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.ExitEventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Application.Exit" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnExit%2A><xref:System.Windows.Application.Exit> podnosi zdarzenie.  
  
 Typ, który pochodzi z <xref:System.Windows.Application> może <xref:System.Windows.Application.OnExit%2A> zastąpić metodę. Przesłonięta Metoda musi <xref:System.Windows.Application.OnExit%2A> wywołać w klasie bazowej, <xref:System.Windows.Application.Exit> Jeśli trzeba ją podwyższyć.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFragmentNavigation">
      <MemberSignature Language="C#" Value="protected virtual void OnFragmentNavigation (System.Windows.Navigation.FragmentNavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFragmentNavigation(class System.Windows.Navigation.FragmentNavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFragmentNavigation (e As FragmentNavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFragmentNavigation(System::Windows::Navigation::FragmentNavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit&#xA;override this.OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit" Usage="application.OnFragmentNavigation e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.FragmentNavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Navigation.FragmentNavigationEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Application.FragmentNavigation" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnFragmentNavigation%2A><xref:System.Windows.Application.FragmentNavigation> podnosi zdarzenie.  
  
 Typ, który pochodzi od <xref:System.Windows.Application> może przesłonić. <xref:System.Windows.Application.OnFragmentNavigation%2A> Przesłonięta Metoda musi <xref:System.Windows.Application.OnFragmentNavigation%2A> wywołać w klasie bazowej, <xref:System.Windows.Application.FragmentNavigation> Jeśli trzeba ją podwyższyć.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnLoadCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadCompleted (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadCompleted(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoadCompleted (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoadCompleted(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnLoadCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Navigation.NavigationEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Application.LoadCompleted" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnLoadCompleted%2A><xref:System.Windows.Application.LoadCompleted> podnosi zdarzenie.  
  
 Typ, który pochodzi od <xref:System.Windows.Application> może przesłonić. <xref:System.Windows.Application.OnLoadCompleted%2A> Przesłonięta Metoda musi <xref:System.Windows.Application.OnLoadCompleted%2A> wywołać w klasie bazowej, <xref:System.Windows.Application.LoadCompleted> Jeśli trzeba ją podwyższyć.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigated">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigated (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigated(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigated (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigated(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Navigation.NavigationEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Application.Navigated" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigated%2A><xref:System.Windows.Application.Navigated> podnosi zdarzenie.  
  
 Typ, który pochodzi od <xref:System.Windows.Application> może przesłonić. <xref:System.Windows.Application.OnNavigated%2A> Przesłonięta Metoda musi <xref:System.Windows.Application.OnNavigated%2A> wywołać w klasie bazowej, <xref:System.Windows.Application.Navigated> Jeśli trzeba ją podwyższyć.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigating">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigating (System.Windows.Navigation.NavigatingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigating(class System.Windows.Navigation.NavigatingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigating (e As NavigatingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigating(System::Windows::Navigation::NavigatingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit&#xA;override this.OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit" Usage="application.OnNavigating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigatingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Navigation.NavigatingCancelEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Application.Navigating" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigating%2A><xref:System.Windows.Application.Navigating> podnosi zdarzenie.  
  
 Typ, który pochodzi od <xref:System.Windows.Application> może przesłonić. <xref:System.Windows.Application.OnNavigating%2A> Przesłonięta Metoda musi <xref:System.Windows.Application.OnNavigating%2A> wywołać w klasie bazowej, <xref:System.Windows.Application.Navigating> Jeśli trzeba ją podwyższyć.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationFailed">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationFailed (System.Windows.Navigation.NavigationFailedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationFailed(class System.Windows.Navigation.NavigationFailedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationFailed (e As NavigationFailedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationFailed(System::Windows::Navigation::NavigationFailedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit&#xA;override this.OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit" Usage="application.OnNavigationFailed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationFailedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Navigation.NavigationFailedEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Application.NavigationFailed" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationFailed%2A><xref:System.Windows.Application.NavigationFailed> podnosi zdarzenie.  
  
 Typ, który pochodzi od <xref:System.Windows.Application> może przesłonić. <xref:System.Windows.Application.OnNavigationFailed%2A> Przesłonięta Metoda musi <xref:System.Windows.Application.OnNavigationFailed%2A> wywołać w klasie bazowej, <xref:System.Windows.Application.NavigationFailed> Jeśli trzeba ją podwyższyć.  
  
   
  
## Examples  
 <xref:System.Windows.Application.OnFragmentNavigation%2A>  
  
 <xref:System.Windows.Application.OnLoadCompleted%2A>  
  
 <xref:System.Windows.Application.OnNavigating%2A>  
  
 <xref:System.Windows.Application.OnNavigated%2A>  
  
 <xref:System.Windows.Application.OnNavigationProgress%2A>  
  
 <xref:System.Windows.Application.OnNavigationStopped%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNavigationProgress">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationProgress (System.Windows.Navigation.NavigationProgressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationProgress(class System.Windows.Navigation.NavigationProgressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationProgress (e As NavigationProgressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationProgress(System::Windows::Navigation::NavigationProgressEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit&#xA;override this.OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit" Usage="application.OnNavigationProgress e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationProgressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Navigation.NavigationProgressEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Application.NavigationProgress" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationProgress%2A><xref:System.Windows.Application.NavigationProgress> podnosi zdarzenie.  
  
 Typ, który pochodzi od <xref:System.Windows.Application> może przesłonić. <xref:System.Windows.Application.OnNavigationProgress%2A> Przeciążona metoda musi jawnie wywołać <xref:System.Windows.Application.OnNavigationProgress%2A> w klasie bazowej, jeśli <xref:System.Windows.Application.NavigationProgress> trzeba ją podwyższyć.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationStopped">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationStopped (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationStopped(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationStopped (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationStopped(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigationStopped e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Navigation.NavigationEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Application.NavigationStopped" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationStopped%2A><xref:System.Windows.Application.NavigationStopped> podnosi zdarzenie.  
  
 Typ, który pochodzi od <xref:System.Windows.Application> może przesłonić. <xref:System.Windows.Application.OnNavigationStopped%2A> Przesłonięta Metoda musi <xref:System.Windows.Application.OnNavigationStopped%2A> wywołać w klasie bazowej, <xref:System.Windows.Application.NavigationStopped> Jeśli trzeba ją podwyższyć.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionEnding">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionEnding (System.Windows.SessionEndingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionEnding(class System.Windows.SessionEndingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionEnding (e As SessionEndingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionEnding(System::Windows::SessionEndingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit&#xA;override this.OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit" Usage="application.OnSessionEnding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.SessionEndingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.SessionEndingCancelEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Application.SessionEnding" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnSessionEnding%2A><xref:System.Windows.Application.SessionEnding> podnosi zdarzenie.  
  
 Typ, który pochodzi od <xref:System.Windows.Application> może przesłonić. <xref:System.Windows.Application.OnSessionEnding%2A> Przesłonięta Metoda musi <xref:System.Windows.Application.OnSessionEnding%2A> wywołać w klasie bazowej, <xref:System.Windows.Application.SessionEnding> Jeśli trzeba ją podwyższyć.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStartup">
      <MemberSignature Language="C#" Value="protected virtual void OnStartup (System.Windows.StartupEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStartup(class System.Windows.StartupEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStartup (e As StartupEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStartup(System::Windows::StartupEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStartup : System.Windows.StartupEventArgs -&gt; unit&#xA;override this.OnStartup : System.Windows.StartupEventArgs -&gt; unit" Usage="application.OnStartup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.StartupEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.StartupEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Application.Startup" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnStartup%2A><xref:System.Windows.Application.Startup> podnosi zdarzenie.  
  
 Typ, który pochodzi od <xref:System.Windows.Application> może przesłonić. <xref:System.Windows.Application.OnStartup%2A> Zastąpiona metoda musi wywołać <xref:System.Windows.Application.OnStartup%2A> w klasie bazowej, <xref:System.Windows.Application.Startup> Jeśli zdarzenie ma zostać zgłoszone.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Properties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Properties { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Collections.IDictionary" Usage="System.Windows.Application.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję właściwości zakresu aplikacji.</summary>
        <value><see cref="T:System.Collections.IDictionary" /> Zawierający właściwości zakresu aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application>udostępnia słownik, za <xref:System.Windows.Application.Properties%2A> pomocą którego można przechowywać właściwości zakresu aplikacji. Pozwala to na udostępnianie stanu całego kodu w <xref:System.AppDomain> sposób bezpieczny dla wątków, bez konieczności pisania kodu stanu.  
  
 Właściwości przechowywane w <xref:System.Windows.Application.Properties%2A> elemencie muszą być konwertowane na odpowiedni zwracany typ.  
  
 <xref:System.Windows.Application.Properties%2A> Właściwość jest bezpieczna wątkowo i jest dostępna z dowolnego wątku.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć i używać właściwości zakresu aplikacji przy użyciu <xref:System.Windows.Application.Properties%2A>.  
  
 [!code-xaml[ApplicationPropertiesSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml1)]  
[!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml2)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml.cs#mainwindowgetpropertycodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/mainwindow.xaml.vb#mainwindowgetpropertycodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="ResourceAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ResourceAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Assembly ResourceAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ResourceAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ResourceAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Assembly ^ ResourceAssembly { System::Reflection::Assembly ^ get(); void set(System::Reflection::Assembly ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResourceAssembly : System.Reflection.Assembly with get, set" Usage="System.Windows.Application.ResourceAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see cref="T:System.Reflection.Assembly" /> określającą pakiet [!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] dla zasobów w [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] aplikacji.</summary>
        <value>Odwołanie do <see cref="T:System.Reflection.Assembly" /> pakietu zawierającego pakiet [!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] dla zasobów w [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] zasoby są rozwiązane w czasie wykonywania w odniesieniu do zestawu wejścia, który jest identyfikowany przez wartość zwróconą <xref:System.Reflection.Assembly.GetEntryAssembly%2A> przez metodę.  
  
 Zestaw wejściowy jest zestawem, który jest zwracany <xref:System.Reflection.Assembly.GetEntryAssembly%2A> przez i może być następujący:  
  
-   Zestaw wykonywalny w domyślnej domenie aplikacji.  
  
-   Pierwszy zestaw, który ma zostać wykonany przez <xref:System.AppDomain.ExecuteAssembly%2A>wywołanie.  
  
 Jednak w następujących przypadkach [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] zestaw nie może pobrać odwołania do zestawu wpisów:  
  
-   Niezarządzana (natywna) aplikacja [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] hostuje zestaw.  
  
-   Aplikacja zarządzana obsługuje [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] zestaw przez załadowanie go do nowej domeny aplikacji przy użyciu metody innej niż <xref:System.AppDomain.ExecuteAssembly%2A>.  
  
 W obu tych przypadkach <xref:System.Reflection.Assembly.GetEntryAssembly%2A> zwraca `null`i [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] nie można rozpoznać zasobów zestawu. W takich przypadkach <xref:System.Windows.Application.ResourceAssembly%2A> można ustawić tylko raz, z odwołaniem do zestawu, który ma być używany do rozwiązywania zasobów.  
  
 <xref:System.Windows.Application.ResourceAssembly%2A>można ustawić tylko raz, ponieważ jest mało prawdopodobne, że zestaw zasobów ulegnie zmianie po [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] załadowaniu zestawu.  
  
> [!NOTE]
>  <xref:System.Windows.Application.ResourceAssembly%2A>nie można ustawić, gdy [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] zestaw nie może odnaleźć zestawu wejścia, czyli gdy <xref:System.Reflection.Assembly.GetEntryAssembly%2A> zwraca odwołanie `null`do zestawu, a nie.  
  
 Ta właściwość jest bezpieczna wątkowo i jest dostępna z dowolnego wątku.  
  
 <xref:System.Windows.Application.ResourceAssembly%2A>wprowadzono w .NET Framework w wersji 3,5.  Aby uzyskać więcej informacji, zobacz [wersje i zależności](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aplikacja ma zestaw wpisów lub <see cref="P:System.Windows.Application.ResourceAssembly" /> został już ustawiony. [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]</exception>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.Application.Resources" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolekcję zasobów zakresu aplikacji, takich jak style i pędzle.</summary>
        <value><see cref="T:System.Windows.ResourceDictionary" /> Obiekt, który zawiera zero lub więcej zasobów zakresu aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Resources%2A> Właściwość może służyć do udostępniania zasobów między oknami i elementami aplikacji. <xref:System.Windows.Application.Resources%2A> Ponadto właściwość jest uwzględniona w ścieżce wyszukiwania zasobów, która jest przesunięta w następujący sposób:  
  
1.  Elementy  
  
2.  Windows  
  
3.  <xref:System.Windows.Application.Resources%2A?displayProperty=nameWithType>  
  
4.  System  
  
 W [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] związku z tym elementy mogą być powiązane z zasobami zakresu aplikacji. Ponadto w przypadku zmiany zasobów system zasobów zapewnia, że właściwości elementu powiązane z tymi zasobami są automatycznie aktualizowane w celu odzwierciedlenia zmiany.  
  
 Zasoby zakresu aplikacji zapewniają prosty sposób obsługi spójnego motywu w aplikacji. Możesz łatwo utworzyć motyw w programie [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] przy `Application.Resources` użyciu znacznika. Jeśli jednak aplikacja obsługuje wiele motywów, które mogą zawierać dużą liczbę elementów motywu, można łatwiej zarządzać nimi przy użyciu jednego <xref:System.Windows.ResourceDictionary> wystąpienia dla każdego motywu. W ten sposób można zastosować nowy motyw, ustawiając właściwość resources na odpowiednią <xref:System.Windows.ResourceDictionary>.  
  
 Istnieją dwa kwestie, które należy wziąć pod <xref:System.Windows.Application.Resources%2A>uwagę podczas korzystania z programu. Najpierw *klucz* słownika jest obiektem, dlatego należy użyć dokładnie tego samego wystąpienia obiektu, gdy oba ustawienia i pobierają wartość właściwości (należy zauważyć, że w kluczu jest rozróżniana wielkość liter przy użyciu ciągu). Po drugie, *wartość* słownika jest obiektem, dlatego podczas pobierania wartości właściwości należy skonwertować wartość na żądany typ.  
  
 <xref:System.Windows.Application.Resources%2A>jest bezpieczny dla wątków i jest dostępny z dowolnego wątku.  
  
   
  
## Examples  
Ten przykład ilustruje sposób używania języka XAML wraz z zasobami zakresu aplikacji w celu utworzenia spójnego wyglądu wizualizacji. Pierwszy przykład pochodzi z pliku *App. XAML*; sekunda, z *MainWindow. XAML*. 
  
[!code-xaml[ApplicationResourcesSnippets#ResourcesPropertyXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/App.xaml#resourcespropertyxaml)]  
  
[!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml?highlight=7)]  
  
 Poniższy przykład pokazuje, jak ustawić zasób aplikacji w kodzie i XAML (w pliku App. XAML w projekcie C# WPF lub pliku Application. xaml w Visual Basic projekcie WPF).  
  
 [!code-csharp[Setting-an-application-resource-in-code](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#setapplicationscoperesourcecode)]
 [!code-vb[Setting-an-application-resource-in-code](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#setapplicationscoperesourcecode)]  
  
 [!code-xaml[Setting-an-application-resource-in-XAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/App.xaml?highlight=8-10)]  
  
 Poniższy przykład pokazuje, jak uzyskać zasób aplikacji w kodzie.  
  
 [!code-csharp[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#getapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#getapplicationscoperesourcecode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uruchamia aplikację Windows Presentation Foundation.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Function Run () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run();" />
      <MemberSignature Language="F#" Value="member this.Run : unit -&gt; int" Usage="application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia aplikację Windows Presentation Foundation.</summary>
        <returns>Kod <see cref="T:System.Int32" /> zakończenia aplikacji, który jest zwracany do systemu operacyjnego podczas zamykania aplikacji. Domyślnie wartość kodu zakończenia to 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Run%2A>jest wywoływana w celu uruchomienia [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] aplikacji. Jeśli zdefiniujesz <xref:System.Windows.Application> znaczniki using lub znaczniki i kod w tle, <xref:System.Windows.Application.Run%2A> zostaną one wywołane niejawnie. Jeśli jednak zdefiniujesz swój <xref:System.Windows.Application> kod przy użyciu, musisz jawnie wywołać. <xref:System.Windows.Application.Run%2A>  
  
 Gdy <xref:System.Windows.Application.Run%2A> jest wywoływana, <xref:System.Windows.Application> dołącza nowe <xref:System.Windows.Threading.Dispatcher> wystąpienie do wątku interfejsu użytkownika. Następnie wywoływana jest <xref:System.Windows.Threading.Dispatcher.Run%2A> Metoda obiektu,którauruchamiapompękomunikatów,abyprzetwarzaćkomunikatysystemuWindows.<xref:System.Windows.Threading.Dispatcher> Na <xref:System.Windows.Threading.Dispatcher> koniec obiekt <xref:System.Windows.Application> wywołuje <xref:System.Windows.Application.OnStartup%2A> metodę w celu podniesienia <xref:System.Windows.Application.Startup> zdarzenia. W związku z tym model wykonywania aplikacji został ustanowiony przez czas <xref:System.Windows.Application.Startup>, w którym aplikacja jest traktowana jako uruchomiona.  
  
 Aplikacja przestaje działać, gdy <xref:System.Windows.Application.Shutdown%2A> jest wywoływana; wartość <xref:System.Windows.Application.ShutdownMode%2A> właściwości określa, kiedy <xref:System.Windows.Application.Shutdown%2A> jest wywoływana, i czy jest ona wykonywana automatycznie, czy należy jawnie wywołać ją.  
  
 <xref:System.Windows.Application.Run%2A>może być wywoływana tylko z wątku, który tworzy <xref:System.Windows.Application> obiekt. Ponadto nie można wywołać z elementu [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]. <xref:System.Windows.Application.Run%2A>  
  
   
  
## Examples  
 Poniższy przykład pokazuje aplikację, która używa niestandardowych <xref:System.Windows.Application> i dlatego musi jawnie wywołać. <xref:System.Windows.Application.Run%2A>  
  
 [!code-csharp[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunSnippets/CSharp/App.cs#customentrypointandruncode)]
 [!code-vb[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunSnippets/visualbasic/app.vb#customentrypointandruncode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Application.Run" />jest wywoływana z aplikacji hostowanej w przeglądarce (na przykład [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]).</exception>
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run (System.Windows.Window window);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run(class System.Windows.Window window) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run(System.Windows.Window)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run(System::Windows::Window ^ window);" />
      <MemberSignature Language="F#" Value="member this.Run : System.Windows.Window -&gt; int" Usage="application.Run window" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="window" Type="System.Windows.Window" />
      </Parameters>
      <Docs>
        <param name="window"><see cref="T:System.Windows.Window" /> Zostanie otwarty automatycznie podczas uruchamiania aplikacji.</param>
        <summary>Uruchamia aplikację Windows Presentation Foundation i otwiera określone okno.</summary>
        <returns>Kod <see cref="T:System.Int32" /> zakończenia aplikacji, który jest zwracany do systemu operacyjnego podczas zamykania aplikacji. Domyślnie wartość kodu zakończenia to 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie rozszerza <xref:System.Windows.Application.Run%2A> metodę, aby otworzyć określone okno po uruchomieniu aplikacji.  
  
 Jeśli zdefiniujesz kod <xref:System.Windows.Application> , który otwiera okno podczas uruchamiania, jawnie Wywołaj <xref:System.Windows.Application.Run%2A>.  
  
 Jeśli tworzysz <xref:System.Windows.Application> znaczniki użycia lub znaczniki i kod w tle, możesz automatycznie otworzyć okno podczas korzystania z jednej z następujących metod:  
  
-   Deklaratywnie, przez ustawienie <xref:System.Windows.Application.StartupUri%2A>.  
  
-   Programowo, przez obsługę <xref:System.Windows.Application.Startup>.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono aplikację z ręcznie utworzoną metodą statycznego punktu wejścia <xref:System.Windows.Application>, która tworzy wystąpienia przed wywołaniem. <xref:System.Windows.Application.Run%2A>  
  
 [!code-csharp[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunOL1Snippets/CSharp/App.cs#customentrypointandrunol1code)]
 [!code-vb[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunOL1Snippets/visualbasic/app.vb#customentrypointandrunol1code)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Application.Run" />jest wywoływana z aplikacji hostowanej w przeglądarce (na przykład [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]).</exception>
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public event System.Windows.SessionEndingCancelEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SessionEndingCancelEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SessionEnding As SessionEndingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SessionEndingCancelEventHandler ^ SessionEnding;" />
      <MemberSignature Language="F#" Value="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " Usage="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SessionEndingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik kończy sesję systemu Windows przez wylogowanie lub wyłączenie systemu operacyjnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie aplikacja jest zamykana po zakończeniu sesji systemu Windows, która występuje, gdy użytkownik wyloguje się lub zamknie. W takim przypadku system Windows prosi o zamknięcie każdej otwartej aplikacji. Jednak jest możliwe, że aplikacja może nie być gotowa do zamknięcia w przypadku wystąpienia tego problemu. Na przykład aplikacja może mieć dane, które znajdują się w stanie niespójnym lub w środku długotrwałej operacji. W takich sytuacjach może być pożądane, aby uniemożliwić zakończenie sesji i może być bardziej pożądane, aby umożliwić użytkownikom określenie, czy chcesz zezwolić na zakończenie sesji.  
  
 Możesz wykryć czas zakończenia sesji przez obsługę <xref:System.Windows.Application.SessionEnding> zdarzenia. Jeśli aplikacja musi uniemożliwiać zakończenie sesji <xref:System.Windows.SessionEndingCancelEventArgs> , argument, który jest przesyłany do procedury obsługi zdarzeń, <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> uwidacznia wartość ustawioną na `true` (wartością domyślną jest `false`).  
  
 Jeśli <xref:System.Windows.Application.SessionEnding> jest nieobsługiwany lub jest obsługiwany bez anulowania, <xref:System.Windows.Application.Shutdown%2A> jest wywoływana i <xref:System.Windows.Application.Exit> zdarzenie jest zgłaszane.  
  
 Aby uzyskać więcej informacji na temat przyczyny zakończenia sesji, aplikacja może przeprowadzić inspekcję <xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>, która jest jedną <xref:System.Windows.ReasonSessionEnding> z wartości (<xref:System.Windows.ReasonSessionEnding.Logoff?displayProperty=nameWithType> i <xref:System.Windows.ReasonSessionEnding.Shutdown?displayProperty=nameWithType>).  
  
 <xref:System.Windows.Application.SessionEnding>nie jest wywoływany przez aplikacje konsolowe.  
  
 <xref:System.Windows.Application.SessionEnding>jest wywoływany tylko w wątku, który tworzy <xref:System.Windows.Application> obiekt.  
  
 <xref:System.Windows.Application.SessionEnding>nie jest zgłaszane dla aplikacji przeglądarki XAML (XBAP).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak obsłużyć <xref:System.Windows.Application.SessionEnding> zdarzenie i zezwolić użytkownikowi na jego anulowanie.  
  
 [!code-xaml[ApplicationSessionEndingSnippets#HandlingSessionEndingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml#handlingsessionendingxaml)]  
  
 [!code-csharp[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml.cs#handlingsessionendingcodebehind)]
 [!code-vb[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/visualbasic/application.xaml.vb#handlingsessionendingcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public static void SetCookie (Uri uri, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCookie(class System.Uri uri, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCookie(Uri ^ uri, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetCookie : Uri * string -&gt; unit" Usage="System.Windows.Application.SetCookie (uri, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri"><see cref="T:System.Uri" /> Określa lokalizację, dla której ma zostać utworzony plik cookie.</param>
        <param name="value"><see cref="T:System.String" /> Zawiera dane plików cookie.</param>
        <summary>Tworzy plik cookie dla lokalizacji określonej przez <see cref="T:System.Uri" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plik cookie to dowolna część danych, która może być przechowywana przez aplikację na komputerze klienckim podczas sesji aplikacji (pliki cookie sesji) lub między sesjami aplikacji (trwałych plików cookie). Można utworzyć oba typy plików cookie, wywołując <xref:System.Windows.Application.SetCookie%2A>metodę.  
  
 Dane plików cookie zazwyczaj przyjmuje postać pary nazwa/wartość w następującym formacie:  
  
 `Name=Value`  
  
 Należy przekazać ciąg tego formatu do <xref:System.Windows.Application.SetCookie%2A>, wraz <xref:System.Uri> z lokalizacją, w której ma zostać ustawiony plik cookie (zazwyczaj domena aplikacji).  
  
 Niezależnie od tego, czy plik cookie jest plikiem cookie sesji, czy trwały plik cookie zależy od tego, czy <xref:System.Windows.Application.SetCookie%2A> przekazany ciąg cookie zawiera datę wygaśnięcia. Ciąg dla pliku cookie sesji nie zawiera daty wygaśnięcia. Ciąg dla trwałego pliku cookie ma wartość i musi mieć następujący format:  
  
 `NAME=VALUE; expires=DAY, DD-MMM-YYYY HH:MM:SS GMT`  
  
 Trwałe pliki cookie są przechowywane w folderze [!INCLUDE[TLA#tla_mswin](~/includes/tlasharptla-mswin-md.md)] tymczasowych plików internetowych bieżącej instalacji do momentu ich wygaśnięcia, w takim przypadku zostaną usunięte. Można usunąć trwały plik cookie z aplikacji, ustawiając jego datę wygaśnięcia na wartość daty/godziny, która przypada w przeszłości.  
  
 Aby zapoznać się z omówieniem plików [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]cookie w programie, zobacz [Omówienie nawigacji](~/docs/framework/wpf/app-development/navigation-overview.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Błąd jest wywoływany przez funkcję <see langword="InternetSetCookie" /> (wywoływaną przez <see cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />), jeśli wystąpi problem podczas próby utworzenia określonego pliku cookie. [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)]</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do pobierania pliku cookie na podstawie <see cref="T:System.Uri" />plików. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">w celu pobrania pliku cookie dla nieopartego na <see cref="T:System.Uri" />plikach. Skojarzone Wyliczenie:<see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Windows.Application.GetCookie(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Shutdown">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zamyka aplikację.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown();" />
      <MemberSignature Language="F#" Value="member this.Shutdown : unit -&gt; unit" Usage="application.Shutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka aplikację.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.Application.Shutdown%2A> jest wywoływana, aplikacja przestaje działać. Możesz obsłużyć <xref:System.Windows.Application.Exit> zdarzenie, aby wykryć, kiedy aplikacja ma przestać działać, aby wykonać odpowiednie przetwarzanie.  
  
 <xref:System.Windows.Application.Shutdown%2A>jest wywoływany niejawnie przez Windows Presentation Foundation w następujących sytuacjach:  
  
-   Gdy <xref:System.Windows.Application.ShutdownMode%2A> jest ustawiona na <xref:System.Windows.ShutdownMode.OnLastWindowClose>.  
  
-   Gdy jest ustawiona na <xref:System.Windows.ShutdownMode.OnMainWindowClose>. <xref:System.Windows.Application.ShutdownMode%2A>  
  
-   Gdy użytkownik skończy sesję, a <xref:System.Windows.Application.SessionEnding> zdarzenie jest nieobsłużone lub obsługiwane bez anulowania.  
  
 Wywołanie <xref:System.Windows.Application.Shutdown%2A> jawnie powoduje wyłączenie aplikacji, niezależnie <xref:System.Windows.Application.ShutdownMode%2A> od ustawienia. Jeśli <xref:System.Windows.Application.ShutdownMode%2A> jednak jest ustawiona na <xref:System.Windows.ShutdownMode.OnExplicitShutdown>, należy wywołać <xref:System.Windows.Application.Shutdown%2A> , aby zamknąć aplikację.  
  
> [!IMPORTANT]
>  Gdy <xref:System.Windows.Application.Shutdown%2A> jest wywoływana, aplikacja zostanie zamknięta bez względu na to, <xref:System.Windows.Window.Closing> czy zdarzenie dotyczące otwartych okien zostało anulowane.  
  
 Tę metodę można wywołać tylko z wątku, który utworzył <xref:System.Windows.Application> obiekt.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">w celu zezwolenia na używanie wszystkich zdarzeń systemu Windows i danych wejściowych użytkownika bez ograniczeń. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
        <altmember cref="M:System.Windows.Application.Run" />
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(int exitCode);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : int -&gt; unit" Usage="application.Shutdown exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">Kod zakończenia dla aplikacji. Domyślny kod zakończenia to 0.</param>
        <summary>Zamyka aplikację, która zwraca określony kod zakończenia do systemu operacyjnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz obsłużyć <xref:System.Windows.Application.Exit> zdarzenie, aby ustawić kod zakończenia. Jednakże w przypadku jawnego wywołania <xref:System.Windows.Application.Shutdown%2A>i obsłużenia <xref:System.Windows.Application.Exit> tylko do ustawiania kodu zakończenia można wywołać <xref:System.Windows.Application.Shutdown%2A> zamiast tego.  
  
 Tę metodę można wywołać tylko z wątku, który utworzył <xref:System.Windows.Application> obiekt.  
  
 Zobacz <xref:System.Environment.ExitCode%2A?displayProperty=nameWithType> , aby uzyskać informacje na temat kodów zakończenia.
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">w celu zezwolenia na używanie wszystkich zdarzeń systemu Windows i danych wejściowych użytkownika bez ograniczeń. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="Overload:System.Windows.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownMode">
      <MemberSignature Language="C#" Value="public System.Windows.ShutdownMode ShutdownMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ShutdownMode ShutdownMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ShutdownMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ShutdownMode As ShutdownMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ShutdownMode ShutdownMode { System::Windows::ShutdownMode get(); void set(System::Windows::ShutdownMode value); };" />
      <MemberSignature Language="F#" Value="member this.ShutdownMode : System.Windows.ShutdownMode with get, set" Usage="System.Windows.Application.ShutdownMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ShutdownMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia warunek, który powoduje <see cref="M:System.Windows.Application.Shutdown" /> wywołanie metody.</summary>
        <value>Wartość <see cref="T:System.Windows.ShutdownMode" /> wyliczenia. Wartość domyślna to <see cref="F:System.Windows.ShutdownMode.OnLastWindowClose" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacje są uruchamiane tylko wtedy, <xref:System.Windows.Application.Shutdown%2A> gdy wywoływana jest metoda aplikacji. Zamykanie może wystąpić niejawnie lub jawnie, zgodnie z wartością <xref:System.Windows.Application.ShutdownMode%2A> właściwości.  
  
 W przypadku wybrania opcji, Windows Presentation Foundation (WPF) niejawnie wywołuje <xref:System.Windows.Application.Shutdown%2A> się, gdy ostatnie okno w aplikacji zostanie zamknięte, nawet jeśli wszystkie aktualnie utworzone okna są ustawiane jako okno główne <xref:System.Windows.Application.MainWindow%2A>(zobacz). <xref:System.Windows.ShutdownMode.OnLastWindowClose> <xref:System.Windows.Application.ShutdownMode%2A>  
  
 A <xref:System.Windows.Application.ShutdownMode%2A> <xref:System.Windows.Application.Shutdown%2A> <xref:System.Windows.Application.MainWindow%2A> z <xref:System.Windows.ShutdownMode.OnMainWindowClose> powoduje, że WPF niejawnie wywołuje się po zamknięciu, nawet jeśli obecnie są otwarte inne okna.  
  
 Okres istnienia niektórych aplikacji może nie być zależny od tego, kiedy okno główne lub ostatnie okno jest zamknięte, lub może nie być zależne od systemu Windows. Dla tych scenariuszy należy ustawić <xref:System.Windows.Application.ShutdownMode%2A> właściwość na <xref:System.Windows.ShutdownMode.OnExplicitShutdown>, która wymaga jawnego <xref:System.Windows.Application.Shutdown%2A> wywołania metody, aby zatrzymać aplikację. W przeciwnym razie aplikacja będzie działać w tle.  
  
 <xref:System.Windows.Application.ShutdownMode%2A>można skonfigurować deklaratywnie z [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] kodu lub programowo.  
  
 Ta właściwość jest dostępna tylko w wątku, który utworzył <xref:System.Windows.Application> obiekt.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak skonfigurować <xref:System.Windows.Application.ShutdownMode%2A> , aby określić, że aplikacja musi zostać ZAMKNIĘTA jawnie.  
  
 [!code-xaml[ApplicationShutdownModeSnippets#SetShutdownModeXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationShutdownModeSnippets/CS/App.xaml#setshutdownmodexaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Startup">
      <MemberSignature Language="C#" Value="public event System.Windows.StartupEventHandler Startup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.StartupEventHandler Startup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Startup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Startup As StartupEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::StartupEventHandler ^ Startup;" />
      <MemberSignature Language="F#" Value="member this.Startup : System.Windows.StartupEventHandler " Usage="member this.Startup : System.Windows.StartupEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.StartupEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, <see cref="M:System.Windows.Application.Run" /> gdy wywoływana jest metoda <see cref="T:System.Windows.Application" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typowa aplikacja Windows Presentation Foundation może wykonywać rozmaite zadania inicjujące podczas uruchamiania, w tym:  
  
-   Przetwarzanie parametrów wiersza polecenia.  
  
-   Otwieranie okna głównego.  
  
-   Inicjowanie zasobów zakresu aplikacji.  
  
-   Inicjowanie właściwości zakresu aplikacji.  
  
 Można deklaratywnie określić główne zasoby okna i zakresu aplikacji przy użyciu [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] <xref:System.Windows.Application.Resources%2A>(<xref:System.Windows.Application.StartupUri%2A> odpowiednio). Czasami jednak zasoby lub główne okno aplikacji można określić programowo tylko w czasie wykonywania. Ponadto właściwości zakresu aplikacji i parametry wiersza polecenia mogą być używane programowo. Inicjowanie programistyczne może być wykonywane przez obsługę <xref:System.Windows.Application.Startup> zdarzenia, w tym następujące:  
  
-   Pobieranie i przetwarzanie parametrów wiersza polecenia, które są dostępne z <xref:System.Windows.StartupEventArgs.Args%2A> właściwości <xref:System.Windows.StartupEventArgs> klasy <xref:System.Windows.Application.Startup> , która jest przenoszona do programu obsługi zdarzeń.  
  
-   Inicjowanie zasobów zakresu aplikacji przy użyciu <xref:System.Windows.Application.Resources%2A> właściwości.  
  
-   Inicjowanie właściwości zakresu aplikacji przy użyciu <xref:System.Windows.Application.Properties%2A> właściwości.  
  
-   Tworzenie wystąpienia i wyświetlanie jednego (lub więcej) okien.  
  
> [!NOTE]
>  Parametry wiersza polecenia można również uzyskać przez wywołanie statycznej <xref:System.Environment.GetCommandLineArgs%2A> metody <xref:System.Environment> obiektu. <xref:System.Environment.GetCommandLineArgs%2A> Jednak wymaga pełnego zaufania do wykonania.  
  
 Jeśli ustawisz <xref:System.Windows.Application.StartupUri%2A> opcję [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]using, utworzone okno główne <xref:System.Windows.Application.MainWindow%2A> nie jest dostępne z właściwości lub <xref:System.Windows.Application.Windows%2A> właściwości <xref:System.Windows.Application> obiektu do momentu <xref:System.Windows.Application.Startup> przetworzenia zdarzenia. Jeśli potrzebujesz dostępu do głównego okna podczas uruchamiania, musisz ręcznie utworzyć nowy obiekt okna z <xref:System.Windows.Application.Startup> programu obsługi zdarzeń.  
  
> [!NOTE]
>  Jeśli <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> aplikacja używa programu w celu określenia zasad poświadczeń, należy ją ustawić <xref:System.Windows.Application.Startup> <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> po podniesieniu. w przeciwnym [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] razie program ustawia ją na domyślne zasady wewnętrzne bezpośrednio po <xref:System.Windows.Application.Startup> wyjściu zdarzenia.  
  
 Argumenty wiersza polecenia, które są przekazane do <xref:System.Windows.Application.Startup> programu obsługi zdarzeń, nie są takie same, [!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)] jak parametry ciągu zapytania [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)], które są przekazane do.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak uzyskać i przetworzyć opcje wiersza polecenia z aplikacji autonomicznej. Jeśli podano parametr wiersza polecenia **/StartMinimized** , aplikacja otwiera okno główne w stanie zminimalizowanym.  
  
 [!code-xaml[ApplicationStartupSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationStartupSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]nie można pobrać i przetworzyć argumentów wiersza polecenia, ponieważ są [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)] one uruchamiane z wdrożeniem (zobacz [wdrażanie aplikacji WPF (WPF)](~/docs/framework/wpf/app-development/deploying-a-wpf-application-wpf.md)). Mogą jednak pobierać i przetwarzać parametry ciągu zapytania z adresów URL, które są używane do ich uruchamiania.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="StartupUri">
      <MemberSignature Language="C#" Value="public Uri StartupUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri StartupUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.StartupUri" />
      <MemberSignature Language="VB.NET" Value="Public Property StartupUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ StartupUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartupUri : Uri with get, set" Usage="System.Windows.Application.StartupUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia interfejs użytkownika, który jest automatycznie wyświetlany podczas uruchamiania aplikacji.</summary>
        <value><see cref="T:System.Uri" /> Odnosi się do interfejsu użytkownika, który jest automatycznie otwierany podczas uruchamiania aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Programu można użyć <xref:System.Windows.Application.StartupUri%2A> do automatycznego ładowania zasobu interfejsu użytkownika podczas uruchamiania aplikacji.  
  
 W poniższej tabeli przedstawiono typy zasobów interfejsu użytkownika, które mogą być ładowane, typ okna, w którym są otwierane, oraz typ aplikacji, które mogą być ustawiane jako <xref:System.Windows.Application.StartupUri%2A>.  
  
|Typ|Okno|Typ aplikacji|  
|----------|------------|----------------------|  
|<xref:System.Windows.Window>|<xref:System.Windows.Window>|Tylko wersja autonomiczna|  
|<xref:System.Windows.Navigation.NavigationWindow>|<xref:System.Windows.Navigation.NavigationWindow>|Tylko wersja autonomiczna|  
|<xref:System.Windows.Controls.Page>|<xref:System.Windows.Navigation.NavigationWindow>|Autonomiczna/hostowana w przeglądarce|  
|<xref:System.Windows.Controls.UserControl>|<xref:System.Windows.Navigation.NavigationWindow>|Autonomiczna/hostowana w przeglądarce|  
|<xref:System.Windows.Documents.FlowDocument>|<xref:System.Windows.Navigation.NavigationWindow>|Autonomiczna/hostowana w przeglądarce|  
|<xref:System.Windows.Navigation.PageFunction%601>|<xref:System.Windows.Navigation.NavigationWindow>|Autonomiczna/hostowana w przeglądarce|  
  
 Zazwyczaj właściwość jest <xref:System.Windows.Application.StartupUri%2A> ustawiana w sposób deklaratywny [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]w. Można jednak ustawić <xref:System.Windows.Application.StartupUri%2A> program programowo, na przykład <xref:System.Windows.Application.Startup> z programu obsługi zdarzeń, który jest przydatny, jeśli dla aplikacji, które mogą ładować wymagane zasoby interfejsu użytkownika w czasie wykonywania. Na przykład aplikacja może czekać do momentu uruchomienia w celu załadowania zasobów, jeśli nazwa zasobu interfejsu użytkownika jest przechowywana w pliku konfiguracji.  
  
 Niezależnie od tego <xref:System.Windows.Application.StartupUri%2A> <xref:System.Windows.Application.Startup> , czy jest ustawiony deklaratywny czy programowo, odpowiedni zasób interfejsu użytkownika nie jest ładowany do momentu obsługi zdarzenia. W związku z tym nie będziesz mieć dostępu do okna wyników z <xref:System.Windows.Application.Windows%2A> właściwości <xref:System.Windows.Application.MainWindow%2A> lub właściwości podczas obsługi <xref:System.Windows.Application.Startup>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Windows.Application.StartupUri" />ma ustawioną wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nazwa żądanej właściwości otoczenia.</param>
        <summary>Wykonuje zapytania dotyczące tego, czy określona właściwość otoczenia jest dostępna w bieżącym zakresie.</summary>
        <returns><see langword="true" />Jeśli żądana Właściwość otoczenia jest dostępna; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.Application> gdy wystąpienie jest rzutowane <xref:System.Windows.Markup.IQueryAmbient> do interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.IQueryAmbient" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="application.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Nazwa zasobu do wyszukania.</param>
        <summary>Wyszukuje określony zasób.</summary>
        <returns>Żądany obiekt zasobu. Jeśli żądany zasób nie zostanie znaleziony, zwracane jest odwołanie o wartości null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.TryFindResource%2A>najpierw Przyjrzyj się zasobom zakresu aplikacji dla określonego zasobu. Zasoby zakresu aplikacji są zarządzane przez <xref:System.Windows.Application>program i są dostępne <xref:System.Windows.Application.Resources%2A> z poziomu właściwości. Jeśli określony zasób nie zostanie znaleziony w zestawie zasobów zakresu aplikacji, <xref:System.Windows.Application.TryFindResource%2A> następnie następnym szuka zasobów systemu. Zasoby systemowe są zasobami powłoki zdefiniowanymi przez użytkownika i obejmują kolory, czcionki i konfiguracje powłoki. Są one udostępniane z <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, i <xref:System.Windows.SystemParameters> , odpowiednio, jako właściwości statyczne. Aby skorzystać <xref:System.Windows.Application.TryFindResource%2A> z programu w celu uzyskania tych typów, należy również uwidocznić właściwości klucza zasobu, które są <xref:System.Windows.Application.TryFindResource%2A>przeznaczone do przekazywania; <xref:System.Windows.SystemParameters.IconWidthKey%2A>na przykład.  
  
 Ponieważ <xref:System.Windows.Application.TryFindResource%2A> zwraca obiekt, należy rzutować zwróconą wartość na odpowiedni typ, jeśli zasób zostanie znaleziony.  
  
 Ta metoda jest bezpieczna wątkowo i może być wywoływana z dowolnego wątku.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób użycia <xref:System.Windows.Application.TryFindResource%2A> w celu uzyskania zasobu.  
  
 [!code-xaml[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/App.xaml#applicationcalltryfindresourcexaml)]  
  
 [!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind1)]
 [!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind1)]  
[!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind2)]
[!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Windows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection Windows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection Windows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Windows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Windows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ Windows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Windows : System.Windows.WindowCollection" Usage="System.Windows.Application.Windows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera okna utworzone w aplikacji.</summary>
        <value>A <see cref="T:System.Windows.WindowCollection" /> , który zawiera odwołania do wszystkich obiektów okien w bieżącym <see cref="T:System.AppDomain" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Odwołanie jest automatycznie dodawane do <xref:System.Windows.Application.Windows%2A> zaraz po utworzeniu wystąpienia okna w [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] wątku; system Windows, który jest tworzony przez wątki robocze, nie jest dodawany. <xref:System.Windows.Window> Odwołanie jest automatycznie usuwane <xref:System.Windows.Window.Closing> po obsłudze zdarzenia i przed podjęciem <xref:System.Windows.Window.Closed> zdarzenia. <xref:System.Windows.Window>  
  
 Domyślnie pierwszy element dodany do <xref:System.Windows.Application.Windows%2A> właściwości zostaje ustawiony na. <xref:System.Windows.Application.MainWindow%2A>  
  
 Ta właściwość jest dostępna tylko w wątku, który utworzył <xref:System.Windows.Application> obiekt.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak wyliczyć <xref:System.Windows.Application.Windows%2A> właściwość w celu utworzenia menu systemu Windows najwyższego poziomu, które jest [!INCLUDE[TLA#tla_mdi](~/includes/tlasharptla-mdi-md.md)] wspólne dla [!INCLUDE[TLA#tla_xl](~/includes/tlasharptla-xl-md.md)]aplikacji, takich jak aplikacje interfejsu jednostronicowego (SDI) o wielu wystąpieniach, takie jak [!INCLUDE[TLA#tla_word](~/includes/tlasharptla-word-md.md)].  
  
 [!code-csharp[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/WindowMenuItem.cs#windowmenuitemcode)]
 [!code-vb[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/windowmenuitem.vb#windowmenuitemcode)]  
  
 [!code-xaml[ApplicationWindowsSnippets#MainWindowSetWindowsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml#mainwindowsetwindowsxaml)]  
  
 [!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind1)]
 [!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind1)]  
[!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind2)]
[!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Window" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="Application" FullName="System.Windows.Application">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="eaedec6f4a42c946175d6b611e987e19396e32be" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36462389" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Application : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Application extends System.Windows.Threading.DispatcherObject implements class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Application" />
  <TypeSignature Language="VB.NET" Value="Public Class Application&#xA;Inherits DispatcherObject&#xA;Implements IQueryAmbient" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application : System::Windows::Threading::DispatcherObject, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type Application = class&#xA;    inherit DispatcherObject&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Hermetyzuje aplikacji Windows Presentation Foundation.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> Klasa, która hermetyzuje [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] funkcje specyficzne dla aplikacji, w tym następujące:  
  
-   **Cykl życia aplikacji**: <xref:System.Windows.Application.Activated>, <xref:System.Windows.Application.Current%2A>, <xref:System.Windows.Application.Deactivated>, <xref:System.Windows.Application.DispatcherUnhandledException>, <xref:System.Windows.Application.Exit>, <xref:System.Windows.Application.Run%2A>, <xref:System.Windows.Application.SessionEnding>, <xref:System.Windows.Application.Shutdown%2A>, <xref:System.Windows.Application.ShutdownMode%2A>, <xref:System.Windows.Application.Startup>.  
  
-   **Okno zakresu aplikacji, właściwości i zarządzanie zasobami**: <xref:System.Windows.Application.FindResource%2A>, <xref:System.Windows.Application.GetContentStream%2A>, <xref:System.Windows.Application.GetResourceStream%2A>, <xref:System.Windows.Application.LoadComponent%2A>, <xref:System.Windows.Application.MainWindow%2A>, <xref:System.Windows.Application.Properties%2A>, <xref:System.Windows.Application.Resources%2A>, <xref:System.Windows.Application.StartupUri%2A>, <xref:System.Windows.Application.Windows%2A>.  
  
-   **Parametr wiersza polecenia i zakończenia kodu przetwarzania**: <xref:System.Windows.Application.Startup?displayProperty=nameWithType>, <xref:System.Windows.Application.Exit?displayProperty=nameWithType>, <xref:System.Windows.Application.Shutdown%2A?displayProperty=nameWithType>.  
  
-   **Nawigacji**: <xref:System.Windows.Application.FragmentNavigation>, <xref:System.Windows.Application.LoadCompleted>, <xref:System.Windows.Application.Navigated>, <xref:System.Windows.Application.Navigating>, <xref:System.Windows.Application.NavigationProgress>, <xref:System.Windows.Application.NavigationStopped>, <xref:System.Windows.Application.NavigationFailed>, <xref:System.Windows.Application.SetCookie%2A>, <xref:System.Windows.Application.GetCookie%2A>.  
  
 <xref:System.Windows.Application> implementuje wzorzec singleton do udostępniają okna, właściwości i usług w zakresie zasobów. W związku z tym, tylko jedno wystąpienie <xref:System.Windows.Application> dla można utworzyć klasy <xref:System.AppDomain>.  
  
 Można zaimplementować <xref:System.Windows.Application> przy użyciu znaczników, znaczników i kodu powiązanego lub kodu. Jeśli <xref:System.Windows.Application> jest realizowana za pomocą znacznika, czy znaczniki lub znaczników i kodu powiązanego pliku znaczników musi być skonfigurowany jako [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] `ApplicationDefinition` elementu.  
  
> [!NOTE]
>  Nie wymaga aplikacja autonomiczna <xref:System.Windows.Application> obiekt; istnieje możliwość zaimplementowania niestandardowego `static` metoda punktu wejścia (`Main`) która powoduje otwarcie okna bez tworzenia wystąpienia <xref:System.Windows.Application>. Jednak [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] wymagają <xref:System.Windows.Application> obiektu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak standardowa aplikacja jest zdefiniowane przy użyciu tylko kod znaczników:  
  
 [!code-xaml[ApplicationSnippets#ApplicationMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppMarkup.xaml#applicationmarkup)]  
  
 W poniższym przykładzie przedstawiono sposób standardowej aplikacji jest definiowana za pomocą tylko kodu:  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppCode.cs#applicationcode)]
 [!code-vb[ApplicationSnippets#ApplicationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/appcode.vb#applicationcode)]  
  
 W poniższym przykładzie pokazano, jak standardowa aplikacja jest zdefiniowane przy użyciu kombinacji znaczników i związane z kodem.  
  
 [!code-xaml[ApplicationSnippets#ApplicationXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml#applicationxaml)]  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml.cs#applicationcodebehind)]
 [!code-vb[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/application.xaml.vb#applicationcodebehind)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Publicznego <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) elementy członkowskie tego typu są bezpieczne dla wątków. Ponadto <see cref="M:System.Windows.Application.FindResource(System.Object)" /> i <see cref="M:System.Windows.Application.TryFindResource(System.Object)" /> metod i <see cref="P:System.Windows.Application.Properties" /> i <see cref="P:System.Windows.Application.Resources" /> właściwości są bezpieczne dla wątków.</threadsafe>
    <altmember cref="T:System.Windows.Window" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Application ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Application();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Application" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tylko jedno wystąpienie <xref:System.Windows.Application> klasy można tworzyć na <xref:System.AppDomain>, aby zapewnić dostęp do jednego zestawu danych zakresu aplikacji okna, właściwości i zasobów. W rezultacie domyślny konstruktor obiektu <xref:System.Windows.Application> klasy wykrywa, czy wystąpienie inicjowany jest pierwsze wystąpienie w <xref:System.AppDomain>; Jeśli nie, <xref:System.InvalidOperationException> jest generowany.  
  
 <xref:System.Windows.Application> Obiektu dla bieżącej <xref:System.AppDomain> uwidocznioną z statycznych <xref:System.Windows.Application.Current%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Więcej niż jedno wystąpienie <see cref="T:System.Windows.Application" /> klasa jest tworzona na <see cref="T:System.AppDomain" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy aplikacja stanie się aplikacja pierwszego planu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aktywowano aplikację Windows Presentation Foundation, który ma co najmniej jednego okna (staje się pierwszoplanowych) po jest okien aktywować po raz pierwszy, ponieważ aplikacja została uruchomiona lub po aktywowaniu okien podczas Aplikacja jest nieaktywny: w szczególności aktywacji występuje, gdy:  
  
-   Otwiera się aplikacja jego pierwszym oknie.  
  
-   Użytkownik przełącza się do aplikacji za pomocą ALT + TAB lub za pomocą Menedżera zadań.  
  
-   Użytkownik klika przycisk paska zadań dla jednego z przedziałów czasu w aplikacji.  
  
 Aplikacje wymagające wykrycie, kiedy aktywują może obsłużyć <xref:System.Windows.Application.Activated> zdarzeń.  
  
 Po aktywowaniu aplikacji mogą być dezaktywowane i ponownie uaktywnić wiele razy w ciągu okresu jego istnienia. Jeśli stan lub zachowanie aplikacji jest zależny od stanu aktywacji, może obsługiwać oba <xref:System.Windows.Application.Activated> i <xref:System.Windows.Application.Deactivated> do zdarzeń, aby określić, które aktywacji stanie go.  
  
 Gdy aplikacja staje się aktywny, <xref:System.Windows.Application.Activated> nie będą zgłaszane ponownie dopóki aplikacja jest dezaktywowana, niezależnie od tego, jak wiele okien aplikacji zostaną aktywowane, podczas gdy aplikacja jest aktywna.  
  
 <xref:System.Windows.Application.Activated> nie jest wywoływane dla [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wykrycie, kiedy aplikacja autonomiczna aktywuje i dezaktywuje.  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Windows.Application Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Application Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Application ^ Current { System::Windows::Application ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Windows.Application" Usage="System.Windows.Application.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.Application" /> obiektu dla bieżącej <see cref="T:System.AppDomain" />.</summary>
        <value>
          <see cref="T:System.Windows.Application" /> Obiektu dla bieżącej <see cref="T:System.AppDomain" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> jest na-<xref:System.AppDomain> pojedynczego wystąpienia typu, który implementuje statycznych <xref:System.Windows.Application.Current%2A> właściwości udostępniają <xref:System.Windows.Application> wystąpienia dla bieżącego <xref:System.AppDomain>. Ten projekt gwarantuje Państwa zarządza <xref:System.Windows.Application>, łącznie z udostępnionymi zasobami i stan, jest dostępny w lokalizacji pojedynczego, współużytkowanego.  
  
 Ta właściwość jest bezpieczne dla wątków i jest dostępna z dowolnego wątku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy aplikacja przestaje jest aplikacja pierwszego planu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja Windows Presentation Foundation, która ma co najmniej jednego okna dezaktywuje (przestanie być pierwszoplanowych) gdy użytkownik wykonuje następujące czynności:  
  
-   Przełącza do innej aplikacji za pomocą ALT + TAB lub za pomocą Menedżera zadań.  
  
-   Kliknie przycisk paska zadań dla okna w innej aplikacji.  
  
 Aplikacje wymagające wykryć dezaktywacji może obsłużyć <xref:System.Windows.Application.Deactivated> zdarzeń.  
  
 Po aktywowaniu aplikacji mogą być dezaktywowane i ponownie uaktywnić wiele razy w ciągu okresu jego istnienia. Jeśli stan lub zachowanie aplikacji jest zależny od stanu aktywacji, może obsługiwać oba <xref:System.Windows.Application.Deactivated> i <xref:System.Windows.Application.Activated> zdarzeń, aby określić, które jej stanu użytkownika.  
  
 <xref:System.Windows.Application.Deactivated> nie jest wywoływane dla [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wykrycie, kiedy aplikacja autonomiczna dezaktywuje i aktywuje.  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Activated" />
      </Docs>
    </Member>
    <Member MemberName="DispatcherUnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.DispatcherUnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DispatcherUnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ DispatcherUnhandledException;" />
      <MemberSignature Language="F#" Value="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " Usage="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wyjątek jest generowany przez aplikację, ale nie jest obsługiwane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie Windows Presentation Foundation przechwytuje nieobsługiwanych wyjątków, powiadamia użytkowników wyjątku z okna dialogowego (w którym one zgłosić wyjątek) i zostaje automatycznie zamknięty aplikacji.  
  
 Jednak jeśli aplikacja musi wykonać niestandardowe nieobsługiwany wyjątek podczas przetwarzania ze scentralizowanej lokalizacji, powinna obsługiwać <xref:System.Windows.Application.DispatcherUnhandledException>.  
  
 <xref:System.Windows.Application.DispatcherUnhandledException> zostanie wywołane przez <xref:System.Windows.Application> dla każdego wyjątku, który jest nieobsługiwany przez kod działający w głównym wątku interfejsu użytkownika.  
  
 Jeśli wyjątek nie jest obsługiwana na albo tła wątku interfejsu użytkownika (wątków z własną <xref:System.Windows.Threading.Dispatcher>) lub wątku w tle proces roboczy (wątek bez <xref:System.Windows.Threading.Dispatcher>), wyjątek nie był kierowany do głównego wątku interfejsu użytkownika. W rezultacie <xref:System.Windows.Application.DispatcherUnhandledException> nie jest wywoływane. W takiej sytuacji należy napisać kod, aby wykonać następujące czynności:  
  
1.  Obsługa wyjątków w wątku tła.  
  
2.  Wysyłanie tych wyjątków w głównym wątku interfejsu użytkownika.  
  
3.  Rethrow je w głównym wątku interfejsu użytkownika bez ich, aby umożliwić obsługę <xref:System.Windows.Application.DispatcherUnhandledException> do wywołania.  
  
 Aby uzyskać więcej informacji, zobacz [Model wątkowy](~/docs/framework/wpf/advanced/threading-model.md) omówienie.  
  
 <xref:System.Windows.Application.DispatcherUnhandledException> Program obsługi zdarzeń jest przekazywany <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs> argument, który zawiera informacje kontekstowe dotyczące wyjątku, w tym:  
  
-   Wyjątek (<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A>).  
  
-   <xref:System.Windows.Threading.Dispatcher> z którego pochodzi (<xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A>).  
  
 Można użyć tych informacji do ustalenia, czy jest możliwe do odzyskania wyjątek, lub nie. Może być możliwe do odzyskania wyjątek <xref:System.IO.FileNotFoundException>, na przykład podczas wystąpił nieodwracalny wyjątek może być <xref:System.StackOverflowException>, np.  
  
 Podczas przetwarzania nieobsługiwany wyjątek z <xref:System.Windows.Application.DispatcherUnhandledException>, i nie chcesz [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] aby kontynuować przetwarzanie go, należy ustawić <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A> właściwości `true`.  
  
 W odróżnieniu od innych zdarzeń który <xref:System.Windows.Application> zgłasza, <xref:System.Windows.Application.DispatcherUnhandledException> jest nie ma odpowiadającego mu chronione wirtualnego implementacji (OnDispatcherUnhandledException). W rezultacie klasy który pochodzi od <xref:System.Windows.Application> zawsze należy zarejestrować program obsługi zdarzeń z <xref:System.Windows.Application.DispatcherUnhandledException> do przetwarzania nieobsługiwanych wyjątków.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób przetwarzania nieobsługiwanych wyjątków, obsługa <xref:System.Windows.Application.DispatcherUnhandledException> zdarzeń.  
  
 [!code-csharp[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind1)]
 [!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb#handledispatcherunhandledexceptioncodebehind1)]  
[!code-csharp[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind2)]
[!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb#handledispatcherunhandledexceptioncodebehind2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public event System.Windows.ExitEventHandler Exit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.ExitEventHandler Exit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exit As ExitEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::ExitEventHandler ^ Exit;" />
      <MemberSignature Language="F#" Value="member this.Exit : System.Windows.ExitEventHandler " Usage="member this.Exit : System.Windows.ExitEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ExitEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje zaraz przed aplikacja będzie zamykany i nie można anulować.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikację można zamknąć dla jednej z następujących powodów:  
  
-   <xref:System.Windows.Application.Shutdown%2A> Metody <xref:System.Windows.Application> obiektu po wywołaniu jawnie lub określone przez <xref:System.Windows.Application.ShutdownMode%2A> właściwości.  
  
-   Użytkownik kończy sesję przez wylogowanie lub zamykania.  
  
 Obsługa podczas zamykania aplikacji, można wykrywać <xref:System.Windows.Application.Exit> zdarzenia i wykonywać żadnych dodatkowych czynności, zgodnie z wymaganiami.  
  
 Można również obsługiwać <xref:System.Windows.Application.Exit> sprawdzić lub zmienić kod zakończenia aplikacji, gdy nie jest konieczne do wywołania <xref:System.Windows.Application.Shutdown%2A> jawnie. Kod zakończenia ma połączenie z <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> właściwość <xref:System.Windows.ExitEventArgs> argumentu przekazanego do <xref:System.Windows.Application.Exit> obsługi zdarzeń. Gdy aplikacja przestanie działać, kod zakończenia jest przekazywany do systemu operacyjnego dla dalszego przetwarzania.  
  
 Jeśli aplikacja obsługuje <xref:System.Windows.Application.SessionEnding> zdarzeń, a następnie anuluje, <xref:System.Windows.Application.Exit> nie jest wywoływane i uruchomione zgodnie z trybem zamknięcia aplikacji.  
  
 Można ustawić kodu zakończenia [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)], mimo że wartość jest ignorowana.  
  
 Aby uzyskać [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)], <xref:System.Windows.Application.Exit> jest zgłaszany w następujących okolicznościach:  
  
-   [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] Jest opuszczeniu.  
  
-   W [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)], gdy karta, który jest hostem [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] jest zamknięty.  
  
-   Gdy przeglądarka jest zamknięty.  
  
 We wszystkich przypadkach wartość <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> właściwość jest ignorowana.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób:  
  
-   Obsługa <xref:System.Windows.Application.Exit> zdarzeń.  
  
-   Przejrzyj i zaktualizuj <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> właściwość <xref:System.Windows.ExitEventArgs>.  
  
-   Zapisu do dziennika aplikacji w magazynie izolowanym.  
  
-   Utrwalanie stanu aplikacji do magazynu izolowanego.  
  
 [!code-xaml[ApplicationExitSnippets#HandleExitXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml#handleexitxaml)]  
  
 [!code-csharp[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml.cs#handleexitcodebehind)]
 [!code-vb[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationExitSnippets/visualbasic/application.xaml.vb#handleexitcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
        <altmember cref="T:System.IO.IsolatedStorage.IsolatedStorage" />
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="application.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Nazwa zasobu, aby znaleźć.</param>
        <summary>Wyszukuje [! INCLUDE[TLA#tla_ui](~/includes/tlasharptla-UI-MD.MD)] zasobów, takich jak <see cref="T:System.Windows.Style" /> lub <see cref="T:System.Windows.Media.Brush" />, z określonym kluczem i zgłasza wyjątek, jeśli żądany zasób nie zostanie znaleziony (zobacz — XAML zasobów (~/docs/framework/wpf/advanced/ XAML — resources.md)).</summary>
        <returns>Obiekt żądanego zasobu. Jeśli nie odnaleziono żądanego zasobu, <see cref="T:System.Windows.ResourceReferenceKeyNotFoundException" /> jest generowany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.FindResource%2A> najpierw sprawdza się w zasobach zakresu aplikacji dla określonego zasobu. Zasoby zakresu aplikacji są zarządzane przez <xref:System.Windows.Application>i są dostępne z <xref:System.Windows.Application.Resources%2A> właściwości. Jeśli określony zasób nie zostanie znaleziony w zestawie zasobów zakresu aplikacji <xref:System.Windows.Application.FindResource%2A> następnie wyszukuje zasobów systemowych. Zasoby systemowe są shell zasoby zdefiniowane przez użytkownika i Dołącz kolory, czcionki i konfiguracje powłoki. Są one dostępne z <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, i <xref:System.Windows.SystemParameters> typy odpowiednio właściwości statycznej. Aby użyć <xref:System.Windows.Application.FindResource%2A> uzyskać je, te typy również ujawniać klucza właściwości zasobów, które są przeznaczone do przekazania do <xref:System.Windows.Application.FindResource%2A>, na przykład <xref:System.Windows.SystemParameters.IconWidthKey%2A>.  
  
 Ponieważ <xref:System.Windows.Application.FindResource%2A> zwraca obiekt, należy rzutować zwrócona wartość do odpowiedniego typu, jeśli zasób znajduje się.  
  
> [!IMPORTANT]
>  Jeśli ta metoda jest wywoływana dla klucza, którego nie można znaleźć, jest zwracany wyjątek. Jeśli nie chcesz obsługi wyjątków, wynikających z wywołaniem <xref:System.Windows.Application.FindResource%2A>, wywołaj <xref:System.Windows.Application.TryFindResource%2A> zamiast; <xref:System.Windows.Application.TryFindResource%2A> zwraca `null` się odwołać, kiedy nie można odnaleźć żądanego zasobu i nie zgłasza wyjątek.  
  
 Ta metoda jest bezpieczne dla wątków i może zostać wywołana z dowolnego wątku.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Windows.Application.FindResource%2A> można znaleźć zasobu, a także do obsługi <xref:System.Windows.ResourceReferenceKeyNotFoundException> Jeśli zasób nie zostanie znaleziony.  
  
 [!code-csharp[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcallfindresourcecodebehind)]
 [!code-vb[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcallfindresourcecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">Nie można odnaleźć zasobu.</exception>
        <altmember cref="M:System.Windows.Application.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Event FragmentNavigation As FragmentNavigationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberSignature Language="F#" Value="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " Usage="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy navigator w aplikacji rozpoczęciu nawigacji do fragmentu zawartości nawigacji natychmiast występuje w przypadku żądanego fragmentu w bieżącej zawartości lub po źródła [! Zawartość include[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-MD.MD)] został załadowany w przypadku żądanego fragmentu w innej zawartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nawigator jest <xref:System.Windows.Navigation.NavigationWindow> lub <xref:System.Windows.Controls.Frame>.  
  
 Zobacz <xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetContentStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetContentStream (Uri uriContent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetContentStream(class System.Uri uriContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetContentStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetContentStream (uriContent As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetContentStream(Uri ^ uriContent);" />
      <MemberSignature Language="F#" Value="static member GetContentStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetContentStream uriContent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriContent" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriContent">Względne <see cref="T:System.Uri" /> mapujący do utracić zasobu.</param>
        <summary>Zwraca strumień zasobu dla pliku danych zawartości, który znajduje się w określonym <see cref="T:System.Uri" /> (zobacz [zasób w aplikacji WPF, zawartość i Files](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)) danych.</summary>
        <returns>A <see cref="T:System.Windows.Resources.StreamResourceInfo" /> zawierający plik danych zawartości, która znajduje się w określonym <see cref="T:System.Uri" />. Jeśli nie można odnaleźć zasobu utracić, zwracana jest wartość null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest bezpieczne dla wątków.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Uri" /> Przekazywany do <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Uri" /> Przekazywany do <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> jest bezwzględnym <see cref="T:System.Uri" />.</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetCookie">
      <MemberSignature Language="C#" Value="public static string GetCookie (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCookie(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetCookie(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCookie(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="static member GetCookie : Uri -&gt; string" Usage="System.Windows.Application.GetCookie uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">
          <see cref="T:System.Uri" /> , Który określa lokalizację, dla którego utworzono plik cookie.</param>
        <summary>Pobiera plik cookie dla lokalizacji określonej przez <see cref="T:System.Uri" />.</summary>
        <returns>A <see cref="T:System.String" /> wartość, jeśli istnieje plik cookie; w przeciwnym razie <see cref="T:System.ComponentModel.Win32Exception" /> jest generowany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.GetCookie%2A> pobiera plik cookie dla określonego <xref:System.Uri>. Jeśli nie można pobrać pliku cookie, <xref:System.ComponentModel.Win32Exception> jest generowany. Należy napisać kod do analizowania pliku cookie na listę par nazwa/wartość.  
  
 Przegląd plików cookie w [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)], zobacz [omówienie nawigacji](~/docs/framework/wpf/app-development/navigation-overview.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">A [! Błąd include[TLA#tla_win32](~/includes/tlasharptla-Win32-MD.MD)] przez <see langword="InternetGetCookie" /> — funkcja (wywoływane przez <see cref="M:System.Windows.Application.GetCookie(System.Uri)" />) Jeśli wystąpi problem podczas próby pobrania określonego pliku cookie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do pobierania plików cookie dla opartą na plikach <see cref="T:System.Uri" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">do pobierania plików cookie dla pliku nieopartych <see cref="T:System.Uri" />. Wyliczenie skojarzone: <see cref="P:System.Net.WebPermission.ConnectList" /></permission>
        <altmember cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRemoteStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetRemoteStream (Uri uriRemote);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetRemoteStream(class System.Uri uriRemote) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRemoteStream (uriRemote As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetRemoteStream(Uri ^ uriRemote);" />
      <MemberSignature Language="F#" Value="static member GetRemoteStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetRemoteStream uriRemote" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriRemote" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriRemote">
          <see cref="T:System.Uri" /> Mapuje utracić zasobów w witrynie pochodzenia.</param>
        <summary>Zwraca strumień zasobu dla pliku witryny pochodzenia danych, który znajduje się w określonym <see cref="T:System.Uri" /> (zobacz [zasób w aplikacji WPF, zawartość i pliki danych] (~/docs/framework/wpf/app-development/ WPF-Application-Resource-Content-and-Data-Files.MD)).</summary>
        <returns>A <see cref="T:System.Windows.Resources.StreamResourceInfo" /> zawierający strumienia zasobu dla pliku witryny pochodzenia danych, który znajduje się w określonym <see cref="T:System.Uri" />. Jeśli nie można odnaleźć zasobu utracić, <see langword="null" /> jest zwracany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest bezpieczne dla wątków.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Uri" /> Przekazywany do <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Uri" /> Przekazywany do <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> nie jest względną lub bezwzględną, ale nie w <c>formy :,,,/</c> formularza.</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetResourceStream (Uri uriResource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetResourceStream(class System.Uri uriResource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetResourceStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetResourceStream (uriResource As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetResourceStream(Uri ^ uriResource);" />
      <MemberSignature Language="F#" Value="static member GetResourceStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetResourceStream uriResource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriResource" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriResource">
          <see cref="T:System.Uri" /> Mapujący osadzonego zasobu.</param>
        <summary>Zwraca strumień zasobu dla pliku danych zasobów, które znajduje się w określonym <see cref="T:System.Uri" /> (zobacz [zasób w aplikacji WPF, zawartość i Files](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)) danych.</summary>
        <returns>A <see cref="T:System.Windows.Resources.StreamResourceInfo" /> zawierający strumienia zasobu dla pliku danych zasobów, które znajduje się w określonym <see cref="T:System.Uri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest bezpieczne dla wątków.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Uri" /> Przekazywany do <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Uri" /> Przekazywany do <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> nie jest względną lub bezwzględną, ale nie w <c>pack://application :,,,/</c> formularza.</exception>
        <exception cref="T:System.IO.IOException">
          <see cref="T:System.Uri" /> Przekazywany do <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> nie można odnaleźć.</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zawartość, która została przejście przez nawigatora w aplikacji został załadowany, przeanalizować i zostało uruchomione renderowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nawigator jest <xref:System.Windows.Navigation.NavigationWindow> lub <xref:System.Windows.Controls.Frame>.  
  
 Zobacz <xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Nasłuchiwanie zdarzeń nawigować zawartości, takich jak <xref:System.Windows.FrameworkElement.Loaded> zdarzenia w <xref:System.Windows.Controls.Page> Aby uzyskać dostęp do właściwości nawigować zawartości.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadComponent">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obciążenia [! Plik include[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-MD.MD)], który znajduje się w określonym [! INCLUDE[TLA#tla_uri](~/includes/tlasharptla-URI-MD.MD)].</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] Plik może być plik kodu aplikacji (skonfigurowany jako [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] elementu strony) lub pliku danych aplikacji (pliku zasobu, plik zawartości lub witryny pochodzenia pliku; zobacz [zasób w aplikacji WPF, zawartość i pliki danych](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  Ta metoda nie jest metodą o bezpiecznych wątkach.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static object LoadComponent (Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object LoadComponent(class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadComponent (resourceLocator As Uri) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ LoadComponent(Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : Uri -&gt; obj" Usage="System.Windows.Application.LoadComponent resourceLocator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="resourceLocator">A <see cref="T:System.Uri" /> mapuje względny [! Plik include[TLA2#tla_xaml](~/includes/tla2sharptla-XAML-MD.MD)].</param>
        <summary>Obciążenia [! Plik include[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-MD.MD)], który znajduje się w określonym [! INCLUDE[TLA#tla_uri](~/includes/tlasharptla-URI-MD.MD)] i konwertuje ją na wystąpienie obiektu, który jest określony przez element główny [! Plik include[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-MD.MD)].</summary>
        <returns>Wystąpienie elementu głównego określone przez plik XAML załadowany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana musi jawnie przekonwertować na ten sam typ jako element główny [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] pliku.  
  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] Plik może być plik kodu aplikacji (skonfigurowany jako [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] elementu strony) lub pliku danych aplikacji (pliku zasobu, plik zawartości lub witryny pochodzenia pliku; zobacz [zasób w aplikacji WPF, zawartość i pliki danych](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  Ta metoda nie jest metodą o bezpiecznych wątkach.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceLocator" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceLocator" /> Jest bezwzględnym [! INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-URI-MD.MD)].</exception>
        <exception cref="T:System.Exception">Plik nie jest [! Plik include[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-MD.MD)].</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static void LoadComponent (object component, Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LoadComponent(object component, class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Object,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LoadComponent (component As Object, resourceLocator As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LoadComponent(System::Object ^ component, Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : obj * Uri -&gt; unit" Usage="System.Windows.Application.LoadComponent (component, resourceLocator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="component">Obiekt tego samego typu jako element główny [! Plik include[TLA2#tla_xaml](~/includes/tla2sharptla-XAML-MD.MD)].</param>
        <param name="resourceLocator">A <see cref="T:System.Uri" /> mapuje względny [! Plik include[TLA2#tla_xaml](~/includes/tla2sharptla-XAML-MD.MD)].</param>
        <summary>Obciążenia [! Plik include[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-MD.MD)], który znajduje się w określonym [! INCLUDE[TLA#tla_uri](~/includes/tlasharptla-URI-MD.MD)] i konwertuje ją na wystąpienie obiektu, który jest określony przez element główny [! Plik include[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-MD.MD)].</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] Plik może być plik kodu aplikacji (skonfigurowany jako [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] elementu strony) lub pliku danych aplikacji (pliku zasobu, plik zawartości lub witryny pochodzenia pliku; zobacz [zasób w aplikacji WPF, zawartość i pliki danych](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  Ta metoda nie jest metodą o bezpiecznych wątkach.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceLocator" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceLocator" /> Jest bezwzględnym [! INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-URI-MD.MD)].</exception>
        <exception cref="T:System.Exception">
          <paramref name="component" /> jest typu, który jest niezgodny z elementem głównym [! Plik include[TLA2#tla_xaml](~/includes/tla2sharptla-XAML-MD.MD)].</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="MainWindow">
      <MemberSignature Language="C#" Value="public System.Windows.Window MainWindow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window MainWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.MainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Property MainWindow As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ MainWindow { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MainWindow : System.Windows.Window with get, set" Usage="System.Windows.Application.MainWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia głównego okna aplikacji.</summary>
        <value>A <see cref="T:System.Windows.Window" /> wyznaczony jako okna głównego aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.MainWindow%2A> jest automatycznie ustawiana z odwołaniem do pierwszej <xref:System.Windows.Window> obiektu do użycia w <xref:System.AppDomain>.  
  
 Można określić różne okno główne przez ustawienie <xref:System.Windows.Application.MainWindow%2A> przypisywanie innego <xref:System.Windows.Application.Windows%2A> do obiektu <xref:System.Windows.Application.MainWindow%2A> właściwości.  
  
 Jeśli <xref:System.Windows.Application.ShutdownMode%2A> właściwość <xref:System.Windows.Application> obiektu ma ustawioną wartość <xref:System.Windows.ShutdownMode.OnMainWindowClose>, zamknięcie okna głównego powoduje, że aplikacja jest zamykana.  
  
 Można ustawić <xref:System.Windows.Application.MainWindow%2A> właściwość z [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)], jeśli głównego okna aplikacji nie jest okno jest generowany przez ustawienie <xref:System.Windows.Application.StartupUri%2A> właściwości w [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]. Dwa ograniczenia [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] podejścia są:  
  
-   Można określić [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-tylko <xref:System.Windows.Window> lub [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-tylko <xref:System.Windows.Navigation.NavigationWindow> jako głównego okna.  
  
-   Należy ustawić <xref:System.Windows.UIElement.Visibility%2A> Określ właściwość okna, w przeciwnym razie nie będą wyświetlane.  
  
 Odwołanie do pierwszej <xref:System.Windows.Window> można utworzyć wystąpienia obiektu jest także dodawane jako pierwszy element do <xref:System.Windows.Application.Windows%2A> kolekcji. Jeśli <xref:System.Windows.Application.MainWindow%2A> zostanie ustawiony z odwołaniem do innej <xref:System.Windows.Window>, podczas kolejności elementów w pozycji elementu z odwołaniem do głównego okna zmieni <xref:System.Windows.Application.Windows%2A> jest taka sama. W związku z tym, należy zawsze używać <xref:System.Windows.Application.MainWindow%2A> do odwoływania się do głównego okna zamiast pierwszy element <xref:System.Windows.Application.Windows%2A>.  
  
> [!NOTE]
>  Jeśli okno główne jest <xref:System.Windows.Navigation.NavigationWindow>, i wymagają określonym dostępu do <xref:System.Windows.Navigation.NavigationWindow> członków, należy rzutować wartości <xref:System.Windows.Application.MainWindow%2A> do <xref:System.Windows.Navigation.NavigationWindow>.  
>   
>  Ta właściwość jest dostępna tylko w wątku, który utworzony <xref:System.Windows.Application> obiektu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak można znaleźć w oknie głównym aplikacji.  
  
 [!code-csharp[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationMainWindowSnippets/CSharp/App.xaml.cs#getapplicationmainwindowcode)]
 [!code-vb[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationMainWindowSnippets/visualbasic/application.xaml.vb#getapplicationmainwindowcode)]  
  
 Poniższy przykład przedstawia sposób ustawiania <xref:System.Windows.Application.MainWindow%2A> przy użyciu [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)].  
  
 [!code-xaml[ApplicationMainWindowSnippets#SetApplicationMainWindowXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/ApplicationMainWindowSnippets/XAML/App.xaml#setapplicationmainwindowxaml)]  
  
 Poniższy przykład przedstawia sposób tworzenia wystąpienia <xref:System.Windows.Application.MainWindow%2A> w kodzie podczas uruchamiania aplikacji.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/App.xaml.cs#firstwindowusingcodecodebehind)]
 [!code-vb[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/application.xaml.vb#firstwindowusingcodecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Application.MainWindow" /> ustawiono z aplikacji, która znajduje się w przeglądarce, takie jak [! INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-MD.MD)].</exception>
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zawartość, która jest trwa przejście przez nawigatora w aplikacji został znaleziony, mimo że nie może zakończyć się ładowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nawigator jest <xref:System.Windows.Navigation.NavigationWindow> lub <xref:System.Windows.Controls.Frame>.  
  
 Zobacz <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy nowy nawigacji jest wymagany przez nawigatora w aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nawigator jest <xref:System.Windows.Navigation.NavigationWindow> lub <xref:System.Windows.Controls.Frame>.  
  
 Zobacz <xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberSignature Language="F#" Value="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " Usage="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wystąpi błąd, gdy navigator w aplikacji jest nawigowania do żądanej zawartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nawigator jest <xref:System.Windows.Navigation.NavigationWindow> lub <xref:System.Windows.Controls.Frame>.  
  
 Zobacz <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationProgress As NavigationProgressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberSignature Language="F#" Value="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " Usage="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje okresowo podczas pobierania, który jest zarządzany przez nawigatora w aplikacji, aby podać informacje o postępie nawigacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nawigator jest <xref:System.Windows.Navigation.NavigationWindow> lub <xref:System.Windows.Controls.Frame>.  
  
 Zobacz <xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationStopped As NavigationStoppedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberSignature Language="F#" Value="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " Usage="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see langword="StopLoading" /> wywoływana jest metoda navigator w aplikacji lub gdy nowe nawigacji jest wymagany przez nawigatora w trakcie bieżącego nawigacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nawigator jest <xref:System.Windows.Navigation.NavigationWindow> lub <xref:System.Windows.Controls.Frame>.  
  
 Zobacz <xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="application.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Application.Activated" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnActivated%2A> zgłasza <xref:System.Windows.Application.Activated> zdarzeń.  
  
 Typ, który pochodzi z <xref:System.Windows.Application> może zastąpić <xref:System.Windows.Application.OnActivated%2A>. Należy wywołać przeciążonej <xref:System.Windows.Application.OnActivated%2A> w klasie podstawowej Jeśli <xref:System.Windows.Application.Activated> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="application.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Application.Deactivated" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnDeactivated%2A> zgłasza <xref:System.Windows.Application.Deactivated> zdarzeń.  
  
 Typ, który pochodzi z <xref:System.Windows.Application> może zastąpić <xref:System.Windows.Application.OnDeactivated%2A>. Należy wywołać przeciążonej <xref:System.Windows.Application.OnDeactivated%2A> w klasie podstawowej Jeśli <xref:System.Windows.Application.Deactivated> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnExit">
      <MemberSignature Language="C#" Value="protected virtual void OnExit (System.Windows.ExitEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnExit(class System.Windows.ExitEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnExit (e As ExitEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnExit(System::Windows::ExitEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnExit : System.Windows.ExitEventArgs -&gt; unit&#xA;override this.OnExit : System.Windows.ExitEventArgs -&gt; unit" Usage="application.OnExit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.ExitEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.ExitEventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Application.Exit" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnExit%2A> zgłasza <xref:System.Windows.Application.Exit> zdarzeń.  
  
 Typ, który pochodzi z <xref:System.Windows.Application> może zastąpić <xref:System.Windows.Application.OnExit%2A> metody. Należy wywołać przeciążonej <xref:System.Windows.Application.OnExit%2A> w klasie podstawowej Jeśli <xref:System.Windows.Application.Exit> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFragmentNavigation">
      <MemberSignature Language="C#" Value="protected virtual void OnFragmentNavigation (System.Windows.Navigation.FragmentNavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFragmentNavigation(class System.Windows.Navigation.FragmentNavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFragmentNavigation (e As FragmentNavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFragmentNavigation(System::Windows::Navigation::FragmentNavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit&#xA;override this.OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit" Usage="application.OnFragmentNavigation e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.FragmentNavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Navigation.FragmentNavigationEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Application.FragmentNavigation" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnFragmentNavigation%2A> zgłasza <xref:System.Windows.Application.FragmentNavigation> zdarzeń.  
  
 Typ, który pochodzi z <xref:System.Windows.Application> może zastąpić <xref:System.Windows.Application.OnFragmentNavigation%2A>. Należy wywołać przeciążonej <xref:System.Windows.Application.OnFragmentNavigation%2A> w klasie podstawowej Jeśli <xref:System.Windows.Application.FragmentNavigation> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnLoadCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadCompleted (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadCompleted(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoadCompleted (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoadCompleted(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnLoadCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Navigation.NavigationEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Application.LoadCompleted" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnLoadCompleted%2A> zgłasza <xref:System.Windows.Application.LoadCompleted> zdarzeń.  
  
 Typ, który pochodzi z <xref:System.Windows.Application> może zastąpić <xref:System.Windows.Application.OnLoadCompleted%2A>. Należy wywołać przeciążonej <xref:System.Windows.Application.OnLoadCompleted%2A> w klasie podstawowej Jeśli <xref:System.Windows.Application.LoadCompleted> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigated">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigated (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigated(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigated (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigated(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Navigation.NavigationEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Application.Navigated" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigated%2A> zgłasza <xref:System.Windows.Application.Navigated> zdarzeń.  
  
 Typ, który pochodzi z <xref:System.Windows.Application> może zastąpić <xref:System.Windows.Application.OnNavigated%2A>. Należy wywołać przeciążonej <xref:System.Windows.Application.OnNavigated%2A> w klasie podstawowej Jeśli <xref:System.Windows.Application.Navigated> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigating">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigating (System.Windows.Navigation.NavigatingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigating(class System.Windows.Navigation.NavigatingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigating (e As NavigatingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigating(System::Windows::Navigation::NavigatingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit&#xA;override this.OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit" Usage="application.OnNavigating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigatingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Navigation.NavigatingCancelEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Application.Navigating" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigating%2A> zgłasza <xref:System.Windows.Application.Navigating> zdarzeń.  
  
 Typ, który pochodzi z <xref:System.Windows.Application> może zastąpić <xref:System.Windows.Application.OnNavigating%2A>. Należy wywołać przeciążonej <xref:System.Windows.Application.OnNavigating%2A> w klasie podstawowej Jeśli <xref:System.Windows.Application.Navigating> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationFailed">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationFailed (System.Windows.Navigation.NavigationFailedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationFailed(class System.Windows.Navigation.NavigationFailedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationFailed (e As NavigationFailedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationFailed(System::Windows::Navigation::NavigationFailedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit&#xA;override this.OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit" Usage="application.OnNavigationFailed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationFailedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Navigation.NavigationFailedEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Application.NavigationFailed" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationFailed%2A> zgłasza <xref:System.Windows.Application.NavigationFailed> zdarzeń.  
  
 Typ, który pochodzi z <xref:System.Windows.Application> może zastąpić <xref:System.Windows.Application.OnNavigationFailed%2A>. Należy wywołać przeciążonej <xref:System.Windows.Application.OnNavigationFailed%2A> w klasie podstawowej Jeśli <xref:System.Windows.Application.NavigationFailed> musi zostać wywołane.  
  
   
  
## Examples  
 <xref:System.Windows.Application.OnFragmentNavigation%2A>  
  
 <xref:System.Windows.Application.OnLoadCompleted%2A>  
  
 <xref:System.Windows.Application.OnNavigating%2A>  
  
 <xref:System.Windows.Application.OnNavigated%2A>  
  
 <xref:System.Windows.Application.OnNavigationProgress%2A>  
  
 <xref:System.Windows.Application.OnNavigationStopped%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNavigationProgress">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationProgress (System.Windows.Navigation.NavigationProgressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationProgress(class System.Windows.Navigation.NavigationProgressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationProgress (e As NavigationProgressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationProgress(System::Windows::Navigation::NavigationProgressEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit&#xA;override this.OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit" Usage="application.OnNavigationProgress e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationProgressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Navigation.NavigationProgressEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Application.NavigationProgress" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationProgress%2A> zgłasza <xref:System.Windows.Application.NavigationProgress> zdarzeń.  
  
 Typ, który pochodzi z <xref:System.Windows.Application> może zastąpić <xref:System.Windows.Application.OnNavigationProgress%2A>. Przeciążonej musi jawnie wywołać <xref:System.Windows.Application.OnNavigationProgress%2A> w klasie podstawowej Jeśli <xref:System.Windows.Application.NavigationProgress> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationStopped">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationStopped (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationStopped(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationStopped (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationStopped(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigationStopped e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Navigation.NavigationEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Application.NavigationStopped" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationStopped%2A> zgłasza <xref:System.Windows.Application.NavigationStopped> zdarzeń.  
  
 Typ, który pochodzi z <xref:System.Windows.Application> może zastąpić <xref:System.Windows.Application.OnNavigationStopped%2A>. Należy wywołać przeciążonej <xref:System.Windows.Application.OnNavigationStopped%2A> w klasie podstawowej Jeśli <xref:System.Windows.Application.NavigationStopped> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionEnding">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionEnding (System.Windows.SessionEndingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionEnding(class System.Windows.SessionEndingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionEnding (e As SessionEndingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionEnding(System::Windows::SessionEndingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit&#xA;override this.OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit" Usage="application.OnSessionEnding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.SessionEndingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.SessionEndingCancelEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Application.SessionEnding" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnSessionEnding%2A> zgłasza <xref:System.Windows.Application.SessionEnding> zdarzeń.  
  
 Typ, który pochodzi z <xref:System.Windows.Application> może zastąpić <xref:System.Windows.Application.OnSessionEnding%2A>. Należy wywołać przeciążonej <xref:System.Windows.Application.OnSessionEnding%2A> w klasie podstawowej Jeśli <xref:System.Windows.Application.SessionEnding> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStartup">
      <MemberSignature Language="C#" Value="protected virtual void OnStartup (System.Windows.StartupEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStartup(class System.Windows.StartupEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStartup (e As StartupEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStartup(System::Windows::StartupEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStartup : System.Windows.StartupEventArgs -&gt; unit&#xA;override this.OnStartup : System.Windows.StartupEventArgs -&gt; unit" Usage="application.OnStartup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.StartupEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.StartupEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Application.Startup" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnStartup%2A> zgłasza <xref:System.Windows.Application.Startup> zdarzeń.  
  
 Typ, który pochodzi z <xref:System.Windows.Application> może zastąpić <xref:System.Windows.Application.OnStartup%2A>. Należy wywołać przeciążonej <xref:System.Windows.Application.OnStartup%2A> w klasie podstawowej Jeśli <xref:System.Windows.Application.Startup> zdarzenia musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Properties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Properties { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Collections.IDictionary" Usage="System.Windows.Application.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję właściwości zakresu aplikacji.</summary>
        <value>
          <see cref="T:System.Collections.IDictionary" /> Zawierający właściwości zakresu aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> udostępnia słownik za pośrednictwem <xref:System.Windows.Application.Properties%2A> służącego do zapisania właściwości zakresu aplikacji. Dzięki temu można udostępnić stanu między cały kod w <xref:System.AppDomain> w sposób wątkowo, bez konieczności napisać własny kod stanu.  
  
 Właściwości przechowywanych we <xref:System.Windows.Application.Properties%2A> muszą zostać skonwertowane do odpowiedni typ zwracany.  
  
 <xref:System.Windows.Application.Properties%2A> Właściwość wielowątkowość i jest dostępny z dowolnego wątku.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono sposób tworzenia i używania, za pomocą właściwości zakresu aplikacji <xref:System.Windows.Application.Properties%2A>.  
  
 [!code-xaml[ApplicationPropertiesSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml1)]  
[!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml2)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml.cs#mainwindowgetpropertycodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/mainwindow.xaml.vb#mainwindowgetpropertycodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="ResourceAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ResourceAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Assembly ResourceAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ResourceAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ResourceAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Assembly ^ ResourceAssembly { System::Reflection::Assembly ^ get(); void set(System::Reflection::Assembly ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResourceAssembly : System.Reflection.Assembly with get, set" Usage="System.Windows.Application.ResourceAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Reflection.Assembly" /> zapewnia pakiet [! INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-MD.MD)] dla zasobów w [! Aplikacja include[TLA2#tla_wpf](~/includes/tla2sharptla-WPF-MD.MD)].</summary>
        <value>Odwołanie do <see cref="T:System.Reflection.Assembly" /> zapewnia pakiet [! INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-MD.MD)] dla zasobów w [! Aplikacja include[TLA2#tla_wpf](~/includes/tla2sharptla-WPF-MD.MD)].</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] zasoby zostaną rozwiązane w czasie wykonywania względem zestawu wpis, który jest identyfikowany przez wartość zwracana z <xref:System.Reflection.Assembly.GetEntryAssembly%2A> metody.  
  
 Zestaw wpis jest zestawu, który jest zwracany przez <xref:System.Reflection.Assembly.GetEntryAssembly%2A> i mogą być następujące:  
  
-   Zestaw pliku wykonywalnego w domyślnej domeny aplikacji.  
  
-   Pierwszy zestaw ma być wykonane przez wywołanie <xref:System.AppDomain.ExecuteAssembly%2A>.  
  
 W następujących przypadkach, jednak [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] zestawu nie można pobrać odwołania do zestawu wpis:  
  
-   Hosty niezarządzanych aplikacji (natywna) [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] zestawu.  
  
-   Hosty zarządzanej aplikacji [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] zestawu przez załadowanie go do nowej domeny aplikacji przy użyciu metody inne niż <xref:System.AppDomain.ExecuteAssembly%2A>.  
  
 W obu przypadkach <xref:System.Reflection.Assembly.GetEntryAssembly%2A> zwraca `null`i [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] zasobów zestawu nie można rozpoznać. W takich przypadkach <xref:System.Windows.Application.ResourceAssembly%2A> można ustawić, tylko raz, w odniesieniu do zestawu, który powinien być używany do rozpoznania zasobów.  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> można ustawić tylko raz, ponieważ jest mało prawdopodobne, że zestaw zasobów ulegnie zmianie po [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] zestaw jest ładowany.  
  
> [!NOTE]
>  <xref:System.Windows.Application.ResourceAssembly%2A> Nie można ustawić podczas [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] zestawu można odnaleźć wpisu zestawu — to znaczy, jeśli <xref:System.Reflection.Assembly.GetEntryAssembly%2A> zwraca odwołanie do zestawu zamiast `null`.  
  
 Ta właściwość jest bezpieczne dla wątków i jest dostępna z dowolnego wątku.  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> wprowadzono w programie .NET Framework w wersji 3.5.  Aby uzyskać więcej informacji, zobacz [wersje i zależności](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A [! Aplikacja include[TLA2#tla_wpf](~/includes/tla2sharptla-WPF-MD.MD)] ma zestaw wpis lub <see cref="P:System.Windows.Application.ResourceAssembly" /> został już ustawiony.</exception>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.Application.Resources" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolekcję zasobów zakres aplikacji, takich jak style i pędzle.</summary>
        <value>A <see cref="T:System.Windows.ResourceDictionary" /> obiekt zawierający zero lub więcej zasobów zakresu aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Resources%2A> Właściwości może służyć do udostępniania zasobów między systemem windows i elementy aplikacji. Ponadto <xref:System.Windows.Application.Resources%2A> właściwości znajduje się w ścieżce wyszukiwania zasobów jest przesunięta w następującej kolejności:  
  
1.  Elementy  
  
2.  Windows  
  
3.  <xref:System.Windows.Application.Resources%2A?displayProperty=nameWithType>  
  
4.  System  
  
 W rezultacie [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] elementów można powiązać z zakresu aplikacji zasobów. Ponadto jeśli zmiana zasobów, zasobów systemu zapewnia elementu właściwości, które są powiązane z tych zasobów są automatycznie aktualizowane w celu odzwierciedlenia zmian.  
  
 Zakres aplikacji zasobów zapewniają prosty sposób obsługi motywu spójne w aplikacji. Można jednak łatwo tworzyć motywu w [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] przy użyciu `Application.Resources` tagu. Jednak jeśli aplikacja obsługuje wiele motywów, które mogą zawierać dużą liczbę elementy kompozycja, może być łatwiej zarządzać nimi przy użyciu jednej <xref:System.Windows.ResourceDictionary> wystąpienia dla każdej kompozycji. W ten sposób można zastosować nową kompozycję przez ustawienie właściwości zasobów do odpowiedniego <xref:System.Windows.ResourceDictionary>.  
  
 Istnieją dwa zagadnienia dotyczące podczas korzystania z <xref:System.Windows.Application.Resources%2A>. Po pierwsze, słownik *klucza* jest obiektem, dlatego należy użyć dokładnie tego samego wystąpienia obiektu podczas zarówno ustawiania i pobierania wartości właściwości (Uwaga klucz jest rozróżniana wielkość liter, korzystając z ciągu). Drugi, słownik *wartość* jest obiektem, dzięki czemu będzie trzeba przekonwertować wartości na żądany typ. podczas pobierania wartości właściwości.  
  
 <xref:System.Windows.Application.Resources%2A> wielowątkowość i jest dostępny z dowolnego wątku.  
  
   
  
## Examples  
 W tym przykładzie przedstawiono metodę zastosowania [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] wraz z zakresu aplikacji zasoby do utworzenia spójny wygląd.  
  
 [!code-xaml[ApplicationResourcesSnippets#ResourcesPropertyXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/App.xaml#resourcespropertyxaml)]  
  
 [!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml#windowbackgroundpropertyxaml1)]  
[!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml#windowbackgroundpropertyxaml2)]  
  
 Poniższy przykład pokazuje, jak ustawić zasobu aplikacji w kodzie i pliku XAML.  
  
 [!code-csharp[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#setapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#setapplicationscoperesourcecode)]  
  
 [!code-xaml[HOWTOApplicationModelSnippets#SetApplicationScopeResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/App.xaml#setapplicationscoperesourcexaml)]  
  
 Poniższy przykład pokazuje, jak można pobrać zasobów aplikacji w kodzie.  
  
 [!code-csharp[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#getapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#getapplicationscoperesourcecode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uruchamia aplikację systemu Windows Presentation Foundation.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Function Run () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run();" />
      <MemberSignature Language="F#" Value="member this.Run : unit -&gt; int" Usage="application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia aplikację systemu Windows Presentation Foundation.</summary>
        <returns>
          <see cref="T:System.Int32" /> Kod zakończenia aplikacji, która jest zwracana do systemu operacyjnego, podczas zamykania aplikacji. Domyślnie wartość kodu zakończenia jest 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Run%2A> jest wywoływana, aby uruchomić [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] aplikacji. W przypadku definiowania Twojej <xref:System.Windows.Application> za pomocą znacznika, lub znaczników i kodu powiązanego <xref:System.Windows.Application.Run%2A> będzie wywoływany niejawnie. Jednak w przypadku definiowania Twojej <xref:System.Windows.Application> przy użyciu kodu, musisz jawnie wywołać <xref:System.Windows.Application.Run%2A>.  
  
 Gdy <xref:System.Windows.Application.Run%2A> jest nazywany <xref:System.Windows.Application> dołącza nowy <xref:System.Windows.Threading.Dispatcher> wystąpienie do wątku interfejsu użytkownika. Następnie <xref:System.Windows.Threading.Dispatcher> obiektu <xref:System.Windows.Threading.Dispatcher.Run%2A> wywoływana jest metoda, która rozpoczyna się pompę komunikat do przetwarzania komunikatów systemu windows. Na koniec <xref:System.Windows.Threading.Dispatcher> obiektu wywołania <xref:System.Windows.Application> obiektu <xref:System.Windows.Application.OnStartup%2A> metodę, aby podnieść <xref:System.Windows.Application.Startup> zdarzeń. W rezultacie model wykonywania aplikacji została ustanowiona w czasie obsługi <xref:System.Windows.Application.Startup>, w którym aplikacja została uznana za działać.  
  
 Przerwanie podczas działania aplikacji <xref:System.Windows.Application.Shutdown%2A> jest nazywany; wartość <xref:System.Windows.Application.ShutdownMode%2A> właściwość określa, kiedy <xref:System.Windows.Application.Shutdown%2A> nosi nazwę i czy odbywa się automatycznie, czy należy jawnie wywołać ją.  
  
 <xref:System.Windows.Application.Run%2A> może być wywołana tylko z wątku, który tworzy <xref:System.Windows.Application> obiektu. Ponadto <xref:System.Windows.Application.Run%2A> nie można wywołać z [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)].  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono aplikację, która używa niestandardowego <xref:System.Windows.Application> i dlatego należy jawnie wywołać <xref:System.Windows.Application.Run%2A>.  
  
 [!code-csharp[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunSnippets/CSharp/App.cs#customentrypointandruncode)]
 [!code-vb[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunSnippets/visualbasic/app.vb#customentrypointandruncode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Application.Run" /> jest wywoływana z poziomu aplikacji obsługiwane w przeglądarce (na przykład [! INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-XBAP-MD.MD)]).</exception>
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run (System.Windows.Window window);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run(class System.Windows.Window window) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run(System.Windows.Window)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run(System::Windows::Window ^ window);" />
      <MemberSignature Language="F#" Value="member this.Run : System.Windows.Window -&gt; int" Usage="application.Run window" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="window" Type="System.Windows.Window" />
      </Parameters>
      <Docs>
        <param name="window">A <see cref="T:System.Windows.Window" /> który otwierany automatycznie podczas uruchamiania aplikacji.</param>
        <summary>Uruchamia aplikację systemu Windows Presentation Foundation i otwiera określone okno.</summary>
        <returns>
          <see cref="T:System.Int32" /> Kod zakończenia aplikacji, która jest zwracana do systemu operacyjnego, podczas zamykania aplikacji. Domyślnie wartość kodu zakończenia jest 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie rozszerza <xref:System.Windows.Application.Run%2A> metodę, aby otworzyć okno określona po uruchamiania aplikacji.  
  
 W przypadku definiowania kod <xref:System.Windows.Application> otwiera okno, kiedy rozpoczyna działanie, jawnie wywołać <xref:System.Windows.Application.Run%2A>.  
  
 W przypadku utworzenia użytkownika <xref:System.Windows.Application> za pomocą znacznika, lub znacznika i związane z kodem, można automatycznie otworzyć okno podczas przy użyciu jednej z następujących metod:  
  
-   Deklaratywnie, ustawiając <xref:System.Windows.Application.StartupUri%2A>.  
  
-   Programowe przez Obsługa <xref:System.Windows.Application.Startup>.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono aplikację za pomocą metody punktu ręcznie utworzyć wpis statyczny, tworzącym <xref:System.Windows.Application>, przed wywołaniem <xref:System.Windows.Application.Run%2A>.  
  
 [!code-csharp[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunOL1Snippets/CSharp/App.cs#customentrypointandrunol1code)]
 [!code-vb[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunOL1Snippets/visualbasic/app.vb#customentrypointandrunol1code)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Application.Run" /> jest wywoływana z poziomu aplikacji obsługiwane w przeglądarce (na przykład [! INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-XBAP-MD.MD)]).</exception>
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public event System.Windows.SessionEndingCancelEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SessionEndingCancelEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SessionEnding As SessionEndingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SessionEndingCancelEventHandler ^ SessionEnding;" />
      <MemberSignature Language="F#" Value="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " Usage="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SessionEndingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik kończy się sesja systemu Windows wylogowania lub zamykania systemu operacyjnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie aplikacja zamknięty kiedy zakończenia sesji systemu Windows, które występuje, gdy użytkownik wyloguje się lub kończy pracę. W takim przypadku system Windows pyta każdego Otwórz aplikacja jest zamykana. Jednak jest możliwe, że aplikacja może nie być gotowy do zamykania w takiej sytuacji. Na przykład aplikacja może mieć dane, które są w stanie niespójnym, lub w środku długotrwałej operacji. W takich przypadkach go może być pożądane, aby uniemożliwić kończenie sesji i może być bardziej pożądane, aby umożliwić użytkownikom opcję, aby zdecydować, czy zezwolić na zakończenie sesji.  
  
 Można wykryć w momencie kończenia sesji Obsługa <xref:System.Windows.Application.SessionEnding> zdarzeń. Jeśli aplikacja trzeba uniemożliwić sesji Kończenie, <xref:System.Windows.SessionEndingCancelEventArgs> przedstawia argumentu przekazanego do obsługi zdarzeń <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> ustawionej dla `true` (wartość domyślna to `false`).  
  
 Jeśli <xref:System.Windows.Application.SessionEnding> jest nieobsługiwany lub bez Trwa anulowanie <xref:System.Windows.Application.Shutdown%2A> nosi nazwę i <xref:System.Windows.Application.Exit> zdarzenia.  
  
 Aby uzyskać więcej informacji na temat przyczyny kończy się sesja, aplikacja może sprawdzać <xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>, które jest jednym z <xref:System.Windows.ReasonSessionEnding> wartości (<xref:System.Windows.ReasonSessionEnding.Logoff?displayProperty=nameWithType> i <xref:System.Windows.ReasonSessionEnding.Shutdown?displayProperty=nameWithType>).  
  
 <xref:System.Windows.Application.SessionEnding> nie jest wywoływane przez aplikacje konsoli.  
  
 <xref:System.Windows.Application.SessionEnding> jest wywoływane tylko w wątku, który tworzy <xref:System.Windows.Application> obiektu.  
  
 <xref:System.Windows.Application.SessionEnding> nie jest wywoływane dla aplikacji przeglądarki XAML (XBAP).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób obsługi <xref:System.Windows.Application.SessionEnding> zdarzeń i umożliwia użytkownikowi je anulować.  
  
 [!code-xaml[ApplicationSessionEndingSnippets#HandlingSessionEndingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml#handlingsessionendingxaml)]  
  
 [!code-csharp[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml.cs#handlingsessionendingcodebehind)]
 [!code-vb[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/visualbasic/application.xaml.vb#handlingsessionendingcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public static void SetCookie (Uri uri, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCookie(class System.Uri uri, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCookie(Uri ^ uri, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetCookie : Uri * string -&gt; unit" Usage="System.Windows.Application.SetCookie (uri, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri">
          <see cref="T:System.Uri" /> , Który określa lokalizację, dla którego można utworzyć pliku cookie.</param>
        <param name="value">
          <see cref="T:System.String" /> Zawierający dane pliku cookie.</param>
        <summary>Tworzy plik cookie do lokalizacji określonej przez <see cref="T:System.Uri" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plik cookie jest dowolne dane, które mogą być przechowywane przez aplikację na komputerze klienckim podczas sesji aplikacji (pliki cookie z sesji) lub między sesjami aplikacji (trwałe pliki cookie). Oba typy plików cookie można utworzyć przez wywołanie metody <xref:System.Windows.Application.SetCookie%2A>.  
  
 Dane pliku cookie mają zwykle postać pary nazwa/wartość w następującym formacie:  
  
 `Name=Value`  
  
 Przekaż ciąg ten format <xref:System.Windows.Application.SetCookie%2A>, wraz z <xref:System.Uri> lokalizacji, dla którego plik cookie powinien być ustawiony (zazwyczaj domeny aplikacji).  
  
 Czy plik cookie to plik cookie sesji lub trwały plik cookie zależy od tego, czy plik cookie ciąg, który należy przekazać do <xref:System.Windows.Application.SetCookie%2A> ma datę wygaśnięcia. Ciąg dla pliku cookie sesji nie ma datę wygaśnięcia. Ciąg dla trwały plik cookie jest i musi być w następującym formacie:  
  
 `NAME=VALUE; expires=DAY, DD-MMM-YYYY HH:MM:SS GMT`  
  
 Trwałe pliki cookie są przechowywane w bieżącym [!INCLUDE[TLA#tla_mswin](~/includes/tlasharptla-mswin-md.md)] instalacji folderu tymczasowych plików internetowych, dopóki nie wygasną, w którym to przypadku są usuwane. Trwały plik cookie można usunąć z aplikacji przez ustawienie daty wygaśnięcia na wartość daty/godziny, która jest w przeszłości.  
  
 Przegląd plików cookie w [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)], zobacz [omówienie nawigacji](~/docs/framework/wpf/app-development/navigation-overview.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">A [! Błąd include[TLA#tla_win32](~/includes/tlasharptla-Win32-MD.MD)] przez <see langword="InternetSetCookie" /> — funkcja (wywoływane przez <see cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />) Jeśli wystąpi problem podczas próby utworzenia określonego pliku cookie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do pobierania plików cookie dla opartą na plikach <see cref="T:System.Uri" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">do pobierania plików cookie dla pliku nieopartych <see cref="T:System.Uri" />. Wyliczenie skojarzone: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Windows.Application.GetCookie(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Shutdown">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zamyka aplikację.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown();" />
      <MemberSignature Language="F#" Value="member this.Shutdown : unit -&gt; unit" Usage="application.Shutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka aplikację.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.Application.Shutdown%2A> jest wywoływana aplikacja przestanie działać. Może obsłużyć <xref:System.Windows.Application.Exit> zdarzeń do wykrycia, gdy aplikacja jest zamiar przestanie działać, aby wykonać wszelkie odpowiednie przetwarzania.  
  
 <xref:System.Windows.Application.Shutdown%2A> jest wywoływany niejawnie przez Windows Presentation Foundation w następujących sytuacjach:  
  
-   Gdy <xref:System.Windows.Application.ShutdownMode%2A> ma ustawioną wartość <xref:System.Windows.ShutdownMode.OnLastWindowClose>.  
  
-   Gdy <xref:System.Windows.Application.ShutdownMode%2A> ma ustawioną wartość <xref:System.Windows.ShutdownMode.OnMainWindowClose>.  
  
-   Gdy użytkownik kończy się sesja i <xref:System.Windows.Application.SessionEnding> zdarzeń jest nieobsługiwany, albo bez anulowania.  
  
 Wywoływanie <xref:System.Windows.Application.Shutdown%2A> jawnie powoduje, że aplikacja jest zamykana, niezależnie od tego <xref:System.Windows.Application.ShutdownMode%2A> ustawienie. Jednak jeśli <xref:System.Windows.Application.ShutdownMode%2A> ustawiono <xref:System.Windows.ShutdownMode.OnExplicitShutdown>, należy wywołać <xref:System.Windows.Application.Shutdown%2A> zamknąć aplikacji.  
  
> [!IMPORTANT]
>  Gdy <xref:System.Windows.Application.Shutdown%2A> jest nazywane, aplikacja zostanie zamknięty niezależnie od tego, czy <xref:System.Windows.Window.Closing> zdarzenia wszystkie otwarte okna zostało anulowane.  
  
 Tę metodę można wywołać tylko z wątku, który utworzony <xref:System.Windows.Application> obiektu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uzyskać uprawnienia do używania wszystkie okna i zdarzenia wejściowe użytkownika bez ograniczeń. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
        <altmember cref="M:System.Windows.Application.Run" />
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(int exitCode);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : int -&gt; unit" Usage="application.Shutdown exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">Kod zakończenia całkowitą dla aplikacji. Domyślny kod zakończenia ma wartość 0.</param>
        <summary>Zamyka aplikację, która zwraca określony kod zakończenia do systemu operacyjnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Może obsłużyć <xref:System.Windows.Application.Exit> zdarzeń można ustawić kodu zakończenia. Jednak jeśli jawnie wywołać <xref:System.Windows.Application.Shutdown%2A>, i można obsługiwać <xref:System.Windows.Application.Exit> tylko można ustawić kodu zakończenia, można wywołać <xref:System.Windows.Application.Shutdown%2A> zamiast tego.  
  
 Tę metodę można wywołać tylko z wątku, który utworzony <xref:System.Windows.Application> obiektu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uzyskać uprawnienia do używania wszystkie okna i zdarzenia wejściowe użytkownika bez ograniczeń. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="Overload:System.Windows.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownMode">
      <MemberSignature Language="C#" Value="public System.Windows.ShutdownMode ShutdownMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ShutdownMode ShutdownMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ShutdownMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ShutdownMode As ShutdownMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ShutdownMode ShutdownMode { System::Windows::ShutdownMode get(); void set(System::Windows::ShutdownMode value); };" />
      <MemberSignature Language="F#" Value="member this.ShutdownMode : System.Windows.ShutdownMode with get, set" Usage="System.Windows.Application.ShutdownMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ShutdownMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia warunek, który powoduje <see cref="M:System.Windows.Application.Shutdown" /> wywoływanej metody.</summary>
        <value>A <see cref="T:System.Windows.ShutdownMode" /> wartości wyliczenia. Wartość domyślna to <see cref="F:System.Windows.ShutdownMode.OnLastWindowClose" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacje zatrzymał tylko wtedy, gdy <xref:System.Windows.Application.Shutdown%2A> wywoływana jest metoda aplikacji. Zamknij może wystąpić jawnie lub niejawnie, określony przez wartość <xref:System.Windows.Application.ShutdownMode%2A> właściwości.  
  
 Jeśli ustawisz <xref:System.Windows.Application.ShutdownMode%2A> do <xref:System.Windows.ShutdownMode.OnLastWindowClose>, Windows Presentation Foundation (WPF) niejawnie wywołuje <xref:System.Windows.Application.Shutdown%2A> po zamknięciu ostatniego okno aplikacji, nawet wtedy, gdy wszystkie obecnie wystąpień systemu windows są ustawione jako okno główne (zobacz <xref:System.Windows.Application.MainWindow%2A>).  
  
 A <xref:System.Windows.Application.ShutdownMode%2A> z <xref:System.Windows.ShutdownMode.OnMainWindowClose> powoduje, że WPF niejawnie wywołać <xref:System.Windows.Application.Shutdown%2A> podczas <xref:System.Windows.Application.MainWindow%2A> zamyka, nawet jeśli inne okna są obecnie otwarte.  
  
 Okres istnienia niektórych aplikacji nie może być zależny od kiedy okna głównego lub ostatniego został zamknięty lub może nie być zależna od systemu windows na wszystkich. Te scenariusze należy ustawić <xref:System.Windows.Application.ShutdownMode%2A> właściwości <xref:System.Windows.ShutdownMode.OnExplicitShutdown>, co wymaga jawnego <xref:System.Windows.Application.Shutdown%2A> wywołania metody, aby zatrzymać aplikację. W przeciwnym razie aplikacja nadal uruchomione w tle.  
  
 <xref:System.Windows.Application.ShutdownMode%2A> można skonfigurować deklaratywnie w [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] lub programowo z kodu.  
  
 Ta właściwość jest dostępna tylko w wątku, który utworzony <xref:System.Windows.Application> obiektu.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób konfigurowania <xref:System.Windows.Application.ShutdownMode%2A> Aby określić, że aplikacja musi być jawnie zamknięty.  
  
 [!code-xaml[ApplicationShutdownModeSnippets#SetShutdownModeXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationShutdownModeSnippets/CS/App.xaml#setshutdownmodexaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Startup">
      <MemberSignature Language="C#" Value="public event System.Windows.StartupEventHandler Startup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.StartupEventHandler Startup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Startup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Startup As StartupEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::StartupEventHandler ^ Startup;" />
      <MemberSignature Language="F#" Value="member this.Startup : System.Windows.StartupEventHandler " Usage="member this.Startup : System.Windows.StartupEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.StartupEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="M:System.Windows.Application.Run" /> metody <see cref="T:System.Windows.Application" /> nosi nazwę obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typowa aplikacja Windows Presentation Foundation może wykonywać różne zadania inicjowania podczas uruchamiania, w tym:  
  
-   Przetwarzanie parametry wiersza polecenia.  
  
-   Otwieranie okna głównego.  
  
-   Inicjowanie zasobów z zakresu aplikacji.  
  
-   Inicjowanie właściwości zakresu aplikacji.  
  
 Można określić deklaratywnie główne okno i zasobów z zakresu aplikacji przy użyciu [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] (<xref:System.Windows.Application.StartupUri%2A> i <xref:System.Windows.Application.Resources%2A>odpowiednio). Czasami jednak zasobów lub głównego okna aplikacji mogą być ustalane tylko programowo w czasie wykonywania. Ponadto właściwości zakresu aplikacji i parametry wiersza polecenia można tylko programowo. Inicjowanie programistyczny może zostać wykonana przez Obsługa <xref:System.Windows.Application.Startup> zdarzenia, takie jak:  
  
-   Pobrać i przetworzyć parametry wiersza polecenia, które są dostępne z <xref:System.Windows.StartupEventArgs.Args%2A> właściwość <xref:System.Windows.StartupEventArgs> klasy, która została przekazana do <xref:System.Windows.Application.Startup> obsługi zdarzeń.  
  
-   Inicjowanie zasobów zakresu aplikacji za pomocą <xref:System.Windows.Application.Resources%2A> właściwości.  
  
-   Inicjowanie właściwości zakresu aplikacji za pomocą <xref:System.Windows.Application.Properties%2A> właściwości.  
  
-   Utwórz wystąpienie i Pokaż jeden (lub więcej) systemu windows.  
  
> [!NOTE]
>  Parametry wiersza polecenia można również można uzyskać przez wywołanie metody statycznych <xref:System.Environment.GetCommandLineArgs%2A> metody <xref:System.Environment> obiektu. Jednak <xref:System.Environment.GetCommandLineArgs%2A> wymaga pełnego zaufania do wykonania.  
  
 Jeśli ustawisz <xref:System.Windows.Application.StartupUri%2A> przy użyciu [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)], okno główne, która jest tworzona jest niedostępna z jednego <xref:System.Windows.Application.MainWindow%2A> właściwości lub <xref:System.Windows.Application.Windows%2A> właściwość <xref:System.Windows.Application> obiektu, dopóki nie po <xref:System.Windows.Application.Startup> przetwarzania zdarzeń. Aby uzyskać dostęp do okna głównego podczas uruchamiania, należy ręcznie utworzyć obiekt window z Twojej <xref:System.Windows.Application.Startup> obsługi zdarzeń.  
  
> [!NOTE]
>  Jeśli aplikacja używa <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> Aby określić zasady poświadczeń, należy ustawić <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> po <xref:System.Windows.Application.Startup> zgłoszono, a w przeciwnym razie [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] ustawia ją na domyślnych wewnętrznych zasad bezpośrednio po <xref:System.Windows.Application.Startup> zdarzeń został zgłoszony.  
  
 Argumenty wiersza polecenia, które są przekazywane do <xref:System.Windows.Application.Startup> program obsługi zdarzeń nie są takie same, jak [!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)] parametry ciągu, które są przekazywane do zapytania [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)].  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak uzyskać i przetworzyć opcje wiersza polecenia aplikacji autonomicznych. Jeśli **/StartMinimized** podano parametr wiersza polecenia, główne okno aplikacji otworzy się w stanie zminimalizowanym.  
  
 [!code-xaml[ApplicationStartupSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationStartupSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] Nie można pobrać i przetworzyć argumenty wiersza polecenia, ponieważ są one uruchamiane z [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)] wdrożenia (zobacz [wdrażanie aplikacji WPF (WPF)](~/docs/framework/wpf/app-development/deploying-a-wpf-application-wpf.md)). Jednak można pobrać i przetworzyć parametrów ciągu zapytania z adresów URL, które są używane do uruchamiania ich.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="StartupUri">
      <MemberSignature Language="C#" Value="public Uri StartupUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri StartupUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.StartupUri" />
      <MemberSignature Language="VB.NET" Value="Public Property StartupUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ StartupUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartupUri : Uri with get, set" Usage="System.Windows.Application.StartupUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia interfejs użytkownika, który jest automatycznie wyświetlana podczas uruchamiania aplikacji.</summary>
        <value>A <see cref="T:System.Uri" /> odwołujący się do interfejsu użytkownika, który automatycznie zostanie otwarty podczas uruchamiania aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć <xref:System.Windows.Application.StartupUri%2A> automatyczne ładowanie zasobu interfejsu użytkownika podczas uruchamiania aplikacji.  
  
 W poniższej tabeli przedstawiono typy zasobów interfejsu użytkownika, które mogą być ładowane, typie okna otwartych w i typu aplikacji, która tych zasobów można ustawić jako <xref:System.Windows.Application.StartupUri%2A>.  
  
|Typ|Okno|Typ aplikacji|  
|----------|------------|----------------------|  
|<xref:System.Windows.Window>|<xref:System.Windows.Window>|Tylko autonomicznej|  
|<xref:System.Windows.Navigation.NavigationWindow>|<xref:System.Windows.Navigation.NavigationWindow>|Tylko autonomicznej|  
|<xref:System.Windows.Controls.Page>|<xref:System.Windows.Navigation.NavigationWindow>|Obsługiwane w autonomicznej/przeglądarce|  
|<xref:System.Windows.Controls.UserControl>|<xref:System.Windows.Navigation.NavigationWindow>|Obsługiwane w autonomicznej/przeglądarce|  
|<xref:System.Windows.Documents.FlowDocument>|<xref:System.Windows.Navigation.NavigationWindow>|Obsługiwane w autonomicznej/przeglądarce|  
|<xref:System.Windows.Navigation.PageFunction%601>|<xref:System.Windows.Navigation.NavigationWindow>|Obsługiwane w autonomicznej/przeglądarce|  
  
 Zwykle ustawić <xref:System.Windows.Application.StartupUri%2A> właściwości deklaratywnie w [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]. Jednak można ustawić <xref:System.Windows.Application.StartupUri%2A> programowo, takich jak z <xref:System.Windows.Application.Startup> program obsługi zdarzeń, co jest przydatne, jeśli w aplikacji, która może ładować tylko niezbędne zasoby interfejsu użytkownika w czasie wykonywania. Na przykład aplikacja może czekać do wykonywania załadować jej zasobów, jeśli nazwa zasobu interfejsu użytkownika jest przechowywany w pliku konfiguracji.  
  
 Określa, czy ustawić <xref:System.Windows.Application.StartupUri%2A> deklaratywnie lub programowo, odpowiadający jej zasób interfejsu użytkownika nie został załadowany do po <xref:System.Windows.Application.Startup> zdarzenie jest obsługiwane. W związku z tym, nie będziesz mieć dostępu do okna wynikowego z dowolnej <xref:System.Windows.Application.Windows%2A> właściwości lub <xref:System.Windows.Application.MainWindow%2A> właściwości podczas obsługi <xref:System.Windows.Application.Startup>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Windows.Application.StartupUri" /> ustawiono wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nazwa żądanej właściwości otoczenia.</param>
        <summary>Zapytania dotyczące tego, czy określona właściwość otoczenia jest dostępna w bieżącym zakresie.</summary>
        <returns>
          <see langword="true" /> Jeśli żądana właściwość otoczenia jest dostępna; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Windows.Application> wystąpienia jest rzutowane na <xref:System.Windows.Markup.IQueryAmbient> interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.IQueryAmbient" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="application.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Nazwa zasobu, aby znaleźć.</param>
        <summary>Wyszukuje określonego zasobu.</summary>
        <returns>Obiekt żądanego zasobu. Jeśli nie odnaleziono żądanego zasobu, zwracany jest odwołanie o wartości null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.TryFindResource%2A> najpierw sprawdza się w zasobach zakresu aplikacji dla określonego zasobu. Zasoby zakresu aplikacji są zarządzane przez <xref:System.Windows.Application>i są dostępne z <xref:System.Windows.Application.Resources%2A> właściwości. Jeśli określony zasób nie zostanie znaleziony w zestawie zasobów zakresu aplikacji <xref:System.Windows.Application.TryFindResource%2A> następnie wyszukuje zasobów systemowych. Zasoby systemowe są shell zasoby zdefiniowane przez użytkownika i Dołącz kolory, czcionki i konfiguracje powłoki. Są one dostępne z <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, i <xref:System.Windows.SystemParameters> typy odpowiednio właściwości statycznej. Aby użyć <xref:System.Windows.Application.TryFindResource%2A> uzyskać je, te typy również ujawniać klucza właściwości zasobów, które są przeznaczone do przekazania do <xref:System.Windows.Application.TryFindResource%2A>, na przykład <xref:System.Windows.SystemParameters.IconWidthKey%2A>.  
  
 Ponieważ <xref:System.Windows.Application.TryFindResource%2A> zwraca obiekt, należy rzutować zwrócona wartość do odpowiedniego typu, jeśli zasób znajduje się.  
  
 Ta metoda jest bezpieczne dla wątków i może zostać wywołana z dowolnego wątku.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Windows.Application.TryFindResource%2A> można uzyskać zasobu.  
  
 [!code-xaml[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/App.xaml#applicationcalltryfindresourcexaml)]  
  
 [!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind1)]
 [!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind1)]  
[!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind2)]
[!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Windows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection Windows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection Windows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Windows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Windows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ Windows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Windows : System.Windows.WindowCollection" Usage="System.Windows.Application.Windows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wystąpień systemu windows w aplikacji.</summary>
        <value>A <see cref="T:System.Windows.WindowCollection" /> zawiera odwołania do wszystkich obiektów okno w bieżącym <see cref="T:System.AppDomain" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Window> odwołanie jest automatycznie dodawany do <xref:System.Windows.Application.Windows%2A> się, gdy okno jest tworzone w [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] wątku; okna, które są tworzone przez proces roboczy nie dodano wątków. A <xref:System.Windows.Window> odwołanie zostanie automatycznie usunięta po jego <xref:System.Windows.Window.Closing> zdarzeń został obsłużony i przed jego <xref:System.Windows.Window.Closed> zdarzenia.  
  
 Domyślnie pierwszy element dodawany do <xref:System.Windows.Application.Windows%2A> staje się właściwość <xref:System.Windows.Application.MainWindow%2A>.  
  
 Ta właściwość jest dostępna tylko w wątku, który utworzony <xref:System.Windows.Application> obiektu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wyliczania <xref:System.Windows.Application.Windows%2A> właściwości do utworzenia najwyższego poziomu menu systemu Windows, który jest wspólny dla [!INCLUDE[TLA#tla_mdi](~/includes/tlasharptla-mdi-md.md)] aplikacje, takie jak [!INCLUDE[TLA#tla_xl](~/includes/tlasharptla-xl-md.md)], lub wielu wystąpień jednego interfejsu dokumentu (SDI) aplikacje, takie jak [!INCLUDE[TLA#tla_word](~/includes/tlasharptla-word-md.md)].  
  
 [!code-csharp[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/WindowMenuItem.cs#windowmenuitemcode)]
 [!code-vb[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/windowmenuitem.vb#windowmenuitemcode)]  
  
 [!code-xaml[ApplicationWindowsSnippets#MainWindowSetWindowsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml#mainwindowsetwindowsxaml)]  
  
 [!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind1)]
 [!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind1)]  
[!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind2)]
[!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Window" />
      </Docs>
    </Member>
  </Members>
</Type>
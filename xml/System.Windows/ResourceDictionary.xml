<Type Name="ResourceDictionary" FullName="System.Windows.ResourceDictionary">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b6aedd68ba79049587a5de7595bec19c8e0fe195" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69444192" /></Metadata><TypeSignature Language="C#" Value="public class ResourceDictionary : System.Collections.IDictionary, System.ComponentModel.ISupportInitialize, System.Windows.Markup.INameScope, System.Windows.Markup.IUriContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ResourceDictionary extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.ComponentModel.ISupportInitialize, class System.Windows.Markup.INameScope, class System.Windows.Markup.IUriContext" />
  <TypeSignature Language="DocId" Value="T:System.Windows.ResourceDictionary" />
  <TypeSignature Language="VB.NET" Value="Public Class ResourceDictionary&#xA;Implements IDictionary, INameScope, ISupportInitialize, IUriContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceDictionary : System::Collections::IDictionary, System::ComponentModel::ISupportInitialize, System::Windows::Markup::INameScope, System::Windows::Markup::IUriContext" />
  <TypeSignature Language="F#" Value="type ResourceDictionary = class&#xA;    interface IDictionary&#xA;    interface ICollection&#xA;    interface IEnumerable&#xA;    interface ISupportInitialize&#xA;    interface IUriContext&#xA;    interface INameScope" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.INameScope</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IUriContext</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Windows.Markup.Ambient</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zapewnia implementację tabeli/słownika wartości skrótu, która zawiera zasoby WPF używane przez składniki i inne elementy aplikacji WPF.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy w a <xref:System.Windows.ResourceDictionary> nie są natychmiast przetwarzane, gdy kod aplikacji jest ładowany [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] przez moduł ładujący. Zamiast tego są utrwalane jako obiekt, a poszczególne wartości są przetwarzane tylko wtedy, gdy są one konkretnie wymagane. <xref:System.Windows.ResourceDictionary>  
  
 Klasa nie pochodzi od <xref:System.Collections.DictionaryBase>klasy. <xref:System.Windows.ResourceDictionary> Zamiast tego <xref:System.Windows.ResourceDictionary> Klasa implementuje <xref:System.Collections.IDictionary> , ale opiera się <xref:System.Collections.Hashtable> wewnętrznie.  
  
 W programie [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]Klasajestzazwyczaj niejawnym elementem kolekcji, który jest wartością elementu obiektu kilku `Resources` właściwości, gdy jest podawana w składni elementu właściwości. <xref:System.Windows.ResourceDictionary> Aby uzyskać szczegółowe informacje na temat [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]niejawnych kolekcji w programie, zobacz [Szczegóły składni języka XAML](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md). Wyjątek polega na tym, że chcesz określić scalony słownik; Aby uzyskać szczegółowe informacje, zobacz [scalone słowniki zasobów](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
 Innym możliwym [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sposobem użycia jest zadeklarowanie słownika zasobów jako pliku [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] dyskretnego i załadowanie go w czasie wykonywania z <xref:System.Windows.Markup.XamlReader.Load%2A> lub dołączenie go do projektu (pełnego zaufania) jako zasobu lub luźnego pliku. W tym przypadku <xref:System.Windows.ResourceDictionary> może być zadeklarowany jako element obiektu, służący jako element [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]główny. Należy zmapować odpowiednie wartości przestrzeni nazw XML (domyślnie [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] dla przestrzeni nazw i zwykle `x:` dla [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] przestrzeni nazw) na element, <xref:System.Windows.ResourceDictionary> Jeśli zamierzasz użyć go jako elementu głównego. Następnie można dodać elementy podrzędne, które definiują zasoby, z których każdy ma wartość [x:Key](~/docs/framework/xaml-services/x-key-directive.md) .  
  
<a name="xamlImplicitCollectionUsage_ResourceDictionary"></a>   
## <a name="xaml-implicit-collection-usage"></a>Użycie niejawnej kolekcji języka XAML  
  
```  
<object>  
  <object.resourcesProperty>  
    oneOrMoreResources  
  </object.resourcesProperty>  
</object>  
```  
  
<a name="xamlValues_ResourceDictionary"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *resourcesProperty*  
 Właściwość określająca element właściwości, gdzie typem wartości tej właściwości jest <xref:System.Windows.ResourceDictionary>. Zazwyczaj jest `Resources` to <xref:System.Windows.FrameworkElement> właściwość lub <xref:System.Windows.FrameworkContentElement>lub <xref:System.Windows.Application> w przypadku zasobów aplikacji.  
  
 *oneOrMoreResources*  
 Co najmniej jeden zasób określony jako element obiektu. Każdy określony zasób musi mieć przypisaną [dyrektywę x:Key](~/docs/framework/xaml-services/x-key-directive.md) .  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.FrameworkElement.Resources" />
    <altmember cref="P:System.Windows.Application.Resources" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceDictionary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceDictionary();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.ResourceDictionary" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Add : obj * obj -&gt; unit&#xA;override this.Add : obj * obj -&gt; unit" Usage="resourceDictionary.Add (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Nazwa klucza do dodania.</param>
        <param name="value">Wartość zasobu do dodania.</param>
        <summary>Dodaje zasób według klucza do tego <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Próba dodania zduplikowanego klucza wywołuje wyjątek.  
  
 Klucze są zawsze dodawane do słownika podstawowego. Klucze w <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> obrębie bieżącego <xref:System.Windows.ResourceDictionary> nie są sprawdzane pod kątem duplikowania, tylko słownik podstawowy jest sprawdzany pod kątem duplikatów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Windows.ResourceDictionary" /> Jest zablokowany lub tylko do odczytu.</exception>
        <exception cref="T:System.ArgumentException">Element z tym samym kluczem już istnieje w <see cref="T:System.Collections.Hashtable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="resourceDictionary.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna fazę inicjalizacji dla tego <see cref="T:System.Windows.ResourceDictionary" />elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody jest wskazaniem, że zawartość <xref:System.Windows.ResourceDictionary> ma zostać załadowana. Następnym krokiem w procesie jest wywołanie <xref:System.Windows.ResourceDictionary.EndInit%2A>.  
  
 Przed wywołaniem <xref:System.Windows.ResourceDictionary.BeginInit%2A> <xref:System.Windows.ResourceDictionary.EndInit%2A>Nie wywołuj więcej niż raz. Wykonanie tej czynności spowoduje wystąpienie wyjątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wywołano <see cref="M:System.Windows.ResourceDictionary.BeginInit" /> więcej niż raz <see cref="M:System.Windows.ResourceDictionary.EndInit" /> , zanim została wywołana.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="resourceDictionary.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści wszystkie klucze (i wartości) w bazie <see cref="T:System.Windows.ResourceDictionary" />. Nie spowoduje to usunięcia wszystkich scalonych elementów słownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zachodzi potrzeba wyczyszczenia scalonych elementów słownika, należy uzyskać określony <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> słownik z kolekcji i <xref:System.Windows.ResourceDictionary.Clear%2A> w <xref:System.Windows.ResourceDictionary>szczególności wywołać to, chociaż zwykle słowniki są zdalne i użytkownik może nie mieć dostępu. Alternatywnie usuń cały <xref:System.Windows.ResourceDictionary> z <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> , wywołując metodę Remove w kolekcji ogólnej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="resourceDictionary.Contains key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz, który ma zostać zlokalizowany w <see cref="T:System.Windows.ResourceDictionary" />.</param>
        <summary>Określa, <see cref="T:System.Windows.ResourceDictionary" /> czy zawiera element z określonym kluczem.</summary>
        <returns><see langword="true" />Jeśli <see cref="T:System.Windows.ResourceDictionary" /> zawiera parę klucz-wartość z określonym kluczem; w przeciwnym razie, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli żądany klucz nie znajduje się w tym słowniku zasobów, logika wyszukiwania zasobów również sprawdza scalone słowniki.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.MergedDictionaries" />
        <altmember cref="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Collections.DictionaryEntry[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(valuetype System.Collections.DictionaryEntry[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.CopyTo(System.Collections.DictionaryEntry[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As DictionaryEntry(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;System::Collections::DictionaryEntry&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.Collections.DictionaryEntry[] * int -&gt; unit" Usage="resourceDictionary.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.DictionaryEntry[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa tablica, która jest miejscem docelowym <see cref="T:System.Collections.DictionaryEntry" /> obiektów kopiowanych <see cref="T:System.Windows.ResourceDictionary" /> z wystąpienia. Tablica musi mieć indeksowane zaczynające od zera.</param>
        <param name="arrayIndex">Indeks, w <paramref name="array" /> którym rozpoczyna się kopiowanie, liczony od zera.</param>
        <summary>Kopiuje elementy do jednowymiarowego <see cref="T:System.Collections.DictionaryEntry" /> o określonym indeksie. <see cref="T:System.Windows.ResourceDictionary" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spowoduje to skopiowanie tylko słownika podstawowego. Tablica wynikowa będzie miała wartość <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> <xref:System.Windows.ResourceDictionary> nie, jeśli zostanie ona ponownie utworzona.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Windows.ResourceDictionary.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę wpisów w podstawowym <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <value>Bieżąca liczba wpisów w słowniku podstawowym.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="DeferrableContent">
      <MemberSignature Language="C#" Value="public System.Windows.DeferrableContent DeferrableContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DeferrableContent DeferrableContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.DeferrableContent" />
      <MemberSignature Language="VB.NET" Value="Public Property DeferrableContent As DeferrableContent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DeferrableContent ^ DeferrableContent { System::Windows::DeferrableContent ^ get(); void set(System::Windows::DeferrableContent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DeferrableContent : System.Windows.DeferrableContent with get, set" Usage="System.Windows.ResourceDictionary.DeferrableContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DeferrableContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zawartość odroczoną dla tego słownika zasobów.</summary>
        <value>Zawsze zwraca <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="resourceDictionary.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka fazę inicjalizacji i unieważnia poprzednie drzewo, aby można było uwzględnić wszystkie zmiany w kluczach podczas fazy inicjalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ResourceDictionary.BeginInit%2A>i <xref:System.Windows.ResourceDictionary.EndInit%2A> postępuj zgodnie z modelem transakcji. <xref:System.Windows.ResourceDictionary.BeginInit%2A>oznacza słownik niezainicjowany i <xref:System.Windows.ResourceDictionary.EndInit%2A> oznacza zainicjowany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member FindName : string -&gt; obj&#xA;override this.FindName : string -&gt; obj" Usage="resourceDictionary.FindName name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.FindName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Identyfikator nazwy żądanego obiektu.</param>
        <summary>Nieobsługiwane przez tę implementację słownika.</summary>
        <returns>Zawsze zwraca <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ResourceDictionary> Klasa nie obsługuje rejestrowania według nazwy. Zamiast tego używa kluczy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="resourceDictionary.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość <see cref="T:System.Windows.ResourceDictionary" />, która może być używana do iteracji przez. <see cref="T:System.Collections.IDictionaryEnumerator" /></summary>
        <returns>Wyspecjalizowany moduł wyliczający <see cref="T:System.Windows.ResourceDictionary" />dla.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Iterator dotyczy tylko słownika podstawowego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidatesImplicitDataTemplateResources">
      <MemberSignature Language="C#" Value="public bool InvalidatesImplicitDataTemplateResources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InvalidatesImplicitDataTemplateResources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.InvalidatesImplicitDataTemplateResources" />
      <MemberSignature Language="VB.NET" Value="Public Property InvalidatesImplicitDataTemplateResources As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InvalidatesImplicitDataTemplateResources { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InvalidatesImplicitDataTemplateResources : bool with get, set" Usage="System.Windows.ResourceDictionary.InvalidatesImplicitDataTemplateResources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy unieważnienia wywołane przez <see cref="T:System.Windows.ResourceDictionary" /> obiekt powodują <see cref="T:System.Windows.Controls.ContentPresenter" /> , że obiekty będą reoszacować wybór szablonu. Unieważnienia zachodzą w przypadku zmiany niejawnego zasobu szablonu danych.</summary>
        <value><see langword="true" />Jeśli unieważnienia powodują <see cref="T:System.Windows.Controls.ContentPresenter" /> , <see langword="false" />że obiekty mogą reoszacować swój wybór szablonu; w przeciwnym razie. Wartość domyślna to <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Windows.ResourceDictionary.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy <see cref="T:System.Windows.ResourceDictionary" /> rozmiar jest ustalony.</summary>
        <value><see langword="true" />Jeśli tablica skrótów ma stały rozmiar; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca <xref:System.Collections.Hashtable> wartość domyślną, `false`czyli.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Windows.ResourceDictionary.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy <see cref="T:System.Windows.ResourceDictionary" /> jest to tylko do odczytu.</summary>
        <value><see langword="true" />Jeśli tablica skrótów jest tylko do odczytu; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca <xref:System.Collections.Hashtable> wartość domyślną, `false`czyli.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Windows.ResourceDictionary.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Żądany klucz do pobrania lub ustawienia.</param>
        <summary>Pobiera lub ustawia wartość skojarzoną z danym kluczem.</summary>
        <value>Wartość klucza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli żądany klucz nie znajduje się w tym słowniku zasobów, system zasobów struktury sprawdzi również scalone słowniki.  
  
 <xref:System.Windows.ResourceDictionary> Sprawdzanie przez element lub indeks nie jest generalnie preferowanym sposobem pobierania zasobów. Zamiast tego należy wywoływać metody, które mogą uczestniczyć w pełnym procesie wyszukiwania zasobów i wyszukiwać zasoby według ich kluczy, a które mogą znaleźć zasoby w aplikacjach lub motywach. <xref:System.Windows.FrameworkElement.FindResource%2A>jest to metoda, i jest obecna na dowolnym <xref:System.Windows.FrameworkElement>z nich. W przeciwnym razie próba znalezienia zasobu nie jest zgodna z rzeczywistym zachowaniem w czasie wykonywania.  
  
 Jednak uzyskanie zasobów bezpośrednio z danego słownika może być odpowiednie w przypadku pobierania zasobów ze znanej <xref:System.Windows.ResourceDictionary> lokalizacji i w ten sposób, aby uniknąć możliwego wpływu na wydajność i zakres wyszukiwania kluczy czasu wykonywania.  
  
 Nie używasz indeksatorów do definiowania elementów członkowskich kolekcji w programie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Zamiast tego tworzysz elementy podrzędne w znacznikach. Elementy podrzędne są elementami <xref:System.Windows.ResourceDictionary>podrzędnymi lub elementu właściwości, w którym jest `ResourceDictionary`typem właściwości. Aby uzyskać szczegółowe informacje, [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Zobacz sekcję dotyczącą użycia w <xref:System.Windows.ResourceDictionary>temacie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ICollection ^ Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.ICollection" Usage="System.Windows.ResourceDictionary.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję wszystkich kluczy zawartych w tym <see cref="T:System.Windows.ResourceDictionary" />elemencie.</summary>
        <value>Kolekcja wszystkich kluczy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość istnieje, ponieważ jest wymagana przez <xref:System.Collections.IDictionary>, ale <xref:System.Windows.ResourceDictionary.Keys%2A> ogólnie nie jest przydatna w większości <xref:System.Windows.ResourceDictionary> scenariuszy.  
  
 Zwracane klucze nie obejmują kluczy w ramach <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A>. Ponadto kolekcja kluczy jest migawką kluczy w słowniku podstawowym. Po dokonaniu zmiany w tym <xref:System.Windows.ResourceDictionary>czasie przechowywane <xref:System.Windows.ResourceDictionary.Keys%2A> nie będzie odzwierciedlać zmian.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="MergedDictionaries">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.Windows.ResourceDictionary&gt; MergedDictionaries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.Windows.ResourceDictionary&gt; MergedDictionaries" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.MergedDictionaries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MergedDictionaries As Collection(Of ResourceDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::Windows::ResourceDictionary ^&gt; ^ MergedDictionaries { System::Collections::ObjectModel::Collection&lt;System::Windows::ResourceDictionary ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MergedDictionaries : System.Collections.ObjectModel.Collection&lt;System.Windows.ResourceDictionary&gt;" Usage="System.Windows.ResourceDictionary.MergedDictionaries" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.Windows.ResourceDictionary&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję <see cref="T:System.Windows.ResourceDictionary" /> słowników, które stanowią różne słowniki zasobów w scalonych słownikach.</summary>
        <value>Kolekcja scalonych słowników.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Słowniki są scalane przez <xref:System.Windows.ResourceDictionary> dodanie do kolekcji ogólnej, do <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A>której odwołuje się. Scalony <xref:System.Windows.ResourceDictionary> element nie zawiera elementów zasobów zdefiniowanych w tym znaczniku. Zamiast tego scalony słownik ma <xref:System.Windows.ResourceDictionary> zdefiniowane elementy potomne bez znaczników (lub bez elementów dodanych za pomocą kodu), ale [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] z określonym dla <xref:System.Windows.ResourceDictionary.Source%2A>. Oznaczenie umożliwia scalenie ze źródłem zewnętrznym, na przykład oddzielnego zestawu zasobów, który jest dostarczany z aplikacją, "luźną [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]" lub zestawem zasobów globalnych. <xref:System.Windows.ResourceDictionary.Source%2A>  
  
 Określanie elementów zasobów w <xref:System.Windows.ResourceDictionary> <xref:System.Windows.ResourceDictionary.Source%2A> określonym elemencie nie jest obsługiwane.  
  
 Zachowanie wyszukiwania w <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> kolekcji przeszuka ostatnio dodane <xref:System.Windows.ResourceDictionary> pierwsze, a wyszukiwanie zostanie zatrzymane natychmiast po znalezieniu żądanego klucza. Zduplikowane klucze w kolekcji scalonych słowników są niedozwolone. Aby uzyskać więcej informacji o zachowaniu scalonego słownika, zobacz [scalone słowniki zasobów](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
<a name="xamlPropertyElementUsage_MergedDictionaries"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.MergedDictionaries>  
    oneOrMoreResourceDictionaries  
  </object.MergedDictionaries>  
</object>  
  
```  
  
<a name="xamlValues_MergedDictionaries"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *oneOrMoreResourceDictionaries*  
 Co najmniej jeden element obiektu.<xref:System.Windows.ResourceDictionary> Użyta dla <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> nie ma zawartości kolekcji i określa atrybut, który <xref:System.Windows.ResourceDictionary.Source%2A> odwołuje się do kompletnego <xref:System.Windows.ResourceDictionary> elementu zdalnego. <xref:System.Windows.ResourceDictionary>  
  
   
  
## Examples  
 Poniższy przykład określa dwa <xref:System.Windows.ResourceDictionary> elementy, które mają zostać scalone w podstawowym. <xref:System.Windows.ResourceDictionary>  
  
 [!code-xaml[ResourceMergeDictionary#MergedXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ResourceMergeDictionary/CS/default.xaml#mergedxaml)]   
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.Source" />
      </Docs>
    </Member>
    <Member MemberName="OnGettingValue">
      <MemberSignature Language="C#" Value="protected virtual void OnGettingValue (object key, ref object value, out bool canCache);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGettingValue(object key, object&amp; value, [out] bool&amp; canCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.OnGettingValue(System.Object,System.Object@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGettingValue (key As Object, ByRef value As Object, ByRef canCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGettingValue(System::Object ^ key, System::Object ^ % value, [Runtime::InteropServices::Out] bool % canCache);" />
      <MemberSignature Language="F#" Value="abstract member OnGettingValue : obj *  *  -&gt; unit&#xA;override this.OnGettingValue : obj *  *  -&gt; unit" Usage="resourceDictionary.OnGettingValue (key, value, canCache)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="value" Type="System.Object" RefType="ref" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="canCache" Type="System.Boolean" RefType="out" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="key">Klucz zasobu do pobrania.</param>
        <param name="value">Wartość żądanego zasobu.</param>
        <param name="canCache"><see langword="true" />Jeśli zasób można zapisać i użyć później; w przeciwnym razie. <see langword="false" /></param>
        <summary>Występuje po <see cref="T:System.Windows.ResourceDictionary" /> odebraniu żądania dla zasobu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="abstract member RegisterName : string * obj -&gt; unit&#xA;override this.RegisterName : string * obj -&gt; unit" Usage="resourceDictionary.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.RegisterName(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Nieobsługiwane.</param>
        <param name="scopedElement">Nieobsługiwane.</param>
        <summary>Nieobsługiwane przez tę implementację słownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ResourceDictionary> Klasa nie obsługuje rejestrowania według nazwy. Zamiast tego używa kluczy. Metody namescope języka XAML są implementowane jako niedziałające <xref:System.Windows.ResourceDictionary> wersje w programie, aby wyczyścić, że nazwy XAML nie mają zastosowania do zasobów.  
  
 Wywołanie tej metody spowoduje, że <xref:System.NotSupportedException> zostanie zgłoszony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">We wszystkich przypadkach, gdy ta metoda jest wywoływana.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (key As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : obj -&gt; unit&#xA;override this.Remove : obj -&gt; unit" Usage="resourceDictionary.Remove key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz wpisu do usunięcia.</param>
        <summary>Usuwa wpis z określonym kluczem ze słownika podstawowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie zawiera elementu z określonym kluczem <xref:System.Windows.ResourceDictionary> , pozostaje niezmieniona. <xref:System.Windows.ResourceDictionary> Nie zgłoszono żadnego wyjątku.  
  
 Ta metoda nie usuwa kluczy z <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A>. Musisz uzyskać określone <xref:System.Windows.ResourceDictionary> z kolekcji, aby usunąć te klucze, ale mogą one nie być możliwe, ponieważ zwykle uzyskujesz dostęp do takiego słownika zdalnie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Windows.ResourceDictionary" /> Jest zablokowany lub tylko do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public Uri Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Source { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : Uri with get, set" Usage="System.Windows.ResourceDictionary.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] w celu załadowania zasobów z programu.</summary>
        <value>Lokalizacja źródłowa zewnętrznego słownika zasobów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ResourceDictionary.Source%2A> Zwykle jest określony jako identyfikator URI pakietu, który odwołuje się do lokalizacji słownika zasobów, który jest dołączony jako Nieskompilowany zasób lub Akcja kompilacji zawartości przez projekt kompilowania aplikacji. Aby uzyskać szczegółowe informacje o formacie URI pakietu, zobacz [identyfikatory URI pakietów w WPF](~/docs/framework/wpf/app-development/pack-uris-in-wpf.md).  
  
 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] <xref:System.Windows.ResourceDictionary> <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> Ogólnie rzecz biorąc <xref:System.Windows.ResourceDictionary> właściwość jest ustawiana tylko dla klasy, która jest określona dla właściwości (jako element właściwości w, lub jako element kolekcji w kodzie). <xref:System.Windows.ResourceDictionary.Source%2A> W tym kontekście ustawienie wartości <xref:System.Windows.ResourceDictionary.Source%2A> spowoduje scalenie zawartości słownika znajdującej się w podanej [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] <xref:System.Windows.ResourceDictionary>lokalizacji. Wszelkie błędy ładowania spowodują wystąpienie wyjątku.  
  
   
  
## Examples  
 Poniższy przykład określa dwa <xref:System.Windows.ResourceDictionary> elementy, które mają zostać scalone w podstawowym. <xref:System.Windows.ResourceDictionary>  
  
 [!code-xaml[ResourceMergeDictionary#MergedXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ResourceMergeDictionary/CS/default.xaml#mergedxaml)]   
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.MergedDictionaries" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Wartość zerowa <see cref="T:System.Array" /> , która odbiera skopiowane elementy <see cref="T:System.Windows.Markup.Localizer.BamlLocalizationDictionary" />z.</param>
        <param name="arrayIndex">Pierwsza pozycja w określonym <see cref="T:System.Array" /> do odebrania skopiowanej zawartości.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />Zobacz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.ResourceDictionary> gdy wystąpienie jest rzutowane <xref:System.Collections.ICollection> do interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ResourceDictionary.CopyTo(System.Collections.DictionaryEntry[],System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Collections.ICollection.IsSynchronized" />Zobacz.</summary>
        <value><see langword="true" />w przypadku synchronizacji <see cref="T:System.Windows.ResourceDictionary" /> dostępu do programu (wątek bezpieczny); w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.ResourceDictionary> gdy wystąpienie jest rzutowane <xref:System.Collections.ICollection> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Collections.ICollection.SyncRoot" />Zobacz.</summary>
        <value>Obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Windows.ResourceDictionary" />programu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.ResourceDictionary> gdy wystąpienie jest rzutowane <xref:System.Collections.ICollection> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.Collections.IEnumerable.GetEnumerator" />Zobacz.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> Obiekt, którego można użyć do iteracji w kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.ResourceDictionary> gdy wystąpienie jest rzutowane <xref:System.Collections.IEnumerable> do interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ResourceDictionary.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IUriContext.BaseUri">
      <MemberSignature Language="C#" Value="Uri System.Windows.Markup.IUriContext.BaseUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri System.Windows.Markup.IUriContext.BaseUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.System#Windows#Markup#IUriContext#BaseUri" />
      <MemberSignature Language="VB.NET" Value=" Property BaseUri As Uri Implements IUriContext.BaseUri" />
      <MemberSignature Language="C++ CLI" Value="property Uri ^ System::Windows::Markup::IUriContext::BaseUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Windows.Markup.IUriContext.BaseUri" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IUriContext.BaseUri</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Windows.Markup.IUriContext.BaseUri" />Zobacz.</summary>
        <value>Podstawa [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] bieżącego kontekstu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.ResourceDictionary> gdy wystąpienie jest rzutowane <xref:System.Windows.Markup.IUriContext> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member UnregisterName : string -&gt; unit&#xA;override this.UnregisterName : string -&gt; unit" Usage="resourceDictionary.UnregisterName name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.UnregisterName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nieobsługiwane.</param>
        <summary>Nieobsługiwane przez tę implementację słownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ResourceDictionary> Klasa nie obsługuje rejestrowania według nazwy. Zamiast tego używa kluczy. Wywołanie tej metody nie robi nic.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ICollection ^ Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.ICollection" Usage="System.Windows.ResourceDictionary.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję wszystkich wartości skojarzonych z kluczami zawartymi w tym <see cref="T:System.Windows.ResourceDictionary" />elemencie.</summary>
        <value>Kolekcja wszystkich wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość istnieje, ponieważ jest wymagana przez <xref:System.Collections.IDictionary>, ale ogólnie nie jest przydatna w większości <xref:System.Windows.ResourceDictionary> scenariuszy.  
  
 Zwracane wartości nie zawierają wartości w elemencie <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A>. Ponadto kolekcja jest migawką wartości w słowniku podstawowym. Po dokonaniu zmiany w tym <xref:System.Windows.ResourceDictionary>czasie przechowywane <xref:System.Windows.ResourceDictionary.Values%2A> nie będzie odzwierciedlać zmian.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

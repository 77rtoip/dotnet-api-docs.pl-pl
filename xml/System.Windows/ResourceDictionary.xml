<Type Name="ResourceDictionary" FullName="System.Windows.ResourceDictionary">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f859d87dbc5cb4e1949393abb5fa652fe9bc3088" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36457904" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ResourceDictionary : System.Collections.IDictionary, System.ComponentModel.ISupportInitialize, System.Windows.Markup.INameScope, System.Windows.Markup.IUriContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ResourceDictionary extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.ComponentModel.ISupportInitialize, class System.Windows.Markup.INameScope, class System.Windows.Markup.IUriContext" />
  <TypeSignature Language="DocId" Value="T:System.Windows.ResourceDictionary" />
  <TypeSignature Language="VB.NET" Value="Public Class ResourceDictionary&#xA;Implements IDictionary, INameScope, ISupportInitialize, IUriContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceDictionary : System::Collections::IDictionary, System::ComponentModel::ISupportInitialize, System::Windows::Markup::INameScope, System::Windows::Markup::IUriContext" />
  <TypeSignature Language="F#" Value="type ResourceDictionary = class&#xA;    interface IDictionary&#xA;    interface ICollection&#xA;    interface IEnumerable&#xA;    interface ISupportInitialize&#xA;    interface IUriContext&#xA;    interface INameScope" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.INameScope</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IUriContext</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.Ambient</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia tablicy skrótów / implementacji słownik, który zawiera zasoby WPF używanych przez składniki i inne elementy aplikacji WPF.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy w <xref:System.Windows.ResourceDictionary> nie są natychmiast przetwarzane, gdy ładowany przez kod aplikacji [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] modułu ładującego. Zamiast tego <xref:System.Windows.ResourceDictionary> będzie nadal występował jako obiekt, a poszczególne wartości są przetwarzane tylko wtedy, gdy w szczególności żądania.  
  
 <xref:System.Windows.ResourceDictionary> Nie pochodzi od klasy <xref:System.Collections.DictionaryBase>. Zamiast tego <xref:System.Windows.ResourceDictionary> klasa implementuje <xref:System.Collections.IDictionary> , ale zależy od <xref:System.Collections.Hashtable> wewnętrznie.  
  
 W [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], <xref:System.Windows.ResourceDictionary> klasy jest zwykle elementu kolekcji niejawne wartości elementu obiektu kilku `Resources` właściwości, gdy w składni elementu właściwości. Szczegółowe informacje na temat niejawne kolekcji w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], zobacz [szczegółów w składni języka XAML](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md). Jest wyjątek, jeśli chcesz określić scalonych słownika. Aby uzyskać więcej informacji, zobacz [scalić słowniki zasobów](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
 Inny możliwe [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] użycie jest aby zadeklarować słownik zasobów jako osobny [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] pliku, a następnie załadować go w czasie wykonywania w <xref:System.Windows.Markup.XamlReader.Load%2A> lub uwzględniania go w projekcie (pełnego zaufania) jako zasobu lub utracić plik. W takim przypadku <xref:System.Windows.ResourceDictionary> mogą być deklarowane jako elementu obiektu, służąc jako element główny [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Zamapuj odpowiednie wartości przestrzeni nazw XML (domyślne dla [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] przestrzeni nazw i zazwyczaj `x:` dla [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] przestrzeni nazw) na <xref:System.Windows.ResourceDictionary> elementu, jeśli planujesz używać go jako element główny. Następnie można dodać elementy podrzędne, które określają zasoby, z których każda [x: Key](~/docs/framework/xaml-services/x-key-directive.md) wartość.  
  
<a name="xamlImplicitCollectionUsage_ResourceDictionary"></a>   
## <a name="xaml-implicit-collection-usage"></a>Użycie niejawnej kolekcji języka XAML  
  
```  
<object>  
  <object.resourcesProperty>  
    oneOrMoreResources  
  </object.resourcesProperty>  
</object>  
```  
  
<a name="xamlValues_ResourceDictionary"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *resourcesProperty*  
 Określanie elementu właściwości, których typem wartość tej właściwości jest właściwością <xref:System.Windows.ResourceDictionary>. Zazwyczaj jest to `Resources` właściwość <xref:System.Windows.FrameworkElement> lub <xref:System.Windows.FrameworkContentElement>, lub <xref:System.Windows.Application> w przypadku zasobów aplikacji.  
  
 *oneOrMoreResources*  
 Co najmniej jeden zasób określony jako elementy obiektu. Wszystkie zasoby, które określisz musi mieć [dyrektywy x: Key](~/docs/framework/xaml-services/x-key-directive.md) przypisane.  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.FrameworkElement.Resources" />
    <altmember cref="P:System.Windows.Application.Resources" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceDictionary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceDictionary();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.ResourceDictionary" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Add : obj * obj -&gt; unit&#xA;override this.Add : obj * obj -&gt; unit" Usage="resourceDictionary.Add (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Nazwa klucz do dodania.</param>
        <param name="value">Wartość zasobów do dodania.</param>
        <summary>Dodaje do tego zasobu klucza <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Próba dodania zduplikowanego klucza zgłasza wyjątek.  
  
 Klucze są zawsze dodawane do podstawowego słownika. Klucze w <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> w bieżącym <xref:System.Windows.ResourceDictionary> nie są sprawdzane do duplikacji, podstawowego słownika jest sprawdzany pod kątem duplikatów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Windows.ResourceDictionary" /> Jest zablokowany lub tylko do odczytu.</exception>
        <exception cref="T:System.ArgumentException">Element z tym samym kluczem już istnieje w <see cref="T:System.Collections.Hashtable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="resourceDictionary.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna się faza inicjowania dla tego <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody zawiera wskazanie, który zawartość <xref:System.Windows.ResourceDictionary> mają być załadowane. Następnym krokiem w procesie jest wywołać <xref:System.Windows.ResourceDictionary.EndInit%2A>.  
  
 Nie wywołuj <xref:System.Windows.ResourceDictionary.BeginInit%2A> więcej niż raz, przed wywołaniem <xref:System.Windows.ResourceDictionary.EndInit%2A>. Dzięki temu zgłosi wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wywołuje się <see cref="M:System.Windows.ResourceDictionary.BeginInit" /> więcej niż jednokrotnie przed <see cref="M:System.Windows.ResourceDictionary.EndInit" /> została wywołana.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="resourceDictionary.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie klucze (i wartości) w podstawowym <see cref="T:System.Windows.ResourceDictionary" />. To nie wyczyść wszystkie scalane elementów słownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby wyczyścić elementy scalone słownika należy uzyskać określonego słownika z <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> kolekcji, a w szczególności wywołania <xref:System.Windows.ResourceDictionary.Clear%2A> na tej <xref:System.Windows.ResourceDictionary>, chociaż zazwyczaj słowników są zdalnego i nie może mieć dostęp. Można również usunąć cały <xref:System.Windows.ResourceDictionary> z <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> wywołując Usuń w zbiorze ogólnym.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="resourceDictionary.Contains key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz do zlokalizowania w <see cref="T:System.Windows.ResourceDictionary" />.</param>
        <summary>Określa, czy <see cref="T:System.Windows.ResourceDictionary" /> zawiera element z określonym kluczem.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Windows.ResourceDictionary" /> zawiera pary klucz wartość z określonym kluczem, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli żądany klucz nie jest w tym słowniku zasobów, logika wyszukiwania zasobów również sprawdzi scalonych słownikach.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.MergedDictionaries" />
        <altmember cref="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Collections.DictionaryEntry[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(valuetype System.Collections.DictionaryEntry[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.CopyTo(System.Collections.DictionaryEntry[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As DictionaryEntry(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;System::Collections::DictionaryEntry&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.Collections.DictionaryEntry[] * int -&gt; unit" Usage="resourceDictionary.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.DictionaryEntry[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa tablica, która jest lokalizacją docelową <see cref="T:System.Collections.DictionaryEntry" /> obiektów kopiowanych ze <see cref="T:System.Windows.ResourceDictionary" /> wystąpienia. Tablica musi mieć indeksowane zaczynające od zera.</param>
        <param name="arrayIndex">Liczony od zera indeks <c>tablicy</c> którym rozpoczyna się kopiowanie.</param>
        <summary>Kopie <see cref="T:System.Windows.ResourceDictionary" /> elementów na jednowymiarowe <see cref="T:System.Collections.DictionaryEntry" /> pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spowoduje to skopiowanie podstawowego słownika. Tablica wynikowa będzie mieć nie <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> , jeśli jest on odtworzenia jako <xref:System.Windows.ResourceDictionary> ponownie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Windows.ResourceDictionary.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę wpisów w podstawowym <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <value>Bieżąca liczba wpisów w słowniku podstawowej.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="DeferrableContent">
      <MemberSignature Language="C#" Value="public System.Windows.DeferrableContent DeferrableContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DeferrableContent DeferrableContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.DeferrableContent" />
      <MemberSignature Language="VB.NET" Value="Public Property DeferrableContent As DeferrableContent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DeferrableContent ^ DeferrableContent { System::Windows::DeferrableContent ^ get(); void set(System::Windows::DeferrableContent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DeferrableContent : System.Windows.DeferrableContent with get, set" Usage="System.Windows.ResourceDictionary.DeferrableContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DeferrableContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zawartość dla tego słownika zasobów.</summary>
        <value>Zawsze zwraca <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="resourceDictionary.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kończy się na etapie inicjalizacji i unieważnia poprzedniej drzewa w taki sposób, że wszystkie zmiany wprowadzone do kluczy w fazie inicjowania mogą znajdować się.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ResourceDictionary.BeginInit%2A> i <xref:System.Windows.ResourceDictionary.EndInit%2A> postępuj zgodnie z modelem transakcji. <xref:System.Windows.ResourceDictionary.BeginInit%2A> oznacza słownika odinicjowany i <xref:System.Windows.ResourceDictionary.EndInit%2A> znaczniki on zainicjowany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member FindName : string -&gt; obj&#xA;override this.FindName : string -&gt; obj" Usage="resourceDictionary.FindName name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.FindName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Identyfikator nazwy dla żądanego obiektu.</param>
        <summary>Nie są obsługiwane przez tę implementację słownika.</summary>
        <returns>Zawsze zwraca <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ResourceDictionary> Klasa nie obsługuje rejestrowania według nazwy. Zamiast tego użyto kluczy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="resourceDictionary.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Collections.IDictionaryEnumerator" /> który może służyć do iterowania po <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <returns>Specjalne modułu wyliczającego dla <see cref="T:System.Windows.ResourceDictionary" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Iterator jest tylko podstawowego słownika.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidatesImplicitDataTemplateResources">
      <MemberSignature Language="C#" Value="public bool InvalidatesImplicitDataTemplateResources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InvalidatesImplicitDataTemplateResources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.InvalidatesImplicitDataTemplateResources" />
      <MemberSignature Language="VB.NET" Value="Public Property InvalidatesImplicitDataTemplateResources As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InvalidatesImplicitDataTemplateResources { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InvalidatesImplicitDataTemplateResources : bool with get, set" Usage="System.Windows.ResourceDictionary.InvalidatesImplicitDataTemplateResources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy invalidations wywoływane przez <see cref="T:System.Windows.ResourceDictionary" /> obiekt Przyczyna <see cref="T:System.Windows.Controls.ContentPresenter" /> obiektów, aby obliczyć ponownie wybór szablonu. Invalidations się zdarzyć, gdy zmiany zasobu szablon niejawne danych.</summary>
        <value>
          <see langword="true" /> Jeśli spowodować invalidations <see cref="T:System.Windows.Controls.ContentPresenter" /> obiektów, aby obliczyć ponownie wybór szablonu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Windows.ResourceDictionary.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy to <see cref="T:System.Windows.ResourceDictionary" /> ma stały rozmiar.</summary>
        <value>
          <see langword="true" /> w przypadku tablicy skrótów stałym rozmiarze; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca <xref:System.Collections.Hashtable> domyślna, czyli `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Windows.ResourceDictionary.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy to <see cref="T:System.Windows.ResourceDictionary" /> jest tylko do odczytu.</summary>
        <value>
          <see langword="true" /> Jeśli tabela skrótów jest tylko do odczytu. w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca <xref:System.Collections.Hashtable> domyślna, czyli `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Windows.ResourceDictionary.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Żądany klucz do pobrania lub ustawienia.</param>
        <summary>Pobiera lub ustawia wartość skojarzoną z danym kluczem.</summary>
        <value>Wartość klucza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Żądany klucz nie jest w tym słowniku zasobów, system zasobów framework również sprawdza scalonych słownikach.  
  
 Sprawdzanie <xref:System.Windows.ResourceDictionary> przez element lub indeks nie jest zazwyczaj preferowany sposób pobierania zasobów. Zamiast tego należy wywołać metody wyszukiwania zasobów według ich kluczy, się możliwość uczestnictwa w procesie wyszukiwania wszystkich zasobów i które można znaleźć zasobów w aplikacji i motywów. <xref:System.Windows.FrameworkElement.FindResource%2A> taka metoda jest i znajduje się na dowolnym <xref:System.Windows.FrameworkElement>. W przeciwnym razie próba znalezienia zasobu jest niezgodna true zachowania w czasie wykonywania.  
  
 Jednak uzyskiwania bezpośrednio z poszczególnych słownika zasobów może być odpowiednie, jeśli zasoby są pobierane z znanego <xref:System.Windows.ResourceDictionary> lokalizacji i są to tak, aby uniknąć możliwych wpływ wydajności i zakres wyszukiwania klucza środowiska wykonawczego.  
  
 Indeksatory nie należy używać do definiowania członków kolekcji w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Zamiast tego można utworzyć podrzędne elementy w znaczników. Elementy podrzędne są albo elementy podrzędne <xref:System.Windows.ResourceDictionary>, lub elementu właściwości, której typ właściwości jest `ResourceDictionary`. Aby uzyskać więcej informacji, zobacz [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] użycia sekcje w <xref:System.Windows.ResourceDictionary>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ICollection ^ Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.ICollection" Usage="System.Windows.ResourceDictionary.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję wszystkich kluczy zawartych w tym <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <value>Kolekcja wszystkich kluczy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość nie istnieje, ponieważ jest to wymagane przez <xref:System.Collections.IDictionary>, ale <xref:System.Windows.ResourceDictionary.Keys%2A> zazwyczaj nie jest przydatne w przypadku większości <xref:System.Windows.ResourceDictionary> scenariuszy.  
  
 Zwrócony kluczy nie ma kluczy w <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A>. Kolekcja kluczy jest także migawki kluczy w słowniku podstawowej. Jeśli następnie wprowadzania zmian w tym <xref:System.Windows.ResourceDictionary>, przechowywane <xref:System.Windows.ResourceDictionary.Keys%2A> nie zostaną one zastosowane zmiany.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="MergedDictionaries">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.Windows.ResourceDictionary&gt; MergedDictionaries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.Windows.ResourceDictionary&gt; MergedDictionaries" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.MergedDictionaries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MergedDictionaries As Collection(Of ResourceDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::Windows::ResourceDictionary ^&gt; ^ MergedDictionaries { System::Collections::ObjectModel::Collection&lt;System::Windows::ResourceDictionary ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MergedDictionaries : System.Collections.ObjectModel.Collection&lt;System.Windows.ResourceDictionary&gt;" Usage="System.Windows.ResourceDictionary.MergedDictionaries" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.Windows.ResourceDictionary&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję <see cref="T:System.Windows.ResourceDictionary" /> słowniki wchodzących w skład różnych słowniki zasobów w scalonych słownikach.</summary>
        <value>Kolekcja słowników scalone.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Słowniki są łączone przez dodanie <xref:System.Windows.ResourceDictionary> do kolekcji uniwersalnej, odwołuje się <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A>. Scalone <xref:System.Windows.ResourceDictionary> nie ma zdefiniowanych w nim w znaczniku elementów zasobów. Połączony słownik jest <xref:System.Windows.ResourceDictionary> z elementami podrzędnymi nie znaczników zdefiniowanego (lub z żadnych elementów dodane przy użyciu kodu), ale z [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] określona dla <xref:System.Windows.ResourceDictionary.Source%2A>. <xref:System.Windows.ResourceDictionary.Source%2A> Połączony słownik pochodzić ze źródła zewnętrznego, takich jak zestaw oddzielnych zasobu, który jest dostarczany z aplikacji, umożliwia określenie "utracić [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]", lub określonych lokalizacji lub zestaw zasobów globalnych.  
  
 Określanie elementów zasobów w ramach <xref:System.Windows.ResourceDictionary> mający <xref:System.Windows.ResourceDictionary.Source%2A> określonego nie jest obsługiwane.  
  
 Zachowanie wyszukiwania w obrębie <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> kolekcji przeszukuje ostatnio dodane <xref:System.Windows.ResourceDictionary> pierwszy i zatrzymuje wyszukiwania, jak żądany klucz zostanie znaleziony. Zduplikowane klucze w kolekcji scalonych słownikach nie są niedozwolone. Aby uzyskać więcej informacji dotyczących zachowania połączony słownik, zobacz [scalonych słownikach zasobów](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
<a name="xamlPropertyElementUsage_MergedDictionaries"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.MergedDictionaries>  
    oneOrMoreResourceDictionaries  
  </object.MergedDictionaries>  
</object>  
  
```  
  
<a name="xamlValues_MergedDictionaries"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *oneOrMoreResourceDictionaries*  
 Co najmniej jeden <xref:System.Windows.ResourceDictionary> obiekt elementów. A <xref:System.Windows.ResourceDictionary> używany do <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> nie ma zawartości kolekcji i określa <xref:System.Windows.ResourceDictionary.Source%2A> atrybut, który odwołuje się do pełnej <xref:System.Windows.ResourceDictionary> zdalnie.  
  
   
  
## Examples  
 W poniższym przykładzie dwa <xref:System.Windows.ResourceDictionary> elementy, które można scalić w podstawowym <xref:System.Windows.ResourceDictionary>.  
  
 [!code-xaml[ResourceMergeDictionary#MergedXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ResourceMergeDictionary/CS/default.xaml#mergedxaml)]   
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.Source" />
      </Docs>
    </Member>
    <Member MemberName="OnGettingValue">
      <MemberSignature Language="C#" Value="protected virtual void OnGettingValue (object key, ref object value, out bool canCache);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGettingValue(object key, object&amp; value, [out] bool&amp; canCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.OnGettingValue(System.Object,System.Object@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGettingValue (key As Object, ByRef value As Object, ByRef canCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGettingValue(System::Object ^ key, System::Object ^ % value, [Runtime::InteropServices::Out] bool % canCache);" />
      <MemberSignature Language="F#" Value="abstract member OnGettingValue : obj *  *  -&gt; unit&#xA;override this.OnGettingValue : obj *  *  -&gt; unit" Usage="resourceDictionary.OnGettingValue (key, value, canCache)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="canCache" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Klucz zasobu do pobrania.</param>
        <param name="value">Wartość żądanego zasobu.</param>
        <param name="canCache">
          <see langword="true" /> Jeśli zasób może zapisane i użyte później; w przeciwnym razie <see langword="false" />.</param>
        <summary>Występuje, gdy <see cref="T:System.Windows.ResourceDictionary" /> odbiera żądanie zasobu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="abstract member RegisterName : string * obj -&gt; unit&#xA;override this.RegisterName : string * obj -&gt; unit" Usage="resourceDictionary.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.RegisterName(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Nieobsługiwane.</param>
        <param name="scopedElement">Nieobsługiwane.</param>
        <summary>Nie są obsługiwane przez tę implementację słownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ResourceDictionary> Klasa nie obsługuje rejestrowania według nazwy. Zamiast tego użyto kluczy. Metody namescope XAML są zaimplementowane jako niedziałających wersji w <xref:System.Windows.ResourceDictionary> wyjaśniające tego XAML nazwy są stosowane do zasobów.  
  
 Wywołanie tej metody spowoduje, że <xref:System.NotSupportedException> zostanie wygenerowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">We wszystkich przypadkach, gdy ta metoda jest wywoływana.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (key As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : obj -&gt; unit&#xA;override this.Remove : obj -&gt; unit" Usage="resourceDictionary.Remove key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz wpisu do usunięcia.</param>
        <summary>Usuwa wpis z określonym kluczem z podstawowego słownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.ResourceDictionary> nie zawiera element z określonym kluczem <xref:System.Windows.ResourceDictionary> pozostaje niezmieniona. Nie wyjątek.  
  
 Ta metoda nie powoduje usunięcia kluczy z <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A>. Należy uzyskać konkretnym <xref:System.Windows.ResourceDictionary> z kolekcji, aby usunąć te klucze, ale który może nie być możliwe ponieważ są zwykle dostęp do takich słownika zdalnie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Windows.ResourceDictionary" /> Jest zablokowany lub tylko do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public Uri Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Source { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : Uri with get, set" Usage="System.Windows.ResourceDictionary.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia [! INCLUDE[TLA#tla_uri](~/includes/tlasharptla-URI-MD.MD)] załadować zasobów z.</summary>
        <value>Lokalizacja źródła zewnętrznego słownika zasobów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj <xref:System.Windows.ResourceDictionary.Source%2A> jest określony jako identyfikator URI pakietu, który odwołuje się do lokalizacji słownika zasobów, nie jest uwzględniana jako Nieskompilowane zasobów lub zawartości akcji kompilacji projektu tworzenia aplikacji. Aby uzyskać więcej informacji o formacie identyfikatora URI elementu Pack, zobacz [identyfikatorów URI pakietu na platformie WPF](~/docs/framework/wpf/app-development/pack-uris-in-wpf.md).  
  
 Ogólnie rzecz biorąc <xref:System.Windows.ResourceDictionary.Source%2A> właściwość ma wartość tylko dla <xref:System.Windows.ResourceDictionary> dla określono <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> właściwości (albo jako elementu właściwości w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], lub jako <xref:System.Windows.ResourceDictionary> element kolekcji w kodzie). W tym kontekście ustawienie wartości dla <xref:System.Windows.ResourceDictionary.Source%2A> zostaną scalone zawartość słownika znaleźć pod adresem podane [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] do bieżącego <xref:System.Windows.ResourceDictionary>. Wszelkie błędy ładowania spowoduje, że wyjątek zostanie wygenerowany.  
  
   
  
## Examples  
 W poniższym przykładzie dwa <xref:System.Windows.ResourceDictionary> elementy, które można scalić w podstawowym <xref:System.Windows.ResourceDictionary>.  
  
 [!code-xaml[ResourceMergeDictionary#MergedXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ResourceMergeDictionary/CS/default.xaml#mergedxaml)]   
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.MergedDictionaries" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Liczony od zera <see cref="T:System.Array" /> odbierająca skopiowane elementy z <see cref="T:System.Windows.Markup.Localizer.BamlLocalizationDictionary" />.</param>
        <param name="arrayIndex">Pierwszą pozycję w określonym <see cref="T:System.Array" /> do odbierania skopiowane dane.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Windows.ResourceDictionary> wystąpienia jest rzutowane na <xref:System.Collections.ICollection> interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ResourceDictionary.CopyTo(System.Collections.DictionaryEntry[],System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Windows.ResourceDictionary.System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Collections.ICollection.IsSynchronized" />.</summary>
        <value>
          <see langword="true" /> Jeśli dostęp do <see cref="T:System.Windows.ResourceDictionary" /> jest synchronizowane (wielowątkowość); w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Windows.ResourceDictionary> wystąpienia jest rzutowane na <xref:System.Collections.ICollection> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Windows.ResourceDictionary.System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Collections.ICollection.SyncRoot" />.</summary>
        <value>Obiekt, który może służyć do synchronizujący dostęp do <see cref="T:System.Windows.ResourceDictionary" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Windows.ResourceDictionary> wystąpienia jest rzutowane na <xref:System.Collections.ICollection> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.Collections.IEnumerable.GetEnumerator" />.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> Obiekt, który może służyć do iterowania po kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Windows.ResourceDictionary> wystąpienia jest rzutowane na <xref:System.Collections.IEnumerable> interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ResourceDictionary.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IUriContext.BaseUri">
      <MemberSignature Language="C#" Value="Uri System.Windows.Markup.IUriContext.BaseUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri System.Windows.Markup.IUriContext.BaseUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.System#Windows#Markup#IUriContext#BaseUri" />
      <MemberSignature Language="VB.NET" Value=" Property BaseUri As Uri Implements IUriContext.BaseUri" />
      <MemberSignature Language="C++ CLI" Value="property Uri ^ System.Windows.Markup.IUriContext.BaseUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Windows.ResourceDictionary.System.Windows.Markup.IUriContext.BaseUri" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IUriContext.BaseUri</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Windows.Markup.IUriContext.BaseUri" />.</summary>
        <value>Podstawowym [! INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-URI-MD.MD)] bieżącego kontekstu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Windows.ResourceDictionary> wystąpienia jest rzutowane na <xref:System.Windows.Markup.IUriContext> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member UnregisterName : string -&gt; unit&#xA;override this.UnregisterName : string -&gt; unit" Usage="resourceDictionary.UnregisterName name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.UnregisterName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nieobsługiwane.</param>
        <summary>Nie są obsługiwane przez tę implementację słownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ResourceDictionary> Klasa nie obsługuje rejestrowania według nazwy. Zamiast tego użyto kluczy. Wywołanie tej metody nie działają.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ICollection ^ Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.ICollection" Usage="System.Windows.ResourceDictionary.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję wszystkie wartości skojarzone z kluczy zawartych w tym <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <value>Kolekcja wszystkich wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość nie istnieje, ponieważ jest to wymagane przez <xref:System.Collections.IDictionary>, ale zazwyczaj nie jest przydatne w przypadku większości <xref:System.Windows.ResourceDictionary> scenariuszy.  
  
 Wartości zwracane nie zawierają wartości w ramach <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A>. Kolekcja jest również migawkę wartości w słowniku podstawowej. Jeśli następnie wprowadzania zmian w tym <xref:System.Windows.ResourceDictionary>, przechowywane <xref:System.Windows.ResourceDictionary.Values%2A> nie zostaną one zastosowane zmiany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
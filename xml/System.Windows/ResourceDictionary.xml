<Type Name="ResourceDictionary" FullName="System.Windows.ResourceDictionary">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b3b67e3a8038fcd36edfcd277ebdca33c4d099d0" />
    <Meta Name="ms.sourcegitcommit" Value="723b8a6d92667ba86fcda96190bad3b4a03283b3" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/09/2018" />
    <Meta Name="ms.locfileid" Value="51306911" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ResourceDictionary : System.Collections.IDictionary, System.ComponentModel.ISupportInitialize, System.Windows.Markup.INameScope, System.Windows.Markup.IUriContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ResourceDictionary extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.ComponentModel.ISupportInitialize, class System.Windows.Markup.INameScope, class System.Windows.Markup.IUriContext" />
  <TypeSignature Language="DocId" Value="T:System.Windows.ResourceDictionary" />
  <TypeSignature Language="VB.NET" Value="Public Class ResourceDictionary&#xA;Implements IDictionary, INameScope, ISupportInitialize, IUriContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceDictionary : System::Collections::IDictionary, System::ComponentModel::ISupportInitialize, System::Windows::Markup::INameScope, System::Windows::Markup::IUriContext" />
  <TypeSignature Language="F#" Value="type ResourceDictionary = class&#xA;    interface IDictionary&#xA;    interface ICollection&#xA;    interface IEnumerable&#xA;    interface ISupportInitialize&#xA;    interface IUriContext&#xA;    interface INameScope" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.INameScope</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IUriContext</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.Ambient</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zawiera tabelę mieszania / implementacji słownika, która zawiera zasoby WPF używanych przez składniki i inne elementy aplikacji WPF.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy w <xref:System.Windows.ResourceDictionary> nie są natychmiast przetwarzane, gdy kod aplikacji jest ładowany przez [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] modułu ładującego. Zamiast tego <xref:System.Windows.ResourceDictionary> będzie nadal występować jako obiekt, a poszczególne wartości są przetwarzane tylko wtedy, gdy żądanie specjalnie.  
  
 <xref:System.Windows.ResourceDictionary> Nie pochodzi od klasy <xref:System.Collections.DictionaryBase>. Zamiast tego <xref:System.Windows.ResourceDictionary> klasy implementuje <xref:System.Collections.IDictionary> , ale opiera się na <xref:System.Collections.Hashtable> wewnętrznie.  
  
 W [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], <xref:System.Windows.ResourceDictionary> klasy jest zazwyczaj element niejawnej kolekcji, który jest wartością elementu obiektu kilku `Resources` właściwości, gdy podano w składni elementu właściwości. Szczegółowe informacje na temat niejawnej kolekcji w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], zobacz [składnia XAML w szczegółów](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md). Wyjątkiem jest, aby określić scalonych słowników; Aby uzyskać więcej informacji, zobacz [scalone słowniki zasobów](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
 Inną możliwą [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] jest używane do deklarowania słownika zasobów jako osobny [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] pliku, a następnie załadować je w czasie wykonywania za pomocą <xref:System.Windows.Markup.XamlReader.Load%2A> lub dołączyć go w projekcie (zaufaną) jako zasobu lub plik nie będzie. W tym przypadku <xref:System.Windows.ResourceDictionary> mogą być deklarowane jako elementu obiektu, służąc jako element główny [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Musisz dokonać mapowania odpowiednie wartości przestrzeni nazw XML (domyślne dla [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] przestrzeni nazw i zazwyczaj `x:` dla [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] przestrzeni nazw) na <xref:System.Windows.ResourceDictionary> elementu, jeśli planujesz używać go jako element główny. Następnie można dodać elementy podrzędne, które określają zasoby, każdy z [x: Key](~/docs/framework/xaml-services/x-key-directive.md) wartość.  
  
<a name="xamlImplicitCollectionUsage_ResourceDictionary"></a>   
## <a name="xaml-implicit-collection-usage"></a>Użycie niejawnej kolekcji języka XAML  
  
```  
<object>  
  <object.resourcesProperty>  
    oneOrMoreResources  
  </object.resourcesProperty>  
</object>  
```  
  
<a name="xamlValues_ResourceDictionary"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *resourcesProperty*  
 Element właściwości, których typem wartość tej właściwości jest określenie właściwości <xref:System.Windows.ResourceDictionary>. Zazwyczaj jest to `Resources` właściwość <xref:System.Windows.FrameworkElement> lub <xref:System.Windows.FrameworkContentElement>, lub <xref:System.Windows.Application> w przypadku zasobów aplikacji.  
  
 *oneOrMoreResources*  
 Co najmniej jeden zasób określony jako elementów obiektu. Każdy zasób, który określisz musi mieć [x: Key — dyrektywa](~/docs/framework/xaml-services/x-key-directive.md) przypisane.  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.FrameworkElement.Resources" />
    <altmember cref="P:System.Windows.Application.Resources" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceDictionary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceDictionary();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.ResourceDictionary" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Add : obj * obj -&gt; unit&#xA;override this.Add : obj * obj -&gt; unit" Usage="resourceDictionary.Add (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Nazwa klucza do dodania.</param>
        <param name="value">Wartość zasobu do dodania.</param>
        <summary>Dodaje zasobu według klucza to <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podjęto próbę dodania zduplikowanego klucza zgłasza wyjątek.  
  
 Klucze są zawsze dodawane do podstawowej słownika. Klucze w <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> w obrębie bieżącego <xref:System.Windows.ResourceDictionary> nie są sprawdzane pod kątem duplikatów, tylko podstawowego słownika jest sprawdzane dla duplikatów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Windows.ResourceDictionary" /> Jest zablokowany lub tylko do odczytu.</exception>
        <exception cref="T:System.ArgumentException">Element o takim samym kluczem już istnieje w <see cref="T:System.Collections.Hashtable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="resourceDictionary.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna fazy inicjowania dla tego <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody jest wskazaniem, zawartość <xref:System.Windows.ResourceDictionary> mają być załadowane. Następnym krokiem w procesie jest wywołać <xref:System.Windows.ResourceDictionary.EndInit%2A>.  
  
 Nie wywołuj <xref:System.Windows.ResourceDictionary.BeginInit%2A> więcej niż raz, przed wywołaniem <xref:System.Windows.ResourceDictionary.EndInit%2A>. Ten sposób zgłosi wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wywołuje się <see cref="M:System.Windows.ResourceDictionary.BeginInit" /> więcej niż jeden raz przed <see cref="M:System.Windows.ResourceDictionary.EndInit" /> została wywołana.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="resourceDictionary.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie klucze (i wartości) w podstawowym <see cref="T:System.Windows.ResourceDictionary" />. To nie wyczyść wszystkie scalane dictionary elementów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zachodzi potrzeba Wyczyść elementy scalonych słowników, uzyskać określonego słownika z <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> kolekcji, a konkretnie wywołanie <xref:System.Windows.ResourceDictionary.Clear%2A> na tym <xref:System.Windows.ResourceDictionary>, chociaż zazwyczaj słowniki są obiektami zdalnymi i może nie mieć dostępu. Możesz też usunąć całą <xref:System.Windows.ResourceDictionary> z <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> poprzez wywołanie usuwanie w kolekcji ogólnej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="resourceDictionary.Contains key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz do zlokalizowania w <see cref="T:System.Windows.ResourceDictionary" />.</param>
        <summary>Określa, czy <see cref="T:System.Windows.ResourceDictionary" /> zawiera element z określonym kluczem.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Windows.ResourceDictionary" /> zawiera parę klucz wartość z określonym kluczem, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli żądany klucz nie jest w tym słowniku zasobów, logika wyszukiwania zasobów spowoduje również sprawdzić scalonymi słownikami.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.MergedDictionaries" />
        <altmember cref="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Collections.DictionaryEntry[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(valuetype System.Collections.DictionaryEntry[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.CopyTo(System.Collections.DictionaryEntry[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As DictionaryEntry(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;System::Collections::DictionaryEntry&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.Collections.DictionaryEntry[] * int -&gt; unit" Usage="resourceDictionary.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.DictionaryEntry[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa tablica, która jest lokalizacją docelową <see cref="T:System.Collections.DictionaryEntry" /> obiektów kopiowanych ze <see cref="T:System.Windows.ResourceDictionary" /> wystąpienia. Tablica musi mieć indeksowane zaczynające od zera.</param>
        <param name="arrayIndex">Liczony od zera indeks <c>tablicy</c> gdzie rozpoczyna się kopiowanie.</param>
        <summary>Kopiuje <see cref="T:System.Windows.ResourceDictionary" /> elementów do jednowymiarowego obiektu <see cref="T:System.Collections.DictionaryEntry" /> pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spowoduje to skopiowanie tylko podstawowego słownika. Tablica wynikowa nie będą mieć <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> Jeśli jest on odtworzonych jako <xref:System.Windows.ResourceDictionary> ponownie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Windows.ResourceDictionary.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę wpisów w podstawowym <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <value>Bieżąca liczba wpisów z podstawowego słownika.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="DeferrableContent">
      <MemberSignature Language="C#" Value="public System.Windows.DeferrableContent DeferrableContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DeferrableContent DeferrableContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.DeferrableContent" />
      <MemberSignature Language="VB.NET" Value="Public Property DeferrableContent As DeferrableContent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DeferrableContent ^ DeferrableContent { System::Windows::DeferrableContent ^ get(); void set(System::Windows::DeferrableContent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DeferrableContent : System.Windows.DeferrableContent with get, set" Usage="System.Windows.ResourceDictionary.DeferrableContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DeferrableContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia deferrable zawartość dla tego słownika zasobów.</summary>
        <value>Zawsze zwraca <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="resourceDictionary.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kończy fazy inicjowania i unieważnia poprzedniego drzewa w taki sposób, że można uwzględnić wszystkie zmiany wprowadzone do kluczy podczas fazy inicjowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ResourceDictionary.BeginInit%2A> i <xref:System.Windows.ResourceDictionary.EndInit%2A> postępuj zgodnie z modelem transakcji. <xref:System.Windows.ResourceDictionary.BeginInit%2A> oznacza słownika niezainicjowana i <xref:System.Windows.ResourceDictionary.EndInit%2A> znaczniki on zainicjowany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member FindName : string -&gt; obj&#xA;override this.FindName : string -&gt; obj" Usage="resourceDictionary.FindName name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.FindName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Identyfikator nazwy dla obiektu żądanej.</param>
        <summary>Nie są obsługiwane przez tę implementację słownika.</summary>
        <returns>Zawsze zwraca <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ResourceDictionary> Klasa nie obsługuje rejestrowania według nazwy. Zamiast tego używa kluczy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="resourceDictionary.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Collections.IDictionaryEnumerator" /> który może służyć do iterowania po <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <returns>Wyspecjalizowane modułu wyliczającego dla <see cref="T:System.Windows.ResourceDictionary" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Iterator który jest tylko podstawowego słownika.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidatesImplicitDataTemplateResources">
      <MemberSignature Language="C#" Value="public bool InvalidatesImplicitDataTemplateResources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InvalidatesImplicitDataTemplateResources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.InvalidatesImplicitDataTemplateResources" />
      <MemberSignature Language="VB.NET" Value="Public Property InvalidatesImplicitDataTemplateResources As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InvalidatesImplicitDataTemplateResources { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InvalidatesImplicitDataTemplateResources : bool with get, set" Usage="System.Windows.ResourceDictionary.InvalidatesImplicitDataTemplateResources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy invalidations wywoływane przez <see cref="T:System.Windows.ResourceDictionary" /> obiektu Przyczyna <see cref="T:System.Windows.Controls.ContentPresenter" /> obiektów, aby ponownie oceń swoje wybranego szablonu. Invalidations się tak zdarzyć, gdy ulegnie zmianie danych niejawnego szablonu zasobów.</summary>
        <value>
          <see langword="true" /> Jeśli spowoduje invalidations <see cref="T:System.Windows.Controls.ContentPresenter" /> obiektów, aby ponownie oceń wybranych przez nich szablonu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Windows.ResourceDictionary.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy to <see cref="T:System.Windows.ResourceDictionary" /> jest stałym rozmiarze.</summary>
        <value>
          <see langword="true" /> Jeśli tabela skrótu jest stałym rozmiarze; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca <xref:System.Collections.Hashtable> domyślna, czyli `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Windows.ResourceDictionary.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy to <see cref="T:System.Windows.ResourceDictionary" /> jest tylko do odczytu.</summary>
        <value>
          <see langword="true" /> Jeśli tabela skrótu jest tylko do odczytu. w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca <xref:System.Collections.Hashtable> domyślna, czyli `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Windows.ResourceDictionary.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Żądany klucz do pobierania lub ustawiania.</param>
        <summary>Pobiera lub ustawia wartość skojarzoną z danym kluczem.</summary>
        <value>Wartość klucza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli żądany klucz nie jest w tym słowniku zasobów, system zasobów framework również sprawdzi scalonymi słownikami.  
  
 Sprawdzanie <xref:System.Windows.ResourceDictionary> przez element lub indeks nie jest zazwyczaj preferowanym sposobem pobierania zasobów. Zamiast tego należy wywołać metody, są w stanie udział w procesie wyszukiwania wszystkich zasobów i wyszukaj zasoby według ich klucze i który Znajdź zasoby w aplikacjach i motywów. <xref:System.Windows.FrameworkElement.FindResource%2A> jest taka metoda i znajduje się na dowolnym <xref:System.Windows.FrameworkElement>. W przeciwnym razie próba odnaleźć zasobu jest niezgodna true zachowanie w czasie wykonywania.  
  
 Jednak uzyskiwania zasobów bezpośrednio ze słownika indywidualnych może być odpowiednie, jeśli zasoby są pobierane z poprawną <xref:System.Windows.ResourceDictionary> lokalizacji i są to tak, aby uniknąć możliwych wpływ wydajności i zakres wyszukiwania klucza czasu wykonywania.  
  
 Indeksatory nie należy używać do definiowania członków kolekcji w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Zamiast tego należy utworzyć podrzędne elementy w znaczników. Elementy podrzędne są albo elementami podrzędnymi <xref:System.Windows.ResourceDictionary>, lub elementu właściwości, których typ właściwości to `ResourceDictionary`. Aby uzyskać więcej informacji, zobacz [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] użycia sekcje w <xref:System.Windows.ResourceDictionary>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ICollection ^ Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.ICollection" Usage="System.Windows.ResourceDictionary.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję wszystkich kluczy zawartych w tym <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <value>Kolekcja wszystkich kluczy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość istnieje, ponieważ jest to wymagane przez <xref:System.Collections.IDictionary>, ale <xref:System.Windows.ResourceDictionary.Keys%2A> ogólnie nie jest przydatne w przypadku większości <xref:System.Windows.ResourceDictionary> scenariuszy.  
  
 Klucze zwróconego nie dołączaj klucze w ramach <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A>. Również kolekcji kluczy jest migawką kluczy w słowniku podstawowej. Jeśli później wprowadzić zmiany do tego <xref:System.Windows.ResourceDictionary>, przechowywanego <xref:System.Windows.ResourceDictionary.Keys%2A> nie odzwierciedlają zmiany.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="MergedDictionaries">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.Windows.ResourceDictionary&gt; MergedDictionaries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.Windows.ResourceDictionary&gt; MergedDictionaries" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.MergedDictionaries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MergedDictionaries As Collection(Of ResourceDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::Windows::ResourceDictionary ^&gt; ^ MergedDictionaries { System::Collections::ObjectModel::Collection&lt;System::Windows::ResourceDictionary ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MergedDictionaries : System.Collections.ObjectModel.Collection&lt;System.Windows.ResourceDictionary&gt;" Usage="System.Windows.ResourceDictionary.MergedDictionaries" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.Windows.ResourceDictionary&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję <see cref="T:System.Windows.ResourceDictionary" /> słowników wchodzących w skład różnych słownikach zasobów w scalonych słownikach.</summary>
        <value>Kolekcja scalonymi słownikami.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Słowniki są scalane, dodając <xref:System.Windows.ResourceDictionary> do kolekcji ogólnej, odwołuje się <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A>. Scalone <xref:System.Windows.ResourceDictionary> nie ma zasobu elementy zdefiniowane w znacznikach. Zamiast tego jest scalonych słowników <xref:System.Windows.ResourceDictionary> bez znaczników elementów podrzędnych zdefiniowanych (lub bez elementów dodanych do kodu), ale z [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] określony dla <xref:System.Windows.ResourceDictionary.Source%2A>. <xref:System.Windows.ResourceDictionary.Source%2A> Oznaczenia umożliwia scalonych słowników pochodzić z zewnętrznego źródła, takich jak zestaw osobny zasób, który jest dostarczany razem z aplikacją, "luźne [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]", lub określonej lokalizacji lub zestawu zasobów globalnych.  
  
 Określanie elementów zasobów w obrębie <xref:System.Windows.ResourceDictionary> zawierający <xref:System.Windows.ResourceDictionary.Source%2A> określonego nie jest obsługiwane.  
  
 Zachowanie wyszukiwania w ramach <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> kolekcji umożliwia wyszukiwanie ostatnio dodane <xref:System.Windows.ResourceDictionary> pierwszy i zatrzymuje wyszukiwanie, jak żądany klucz zostanie znaleziony. Zduplikowane klucze w kolekcji scalonymi słownikami są niedozwolone. Aby uzyskać więcej informacji na temat zachowania scalonych słowników, zobacz [scalonych słownikach zasobów](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
<a name="xamlPropertyElementUsage_MergedDictionaries"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.MergedDictionaries>  
    oneOrMoreResourceDictionaries  
  </object.MergedDictionaries>  
</object>  
  
```  
  
<a name="xamlValues_MergedDictionaries"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *oneOrMoreResourceDictionaries*  
 Co najmniej jeden <xref:System.Windows.ResourceDictionary> obiektu elementów. A <xref:System.Windows.ResourceDictionary> umożliwiający <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> nie ma zawartości kolekcji i określa <xref:System.Windows.ResourceDictionary.Source%2A> atrybut, który odwołuje się do pełnego <xref:System.Windows.ResourceDictionary> zdalnie.  
  
   
  
## Examples  
 W poniższym przykładzie określono dwa <xref:System.Windows.ResourceDictionary> elementy scalone w podstawowym <xref:System.Windows.ResourceDictionary>.  
  
 [!code-xaml[ResourceMergeDictionary#MergedXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ResourceMergeDictionary/CS/default.xaml#mergedxaml)]   
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.Source" />
      </Docs>
    </Member>
    <Member MemberName="OnGettingValue">
      <MemberSignature Language="C#" Value="protected virtual void OnGettingValue (object key, ref object value, out bool canCache);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGettingValue(object key, object&amp; value, [out] bool&amp; canCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.OnGettingValue(System.Object,System.Object@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGettingValue (key As Object, ByRef value As Object, ByRef canCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGettingValue(System::Object ^ key, System::Object ^ % value, [Runtime::InteropServices::Out] bool % canCache);" />
      <MemberSignature Language="F#" Value="abstract member OnGettingValue : obj *  *  -&gt; unit&#xA;override this.OnGettingValue : obj *  *  -&gt; unit" Usage="resourceDictionary.OnGettingValue (key, value, canCache)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" RefType="ref" />
        <Parameter Name="canCache" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Klucz zasobu, aby pobrać.</param>
        <param name="value">Wartość żądanego zasobu.</param>
        <param name="canCache">
          <see langword="true" /> Jeśli zasób można zapisać i użyty później; w przeciwnym razie <see langword="false" />.</param>
        <summary>Występuje, gdy <see cref="T:System.Windows.ResourceDictionary" /> odbiera żądanie dotyczące zasobów.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="abstract member RegisterName : string * obj -&gt; unit&#xA;override this.RegisterName : string * obj -&gt; unit" Usage="resourceDictionary.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.RegisterName(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Nieobsługiwane.</param>
        <param name="scopedElement">Nieobsługiwane.</param>
        <summary>Nie są obsługiwane przez tę implementację słownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ResourceDictionary> Klasa nie obsługuje rejestrowania według nazwy. Zamiast tego używa kluczy. Metody namescope XAML są implementowane jako wersje niedziałającego w <xref:System.Windows.ResourceDictionary> można było jasne, że XAML nazw są stosowane do zasobów.  
  
 Wywołanie tej metody spowoduje, że <xref:System.NotSupportedException> zostanie wygenerowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">We wszystkich przypadkach, gdy ta metoda jest wywoływana.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (key As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : obj -&gt; unit&#xA;override this.Remove : obj -&gt; unit" Usage="resourceDictionary.Remove key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz wpis do usunięcia.</param>
        <summary>Usuwa wpis z określonym kluczem z podstawowego słownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.ResourceDictionary> nie zawiera element z określonym kluczem <xref:System.Windows.ResourceDictionary> pozostaje bez zmian. Jest zgłaszany żaden wyjątek.  
  
 Ta metoda nie powoduje usunięcia kluczy z <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A>. Należy uzyskać konkretne <xref:System.Windows.ResourceDictionary> z kolekcji, aby usunąć te klucze, ale to może nie być możliwe ponieważ są zwykle dostęp do takich słownika zdalnie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Windows.ResourceDictionary" /> Jest zablokowany lub tylko do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public Uri Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Source { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : Uri with get, set" Usage="System.Windows.ResourceDictionary.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] można załadować zasobów.</summary>
        <value>Lokalizacja źródła zewnętrznego słownika zasobów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj <xref:System.Windows.ResourceDictionary.Source%2A> jest określony jako identyfikatora URI pakietu, który odwołuje się do lokalizacji słownik zasobów, które jest dołączone jako Nieskompilowane akcji kompilacji zasobów lub zawartości przez tworzenie projektu aplikacji. Aby uzyskać szczegółowe informacje o formacie identyfikatora URI pakietu, zobacz [pakiet URI w WPF](~/docs/framework/wpf/app-development/pack-uris-in-wpf.md).  
  
 Ogólnie rzecz biorąc <xref:System.Windows.ResourceDictionary.Source%2A> właściwość jest ustawiona tylko w przypadku <xref:System.Windows.ResourceDictionary> dla określono <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> właściwości (jako prvek Vlastnosti w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], lub jako <xref:System.Windows.ResourceDictionary> element kolekcji w kodzie). W tym kontekście ustawienie wartości dla <xref:System.Windows.ResourceDictionary.Source%2A> scali zawartość słownika znaleźć pod adresem podanym [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] do bieżącej <xref:System.Windows.ResourceDictionary>. Wszelkie błędy ładowania spowoduje zgłoszenie wyjątku.  
  
   
  
## Examples  
 W poniższym przykładzie określono dwa <xref:System.Windows.ResourceDictionary> elementy scalone w podstawowym <xref:System.Windows.ResourceDictionary>.  
  
 [!code-xaml[ResourceMergeDictionary#MergedXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ResourceMergeDictionary/CS/default.xaml#mergedxaml)]   
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.MergedDictionaries" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Liczony od zera <see cref="T:System.Array" /> odbierająca skopiowane elementy z <see cref="T:System.Windows.Markup.Localizer.BamlLocalizationDictionary" />.</param>
        <param name="arrayIndex">Pierwszą pozycję na określonym <see cref="T:System.Array" /> do odbierania skopiowane dane.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.ResourceDictionary> wystąpienia jest rzutowany na <xref:System.Collections.ICollection> interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ResourceDictionary.CopyTo(System.Collections.DictionaryEntry[],System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Collections.ICollection.IsSynchronized" />.</summary>
        <value>
          <see langword="true" /> Jeśli dostęp do <see cref="T:System.Windows.ResourceDictionary" /> jest synchronizowane (wątkowo); w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.ResourceDictionary> wystąpienia jest rzutowany na <xref:System.Collections.ICollection> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Collections.ICollection.SyncRoot" />.</summary>
        <value>Obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Windows.ResourceDictionary" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.ResourceDictionary> wystąpienia jest rzutowany na <xref:System.Collections.ICollection> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.Collections.IEnumerable.GetEnumerator" />.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> Obiekt, który może służyć do iterowania po kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.ResourceDictionary> wystąpienia jest rzutowany na <xref:System.Collections.IEnumerable> interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ResourceDictionary.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IUriContext.BaseUri">
      <MemberSignature Language="C#" Value="Uri System.Windows.Markup.IUriContext.BaseUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri System.Windows.Markup.IUriContext.BaseUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.System#Windows#Markup#IUriContext#BaseUri" />
      <MemberSignature Language="VB.NET" Value=" Property BaseUri As Uri Implements IUriContext.BaseUri" />
      <MemberSignature Language="C++ CLI" Value="property Uri ^ System::Windows::Markup::IUriContext::BaseUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Windows.Markup.IUriContext.BaseUri" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IUriContext.BaseUri</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Windows.Markup.IUriContext.BaseUri" />.</summary>
        <value>Podstawa [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] bieżącego kontekstu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.ResourceDictionary> wystąpienia jest rzutowany na <xref:System.Windows.Markup.IUriContext> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member UnregisterName : string -&gt; unit&#xA;override this.UnregisterName : string -&gt; unit" Usage="resourceDictionary.UnregisterName name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.UnregisterName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nieobsługiwane.</param>
        <summary>Nie są obsługiwane przez tę implementację słownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ResourceDictionary> Klasa nie obsługuje rejestrowania według nazwy. Zamiast tego używa kluczy. Wywołanie tej metody nie działa.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ICollection ^ Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.ICollection" Usage="System.Windows.ResourceDictionary.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję wszystkie wartości skojarzone z kluczy zawartych w tym <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <value>Kolekcja wszystkich wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość istnieje, ponieważ jest to wymagane przez <xref:System.Collections.IDictionary>, ale zwykle nie jest przydatne w przypadku większości <xref:System.Windows.ResourceDictionary> scenariuszy.  
  
 Wartości zwracane przez nie zawierają wartości w ramach <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A>. Również kolekcji jest migawką wartości w słowniku podstawowej. Jeśli później wprowadzić zmiany do tego <xref:System.Windows.ResourceDictionary>, przechowywanego <xref:System.Windows.ResourceDictionary.Values%2A> nie odzwierciedlają zmiany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bcf7dc63deeaebfa62a5b5e0578c3f64cef20e2d" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69433631" /></Metadata><TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type RoutedEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zawiera informacje o stanie i dane zdarzenia skojarzone ze zdarzeniem kierowanym.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Różne <xref:System.Windows.RoutedEventArgs> mogą być używane z pojedynczą <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>. Ta klasa jest odpowiedzialna za pakowanie danych zdarzenia dla a <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>, dostarczanie dodatkowych informacji o stanie zdarzenia i jest używana przez system zdarzeń do wywoływania procedury obsługi skojarzonej ze zdarzeniem kierowanym.  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.RoutedEventArgs" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.RoutedEventArgs" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku korzystania z tego konstruktora bez parametrów wszystkie właściwości publiczne nowego <xref:System.Windows.RoutedEventArgs> wystąpienia zakładają następujące wartości domyślne:  
  
-   <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>wartość domyślna `null`to.  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A>Domyślnie`false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A>wartość domyślna `null`to.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>wartość domyślna `null`to.  
  
 Wartości null dla <xref:System.Windows.RoutedEventArgs.Source%2A> i <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> oznaczają jedynie, że <xref:System.Windows.RoutedEventArgs> dane nie podejmują próby określenia źródła. Gdy to wystąpienie jest używane w wywołaniu <xref:System.Windows.UIElement.RaiseEvent%2A> <xref:System.Windows.RoutedEventArgs.Source%2A> , wartości i <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> są wypełniane na podstawie elementu, który spowodował zdarzenie i są przesyłane do odbiorników za pośrednictwem routingu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs routedEvent" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Identyfikator zdarzenia kierowanego dla tego wystąpienia <see cref="T:System.Windows.RoutedEventArgs" /> klasy.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.RoutedEventArgs" /> klasy przy użyciu dostarczonego identyfikatora zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku korzystania z tego przeciążonego konstruktora nieokreślone właściwości nowego <xref:System.Windows.RoutedEventArgs> wystąpienia zakładają następujące wartości domyślne:  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A>Domyślnie`false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A>wartość domyślna `null`to.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>wartość domyślna `null`to.  
  
 Wartości null dla <xref:System.Windows.RoutedEventArgs.Source%2A> i <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> oznaczają jedynie, że <xref:System.Windows.RoutedEventArgs> nie spowoduje to próby określenia źródła. Gdy to wystąpienie jest używane w wywołaniu <xref:System.Windows.UIElement.RaiseEvent%2A> <xref:System.Windows.RoutedEventArgs.Source%2A> , wartości i <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> są wypełniane na podstawie elementu, który spowodował zdarzenie i są przesyłane do odbiorników za pośrednictwem routingu.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy <xref:System.Windows.RoutedEventArgs> do użycia w <xref:System.Windows.UIElement.RaiseEvent%2A>wywołaniu.  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent * obj -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs (routedEvent, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Identyfikator zdarzenia kierowanego dla tego wystąpienia <see cref="T:System.Windows.RoutedEventArgs" /> klasy.</param>
        <param name="source">Alternatywne źródło, które będzie zgłaszane w przypadku obsługi zdarzenia. Spowoduje to wstępne wypełnienie <see cref="P:System.Windows.RoutedEventArgs.Source" /> właściwości.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.RoutedEventArgs" /> klasy przy użyciu dostarczonego identyfikatora zdarzenia, który umożliwia zadeklarować inne źródło dla zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku korzystania z tego przeciążonego konstruktora nieokreślone właściwości nowego <xref:System.Windows.RoutedEventArgs> wystąpienia zakładają następujące wartości domyślne:  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A>Domyślnie`false`  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>wartość domyślna `null`to.  
  
 Wartości null dla <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> są wypełniane na podstawie elementu, który wywołał zdarzenie i przeszedł przy użyciu routingu, ale zostanie `null` odczytany przed wywołaniem.  
  
 Użyj tej sygnatury podczas <xref:System.Windows.RoutedEventArgs> przekazywania do wirtualnych, takich <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>jak, gdzie argumenty są używane do wewnętrznego <xref:System.Windows.UIElement.RaiseEvent%2A> wywoływania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Handled : bool with get, set" Usage="System.Windows.RoutedEventArgs.Handled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą obecny stan obsługi zdarzeń dla zdarzenia kierowanego w trakcie podróży trasy.</summary>
        <value>Jeśli ustawienie jest ustawione na <see langword="true" /> wartość czy zdarzenie ma być oznaczone jako obsługiwane; w <see langword="false" />przeciwnym razie. W przypadku odczytywania tej <see langword="true" /> wartości wskazuje, że obsługa klasy lub część obsługi wystąpienia w trasie została już oznaczona przez to zdarzenie. <see langword="false" />. wskazuje, że żaden program obsługi nie oznaczył zdarzenia.  
  
Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oznaczenie obsługiwanego zdarzenia spowoduje ograniczenie widoczności zdarzenia kierowanego do detektorów wzdłuż trasy zdarzenia. To zdarzenie nadal podróżuje w pozostałej części trasy, ale tylko programy obsługi, które `HandledEventsToo` zostały dodane <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> `true` w wywołaniu metody, będą wywoływane w odpowiedzi. Domyślne programy obsługi odbiorników wystąpień (takie jak te wyrażone [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]w elemencie) nie będą wywoływane. Obsługa zdarzeń oznaczonych jako obsługiwane nie jest typowym scenariuszem.  
  
 Jeśli jesteś autorem kontrolki, który definiuje własne zdarzenia, podejmowane decyzje dotyczące obsługi zdarzeń na poziomie klasy będą mieć wpływ na użytkowników kontrolki, a także wszystkich użytkowników formantów pochodnych oraz inne elementy, które są zawarte w formancie lub, który zawiera kontrolkę. Aby uzyskać więcej informacji, zobacz [oznaczanie zdarzeń kierowanych jako obsłużone i obsługa klas](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 W bardzo rzadkich przypadkach jest odpowiednie do obsługi zdarzeń, <xref:System.Windows.RoutedEventArgs.Handled%2A> gdzie jest `true`oznaczona, i modyfikowanie argumentów zdarzeń przez zmianę <xref:System.Windows.RoutedEventArgs.Handled%2A> na `false`. Może to być konieczne w niektórych obszarach wejściowych zdarzeń kontroli, takich jak obsługa <xref:System.Windows.UIElement.KeyDown> <xref:System.Windows.UIElement.TextInput> klucza w przypadku, gdy zdarzenia wejściowe niskiego poziomu i wysokiego poziomu konkurują się z obsługą, a każda z nich próbuje współpracować z inną strategią routingu.  
  
   
  
## Examples  
 Poniższy przykład implementuje procedurę obsługi zdarzeń, która oznacza, że zdarzenie jest obsługiwane.  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberSignature Language="F#" Value="abstract member InvokeEventHandler : Delegate * obj -&gt; unit&#xA;override this.InvokeEventHandler : Delegate * obj -&gt; unit" Usage="routedEventArgs.InvokeEventHandler (genericHandler, genericTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">Procedura obsługi ogólnej/obiektu delegowanego, który ma zostać wywołany.</param>
        <param name="genericTarget">Obiekt docelowy, w którym powinien zostać wywołany dostarczony program obsługi.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, zapewnia sposób wywoływania programów obsługi zdarzeń w sposób specyficzny dla typu, co może zwiększyć wydajność w porównaniu z podstawową implementacją.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podstawowa implementacja opiera odbicie w celu określenia odpowiedniej procedury obsługi w każdym przypadku, gdy program obsługi nie jest dosłownie <xref:System.Windows.RoutedEventHandler>i ten krok odbicia ma pewne konsekwencje związane z wydajnością. Wywołania mogą być bardziej wydajne, nie polegają na odbiciu. Jest to scenariusz, w którym ta metoda jest dostępna dla każdej klasy argumentów zdarzeń kierowanych, która ma zostać przesłonięta. Implementacje nie powinny wywoływać podstawy dla tej metody, ponieważ implementacja powinna już być odpowiedzialna za wywoływanie bezpiecznych programów obsługi.  
  
   
  
## Examples  
 Poniżej przedstawiono pseudokodzie, który ilustruje podstawowy wzorzec, który może być używany do implementacji. W tym miejscu <xref:System.Windows.RoutedEventHandler> jestpodklasą`MyRoutedEventHandler` klasy.  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ta metoda jest przeznaczona do przesłaniania przez pochodne klasy danych zdarzeń w celu zapewnienia bardziej wydajnego wywołania swoich delegatów. Implementacja powinna rzutować podane <paramref name="genericHandler" /> do delegata specyficznego dla typu, a następnie wywołać tę procedurę obsługi.  
  
Domyślna implementacja podejmie próbę wywołania podanej procedury obsługi, próbując ją rzutować jako <see cref="T:System.Windows.RoutedEventHandler" />. <paramref name="genericHandler" /> Jeśli lub <paramref name="genericTarget" /> jest określony jako <see langword="null" />, zostaną zgłoszone wyjątki.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member OnSetSource : obj -&gt; unit&#xA;override this.OnSetSource : obj -&gt; unit" Usage="routedEventArgs.OnSetSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Nowa wartość, która <see cref="P:System.Windows.RoutedEventArgs.Source" /> jest ustawiana na.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, udostępnia punkt wejścia wywołania zwrotnego powiadomienia za każdym razem <see cref="P:System.Windows.RoutedEventArgs.Source" /> , gdy wartość właściwości wystąpienia zostanie zmieniona.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Zmiana zgłoszonego źródła zdarzenia programowo może potencjalnie wymagać aktualizacji danych specyficznych dla typu w ramach zdarzenia. Z <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> tego powodu Metoda jest chroniona jako wirtualna i jest przeznaczona do przesłaniania przez podklasy <see cref="T:System.Windows.RoutedEventArgs" />.  
  
Ta metoda nie ma domyślnej implementacji.</para></block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalSource : obj" Usage="System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera oryginalne źródło raportowania określone przez czyste Testy trafień przed dopuszczalną <see cref="P:System.Windows.RoutedEventArgs.Source" /> korektą przez klasę nadrzędną.</summary>
        <value>Oryginalne źródło raportowania przed wszelkimi możliwymi <see cref="P:System.Windows.RoutedEventArgs.Source" /> korektami w ramach obsługi klas, które mogły zostać wykonane w celu spłaszczenia złożonych drzew elementów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość uzyskuje swoją wartość raz, zanim zostaną wywołane procedury obsługi zdarzeń klasy lub wszystkie procedury obsługi wystąpień, i nigdy nie zostanie ona zmieniona po tym punkcie. Oryginalne informacje o źródle są tylko do odczytu do programów obsługi klas lub implementacji klas, tak jak w przypadku zgłoszenia w danych zdarzenia.  
  
 Typowe przypadki, w których można dostosować źródło, obejmują elementy zawartości w modelu zawartości dla kontrolki (zawartość elementu listy, na przykład, będzie zgłaszać element listy jako <xref:System.Windows.RoutedEventArgs.Source%2A> i rzeczywisty element w ramach elementu listy będzie <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.  
  
 Korekta źródła według różnych elementów i modeli zawartości różni się od klasy do klasy. Każda klasa, która dostosowuje źródła zdarzeń, próbuje przewidzieć, które źródło jest najbardziej przydatne do zgłaszania większości scenariuszy wejściowych i scenariuszy, dla których Klasa jest zamierzona, a następnie ustawia to źródło <xref:System.Windows.RoutedEventArgs.Source%2A>jako. Jeśli to źródło nie jest tym, które ma znaczenie dla obsługi zdarzenia, spróbuj sprawdzić <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> zamiast tego, czy zgłasza inne źródło, które jest bardziej odpowiednie. Aby uzyskać więcej informacji na temat zdarzeń wejściowych, zobacz [Omówienie danych wejściowych](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RoutedEvent : System.Windows.RoutedEvent with get, set" Usage="System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> skojarzenie skojarzone z <see cref="T:System.Windows.RoutedEventArgs" /> tym wystąpieniem.</summary>
        <value>Identyfikator zdarzenia, który został wywołany.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można ustawić tej wartości na serwerze <xref:System.Windows.RoutedEventArgs> , który został już rozesłany (na przykład w przypadku uzyskania argumentów za pomocą procedury obsługi). Próba wykonania tej czynności spowoduje wygenerowanie wyjątku. Można ją ustawić tylko dla wystąpienia, które nie zostało jeszcze użyte do wygenerowania wywołania zdarzenia.  
  
 Wartość <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> nie może być `null` w dowolnym momencie.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowe przekazane dane zdarzeń z konstruktorem początkowym, a następnie ustawia <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> właściwość jako kolejną operację. Przed podnoszeniem zdarzenia kierowanego należy <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> ustawić zestaw.  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę zmiany <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> wartości podczas routingu zdarzenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : obj with get, set" Usage="System.Windows.RoutedEventArgs.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia odwołanie do obiektu, który wywołał zdarzenie.</summary>
        <value>Obiekt, który wywołał zdarzenie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku dowolnego zdarzenia z propagacją bąbelkową, które faktycznie przebyło trasę poza elementem, który je podniósł, oraz w przypadku dowolnego tunelowanego wydarzenia, które jeszcze nie zostało tunelowane w dół do elementu, który je podniósł, wartość <xref:System.Windows.RoutedEventArgs.Source%2A> będzie inna niż wartość `sender` parametr klasy argumentów zdarzeń. Który z dwóch elementów uwzględnionych w zdarzeniu jest najbardziej istotny w przypadku każdej procedury obsługi (<xref:System.Windows.RoutedEventArgs.Source%2A>, elementu, który go spowodował, lub `sender`element, który jest obecnie obsługiwany) zależy od logiki aplikacji, która jest obsługiwana przez program obsługi adresowania.  
  
 Ustawienie tej właściwości jest zazwyczaj wykonywane tylko przy zastępowaniu lub implementacji [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] innych, które dostosowują źródła zdarzeń, na przykład gdy klasa obsługuje zdarzenie. Nie zaleca się resetowania pozornych źródeł zdarzeń z procedur obsługi wystąpień, szczególnie w przypadku, gdy program obsługi nie oznaczy zdarzenia jako obsługiwanego.  
  
 Jeśli zresetujesz <xref:System.Windows.RoutedEventArgs.Source%2A> , aby zgłosić inne źródło zdarzeń, <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> program będzie kontynuował zgłaszanie źródła jako pierwsze <xref:System.Windows.UIElement.RaiseEvent%2A> zgłoszone przez wywołanie źródłowe.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="21f68e6f314d849540abfcb8c2deb7a7baf7fada" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36457563" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type RoutedEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zawiera informacje i zdarzeń danych o stanie skojarzone z kierowanego zdarzenia.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Różne <xref:System.Windows.RoutedEventArgs> może być używany z pojedynczym <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>. Ta klasa jest odpowiedzialny za pakowanie danych zdarzeń dla <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>, zapewniając zdarzeń dodatkowe informacje o stanie i jest używany przez system obsługi zdarzeń do wywoływania skojarzonej kierowanego zdarzenia obsługi.  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.RoutedEventArgs" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.RoutedEventArgs" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystając z tego konstruktora bez parametrów, właściwości wszystkich publicznych nowej <xref:System.Windows.RoutedEventArgs> wystąpienia przyjmuje następujące wartości domyślne:  
  
-   <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> Domyślnie `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> Wartość domyślna to `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> Domyślnie `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> Domyślnie `null`.  
  
 Wartości null <xref:System.Windows.RoutedEventArgs.Source%2A> i <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> tylko oznaczają, że <xref:System.Windows.RoutedEventArgs> danych powoduje, że próba Określ źródło. Gdy to wystąpienie jest używane w wywołaniu <xref:System.Windows.UIElement.RaiseEvent%2A>, <xref:System.Windows.RoutedEventArgs.Source%2A> i <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> wartości zostaną wypełnione oparte na element, który wywołał zdarzenie i są przekazywane do odbiorników przy użyciu routingu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs routedEvent" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Identyfikator kierowanego zdarzenia dla tego wystąpienia <see cref="T:System.Windows.RoutedEventArgs" /> klasy.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.RoutedEventArgs" /> klasy, za pomocą identyfikatora dostarczonego kierowanego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystając z tego przeciążonego konstruktora, nieokreślone właściwości nowej <xref:System.Windows.RoutedEventArgs> wystąpienia przyjmuje następujące wartości domyślne:  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> Wartość domyślna to `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> Domyślnie `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> Domyślnie `null`.  
  
 Wartości null <xref:System.Windows.RoutedEventArgs.Source%2A> i <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> tylko oznaczają, że to <xref:System.Windows.RoutedEventArgs> sprawia, że próba Określ źródło. Gdy to wystąpienie jest używane w wywołaniu <xref:System.Windows.UIElement.RaiseEvent%2A>, <xref:System.Windows.RoutedEventArgs.Source%2A> i <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> wartości zostaną wypełnione oparte na element, który wywołał zdarzenie i są przekazywane do odbiorników przy użyciu routingu.  
  
   
  
## Examples  
 Poniższy przykład tworzy nową <xref:System.Windows.RoutedEventArgs> do użycia w wywołaniu <xref:System.Windows.UIElement.RaiseEvent%2A>.  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent * obj -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs (routedEvent, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Identyfikator kierowanego zdarzenia dla tego wystąpienia <see cref="T:System.Windows.RoutedEventArgs" /> klasy.</param>
        <param name="source">Alternatywne źródło, które będą zgłaszane, gdy zdarzenie jest obsługiwane. Spowoduje to wstępne wypełnienie <see cref="P:System.Windows.RoutedEventArgs.Source" /> właściwości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.RoutedEventArgs" /> klasy, za pomocą identyfikatora dostarczonego kierowanego zdarzenia i zapewniając możliwość zadeklarować innego źródła zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystając z tego przeciążonego konstruktora, nieokreślone właściwości nowej <xref:System.Windows.RoutedEventArgs> wystąpienia przyjmuje następujące wartości domyślne:  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> Wartość domyślna to `false`  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> Domyślnie `null`.  
  
 Wartości null <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> zostaną wypełnione na element, który wywołał zdarzenie i routingu, przekazywane podstawie, ale odczyta `null` przed wywołaniem.  
  
 Użyj tego podpisu, podczas przekazywania <xref:System.Windows.RoutedEventArgs> do elementów wirtualnych, takie jak <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>, gdzie argumenty są używane do wywoływania <xref:System.Windows.UIElement.RaiseEvent%2A> wewnętrznie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Handled : bool with get, set" Usage="System.Windows.RoutedEventArgs.Handled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, obecny stan zdarzenia obsługi kierowanego zdarzenia podczas przekazywania trasy.</summary>
        <value>Jeśli ustawienie, ustaw <see langword="true" /> Jeśli zdarzenie ma być oznaczone jako obsługiwany, a w przeciwnym razie <see langword="false" />. Jeśli odczytu tej wartości <see langword="true" /> wskazuje, czy program obsługi klasy lub niektóre wystąpienia obsługi wzdłuż trasy, już oznaczył to zdarzenie obsługiwane. <see langword="false" />.indicates oznaczonego zdarzenia obsługiwane bez takiej obsługi.  Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oznaczenie zdarzeń obsługiwane ograniczy widoczność kierowanego zdarzenia do odbiorników wzdłuż trasy zdarzenia. Zdarzenia są nadal przesyłane w pozostałej części trasy, ale tylko programy obsługi dodanych z `HandledEventsToo` `true` w <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> wywołania metody, które będą wywoływane w odpowiedzi. Domyślnych programów obsługi na obiekty nasłuchujące wystąpienia (takich jak te wyrażone w [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) nie zostaną wywołane. Obsługi zdarzeń, które są oznaczone obsługi nie jest typowym scenariuszem.  
  
 Autor kontroli Definiowanie własnych zdarzenia decyzje podjęte przez użytkownika dotyczące zdarzeń obsługi na poziomie klasy będzie miało wpływ na użytkowników formantu, a także wszyscy użytkownicy formanty pochodne i potencjalnie innych elementów, które są objęte formantu lub zawierają formantu. Aby uzyskać więcej informacji, zobacz [oznaczenie kierowane zdarzenia jako Handled i obsługa klasy](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 W sytuacji bardzo rzadko jest odpowiednie do obsługi zdarzeń gdzie <xref:System.Windows.RoutedEventArgs.Handled%2A> jest oznaczony jako `true`i modyfikować, zmieniając argumenty zdarzenia <xref:System.Windows.RoutedEventArgs.Handled%2A> do `false`. Może to być konieczne w niektórych obszarach zdarzenia wejściowe formantów, takich jak obsługa klucza <xref:System.Windows.UIElement.KeyDown> i <xref:System.Windows.UIElement.TextInput> gdzie niski poziom konkurować zdarzenia wejściowe wysokiego poziomu obsługi i każdej próby pracować z różnych strategii routingu.  
  
   
  
## Examples  
 Poniższy przykład implementuje obsługi zdarzeń, który oznacza obsługi zdarzenia.  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberSignature Language="F#" Value="abstract member InvokeEventHandler : Delegate * obj -&gt; unit&#xA;override this.InvokeEventHandler : Delegate * obj -&gt; unit" Usage="routedEventArgs.InvokeEventHandler (genericHandler, genericTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">Ogólny program obsługi / przekazać wykonywanie do wywołania.</param>
        <param name="genericTarget">Obiekt docelowy, na którym powinna być wywoływana podanego programu obsługi.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej zapewnia sposób wywołania procedury obsługi zdarzeń w sposób określonego typu, co może zwiększyć wydajność w implementacji podstawowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podstawowa implementacja zawiera odbicia, aby określić prawo obsługę zawsze, gdy program obsługi nie jest dosłownie <xref:System.Windows.RoutedEventHandler>, i ten krok odbicia niektórych konsekwencje wydajności. Wywołań może się bardziej wydajne polegając nie na podstawie odbicia. To jest scenariusz, który każdą motywację ta metoda jest dostępna dla każdej klasy argumenty kierowanego zdarzenia, która go zastąpić. Implementacje nie powinny wywoływać podstawowym dla tej metody, ponieważ implementacji powinna już być odpowiedzialną za wywoływanie obsługi bezpiecznych typu.  
  
   
  
## Examples  
 Poniżej znajduje się pseudocode, która ilustruje podstawowe wzorzec, który może służyć do wykonania. W tym miejscu `MyRoutedEventHandler` jest podklasą <xref:System.Windows.RoutedEventHandler>.  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ta metoda jest przeznaczona do zastąpienia przez zdarzenie pochodnej klasy danych umożliwia bardziej efektywne wywołania ich obiektów delegowanych. Implementacja należy rzutować dostarczonych <paramref name="genericHandler" /> do określonego typu delegata, a następnie wywołaj programu obsługi.  Domyślna implementacja będzie podejmować próby wywołania podanego programu obsługi próby rzutować go jako <see cref="T:System.Windows.RoutedEventHandler" />. Jeśli dowolny <paramref name="genericHandler" /> lub <paramref name="genericTarget" /> jest dostarczane jako <see langword="null" />, wyjątki będą zgłaszane.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member OnSetSource : obj -&gt; unit&#xA;override this.OnSetSource : obj -&gt; unit" Usage="routedEventArgs.OnSetSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Nowa wartość <see cref="P:System.Windows.RoutedEventArgs.Source" /> jest ustawiany.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej zapewnia wpis wywołania zwrotnego powiadomień punktu zawsze, gdy wartość <see cref="P:System.Windows.RoutedEventArgs.Source" /> właściwości wystąpienia zmiany.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Programistyczna zgłoszone źródło zdarzenia mogą wymagać aktualizacji danych określonego typu w zdarzeniu. Z tego powodu <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> metoda jest chroniona wirtualnego i ma być zastąpiona przez podklasy <see cref="T:System.Windows.RoutedEventArgs" />.  Ta metoda ma domyślnej implementacji.</para>
        </block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalSource : obj" Usage="System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera raportowania oryginalne źródło określone przez pure testowanie trafień, przed wszelkie <see cref="P:System.Windows.RoutedEventArgs.Source" /> korekty przez klasy nadrzędnej.</summary>
        <value>Oryginalne źródło raportowania, zanim wszystkie możliwe <see cref="P:System.Windows.RoutedEventArgs.Source" /> dostosowanie przez obsługi klasy, która może wykonać do spłaszczenia połączone element drzewa.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość uzyskuje wartość po przed klasę programów obsługi zdarzeń lub dowolnym uchwyty wystąpienia są wywoływane i nigdy nie jest dostosowywany po tym punkcie. Oryginalne informacje o źródle jest tylko do odczytu do obsługi klasy lub klasa implementacji, tak samo, jak jest zgłaszany w danych zdarzenia.  
  
 Typowe przypadki, w którym mogą być dostosowywane źródło obejmują elementy zawartości w modelu zawartości formantu (zawartość elementu listy, na przykład, będzie zgłaszać element listy jako <xref:System.Windows.RoutedEventArgs.Source%2A> i rzeczywiste elementy w elemencie listy zostaną <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.  
  
 Dostosowania źródło przez różnych elementów i zawartości modeli różne klasy klasy. Każdej klasy, które można dostosować źródła zdarzeń podejmuje próbę przewidywać źródłem jest najbardziej przydatny raport najbardziej wejściowych scenariuszy i scenariusze, dla których ma klasy, a następnie ustawia który źródła jako <xref:System.Windows.RoutedEventArgs.Source%2A>. Jeśli to źródło nie jest jedną, która ma znaczenie dla programu obsługi zdarzeń, spróbuj <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> natomiast aby zobaczyć, czy raporty innego źródła, które jest bardziej odpowiednie. Więcej szczegółów na zdarzenia wejściowe, zobacz [wejściowych omówienie](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RoutedEvent : System.Windows.RoutedEvent with get, set" Usage="System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> skojarzony z tym <see cref="T:System.Windows.RoutedEventArgs" /> wystąpienia.</summary>
        <value>Identyfikator zdarzenia, który został wywołany.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można ustawić tej wartości na <xref:System.Windows.RoutedEventArgs> który już ma został skierowany (na przykład, jeśli użytkownik uzyskał argumenty za pośrednictwem programu obsługi). Takie próby wygeneruje wyjątek. Można tylko ustawić na wystąpienie, które jeszcze nie został użyty do generowania wywołania zdarzenia.  
  
 Wartość <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> nie może być `null` w dowolnym momencie.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowe dane kierowanego zdarzenia z konstruktorem początkowej, a następnie ustawia <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> właściwość jako kolejnych operacji. Musi mieć <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> ustawiony przed wywołaniem kierowanego zdarzenia.  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę zmiany <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> wartość, gdy zdarzenie jest przesyłane.</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : obj with get, set" Usage="System.Windows.RoutedEventArgs.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia odwołanie do obiektu, który wywołał zdarzenie.</summary>
        <value>Obiekt, który wywołał zdarzenie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku dowolnego zdarzenia z propagacją bąbelkową, które faktycznie przebyło trasę poza elementem, który je podniósł, oraz w przypadku dowolnego tunelowanego wydarzenia, które jeszcze nie zostało tunelowane w dół do elementu, który je podniósł, wartość <xref:System.Windows.RoutedEventArgs.Source%2A> będzie inna niż wartość `sender` parametr klasy argumentów zdarzeń. Które dwa elementy zaangażowane w zdarzeniu jest najbardziej znaczenie w dowolnym dany program obsługi (<xref:System.Windows.RoutedEventArgs.Source%2A>, element, do którego jest uruchamiany, lub `sender`, element, który obecnie jest obsługa) jest zależny od logiki aplikacji, która jest programu obsługi adresowania.  
  
 Ustawienie dla tej właściwości jest zazwyczaj wykonywane tylko podczas implementowania innych lub zastępowania [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] korygujące źródła zdarzeń, takie jak kiedy klasy obsługi zdarzeń. Resetowanie źródła zdarzeń jawnego z wystąpienia obsługi nie jest zalecane, szczególnie w przypadku, gdy program obsługi nie oznacza zdarzenia obsługiwane.  
  
 Po zresetowaniu <xref:System.Windows.RoutedEventArgs.Source%2A> zgłoszenia źródła zdarzeń, <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> będzie raportu źródłowego jako pierwsze zgłoszone przez źródłowym <xref:System.Windows.UIElement.RaiseEvent%2A> wywołania.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>
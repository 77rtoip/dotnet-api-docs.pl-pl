<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a03c4f8cd6f46e0811f54af7dc69e0ab173f1753" /><Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="10/04/2018" /><Meta Name="ms.locfileid" Value="48756036" /></Metadata><TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type RoutedEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zawiera dane informacjami i zdarzeniami stan skojarzony ze zdarzeniem trasowane.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Różne <xref:System.Windows.RoutedEventArgs> mogą być używane z jednej <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>. Ta klasa jest odpowiedzialny za pakowania danych zdarzeń dla <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>, podając informacje o stanie dodatkowe zdarzenia i jest używany przez system zdarzeń przy wywołaniu procedury obsługi skojarzonego ze zdarzeniem trasowane.  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.RoutedEventArgs" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.RoutedEventArgs" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystając z tego konstruktora bez parametrów, wszystkie publiczne właściwości nowej <xref:System.Windows.RoutedEventArgs> wystąpienia założono następujące wartości domyślne:  
  
-   <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> Wartość domyślna to `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> Wartość domyślna to `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> Wartość domyślna to `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> Wartość domyślna to `null`.  
  
 Wartość null, wartości <xref:System.Windows.RoutedEventArgs.Source%2A> i <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> tylko oznaczają, że <xref:System.Windows.RoutedEventArgs> danych sprawia, że próba określić źródło. Jeśli to wystąpienie jest używane w wywołaniu <xref:System.Windows.UIElement.RaiseEvent%2A>, <xref:System.Windows.RoutedEventArgs.Source%2A> i <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> wartości zostaną wypełnione na podstawie elementu, który spowodował zdarzenie i są przekazywane do odbiorników przy użyciu routingu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs routedEvent" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Identyfikator zdarzenia trasowanego dla tego wystąpienia <see cref="T:System.Windows.RoutedEventArgs" /> klasy.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.RoutedEventArgs" /> klasy przy użyciu identyfikatora zdarzenia trasowanego podane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystając z tego przeciążonego konstruktora, nie zostanie podany właściwości nowej <xref:System.Windows.RoutedEventArgs> wystąpienia założono następujące wartości domyślne:  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> Wartość domyślna to `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> Wartość domyślna to `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> Wartość domyślna to `null`.  
  
 Wartość null, wartości <xref:System.Windows.RoutedEventArgs.Source%2A> i <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> tylko oznaczają, że to <xref:System.Windows.RoutedEventArgs> sprawia, że próba określić źródło. Jeśli to wystąpienie jest używane w wywołaniu <xref:System.Windows.UIElement.RaiseEvent%2A>, <xref:System.Windows.RoutedEventArgs.Source%2A> i <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> wartości zostaną wypełnione na podstawie elementu, który spowodował zdarzenie i są przekazywane do odbiorników przy użyciu routingu.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy <xref:System.Windows.RoutedEventArgs> do użycia w wywołaniu <xref:System.Windows.UIElement.RaiseEvent%2A>.  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent * obj -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs (routedEvent, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Identyfikator zdarzenia trasowanego dla tego wystąpienia <see cref="T:System.Windows.RoutedEventArgs" /> klasy.</param>
        <param name="source">Alternatywne źródło, które będą zgłaszane, gdy zdarzenie jest obsługiwane. Spowoduje to wstępne wypełnienie <see cref="P:System.Windows.RoutedEventArgs.Source" /> właściwości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.RoutedEventArgs" /> klasy, przy użyciu identyfikatora zdarzenia trasowanego dostarczony i zapewniając możliwość zadeklarować innego źródła zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystając z tego przeciążonego konstruktora, nie zostanie podany właściwości nowej <xref:System.Windows.RoutedEventArgs> wystąpienia założono następujące wartości domyślne:  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> Wartość domyślna to `false`  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> Wartość domyślna to `null`.  
  
 Wartość null, wartości <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> zostaną wypełnione na element, który spowodował zdarzenie i routing, przekazany podstawie, ale będzie odczytywał element `null` przed wywołaniem.  
  
 Podczas przekazywania za pomocą tego podpisu <xref:System.Windows.RoutedEventArgs> na elementy wirtualne, takie jak <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>, której argumenty są używane do wywoływania <xref:System.Windows.UIElement.RaiseEvent%2A> wewnętrznie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Handled : bool with get, set" Usage="System.Windows.RoutedEventArgs.Handled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, obecny stan zdarzenia obsługi dla zdarzenia trasowanego podczas przekazywania trasy.</summary>
        <value>Jeśli to ustawienie, ustaw <see langword="true" /> Jeśli zdarzenie dotyczy był oznaczony jako obsługiwany, a w przeciwnym razie <see langword="false" />. Jeśli tę wartość do czytania <see langword="true" /> wskazuje, że program obsługi klasy lub niektórych obsługi wystąpienia wzdłuż trasy, ma już oznaczony to zdarzenie obsługi. <see langword="false" />.indicates, nie takie obsługi oznaczonego zdarzenie obsługi.  
  
Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oznaczanie zdarzeń obsługiwane ograniczy widoczność zdarzenie trasowane do detektorów zdarzeń trasy. Zdarzenie nadal podróży w pozostałej części trasy, ale tylko obsługi specjalnie dodać za pomocą `HandledEventsToo` `true` w <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> wywołanie metody zostanie wywołany w odpowiedzi. Domyślnych programów obsługi na odbiorniki wystąpień (takie jak te, wyrażone w [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) nie zostaną wywołane. Obsługa zdarzeń, które są oznaczone obsługiwane nie jest typowym scenariuszem.  
  
 Jeśli jesteś autorem formantu Definiowanie własnych zdarzeń decyzje, które wprowadzasz dotyczące zdarzeń Obsługa na poziomie klasy będzie miało wpływ na użytkowników Twoją kontrolą, a także wszystkich użytkowników formanty pochodne i potencjalnie inne elementy, które są zawarte przez Twoją kontrolą lub które zawierają kontrolki. Aby uzyskać więcej informacji, zobacz [oznaczanie zdarzeń trasowanych jako Handled oraz obsługa klasy](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 W bardzo rzadkich przypadkach jest odpowiednie do obsługi zdarzeń gdzie <xref:System.Windows.RoutedEventArgs.Handled%2A> jest oznaczony jako `true`i modyfikować argumenty zdarzenia, zmieniając <xref:System.Windows.RoutedEventArgs.Handled%2A> do `false`. Może to być konieczne w niektórych obszarach zdarzeń wejściowych kontrolek, takie jak Obsługa kluczy <xref:System.Windows.UIElement.KeyDown> a <xref:System.Windows.UIElement.TextInput> gdzie niski poziom wysokiego poziomu zdarzenia wejściowe konkurować obsługi i każdej próby pracować z różnych strategii routingu.  
  
   
  
## Examples  
 Poniższy przykład implementuje oznaczający zdarzenie obsługi program obsługi zdarzeń.  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberSignature Language="F#" Value="abstract member InvokeEventHandler : Delegate * obj -&gt; unit&#xA;override this.InvokeEventHandler : Delegate * obj -&gt; unit" Usage="routedEventArgs.InvokeEventHandler (genericHandler, genericTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">Procedura obsługi typu ogólnego / delegować do implementacji do wywołania.</param>
        <param name="genericTarget">Obiekt docelowy, na którym można wywołać podanego programu obsługi.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, umożliwia wywoływanie programów obsługi zdarzeń w sposób specyficznych dla typu, co może zwiększyć wydajność przez implementację podstawową.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podstawowa implementacja zawiera odbicia, aby określić odpowiednie Obsługa każdy przypadek, w których program obsługi nie jest dosłownie <xref:System.Windows.RoutedEventHandler>, a ten krok odbicia ma pewne skutki wydajności. Wywołania może się bardziej wydajne, nie opierając się na podstawie odbicia. Jest to scenariusz, w którym są każdą motywację tej metody, które są dostępne dla dowolnego zdarzenia trasowanego argumenty klasy, w którym chcesz go zastąpić. Implementacje nie powinien wywoływać podstawowy dla tej metody, ponieważ Twoja implementacja powinna już być odpowiedzialna za wywoływanie procedury obsługi bezpiecznego typu.  
  
   
  
## Examples  
 Poniżej przedstawiono pseudokodzie, który przedstawia podstawowy wzorzec, który może służyć do wdrożenia. W tym miejscu `MyRoutedEventHandler` jest podklasą <xref:System.Windows.RoutedEventHandler>.  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ta metoda ma być zastąpiona przez klas danych zdarzeń pochodnej w celu zapewnienia bardziej wydajne wywołania ich delegatów. Wdrożenia należy rzutować podane <paramref name="genericHandler" /> konkretny typ delegowanie, a następnie wywołaj programu obsługi.  
  
Domyślna implementacja podejmie próbę wywołania programu obsługi podana, próba zrzutowania go <see cref="T:System.Windows.RoutedEventHandler" />. Jeśli <paramref name="genericHandler" /> lub <paramref name="genericTarget" /> jest dostarczana jako <see langword="null" />, wyjątki będą zgłaszane.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member OnSetSource : obj -&gt; unit&#xA;override this.OnSetSource : obj -&gt; unit" Usage="routedEventArgs.OnSetSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Nową wartość, która <see cref="P:System.Windows.RoutedEventArgs.Source" /> zostanie ustawiona wartość.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej zapewnia wpis wywołania zwrotnego powiadomień punktów w każdym przypadku, gdy wartość <see cref="P:System.Windows.RoutedEventArgs.Source" /> właściwość zmian wystąpienia.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Zmienianie programowe zgłoszonych źródło zdarzenia mogą wymagać aktualizacji danych specyficznych dla typu w ramach zdarzenia. Z tego powodu <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> metoda jest chroniona, wirtualna i ma być zastąpiona przez podklasy <see cref="T:System.Windows.RoutedEventArgs" />.  
  
Ta metoda nie ma domyślnej implementacji.</para></block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalSource : obj" Usage="System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera raportowania oryginalnego źródła, zgodnie z ustaleniami czystego testowania trafień, zanim wszystkie możliwe <see cref="P:System.Windows.RoutedEventArgs.Source" /> dostosowania przez klasy nadrzędnej.</summary>
        <value>Oryginalne źródło raportowania, zanim wszystkie możliwe <see cref="P:System.Windows.RoutedEventArgs.Source" /> dostosowanie przez obsługi klasy, która może wykonać spłaszczanie element złożone drzewa.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość uzyskuje wartość po, przed klasa procedury obsługi zdarzeń lub dowolnej obsługi wystąpienia są wywoływane i nigdy nie jest uwzględniany po tym punkcie. Oryginalne informacje źródłowe są funkcje obsługi klas lub implementacji klasy jest tylko do odczytu, tak, jak jest zgłaszany w danych zdarzenia.  
  
 Typowe przypadki, gdzie mogą być dostosowywane źródła zawierają zawartości elementy wewnątrz modelu zawartości kontrolki (zawartość elementu listy, na przykład, będą zgłaszać elementu listy jako <xref:System.Windows.RoutedEventArgs.Source%2A> rzeczywistego elementu w elemencie listy. zostanie ona <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.  
  
 Dostosowania źródła przez różne elementy i modele zawartości różni się od klasy do klasy. Każda klasa, która dostosowuje źródła zdarzeń podejmie próbę przewidywanie, której źródłem jest najbardziej przydatne do raportowania dla większości scenariuszy danych wejściowych i scenariuszy, dla których klasa jest przeznaczona, a następnie zestawów, źródła jako <xref:System.Windows.RoutedEventArgs.Source%2A>. Jeśli to źródło nie jest ten, który ma znaczenie dla Twojej obsługi zdarzenia, spróbuj wykonać sprawdzanie <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> zamiast tego wyświetlić, jeśli raportuje innego źródła, która jest bardziej odpowiednia. Aby uzyskać szczegółowe informacje na temat zdarzeń wejściowych, zobacz [przegląd danych wejściowych](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RoutedEvent : System.Windows.RoutedEvent with get, set" Usage="System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> skojarzony z tym <see cref="T:System.Windows.RoutedEventArgs" /> wystąpienia.</summary>
        <value>Identyfikator zdarzenia, które zostało wywołane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można ustawić tę wartość na <xref:System.Windows.RoutedEventArgs> który już został przesłany (na przykład, jeśli użytkownik uzyskał argumentów, za pomocą programu obsługi). Takie próby spowoduje wygenerowanie wyjątku. Można ustawić tylko jej wystąpieniu, który nie został jeszcze użyty do wygenerowania wywołania zdarzenia.  
  
 Wartość <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> nie może być `null` w dowolnym momencie.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowe zdarzenie trasowane dane za pomocą konstruktora początkową, a następnie ustawia <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> właściwość jako kolejna operacja. Konieczne jest posiadanie <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> ustawiony przed podnoszenie zdarzenia trasowanego.  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę zmiany <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> wartość, gdy zdarzenie jest przesyłane.</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : obj with get, set" Usage="System.Windows.RoutedEventArgs.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia odwołanie do obiektu, który spowodował zdarzenie.</summary>
        <value>Obiekt, który spowodował zdarzenie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku dowolnego zdarzenia z propagacją bąbelkową, które faktycznie przebyło trasę poza elementem, który je podniósł, oraz w przypadku dowolnego tunelowanego wydarzenia, które jeszcze nie zostało tunelowane w dół do elementu, który je podniósł, wartość <xref:System.Windows.RoutedEventArgs.Source%2A> będzie inna niż wartość `sender` parametr klasy argumentów zdarzeń. Które dwa elementy zaangażowany w zdarzeniu jest najbardziej znaczenie w dowolnej podanej procedury obsługi (<xref:System.Windows.RoutedEventArgs.Source%2A>, element, który spowodował, lub `sender`, element, który aktualnie jest obsługa) jest zależna od logiki aplikacji, która jest programu obsługi adresowanie.  
  
 Ustawienie tej właściwości jest zazwyczaj tylko wykonywane podczas zastępowania lub Implementowanie innych [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] , Dostosuj źródła zdarzeń, takie jak czas klasy obsługi zdarzenia. Resetowanie jawnego zdarzeń źródła z obsługi wystąpienia nie jest zalecane, szczególnie w przypadku, gdy program obsługi nie są oznaczane zdarzenia jako obsługiwane.  
  
 W przypadku zresetowania <xref:System.Windows.RoutedEventArgs.Source%2A> zgłosić źródłem zdarzeń w różnych <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> będą w dalszym raportu źródłowego jako pierwsze zgłoszone przez źródłowym <xref:System.Windows.UIElement.RaiseEvent%2A> wywołania.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>
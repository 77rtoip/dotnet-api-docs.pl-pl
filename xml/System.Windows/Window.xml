<Type Name="Window" FullName="System.Windows.Window">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="30e9c154175370c143890004c37ed150b5ecabbb" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36456204" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Window : System.Windows.Controls.ContentControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Window extends System.Windows.Controls.ContentControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Window" />
  <TypeSignature Language="VB.NET" Value="Public Class Window&#xA;Inherits ContentControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class Window : System::Windows::Controls::ContentControl" />
  <TypeSignature Language="F#" Value="type Window = class&#xA;    inherit ContentControl" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Umożliwia tworzenie, konfigurowanie, wyświetlanie i zarządzanie nimi przez czas ich istnienia i okna dialogowe.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Punkt interakcji między użytkownikiem a aplikacja autonomiczna jest oknem. A [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] okno składa się z dwóch różnych obszarach:  
  
-   Obszarze-klient obsługuje skojarzenia systemu windows, takich jak ikony, tytuł, menu systemowe przycisk Minimalizuj, Maksymalizuj przycisk, przycisk Przywróć, zamknij i obramowanie.  
  
-   Obszar klienta, który obsługuje zawartość specyficzne dla aplikacji.  
  
 Standardowe okno jest wyświetlane na poniższej ilustracji:  
  
 ![Elementy okna](~/add/media/windowoverviewfigure1.PNG "elementów okna")  
  
 <xref:System.Windows.Window> hermetyzuje możliwość tworzenia, konfigurowania, Pokaż i zarządzanie okresem istnienia systemu windows i oknach dialogowych i udostępnia następujące usługi klucza:  
  
 **Zarządzanie okresem istnienia**: <xref:System.Windows.Window.Activate%2A>, <xref:System.Windows.Window.Activated>, <xref:System.Windows.Window.Close%2A>, <xref:System.Windows.Window.Closed>, <xref:System.Windows.Window.Closing>, <xref:System.Windows.Window.Deactivated>, <xref:System.Windows.Window.Hide%2A>, <xref:System.Windows.Window.IsActive%2A>, <xref:System.Windows.Window.Show%2A>, <xref:System.Windows.Window.SourceInitialized>.  
  
 **Zarządzanie oknem**: <xref:System.Windows.Window.GetWindow%2A>, <xref:System.Windows.Window.OwnedWindows%2A>, <xref:System.Windows.Window.Owner%2A>.  
  
 **Wygląd i zachowanie**: <xref:System.Windows.Window.AllowsTransparency%2A>, <xref:System.Windows.Window.ContentRendered>, <xref:System.Windows.Window.DragMove%2A>, <xref:System.Windows.Window.Icon%2A>, <xref:System.Windows.Window.Left%2A>, <xref:System.Windows.Window.LocationChanged>, <xref:System.Windows.Window.ResizeMode%2A>, <xref:System.Windows.Window.RestoreBounds%2A>, <xref:System.Windows.Window.ShowActivated%2A>, <xref:System.Windows.Window.ShowInTaskbar%2A>, <xref:System.Windows.Window.SizeToContent%2A>, <xref:System.Windows.Window.StateChanged>, <xref:System.Windows.Window.Title%2A>, <xref:System.Windows.Window.Top%2A>, <xref:System.Windows.Window.Topmost%2A>, <xref:System.Windows.Window.WindowStartupLocation%2A>, <xref:System.Windows.Window.WindowState%2A>, <xref:System.Windows.Window.WindowStyle%2A>  
  
 **Okna dialogowe**: <xref:System.Windows.Window.DialogResult%2A>, <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Ponadto <xref:System.Windows.Application> przedstawia specjalną obsługę zarządzania wszystkie okna w aplikacji:  
  
-   Aplikacja przechowuje listę wszystkich okien, które są aktualnie uruchomione w aplikacji. Ta lista jest udostępniany przez <xref:System.Windows.Application.Windows%2A> właściwości.  
  
-   Domyślnie <xref:System.Windows.Application.MainWindow%2A> jest ustawiany automatycznie z odwołaniem do pierwszej <xref:System.Windows.Window> który zostanie uruchomiony w aplikacji. To, dzięki czemu okna w głównym oknie aplikacji.  
  
 A <xref:System.Windows.Window> można implementować przy użyciu znaczników, znaczników i kodu powiązanego lub kodu.  
  
 <xref:System.Windows.Window> przede wszystkim służy do wyświetlania i okna dialogowe dla aplikacji autonomicznych. Jednak dla aplikacji, które wymagają nawigacji na poziomie okna, takich jak kreatorów, należy użyć <xref:System.Windows.Navigation.NavigationWindow> zamiast; <xref:System.Windows.Navigation.NavigationWindow> pochodną <xref:System.Windows.Window> i rozszerza ją z obsługą nawigacji w stylu przeglądarki.  
  
> [!NOTE]
>  Wyspy można nawigować zawartości mogą być włączone w innych zawartości i kontenerów przy użyciu <xref:System.Windows.Controls.Frame>.  
  
 <xref:System.Windows.Window> wymaga `UnmanagedCode` uprawnień do można utworzyć wystąpienia. To ma następujące konsekwencje:  
  
-   [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)]-Aplikacje autonomiczne wdrożonej zażąda podniesienia uprawnień przy uruchamianiu w strefach Internet lub lokalny Intranet.  
  
-   [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] żądanie który, niczego mniejszej niż pełne uprawnienia nie można utworzyć wystąpienia systemu windows lub w oknach dialogowych.  
  
 Aby uzyskać informacje dotyczące wdrażania aplikacji autonomicznej i zagadnienia dotyczące zabezpieczeń, zobacz [strategii zabezpieczeń WPF - zabezpieczeń platformy](~/docs/framework/wpf/wpf-security-strategy-platform-security.md).  
  
 A <xref:System.Windows.Window> jest <xref:System.Windows.Controls.ContentControl>, co oznacza, że może zawierać pojedynczy obiekt dowolnego typu (np. ciąg, obrazu lub panelu). Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Controls.ContentControl> klasy. Ponadto <xref:System.Windows.Window> jest elementem głównym i, w związku z tym nie może być częścią innego elementu zawartości.  
  
> [!NOTE]
>  <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.Window.Top%2A>, I <xref:System.Windows.Window.Left%2A> właściwości ustawione w <xref:System.Windows.Window> za pośrednictwem stylu nie zostaną zastosowane w czasie wykonywania.  
  
## <a name="customizing-the-window-control"></a>Dostosowywanie formantu okna  
 Aby zastosować te same ustawienia właściwości z wieloma <xref:System.Windows.Window> formantów, użyj <xref:System.Windows.FrameworkElement.Style%2A> właściwości. Można zmodyfikować domyślne <xref:System.Windows.Controls.ControlTemplate> umożliwiają unikatowego wyglądu formantu. Aby uzyskać więcej informacji o tworzeniu <xref:System.Windows.Controls.ControlTemplate>, zobacz [Dostosowywanie wyglądu formant tworząc ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  Aby wyświetlić części i Stany, które są specyficzne dla <xref:System.Windows.Window>, zobacz [Style okna i szablony](~/docs/framework/wpf/controls/window-styles-and-templates.md).  
  
 Właściwości zależności dla tego formantu może być ustawiona w stylu domyślnym formantu.  Jeśli właściwość jest ustawiona w stylu domyślnym, gdy formant jest wyświetlany w aplikacji właściwość może zmienić ze swojej wartości domyślnej. Domyślny styl jest określana, przez które kompozycji pulpitu jest używana, gdy aplikacja jest uruchomiona.  Aby uzyskać więcej informacji, zobacz [domyślnej kompozycji WPF](http://go.microsoft.com/fwlink/?LinkID=158252).  
  
> [!NOTE]
>  Ustawienie właściwości visual będzie miał wpływ tylko jeśli ta właściwość jest obecny w obu <xref:System.Windows.Window> formant na szablon domyślny i ustawić za pomocą. Lista właściwości visual można znaleźć w sekcji "Zmiana Visual struktury kontroli" [Dostosowywanie wyglądu formant tworząc ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak standardowe okno jest zdefiniowane przy użyciu tylko kod znaczników:  
  
 [!code-xaml[WindowSnippets#WindowMARKUPONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MarkupOnlyWindow.xaml#windowmarkuponly)]  
  
 W poniższym przykładzie przedstawiono sposób standardowe okno jest definiowana za pomocą tylko kodu:  
  
 [!code-csharp[WindowSnippets#WindowCODEONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/CodeOnlyWindow.cs#windowcodeonly)]
 [!code-vb[WindowSnippets#WindowCODEONLY](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/codeonlywindow.vb#windowcodeonly)]  
  
 W poniższym przykładzie pokazano, jak standardowe okno jest zdefiniowane przy użyciu kombinacji znaczników i związane z kodem.  
  
 [!code-xaml[WindowSnippets#WindowXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml#windowxaml)]  
  
 [!code-csharp[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml.cs#windowcodebehind)]
 [!code-vb[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/mainwindow.xaml.vb#windowcodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Windows.Window.Show" />
    <altmember cref="M:System.Windows.Window.ShowDialog" />
    <altmember cref="P:System.Windows.Window.DialogResult" />
    <altmember cref="T:System.Windows.Application" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Window ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Window();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Window" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor inicjuje <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.Window.Top%2A>, i <xref:System.Windows.Window.Left%2A> właściwości domyślne <xref:System.Windows.Window> wartości.  
  
 Jeśli okno jest tworzony w <xref:System.AppDomain> mający <xref:System.Windows.Application> obiektu, dodaje konstruktora <xref:System.Windows.Window> obiektu w zestawie <xref:System.Windows.Application>-zarządzanych systemu windows za pośrednictwem <xref:System.Windows.Application.Windows%2A> właściwość <xref:System.Windows.Application> obiektu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">uprawnienia dla tego obiektu do wywołania metod natywnych niebezpieczne. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public bool Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Activate" />
      <MemberSignature Language="VB.NET" Value="Public Function Activate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Activate();" />
      <MemberSignature Language="F#" Value="member this.Activate : unit -&gt; bool" Usage="window.Activate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Próbuje przełączyć się na pierwszym planie okna i aktywuje go.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Windows.Window" /> został pomyślnie aktywowane; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zasady, które określają, czy okno jest aktywowana są takie same jak te używane przez [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] `SetForegroundWindow` — funkcja (User32.dll).  
  
 Jeśli okno jest aktywowana w aplikacji Windows Presentation Foundation, który nie jest pierwszoplanowych użytkownika <xref:System.Windows.Application.Activated> zdarzenia.  
  
> [!NOTE]
>  Nie można wywołać tej metody, gdy okno jest obsługiwany w przeglądarce.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">uprawnienia do aktywacji okna. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy okno staje się oknem pierwszego planu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Okno jest aktywowana (staje się oknem pierwszego planu) po:  
  
-   Pierwszym otwarciu okna.  
  
-   Użytkownik przełącza do okna, wybierając go za pomocą myszy, naciskając klawisze ALT + TAB lub w Menedżerze zadań.  
  
-   Użytkownik klika przycisk okna na pasku zadań.  
  
 Systemu Windows, które trzeba Wykryj, kiedy staną się one aktywować może obsłużyć <xref:System.Windows.Window.Activated> zdarzeń.  
  
 Po uaktywnieniu okna może być dezaktywowane i ponownie uaktywnić wiele razy w ciągu okresu jego istnienia. Jeśli stan lub zachowanie aplikacji jest zależny od stanu aktywacji, można sprawdzić <xref:System.Windows.Window.IsActive%2A> można określić stanu aktywacji, który znajduje się w.  
  
 Można też aplikacji <xref:System.Windows.Application.Activated>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparency">
      <MemberSignature Language="C#" Value="public bool AllowsTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.AllowsTransparency" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowsTransparency As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowsTransparency { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowsTransparency : bool with get, set" Usage="System.Windows.Window.AllowsTransparency" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy obszar klienta okna obsługuje przezroczystość.</summary>
        <value>
          <see langword="true" /> Jeśli okna obsługuje przezroczystość. w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas <xref:System.Windows.Controls.Control.Background%2A> właściwość okna jest ustawiona na przezroczysty kolor, za pomocą <xref:System.Windows.Media.Brushes.Transparent%2A> na przykład okna pozostanie przezroczystości. Oznacza to, że pulpit i wszystkie uruchomione aplikacje "okna poniżej" nie może być widoczne. Aby włączyć ten typ przezroczystości, <xref:System.Windows.Window.AllowsTransparency%2A> musi mieć ustawioną `true`.  
  
 <xref:System.Windows.Window.AllowsTransparency%2A> istnieje ułatwia tworzenie okien o nieregularnych kształtach i w związku z tym, gdy <xref:System.Windows.Window.AllowsTransparency%2A> ustawiono `true`, okna <xref:System.Windows.Window.WindowStyle%2A> musi mieć ustawioną właściwość <xref:System.Windows.WindowStyle.None>.  
  
<a name="dependencyPropertyInfo_WindowAllowsTransparency"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Window.AllowsTransparencyProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Okno ma <see cref="P:System.Windows.Window.WindowStyle" /> cokolwiek innego niż wartość <see cref="F:System.Windows.WindowStyle.None" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparencyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowsTransparencyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowsTransparencyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.AllowsTransparencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowsTransparencyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowsTransparencyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AllowsTransparencyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.AllowsTransparencyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Window.AllowsTransparency" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberSignature Language="F#" Value="override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="window.ArrangeOverride arrangeBounds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">A <see cref="T:System.Windows.Size" /> , które odzwierciedla rozmiaru końcowego, która powinna być używana przez okno ułożyć się i jego elementów podrzędnych.</param>
        <summary>Zastępuje tę metodę rozmieszczania i rozmiaru okna i jego elementów podrzędnych.</summary>
        <returns>A <see cref="T:System.Windows.Size" /> , które odzwierciedla rzeczywistego rozmiaru, który został użyty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.ArrangeOverride%2A> nie jest wywoływane, gdy <xref:System.Windows.UIElement.Visibility%2A> właściwość ma wartość <xref:System.Windows.Visibility.Collapsed>. Jeśli wartość <xref:System.Windows.UIElement.Visibility%2A> właściwości <xref:System.Windows.Visibility.Hidden> lub <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.ArrangeOverride%2A> jest wywoływana.  
  
> [!NOTE]
>  Gdy albo <xref:System.Windows.Window.Show%2A> lub <xref:System.Windows.Window.ShowDialog%2A> są nazywane <xref:System.Windows.UIElement.Visibility%2A> właściwość <xref:System.Windows.Window> ma ustawioną wartość <xref:System.Windows.Visibility.Visible>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="window.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka ręcznie <see cref="T:System.Windows.Window" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Window> można zamknąć przy użyciu jednej z kilku, mechanizmów dobrze znane, dostarczane przez system znajduje się w jego pasek tytułu, w tym:  
  
-   ALT+F4.  
  
-   Menu systemowe &#124; **Zamknij**.  
  
-   **Zamknij** przycisku.  
  
 A <xref:System.Windows.Window> może również zostać zamknięty, za pomocą jednego z kilku dobrze znanego mechanizmów wewnątrz obszaru klienckiego udostępnianych przez deweloperów, w tym:  
  
-   **Plik** &#124; **zakończenia** w oknie głównym.  
  
-   **Plik** &#124; **Zamknij** lub **Zamknij** przycisk na okna podrzędnego.  
  
> [!NOTE]
>  **OK** i **anulować** przyciski w oknie dialogowym są również dostarczane przez deweloperów, mimo że będzie prawdopodobny zestaw <xref:System.Windows.Window.DialogResult%2A>, który jest automatycznie zamykany okna, która została otwarta przez wywołanie metody <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Te mechanizmy wymagają, aby jawnie wywołać <xref:System.Windows.Window.Close%2A> aby zamknąć okno.  
  
> [!NOTE]
>  Po otwarciu okna, wywołując <xref:System.Windows.Window.ShowDialog%2A>oraz z <xref:System.Windows.Controls.Button> z jego <xref:System.Windows.Controls.Button.IsCancel%2A> właściwością o wartości true, zostanie automatycznie zamknięte po kliknięciu przycisku albo lub naciśnięcia klawisza ESC. Jeśli okno otwarto przy użyciu <xref:System.Windows.Window.Show%2A>, jednak <xref:System.Windows.Window.Close%2A> musi być jawnie wywołane, takich jak z <xref:System.Windows.Controls.Primitives.ButtonBase.Click> programu obsługi zdarzeń dla <xref:System.Windows.Controls.Button>.  
  
 Zamknięcie okna powoduje <xref:System.Windows.Window.Closing> się zdarzenia. Jeśli <xref:System.Windows.Window.Closing> zdarzenie nie zostanie anulowane, wystąpią następujące zdarzenia:  
  
-   <xref:System.Windows.Window> Zostanie usunięty z <xref:System.Windows.Application.Windows%2A?displayProperty=nameWithType> (Jeśli <xref:System.Windows.Application> obiekt istnieje).  
  
-   <xref:System.Windows.Window> Zostanie usunięty z właścicielem <xref:System.Windows.Window> Jeśli relacji należące do właściciela/zostało nawiązane przed należących do <xref:System.Windows.Window> wyświetleniem i po właściciela <xref:System.Windows.Window> został otwarty.  
  
-   <xref:System.Windows.Window.Closed> Zdarzenia.  
  
-   Niezarządzane zasoby utworzone przez <xref:System.Windows.Window> są usuwane.  
  
-   Jeśli <xref:System.Windows.Window.ShowDialog%2A> została wywołana w celu wyświetlenia <xref:System.Windows.Window>, <xref:System.Windows.Window.ShowDialog%2A> zwraca.  
  
 Zamykanie <xref:System.Windows.Window> powoduje, że wszystkie okna, które jest właścicielem zostanie zamknięty. Ponadto zamknięcia <xref:System.Windows.Window> może spowodować, że aplikacja przestanie działać w zależności od sposobu <xref:System.Windows.Application.ShutdownMode%2A?displayProperty=nameWithType> właściwość jest ustawiona.  
  
> [!NOTE]
>  Nie można wywołać tej metody, gdy okno jest obsługiwany w przeglądarce.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono **pliku** &#124; **zakończenia** menu obsługiwane jawnie wywołać <xref:System.Windows.Window.Close%2A>.  
  
 [!code-xaml[WindowCloseSnippets#WindowCloseXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml#windowclosexaml)]  
  
 [!code-csharp[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml.cs#windowclosecodebehind)]
 [!code-vb[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowCloseSnippets/visualbasic/mainwindow.xaml.vb#windowclosecodebehind)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uzyskać uprawnienia do używania wszystkie okna i zdarzenia wejściowe użytkownika bez ograniczeń. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="P:System.Windows.Window.DialogResult" />
        <altmember cref="P:System.Windows.Window.Owner" />
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Closed;" />
      <MemberSignature Language="F#" Value="member this.Closed : EventHandler " Usage="member this.Closed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy okno jest zamknięcie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy to zdarzenie jest zgłaszane, okna nie można zablokować zamknięcia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.UIElement.Visibility" /> jest ustawiona, lub <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" />, lub <see cref="M:System.Windows.Window.Hide" /> jest wywoływana podczas zamykania okna.</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closing" />
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Closing;" />
      <MemberSignature Language="F#" Value="member this.Closing : System.ComponentModel.CancelEventHandler " Usage="member this.Closing : System.ComponentModel.CancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje bezpośrednio po <see cref="M:System.Windows.Window.Close" /> jest nazywane i mogą zostać użyte do anulowania zamknięcia okna.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.Closing> może zostać użyte do wykrycia, gdy okno jest zamykane (na przykład, gdy <xref:System.Windows.Window.Close%2A> jest nazywany). Ponadto <xref:System.Windows.Window.Closing> pozwala uniknąć zamknięcia okna. Aby uniemożliwić zamknięcia okna, można ustawić <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> właściwość <xref:System.ComponentModel.CancelEventArgs> argument `true`.  
  
 <xref:System.Windows.Window.Closing> Zdarzenie jest zgłaszane, gdy <xref:System.Windows.Window.Close%2A> jest wywoływana po kliknięciu przycisku Zamknij okno programu, lub gdy użytkownik naciśnie klawisz ALT + F4.  
  
 Jeśli należących do okna otwarto przy użyciu jego okno właściciela <xref:System.Windows.Window.Show%2A>oraz właściciel zamknięciu okna, okno będących własnością <xref:System.Windows.Window.Closing> nie zdarzenia. Jeśli właściciel okno zostanie zamknięty (zobacz <xref:System.Windows.Window.Owner%2A>), <xref:System.Windows.Window.Closing> nie jest wywoływane w oknie należące do firmy.  
  
 Jeśli <xref:System.Windows.Application.Shutdown%2A> jest nazywany <xref:System.Windows.Window.Closing> dla każdego okna zdarzenia. Jednak jeśli <xref:System.Windows.Window.Closing> jest anulowany, anulowania jest ignorowana.  
  
 Jeśli sesja zakończy się, ponieważ użytkownik wyloguje się lub kończy pracę, <xref:System.Windows.Window.Closing> nie jest wywoływane; obsługi <xref:System.Windows.Application.SessionEnding> implementowania kodu, który anuluje zamknięcia aplikacji.  
  
 Jeśli chcesz pokazać lub ukryć okno wiele razy w ciągu okresu istnienia aplikacji, a użytkownik nie chce reinstantiate okna za każdym razem, można wyświetlić, może obsłużyć <xref:System.Windows.Window.Closing> zdarzeń, Anuluj ją i Wywołaj <xref:System.Windows.Window.Hide%2A> metody. Następnie możesz wywołać <xref:System.Windows.Window.Show%2A> dla tego samego wystąpienia, aby otworzyć go ponownie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Windows.Window> Określa, czy wymaga interwencji użytkownika, aby zamknąć.  
  
 [!code-xaml[WindowClosingSnippets#WindowClosingXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml#windowclosingxaml1)]  
  
 [!code-csharp[WindowClosingSnippets](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml.cs)]
 [!code-vb[WindowClosingSnippets](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowClosingSnippets/visualbasic/datawindow.xaml.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.UIElement.Visibility" /> jest ustawiona, lub <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" />, lub <see cref="M:System.Windows.Window.Close" /> jest wywoływana podczas zamykania okna.</exception>
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closed" />
      </Docs>
    </Member>
    <Member MemberName="ContentRendered">
      <MemberSignature Language="C#" Value="public event EventHandler ContentRendered;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContentRendered" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.ContentRendered" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentRendered As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ContentRendered;" />
      <MemberSignature Language="F#" Value="member this.ContentRendered : EventHandler " Usage="member this.ContentRendered : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zrenderowaniu zawartości okna.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli okno nie ma zawartości, to zdarzenie nie jest wywoływane.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ContentControl.Content" />
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy okno staje się oknem tła.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Okno jest dezaktywowana (staje się oknem tła) po:  
  
-   Użytkownik zmienia się na inne okno w bieżącej aplikacji.  
  
-   Użytkownik przełącza do okna w innej aplikacji, za pomocą ALT + TAB lub za pomocą Menedżera zadań.  
  
-   Użytkownik klika przycisk paska zadań dla okna w innej aplikacji.  
  
 Systemu Windows, które trzeba Wykryj, kiedy staną się one dezaktywowane Obsługa <xref:System.Windows.Window.Deactivated> zdarzeń.  
  
 Po dezaktywacji okna może ponownie aktywowana i dezaktywowane wiele razy w ciągu okresu jego istnienia. Jeśli stan lub zachowanie aplikacji jest zależny od stanu aktywacji, można sprawdzić <xref:System.Windows.Window.IsActive%2A> można określić stanu aktywacji, który znajduje się w.  
  
 Można też aplikacji <xref:System.Windows.Application.Deactivated>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;bool&gt; DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.DialogResult" />
      <MemberSignature Language="VB.NET" Value="Public Property DialogResult As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;bool&gt; DialogResult { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.DialogResult : Nullable&lt;bool&gt; with get, set" Usage="System.Windows.Window.DialogResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.DialogResultConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wyniku okna dialogowego, która jest wartością zwracaną z <see cref="M:System.Windows.Window.ShowDialog" /> metody.</summary>
        <value>A <see cref="T:System.Nullable`1" /> wartości typu <see cref="T:System.Boolean" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.DialogResult%2A> można użyć z kodu, który okno dialogowe, aby określić, czy użytkownik jest akceptowany (`true`) lub anulowane (`false`) okno dialogowe. Jeśli okno dialogowe został zaakceptowany, oznacza to do kodu, który otworzyć okno dialogowe, aby pobrać dane, które zostały zebrane przez użytkownika i go przetworzyć. Jeśli okno dialogowe zostało anulowane, jednak to oznacza, że wywołanie kodu należy zatrzymać dalsze przetwarzanie.  
  
 Domyślnie okno dialogowe jest anulowany, gdy użytkownik wykona jedną z następujących czynności:  
  
-   PressesALT+F4.  
  
-   Kliknie **Zamknij** przycisku.  
  
-   Wybiera **Zamknij** z menu systemowego.  
  
 We wszystkich tych przypadkach <xref:System.Windows.Window.DialogResult%2A> jest `false` domyślnie.  
  
 Okno dialogowe zwykle zapewnia specjalne przycisk, aby anulować okno dialogowe, które jest przycisk których <xref:System.Windows.Controls.Button.IsCancel%2A> właściwość jest ustawiona na `true`. Przycisk skonfigurowane w ten sposób zostanie automatycznie zamknięte okno, gdy albo zostanie naciśnięty lub po naciśnięciu klawisza ESC. W tych przypadkach <xref:System.Windows.Window.DialogResult%2A> pozostaje `false`.  
  
 Okno dialogowe zawiera także zazwyczaj przycisk Akceptuj, który jest przycisk których <xref:System.Windows.Controls.Button.IsDefault%2A> właściwość jest ustawiona na `true`. Przycisk skonfigurowane w ten sposób zostanie podniesiony jego <xref:System.Windows.Controls.Primitives.ButtonBase.Click> zdarzenie, gdy zostanie naciśnięty ten plik lub klawisz ENTER. Jednak nie będzie ona automatycznie zamknąć okno dialogowe, ani nie zostanie ustawiony <xref:System.Windows.Window.DialogResult%2A> do `true`. Należy ręcznie napisać ten kod, zazwyczaj z <xref:System.Windows.Controls.Primitives.ButtonBase.Click> programu obsługi zdarzeń dla przycisk domyślny.  
  
 <xref:System.Windows.Window.DialogResult%2A> jest `null` po jest wyświetlane okno dialogowe ale akceptowane ani anulowane.  
  
 Po zamknięciu okno dialogowe można uzyskać wyników okna dialogowego z wartością zwróconą przez <xref:System.Windows.Window.ShowDialog%2A> metody, lub sprawdzając <xref:System.Windows.Window.DialogResult%2A> właściwości.  
  
 <xref:System.Windows.Window.DialogResult%2A> można ustawić tylko podczas <xref:System.Windows.Window> jest otwarty przez wywołanie jego <xref:System.Windows.Window.ShowDialog%2A> metody.  
  
> [!NOTE]
>  Nie można ustawić lub pobrać tej właściwości, gdy okno jest hostowana w przeglądarce.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób konfigurowania przycisk OK, a przycisk Anuluj, aby powrócić do odpowiedniej <xref:System.Windows.Window.DialogResult%2A>.  
  
 [!code-xaml[WindowDialogResultSnippets#WindowDialogResultXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml#windowdialogresultxaml)]  
  
 [!code-csharp[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml.cs#windowdialogresultcodebehind)]
 [!code-vb[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDialogResultSnippets/visualbasic/dialogbox.xaml.vb#windowdialogresultcodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Window.DialogResult" /> jest ustawiony przed otwarciem okna przez wywołanie metody <see cref="M:System.Windows.Window.ShowDialog" />.  - lub - <see cref="P:System.Windows.Window.DialogResult" /> jest ustawiony w oknie, która jest otwarta przez wywołanie metody <see cref="M:System.Windows.Window.Show" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.DpiChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChanged As DpiChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DpiChangedEventHandler ^ DpiChanged;" />
      <MemberSignature Language="F#" Value="member this.DpiChanged : System.Windows.DpiChangedEventHandler " Usage="member this.DpiChanged : System.Windows.DpiChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie wyświetlanej rozdzielczości ekranu, na którym jest okna.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DpiChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DpiChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.DpiChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DpiChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DpiChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DpiChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Window.DpiChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A <see cref="T:System.Windows.RoutedEvent" /> dla przypadku rozdzielczości ekranu okna zmiany.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragMove">
      <MemberSignature Language="C#" Value="public void DragMove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DragMove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.DragMove" />
      <MemberSignature Language="VB.NET" Value="Public Sub DragMove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DragMove();" />
      <MemberSignature Language="F#" Value="member this.DragMove : unit -&gt; unit" Usage="window.DragMove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pozwala oknu przeciąganych przez myszy jego lewym przyciskiem dół przestrzeni dostępnego obszaru klienckiego okna.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lewy przycisk myszy musi być wyłączone podczas <xref:System.Windows.Window.DragMove%2A> jest wywoływana. Jednym ze sposobów Wykryj, kiedy lewy przycisk myszy jest wciśnięty ma obsługiwać <xref:System.Windows.UIElement.MouseLeftButtonDown> zdarzeń.  
  
 Gdy <xref:System.Windows.Window.DragMove%2A> jest wywoływana po lewej stronie przycisku myszy muszą być wciśnięte przestrzeni dostępnego obszaru klienckiego okna.  
  
> [!NOTE]
>  Nie można wywołać tej metody, gdy okno jest obsługiwany w przeglądarce.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób przesłonięcia <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> do wywołania <xref:System.Windows.Window.DragMove%2A>.  
  
 [!code-csharp[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDragMoveSnippets/CSharp/MainWindow.xaml.cs#callwindowdragmovecodebehind)]
 [!code-vb[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDragMoveSnippets/visualbasic/mainwindow.xaml.vb#callwindowdragmovecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Lewy przycisk myszy nie jest w dół.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">uprawnienia do przeciągnij okna. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.LocationChanged" />
      </Docs>
    </Member>
    <Member MemberName="GetWindow">
      <MemberSignature Language="C#" Value="public static System.Windows.Window GetWindow (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Window GetWindow(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.GetWindow(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Window ^ GetWindow(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="static member GetWindow : System.Windows.DependencyObject -&gt; System.Windows.Window" Usage="System.Windows.Window.GetWindow dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Obiekt zależności.</param>
        <summary>Zwraca odwołanie do <see cref="T:System.Windows.Window" /> obiektu, który jest hostem drzewa zawartości, w którym znajduje się obiekt zależności.</summary>
        <returns>A <see cref="T:System.Windows.Window" /> odwołanie do okna hosta.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dependencyObject" /> ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Hide();" />
      <MemberSignature Language="F#" Value="member this.Hide : unit -&gt; unit" Usage="window.Hide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że okno niewidoczne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Okno nie jest zamknięty, gdy jest on ukryty i ani <xref:System.Windows.Window.Closing> ani <xref:System.Windows.Window.Closed> zdarzenia. Zamiast tego okna <xref:System.Windows.UIElement.Visibility%2A> właściwość jest ustawiona na <xref:System.Windows.Visibility.Hidden?displayProperty=nameWithType>.  
  
 Jeśli okno jest aplikacji <xref:System.Windows.Application.MainWindow%2A> i aplikacji <xref:System.Windows.Application.ShutdownMode%2A> jest <xref:System.Windows.ShutdownMode.OnMainWindowClose>, aplikacja nie jest zamykany. Podobnie, aplikacja nie jest zamykany okno jest oknem tylko, jeśli tryb zamknięcia aplikacji jest <xref:System.Windows.ShutdownMode.OnLastWindowClose>.  
  
 Jeśli chcesz pokazać lub ukryć okno wiele razy w ciągu okresu istnienia aplikacji, a nie chcesz ponownie utworzyć wystąpienia okna zawsze wyświetleniem, może obsługiwać <xref:System.Windows.Window.Closing> zdarzeń, Anuluj ją i Wywołaj <xref:System.Windows.Window.Hide%2A> metody. Następnie możesz wywołać <xref:System.Windows.Window.Show%2A> dla tego samego wystąpienia, aby otworzyć go ponownie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.Hide" /> jest wywoływana w oknie, który jest zamykana (<see cref="E:System.Windows.Window.Closing" />) lub zostało zamknięte (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="M:System.Windows.Window.Close" />
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Windows.Media.ImageSource Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageSource Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Icon" />
      <MemberSignature Language="VB.NET" Value="Public Property Icon As ImageSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::ImageSource ^ Icon { System::Windows::Media::ImageSource ^ get(); void set(System::Windows::Media::ImageSource ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Icon : System.Windows.Media.ImageSource with get, set" Usage="System.Windows.Window.Icon" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ikonę okna.</summary>
        <value>
          <see cref="T:System.Windows.Media.ImageSource" /> Obiekt, który reprezentuje ikony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacje autonomiczne Windows Presentation Foundation (WPF) ma dwa typy ikon:  
  
-   Jeden zestaw ikonę, która jest określana za pomocą `<ApplicationIcon>` właściwości w projekcie aplikacji tworzenia pliku. Ta ikona jest stosowana jako ikony pulpitu dla zestawu.  
  
    > [!NOTE]
    >  Podczas debugowania w programie Visual Studio, jako ikony nie może występować z powodu procesu hostingu. Jeśli uruchamiasz plik wykonywalny, pojawi się ikona. Aby uzyskać więcej informacji, zobacz [proces hostingu (vshost.exe)](http://msdn.microsoft.com/library/c6b9e2be-f18d-4d75-ac52-56d55784734b).  
  
-   Jedna ikona na okna, który jest określany przez ustawienie <xref:System.Windows.Window.Icon%2A>. Dla każdego okna ta ikona jest stosowana w pasku tytułu, jego przycisk paska zadań i jego wpis listy wyboru aplikacji przycisków ALT + TAB.  
  
 Okno WPF zawsze wyświetla ikonę. Gdy zostało ono określone nie ustawiając <xref:System.Windows.Window.Icon%2A>, WPF wybierze ikonę, aby wyświetlić na podstawie następujących reguł:  
  
1.  Użyj ikony zestawu, jeśli określony.  
  
2.  Jeśli ikona zestawu nie jest określony, należy użyć domyślnej ikony Microsoft Windows.  
  
 Jeśli używasz <xref:System.Windows.Window.Icon%2A> do określenia ikona niestandardowych okien, można przywrócić domyślną ikonę aplikacji, ustawiając <xref:System.Windows.Window.Icon%2A> do `null`.  
  
 Pojedyncza ikona może służyć na różne sposoby, w systemie Windows, w tym pokazanie na pasku tytułu okna, na pasku zadań dla okna, na liście wyboru plików ALT + TAB. Każdy z tych Pokazuje ikonę przy użyciu innego rozmiaru; Ikona 16 x 16 pikseli jest wyświetlany na pasku tytułu okna i na pasku zadań, gdy ikona 32 x 32 pikseli jest wyświetlana na liście wyboru plików ALT + TAB. Niektóre aplikacje, takie jak [!INCLUDE[TLA#tla_winexpl](~/includes/tlasharptla-winexpl-md.md)], podaj **widoku** menu, które można wybrać ikonę, aby wyświetlić rozmiar.  
  
 Aby automatycznie dostosowują się do różnych rozmiarów ekranu, plik ikony składa się z co najmniej jeden rzeczywiste ikony, gdzie każdy z nich reprezentuje wersji ikony, przeznaczonego dla określonego rozmiaru i koloru głębokości. Na przykład jedna ikona może mieć tylko pojedyncza ikona 16 x 16 pikseli z 16 kolorów, podczas gdy inny może zawierać 16 x 16 pikseli i ikony 32 x 32 pikseli z 16 kolorów i 256 kolorów.  
  
 Jeśli istnieje ikony dla wszystkich możliwych rozmiary i liczby kolorów w pliku ikony <xref:System.Windows.Window> użyje odpowiednią ikonę. Jeśli plik ikony zawiera tylko podzestaw wszystkich możliwych ikon <xref:System.Windows.Window> używa dalej najbardziej odpowiednią ikonę w kolejności malejącej rozmiary i głębi kolorów.  
  
 Wynik jest, że ikona będzie zawsze używana przez <xref:System.Windows.Window>, mimo że ikona nie mogą odnosić się głębokość wymagany rozmiar i kolor. Na przykład ikona 16 x 16 pikseli z 16 kolorów może służyć do wyświetlenia jako ikona 32 x 32 pikseli 256 kolorów. To może spowodować niepożądane efekty wizualne, takie jak pixilation, ale można uniknąć przez tworzenie ikon dla poszczególnych docelowych rozmiary i głębi kolorów.  
  
> [!NOTE]
>  Nie można ustawić lub pobrać tej właściwości, gdy okno jest hostowana w przeglądarce.  
  
<a name="dependencyPropertyInfo_WindowIcon"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Window.IconProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób ustawiania ikonę okna.  
  
 [!code-xaml[WindowIconSnippets#WindowIconSetXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/WindowIconSnippets/XAML/MainWindow.xaml#windowiconsetxaml)]  
  
 [!code-csharp[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowIconSnippets/CSharp/MainWindow.xaml.cs#setwindowiconincode)]
 [!code-vb[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowIconSnippets/visualbasic/mainwindow.xaml.vb#setwindowiconincode)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uzyskać uprawnienia do ustawiania ikony. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IconProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IconProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IconProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IconProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IconProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IconProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IconProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.IconProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Window.Icon" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsActive">
      <MemberSignature Language="C#" Value="public bool IsActive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsActive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.IsActive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsActive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsActive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsActive : bool" Usage="System.Windows.Window.IsActive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy okno jest aktywne.</summary>
        <value>
          <see langword="true" /> Jeśli okno jest aktywne; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aktywne okno jest użytkownika bieżącego okna pierwszoplanowego i ma fokus, który jest oznaczony za pomocą wyglądu aktywnego paska tytułu. Aktywne okno będzie również najwyższy wszystkich okien najwyższego poziomu, które nie jawnie ustawione <xref:System.Windows.Window.Topmost%2A> właściwości.  
  
<a name="dependencyPropertyInfo_WindowIsActive"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Window.IsActiveProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="IsActiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsActiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsActiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IsActiveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsActiveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsActiveProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsActiveProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.IsActiveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Window.IsActive" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public double Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Left" />
      <MemberSignature Language="VB.NET" Value="Public Property Left As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Left { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Left : double with get, set" Usage="System.Windows.Window.Left" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia położenie lewa krawędź okna, w odniesieniu do pulpitu.</summary>
        <value>Położenie okna lewej krawędzi, w jednostkach logicznych (1/96th cala).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.Window> jest zmaksymalizowane lub zminimalizowane tego reprezentuje wartość lewej krawędzi przywracania w punkcie <xref:System.Windows.Window>.  
  
 Nie można ustawić tej właściwości przy użyciu stylu.  
  
 Jeśli nie określisz wartości, <xref:System.Windows.Window.Left%2A> ma ustawioną wartość domyślną systemu. Wartość domyślna systemu można również określić, ustawiając <xref:System.Windows.Window.Left%2A> do <xref:System.Double.NaN>. Ani <xref:System.Double.NegativeInfinity> ani <xref:System.Double.PositiveInfinity> jest prawidłową wartością dla <xref:System.Windows.Window.Left%2A>.  
  
> [!NOTE]
>  Nie można ustawić lub pobrać tej właściwości, gdy okno jest hostowana w przeglądarce.  
  
<a name="dependencyPropertyInfo_WindowLeft"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Window.LeftProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="LeftProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LeftProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LeftProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.LeftProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LeftProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LeftProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LeftProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.LeftProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Window.Left" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.LocationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LocationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LocationChanged;" />
      <MemberSignature Language="F#" Value="member this.LocationChanged : EventHandler " Usage="member this.LocationChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zmieni się lokalizacja okna.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zmieni się lokalizacja okna gdy:  
  
-   Użytkownik przesuwa okno, przeciągając je z pasek tytułu okna.  
  
-   Okno jest przenoszony po <xref:System.Windows.Window.DragMove%2A> jest wywoływana.  
  
-   Albo <xref:System.Windows.Window.Left%2A> lub <xref:System.Windows.Window.Top%2A> programowo ustawiono właściwość.  
  
-   **Przenieś** zostanie wybrany element menu okna systemu menu.  
  
-   <xref:System.Windows.Window.WindowState%2A> Właściwości zostanie zmieniona.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Window.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduł wyliczający dla okna logicznym podrzędnym elementów.</summary>
        <value>
          <see cref="T:System.Collections.IEnumerator" /> Elementy podrzędne logicznego okna.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkElement.LogicalChildren" />
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="window.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">A <see cref="T:System.Windows.Size" /> , które odzwierciedla dostępny rozmiar tego okna może być elementem podrzędnym. Aby wskazać, że zmieni rozmiar okna, niezależnie od zawartość jest dostępna jako wartość można przydzielić nieskończoności.</param>
        <summary>Zastępuje tę metodę do mierzenia rozmiaru okna.</summary>
        <returns>A <see cref="T:System.Windows.Size" /> , które odzwierciedla rozmiar tego okna ustala potrzebuje podczas układu, na podstawie jego obliczeń rozmiary dzieci.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.MeasureOverride%2A> nie jest wywoływane, gdy <xref:System.Windows.UIElement.Visibility%2A> właściwość ma wartość <xref:System.Windows.Visibility.Collapsed>. Jeśli wartość <xref:System.Windows.UIElement.Visibility%2A> właściwości <xref:System.Windows.Visibility.Hidden> lub <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.MeasureOverride%2A> jest wywoływana.  
  
> [!NOTE]
>  Gdy albo <xref:System.Windows.Window.Show%2A> lub <xref:System.Windows.Window.ShowDialog%2A> są nazywane <xref:System.Windows.UIElement.Visibility%2A> właściwość <xref:System.Windows.Window> ma ustawioną wartość <xref:System.Windows.Visibility.Visible>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="window.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Window.Activated" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnActivated%2A> zgłasza <xref:System.Windows.Window.Activated> zdarzeń.  
  
 Typ, który pochodzi z <xref:System.Windows.Window> może zastąpić <xref:System.Windows.Window.OnActivated%2A>. Należy wywołać przeciążonej <xref:System.Windows.Window.OnActivated%2A> dla klasy podstawowej Jeśli <xref:System.Windows.Window.Activated> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosed : EventArgs -&gt; unit&#xA;override this.OnClosed : EventArgs -&gt; unit" Usage="window.OnClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Window.Closed" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnClosed%2A> zgłasza <xref:System.Windows.Window.Closed> zdarzeń.  
  
 Typ, który pochodzi z <xref:System.Windows.Window> może zastąpić <xref:System.Windows.Window.OnClosed%2A>. Należy wywołać przeciążonej <xref:System.Windows.Window.OnClosed%2A> dla klasy podstawowej Jeśli <xref:System.Windows.Window.Closed> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit&#xA;override this.OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="window.OnClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.ComponentModel.CancelEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Window.Closing" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnClosing%2A> zgłasza <xref:System.Windows.Window.Closing> zdarzeń.  
  
 Typ, który pochodzi z <xref:System.Windows.Window> może zastąpić <xref:System.Windows.Window.OnClosing%2A>. Należy wywołać przeciążonej <xref:System.Windows.Window.OnClosing%2A> dla klasy podstawowej Jeśli <xref:System.Windows.Window.Closing> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnContentChanged">
      <MemberSignature Language="C#" Value="protected override void OnContentChanged (object oldContent, object newContent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContentChanged(object oldContent, object newContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentChanged(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContentChanged (oldContent As Object, newContent As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContentChanged(System::Object ^ oldContent, System::Object ^ newContent);" />
      <MemberSignature Language="F#" Value="override this.OnContentChanged : obj * obj -&gt; unit" Usage="window.OnContentChanged (oldContent, newContent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldContent" Type="System.Object" />
        <Parameter Name="newContent" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="oldContent">Odwołanie do katalogu głównego drzewa zawartości stary.</param>
        <param name="newContent">Odwołanie do katalogu głównego nowego drzewa zawartości.</param>
        <summary>Wywoływane, gdy <see cref="P:System.Windows.Controls.ContentControl.Content" /> zmiany właściwości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentRendered">
      <MemberSignature Language="C#" Value="protected virtual void OnContentRendered (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentRendered(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentRendered(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentRendered (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentRendered(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContentRendered : EventArgs -&gt; unit&#xA;override this.OnContentRendered : EventArgs -&gt; unit" Usage="window.OnContentRendered e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Window.ContentRendered" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnContentRendered%2A> zgłasza <xref:System.Windows.Window.ContentRendered> zdarzeń.  
  
 Typ, który pochodzi z <xref:System.Windows.Window> może zastąpić <xref:System.Windows.Window.OnContentRendered%2A>. Należy wywołać przeciążonej <xref:System.Windows.Window.OnContentRendered%2A> dla klasy podstawowej Jeśli <xref:System.Windows.Window.ContentRendered> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="window.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy i zwraca <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> obiekt dla tego <see cref="T:System.Windows.Window" />.</summary>
        <returns>A <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> obiekt dla tego <see cref="T:System.Windows.Window" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="window.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Window.Deactivated" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnDeactivated%2A> zgłasza <xref:System.Windows.Window.Deactivated> zdarzeń.  
  
 Typ, który pochodzi z <xref:System.Windows.Window> może zastąpić <xref:System.Windows.Window.OnDeactivated%2A>. Należy wywołać przeciążonej <xref:System.Windows.Window.OnDeactivated%2A> dla klasy podstawowej Jeśli <xref:System.Windows.Window.Deactivated> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected override void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpi, valuetype System.Windows.DpiScale newDpi) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDpiChanged (oldDpi As DpiScale, newDpi As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDpiChanged(System::Windows::DpiScale oldDpi, System::Windows::DpiScale newDpi);" />
      <MemberSignature Language="F#" Value="abstract member OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit&#xA;override this.OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit" Usage="window.OnDpiChanged (oldDpi, newDpi)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpi" Type="System.Windows.DpiScale" />
        <Parameter Name="newDpi" Type="System.Windows.DpiScale" />
      </Parameters>
      <Docs>
        <param name="oldDpi">Skali DPI poprzedniego ustawienia.</param>
        <param name="newDpi">Skala DPI nowe ustawienie.</param>
        <summary>Wywoływane, gdy wartość DPI, w którym to okno jest renderowany zmiany.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnLocationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLocationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLocationChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLocationChanged : EventArgs -&gt; unit&#xA;override this.OnLocationChanged : EventArgs -&gt; unit" Usage="window.OnLocationChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Window.LocationChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnLocationChanged%2A> zgłasza <xref:System.Windows.Window.LocationChanged> zdarzeń.  
  
 Typ, który pochodzi z <xref:System.Windows.Window> może zastąpić <xref:System.Windows.Window.OnLocationChanged%2A>. Należy wywołać przeciążonej <xref:System.Windows.Window.OnLocationChanged%2A> dla klasy podstawowej Jeśli <xref:System.Windows.Window.LocationChanged> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="OnManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="protected override void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationBoundaryFeedback(class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnManipulationBoundaryFeedback (e As ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnManipulationBoundaryFeedback(System::Windows::Input::ManipulationBoundaryFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnManipulationBoundaryFeedback : System.Windows.Input.ManipulationBoundaryFeedbackEventArgs -&gt; unit" Usage="window.OnManipulationBoundaryFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationBoundaryFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzenia.</param>
        <summary>Wywoływane, gdy <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /> zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja nie zmienia stanu obsługiwany ( <xref:System.Windows.RoutedEventArgs.Handled%2A> właściwości) z <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> danych zdarzenia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Jeśli można zastąpić <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />, zawsze wywoływać implementację podstawową Twojej <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" /> implementacji. Nie można wywoływać implementację podstawową uniemożliwia obsługę zdarzenie, które może zmieniać zachowania w czasie wykonywania końcowej klasy klas podstawowych. W zależności od wymagań, można wywoływać implementację podstawową przed lub po Twoje specjalnej obsługi.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSourceInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnSourceInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSourceInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnSourceInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSourceInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSourceInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSourceInitialized : EventArgs -&gt; unit&#xA;override this.OnSourceInitialized : EventArgs -&gt; unit" Usage="window.OnSourceInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Window.SourceInitialized" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnSourceInitialized%2A> zgłasza <xref:System.Windows.Window.SourceInitialized> zdarzeń.  
  
 Typ, który pochodzi z <xref:System.Windows.Window> może zastąpić <xref:System.Windows.Window.OnSourceInitialized%2A>. Należy wywołać przeciążonej <xref:System.Windows.Window.OnSourceInitialized%2A> dla klasy podstawowej Jeśli <xref:System.Windows.Window.SourceInitialized> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStateChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStateChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnStateChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStateChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStateChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStateChanged : EventArgs -&gt; unit&#xA;override this.OnStateChanged : EventArgs -&gt; unit" Usage="window.OnStateChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Window.StateChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnStateChanged%2A> zgłasza <xref:System.Windows.Window.StateChanged> zdarzeń.  
  
 Typ, który pochodzi z <xref:System.Windows.Window> może zastąpić <xref:System.Windows.Window.OnStateChanged%2A>. Należy wywołać przeciążonej <xref:System.Windows.Window.OnStateChanged%2A> dla klasy podstawowej Jeśli <xref:System.Windows.Window.StateChanged> musi zostać wywołane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides NotOverridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="window.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Element nadrzędny poprzedniej. Ustaw wartość null, jeśli <see cref="T:System.Windows.DependencyObject" /> nie miał poprzedniej nadrzędnej.</param>
        <summary>Wywoływane, gdy zostanie zmieniona okna nadrzędnego.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OwnedWindows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection OwnedWindows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection OwnedWindows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.OwnedWindows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnedWindows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ OwnedWindows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnedWindows : System.Windows.WindowCollection" Usage="System.Windows.Window.OwnedWindows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję systemu windows, których właścicielem jest to okno.</summary>
        <value>A <see cref="T:System.Windows.WindowCollection" /> zawiera odwołania do systemu windows, których właścicielem jest to okno.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należących do okna jest jednym którego <xref:System.Windows.Window.Owner%2A> właściwość jest ustawiona na odwołanie do innego okna, znany jako okno właściciela. Aby znaleźć wszystkie okna, które jest właścicielem oknem właściciela, można wyliczyć <xref:System.Windows.WindowCollection> zwróconego przez <xref:System.Windows.Window.OwnedWindows%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wyliczyć <xref:System.Windows.Window.OwnedWindows%2A>.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#getwindowownedwindowscode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#getwindowownedwindowscode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Window Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Owner" />
      <MemberSignature Language="VB.NET" Value="Public Property Owner As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ Owner { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Owner : System.Windows.Window with get, set" Usage="System.Windows.Window.Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Window" /> , który jest właścicielem to <see cref="T:System.Windows.Window" />.</summary>
        <value>A <see cref="T:System.Windows.Window" /> obiekt, który reprezentuje właściciela tego <see cref="T:System.Windows.Window" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy okno podrzędne jest otwarty przez okno nadrzędne, wywołując <xref:System.Windows.Window.ShowDialog%2A>, następuje ustanowienie niejawnych relacji między okna zarówno obiektów nadrzędnych i podrzędnych. Ta relacja wymusza pewnymi rodzajami zachowań, w tym względem minimalizowania, maksymalizowania i przywracania.  
  
 Podczas tworzenia okna podrzędnego przez okno nadrzędne, wywołując <xref:System.Windows.Window.Show%2A>, jednak okna podrzędnego nie ma relacji z okna nadrzędnego. Oznacza to, że:  
  
-   Okno podrzędne nie ma odwołanie do okna nadrzędnego.  
  
-   Zachowanie okno podrzędne nie są zależne od zachowania okno nadrzędne; albo okna może obejmować innych lub zminimalizowane zmaksymalizowane i przywrócone niezależnie od drugiego.  
  
 Pozwala utworzyć relację okno podrzędne okno nadrzędne, <xref:System.Windows.Window> obsługuje pojęcie własności. Własność jest ustanawiane po <xref:System.Windows.Window.Owner%2A> ustawiono właściwości okna (okien należące do firmy) z odwołaniem do innego okna (Okno właściciela).  
  
 Po ustanowieniu relacji są wystawiane następujące zachowania:  
  
-   Jeśli okno właściciela jest zminimalizowany, wszystkich należących do systemu windows są również zminimalizowane.  
  
-   Jeśli okno będących własnością jest zminimalizowany, jego właściciel nie jest zminimalizowany.  
  
-   Jeśli okno właściciela jest zmaksymalizowane, zarówno okno właściciela i jego należących do systemu windows zostaną przywrócone.  
  
-   Okno właściciela nigdy nie może obejmować należących do okna.  
  
-   Należące do systemu windows, które nie zostały otwarte przy użyciu <xref:System.Windows.Window.ShowDialog%2A> nie są modalne. Użytkownik może korzystać z oknem właściciela.  
  
-   Jeśli zamkniesz okno właściciela, również są zamykane należących do systemu windows.  
  
-   Jeśli należących do okna otwarto przy użyciu jego okno właściciela <xref:System.Windows.Window.Show%2A>oraz właściciel zamknięciu okna, okno będących własnością <xref:System.Windows.Window.Closing> nie zdarzenia.  
  
 Po otwarciu okna podrzędnego wywołując <xref:System.Windows.Window.ShowDialog%2A>, należy także ustawić <xref:System.Windows.Window.Owner%2A> właściwość okna podrzędnego. Jeśli nie, użytkownicy nie będzie mógł przywrócić zarówno okno podrzędne, jak i okno nadrzędne, naciskając przycisk paska zadań. Zamiast tego naciskając przycisk paska zadań umożliwia uzyskanie listy systemu windows, w tym zarówno nadrzędnym a podrzędnym okna, aby wybrać; wybrane okno jest przywrócone.  
  
> [!IMPORTANT]
>  Należy także ustawić <xref:System.Windows.Window.Owner%2A> właściwości w oknie, który jest otwarty przez wywołanie metody <xref:System.Windows.Window.ShowDialog%2A> aby zapewnić poprawne zachowanie w przypadku.  
  
> [!NOTE]
>  Nie można ustawić lub pobrać tej właściwości, gdy okno jest hostowana w przeglądarce.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak do ustanawiania relacji/należące do właściciela.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#setwindowownercode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#setwindowownercode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Okno próbuje należeć do samego siebie - lub - dwa okna próby właścicielem siebie nawzajem.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Window.Owner" /> Właściwość jest ustawiona na widoczne okno wyświetlane przy użyciu <see cref="M:System.Windows.Window.ShowDialog" /> - lub - <see cref="P:System.Windows.Window.Owner" /> ustawiono właściwości okna, które nie zostały wcześniej wyświetlane.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uzyskać uprawnienia do używania wszystkie okna i zdarzenia wejściowe użytkownika bez ograniczeń. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="ResizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.ResizeMode ResizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ResizeMode ResizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ResizeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ResizeMode As ResizeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResizeMode ResizeMode { System::Windows::ResizeMode get(); void set(System::Windows::ResizeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ResizeMode : System.Windows.ResizeMode with get, set" Usage="System.Windows.Window.ResizeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tryb zmiany rozmiaru.</summary>
        <value>A <see cref="T:System.Windows.ResizeMode" /> wartość określającą tryb zmiany rozmiaru.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istnieją cztery opcje:  
  
-   **NoResize**. Użytkownik nie może zmienić rozmiaru okna. Maksymalizuj i Minimalizuj pola nie są wyświetlane.  
  
-   **CanMinimize**. Użytkownik może tylko zminimalizować okno i przywróć ją z poziomu paska zadań. Maksymalizuj i Minimalizuj pola są wyświetlane, ale jest włączona tylko pole minimalizacji.  
  
-   **CanResize**. Użytkownik ma pełną możliwość zmiany rozmiaru okna, za pomocą pola Minimalizuj i Maksymalizuj i możliwością przeciągania konspektu wokół okna. Maksymalizuj i Minimalizuj pola są wyświetlane i włączone. (Ustawienie domyślne).  
  
-   **CanResizeWithGrip**. Ta opcja ma te same funkcje co <xref:System.Windows.ResizeMode.CanResize>, ale dodaje "uchwyt zmiany rozmiaru" w prawym dolnym rogu okna.  
  
> [!NOTE]
>  Nie można ustawić lub pobrać tej właściwości, gdy okno jest hostowana w przeglądarce.  
  
<a name="dependencyPropertyInfo_WindowResizeMode"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Window.ResizeModeProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ResizeGrip" />
      </Docs>
    </Member>
    <Member MemberName="ResizeModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ResizeModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ResizeModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ResizeModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ResizeModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ResizeModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ResizeModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ResizeModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Window.ResizeMode" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.RestoreBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestoreBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect RestoreBounds { System::Windows::Rect get(); };" />
      <MemberSignature Language="F#" Value="member this.RestoreBounds : System.Windows.Rect" Usage="System.Windows.Window.RestoreBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozmiar i położenie okna przed albo zminimalizowane lub zmaksymalizowane.</summary>
        <value>A <see cref="T:System.Windows.Rect" /> , który określa rozmiar i położenie okna przed zminimalizowane lub zmaksymalizowane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prostokąt przywracania jest region zajmowane przez okna przed jego zminimalizowane lub zmaksymalizowane. Można użyć <xref:System.Windows.Window.RestoreBounds%2A> do zapisania ostatnich rozmiar i położenie okna przed zamknięciem aplikacji, a przy następnym uruchomieniu aplikacji. Aby przywrócić okno sposób użytkownika, że pozostała wartości te są pobierane.  
  
 Po wykonaniu zapytania <xref:System.Windows.Window.RestoreBounds%2A> przed wykazało okna lub po jego zamknięciu, <xref:System.Windows.Rect.Empty%2A> jest zwracany.  
  
> [!NOTE]
>  Nie można pobrać tej właściwości, gdy okno jest obsługiwany w przeglądarce.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Windows.Window.RestoreBounds%2A> i izolowanego magazynu, aby upewnić się, rozmiar i położenie okna są takie same jak podczas poprzedniego wyświetleniem okna.  
  
 [!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml1)]  
[!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml2)]  
  
 [!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind1)]
 [!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind1)]  
[!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind2)]
[!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uzyskać uprawnienia do tworzenia zapytań dla rozmiar i położenie okna ograniczenia prostokąta. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Show" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show();" />
      <MemberSignature Language="F#" Value="member this.Show : unit -&gt; unit" Usage="window.Show " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Otwiera okno i zwraca bez oczekiwania na nowo otwartym oknie zamknąć.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.Window> tworzenia wystąpienia klasy, nie jest domyślnie widoczne. <xref:System.Windows.Window.Show%2A> Wyświetla okno i zwraca natychmiast bez oczekiwania na okno zostanie zamknięty. W rezultacie otwartym oknie nie uniemożliwić użytkownikom interakcji z innych okien w aplikacji. Okna tego typu jest nazywana *niemodalne* okna. Typowe przykłady niemodalne systemu Windows to windows właściwości, toolboxes i palety. Aby ograniczyć użytkownika do interakcji z określonego okna, okno musi zostać otwarte przez wywołanie metody <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Okno, która jest otwarta przez wywołanie metody <xref:System.Windows.Window.Show%2A> jest automatycznie nie ma relacji z okna, na którym został otwarty; w szczególności otwartego okna nie może określić, które okno otwarty. Ta relacja można nawiązać za pomocą <xref:System.Windows.Window.Owner%2A> właściwości i zarządzane przy użyciu <xref:System.Windows.Window.OwnedWindows%2A> właściwości.  
  
 Wywoływanie <xref:System.Windows.Window.Show%2A> osiąga ten sam rezultat zakończenia jako ustawienie <xref:System.Windows.UIElement.Visibility%2A> właściwość <xref:System.Windows.Window> do obiektu <xref:System.Windows.Visibility.Visible>. Istnieje jednak różnica między nimi z punktu widzenia chronometrażu.  
  
 Wywoływanie <xref:System.Windows.Window.Show%2A> jest operacja synchroniczna, która zwraca tylko po <xref:System.Windows.FrameworkElement.Loaded> zdarzenia na okno podrzędne:  
  
 [!code-csharp[WindowShowTimingSnippets#ShowSync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showsync)]
 [!code-vb[WindowShowTimingSnippets#ShowSync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showsync)]  
  
 Ustawienie <xref:System.Windows.UIElement.Visibility%2A>, jednak jest operacja asynchroniczna zwracająca natychmiast:  
  
 [!code-csharp[WindowShowTimingSnippets#ShowASync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showasync)]
 [!code-vb[WindowShowTimingSnippets#ShowASync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showasync)]  
  
 Podczas ustawiania <xref:System.Windows.UIElement.Visibility%2A>, wszelkie zdarzenia okna zarejestrować przed ustawieniem <xref:System.Windows.UIElement.Visibility%2A> nie może zostać zgłoszone po metody, w którym można ustawić <xref:System.Windows.UIElement.Visibility%2A> zakończy działanie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak otworzyć niemodalne okno dialogowe.  
  
 [!code-csharp[WindowShowSnippets#WindowShowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowSnippets/CSharp/MainWindow.xaml.cs#windowshowcode)]
 [!code-vb[WindowShowSnippets#WindowShowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowSnippets/visualbasic/mainwindow.xaml.vb#windowshowcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.Show" /> jest wywoływana w oknie, który jest zamykana (<see cref="E:System.Windows.Window.Closing" />) lub zostało zamknięte (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="M:System.Windows.Window.Hide" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowActivated">
      <MemberSignature Language="C#" Value="public bool ShowActivated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowActivated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowActivated" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowActivated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowActivated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowActivated : bool with get, set" Usage="System.Windows.Window.ShowActivated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy okno jest aktywowany przy pierwszym wyświetleniu.</summary>
        <value>
          <see langword="true" /> Jeśli okno jest aktywowany przy pierwszym wyświetleniu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy okno z jego <xref:System.Windows.Window.ShowActivated%2A> ustawioną właściwość `false` jest otwarty, okno nie jest aktywny i jego <xref:System.Windows.Window.Activated> zdarzenie nie jest wywoływane, dopóki użytkownik aktywuje okna ręcznie, wybierając go. Po wybraniu okno aktywuje i dezaktywuje normalnie.  
  
 Aby zapobiec aktywowana po jej otwarciu okna <xref:System.Windows.Window.ShowActivated%2A> musi mieć ustawioną właściwość `false` przed pokazaniem okna (wywołując <xref:System.Windows.Window.Show%2A>); ustawienie <xref:System.Windows.Window.ShowActivated%2A> do `false` po wyświetleniem elementu window nie ma wpływu.  
  
 Ustawienie <xref:System.Windows.Window.ShowActivated%2A> do `false` w oknie, który jest otwarty w trybie modalnym, wywołując <xref:System.Windows.Window.ShowDialog%2A>, nie ma rzeczywistego wpływu. Mimo że modalne okno nie będą aktywowane, modalne okno uniemożliwi użytkownika aktywowanie oknami otwartej aplikacji.  
  
<a name="dependencyPropertyInfo_WindowShowActivated"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Window.ShowActivatedProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie znaczników do skonfigurowania okno, aby otworzyć bez aktywowane.  
  
 [!code-xaml[WindowShowActivatedSnippets#ShowUnactivatedMARKUP1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml#showunactivatedmarkup1)]  
  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml.cs#showunactivatedcodebehind)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/awindow.xaml.vb#showunactivatedcodebehind)]  
  
 Poniższy przykład pokazuje, jak skonfigurować okno ma zostać otwarty bez aktywowane za pomocą kodu.  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/Window1.xaml.cs#showunactivatedwindowcode)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/window1.xaml.vb#showunactivatedwindowcode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowActivatedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowActivatedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowActivatedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowActivatedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowActivatedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowActivatedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShowActivatedProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ShowActivatedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Window.ShowActivated" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ShowDialog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog () As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; ShowDialog();" />
      <MemberSignature Language="F#" Value="member this.ShowDialog : unit -&gt; Nullable&lt;bool&gt;" Usage="window.ShowDialog " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Otwiera okno i zwraca tylko wtedy, gdy w nowo otwartym oknie jest zamknięty.</summary>
        <returns>A <see cref="T:System.Nullable`1" /> wartości typu <see cref="T:System.Boolean" /> Określa, czy działanie zostało zaakceptowane (<see langword="true" />) lub anulowane (<see langword="false" />). Wartość zwracana jest wartość <see cref="P:System.Windows.Window.DialogResult" /> właściwości przed zamknięciem okna.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.Window> tworzenia wystąpienia klasy, nie jest domyślnie widoczne. <xref:System.Windows.Window.ShowDialog%2A> Pokazuje okno powoduje wyłączenie wszystkich innych okien w aplikacji i zwraca tylko wtedy, gdy okno jest zamknięte. Ten typ okna jest nazywany *modalne* okna.  
  
 Głównie używane są okna modalne okna dialogowe. Okno dialogowe jest specjalnym rodzajem oknie, w którym aplikacje używają do interakcji z użytkownikami i wykonywanie zadań, takich jak otwieranie plików lub drukowanie dokumentów. Okna dialogowe często umożliwiają użytkownikom Zaakceptuj lub anulować zadania, dla którego zostały przedstawione przed zamknięciem okna dialogowego. <xref:System.Windows.Window.ShowDialog%2A> Zwraca <xref:System.Nullable%601> <xref:System.Boolean> wartość określająca, czy działanie zostało zaakceptowane lub anulowane. Wartość zwracana jest wartość <xref:System.Windows.Window.DialogResult%2A> właściwości przed zamknięciem okna. Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Window.DialogResult%2A>.  
  
 Okno, która jest otwarta przez wywołanie metody <xref:System.Windows.Window.ShowDialog%2A> — metoda nie ma automatycznie relacji w oknie, w którym został otwarty; w szczególności otwartego okna nie może określić, które okno otwarty. Ta relacja można nawiązać za pomocą <xref:System.Windows.Window.Owner%2A> właściwości i zarządzane przy użyciu <xref:System.Windows.Window.OwnedWindows%2A> właściwości. Do obsługi [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] automatyzacji (zobacz [Przegląd automatyzacji interfejsu użytkownika](~/docs/framework/ui-automation/ui-automation-overview.md)), <xref:System.Windows.Window.Owner%2A> musi być ustawiona dla okno otwierane przez wywołanie metody <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Po zakończeniu instalacji [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] okna (okna otwarte przez wywołanie metody <xref:System.Windows.Window.ShowDialog%2A>) jest zamknięty, wcześniej aktywowana uaktywnieniu okna. Jeśli po zakończeniu instalacji [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] okno jest oknem właściciela (zobacz <xref:System.Windows.Window.Owner%2A>), okno właściciela nie jest ponownie uaktywnić, kiedy modalne [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] zamknięciu okna, chyba że był on wcześniej aktywowana okna.  
  
> [!NOTE]
>  Nie można wywołać tej metody, gdy okno jest obsługiwany w przeglądarce.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób otwierania okna modalnego.  
  
 [!code-csharp[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowDialogSnippets/CSharp/MainWindow.xaml.cs#windowshowdialogcode)]
 [!code-vb[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowDialogSnippets/visualbasic/mainwindow.xaml.vb#windowshowdialogcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.ShowDialog" /> jest wywoływana w oknie, który jest zamykana (<see cref="E:System.Windows.Window.Closing" />) lub zostało zamknięte (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">uprawnienia do aktywacji okna. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowInTaskbar" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowInTaskbar As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowInTaskbar { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowInTaskbar : bool with get, set" Usage="System.Windows.Window.ShowInTaskbar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy okno ma przycisk paska zadań.</summary>
        <value>
          <see langword="true" /> Jeśli okno ma przycisk paska zadań; w przeciwnym razie <see langword="false" />. Nie dotyczy, kiedy okno znajduje się w przeglądarce.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Window.ShowInTaskbar%2A> ma ustawioną wartość `true`, okna pojawi się także na liście wyboru aplikacji ALT + TAB.  
  
 Ikony, która jest używana jako przycisk paska zadań i listy wyboru aplikacji ALT + TAB jest wartością <xref:System.Windows.Window.Icon%2A> właściwości.  
  
> [!NOTE]
>  Nie można ustawić lub pobrać tej właściwości, gdy okno jest hostowana w przeglądarce.  
  
<a name="dependencyPropertyInfo_WindowShowInTaskbar"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Window.ShowInTaskbarProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbarProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowInTaskbarProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowInTaskbarProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowInTaskbarProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowInTaskbarProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowInTaskbarProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShowInTaskbarProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ShowInTaskbarProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Window.ShowInTaskbar" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeToContent">
      <MemberSignature Language="C#" Value="public System.Windows.SizeToContent SizeToContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.SizeToContent SizeToContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.SizeToContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SizeToContent As SizeToContent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::SizeToContent SizeToContent { System::Windows::SizeToContent get(); void set(System::Windows::SizeToContent value); };" />
      <MemberSignature Language="F#" Value="member this.SizeToContent : System.Windows.SizeToContent with get, set" Usage="System.Windows.Window.SizeToContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeToContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy okno zostanie automatycznie zmienia swój rozmiar do rozmiarów jej zawartości.</summary>
        <value>A <see cref="T:System.Windows.SizeToContent" /> wartość. Wartość domyślna to <see cref="F:System.Windows.SizeToContent.Manual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.Window.SizeToContent%2A> ustawiono <xref:System.Windows.SizeToContent.WidthAndHeight>, ustawienia albo <xref:System.Windows.FrameworkElement.Height%2A> lub <xref:System.Windows.FrameworkElement.Width%2A> nie obowiązuje; można ustawić obie właściwości, ale są one konfigurowane przy użyciu wartości nie są stosowane do okna.  
  
 Gdy <xref:System.Windows.Window.SizeToContent%2A> ustawiono <xref:System.Windows.SizeToContent.Height>, ustawienie <xref:System.Windows.FrameworkElement.Height%2A> nie zmienia wysokość okna.  
  
 Gdy <xref:System.Windows.Window.SizeToContent%2A> ustawiono <xref:System.Windows.SizeToContent.Width>, ustawienie <xref:System.Windows.FrameworkElement.Width%2A> nie zmienia szerokość okna.  
  
 Jeśli <xref:System.Windows.Window.SizeToContent%2A> ma wartość innych niż <xref:System.Windows.SizeToContent.Manual>:  
  
-   <xref:System.Windows.Window.SizeToContent%2A> jest automatycznie ustawiana <xref:System.Windows.SizeToContent.Manual> Jeśli użytkownik zmieni okna przy użyciu uchwyt zmiany rozmiaru lub przeciągając obramowania.  
  
-   W przypadku zmiany rozmiaru zawartości w taki sposób, który powoduje, że okno, aby zmienić rozmiar, <xref:System.Windows.FrameworkElement.SizeChanged> jest wywoływane.  
  
 Jeśli okno jest niewidoczne (zobacz <xref:System.Windows.Window.AllowsTransparency%2A>), należy rozważyć ustawienie <xref:System.Windows.Window.SizeToContent%2A> do <xref:System.Windows.SizeToContent.WidthAndHeight> zapewnienie okna jest nie większy niż jego widocznej zawartości.  
  
> [!NOTE]
>  Nie można ustawić lub pobrać tej właściwości, gdy okno jest hostowana w przeglądarce.  
  
<a name="dependencyPropertyInfo_WindowSizeToContent"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Window.SizeToContentProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób ustawiania <xref:System.Windows.Window.SizeToContent%2A> właściwości w kodzie, aby określić, jak zmienia rozmiar okna dopasowana do jego zawartości.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/MainWindow.xaml.cs#setwindowsizetocontentpropertycode)]
 [!code-vb[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/mainwindow.xaml.vb#setwindowsizetocontentpropertycode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="P:System.Windows.Window.ResizeMode" />
      </Docs>
    </Member>
    <Member MemberName="SizeToContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SizeToContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SizeToContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.SizeToContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeToContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SizeToContentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable SizeToContentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.SizeToContentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Window.SizeToContent" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceInitialized">
      <MemberSignature Language="C#" Value="public event EventHandler SourceInitialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SourceInitialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.SourceInitialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceInitialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SourceInitialized;" />
      <MemberSignature Language="F#" Value="member this.SourceInitialized : EventHandler " Usage="member this.SourceInitialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To zdarzenie jest wywoływane w celu obsługi współdziałanie z [! INCLUDE[TLA#tla_win32](~/includes/tlasharptla-Win32-MD.MD)]. Zobacz <see cref="T:System.Windows.Interop.HwndSource" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.StateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StateChanged;" />
      <MemberSignature Language="F#" Value="member this.StateChanged : EventHandler " Usage="member this.StateChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy okno <see cref="P:System.Windows.Window.WindowState" /> zmiany właściwości.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfo">
      <MemberSignature Language="C#" Value="public System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.TaskbarItemInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property TaskbarItemInfo As TaskbarItemInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Shell::TaskbarItemInfo ^ TaskbarItemInfo { System::Windows::Shell::TaskbarItemInfo ^ get(); void set(System::Windows::Shell::TaskbarItemInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TaskbarItemInfo : System.Windows.Shell.TaskbarItemInfo with get, set" Usage="System.Windows.Window.TaskbarItemInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Shell.TaskbarItemInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia [! Miniatury paska zadań include[Win7](~/includes/Win7-MD.MD)] <see cref="T:System.Windows.Window" />.</summary>
        <value>[! Miniatury paska zadań include[Win7](~/includes/Win7-MD.MD)] <see cref="T:System.Windows.Window" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji o sposobie używania [!INCLUDE[win7](~/includes/win7-md.md)] zadań miniatur, zobacz <xref:System.Windows.Shell.TaskbarItemInfo> klasy.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Windows.Shell" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfoProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TaskbarItemInfoProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TaskbarItemInfoProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TaskbarItemInfoProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TaskbarItemInfoProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TaskbarItemInfoProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Window.TaskbarItemInfo" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Windows.Window.Title" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IWindowService.Title</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tytuł okna.</summary>
        <value>A <see cref="T:System.String" /> zawiera tytuł okna.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tytuł <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, lub [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], można również ustawić za pomocą <xref:System.Windows.Controls.Page.WindowTitle%2A?displayProperty=nameWithType>.  
  
<a name="dependencyPropertyInfo_WindowTitle"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Window.TitleProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TitleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TitleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TitleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TitleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TitleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Window.Title" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public double Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Top" />
      <MemberSignature Language="VB.NET" Value="Public Property Top As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Top { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Top : double with get, set" Usage="System.Windows.Window.Top" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia położenie górnej krawędzi okna, w odniesieniu do pulpitu.</summary>
        <value>Pozycja górnej części okna w jednostkach logicznych (1/96").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.Window> jest zmaksymalizowane lub zminimalizowane tego reprezentuje wartość górnej krawędzi przywracania w punkcie <xref:System.Windows.Window>.  
  
 Nie można ustawić tej właściwości przy użyciu stylu.  
  
 Jeśli nie określisz wartości, <xref:System.Windows.Window.Top%2A> ma ustawioną wartość domyślną systemu. Wartość domyślna systemu można również określić, ustawiając <xref:System.Windows.Window.Top%2A> do <xref:System.Double.NaN>. Ani <xref:System.Double.NegativeInfinity> ani <xref:System.Double.PositiveInfinity> jest prawidłową wartością dla <xref:System.Windows.Window.Top%2A>.  
  
> [!NOTE]
>  Nie można ustawić lub pobrać tej właściwości, gdy okno jest hostowana w przeglądarce.  
  
<a name="dependencyPropertyInfo_WindowTop"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Window.TopProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
      </Docs>
    </Member>
    <Member MemberName="Topmost">
      <MemberSignature Language="C#" Value="public bool Topmost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Topmost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Topmost" />
      <MemberSignature Language="VB.NET" Value="Public Property Topmost As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Topmost { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Topmost : bool with get, set" Usage="System.Windows.Window.Topmost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy okno jest wyświetlane w najwyższej kolejności.</summary>
        <value>
          <see langword="true" /> Jeśli okno jest najwyżej; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Okno których <xref:System.Windows.Window.Topmost%2A> właściwość jest ustawiona na `true` pojawi się nad oknami którego <xref:System.Windows.Window.Topmost%2A> właściwości są ustawione na `false`.  
  
 W grupie systemu windows, które mają <xref:System.Windows.Window.Topmost%2A> właściwość jest ustawiona na `true`, znajdujących się na górze okna jest okno jest aktywowany. Podobnie dla grupy systemu windows, które mają <xref:System.Windows.Window.Topmost%2A> właściwość jest ustawiona na `false`.  
  
> [!NOTE]
>  Nie można ustawić lub pobrać tej właściwości, gdy okno jest hostowana w przeglądarce.  
  
<a name="dependencyPropertyInfo_WindowTopmost"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Window.TopmostProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="TopmostProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopmostProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopmostProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopmostProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopmostProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopmostProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopmostProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TopmostProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Window.Topmost" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TopProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TopProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Window.Top" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStartupLocation">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStartupLocation WindowStartupLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStartupLocation WindowStartupLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStartupLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStartupLocation As WindowStartupLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStartupLocation WindowStartupLocation { System::Windows::WindowStartupLocation get(); void set(System::Windows::WindowStartupLocation value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStartupLocation : System.Windows.WindowStartupLocation with get, set" Usage="System.Windows.Window.WindowStartupLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStartupLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia położenie okna przy pierwszym wyświetleniu.</summary>
        <value>A <see cref="T:System.Windows.WindowStartupLocation" /> wartość, która określa górnego/lewego położenie okna przy pierwszym wyświetleniu. Wartość domyślna to <see cref="F:System.Windows.WindowStartupLocation.Manual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie <xref:System.Windows.WindowStartupLocation> do <xref:System.Windows.WindowStartupLocation.Manual> powoduje, że okno, aby być umieszczony zgodnie z jego <xref:System.Windows.Window.Left%2A> i <xref:System.Windows.Window.Top%2A> wartości właściwości. Jeśli dowolny <xref:System.Windows.Window.Left%2A> lub <xref:System.Windows.Window.Top%2A> właściwości nie są określone, ich wartości są określane przez system Windows.  
  
 Ustawienie <xref:System.Windows.WindowStartupLocation.CenterScreen> powoduje, że okno, aby być umieszczona w Centrum ekranu, który zawiera kursora myszy.  
  
 Ustawienie <xref:System.Windows.WindowStartupLocation> do <xref:System.Windows.WindowStartupLocation.CenterOwner> powoduje, że okno, aby być umieszczona w Centrum okna właściciela (zobacz <xref:System.Windows.Window.Owner%2A>), jeśli określony. Okno właściciela może być inne okno WPF lub okna z systemem innym niż WPF.  
  
> [!NOTE]
>  Aby uzyskać więcej informacji dotyczących okien WPF z WPF z systemem innym niż windows, zobacz [WPF i współdziałanie Win32](~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md) i <xref:System.Windows.Interop.WindowInteropHelper>.  
  
 Jeśli oknem właściciela nie jest określony, położenie okna jest określana w ten sam sposób jak <xref:System.Windows.WindowStartupLocation> ma ustawioną wartość <xref:System.Windows.WindowStartupLocation.Manual>.  
  
> [!NOTE]
>  Nie można ustawić lub pobrać wartości tej właściwości, kiedy okno znajduje się w przeglądarce.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.WindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowState" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowState As WindowState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowState WindowState { System::Windows::WindowState get(); void set(System::Windows::WindowState value); };" />
      <MemberSignature Language="F#" Value="member this.WindowState : System.Windows.WindowState with get, set" Usage="System.Windows.Window.WindowState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy okno jest przywrócone, zminimalizowane lub zmaksymalizowane.</summary>
        <value>A <see cref="T:System.Windows.WindowState" /> Określa, czy okno jest przywrócone, zminimalizowane lub zmaksymalizowane. Wartość domyślna to <see cref="F:System.Windows.WindowState.Normal" /> (przywrócona).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed okna zminimalizowane lub zmaksymalizowane, jego rozmiar i położenie są przechowywane w <xref:System.Windows.Window.RestoreBounds%2A>. Gdy okno jest następnie przywrócone, jego rozmiar i położenie wartości zostaną przywrócone z wartościami z <xref:System.Windows.Window.RestoreBounds%2A>.  
  
 Gdy <xref:System.Windows.Window.WindowState%2A> właściwości zostanie zmieniona, <xref:System.Windows.Window.StateChanged> jest wywoływane.  
  
> [!NOTE]
>  Nie można ustawić lub pobrać tej właściwości, gdy okno jest hostowana w przeglądarce.  
  
<a name="dependencyPropertyInfo_WindowWindowState"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Window.WindowStateProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="WindowStateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStateProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WindowStateProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.WindowStateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Window.WindowState" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyle">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStyle WindowStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStyle WindowStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStyle As WindowStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStyle WindowStyle { System::Windows::WindowStyle get(); void set(System::Windows::WindowStyle value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStyle : System.Windows.WindowStyle with get, set" Usage="System.Windows.Window.WindowStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia styl obramowania okna.</summary>
        <value>A <see cref="T:System.Windows.WindowStyle" /> , który określa styl obramowania okna. Wartość domyślna to <see cref="F:System.Windows.WindowStyle.SingleBorderWindow" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.WindowStyle%2A> może być jednym z <xref:System.Windows.WindowStyle> wartości wyliczenia, łącznie z <xref:System.Windows.WindowStyle.None>, <xref:System.Windows.WindowStyle.ToolWindow>, <xref:System.Windows.WindowStyle.SingleBorderWindow> (ustawienie domyślne) i <xref:System.Windows.WindowStyle.ThreeDBorderWindow>.  
  
 Na poniższej ilustracji przedstawiono Style okna na [!INCLUDE[TLA#tla_longhorn](~/includes/tlasharptla-longhorn-md.md)] (Windows Vista Aero motywu, z przezroczystego szkła włączone):  
  
 ![Style okna](~/add/media/windowoverviewfigure6.PNG "Style okna")  
  
> [!NOTE]
>  Nie można ustawić lub pobrać tej właściwości, gdy okno jest hostowana w przeglądarce.  
  
<a name="dependencyPropertyInfo_WindowWindowStyle"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Window.WindowStyleProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WindowStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.WindowStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Window.WindowStyle" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
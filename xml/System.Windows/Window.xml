<Type Name="Window" FullName="System.Windows.Window">
  <Metadata><Meta Name="ms.openlocfilehash" Value="eae82f38da2db6642d1be7c07faa5b5a64322578" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69443616" /></Metadata><TypeSignature Language="C#" Value="public class Window : System.Windows.Controls.ContentControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Window extends System.Windows.Controls.ContentControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Window" />
  <TypeSignature Language="VB.NET" Value="Public Class Window&#xA;Inherits ContentControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class Window : System::Windows::Controls::ContentControl" />
  <TypeSignature Language="F#" Value="type Window = class&#xA;    inherit ContentControl" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zapewnia możliwość tworzenia, konfigurowania, wyświetlania i zarządzania okresem istnienia systemu Windows i okien dialogowych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Punktem interakcji między użytkownikiem a aplikacją autonomiczną jest okno. [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Okno składa się z dwóch odrębnych obszarów:  
  
-   Obszar niebędący klientem, który hostuje zakończenia systemu Windows, łącznie z ikoną, tytułem, menu systemowym, przyciskiem Minimalizuj, przyciskiem Maksymalizuj, przyciskiem Przywróć, przyciskiem Zamknij i obramowaniem.  
  
-   Obszar klienta, który hostuje zawartość specyficzną dla aplikacji.  
  
 Standardowe okno jest pokazane na poniższym rysunku:  
  
 ![Elementy okna] (~/add/media/windowoverviewfigure1.PNG "Elementy okna")  
  
 <xref:System.Windows.Window>hermetyzuje możliwość tworzenia, konfigurowania, wyświetlania i zarządzania okresem istnienia okien i okien dialogowych, a także udostępnia następujące kluczowe usługi:  
  
 **Zarządzanie**okresem <xref:System.Windows.Window.Activate%2A>istnienia: <xref:System.Windows.Window.Closed> <xref:System.Windows.Window.Close%2A> <xref:System.Windows.Window.Activated> ,<xref:System.Windows.Window.Deactivated>, ,<xref:System.Windows.Window.Hide%2A>,,,, ,<xref:System.Windows.Window.SourceInitialized>,. <xref:System.Windows.Window.Show%2A> <xref:System.Windows.Window.Closing> <xref:System.Windows.Window.IsActive%2A>  
  
 **Zarządzanie oknem**: <xref:System.Windows.Window.GetWindow%2A>, <xref:System.Windows.Window.OwnedWindows%2A>, <xref:System.Windows.Window.Owner%2A>.  
  
 **Wygląd i zachowanie**: <xref:System.Windows.Window.AllowsTransparency%2A> <xref:System.Windows.Window.DragMove%2A> ,<xref:System.Windows.Window.ResizeMode%2A> ,<xref:System.Windows.Window.StateChanged> ,,,,,,,, ,<xref:System.Windows.Window.SizeToContent%2A> <xref:System.Windows.Window.Icon%2A> <xref:System.Windows.Window.Left%2A> <xref:System.Windows.Window.ContentRendered> <xref:System.Windows.Window.LocationChanged> <xref:System.Windows.Window.RestoreBounds%2A> <xref:System.Windows.Window.ShowActivated%2A> <xref:System.Windows.Window.ShowInTaskbar%2A> , <xref:System.Windows.Window.Title%2A>, <xref:System.Windows.Window.Top%2A>, <xref:System.Windows.Window.Topmost%2A>, <xref:System.Windows.Window.WindowStartupLocation%2A>, <xref:System.Windows.Window.WindowState%2A>,<xref:System.Windows.Window.WindowStyle%2A>  
  
 **Okna dialogowe**: <xref:System.Windows.Window.DialogResult%2A>, <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Ponadto program <xref:System.Windows.Application> udostępnia specjalną pomoc techniczną dotyczącą zarządzania wszystkimi oknami w aplikacji:  
  
-   Aplikacja przechowuje listę wszystkich okien, które są aktualnie tworzone w aplikacji. Ta lista jest udostępniana przez <xref:System.Windows.Application.Windows%2A> właściwość.  
  
-   Domyślnie <xref:System.Windows.Application.MainWindow%2A> jest automatycznie ustawiany z odwołaniem do pierwszego <xref:System.Windows.Window> wystąpienia, które jest tworzone w aplikacji. Spowoduje to przetworzenie okna w oknie głównym aplikacji.  
  
 <xref:System.Windows.Window> Można zaimplementować przy użyciu znaczników, znaczników i kodu.  
  
 <xref:System.Windows.Window>służy głównie do wyświetlania okna i okien dialogowych aplikacji autonomicznych. Jednak w przypadku aplikacji, które wymagają nawigowania na poziomie okna, takich jak kreatory, można <xref:System.Windows.Navigation.NavigationWindow> użyć zamiast tego. <xref:System.Windows.Navigation.NavigationWindow> pochodzi z<xref:System.Windows.Window> i rozszerza je za pomocą obsługi nawigacji w stylu przeglądarki.  
  
> [!NOTE]
>  Wyspy zawartości nawigacji mogą być dołączone do innych kontenerów zawartości i zawartości przy <xref:System.Windows.Controls.Frame>użyciu programu.  
  
 <xref:System.Windows.Window>wymaga `UnmanagedCode` uprawnienia zabezpieczeń do wystąpienia. Ma to następujące konsekwencje:  
  
-   [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)]-wdrożone Aplikacje autonomiczne będą żądać podniesienia uprawnień w przypadku uruchomienia z Internetu lub lokalnych stref intranetowych.  
  
-   [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)]to żądanie nie jest możliwe, ponieważ nie będzie można utworzyć wystąpienia okien dialogowych ani okna dialogowego.  
  
 Informacje o wdrażaniu aplikacji autonomicznej i zagadnieniach dotyczących zabezpieczeń znajdują się w temacie [strategia zabezpieczeń WPF — zabezpieczenia platformy](~/docs/framework/wpf/wpf-security-strategy-platform-security.md).  
  
 <xref:System.Windows.Window> A<xref:System.Windows.Controls.ContentControl>jest, co oznacza, że może zawierać pojedynczy obiekt dowolnego typu (na przykład ciąg, obraz lub panel). Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Controls.ContentControl> Klasa. <xref:System.Windows.Window> Ponadto jest elementem głównym, dlatego nie może być częścią zawartości innego elementu.  
  
> [!NOTE]
>  <xref:System.Windows.FrameworkElement.Height%2A>Właściwości, <xref:System.Windows.FrameworkElement.Width%2A>, i<xref:System.Windows.Window.Top%2A> ustawionena<xref:System.Windows.Window> podstawie stylu nie będą stosowane w czasie wykonywania. <xref:System.Windows.Window.Left%2A>  
  
## <a name="customizing-the-window-control"></a>Dostosowywanie kontrolki okna  
 Aby zastosować te same ustawienia właściwości do wielu <xref:System.Windows.Window> formantów, <xref:System.Windows.FrameworkElement.Style%2A> Użyj właściwości. Można zmienić wartość domyślną <xref:System.Windows.Controls.ControlTemplate> , aby dać formantowi unikatowy wygląd. Aby uzyskać więcej informacji na temat <xref:System.Windows.Controls.ControlTemplate>tworzenia, zobacz [Dostosowywanie wyglądu istniejącej kontrolki przez utworzenie ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  Aby zobaczyć części i Stany, które są specyficzne dla programu <xref:System.Windows.Window>, zobacz [Style okna i szablony](~/docs/framework/wpf/controls/window-styles-and-templates.md).  
  
 Właściwości zależności dla tego formantu można ustawić przy użyciu domyślnego stylu kontrolki.  Jeśli właściwość jest ustawiana za pomocą stylu domyślnego, właściwość może ulec zmianie z wartości domyślnej, gdy kontrolka pojawi się w aplikacji. Domyślny styl jest określany na podstawie tego, który Motyw pulpitu jest używany, gdy aplikacja jest uruchomiona.  Aby uzyskać więcej informacji, zobacz [domyślne motywy WPF](https://go.microsoft.com/fwlink/?LinkID=158252).  
  
[!INCLUDE[setting-a-visual-property](~/includes/visual-property-note.md)]  
  
## Examples  
 Poniższy przykład pokazuje, jak standardowe okno jest zdefiniowane tylko przy użyciu znaczników:  
  
 [!code-xaml[WindowSnippets#WindowMARKUPONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MarkupOnlyWindow.xaml#windowmarkuponly)]  
  
 W poniższym przykładzie przedstawiono sposób definiowania standardowego okna przy użyciu tylko kodu:  
  
 [!code-csharp[WindowSnippets#WindowCODEONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/CodeOnlyWindow.cs#windowcodeonly)]
 [!code-vb[WindowSnippets#WindowCODEONLY](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/codeonlywindow.vb#windowcodeonly)]  
  
 Poniższy przykład pokazuje, jak standardowe okno jest zdefiniowane przy użyciu kombinacji znaczników i kodu.  
  
 [!code-xaml[WindowSnippets#WindowXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml#windowxaml)]  
  
 [!code-csharp[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml.cs#windowcodebehind)]
 [!code-vb[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/mainwindow.xaml.vb#windowcodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Windows.Window.Show" />
    <altmember cref="M:System.Windows.Window.ShowDialog" />
    <altmember cref="P:System.Windows.Window.DialogResult" />
    <altmember cref="T:System.Windows.Application" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Window ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Window();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Window" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Width%2A>Konstruktor inicjuje <xref:System.Windows.Window> właściwości, <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.Window.Top%2A>i <xref:System.Windows.Window.Left%2A> do ich wartości domyślnych.  
  
 Jeśli okno jest tworzone <xref:System.AppDomain> w ramach <xref:System.Windows.Application> obiektu <xref:System.Windows.Window> , który ma obiekt, Konstruktor dodaje obiekt do zestawu <xref:System.Windows.Application>systemu Windows za pośrednictwem <xref:System.Windows.Application.Windows%2A> właściwości <xref:System.Windows.Application> obiektu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w przypadku uprawnienia dla tego obiektu do wywoływania niebezpiecznych metod natywnych. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public bool Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Activate" />
      <MemberSignature Language="VB.NET" Value="Public Function Activate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Activate();" />
      <MemberSignature Language="F#" Value="member this.Activate : unit -&gt; bool" Usage="window.Activate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Podejmuje próbę przełączenia okna na pierwszy plan i aktywuje go.</summary>
        <returns><see langword="true" />Jeśli program <see cref="T:System.Windows.Window" /> <see langword="false" />został pomyślnie aktywowany; w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reguły określające, czy okno jest aktywowane, są takie same jak te, które są [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] używane przez `SetForegroundWindow` funkcję (User32. dll).  
  
 Jeśli okno jest aktywowane w aplikacji Windows Presentation Foundation, która nie jest aplikacją na pierwszym planie użytkownika, <xref:System.Windows.Application.Activated> zdarzenie jest zgłaszane.  
  
> [!NOTE]
>  Nie można wywołać tej metody, gdy okno jest hostowane w przeglądarce.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla uprawnienia do uaktywnienia okna. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy okno stanie się oknem pierwszego planu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Okno zostanie uaktywnione (przejdzie do okna pierwszego planu), gdy:  
  
-   Okno jest otwierane po raz pierwszy.  
  
-   Użytkownik przełącza się do okna, zaznaczając go za pomocą myszy, naciskając klawisze ALT + TAB lub z Menedżera zadań.  
  
-   Użytkownik klika przycisk Pasek zadań okna.  
  
 System Windows, który musi wykryć, gdy staną się aktywowane, <xref:System.Windows.Window.Activated> może obsłużyć zdarzenie.  
  
 Po pierwszym aktywowaniu okna może ono zostać zdezaktywowane i ponownie uaktywnione wielokrotnie w okresie istnienia. Jeśli zachowanie lub stan aplikacji zależy od jej stanu aktywacji, może <xref:System.Windows.Window.IsActive%2A> ona sprawdzić, czy stan aktywacji, w której się znajduje.  
  
 Aplikacja może być <xref:System.Windows.Application.Activated>również.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparency">
      <MemberSignature Language="C#" Value="public bool AllowsTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.AllowsTransparency" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowsTransparency As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowsTransparency { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowsTransparency : bool with get, set" Usage="System.Windows.Window.AllowsTransparency" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy obszar klienta okna obsługuje przezroczystość.</summary>
        <value><see langword="true" />Jeśli okno obsługuje przezroczystość; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy właściwość okna ma ustawiony kolor przezroczysty, przy użyciu <xref:System.Windows.Media.Brushes.Transparent%2A> na przykład okno pozostaje nieprzezroczyste. <xref:System.Windows.Controls.Control.Background%2A> Oznacza to, że pulpit i wszystkie uruchomione aplikacje "poniżej" nie mogą być widoczne. Aby włączyć przezroczystość tego typu, <xref:System.Windows.Window.AllowsTransparency%2A> należy `true`ustawić wartość.  
  
 <xref:System.Windows.Window.AllowsTransparency%2A>istnieje, aby ułatwić tworzenie okien bez prostokątów, a w związku z tym, gdy <xref:System.Windows.Window.AllowsTransparency%2A> jest ustawiony na `true`, <xref:System.Windows.Window.WindowStyle%2A> Właściwość okna musi być ustawiona na <xref:System.Windows.WindowStyle.None>.  
  
<a name="dependencyPropertyInfo_WindowAllowsTransparency"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Window.AllowsTransparencyProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Okno, które ma <see cref="P:System.Windows.Window.WindowStyle" /> wartość inną niż. <see cref="F:System.Windows.WindowStyle.None" /></exception>
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparencyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowsTransparencyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowsTransparencyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.AllowsTransparencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowsTransparencyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowsTransparencyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AllowsTransparencyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.AllowsTransparencyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Window.AllowsTransparency" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberSignature Language="F#" Value="override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="window.ArrangeOverride arrangeBounds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds"><see cref="T:System.Windows.Size" /> Odzwierciedla końcowy rozmiar, którego okno powinno użyć do rozmieszczenia siebie i jego elementów podrzędnych.</param>
        <summary>Zastąp tę metodę, aby rozmieścić i zmienić rozmiar okna i jego elementów podrzędnych.</summary>
        <returns><see cref="T:System.Windows.Size" /> Odzwierciedla rzeczywisty używany rozmiar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.ArrangeOverride%2A>nie jest wywoływana, <xref:System.Windows.UIElement.Visibility%2A> Jeśli właściwość ma <xref:System.Windows.Visibility.Collapsed>wartość. Jeśli wartość <xref:System.Windows.UIElement.Visibility%2A> właściwości <xref:System.Windows.Visibility.Hidden> jest <xref:System.Windows.Visibility.Visible>albo ,<xref:System.Windows.Window.ArrangeOverride%2A> jest wywoływana.  
  
> [!NOTE]
>  <xref:System.Windows.UIElement.Visibility%2A> <xref:System.Windows.Visibility.Visible>Gdy lub są<xref:System.Windows.Window.ShowDialog%2A> wywoływane ,właściwośćobiektumaustawionąwartość.<xref:System.Windows.Window> <xref:System.Windows.Window.Show%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="window.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ręcznie zamyka <see cref="T:System.Windows.Window" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window> Można zamknąć przy użyciu jednego z kilku, dobrze znanych mechanizmów zapewnianych przez system, które znajdują się na pasku tytułu, w tym:  
  
-   ALT+F4.  
  
-   &#124; **Zamknij**menu systemowe.  
  
-   Przycisk **Zamknij** .  
  
 <xref:System.Windows.Window> Można również zamknąć przy użyciu jednego z kilku dobrze znanych mechanizmów w obszarze klienta udostępnianym przez deweloperów, w tym:  
  
-   **Plik** &#124; **Wyjdź** z okna głównego.  
  
-   **Plik** &#124; **Zamknij** lub przycisk **Zamknij** w oknie podrzędnym.  
  
> [!NOTE]
>  Przyciski **OK** i **Anuluj** w oknie dialogowym są również udostępniane przez dewelopera, chociaż prawdopodobnie zostaną ustawione <xref:System.Windows.Window.DialogResult%2A>, co spowoduje automatyczne zamknięcie okna otwartego przez wywołanie <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Te mechanizmy wymagają jawnie wywołania <xref:System.Windows.Window.Close%2A> , aby zamknąć okno.  
  
> [!NOTE]
>  Jeśli okno otwierane przez wywołanie <xref:System.Windows.Window.ShowDialog%2A>, i <xref:System.Windows.Controls.Button> z jego <xref:System.Windows.Controls.Button.IsCancel%2A> właściwością ustawioną na wartość true, zostanie automatycznie zamknięte po kliknięciu przycisku lub naciśnięciu klawisza ESC. Jeśli okno zostało otwarte przy użyciu <xref:System.Windows.Window.Show%2A>, <xref:System.Windows.Window.Close%2A> jednak musi być jawnie wywołana, na przykład <xref:System.Windows.Controls.Button>z <xref:System.Windows.Controls.Primitives.ButtonBase.Click> programu obsługi zdarzeń dla.  
  
 Zamknięcie okna powoduje <xref:System.Windows.Window.Closing> podniesienie zdarzenia. <xref:System.Windows.Window.Closing> Jeśli zdarzenie nie zostanie anulowane, występują następujące sytuacje:  
  
-   <xref:System.Windows.Application.Windows%2A?displayProperty=nameWithType> Element <xref:System.Windows.Window> zostanieusuniętyz(Jeśli<xref:System.Windows.Application> obiekt istnieje).  
  
-   Jest usuwany z właściciela <xref:System.Windows.Window> , jeśli relacja właściciela/własności <xref:System.Windows.Window> została ustanowiona przed wyświetleniem właściciela <xref:System.Windows.Window> i po jego otwarciu. <xref:System.Windows.Window>  
  
-   <xref:System.Windows.Window.Closed> Zdarzenie jest zgłaszane.  
  
-   Niezarządzane zasoby utworzone przez <xref:System.Windows.Window> są usuwane.  
  
-   Jeśli <xref:System.Windows.Window.ShowDialog%2A> został wywołany <xref:System.Windows.Window>, aby pokazać <xref:System.Windows.Window.ShowDialog%2A> , zwraca.  
  
 <xref:System.Windows.Window> Zamknięcie powoduje, że wszystkie okna, które należy zamknąć. Ponadto zamknięcie programu <xref:System.Windows.Window> może spowodować, że aplikacja przestanie działać w zależności od <xref:System.Windows.Application.ShutdownMode%2A?displayProperty=nameWithType> sposobu ustawienia właściwości.  
  
> [!NOTE]
>  Nie można wywołać tej metody, gdy okno jest hostowane w przeglądarce.  
  
   
  
## Examples  
 Poniższy przykład pokazuje menu wyjścia **pliku** &#124; **** , które jest obsługiwane do jawnego <xref:System.Windows.Window.Close%2A>wywołania.  
  
 [!code-xaml[WindowCloseSnippets#WindowCloseXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml#windowclosexaml)]  
  
 [!code-csharp[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml.cs#windowclosecodebehind)]
 [!code-vb[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowCloseSnippets/visualbasic/mainwindow.xaml.vb#windowclosecodebehind)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">w celu zezwolenia na używanie wszystkich zdarzeń systemu Windows i danych wejściowych użytkownika bez ograniczeń. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="P:System.Windows.Window.DialogResult" />
        <altmember cref="P:System.Windows.Window.Owner" />
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Closed;" />
      <MemberSignature Language="F#" Value="member this.Closed : EventHandler " Usage="member this.Closed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy okno zostanie zamknięte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po podniesieniu tego zdarzenia nie można uniemożliwić zamykania okna.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.UIElement.Visibility" />jest ustawiana, <see cref="M:System.Windows.Window.Show" />lub <see cref="M:System.Windows.Window.ShowDialog" />, lub <see cref="M:System.Windows.Window.Hide" /> jest wywoływana podczas zamykania okna.</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closing" />
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Closing;" />
      <MemberSignature Language="F#" Value="member this.Closing : System.ComponentModel.CancelEventHandler " Usage="member this.Closing : System.ComponentModel.CancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje bezpośrednio po <see cref="M:System.Windows.Window.Close" /> wywołaniu i może być obsłużone w celu anulowania zamknięcia okna.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.Closing>mogą być obsługiwane w celu wykrywania czasu zamykania okna (na przykład gdy <xref:System.Windows.Window.Close%2A> jest wywoływana). Ponadto, <xref:System.Windows.Window.Closing> można użyć, aby zapobiec zamykaniu okna. Aby zapobiec zamykaniu okna, można ustawić <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Właściwość <xref:System.ComponentModel.CancelEventArgs> argumentu na `true`.  
  
 Zdarzenie jest wywoływane, gdy <xref:System.Windows.Window.Close%2A> zostanie wywołany przycisk zamykania okna lub użytkownik naciśnie klawisz Alt + F4. <xref:System.Windows.Window.Closing>  
  
 Jeśli posiadane okno zostało otwarte przez okno jego właściciela przy <xref:System.Windows.Window.Show%2A>użyciu, a okno właściciela zostało zamknięte, nie zostanie zgłoszone <xref:System.Windows.Window.Closing> zdarzenie danego okna. Jeśli właściciel okna jest zamknięty (zobacz <xref:System.Windows.Window.Owner%2A>), <xref:System.Windows.Window.Closing> nie jest wywoływany w oknie należącym do użytkownika.  
  
 Jeśli <xref:System.Windows.Application.Shutdown%2A> jest wywoływana <xref:System.Windows.Window.Closing> , zostanie wywołane zdarzenie dla każdego okna. Jeśli <xref:System.Windows.Window.Closing> jednak zostanie anulowana, anulowanie zostanie zignorowane.  
  
 Jeśli sesja zakończy się, ponieważ użytkownik wyloguje się lub zamknie, <xref:System.Windows.Window.Closing> nie zostanie zgłoszony; dojście <xref:System.Windows.Application.SessionEnding> do zaimplementowania kodu, który Anuluje zamknięcie aplikacji.  
  
 Jeśli chcesz wyświetlać i ukrywać okno wiele razy w okresie istnienia aplikacji i nie chcesz, aby można było utworzyć wystąpienie tego okna za każdym razem, możesz obsłużyć <xref:System.Windows.Window.Closing> zdarzenie, anulować je i <xref:System.Windows.Window.Hide%2A> wywołać metodę. Następnie można wywołać <xref:System.Windows.Window.Show%2A> w tym samym wystąpieniu, aby otworzyć je ponownie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Windows.Window> , że program określa, czy konieczna jest interwencja użytkownika.  
  
 [!code-xaml[WindowClosingSnippets#WindowClosingXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml#windowclosingxaml1)]  
  
 [!code-csharp[WindowClosingSnippets](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml.cs)]
 [!code-vb[WindowClosingSnippets](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowClosingSnippets/visualbasic/datawindow.xaml.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.UIElement.Visibility" />jest ustawiana, <see cref="M:System.Windows.Window.Show" />lub <see cref="M:System.Windows.Window.ShowDialog" />, lub <see cref="M:System.Windows.Window.Close" /> jest wywoływana podczas zamykania okna.</exception>
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closed" />
      </Docs>
    </Member>
    <Member MemberName="ContentRendered">
      <MemberSignature Language="C#" Value="public event EventHandler ContentRendered;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContentRendered" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.ContentRendered" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentRendered As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ContentRendered;" />
      <MemberSignature Language="F#" Value="member this.ContentRendered : EventHandler " Usage="member this.ContentRendered : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po wyrenderowaniu zawartości okna.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli okno nie ma zawartości, to zdarzenie nie zostanie zgłoszone.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ContentControl.Content" />
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy okno stanie się oknem tła.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Okno zostanie zdezaktywowane (zostanie oknem tła), gdy:  
  
-   Użytkownik przełącza się do innego okna w bieżącej aplikacji.  
  
-   Użytkownik przełącza się do okna w innej aplikacji za pomocą klawiszy ALT + TAB lub przy użyciu Menedżera zadań.  
  
-   Użytkownik klika przycisk paska zadań dla okna w innej aplikacji.  
  
 System Windows, który musi wykryć, gdy zostanie zdezaktywowany przez obsługę <xref:System.Windows.Window.Deactivated> zdarzenia.  
  
 Po pierwszym zdezaktywowaniu okno może zostać ponownie aktywowane i zdezaktywowane w okresie istnienia. Jeśli zachowanie lub stan aplikacji zależy od jej stanu aktywacji, może <xref:System.Windows.Window.IsActive%2A> ona sprawdzić, czy stan aktywacji, w której się znajduje.  
  
 Aplikacja może być <xref:System.Windows.Application.Deactivated>również.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;bool&gt; DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.DialogResult" />
      <MemberSignature Language="VB.NET" Value="Public Property DialogResult As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;bool&gt; DialogResult { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.DialogResult : Nullable&lt;bool&gt; with get, set" Usage="System.Windows.Window.DialogResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.DialogResultConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wyniku okna dialogowego, która jest wartością zwracaną z <see cref="M:System.Windows.Window.ShowDialog" /> metody.</summary>
        <value><see cref="T:System.Nullable`1" /> Wartość typu<see cref="T:System.Boolean" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.DialogResult%2A>można go użyć z kodu, który pokazał okno dialogowe, aby określić, czy Użytkownik zaakceptował (`true`) lub anulował (`false`) okno dialogowe. Jeśli okno dialogowe zostało zaakceptowane, oznacza to kod, który otworzył okno dialogowe, aby pobrać dane, które zostały zebrane przez użytkownika i przetworzyć. Jeśli okno dialogowe zostało anulowane, oznacza to, że Wywoływanie kodu powinno przerwać dalsze przetwarzanie.  
  
 Domyślnie okno dialogowe zostało anulowane, gdy użytkownik wykonuje jedną z następujących czynności:  
  
-   PressesALT+F4.  
  
-   Klika przycisk **Zamknij** .  
  
-   Wybierz opcję **Zamknij** z menu systemowego.  
  
 We wszystkich tych przypadkach <xref:System.Windows.Window.DialogResult%2A> jest `false` domyślnie.  
  
 Okno dialogowe zazwyczaj udostępnia przycisk specjalny, aby anulować okno dialogowe, czyli przycisk, którego <xref:System.Windows.Controls.Button.IsCancel%2A> właściwość jest ustawiona na. `true` Przycisk skonfigurowany w ten sposób automatycznie zamknie okno po jego naciśnięciu lub po naciśnięciu klawisza ESC. W każdym z tych przypadków <xref:System.Windows.Window.DialogResult%2A> pozostało. `false`  
  
 Okno dialogowe zazwyczaj udostępnia przycisk Akceptuj, który jest przyciskiem, którego <xref:System.Windows.Controls.Button.IsDefault%2A> właściwość jest ustawiona na. `true` Przycisk skonfigurowany w ten sposób spowoduje <xref:System.Windows.Controls.Primitives.ButtonBase.Click> zdarzenie zdarzenia, gdy zostanie naciśnięte lub klawisz ENTER. Jednak nie będzie on automatycznie zamykał okna dialogowego ani nie ustawił <xref:System.Windows.Window.DialogResult%2A> go jako. `true` Należy ręcznie napisać ten kod, zazwyczaj z <xref:System.Windows.Controls.Primitives.ButtonBase.Click> programu obsługi zdarzeń dla przycisku domyślnego.  
  
 <xref:System.Windows.Window.DialogResult%2A>jest `null` wyświetlany, gdy okno dialogowe jest wyświetlane, ale nie zostało zaakceptowane ani anulowane.  
  
 Po zamknięciu okna dialogowego można uzyskać wynik okna dialogowego z wartości zwracanej przez <xref:System.Windows.Window.ShowDialog%2A> metodę lub przez sprawdzenie <xref:System.Windows.Window.DialogResult%2A> właściwości.  
  
 <xref:System.Windows.Window.DialogResult%2A>można ustawić tylko wtedy, <xref:System.Windows.Window> gdy jest otwarty, wywołując jego <xref:System.Windows.Window.ShowDialog%2A> metodę.  
  
> [!NOTE]
>  Nie można ustawić lub pobrać tej właściwości, gdy okno jest hostowane w przeglądarce.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak skonfigurować przycisk OK i przycisk Anuluj, aby przywrócić odpowiednie <xref:System.Windows.Window.DialogResult%2A>.  
  
 [!code-xaml[WindowDialogResultSnippets#WindowDialogResultXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml#windowdialogresultxaml)]  
  
 [!code-csharp[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml.cs#windowdialogresultcodebehind)]
 [!code-vb[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDialogResultSnippets/visualbasic/dialogbox.xaml.vb#windowdialogresultcodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Window.DialogResult" />jest ustawiany przed otwarciem okna przez wywołanie <see cref="M:System.Windows.Window.ShowDialog" />.  
  
—lub— 
 <see cref="P:System.Windows.Window.DialogResult" />jest ustawiony w oknie otwartym przez wywołanie <see cref="M:System.Windows.Window.Show" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.DpiChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChanged As DpiChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DpiChangedEventHandler ^ DpiChanged;" />
      <MemberSignature Language="F#" Value="member this.DpiChanged : System.Windows.DpiChangedEventHandler " Usage="member this.DpiChanged : System.Windows.DpiChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po wartości DPI ekranu, w którym jest wyświetlana zmiana okna.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DpiChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DpiChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.DpiChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DpiChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DpiChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DpiChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Window.DpiChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A <see cref="T:System.Windows.RoutedEvent" /> dla gdy wartość DPI ekranu jest zmieniana.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragMove">
      <MemberSignature Language="C#" Value="public void DragMove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DragMove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.DragMove" />
      <MemberSignature Language="VB.NET" Value="Public Sub DragMove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DragMove();" />
      <MemberSignature Language="F#" Value="member this.DragMove : unit -&gt; unit" Usage="window.DragMove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia przeciągnięcie okna przez myszą z lewym przyciskiem myszy nad widocznym obszarem obszaru klienta okna.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lewy przycisk myszy musi być wyłączony, gdy <xref:System.Windows.Window.DragMove%2A> jest wywoływana. Jednym ze sposobów wykrycia naciśnięcia przycisku myszy jest obsłużenie <xref:System.Windows.UIElement.MouseLeftButtonDown> zdarzenia.  
  
 Gdy <xref:System.Windows.Window.DragMove%2A> jest wywoływana, lewy przycisk myszy musi być rozciśnięty w obszarze widocznego obszaru klienta okna.  
  
> [!NOTE]
>  Nie można wywołać tej metody, gdy okno jest hostowane w przeglądarce.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak przesłonić <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> wywołanie. <xref:System.Windows.Window.DragMove%2A>  
  
 [!code-csharp[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDragMoveSnippets/CSharp/MainWindow.xaml.cs#callwindowdragmovecodebehind)]
 [!code-vb[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDragMoveSnippets/visualbasic/mainwindow.xaml.vb#callwindowdragmovecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Lewy przycisk myszy nie działa.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">w celu przeciągnięcia okna. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.LocationChanged" />
      </Docs>
    </Member>
    <Member MemberName="GetWindow">
      <MemberSignature Language="C#" Value="public static System.Windows.Window GetWindow (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Window GetWindow(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.GetWindow(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Window ^ GetWindow(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="static member GetWindow : System.Windows.DependencyObject -&gt; System.Windows.Window" Usage="System.Windows.Window.GetWindow dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Obiekt Dependency.</param>
        <summary>Zwraca odwołanie do <see cref="T:System.Windows.Window" /> obiektu, który hostuje drzewo zawartości, w którym znajduje się obiekt Dependency.</summary>
        <returns><see cref="T:System.Windows.Window" /> Odwołanie do okna hosta.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dependencyObject" />ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Hide();" />
      <MemberSignature Language="F#" Value="member this.Hide : unit -&gt; unit" Usage="window.Hide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że okno jest niewidoczne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Okno nie jest zamknięte, gdy jest ukryte i <xref:System.Windows.Window.Closing> nie jest wywoływane zdarzenie ani. <xref:System.Windows.Window.Closed> Zamiast tego okno <xref:System.Windows.UIElement.Visibility%2A> właściwości jest ustawione na <xref:System.Windows.Visibility.Hidden?displayProperty=nameWithType>.  
  
 Jeśli okno jest aplikacją <xref:System.Windows.Application.MainWindow%2A> i <xref:System.Windows.Application.ShutdownMode%2A> jest aplikacją, aplikacja nie jest <xref:System.Windows.ShutdownMode.OnMainWindowClose>zamykana. Podobnie aplikacja nie jest zamykana, jeśli okno jest jedynym oknem, a tryb zamykania aplikacji jest <xref:System.Windows.ShutdownMode.OnLastWindowClose>.  
  
 Jeśli chcesz wyświetlać i ukrywać okno wiele razy w okresie istnienia aplikacji i nie chcesz, aby okno było odtwarzane za każdym razem, możesz obsłużyć <xref:System.Windows.Window.Closing> zdarzenie, anulować je i <xref:System.Windows.Window.Hide%2A> wywołać metodę. Następnie można wywołać <xref:System.Windows.Window.Show%2A> w tym samym wystąpieniu, aby je ponownie otworzyć.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Window.Hide" />jest wywoływana w oknie, które jest zamykane<see cref="E:System.Windows.Window.Closing" />() lub zostało zamknięte (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="M:System.Windows.Window.Close" />
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Windows.Media.ImageSource Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageSource Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Icon" />
      <MemberSignature Language="VB.NET" Value="Public Property Icon As ImageSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::ImageSource ^ Icon { System::Windows::Media::ImageSource ^ get(); void set(System::Windows::Media::ImageSource ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Icon : System.Windows.Media.ImageSource with get, set" Usage="System.Windows.Window.Icon" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ikonę okna.</summary>
        <value><see cref="T:System.Windows.Media.ImageSource" /> Obiekt, który reprezentuje ikonę.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacje autonomiczne Windows Presentation Foundation (WPF) mają dwa typy ikon:  
  
-   Ikona jednego zestawu, która jest określona przy użyciu `<ApplicationIcon>` właściwości w pliku kompilacji projektu aplikacji. Ta ikona jest używana jako ikona pulpitu dla zestawu.  
  
    > [!NOTE]
    >  Podczas debugowania w programie Visual Studio ikona może nie być wyświetlana ze względu na proces hostingu. Jeśli uruchomisz plik wykonywalny, zostanie wyświetlona ikona. Aby uzyskać więcej informacji, zobacz [proces hostingu (vshost. exe)](https://msdn.microsoft.com/library/c6b9e2be-f18d-4d75-ac52-56d55784734b).  
  
-   Jedna ikona na okno, która jest określona przez <xref:System.Windows.Window.Icon%2A>ustawienie. Dla każdego okna ta ikona jest używana na pasku tytułu, na pasku zadań i na pozycji listy wyboru aplikacji ALT-TAB.  
  
 Okno WPF zawsze wyświetla ikonę. Gdy wartość nie jest określona przez ustawienie <xref:System.Windows.Window.Icon%2A>, WPF wybiera ikonę, która zostanie wyświetlona na podstawie następujących reguł:  
  
1.  Użyj ikony zestawu, jeśli została określona.  
  
2.  Jeśli ikona zestawu nie jest określona, Użyj domyślnej ikony systemu Microsoft Windows.  
  
 Jeśli używasz <xref:System.Windows.Window.Icon%2A> , aby określić niestandardową ikonę okna, możesz przywrócić domyślną ikonę aplikacji przez ustawienie <xref:System.Windows.Window.Icon%2A> do `null`.  
  
 Pojedynczą ikonę można użyć na różne sposoby w systemie Windows, w tym na pasku tytułu okna, pasek zadań dla okna, na liście wyboru pliku ALT + TAB. Każda z tych pokazuje ikonę przy użyciu innego rozmiaru; ikona 16x16 pikseli jest wyświetlana na pasku tytułu okna i na pasku zadań, a na liście wyboru pliku na karcie ALT + TAB zostanie wyświetlona ikona piksela 32x32. Niektóre aplikacje, takie [!INCLUDE[TLA#tla_winexpl](~/includes/tlasharptla-winexpl-md.md)]jak, udostępniają menu **Widok** umożliwiające wybranie rozmiaru ikony, którą chcesz wyświetlić.  
  
 Aby dowiedzieć się o różnych rozmiarach wyświetlania, plik ikony składa się z co najmniej jednej ikony rzeczywistej, w której każda z nich reprezentuje wersję ikony, która jest przeznaczona dla określonego rozmiaru i głębokości koloru. Na przykład jedna ikona może mieć tylko jedną ikonę 16x16 pikseli z 16 kolorami, a inna może zawierać ikony pikseli 16x16 pikseli i 32x32 z 16 kolorami i 256 kolorami.  
  
 Jeśli ikony dla wszystkich możliwych rozmiarów i głębi kolorów istnieją w pliku ikony, <xref:System.Windows.Window> program użyje odpowiedniej ikony. Jeśli plik ikony zawiera tylko podzestaw wszystkich możliwych ikon, program <xref:System.Windows.Window> używa następnej najbardziej odpowiedniej ikony w kolejności zmniejszania rozmiaru i głębi kolorów.  
  
 Wynikiem tego jest to, że ikona będzie zawsze używana przez <xref:System.Windows.Window>program, chociaż użyta ikona może nie wskazywać wymaganego rozmiaru i głębokości koloru. Na przykład ikona 16x16 pikseli z 16 kolorami może być używana do wyświetlania jako ikony pikseli 32x32 z 256 kolory. Może to spowodować niepożądane efekty wizualne, takie jak pixilation, ale można je uniknąć przez utworzenie ikon dla wszystkich rozmiarów i głębi kolorów.  
  
> [!NOTE]
>  Nie można ustawić lub pobrać tej właściwości, gdy okno jest hostowane w przeglądarce.  
  
<a name="dependencyPropertyInfo_WindowIcon"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Window.IconProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak ustawić ikonę okna.  
  
 [!code-xaml[WindowIconSnippets#WindowIconSetXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/WindowIconSnippets/XAML/MainWindow.xaml#windowiconsetxaml)]  
  
 [!code-csharp[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowIconSnippets/CSharp/MainWindow.xaml.cs#setwindowiconincode)]
 [!code-vb[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowIconSnippets/visualbasic/mainwindow.xaml.vb#setwindowiconincode)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla uprawnienia do ustawiania ikony. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IconProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IconProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IconProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IconProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IconProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IconProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IconProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.IconProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Window.Icon" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsActive">
      <MemberSignature Language="C#" Value="public bool IsActive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsActive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.IsActive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsActive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsActive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsActive : bool" Usage="System.Windows.Window.IsActive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy okno jest aktywne.</summary>
        <value><see langword="true" />Jeśli okno jest aktywne; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aktywne okno jest bieżącym oknem pierwszego planu użytkownika i ma fokus, który jest oznaczony aktywnym wyglądem paska tytułu. Aktywne okno będzie również najbardziej górną częścią wszystkich okien najwyższego poziomu, które nie ustawi <xref:System.Windows.Window.Topmost%2A> jawnie właściwości.  
  
<a name="dependencyPropertyInfo_WindowIsActive"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Window.IsActiveProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="IsActiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsActiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsActiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IsActiveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsActiveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsActiveProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsActiveProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.IsActiveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Window.IsActive" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public double Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Left" />
      <MemberSignature Language="VB.NET" Value="Public Property Left As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Left { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Left : double with get, set" Usage="System.Windows.Window.Left" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia położenie lewej krawędzi okna w odniesieniu do pulpitu.</summary>
        <value>Pozycja lewej krawędzi okna w jednostkach logicznych (1/1/96 cala).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy jest zmaksymalizowane lub zminimalizowane, ta wartość reprezentuje lewą krawędź punktu przywracania <xref:System.Windows.Window>dla. <xref:System.Windows.Window>  
  
 Tej właściwości nie można ustawić za pomocą stylu.  
  
 Jeśli wartość nie zostanie określona, <xref:System.Windows.Window.Left%2A> jest ustawiona na wartość domyślną systemowej. Możesz również określić wartość domyślną system, ustawiając ustawienie <xref:System.Windows.Window.Left%2A> na. <xref:System.Double.NaN> Ani nie jest prawidłową wartością dla <xref:System.Windows.Window.Left%2A>. <xref:System.Double.NegativeInfinity> <xref:System.Double.PositiveInfinity>  
  
> [!NOTE]
>  Nie można ustawić lub pobrać tej właściwości, gdy okno jest hostowane w przeglądarce.  
  
<a name="dependencyPropertyInfo_WindowLeft"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Window.LeftProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="LeftProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LeftProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LeftProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.LeftProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LeftProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LeftProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LeftProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.LeftProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Window.Left" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.LocationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LocationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LocationChanged;" />
      <MemberSignature Language="F#" Value="member this.LocationChanged : EventHandler " Usage="member this.LocationChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zmieni się lokalizacja okna.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lokalizacja okna zmienia się, gdy:  
  
-   Użytkownik przenosi okno, przeciągając je na pasek tytułu okna.  
  
-   Okno jest przenoszone po <xref:System.Windows.Window.DragMove%2A> wywołaniu.  
  
-   <xref:System.Windows.Window.Left%2A> Właściwość or <xref:System.Windows.Window.Top%2A> jest ustawiana programowo.  
  
-   Wybrano element menu **przenoszenia** menu systemowego okna.  
  
-   <xref:System.Windows.Window.WindowState%2A> Właściwość zostanie zmieniona.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Window.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduł wyliczający dla logicznych elementów podrzędnych okna.</summary>
        <value><see cref="T:System.Collections.IEnumerator" /> Logiczne elementy podrzędne okna.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkElement.LogicalChildren" />
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="window.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize"><see cref="T:System.Windows.Size" /> Odzwierciedla dostępny rozmiar, który to okno może dać dla elementu podrzędnego. Nieskończoność można podać jako wartość, aby wskazać, że rozmiar okna ma być dostępny.</param>
        <summary>Zastąp tę metodę, aby zmierzyć rozmiar okna.</summary>
        <returns><see cref="T:System.Windows.Size" /> Odzwierciedla rozmiar, który jest określany przez to okno podczas układania w oparciu o obliczenia rozmiarów dzieci.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.MeasureOverride%2A>nie jest wywoływana, <xref:System.Windows.UIElement.Visibility%2A> Jeśli właściwość ma <xref:System.Windows.Visibility.Collapsed>wartość. Jeśli wartość <xref:System.Windows.UIElement.Visibility%2A> właściwości <xref:System.Windows.Visibility.Hidden> jest <xref:System.Windows.Visibility.Visible>albo ,<xref:System.Windows.Window.MeasureOverride%2A> jest wywoływana.  
  
> [!NOTE]
>  <xref:System.Windows.UIElement.Visibility%2A> <xref:System.Windows.Visibility.Visible>Gdy lub są<xref:System.Windows.Window.ShowDialog%2A> wywoływane ,właściwośćobiektumaustawionąwartość.<xref:System.Windows.Window> <xref:System.Windows.Window.Show%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="window.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Window.Activated" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnActivated%2A><xref:System.Windows.Window.Activated> podnosi zdarzenie.  
  
 Typ, który pochodzi od <xref:System.Windows.Window> może przesłonić. <xref:System.Windows.Window.OnActivated%2A> Przesłonięta Metoda musi <xref:System.Windows.Window.OnActivated%2A> wywoływać klasę bazową <xref:System.Windows.Window.Activated> , jeśli trzeba ją wywołać.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosed : EventArgs -&gt; unit&#xA;override this.OnClosed : EventArgs -&gt; unit" Usage="window.OnClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Window.Closed" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnClosed%2A><xref:System.Windows.Window.Closed> podnosi zdarzenie.  
  
 Typ, który pochodzi od <xref:System.Windows.Window> może przesłonić. <xref:System.Windows.Window.OnClosed%2A> Przesłonięta Metoda musi <xref:System.Windows.Window.OnClosed%2A> wywoływać klasę bazową <xref:System.Windows.Window.Closed> , jeśli trzeba ją wywołać.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit&#xA;override this.OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="window.OnClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.ComponentModel.CancelEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Window.Closing" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnClosing%2A><xref:System.Windows.Window.Closing> podnosi zdarzenie.  
  
 Typ, który pochodzi od <xref:System.Windows.Window> może przesłonić. <xref:System.Windows.Window.OnClosing%2A> Przesłonięta Metoda musi <xref:System.Windows.Window.OnClosing%2A> wywoływać klasę bazową <xref:System.Windows.Window.Closing> , jeśli trzeba ją wywołać.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnContentChanged">
      <MemberSignature Language="C#" Value="protected override void OnContentChanged (object oldContent, object newContent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContentChanged(object oldContent, object newContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentChanged(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContentChanged (oldContent As Object, newContent As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContentChanged(System::Object ^ oldContent, System::Object ^ newContent);" />
      <MemberSignature Language="F#" Value="override this.OnContentChanged : obj * obj -&gt; unit" Usage="window.OnContentChanged (oldContent, newContent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldContent" Type="System.Object" />
        <Parameter Name="newContent" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="oldContent">Odwołanie do katalogu głównego starego drzewa zawartości.</param>
        <param name="newContent">Odwołanie do katalogu głównego nowego drzewa zawartości.</param>
        <summary>Wywoływana, gdy <see cref="P:System.Windows.Controls.ContentControl.Content" /> właściwość zostanie zmieniona.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentRendered">
      <MemberSignature Language="C#" Value="protected virtual void OnContentRendered (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentRendered(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentRendered(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentRendered (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentRendered(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContentRendered : EventArgs -&gt; unit&#xA;override this.OnContentRendered : EventArgs -&gt; unit" Usage="window.OnContentRendered e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Window.ContentRendered" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnContentRendered%2A><xref:System.Windows.Window.ContentRendered> podnosi zdarzenie.  
  
 Typ, który pochodzi od <xref:System.Windows.Window> może przesłonić. <xref:System.Windows.Window.OnContentRendered%2A> Przesłonięta Metoda musi <xref:System.Windows.Window.OnContentRendered%2A> wywoływać klasę bazową <xref:System.Windows.Window.ContentRendered> , jeśli trzeba ją wywołać.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="window.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy i zwraca <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> obiekt dla tego <see cref="T:System.Windows.Window" />obiektu.</summary>
        <returns>Obiekt dla tego <see cref="T:System.Windows.Window" />elementu. <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przesłania <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="window.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Window.Deactivated" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnDeactivated%2A><xref:System.Windows.Window.Deactivated> podnosi zdarzenie.  
  
 Typ, który pochodzi od <xref:System.Windows.Window> może przesłonić. <xref:System.Windows.Window.OnDeactivated%2A> Przesłonięta Metoda musi <xref:System.Windows.Window.OnDeactivated%2A> wywoływać klasę bazową <xref:System.Windows.Window.Deactivated> , jeśli trzeba ją wywołać.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected override void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpi, valuetype System.Windows.DpiScale newDpi) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDpiChanged (oldDpi As DpiScale, newDpi As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDpiChanged(System::Windows::DpiScale oldDpi, System::Windows::DpiScale newDpi);" />
      <MemberSignature Language="F#" Value="override this.OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit" Usage="window.OnDpiChanged (oldDpi, newDpi)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpi" Type="System.Windows.DpiScale" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="newDpi" Type="System.Windows.DpiScale" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="oldDpi">Poprzednie ustawienie skalowania DPI.</param>
        <param name="newDpi">Nowe ustawienie skalowania DPI.</param>
        <summary>Wywołuje się, gdy zmienia się wartość DPI tego okna.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnLocationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLocationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLocationChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLocationChanged : EventArgs -&gt; unit&#xA;override this.OnLocationChanged : EventArgs -&gt; unit" Usage="window.OnLocationChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Window.LocationChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnLocationChanged%2A><xref:System.Windows.Window.LocationChanged> podnosi zdarzenie.  
  
 Typ, który pochodzi od <xref:System.Windows.Window> może przesłonić. <xref:System.Windows.Window.OnLocationChanged%2A> Przesłonięta Metoda musi <xref:System.Windows.Window.OnLocationChanged%2A> wywoływać klasę bazową <xref:System.Windows.Window.LocationChanged> , jeśli trzeba ją wywołać.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="OnManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="protected override void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationBoundaryFeedback(class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnManipulationBoundaryFeedback (e As ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnManipulationBoundaryFeedback(System::Windows::Input::ManipulationBoundaryFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnManipulationBoundaryFeedback : System.Windows.Input.ManipulationBoundaryFeedbackEventArgs -&gt; unit" Usage="window.OnManipulationBoundaryFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationBoundaryFeedbackEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzenia.</param>
        <summary>Wywoływana, <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /> gdy wystąpi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja nie zmienia stanu obsługi ( <xref:System.Windows.RoutedEventArgs.Handled%2A> właściwości) <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> danych zdarzenia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Jeśli przesłonisz <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />, zawsze Wywołaj implementację podstawową <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" /> w implementacji. Niepowodzenie wywołania podstawowej implementacji uniemożliwia klasom bazowym obsługiwanie zdarzenia, co może zmienić zachowanie klasy końcowej w czasie wykonywania. Implementację podstawową można wywołać przed lub po specjalnej obsłudze, w zależności od wymagań.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSourceInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnSourceInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSourceInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnSourceInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSourceInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSourceInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSourceInitialized : EventArgs -&gt; unit&#xA;override this.OnSourceInitialized : EventArgs -&gt; unit" Usage="window.OnSourceInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Window.SourceInitialized" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnSourceInitialized%2A><xref:System.Windows.Window.SourceInitialized> podnosi zdarzenie.  
  
 Typ, który pochodzi od <xref:System.Windows.Window> może przesłonić. <xref:System.Windows.Window.OnSourceInitialized%2A> Przesłonięta Metoda musi <xref:System.Windows.Window.OnSourceInitialized%2A> wywoływać klasę bazową <xref:System.Windows.Window.SourceInitialized> , jeśli trzeba ją wywołać.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStateChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStateChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnStateChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStateChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStateChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStateChanged : EventArgs -&gt; unit&#xA;override this.OnStateChanged : EventArgs -&gt; unit" Usage="window.OnStateChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Window.StateChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnStateChanged%2A><xref:System.Windows.Window.StateChanged> podnosi zdarzenie.  
  
 Typ, który pochodzi od <xref:System.Windows.Window> może przesłonić. <xref:System.Windows.Window.OnStateChanged%2A> Przesłonięta Metoda musi <xref:System.Windows.Window.OnStateChanged%2A> wywoływać klasę bazową <xref:System.Windows.Window.StateChanged> , jeśli trzeba ją wywołać.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualChildrenChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualChildrenChanged (System.Windows.DependencyObject visualAdded, System.Windows.DependencyObject visualRemoved);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualChildrenChanged(class System.Windows.DependencyObject visualAdded, class System.Windows.DependencyObject visualRemoved) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualChildrenChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualChildrenChanged (visualAdded As DependencyObject, visualRemoved As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualChildrenChanged(System::Windows::DependencyObject ^ visualAdded, System::Windows::DependencyObject ^ visualRemoved);" />
      <MemberSignature Language="F#" Value="override this.OnVisualChildrenChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="window.OnVisualChildrenChanged (visualAdded, visualRemoved)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visualAdded" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.8" />
        <Parameter Name="visualRemoved" Type="System.Windows.DependencyObject" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="visualAdded"><see cref="T:System.Windows.Media.Visual" /> , Który został dodany do kolekcji.</param>
        <param name="visualRemoved"><see cref="T:System.Windows.Media.Visual" /> , Który został usunięty z kolekcji.</param>
        <summary>Wywoływana, <see cref="T:System.Windows.Media.VisualCollection" /> gdy ten <see cref="T:System.Windows.Window" /> obiekt jest modyfikowany.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides NotOverridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="window.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Poprzedni element nadrzędny. Ustaw wartość null, <see cref="T:System.Windows.DependencyObject" /> Jeśli nie ma poprzedniego elementu nadrzędnego.</param>
        <summary>Wywoływana, gdy zostanie zmieniony element nadrzędny okna.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OwnedWindows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection OwnedWindows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection OwnedWindows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.OwnedWindows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnedWindows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ OwnedWindows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnedWindows : System.Windows.WindowCollection" Usage="System.Windows.Window.OwnedWindows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję okien, dla których to okno jest właścicielem.</summary>
        <value>A <see cref="T:System.Windows.WindowCollection" /> , który zawiera odwołania do okien, dla których to okno jest właścicielem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posiadane okno to jeden, <xref:System.Windows.Window.Owner%2A> którego właściwość jest ustawiona z odwołaniem do innego okna, które jest znane jako okno właściciela. Aby znaleźć wszystkie okna, które są własnością danego okna właściciela, można wyliczyć <xref:System.Windows.WindowCollection> , które jest zwracane <xref:System.Windows.Window.OwnedWindows%2A> przez właściwość.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wyliczyć <xref:System.Windows.Window.OwnedWindows%2A>.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#getwindowownedwindowscode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#getwindowownedwindowscode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Window Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Owner" />
      <MemberSignature Language="VB.NET" Value="Public Property Owner As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ Owner { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Owner : System.Windows.Window with get, set" Usage="System.Windows.Window.Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Window" /> ten, który jest <see cref="T:System.Windows.Window" />właścicielem tego obiektu.</summary>
        <value>Obiekt, który reprezentuje właściciela tego <see cref="T:System.Windows.Window" />elementu. <see cref="T:System.Windows.Window" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy okno podrzędne jest otwierane za pomocą okna nadrzędnego przez wywołanie <xref:System.Windows.Window.ShowDialog%2A>, niejawna relacja jest ustanowiona między oknem nadrzędnym i podrzędnym. Ta relacja wymusza pewne zachowania, w tym w odniesieniu do minimalizowania, maksymalizowania i przywracania.  
  
 Gdy okno podrzędne jest tworzone przez okno nadrzędne przez wywołanie <xref:System.Windows.Window.Show%2A>, jednak okno podrzędne nie ma relacji z oknem nadrzędnym. Oznacza to, że:  
  
-   Okno podrzędne nie ma odwołania do okna nadrzędnego.  
  
-   Zachowanie okna podrzędnego nie zależy od zachowania okna nadrzędnego; Oba okna mogą pokryć inne lub być zminimalizowane, zmaksymalizowane i przywrócone niezależnie od siebie.  
  
 Aby umożliwić tworzenie relacji między oknem podrzędnym a oknem nadrzędnym, program <xref:System.Windows.Window> obsługuje pojęcie własności. Własność jest ustalana, <xref:System.Windows.Window.Owner%2A> gdy właściwość okna (własność okna) jest ustawiona z odwołaniem do innego okna (okno właściciela).  
  
 Po ustanowieniu tej relacji są następujące zachowania:  
  
-   Jeśli okno właściciela jest zminimalizowane, wszystkie jego należące do siebie okna są również zminimalizowane.  
  
-   Jeśli okno posiadane jest zminimalizowane, jego właściciel nie jest zminimalizowany.  
  
-   Jeśli okno właściciela jest zmaksymalizowane, zostaną przywrócone zarówno okno właściciela, jak i jego należące do siebie okna.  
  
-   Okno właściciela nigdy nie może obejmować posiadanego okna.  
  
-   Posiadane okna, które nie były <xref:System.Windows.Window.ShowDialog%2A> otwierane przy użyciu programu, nie są modalne. Użytkownik może nadal korzystać z okna właściciela.  
  
-   Jeśli zamkniesz okno właściciela, jego posiadane okna są również zamknięte.  
  
-   Jeśli posiadane okno zostało otwarte przez okno jego właściciela przy <xref:System.Windows.Window.Show%2A>użyciu, a okno właściciela zostało zamknięte, nie zostanie zgłoszone <xref:System.Windows.Window.Closing> zdarzenie danego okna.  
  
 Po otwarciu okna podrzędnego przez wywołanie <xref:System.Windows.Window.ShowDialog%2A>, należy również <xref:System.Windows.Window.Owner%2A> ustawić właściwość okna podrzędnego. Jeśli tego nie zrobisz, użytkownicy nie będą mogli przywrócić okna podrzędnego i okna nadrzędnego, naciskając przycisk Pasek zadań. Zamiast tego, naciśnięcie przycisku paska zadań spowoduje wyświetlenie listy systemu Windows, w tym okna podrzędnego i nadrzędnego, do wyboru; tylko wybrane okno zostanie przywrócone.  
  
> [!IMPORTANT]
>  Należy również ustawić <xref:System.Windows.Window.Owner%2A> właściwość w oknie, które jest otwierane przez wywołanie <xref:System.Windows.Window.ShowDialog%2A> w celu zapewnienia prawidłowego zachowania przy użyciu.  
  
> [!NOTE]
>  Nie można ustawić lub pobrać tej właściwości, gdy okno jest hostowane w przeglądarce.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak ustanowić relację właściciela/własności.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#setwindowownercode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#setwindowownercode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Okno próbuje nawiązać własne  
  
 —lub—  
  
 Dwa systemy Windows próbują sobie nawzajem.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Window.Owner" /> Właściwość jest ustawiana w widocznym oknie wyświetlanym za pomocą<see cref="M:System.Windows.Window.ShowDialog" />  
  
—lub— 
<see cref="P:System.Windows.Window.Owner" /> Właściwość jest ustawiana za pomocą okna, które nie zostało wcześniej pokazane.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">w celu zezwolenia na używanie wszystkich zdarzeń systemu Windows i danych wejściowych użytkownika bez ograniczeń. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="ResizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.ResizeMode ResizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ResizeMode ResizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ResizeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ResizeMode As ResizeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResizeMode ResizeMode { System::Windows::ResizeMode get(); void set(System::Windows::ResizeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ResizeMode : System.Windows.ResizeMode with get, set" Usage="System.Windows.Window.ResizeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tryb zmiany rozmiaru.</summary>
        <value><see cref="T:System.Windows.ResizeMode" /> Wartość określająca tryb zmiany rozmiaru.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dostępne są cztery opcje:  
  
-   Nie **zmieniaj rozmiaru**. Użytkownik nie może zmienić rozmiaru okna. Pola Maksymalizuj i Minimalizuj nie są wyświetlane.  
  
-   **Zmniejsz liczbę**. Użytkownik może zminimalizować okno i przywrócić go z paska zadań. Pola Minimalizuj i Maksymalizuj są wyświetlane, ale tylko pole Minimalizuj jest włączone.  
  
-   **Zmień rozmiar**. Użytkownik ma pełną możliwość zmiany rozmiaru okna przy użyciu pól Minimalizuj i Maksymalizuj oraz przeciągając kontur wokół okna. Pola Minimalizuj i Maksymalizuj są wyświetlane i włączane. (Wartość domyślna).  
  
-   **CanResizeWithGrip**. Ta opcja ma takie same funkcje jak <xref:System.Windows.ResizeMode.CanResize>, ale dodaje "uchwyt zmiany rozmiaru" do prawego dolnego rogu okna.  
  
> [!NOTE]
>  Nie można ustawić lub pobrać tej właściwości, gdy okno jest hostowane w przeglądarce.  
  
<a name="dependencyPropertyInfo_WindowResizeMode"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Window.ResizeModeProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ResizeGrip" />
      </Docs>
    </Member>
    <Member MemberName="ResizeModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ResizeModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ResizeModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ResizeModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ResizeModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ResizeModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ResizeModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ResizeModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Window.ResizeMode" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.RestoreBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestoreBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect RestoreBounds { System::Windows::Rect get(); };" />
      <MemberSignature Language="F#" Value="member this.RestoreBounds : System.Windows.Rect" Usage="System.Windows.Window.RestoreBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozmiar i lokalizację okna przed zminimalizowaniem lub zmaksymalizowaniem.</summary>
        <value><see cref="T:System.Windows.Rect" /> Określa rozmiar i lokalizację okna przed zminimalizowaniem lub zmaksymalizowaniem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prostokąt przywracania jest regionem zajmowanym przez okno, zanim został zminimalizowany lub zmaksymalizowany. Możesz użyć <xref:System.Windows.Window.RestoreBounds%2A> , aby zapisać ostatni rozmiar i lokalizację okna przed zamknięciem aplikacji i pobrać te wartości przy następnym uruchomieniu aplikacji w celu przywrócenia okna do sposobu, w jaki użytkownik je pozostawił.  
  
 Jeśli kwerenda <xref:System.Windows.Window.RestoreBounds%2A> przed wyświetleniem okna lub po jego zamknięciu, <xref:System.Windows.Rect.Empty%2A> jest zwracana.  
  
> [!NOTE]
>  Nie można pobrać tej właściwości, gdy okno jest hostowane w przeglądarce.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Windows.Window.RestoreBounds%2A> i wyizolowany magazyn, aby upewnić się, że rozmiar i lokalizacja okna są takie same, jak poprzednio wyświetlane okno.  
  
 [!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml1)]  
[!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml2)]  
  
 [!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind1)]
 [!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind1)]  
[!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind2)]
[!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla uprawnienia do wykonywania zapytań dotyczących rozmiaru i lokalizacji prostokąta obwiedni okna. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Show" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show();" />
      <MemberSignature Language="F#" Value="member this.Show : unit -&gt; unit" Usage="window.Show " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Otwiera okno i zwraca bez oczekiwania na zamknięcie nowo otwartego okna.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po utworzeniu wystąpienia klasy nie jest ona widoczna domyślnie. <xref:System.Windows.Window> <xref:System.Windows.Window.Show%2A>Wyświetla okno i zwraca natychmiast, bez czekania na zamknięcie okna. W związku z tym otwarte okno nie uniemożliwia użytkownikom współdziałania z innymi oknami w aplikacji. Ten typ okna jest nazywany oknem niemodalnym. ** Typowymi przykładami okien niemodalnych są okna właściwości, Przyborniki i palety. Aby ograniczyć użytkownika do współpracy z określonym oknem, należy otworzyć okno przez wywołanie <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Okno otwierane przez wywołanie <xref:System.Windows.Window.Show%2A> nie ma automatycznie relacji z oknem, które je otworzyło; w związku z tym otwartym oknem nie wiadomo, które okno zostało otwarte. Tę relację można ustalić przy użyciu <xref:System.Windows.Window.Owner%2A> właściwości i zarządzanej <xref:System.Windows.Window.OwnedWindows%2A> przy użyciu właściwości.  
  
 Wywołanie <xref:System.Windows.Window.Show%2A> osiąga ten sam wynik końcowy jako właściwość <xref:System.Windows.Window> ustawienia <xref:System.Windows.UIElement.Visibility%2A> obiektu na <xref:System.Windows.Visibility.Visible>. Istnieje jednak różnica między tymi dwoma z perspektywy czasowej.  
  
 Wywołanie <xref:System.Windows.Window.Show%2A> jest operacją synchroniczną, która zwraca tylko <xref:System.Windows.FrameworkElement.Loaded> po podniesieniu zdarzenia w oknie podrzędnym:  
  
 [!code-csharp[WindowShowTimingSnippets#ShowSync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showsync)]
 [!code-vb[WindowShowTimingSnippets#ShowSync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showsync)]  
  
 Ustawienie <xref:System.Windows.UIElement.Visibility%2A>jest jednak operacją asynchroniczną, która zwraca natychmiast:  
  
 [!code-csharp[WindowShowTimingSnippets#ShowASync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showasync)]
 [!code-vb[WindowShowTimingSnippets#ShowASync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showasync)]  
  
 W przypadku <xref:System.Windows.UIElement.Visibility%2A>ustawienia wszystkie zdarzenia okna, które należy zarejestrować przed <xref:System.Windows.UIElement.Visibility%2A> ustawieniem, mogą nie zostać podniesione do momentu, <xref:System.Windows.UIElement.Visibility%2A> w którym ustawiono metodę wykonania.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak otworzyć niemodalne okno.  
  
 [!code-csharp[WindowShowSnippets#WindowShowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowSnippets/CSharp/MainWindow.xaml.cs#windowshowcode)]
 [!code-vb[WindowShowSnippets#WindowShowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowSnippets/visualbasic/mainwindow.xaml.vb#windowshowcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Window.Show" />jest wywoływana w oknie, które jest zamykane<see cref="E:System.Windows.Window.Closing" />() lub zostało zamknięte (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="M:System.Windows.Window.Hide" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowActivated">
      <MemberSignature Language="C#" Value="public bool ShowActivated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowActivated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowActivated" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowActivated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowActivated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowActivated : bool with get, set" Usage="System.Windows.Window.ShowActivated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy okno jest aktywowane podczas pierwszego wyświetlania.</summary>
        <value><see langword="true" />Jeśli okno jest aktywowane podczas pierwszego wyświetlania; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy okno z <xref:System.Windows.Window.ShowActivated%2A> `false` ustawioną właściwością jest otwarte, okno nie zostanie aktywowane i jego <xref:System.Windows.Window.Activated> zdarzenie nie zostanie zgłoszone do momentu ręcznego aktywowania tego okna przez użytkownika. Po wybraniu okna uaktywnia się i dezaktywuje normalne.  
  
 Aby uniemożliwić aktywowanie okna, gdy zostanie <xref:System.Windows.Window.ShowActivated%2A> ono otwarte, właściwość musi być ustawiona na `false` wartość przed wyświetleniem okna (poprzez `false` wywoływanie <xref:System.Windows.Window.Show%2A>); ustawienie <xref:System.Windows.Window.ShowActivated%2A> po wyświetleniu okna nie ma żadnego efektu.  
  
 Ustawienie <xref:System.Windows.Window.ShowActivated%2A> w oknie, które jest otwierane modalnie, przez wywołanie <xref:System.Windows.Window.ShowDialog%2A>, nie ma rzeczywistego wpływu. `false` Chociaż okno modalne nie zostanie aktywowane, okno modalne uniemożliwi użytkownikowi aktywowanie innych otwartych okien aplikacji.  
  
<a name="dependencyPropertyInfo_WindowShowActivated"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Window.ShowActivatedProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać znaczników do konfigurowania okna, które ma być otwierane bez uaktywniania.  
  
 [!code-xaml[WindowShowActivatedSnippets#ShowUnactivatedMARKUP1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml#showunactivatedmarkup1)]  
  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml.cs#showunactivatedcodebehind)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/awindow.xaml.vb#showunactivatedcodebehind)]  
  
 Poniższy przykład pokazuje, jak używać kodu do konfigurowania okna, które ma być otwierane bez jego aktywowania.  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/Window1.xaml.cs#showunactivatedwindowcode)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/window1.xaml.vb#showunactivatedwindowcode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowActivatedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowActivatedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowActivatedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowActivatedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowActivatedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowActivatedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShowActivatedProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ShowActivatedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Window.ShowActivated" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ShowDialog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog () As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; ShowDialog();" />
      <MemberSignature Language="F#" Value="member this.ShowDialog : unit -&gt; Nullable&lt;bool&gt;" Usage="window.ShowDialog " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Otwiera okno i zwraca tylko wtedy, gdy nowo otwarte okno jest zamknięte.</summary>
        <returns>Wartość typu <see cref="T:System.Boolean" /> określająca, czy działanie zostało zaakceptowane (<see langword="true" />) czy anulowane (<see langword="false" />). <see cref="T:System.Nullable`1" /> Wartość zwracana jest wartością <see cref="P:System.Windows.Window.DialogResult" /> właściwości przed zamknięciem okna.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po utworzeniu wystąpienia klasy nie jest ona widoczna domyślnie. <xref:System.Windows.Window> <xref:System.Windows.Window.ShowDialog%2A>Wyświetla okno, wyłącza wszystkie inne okna w aplikacji i zwraca tylko wtedy, gdy okno jest zamknięte. Ten typ okna jest znany jako modalne ** okno.  
  
 Modalne okna są używane głównie jako okna dialogowe. Okno dialogowe jest specjalnym typem okna używanego przez aplikacje do pracy z użytkownikami w celu wykonywania zadań, takich jak otwieranie plików lub drukowanie dokumentów. Okna dialogowe zwykle umożliwiają użytkownikom akceptowanie lub anulowanie zadania, dla którego były wyświetlane przed zamknięciem okna dialogowego. <xref:System.Windows.Window.ShowDialog%2A><xref:System.Nullable%601> zwracawartośćokreślającą,czydziałaniezostałozaakceptowane<xref:System.Boolean> lub anulowane. Wartość zwracana jest wartością <xref:System.Windows.Window.DialogResult%2A> właściwości przed zamknięciem okna. Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Window.DialogResult%2A>.  
  
 Okno, które jest otwierane przez wywołanie <xref:System.Windows.Window.ShowDialog%2A> metody nie ma automatycznie relacji z oknem, która go otworzyła; w związku z tym otwarte okno nie wie, które okno zostało otwarte. Tę relację można ustalić przy użyciu <xref:System.Windows.Window.Owner%2A> właściwości i zarządzanej <xref:System.Windows.Window.OwnedWindows%2A> przy użyciu właściwości. Aby obsługiwać [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] automatyzację (zobacz [Omówienie automatyzacji interfejsu użytkownika](~/docs/framework/ui-automation/ui-automation-overview.md)), <xref:System.Windows.Window.Owner%2A> należy ustawić dla okna otwartego przez wywołanie. <xref:System.Windows.Window.ShowDialog%2A>  
  
 Po zamknięciu [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] okna modalnego (okno otwierane <xref:System.Windows.Window.ShowDialog%2A>przez wywołanie) poprzednio aktywowane okno jest ponownie uaktywniane. Jeśli okno modalne [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] ma okno właściciela (zobacz <xref:System.Windows.Window.Owner%2A>), okno właściciela nie jest ponownie uaktywniane, gdy okno modalne [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] zostanie zamknięte, chyba że zostało wcześniej uaktywnione okno.  
  
> [!NOTE]
>  Nie można wywołać tej metody, gdy okno jest hostowane w przeglądarce.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak otworzyć okno modalne.  
  
 [!code-csharp[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowDialogSnippets/CSharp/MainWindow.xaml.cs#windowshowdialogcode)]
 [!code-vb[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowDialogSnippets/visualbasic/mainwindow.xaml.vb#windowshowdialogcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Window.ShowDialog" />jest wywoływana w oknie, które jest zamykane<see cref="E:System.Windows.Window.Closing" />() lub zostało zamknięte (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">dla uprawnienia do uaktywnienia okna. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowInTaskbar" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowInTaskbar As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowInTaskbar { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowInTaskbar : bool with get, set" Usage="System.Windows.Window.ShowInTaskbar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy okno ma przycisk paska zadań.</summary>
        <value><see langword="true" />Jeśli okno ma przycisk paska zadań; w przeciwnym razie. <see langword="false" /> Nie ma zastosowania, gdy okno jest hostowane w przeglądarce.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Window.ShowInTaskbar%2A> jest ustawiona na `true`, okno zostanie również wyświetlone na liście wyboru aplikacji Alt + Tab.  
  
 Ikona używana zarówno dla przycisku paska zadań, jak i listy wyboru aplikacji Alt + Tab jest wartością <xref:System.Windows.Window.Icon%2A> właściwości.  
  
> [!NOTE]
>  Nie można ustawić lub pobrać tej właściwości, gdy okno jest hostowane w przeglądarce.  
  
<a name="dependencyPropertyInfo_WindowShowInTaskbar"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Window.ShowInTaskbarProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbarProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowInTaskbarProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowInTaskbarProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowInTaskbarProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowInTaskbarProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowInTaskbarProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShowInTaskbarProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ShowInTaskbarProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Window.ShowInTaskbar" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeToContent">
      <MemberSignature Language="C#" Value="public System.Windows.SizeToContent SizeToContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.SizeToContent SizeToContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.SizeToContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SizeToContent As SizeToContent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::SizeToContent SizeToContent { System::Windows::SizeToContent get(); void set(System::Windows::SizeToContent value); };" />
      <MemberSignature Language="F#" Value="member this.SizeToContent : System.Windows.SizeToContent with get, set" Usage="System.Windows.Window.SizeToContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeToContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy okno automatycznie zmieni rozmiar w celu dopasowania do rozmiaru jego zawartości.</summary>
        <value><see cref="T:System.Windows.SizeToContent" /> Wartość. Wartość domyślna to <see cref="F:System.Windows.SizeToContent.Manual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.Window.SizeToContent%2A> jest ustawiona na <xref:System.Windows.SizeToContent.WidthAndHeight>, ustawienie albo <xref:System.Windows.FrameworkElement.Height%2A> <xref:System.Windows.FrameworkElement.Width%2A> nie ma żadnego wpływu; obie właściwości można ustawić, ale wartości, z których są ustawiane, nie są stosowane do okna.  
  
 Gdy <xref:System.Windows.Window.SizeToContent%2A> jest ustawiona na <xref:System.Windows.SizeToContent.Height>, ustawienie <xref:System.Windows.FrameworkElement.Height%2A> nie zmienia wysokości okna.  
  
 Gdy <xref:System.Windows.Window.SizeToContent%2A> jest ustawiona na <xref:System.Windows.SizeToContent.Width>, ustawienie <xref:System.Windows.FrameworkElement.Width%2A> nie zmienia szerokości okna.  
  
 Jeśli <xref:System.Windows.Window.SizeToContent%2A> ma wartość inną niż <xref:System.Windows.SizeToContent.Manual>:  
  
-   <xref:System.Windows.Window.SizeToContent%2A>jest automatycznie ustawiany na <xref:System.Windows.SizeToContent.Manual> , jeśli użytkownik zmienia rozmiar okna przy użyciu uchwytu Zmień rozmiar lub przeciągając obramowanie.  
  
-   Jeśli rozmiar zawartości zmienia się w taki sposób, że <xref:System.Windows.FrameworkElement.SizeChanged> zostanie podniesiony rozmiar okna.  
  
 Jeśli okno jest przezroczyste (zobacz <xref:System.Windows.Window.AllowsTransparency%2A>), należy rozważyć ustawienie <xref:System.Windows.Window.SizeToContent%2A> , aby <xref:System.Windows.SizeToContent.WidthAndHeight> upewnić się, że okno nie jest większe niż jego widoczna zawartość.  
  
> [!NOTE]
>  Nie można ustawić lub pobrać tej właściwości, gdy okno jest hostowane w przeglądarce.  
  
<a name="dependencyPropertyInfo_WindowSizeToContent"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Window.SizeToContentProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak ustawić właściwość w <xref:System.Windows.Window.SizeToContent%2A> kodzie, aby określić, jak zmienia się rozmiar okna w celu dopasowania do jego zawartości.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/MainWindow.xaml.cs#setwindowsizetocontentpropertycode)]
 [!code-vb[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/mainwindow.xaml.vb#setwindowsizetocontentpropertycode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="P:System.Windows.Window.ResizeMode" />
      </Docs>
    </Member>
    <Member MemberName="SizeToContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SizeToContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SizeToContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.SizeToContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeToContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SizeToContentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable SizeToContentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.SizeToContentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Window.SizeToContent" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceInitialized">
      <MemberSignature Language="C#" Value="public event EventHandler SourceInitialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SourceInitialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.SourceInitialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceInitialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SourceInitialized;" />
      <MemberSignature Language="F#" Value="member this.SourceInitialized : EventHandler " Usage="member this.SourceInitialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To zdarzenie jest wywoływane, aby obsługiwać międzyoperacyjność z [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)]. Zobacz <see cref="T:System.Windows.Interop.HwndSource" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.StateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StateChanged;" />
      <MemberSignature Language="F#" Value="member this.StateChanged : EventHandler " Usage="member this.StateChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zmienia się <see cref="P:System.Windows.Window.WindowState" /> okno właściwości.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfo">
      <MemberSignature Language="C#" Value="public System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.TaskbarItemInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property TaskbarItemInfo As TaskbarItemInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Shell::TaskbarItemInfo ^ TaskbarItemInfo { System::Windows::Shell::TaskbarItemInfo ^ get(); void set(System::Windows::Shell::TaskbarItemInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TaskbarItemInfo : System.Windows.Shell.TaskbarItemInfo with get, set" Usage="System.Windows.Window.TaskbarItemInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Shell.TaskbarItemInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia [!INCLUDE[win7](~/includes/win7-md.md)] miniaturę paska zadań <see cref="T:System.Windows.Window" />dla.</summary>
        <value>Miniatura [!INCLUDE[win7](~/includes/win7-md.md)] paska zadań <see cref="T:System.Windows.Window" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat korzystania [!INCLUDE[win7](~/includes/win7-md.md)] z miniatury paska zadań, <xref:System.Windows.Shell.TaskbarItemInfo> zobacz Klasa.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Windows.Shell" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfoProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TaskbarItemInfoProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TaskbarItemInfoProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TaskbarItemInfoProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TaskbarItemInfoProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TaskbarItemInfoProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Window.TaskbarItemInfo" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Windows.Window.Title" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IWindowService.Title</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tytuł okna.</summary>
        <value>A <see cref="T:System.String" /> , który zawiera tytuł okna.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tytuł <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Page.WindowTitle%2A?displayProperty=nameWithType>lub [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], można również ustawić przy użyciu.  
  
<a name="dependencyPropertyInfo_WindowTitle"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Window.TitleProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TitleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TitleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TitleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TitleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TitleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Window.Title" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public double Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Top" />
      <MemberSignature Language="VB.NET" Value="Public Property Top As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Top { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Top : double with get, set" Usage="System.Windows.Window.Top" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia pozycję górnej krawędzi okna w odniesieniu do pulpitu.</summary>
        <value>Pozycja górnej części okna w jednostkach logicznych (1/96 ").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy jest zmaksymalizowane lub zminimalizowane, ta wartość reprezentuje górną krawędź punktu przywracania <xref:System.Windows.Window>dla. <xref:System.Windows.Window>  
  
 Tej właściwości nie można ustawić za pomocą stylu.  
  
 Jeśli wartość nie zostanie określona, <xref:System.Windows.Window.Top%2A> jest ustawiona na wartość domyślną systemowej. Możesz również określić wartość domyślną system, ustawiając ustawienie <xref:System.Windows.Window.Top%2A> na. <xref:System.Double.NaN> Ani nie jest prawidłową wartością dla <xref:System.Windows.Window.Top%2A>. <xref:System.Double.NegativeInfinity> <xref:System.Double.PositiveInfinity>  
  
> [!NOTE]
>  Nie można ustawić lub pobrać tej właściwości, gdy okno jest hostowane w przeglądarce.  
  
<a name="dependencyPropertyInfo_WindowTop"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Window.TopProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
      </Docs>
    </Member>
    <Member MemberName="Topmost">
      <MemberSignature Language="C#" Value="public bool Topmost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Topmost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Topmost" />
      <MemberSignature Language="VB.NET" Value="Public Property Topmost As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Topmost { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Topmost : bool with get, set" Usage="System.Windows.Window.Topmost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy okno jest wyświetlane w górnej kolejności z góry.</summary>
        <value><see langword="true" />Jeśli okno jest najwyższej stronie; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Okno, którego <xref:System.Windows.Window.Topmost%2A> właściwość jest ustawiona na `true` wartość pojawia się nad wszystkimi <xref:System.Windows.Window.Topmost%2A> oknami, których właściwości `false`są ustawione na.  
  
 W grupie okien, dla których <xref:System.Windows.Window.Topmost%2A> właściwość jest ustawiona na `true`, okno, które jest aktualnie aktywowane, jest oknem najwyższego poziomu. Podobnie dla grupy systemu Windows, która ma <xref:System.Windows.Window.Topmost%2A> właściwość ma `false`ustawioną wartość.  
  
> [!NOTE]
>  Nie można ustawić lub pobrać tej właściwości, gdy okno jest hostowane w przeglądarce.  
  
<a name="dependencyPropertyInfo_WindowTopmost"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Window.TopmostProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="TopmostProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopmostProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopmostProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopmostProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopmostProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopmostProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopmostProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TopmostProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Window.Topmost" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TopProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TopProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Window.Top" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStartupLocation">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStartupLocation WindowStartupLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStartupLocation WindowStartupLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStartupLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStartupLocation As WindowStartupLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStartupLocation WindowStartupLocation { System::Windows::WindowStartupLocation get(); void set(System::Windows::WindowStartupLocation value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStartupLocation : System.Windows.WindowStartupLocation with get, set" Usage="System.Windows.Window.WindowStartupLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStartupLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia pozycję okna podczas pierwszego wyświetlania.</summary>
        <value><see cref="T:System.Windows.WindowStartupLocation" /> Wartość określająca górną/lewą pozycję okna podczas pierwszego wyświetlania. Wartość domyślna to <see cref="F:System.Windows.WindowStartupLocation.Manual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie właściwości w taki <xref:System.Windows.WindowStartupLocation.Manual> sposób, aby okno było <xref:System.Windows.Window.Left%2A> umieszczane według wartości właściwości i <xref:System.Windows.Window.Top%2A>. `WindowStartupLocation` <xref:System.Windows.Window.Left%2A> Jeślialbowłaściwościniesąokreślone,ichwartościsą<xref:System.Windows.Window.Top%2A> określane przez system Windows.  
  
 `WindowStartupLocation` Ustawienie<xref:System.Windows.WindowStartupLocation.CenterScreen> właściwości powoduje, że okno jest umieszczane na środku ekranu, który zawiera kursor myszy.  
  
 `WindowStartupLocation` Ustawienie <xref:System.Windows.Window.Owner%2A?displayProperty=nameWithType>właściwości powoduje, że okno ma być umiejscowione w środku okna właściciela (patrz), jeśli zostało określone. <xref:System.Windows.WindowStartupLocation.CenterOwner> Okno właściciela może być innym oknem WPF lub oknem innym niż WPF.

> [!NOTE]   
>  Aby uzyskać więcej informacji na temat WPF Windows z oknami nienależącymi do WPF, zobacz [WPF i Win32](~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md) — współdziałanie i <xref:System.Windows.Interop.WindowInteropHelper>. 

 Jeśli nie określono okna właściciela, pozycja okna jest określana w taki sam sposób, jak w przypadku, `WindowStartupLocation` gdy właściwość jest ustawiona na. <xref:System.Windows.WindowStartupLocation.Manual>

> [!NOTE]
>  Nie można ustawić ani pobrać wartości tej właściwości, gdy okno jest hostowane w przeglądarce.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.WindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowState" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowState As WindowState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowState WindowState { System::Windows::WindowState get(); void set(System::Windows::WindowState value); };" />
      <MemberSignature Language="F#" Value="member this.WindowState : System.Windows.WindowState with get, set" Usage="System.Windows.Window.WindowState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy okno jest przywrócone, zminimalizowane lub zmaksymalizowane.</summary>
        <value>A <see cref="T:System.Windows.WindowState" /> , który określa, czy okno jest przywrócone, zminimalizowane lub zmaksymalizowane. Wartość domyślna to <see cref="F:System.Windows.WindowState.Normal" /> (przywrócone).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zanim okno zostanie zminimalizowane lub zmaksymalizowane, jego rozmiar i lokalizacja są przechowywane w <xref:System.Windows.Window.RestoreBounds%2A>. Gdy okno zostanie przywrócone, jego wartości rozmiaru i lokalizacji są przywracane z wartościami z <xref:System.Windows.Window.RestoreBounds%2A>.  
  
 Gdy właściwość zostanie zmieniona, <xref:System.Windows.Window.StateChanged> zostanie wygenerowane. <xref:System.Windows.Window.WindowState%2A>  
  
> [!NOTE]
>  Nie można ustawić lub pobrać tej właściwości, gdy okno jest hostowane w przeglądarce.  
  
<a name="dependencyPropertyInfo_WindowWindowState"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Window.WindowStateProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="WindowStateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStateProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WindowStateProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.WindowStateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Window.WindowState" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyle">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStyle WindowStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStyle WindowStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStyle As WindowStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStyle WindowStyle { System::Windows::WindowStyle get(); void set(System::Windows::WindowStyle value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStyle : System.Windows.WindowStyle with get, set" Usage="System.Windows.Window.WindowStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia styl obramowania okna.</summary>
        <value>A <see cref="T:System.Windows.WindowStyle" /> określa styl obramowania okna. Wartość domyślna to <see cref="F:System.Windows.WindowStyle.SingleBorderWindow" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.WindowStyle%2A><xref:System.Windows.WindowStyle> może być jedną z wartości wyliczenia, w tym <xref:System.Windows.WindowStyle.None>, <xref:System.Windows.WindowStyle.ToolWindow>, <xref:System.Windows.WindowStyle.SingleBorderWindow> (domyślnie) i. <xref:System.Windows.WindowStyle.ThreeDBorderWindow>  
  
 Na poniższej ilustracji przedstawiono style [!INCLUDE[TLA#tla_longhorn](~/includes/tlasharptla-longhorn-md.md)] okna (kompozycja Aero systemu Windows Vista z włączonym przezroczystym szkłem):  
  
 ![Style okna] (~/add/media/windowoverviewfigure6.PNG "Style okna")  
  
> [!NOTE]
>  Nie można ustawić lub pobrać tej właściwości, gdy okno jest hostowane w przeglądarce.  
  
<a name="dependencyPropertyInfo_WindowWindowStyle"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Window.WindowStyleProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WindowStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.WindowStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Window.WindowStyle" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

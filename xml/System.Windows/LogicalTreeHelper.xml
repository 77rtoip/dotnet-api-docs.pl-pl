<Type Name="LogicalTreeHelper" FullName="System.Windows.LogicalTreeHelper">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f2fd27ad4c537a177069b372af2f1a949e102361" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30715004" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class LogicalTreeHelper" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit LogicalTreeHelper extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.LogicalTreeHelper" />
  <TypeSignature Language="VB.NET" Value="Public Class LogicalTreeHelper" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogicalTreeHelper abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Udostępnia metody statyczne pomocy do wykonywania zapytań obiektów w drzewie logicznym.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.LogicalTreeHelper> Klasa dostarcza metody, które służy do zwracania kolekcje elementów podrzędnych obiektów lub określonych obiektów z następującego źródła w ramach węzły podrzędne drzewa logicznego. Jednak większość operacji drzewa obiektów, które należy na ogół wykonać są również widoczne przy użyciu podobnych metod i właściwości na <xref:System.Windows.FrameworkElement> lub <xref:System.Windows.FrameworkContentElement>. Na przykład spróbować wykonać następujące czynności:  
  
-   Zamiast wywoływania statycznych <xref:System.Windows.LogicalTreeHelper.GetChildren%2A> metodę, która zwraca moduł wyliczający dla logicznym podrzędnym obiektów, użyć dedykowanego kolekcji w modelu zawartości dla tego obiektu. Prawie wszystkie obiekty, które obsługują model zawartości ujawnia niektóre właściwości, który zawiera kolekcję obiektów podrzędnych, a także Obsługa interfejsu kolekcji bezpośrednio w tej kolekcji.  
  
-   Zamiast wywoływania statycznych <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> metodę, aby uzyskać obiekt podrzędny, określając jej nazwę, wywołanie <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> lub <xref:System.Windows.FrameworkContentElement.FindName%2A?displayProperty=nameWithType> metody w określonych obiektach.  
  
 <xref:System.Windows.LogicalTreeHelper> jest najbardziej przydatna dla scenariuszy analizy, gdzie są podróży w górę lub w dół rekursywnie drzewa logicznego za pośrednictwem różnych poziomach i chcesz użyć spójnego podejścia do badania różnych obiektów nadrzędnych i podrzędnych. W takim przypadku może korzystać kombinację modeli zawartości określonych i przy użyciu więcej modelu zawartości poszczególnych interfejsów API byłoby zbyt złożone.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public static void BringIntoView (System.Windows.DependencyObject current);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BringIntoView(class System.Windows.DependencyObject current) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.LogicalTreeHelper.BringIntoView(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BringIntoView (current As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BringIntoView(System::Windows::DependencyObject ^ current);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="current" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="current">Element interfejsu użytkownika, aby przełączyć do widoku.</param>
        <summary>Próbuje przełączyć do widoku żądanego elementu interfejsu użytkownika i zgłasza <see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /> zdarzeń w celu celu raportuje o wynikach.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to zazwyczaj bardziej wygodne do wywołania metody wystąpienia <xref:System.Windows.FrameworkElement.BringIntoView%2A?displayProperty=nameWithType> lub <xref:System.Windows.FrameworkContentElement.BringIntoView%2A?displayProperty=nameWithType> zamiast tej metody statycznej narzędzia. Zachowanie metody wystąpienia jest odpowiednikiem zachowanie metody statycznej.  
  
 Nawet wtedy, gdy `current` został dostarczony element interfejsu użytkownika <xref:System.Windows.FrameworkContentElement>, wynikowy zdarzeń jest taka sama <xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType> zdarzeń z źródłowym <xref:System.Windows.FrameworkContentElement> zidentyfikować przez sprawdzenie danych zdarzenia zdarzenia.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.RequestBringIntoView" />
      </Docs>
    </Member>
    <Member MemberName="FindLogicalNode">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject FindLogicalNode (System.Windows.DependencyObject logicalTreeNode, string elementName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject FindLogicalNode(class System.Windows.DependencyObject logicalTreeNode, string elementName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.LogicalTreeHelper.FindLogicalNode(System.Windows.DependencyObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLogicalNode (logicalTreeNode As DependencyObject, elementName As String) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyObject ^ FindLogicalNode(System::Windows::DependencyObject ^ logicalTreeNode, System::String ^ elementName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logicalTreeNode" Type="System.Windows.DependencyObject" />
        <Parameter Name="elementName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logicalTreeNode">Obiekt się rozpocząć wyszukiwanie z. Ten obiekt musi być równa albo <see cref="T:System.Windows.FrameworkElement" /> lub <see cref="T:System.Windows.FrameworkContentElement" />.</param>
        <param name="elementName">Nazwa obiektu można znaleźć.</param>
        <summary>Próbuje znaleźć i zwraca obiekt, który ma określoną nazwę. Wyszukiwanie rozpoczyna się od określonego obiektu i kontynuuje na węzły podrzędne drzewa logicznego.</summary>
        <returns>Obiekt o pasującej nazwie, jeśli został znaleziony; Zwraca <see langword="null" /> Jeśli nie pasujące znaleziono nazwy w drzewie logicznym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody <xref:System.Windows.FrameworkContentElement.FindName%2A?displayProperty=nameWithType> i <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> przypominają pozornie <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>, ale działają przez logikę różnych:  
  
-   Kierunek wyszukiwania dla <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> ku obiektów podrzędnych (niżej na drzewie); kierunek wyszukiwania dla `FindName` metody jest kierunku obiektów nadrzędnych (w górę drzewa).  
  
-   `FindName` Metody są regulowane przez pojęcie XAML namescope. Przy użyciu `FindName` ma gwarancji, że tylko jeden obiekt o tej nazwie nie istnieje, ponieważ XAML namescopes wymuszać unikatowość. Z kolei <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> ignoruje XAML namescope i może między granicami namescope XAML podczas wyszukiwania. Tak, nie ma żadnej gwarancji unikatowości z `elementName` nazwy po przekroczeniu granic. Aby uzyskać więcej informacji na temat XAML namescopes, zobacz [WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChildren">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kolekcję obiektów podrzędnych natychmiastowego określonego obiektu przez przetwarzanie drzewa logicznego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChildren">
      <MemberSignature Language="C#" Value="public static System.Collections.IEnumerable GetChildren (System.Windows.DependencyObject current);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IEnumerable GetChildren(class System.Windows.DependencyObject current) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.LogicalTreeHelper.GetChildren(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetChildren (current As DependencyObject) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IEnumerable ^ GetChildren(System::Windows::DependencyObject ^ current);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="current" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="current">Obiekt, z którego chcesz uruchomić przetwarzania drzewa logicznego. Ma to być albo <see cref="T:System.Windows.FrameworkElement" /> lub <see cref="T:System.Windows.FrameworkContentElement" />.</param>
        <summary>Zwraca kolekcję obiektów podrzędnych natychmiastowego określonego obiektu przez przetwarzanie drzewa logicznego.</summary>
        <returns>Wyliczalny kolekcja obiektów podrzędnych natychmiastowego z drzewa logicznego określonego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda podpisu i pomocnika głównie w przypadku, gdy wiadomo, czy `current` jest <xref:System.Windows.FrameworkElement> lub <xref:System.Windows.FrameworkContentElement> i są również nie wiesz, czy ten obiekt klasy obsługuje swoją własną kolekcję modelu zawartości. Jeśli można określić typu obiektu, który jest kwerenda, sprawdź, czy istnieje określonych właściwości zawartości, który znasz tego typu. Na przykład, jeśli wiadomo, że obiekt wyszukując jest <xref:System.Windows.Controls.ItemsControl>, sprawdź <xref:System.Windows.Controls.ItemsControl.Items%2A> właściwości do pobrania silnie typizowaną kolekcją, która obsługuje interfejs kolekcji i jest prawdopodobnie bardziej użyteczne niż moduł wyliczający.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChildren">
      <MemberSignature Language="C#" Value="public static System.Collections.IEnumerable GetChildren (System.Windows.FrameworkContentElement current);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IEnumerable GetChildren(class System.Windows.FrameworkContentElement current) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.LogicalTreeHelper.GetChildren(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetChildren (current As FrameworkContentElement) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IEnumerable ^ GetChildren(System::Windows::FrameworkContentElement ^ current);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="current" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="current">Obiekt, z którego chcesz uruchomić przetwarzania drzewa logicznego.</param>
        <summary>Zwraca kolekcję obiektów podrzędnych natychmiastowego określonego <see cref="T:System.Windows.FrameworkContentElement" /> przez przetwarzanie drzewa logicznego.</summary>
        <returns>Wyliczalny kolekcji obiektów podrzędnych natychmiastowego od <paramref name="current" /> w drzewie logicznym.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChildren">
      <MemberSignature Language="C#" Value="public static System.Collections.IEnumerable GetChildren (System.Windows.FrameworkElement current);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IEnumerable GetChildren(class System.Windows.FrameworkElement current) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.LogicalTreeHelper.GetChildren(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetChildren (current As FrameworkElement) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IEnumerable ^ GetChildren(System::Windows::FrameworkElement ^ current);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="current" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="current">Obiekt, z którego chcesz uruchomić przetwarzania drzewa logicznego.</param>
        <summary>Zwraca kolekcję obiektów podrzędnych natychmiastowego określonego <see cref="T:System.Windows.FrameworkElement" /> przez przetwarzanie drzewa logicznego.</summary>
        <returns>Wyliczalny kolekcji obiektów podrzędnych natychmiastowego od <paramref name="current" /> w drzewie logicznym.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParent">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject GetParent (System.Windows.DependencyObject current);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject GetParent(class System.Windows.DependencyObject current) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.LogicalTreeHelper.GetParent(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetParent (current As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyObject ^ GetParent(System::Windows::DependencyObject ^ current);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="current" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="current">Można odnaleźć obiektu nadrzędnego dla obiekt. Ma to być albo <see cref="T:System.Windows.FrameworkElement" /> lub <see cref="T:System.Windows.FrameworkContentElement" />.</param>
        <summary>Zwraca obiekt nadrzędny określonego obiektu przez przetwarzanie drzewa logicznego.</summary>
        <returns>Żądana nadrzędnego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest jedynie otoka, który pobiera wersję odpowiedniego typu (<xref:System.Windows.FrameworkElement> lub <xref:System.Windows.FrameworkContentElement>) z <xref:System.Windows.FrameworkElement.Parent%2A?displayProperty=nameWithType> lub <xref:System.Windows.FrameworkContentElement.Parent%2A?displayProperty=nameWithType> właściwości; chyba że nie można określić `current` typu, warto sprawdzić odpowiednie Zamiast tego wystąpienia właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="CoerceValueCallback" FullName="System.Windows.CoerceValueCallback">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bc1a383fe21e6b9b549e0ccda7aa8c21c6f92d9f" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37493666" />
  </Metadata>
  <TypeSignature Language="C#" Value="public delegate object CoerceValueCallback(DependencyObject d, object baseValue);" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed CoerceValueCallback extends System.MulticastDelegate" />
  <TypeSignature Language="DocId" Value="T:System.Windows.CoerceValueCallback" />
  <TypeSignature Language="VB.NET" Value="Public Delegate Function CoerceValueCallback(d As DependencyObject, baseValue As Object) As Object " />
  <TypeSignature Language="C++ CLI" Value="public delegate System::Object ^ CoerceValueCallback(DependencyObject ^ d, System::Object ^ baseValue);" />
  <TypeSignature Language="F#" Value="type CoerceValueCallback = delegate of DependencyObject * obj -&gt; obj" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Delegate</BaseTypeName>
  </Base>
  <Parameters>
    <Parameter Name="d" Type="System.Windows.DependencyObject" />
    <Parameter Name="baseValue" Type="System.Object" />
  </Parameters>
  <ReturnValue>
    <ReturnType>System.Object</ReturnType>
  </ReturnValue>
  <Docs>
    <param name="d">
      <span data-ttu-id="613f1-101">Obiekt, który na istnieje właściwość.</span>
      <span class="sxs-lookup">
        <span data-stu-id="613f1-101">The object that the property exists on.</span>
      </span>
      <span data-ttu-id="613f1-102">Po wywołaniu zwrotnym tę wartość przekazuje system właściwości.</span>
      <span class="sxs-lookup">
        <span data-stu-id="613f1-102">When the callback is invoked, the property system will pass this value.</span>
      </span>
    </param>
    <param name="baseValue">
      <span data-ttu-id="613f1-103">Nowa wartość właściwości, przed każda próba wymuszenia.</span>
      <span class="sxs-lookup">
        <span data-stu-id="613f1-103">The new value of the property, prior to any coercion attempt.</span>
      </span>
    </param>
    <summary>
      <span data-ttu-id="613f1-104">Zawiera szablon dla metody, która jest wywoływana zawsze wtedy, gdy trwa ponowne obliczanie wartości właściwości zależności lub wymuszenia specjalnie żądania.</span>
      <span class="sxs-lookup">
        <span data-stu-id="613f1-104">Provides a template for a method that is called whenever a dependency property value is being re-evaluated, or coercion is specifically requested.</span>
      </span>
    </summary>
    <returns>
      <span data-ttu-id="613f1-105">Wartość coerced (przy użyciu odpowiedniego typu).</span>
      <span class="sxs-lookup">
        <span data-stu-id="613f1-105">The coerced value (with appropriate type).</span>
      </span>
    </returns>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="613f1-106">Na podstawie wywołań zwrotnych <xref:System.Windows.CoerceValueCallback> mogą być przypisane do właściwości zależności za pomocą kilku różnych technik.</span><span class="sxs-lookup"><span data-stu-id="613f1-106">Callbacks based on <xref:System.Windows.CoerceValueCallback> can be assigned to a dependency property through several different techniques.</span></span> <span data-ttu-id="613f1-107">Każdy z tych metod wymaga, należy najpierw utworzyć nowy obiekt metadanych właściwości (<xref:System.Windows.PropertyMetadata>, lub klasy pochodnej, takie jak <xref:System.Windows.FrameworkPropertyMetadata>).</span><span class="sxs-lookup"><span data-stu-id="613f1-107">Each of these techniques requires that you first create a new property metadata object (<xref:System.Windows.PropertyMetadata>, or a derived class such as <xref:System.Windows.FrameworkPropertyMetadata>).</span></span> <span data-ttu-id="613f1-108">Tworzenie obiektu metadanych przy użyciu sygnatury konstruktora, który przyjmuje `coerceValueCallback` parametru i Przypisz ten parametr do programu obsługi wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="613f1-108">Create the metadata object using a constructor signature that takes the `coerceValueCallback` parameter, and assign that parameter to your callback handler.</span></span> <span data-ttu-id="613f1-109">Lub konstrukcji metadanych podpisu, a zestaw <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> właściwości przed umieszczania metadanych w użyciu.</span><span class="sxs-lookup"><span data-stu-id="613f1-109">Or construct the metadata by any signature and set the <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> property prior to putting the metadata in use.</span></span>  
  
 <span data-ttu-id="613f1-110">W przypadku takich metadanych, możesz wykonywać następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="613f1-110">When you have this metadata, you can:</span></span>  
  
-   <span data-ttu-id="613f1-111">Zdefiniować nową właściwość zależności dla nowej klasy, przy użyciu albo podpis <xref:System.Windows.DependencyProperty.Register%2A>, dzięki czemu metadanych jako `typeMetadata` wartość.</span><span class="sxs-lookup"><span data-stu-id="613f1-111">Define a new dependency property on a new class, using either signature of  <xref:System.Windows.DependencyProperty.Register%2A>, giving the metadata as the `typeMetadata` value.</span></span>  
  
-   <span data-ttu-id="613f1-112">Zastąp metadane (Wywołaj <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>) dla istniejącej właściwości zależności, po utworzeniu klasy pochodnej z klasy, która jest właścicielem właściwość zależności.</span><span class="sxs-lookup"><span data-stu-id="613f1-112">Override the metadata (call <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>) for an existing dependency property, when you derive from the class that owns the dependency property.</span></span>  
  
-   <span data-ttu-id="613f1-113">Dodaj istniejącą właściwość zależności na nową <xref:System.Windows.DependencyObject> klasy przy użyciu nowych metadanych, wywołując <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>.</span><span class="sxs-lookup"><span data-stu-id="613f1-113">Add an existing dependency property to a new <xref:System.Windows.DependencyObject> class, using new metadata, by calling <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>.</span></span>  
  
 <span data-ttu-id="613f1-114">Implementacje to wywołanie zwrotne zaewidencjonować wartość `baseValue` i określić na podstawie wartości lub typem czy jest to wartość, która musi zostać dodatkowo przekształcone.</span><span class="sxs-lookup"><span data-stu-id="613f1-114">Implementations of this callback should check the value in `baseValue` and determine based on either the value or the type whether this is a value that needs to be further coerced.</span></span>  
  
 <span data-ttu-id="613f1-115"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> Zależność właściwości jest wywoływana za każdym razem system właściwości lub dowolny obiekt wywołujący wywołuje <xref:System.Windows.DependencyObject.CoerceValue%2A> na <xref:System.Windows.DependencyObject> wystąpienie określający identyfikator tę właściwość jako `dp`.</span><span class="sxs-lookup"><span data-stu-id="613f1-115">The <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> for a dependency property is invoked any time that the property system or any other caller calls <xref:System.Windows.DependencyObject.CoerceValue%2A> on a <xref:System.Windows.DependencyObject> instance, specifying that property's identifier as the `dp`.</span></span>  
  
 <span data-ttu-id="613f1-116">Zmiana wartości właściwości może pochodzić z każdy uczestnik możliwe w systemie właściwości.</span><span class="sxs-lookup"><span data-stu-id="613f1-116">Changes to the property value may have come from any possible participant in the property system.</span></span> <span data-ttu-id="613f1-117">Obejmuje to style, ogólny unieważniania, wyzwalacze, dziedziczenie wartości właściwości i ustawienie wartości lokalnej.</span><span class="sxs-lookup"><span data-stu-id="613f1-117">This includes styles, generic invalidation, triggers, property value inheritance, and local value setting.</span></span>  
  
 <span data-ttu-id="613f1-118">Ogólnie należy unikać określenie więcej niż jedną <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> dla dowolnej podanej właściwości zależności (zastępowanie lub dodawanie o nowe metadane dla właściwości zależności, który był już <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>).</span><span class="sxs-lookup"><span data-stu-id="613f1-118">Generally you should avoid specifying more than one <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> for any given dependency property (overriding or adding with new metadata for a dependency property that already had a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>).</span></span> <span data-ttu-id="613f1-119">Tylko jedno z wywołań zwrotnych będą działać. Wywołanie zwrotne acting będzie jedną, która została zastosowana do najbardziej pochodnej klasy w dziedziczeniu w porównaniu z <xref:System.Windows.DependencyObject> obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="613f1-119">Only one of the callbacks will be able to act. The acting callback will be the one that was applied to the most derived class in the inheritance as compared to the <xref:System.Windows.DependencyObject> caller.</span></span> <span data-ttu-id="613f1-120">Inne wywołania zwrotne przypisane metadane dla właściwości zależności wyższej znajdowały się w hierarchii właściciel jest zastępowany w przypadku metadanych jest zastępowany.</span><span class="sxs-lookup"><span data-stu-id="613f1-120">Other callbacks as assigned to metadata for the dependency property as it existed higher in the owner hierarchy are replaced when the metadata is overridden.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="613f1-121">Poniższy przykład zawiera implementację wymuszone przechowywana wartość właściwości zależności oparte na pozostałych danych wejściowych, takie jak wartości innej właściwości tego wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="613f1-121">The following example includes an implementation of this callback to coerce the stored value of a dependency property based on other inputs, such as another property's value.</span></span> <span data-ttu-id="613f1-122">W takim przypadku wywołanie zwrotne sprawdza, czy `ShirtType` właściwość odnosi się do typu koszulka, który zawiera przyciski; sytuacji nawiązaniem początkowy domyślny kolor dla `ButtonColor`, jeśli typ koszuli nie ma żadnych przycisków, jego przekształca wynik dane `ButtonColor` wartość Powrót do wartości początkowej, co powoduje, że [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] (niewyświetlany) do usuwania tej listy rozwijanej Opcje skuteczne.</span><span class="sxs-lookup"><span data-stu-id="613f1-122">In this case, the callback checks to see whether the `ShirtType` property corresponds to a type of shirt that has buttons; if so it establishes a starting default color for the `ButtonColor`, if the shirt type has no buttons, it coerces the `ButtonColor` value back to a starting value, which causes the [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] (not shown) to remove that dropdown from the effective choices.</span></span>  
  
 [!code-csharp[DPCustom#CoerceValueCallback](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCustom/CSharp/default.xaml.cs#coercevaluecallback)]
 [!code-vb[DPCustom#CoerceValueCallback](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCustom/visualbasic/default.xaml.vb#coercevaluecallback)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
</Type>
<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="50e37bc8286c8ba1961d7a1c298161a3c9e3100c" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/24/2018" />
    <Meta Name="ms.locfileid" Value="37492941" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <TypeSignature Language="F#" Value="type FrameworkPropertyMetadata = class&#xA;    inherit UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Raporty lub stosuje metadane dla właściwości zależności, specjalnie dodanie właściwości właściwości określonej platformy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa jest pochodną <xref:System.Windows.PropertyMetadata> (za pośrednictwem <xref:System.Windows.UIPropertyMetadata>). W większości przypadków rozwoju poziomie struktury aplikacji WPF <xref:System.Windows.FrameworkPropertyMetadata> jest typ używany do metadane zależności właściwości, a nie typy podstawowej metadanych <xref:System.Windows.PropertyMetadata> lub <xref:System.Windows.UIPropertyMetadata>. Dotyczy to zarówno istniejących właściwości zależności, jak i w większości przypadków właściwość zależności niestandardowej.  
  
 Elementów członkowskich zadeklarowanych to klasy tego dodatku <xref:System.Windows.PropertyMetadata> klasy bazowej obejmują różne właściwości logiczna określić lub zachowanie systemu właściwości na poziomie struktury WPF, takie jak dziedziczenie właściwości, powiązań danych i układ raportu.  
  
 Wiele podpisów Konstruktor do tworzenia <xref:System.Windows.FrameworkPropertyMetadata> take wystąpienia <xref:System.Windows.FrameworkPropertyMetadataOptions> parametru. <xref:System.Windows.FrameworkPropertyMetadataOptions> Wyliczenie służy tylko do określenia początkowe zachowanie w konstruktorze, a w przeciwnym razie nie jest widoczne po <xref:System.Windows.FrameworkPropertyMetadata> jest konstruowany. Z wystąpienia skonstruowany można uzyskać lub ustawić odpowiednie informacje przy użyciu różnych właściwości, które mają taką nazwę wartości wyliczenia używane w wywołaniu konstruktora.  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Ta klasa nie jest zazwyczaj używany w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Poniższy przykład pobiera metadane dla właściwości zależności na określoną właściciela jako początkowej podstawowy <xref:System.Windows.PropertyMetadata> typu. Metadane są rzutowane na <xref:System.Windows.FrameworkPropertyMetadata>. Jeśli rzutowanie zwrócił nieprawidłowy <xref:System.Windows.FrameworkPropertyMetadata>, a następnie różnych <xref:System.Windows.FrameworkPropertyMetadata> są zgłaszane wartości właściwości, za pomocą prostego interfejsu użytkownika (niewyświetlany).  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy.</summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta sygnatura inicjuje wszystkie wartości <xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A> domyślne właściwości. <xref:System.Windows.PropertyMetadata.DefaultValue%2A> będzie `null`i różnych <xref:System.Windows.FrameworkPropertyMetadata> będzie właściwości logiczne `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zwykle podane jako wartość określonego typu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy z określoną wartość domyślną.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości parametru `defaultValue` musi odpowiadać lub być one związane z typem określonym w oryginalnej rejestrację właściwości zależności, które te metadane zostaną zastosowane do. Niezgodności między metadanych domyślny typ wartości i typ właściwości zależności, które są stosowane do może być trudne do debugowania, ponieważ ta niezgodność występuje wykrywalny podczas kompilacji. System właściwości nie może oszacować efektywne wartości właściwości do czasu wykonywania, więc wynik niezgodność typów typu/właściwości wartość domyślna to błąd czasu wykonywania.  
  
 Wartość <xref:System.Windows.DependencyProperty.UnsetValue> ma specjalne znaczenie w systemie właściwości i nie można użyć jako wartości domyślnej właściwości zależności.  
  
   
  
## Examples  
 Poniższy przykład wywołuje ten podpis konstruktora:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> ustawiono <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, który system właściwości będzie wybierany w każdym przypadku, gdy zmienia się od wartości właściwości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy z określonym <see cref="T:System.Windows.PropertyChangedCallback" /> wywołania zwrotnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład wywołuje ten podpis konstruktora:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zwykle podane jako wartość określonego typu.</param>
        <param name="flags">Flagi opcji metadane (kombinację <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> wartości). Te opcje określają właściwości właściwości zależności, które współdziałają z systemów takich jak układ i powiązanie danych.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy przy użyciu wartości domyślnej podana i opcje metadanych na poziomie framework.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości parametru `defaultValue` musi odpowiadać lub być one związane z typem określonym w oryginalnej rejestrację właściwości zależności, które te metadane zostaną zastosowane do. Niezgodności między metadanych domyślny typ wartości i typ właściwości zależności, które są stosowane do może być trudne do debugowania, ponieważ ta niezgodność występuje wykrywalny podczas kompilacji. System właściwości nie może oszacować efektywne wartości właściwości do czasu wykonywania, więc wynik niezgodność typów typu/właściwości wartość domyślna to błąd czasu wykonywania.  
  
 Wartość <xref:System.Windows.DependencyProperty.UnsetValue> ma specjalne znaczenie w systemie właściwości i nie można użyć jako wartości domyślnej właściwości zależności.  
  
 Wartości oznaczone jako zestaw flag `flags` parametr zostanie ustawiony na wartość logiczną <xref:System.Windows.FrameworkPropertyMetadata> właściwości, które odpowiadają, które <xref:System.Windows.FrameworkPropertyMetadataOptions> Nazwa flagi do `true`. Następnie można zmienić wartości właściwości w metadanych, tak długo, jak metadanych nie została jeszcze zastosowana dla działania systemu określoną właściwość.  
  
   
  
## Examples  
 Poniższy przykład wywołuje ten podpis konstruktora:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> ustawiono <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zwykle podane jako wartość określonego typu.</param>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, który system właściwości będzie wybierany w każdym przypadku, gdy zmienia się od wartości właściwości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy z wartością domyślną podana i określić <see cref="T:System.Windows.PropertyChangedCallback" /> wywołania zwrotnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości parametru `defaultValue` musi odpowiadać lub być one związane z typem określonym w oryginalnej rejestrację właściwości zależności, które te metadane zostaną zastosowane do. Niezgodności między metadanych domyślny typ wartości i typ właściwości zależności, które są stosowane do może być trudne do debugowania, ponieważ ta niezgodność występuje wykrywalny podczas kompilacji. System właściwości nie może oszacować efektywne wartości właściwości do czasu wykonywania, więc wynik niezgodność typów typu/właściwości wartość domyślna to błąd czasu wykonywania.  
  
 Wartość <xref:System.Windows.DependencyProperty.UnsetValue> ma specjalne znaczenie w systemie właściwości i nie można użyć jako wartości domyślnej właściwości zależności.  
  
   
  
## Examples  
 Poniższy przykład wywołuje ten podpis konstruktora:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> ustawiono <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, który system właściwości będzie wybierany w każdym przypadku, gdy zmienia się od wartości właściwości.</param>
        <param name="coerceValueCallback">Odwołanie do implementacji programu obsługi będzie wywoływana zawsze wtedy, gdy system właściwość wywołuje <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> dla tej właściwości zależności.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy przy użyciu określonego wywołania zwrotne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja wywołuje inicjatora bazowej, a następnie dodaje `coerceValueCallback` przez ustawienie właściwości wystąpienia podstawowego.  
  
   
  
## Examples  
 Poniższy przykład wywołuje ten podpis konstruktora:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zwykle podane jako wartość określonego typu.</param>
        <param name="flags">Flagi opcji metadane (kombinację <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> wartości). Te opcje określają właściwości właściwości zależności, które współdziałają z systemów takich jak układ i powiązanie danych.</param>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, który system właściwości będzie wybierany w każdym przypadku, gdy zmienia się od wartości właściwości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy z opcjami domyślnymi podana wartość i struktury metadanych, a określone <see cref="T:System.Windows.PropertyChangedCallback" /> wywołania zwrotnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości parametru `defaultValue` musi odpowiadać lub być one związane z typem określonym w oryginalnej rejestrację właściwości zależności, które te metadane zostaną zastosowane do. Niezgodności między metadanych domyślny typ wartości i typ właściwości zależności, które są stosowane do może być trudne do debugowania, ponieważ ta niezgodność występuje wykrywalny podczas kompilacji. System właściwości nie może oszacować efektywne wartości właściwości do czasu wykonywania, więc wynik niezgodność typów typu/właściwości wartość domyślna to błąd czasu wykonywania.  
  
 Wartość <xref:System.Windows.DependencyProperty.UnsetValue> ma specjalne znaczenie w systemie właściwości i nie można użyć jako wartości domyślnej właściwości zależności.  
  
 Wartości oznaczone jako zestaw flag `flags` parametr zostanie ustawiony na wartość logiczną <xref:System.Windows.FrameworkPropertyMetadata> właściwości, które odpowiadają, które <xref:System.Windows.FrameworkPropertyMetadataOptions> Nazwa flagi do `true`. Nadal można zmienić wartości właściwości w metadanych, tak długo, jak metadanych nie została jeszcze zastosowana dla działania systemu określoną właściwość.  
  
   
  
## Examples  
 Poniższy przykład wywołuje ten podpis konstruktora:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> ustawiono <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zwykle są dostarczane jako określonego typu.</param>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, który system właściwości będzie wybierany w każdym przypadku, gdy zmienia się od wartości właściwości.</param>
        <param name="coerceValueCallback">Odwołanie do implementacji programu obsługi, która będzie wywoływana zawsze wtedy, gdy system właściwość wywołuje <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> dla tej właściwości zależności.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy przy użyciu wartości domyślnej podana i określonego wywołania zwrotne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości parametru `defaultValue` musi odpowiadać lub być one związane z typem określonym w oryginalnej rejestrację właściwości zależności, które te metadane zostaną zastosowane do. Niezgodności między metadanych domyślny typ wartości i typ właściwości zależności, które są stosowane do może być trudne do debugowania, ponieważ ta niezgodność występuje wykrywalny podczas kompilacji. System właściwości nie może oszacować efektywne wartości właściwości do czasu wykonywania, więc wynik niezgodność typów typu/właściwości wartość domyślna to błąd czasu wykonywania.  
  
 Wartość <xref:System.Windows.DependencyProperty.UnsetValue> ma specjalne znaczenie w systemie właściwości i nie można użyć jako wartości domyślnej właściwości zależności.  
  
   
  
## Examples  
 Poniższy przykład wywołuje ten podpis konstruktora:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> ustawiono <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zwykle są dostarczane jako określonego typu.</param>
        <param name="flags">Flagi opcji metadane (kombinację <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> wartości). Te opcje określają właściwości właściwości zależności, które współdziałają z systemów takich jak układ i powiązanie danych.</param>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, który system właściwości będzie wybierany w każdym przypadku, gdy zmienia się od wartości właściwości.</param>
        <param name="coerceValueCallback">Odwołanie do implementacji programu obsługi, która będzie wywoływana zawsze wtedy, gdy system właściwość wywołuje <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> względem tej właściwości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy z podanej wartości domyślnej i opcje metadane struktury i określonego wywołania zwrotne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości parametru `defaultValue` musi odpowiadać lub być one związane z typem określonym w oryginalnej rejestrację właściwości zależności, które te metadane zostaną zastosowane do. Niezgodności między metadanych domyślny typ wartości i typ właściwości zależności, które są stosowane do może być trudne do debugowania, ponieważ ta niezgodność występuje wykrywalny podczas kompilacji. System właściwości nie może oszacować efektywne wartości właściwości do czasu wykonywania, więc wynik niezgodność typów typu/właściwości wartość domyślna to błąd czasu wykonywania.  
  
 Wartość <xref:System.Windows.DependencyProperty.UnsetValue> ma specjalne znaczenie w systemie właściwości i nie można użyć jako wartości domyślnej właściwości zależności.  
  
 Wartości oznaczone jako zestaw flag `flags` parametr zostanie ustawiony na wartość logiczną <xref:System.Windows.FrameworkPropertyMetadata> właściwości, które odpowiadają, które <xref:System.Windows.FrameworkPropertyMetadataOptions> Nazwa flagi do `true`. Nadal można zmienić wartości właściwości w metadanych, tak długo, jak metadanych nie została jeszcze zastosowana dla działania systemu określoną właściwość.  
  
   
  
## Examples  
 Poniższy przykład wywołuje ten podpis konstruktora:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> ustawiono <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zwykle są dostarczane jako określonego typu.</param>
        <param name="flags">Flagi opcji metadane (kombinację <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> wartości). Te opcje określają właściwości właściwości zależności, które współdziałają z systemów takich jak układ i powiązanie danych.</param>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, który system właściwości będzie wybierany w każdym przypadku, gdy zmienia się od wartości właściwości.</param>
        <param name="coerceValueCallback">Odwołanie do implementacji programu obsługi, która będzie wywoływana zawsze wtedy, gdy system właściwość wywołuje <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> dla tej właściwości zależności.</param>
        <param name="isAnimationProhibited">
          <see langword="true" /> Aby zapobiec animowanie właściwość, która te metadane są stosowane do systemu właściwości. Takie właściwości zgłosi wyjątek czasu wykonywania, pochodzące z systemu właściwości, jeśli animacji z nich są próby. <see langword="false" /> Aby zezwolić na animowanie właściwości. Wartość domyślna to <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasie z atrybutem opcje domyślne podana wartość i struktury metadanych, określonego wywołania zwrotne i atrybut typu wartość logiczna, która może służyć do uniemożliwić animacji właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości parametru `defaultValue` musi odpowiadać lub być one związane z typem określonym w oryginalnej rejestrację właściwości zależności, które te metadane zostaną zastosowane do. Niezgodności między metadanych domyślny typ wartości i typ właściwości zależności, które są stosowane do może być trudne do debugowania, ponieważ ta niezgodność występuje wykrywalny podczas kompilacji. System właściwości nie może oszacować efektywne wartości właściwości do czasu wykonywania, więc wynik niezgodność typów typu/właściwości wartość domyślna to błąd czasu wykonywania.  
  
 Wartość <xref:System.Windows.DependencyProperty.UnsetValue> ma specjalne znaczenie w systemie właściwości i nie można użyć jako wartości domyślnej właściwości zależności.  
  
 `isAnimationProhibited` Parametr ustawia wartość początkową <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> właściwość deklarowana przez natychmiastowe base <xref:System.Windows.UIPropertyMetadata> klasy.  
  
 Wartości oznaczone jako zestaw flag `flags` parametr zostanie ustawiony na wartość logiczną <xref:System.Windows.FrameworkPropertyMetadata> właściwości, które odpowiadają, które <xref:System.Windows.FrameworkPropertyMetadataOptions> Nazwa flagi do `true`. Nadal można zmienić wartości właściwości w metadanych, tak długo, jak metadanych nie została jeszcze zastosowana dla działania systemu określoną właściwość.  
  
   
  
## Examples  
 Poniższy przykład wywołuje ten podpis konstruktora:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> ustawiono <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool * System.Windows.Data.UpdateSourceTrigger -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited, defaultUpdateSourceTrigger)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zwykle są dostarczane jako określonego typu.</param>
        <param name="flags">Flagi opcji metadane (kombinację <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> wartości). Te opcje określają właściwości właściwości zależności, które współdziałają z systemów takich jak układ i powiązanie danych.</param>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, który system właściwości będzie wybierany w każdym przypadku, gdy zmienia się od wartości właściwości.</param>
        <param name="coerceValueCallback">Odwołanie do implementacji programu obsługi, która będzie wywoływana zawsze wtedy, gdy system właściwość wywołuje <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> względem tej właściwości.</param>
        <param name="isAnimationProhibited">
          <see langword="true" /> Aby zapobiec animowanie właściwość, która te metadane są stosowane do systemu właściwości. Takie właściwości zgłosi wyjątek czasu wykonywania, pochodzące z systemu właściwości, jeśli animacji z nich są próby. Wartość domyślna to <see langword="false" />.</param>
        <param name="defaultUpdateSourceTrigger">
          <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> Do użycia po zastosowaniu powiązania dla tej właściwości, które mają ich <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> równa <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy przy użyciu podanego domyślne wartości i framework metadanych opcji określonego wywołania zwrotne, atrybut typu wartość logiczna, która może służyć do uniemożliwić animacji właściwości i domyślny wyzwalacz aktualizacji powiązanie danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości parametru `defaultValue` musi odpowiadać lub być one związane z typem określonym w oryginalnej rejestrację właściwości zależności, które te metadane zostaną zastosowane do. Niezgodności między metadanych domyślny typ wartości i typ właściwości zależności, które są stosowane do może być trudne do debugowania, ponieważ ta niezgodność występuje wykrywalny podczas kompilacji. System właściwości nie może oszacować efektywne wartości właściwości do czasu wykonywania, więc wynik niezgodność typów typu/właściwości wartość domyślna to błąd czasu wykonywania.  
  
 Wartość <xref:System.Windows.DependencyProperty.UnsetValue> ma specjalne znaczenie w systemie właściwości i nie można użyć jako wartości domyślnej właściwości zależności.  
  
 `isAnimationProhibited` Parametr ustawia wartość początkową <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> właściwość deklarowana przez natychmiastowe base <xref:System.Windows.UIPropertyMetadata> klasy.  
  
 Aby uzyskać więcej informacji o zachowaniu źródło aktualizacji dla powiązań, zobacz [Przegląd wiązanie danych](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 Wartości oznaczone jako zestaw flag `flags` parametr zostanie ustawiony na wartość logiczną <xref:System.Windows.FrameworkPropertyMetadata> właściwości, które odpowiadają, które <xref:System.Windows.FrameworkPropertyMetadataOptions> Nazwa flagi do `true`. Nadal można zmienić wartości właściwości w metadanych, tak długo, jak metadanych nie została jeszcze zastosowana dla działania systemu określoną właściwość.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> ustawiono <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy właściwość zależności może mieć wpływ na przebieg Rozmieść podczas operacji aparatu układu.</summary>
        <value>
          <see langword="true" /> Jeśli właściwość zależności, w którym te metadane istnieje potencjalnie ma wpływ na przebieg Rozmieść; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> i <xref:System.Windows.FrameworkContentElement> zawierać implementację <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> monitorująca efektywną wartość zmiany do wszystkich właściwości zależności, które istnieją w elemencie. W ramach tej logiki, właściwości zależności, które zmieniają zacznie obowiązywać od wartości i ma metadanych z <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> równa `true` zainicjuje odroczonego żądanie unieważnienia wizualizacji dla tego elementu (wywołanie <xref:System.Windows.UIElement.InvalidateArrange%2A>). Ponieważ ta implementacja poziomie struktury WPF jest już w miejscu, zazwyczaj nie należy do wyszukania właściwości zależności za pomocą <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> chyba że znacznie zastępowanie lub modyfikowanie zachowania poziomie struktury układu WPF.  
  
 Niestandardowe <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementacje warto zachowują się podobnie dla zmiany właściwości zależności gdzie <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> jest `true`.  
  
 Właściwości klasy pochodne <xref:System.Windows.PropertyMetadata> zwykle są zdefiniowane w modelu obiektu jako odczytu i zapisu. Jest to, dzięki czemu można je dostosować po zainicjowaniu wystąpienia. Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości zostanie zapieczętowania to wystąpienie metadanych i właściwości, które obejmują szczegółowe informacje na temat metadanych teraz jest uważany za niezmienialny. Trwa próba skonfigurowania tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są to zazwyczaj nie używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Poniższy przykład uzyskuje dostęp do metadanych domyślne z różnych zależności pola właściwości, odpytuje wartości różnych <xref:System.Windows.FrameworkPropertyMetadata> właściwości, a informacje są używane do wypełniania tabeli, aby zaimplementować "Przeglądarka metadanych".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane już zastosowano do operacji właściwości zależności, tak aby metadanych jest zapieczętowany i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy właściwość zależności może mieć wpływ na miary — dostęp próbny podczas operacji aparatu układu.</summary>
        <value>
          <see langword="true" /> Jeśli właściwość zależności, w którym te metadane istnieje potencjalnie wpływa na miarę — dostęp próbny; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> i <xref:System.Windows.FrameworkContentElement> zawierać implementację <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> monitorująca efektywną wartość zmiany do wszystkich właściwości zależności, które istnieją w elemencie. W ramach tej logiki, właściwości zależności, które zmieniają zacznie obowiązywać od wartości i ma metadanych z <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> równa `true` zainicjuje odroczonego żądanie unieważnienia wizualizacji dla tego elementu. Ponieważ ta implementacja poziomie struktury WPF jest już w miejscu, zazwyczaj nie należy do wyszukania właściwości zależności za pomocą <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> chyba że znacznie zastępowanie lub modyfikowanie zachowania poziomie struktury układu WPF.  
  
 Niestandardowe <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementacje warto zachowują się podobnie dla zmiany właściwości zależności gdzie <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> jest `true`.  
  
 Właściwości klasy pochodne <xref:System.Windows.PropertyMetadata> zwykle są zdefiniowane w modelu obiektu jako odczytu i zapisu. Jest to, dzięki czemu można je dostosować po zainicjowaniu wystąpienia. Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości zostanie zapieczętowania to wystąpienie metadanych i właściwości, które obejmują szczegółowe informacje na temat metadanych teraz jest uważany za niezmienialny. Trwa próba skonfigurowania tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Poniższy przykład uzyskuje dostęp do metadanych domyślne z różnych zależności pola właściwości, odpytuje wartości różnych <xref:System.Windows.FrameworkPropertyMetadata> właściwości, a informacje są używane do wypełniania tabeli, aby zaimplementować "Przeglądarka metadanych".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane już zastosowano do operacji właściwości zależności, tak aby metadanych jest zapieczętowany i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy właściwość zależności może mieć wpływ na przebieg rozmieszczanie układu z elementem nadrzędnym elementu podczas operacji aparatu układu.</summary>
        <value>
          <see langword="true" /> Jeśli właściwość zależności, w którym te metadane istnieje potencjalnie ma wpływ na przebieg Rozmieść szczegółowe informacje dotyczące odpowiedniego elementu nadrzędnego; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> i <xref:System.Windows.FrameworkContentElement> zawierać implementację <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> monitorująca efektywną wartość zmiany do wszystkich właściwości zależności, które istnieją w elemencie. W ramach tej logiki, właściwości zależności, które zmieniają zacznie obowiązywać od wartości i ma metadanych z <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> równa `true` zainicjuje odroczonego żądanie unieważnienia wizualizacji dla elementu nadrzędnego.  
  
 Ogólnie rzecz biorąc, nie trzeba zmiany w raporcie <xref:System.Windows.FrameworkElement> właściwości elementu nadrzędnego za pomocą <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> ponieważ sam element będzie już mieć własny <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> jako `true`. Zwykle wystarczające, ponieważ zmiany w elemencie podrzędnym ogólnie inicjuje element nadrzędny Rozmieść w odpowiednich przypadkach. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> Czasami służy <xref:System.Windows.FrameworkContentElement> klasy pochodnej. W tym przypadku element podrzędne zestawy, a właściwość, ale w <xref:System.Windows.FrameworkContentElement> klasy pochodnej nie jest kontrolowane przez własny renderowania. Renderowanie jest obsługiwany przez <xref:System.Windows.FrameworkElement> elementu nadrzędnego, który służy jako host zawartości. Na przykład zmień wartość <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> unieważnia dołączonej właściwości przez element podrzędny Rozmieść obiektu nadrzędnego, ponieważ musi zostać zmieniona pozycja elementu podrzędnego w obiekcie nadrzędnym. W związku z tym <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> dołączoną właściwość ma metadane gdzie <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> jest `true`. Innym przykładem jest <xref:System.Windows.Controls.Control.Padding%2A>; po tej zmiany właściwości nadrzędnego może zmienić położenie podrzędne, w zależności od dostępnego miejsca.  
  
 Ponieważ ta implementacja poziomie struktury WPF jest już w miejscu, zazwyczaj nie należy do wyszukania właściwości zależności za pomocą <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> chyba że znacznie zastępowanie lub modyfikowanie zachowania poziomie struktury układu WPF.  
  
 Niestandardowe <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementacje warto zachowują się podobnie dla zmiany właściwości zależności gdzie <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> jest `true`.  
  
 Właściwości w dowolnej pochodne klasy <xref:System.Windows.PropertyMetadata> zwykle są zdefiniowane w modelu obiektu jako odczytu i zapisu. Jest to, dzięki czemu można je dostosować po zainicjowaniu wystąpienia. Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości zostanie zapieczętowania to wystąpienie metadanych i właściwości, które obejmują szczegółowe informacje na temat metadanych teraz jest uważany za niezmienialny. Trwa próba skonfigurowania tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane już zastosowano do operacji właściwości zależności, tak aby metadanych jest zapieczętowany i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy właściwość zależności może mieć wpływ na przebieg miary układu z elementem nadrzędnym elementu podczas operacji aparatu układu.</summary>
        <value>
          <see langword="true" /> Jeśli właściwość zależności, w którym te metadane istnieje potencjalnie ma wpływ na przebieg miary w dalszej części przedstawiono elementem nadrzędnym elementu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> i <xref:System.Windows.FrameworkContentElement> zawierać implementację <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> monitorująca efektywną wartość zmiany do wszystkich właściwości zależności, które istnieją w elemencie. W ramach tej logiki, właściwości zależności, które zmieniają zacznie obowiązywać od wartości i ma metadanych z <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> równa `true` zainicjuje odroczonego żądanie unieważnienia wizualizacji dla elementu nadrzędnego. Ponieważ ta implementacja poziomie struktury WPF jest już w miejscu, zazwyczaj nie należy do wyszukania właściwości zależności za pomocą <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> chyba że znacznie zastępowanie lub modyfikowanie zachowania poziomie struktury układu WPF.  
  
 Ogólnie rzecz biorąc, nie trzeba zmiany w raporcie <xref:System.Windows.FrameworkElement> właściwości elementu nadrzędnego za pomocą <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> ponieważ sam element będzie już mieć własny <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> jako `true`. Może to być zwykle wystarczające, ponieważ zmiany w elemencie podrzędnym ogólnie inicjuje przebieg miary nadrzędnego w odpowiednich przypadkach. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> Czasami służy <xref:System.Windows.FrameworkContentElement> klasy pochodnej. W tym przypadku element podrzędne zestawy, a właściwość, ale w <xref:System.Windows.FrameworkContentElement> klasy pochodnej nie jest kontrolowane przez własny renderowania. Renderowanie jest obsługiwany przez <xref:System.Windows.FrameworkElement> elementu nadrzędnego, który służy jako host zawartości. Na przykład zmień wartość <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> właściwość, według elementu podrzędnego unieważnia miary obiektu nadrzędnego, ponieważ względne odstępy między akapitami może zmienić i może zwiększyć lub zmniejszyć rozmiar hosta zawartości. W związku z tym <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> właściwość ma metadanych gdzie <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> jest `true`.  
  
 Host zawartości elementów również często Szukaj zmian w właściwości zależności gdzie <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> jest `true`, jako część logiki renderowania hosta zawartości. Na przykład <xref:System.Windows.Controls.TextBox> element musi odpowiedzieć na pewne zmiany w tekście, który może wymagać, aby pole <xref:System.Windows.Controls.TextBox> sam można zmienić.  
  
 Niestandardowe <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementacje warto zachowują się podobnie dla zmiany właściwości zależności gdzie <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> jest `true`.  
  
 Właściwości w dowolnej pochodne klasy <xref:System.Windows.PropertyMetadata> zwykle są zdefiniowane w modelu obiektu jako odczytu i zapisu. Jest to, dzięki czemu można je dostosować po zainicjowaniu wystąpienia. Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości zostanie zapieczętowania to wystąpienie metadanych i właściwości, które obejmują szczegółowe informacje na temat metadanych teraz jest uważany za niezmienialny. Trwa próba skonfigurowania tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane już zastosowano do operacji właściwości zależności, tak aby metadanych jest zapieczętowany i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy właściwość zależności może mieć wpływ na ogólny układ w jakiś sposób wpływają na specjalnie rozmieszczenie lub miary, ale wymaga ponownego wystawienia.</summary>
        <value>
          <see langword="true" /> Jeśli właściwość zależności, na którym znajduje się te metadane wpływa na renderowanie; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> i <xref:System.Windows.FrameworkContentElement> zawierać implementację <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> monitorująca efektywną wartość zmiany do wszystkich właściwości zależności, które istnieją w elemencie. W ramach tej logiki, właściwości zależności, które zmieniają zacznie obowiązywać od wartości i ma metadanych z <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> równa `true` zainicjuje odroczonego żądanie unieważnienia wizualizacji dla tego elementu. Ponieważ ta implementacja poziomie struktury WPF jest już w miejscu, zazwyczaj nie należy do wyszukania właściwości zależności za pomocą <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> chyba że znacznie zastępowanie lub modyfikowanie zachowania poziomie struktury układu WPF.  
  
 Niestandardowe <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementacje warto zachowują się podobnie dla zmiany właściwości zależności gdzie <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> jest `true`.  
  
 Właściwości w dowolnej pochodne klasy <xref:System.Windows.PropertyMetadata> zwykle są zdefiniowane w modelu obiektu jako odczytu i zapisu. Jest to, dzięki czemu można je dostosować po zainicjowaniu wystąpienia. Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości zostanie zapieczętowania to wystąpienie metadanych i właściwości, które obejmują szczegółowe informacje na temat metadanych teraz jest uważany za niezmienialny. Trwa próba skonfigurowania tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Poniższy przykład uzyskuje dostęp do metadanych domyślne z różnych zależności pola właściwości, odpytuje wartości różnych <xref:System.Windows.FrameworkPropertyMetadata> właściwości, a informacje są używane do wypełniania tabeli, aby zaimplementować "Przeglądarka metadanych".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane już zastosowano do operacji właściwości zależności, tak aby metadanych jest zapieczętowany i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BindsTwoWayByDefault : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy właściwość powiązanie dwukierunkowe domyślnie.</summary>
        <value>
          <see langword="true" /> Jeśli właściwość zależności, na którym znajduje się te metadane powiązanie dwukierunkowe domyślnie; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku braku tej właściwości jest `true`, powiązanie aktualizacji są jednokierunkowe domyślnie w oparciu o zachowanie domyślne <xref:System.Windows.Data.Binding> konstruktorów lub równoważnej [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] składni.  
  
 Istniejące elementy zazwyczaj zawiera tę właściwość ustawioną na `true` metadanych dla właściwości zależności, zarówno raport stanu i są na przykład można modyfikować wyniku akcji użytkownika <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>.  
  
 Ta właściwość tylko domyślnych parametrów aktualizacji powiązania właściwości zależności ogólnie raportów. Wszystkie powiązania zestawu do tej właściwości w wystąpieniu lokalnie można ustawić <xref:System.Windows.Data.Binding.Mode%2A> właściwości powiązania i zmienić to ustawienie domyślne.  
  
 Właściwości w dowolnej pochodne klasy <xref:System.Windows.PropertyMetadata> zwykle są zdefiniowane w modelu obiektu jako odczytu i zapisu. Jest to, dzięki czemu można je dostosować po zainicjowaniu wystąpienia. Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości zostanie zapieczętowania to wystąpienie metadanych i właściwości, które obejmują szczegółowe informacje na temat metadanych teraz jest uważany za niezmienialny. Trwa próba skonfigurowania tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Poniższy przykład uzyskuje dostęp do metadanych domyślne z różnych zależności pola właściwości, odpytuje wartości różnych <xref:System.Windows.FrameworkPropertyMetadata> właściwości, a informacje są używane do wypełniania tabeli, aby zaimplementować "Przeglądarka metadanych".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane już zastosowano do operacji właściwości zależności, tak aby metadanych jest zapieczętowany i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultUpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia domyślną <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> można użyć, gdy są stosowane powiązania dla właściwości o tym metadanych, które mają ich <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> równa <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</summary>
        <value>Wartość wyliczenia inną niż <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości klasy pochodne <xref:System.Windows.PropertyMetadata> zwykle są zdefiniowane w modelu obiektu jako odczytu i zapisu. Jest to, dzięki czemu można je dostosować po zainicjowaniu wystąpienia. Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości zostanie zapieczętowania to wystąpienie metadanych i właściwości, które obejmują szczegółowe informacje na temat metadanych teraz jest uważany za niezmienialny. Trwa próba skonfigurowania tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ta właściwość jest ustawiona <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />; wartość ustawiona w powinien stać się domyślne powiązania na żądanie.</exception>
        <exception cref="T:System.InvalidOperationException">Metadane już zastosowano do operacji właściwości zależności, tak aby metadanych jest zapieczętowany i nie można ustawić właściwości metadanych.</exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Inherits : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy wartość właściwości zależności jest dziedziczone.</summary>
        <value>
          <see langword="true" /> Jeśli wartość właściwości jest dziedziczona; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dziedziczenie wartości właściwości jest funkcją [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] system właściwości na poziomie framework WPF, według której niektórych właściwości zależności lokalnie na można ustawić elementu po lub w pobliżu głównym [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] element drzewa, a następnie ich wartości dziedziczone przez wszystkie elementy w obrębie drzewa logicznego elementy podrzędne, które posiadają również tej właściwości. Dziedziczenie wartości właściwości nie jest domyślnie włączona i włączanie go mieć wpływ na wydajność. Aby uzyskać więcej informacji, zobacz [dziedziczenie wartości właściwości](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
> [!NOTE]
>  Mimo że dziedziczenie wartości właściwości może pojawić się działać w przypadku właściwości zależności nie dołączony, zachowanie dziedziczenia właściwości nie dołączony przez niektóre działy obiektu obiektu w drzewie środowiska uruchomieniowego jest niezdefiniowane. Zawsze używaj <xref:System.Windows.DependencyProperty.RegisterAttached%2A> można zarejestrować właściwości, w którym można określić <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> w metadanych.  
  
 Właściwości klasy pochodne <xref:System.Windows.PropertyMetadata> zwykle są zdefiniowane w modelu obiektu jako odczytu i zapisu. Jest to, dzięki czemu można je dostosować po zainicjowaniu wystąpienia. Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości zostanie zapieczętowania to wystąpienie metadanych i właściwości, które obejmują szczegółowe informacje na temat metadanych teraz jest uważany za niezmienialny. Trwa próba skonfigurowania tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Poniższy przykład uzyskuje dostęp do metadanych domyślne z różnych zależności pola właściwości, odpytuje wartości różnych <xref:System.Windows.FrameworkPropertyMetadata> właściwości, a informacje są używane do wypełniania tabeli, aby zaimplementować "Przeglądarka metadanych".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane już zastosowano do operacji właściwości zależności, tak aby metadanych jest zapieczętowany i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDataBindingAllowed : bool" Usage="System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy powiązanie danych jest obsługiwana dla właściwości zależności.</summary>
        <value>
          <see langword="true" /> Jeśli wiązanie danych jest obsługiwana przez właściwości zależności, do którego stosuje się te metadane; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość raporty `false` dla jednej z dwóch warunków możliwe: albo powiązania danych właściwości zależności nie jest dozwolona, ponieważ właściwość zależności jest tylko do odczytu (zgodnie z raportem identyfikator właściwości zależności nie metadanych), lub wartość inna właściwość metadanych, <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>, jest równa `true` w metadanych. Ta właściwość jest uwidaczniana jako udogodnienie, tak aby obiekty wywołujące nie trzeba sprawdzić zarówno <xref:System.Windows.DependencyProperty.ReadOnly%2A> i <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>.  
  
 Jeśli próbujesz utworzyć metadanych, który określa, w przeciwnym razie właściwości odczytu/zapisu powinien obsługuje powiązanie danych, należy określić flagę <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable> (należy pamiętać, niewielka różnica konwencji nazewnictwa i <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>).  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Poniższy przykład uzyskuje dostęp do metadanych domyślne z różnych zależności pola właściwości, odpytuje wartości różnych <xref:System.Windows.FrameworkPropertyMetadata> właściwości, a informacje są używane do wypełniania tabeli, aby zaimplementować "Przeglądarka metadanych".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsNotDataBindable : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy właściwość zależności obsługuje powiązanie danych.</summary>
        <value>
          <see langword="true" /> Jeśli właściwość nie obsługuje powiązanie danych; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy zauważyć, że ta właściwość metadanych jest równa `true` specjalnie dla właściwości, które nie powinny obsługiwać powiązania danych, mimo iż właściwości odczytu / zapisu. Oczekuje się, że w większości przypadków, w którym zadeklarowano właściwości zależności, wiązanie danych jest pożądane, wiązanie danych jest jednym z kluczowych scenariuszy, w których jest użyteczny właściwość zależności. W odróżnieniu od <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>, to nie zmienia jedynie domyślna, która może ulec zmianie w określonym powiązaniu. Ustawienie tej właściwości `true` w metadanych dla właściwości zależności metadanych spowoduje wyłączenie wszystkie powiązania przed zastosowaniem ich wartości za pomocą wyrażenia do tej właściwości zależności.  
  
 Powiązanie danych (ponieważ mają one nie setter, który można zastosować zmienionymi wartościami) nie obsługują właściwości zależności tylko do odczytu, ale nadal będzie raportu `false` dla <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>. Jest to spowodowane właściwości, które odpowiadają <xref:System.Windows.FrameworkPropertyMetadataOptions> wartości informację o parzystości z jak metadane rzeczywistości ustalono, zamiast zawsze raportowanie nazw właściwości może oznaczać zachowanie wynik końcowy. Aby ustalić, czy danej właściwości zależności pozwala na powiązanie danych, zazwyczaj należy sprawdzić <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> zamiast tego. <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> To udogodnienie sprawdzania zarówno <xref:System.Windows.DependencyProperty.ReadOnly%2A> i <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> jako pojedyncza operacja reaguje oczekiwany wynik.  
  
 Właściwości klasy pochodne <xref:System.Windows.PropertyMetadata> zwykle są zdefiniowane w modelu obiektu jako odczytu i zapisu. Jest to, dzięki czemu można je dostosować po zainicjowaniu wystąpienia. Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości zostanie zapieczętowania to wystąpienie metadanych i właściwości, które obejmują szczegółowe informacje na temat metadanych teraz jest uważany za niezmienialny. Trwa próba skonfigurowania tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane już zastosowano do operacji właściwości zależności, tak aby metadanych jest zapieczętowany i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Journal : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy ta właściwość zawiera informacje rejestrowania, który aplikacji lub powinny być przechowywane jako część wykonania rejestrowanie.</summary>
        <value>
          <see langword="true" /> Jeśli rejestrowanie powinna być wykonywana na właściwość zależności te metadane są stosowane do; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości klasy pochodne <xref:System.Windows.PropertyMetadata> zwykle są zdefiniowane w modelu obiektu jako odczytu i zapisu. Jest to, dzięki czemu można je dostosować po zainicjowaniu wystąpienia. Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości zostanie zapieczętowania to wystąpienie metadanych i właściwości, które obejmują szczegółowe informacje na temat metadanych teraz jest uważany za niezmienialny. Trwa próba skonfigurowania tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane już zastosowano do operacji właściwości zależności, tak aby metadanych jest zapieczętowany i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="frameworkPropertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">Podstawowy metadanych scalania.</param>
        <param name="dp">Właściwości zależności te metadane są stosowane do.</param>
        <summary>Umożliwia scalanie metadanych źródła za pomocą podstawowej metadanych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana wewnętrznie, gdy metadane są zastępowane.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Klasy, które wynikają z <see cref="T:System.Windows.PropertyMetadata" /> (lub ta klasa szczególnie) powinny przesłaniać tę metodę, aby uwzględnić wszystkie właściwości metadanych dodali w implementacji. Na przykład implementacji, że dodano nową wartość wyliczenia flagwise i <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementacji następnie powinien mieć możliwość łączenia tych flag poprawnie.  Zawsze należy wywoływać implementację podstawową przed Twojej własnej implementacji, ponieważ Podstawowa implementacja zajmuje się scalanie wszystkich właściwości, które są już zdefiniowane na poprzednich typów w hierarchii.  Zachowanie dodane przez <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementacji <see cref="T:System.Windows.FrameworkPropertyMetadata" /> jest fakt, że określone właściwości poziomie struktury WPF w metadanych, takich jak <see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /> są łączone w logiczny lub operacji.  <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> Zachowanie implementuje również zachowanie podczas zastąpienia metadanych właściwości modelu na istniejącej właściwości zależności, wywołując <see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />., przy użyciu metadanych zastąpienia, który jest <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="frameworkPropertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">Właściwości zależności, do którego zastosowano metadanych.</param>
        <param name="targetType">Typ skojarzony z metadanych, jeśli jest to metadane specyficzne dla danego typu. Jeśli jest to domyślny metadanych, ta wartość może być <see langword="null" />.</param>
        <summary>Wywołuje się, gdy metadane zostały doliczone do właściwości, co oznacza, że metadane jest zapieczętowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszelkie zmienność struktury danych <xref:System.Windows.FrameworkPropertyMetadata> wystąpienia powinien być oznaczony jako niezmienialny. gdy ta metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.FrameworkPropertyMetadata" /> Implementacja tej metody nie działa poza wywołanie implementację podstawową.</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesInheritanceBehavior : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy oceny dziedziczenie wartości właściwości powinien obejmować niektórych zawartości granice, w drzewie logicznym elementów.</summary>
        <value>
          <see langword="true" /> Jeśli dziedziczenie wartości właściwości powinny obejmować niektórych granice zawartości; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Te metadane raporty rzadko stosowana modyfikacji zachowanie dziedziczenie wartości właściwości granice elementu nadrzędnego specjalne element podrzędny. Canonical Przykładem takich granic znajduje się zawartość <xref:System.Windows.Controls.Frame>, gdzie <xref:System.Windows.Controls.Frame> zawartości może uzyskać załadowany ponownie, niezależnie od istnienia <xref:System.Windows.Controls.Frame>. Zachowanie systemu żądaną właściwość jest, że dziedziczenie wartości właściwości nie powinny przechodzą przez zawartości <xref:System.Windows.Controls.Frame>, ponieważ te zawartość może być elementy, które hosting ramki aplikacji lub przez kontrolowanie. Określanie metadanych za pomocą <xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> równa `true`, a także jak określanie <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> jako `true`, spowoduje, że właściwość, dla którego stosowana jest metadanych jako dziedziczne nawet na <xref:System.Windows.Controls.Frame> granic lub podobne granic.  
  
 Właściwości klasy pochodne <xref:System.Windows.PropertyMetadata> zwykle są zdefiniowane w modelu obiektu jako odczytu i zapisu. Jest to, dzięki czemu można je dostosować po zainicjowaniu wystąpienia. Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości zostanie zapieczętowania to wystąpienie metadanych i właściwości, które obejmują szczegółowe informacje na temat metadanych teraz jest uważany za niezmienialny. Trwa próba skonfigurowania tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane już zastosowano do operacji właściwości zależności, tak aby metadanych jest zapieczętowany i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SubPropertiesDoNotAffectRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy właściwości podrzędnych właściwości zależności nie wpływają na renderowanie krawędzi zawierającego go obiektu.</summary>
        <value>
          <see langword="true" /> w przypadku zmiany wartości właściwości podrzędnych nie wpływają na renderowanie, jeśli zostały zmienione; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta opcja metadanych jest odpowiednie dla właściwości zależności, które są typami odwołań, gdzie ten typ ma wartości właściwości swój własny. Zazwyczaj logiki systemu układ jest przyjęto założenie, że wszystkie właściwości zależności za pomocą właściwości podrzędnych potencjalnie wpłynie na układ, ponieważ sprawdzanie wszystkich właściwości podrzędnych zmian jest bardziej czasochłonne niż rzeczywiście uruchamianie innego renderowania — dostęp próbny. Ustawienie tej opcji na `true` przydaje się do optymalizacji wydajności implementacji systemu uzyskiwania informacji na temat poziomu układ framework WPF.  
  
 Właściwości klasy pochodne <xref:System.Windows.PropertyMetadata> zwykle są zdefiniowane w modelu obiektu jako odczytu i zapisu. Jest to, dzięki czemu można je dostosować po zainicjowaniu wystąpienia. Jednak po zużyciu metadanych jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości zostanie zapieczętowania to wystąpienie metadanych i właściwości, które obejmują szczegółowe informacje na temat metadanych teraz jest uważany za niezmienialny. Trwa próba skonfigurowania tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane już zastosowano do operacji właściwości zależności, tak aby metadanych jest zapieczętowany i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>
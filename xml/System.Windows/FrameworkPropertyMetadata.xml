<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3096061908923e7cf781983beaab620533614144" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36460257" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <TypeSignature Language="F#" Value="type FrameworkPropertyMetadata = class&#xA;    inherit UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Raporty lub stosuje metadane dla właściwości zależności, w szczególności Dodawanie właściwości właściwości określonej struktury.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa pochodzi od <xref:System.Windows.PropertyMetadata> (za pośrednictwem <xref:System.Windows.UIPropertyMetadata>). W większości przypadków rozwoju aplikacji na poziomie framework WPF <xref:System.Windows.FrameworkPropertyMetadata> jest typ używany do metadanych właściwości zależności, zamiast typy podstawowe <xref:System.Windows.PropertyMetadata> lub <xref:System.Windows.UIPropertyMetadata>. Dotyczy to zarówno w przypadku istniejącej właściwości zależności, jak i dla większości scenariuszy właściwości niestandardowe zależności.  
  
 Ten dodatek klasy elementów członkowskich zadeklarowanych przez to <xref:System.Windows.PropertyMetadata> klasy podstawowej obejmują różne właściwości Boolean określ lub zgłosić WPF właściwość framework poziom systemu zachowanie dziedziczenia, powiązania danych i układu.  
  
 Kilka sygnatur Konstruktor do tworzenia <xref:System.Windows.FrameworkPropertyMetadata> podjęcia wystąpienia <xref:System.Windows.FrameworkPropertyMetadataOptions> parametru. <xref:System.Windows.FrameworkPropertyMetadataOptions> Wyliczenie jest używana tylko w celu określenia zachowania początkowej w Konstruktorze i nie jest uwidaczniana w przeciwnym razie po <xref:System.Windows.FrameworkPropertyMetadata> jest tworzony. Z skonstruowane wystąpienie można pobrać lub ustawić odpowiednie informacje przy użyciu różnych właściwości, które współużytkują nazwę wartości wyliczenia używane w wywołaniu konstruktora.  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Ta klasa nie jest zazwyczaj używana w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Poniższy przykład pobiera metadane dla właściwości zależności w szczególności właściciela jako pierwszy podstawowej <xref:System.Windows.PropertyMetadata> typu. Metadane są rzutowane na <xref:System.Windows.FrameworkPropertyMetadata>. Jeśli rzutowanie zwrócony prawidłowy <xref:System.Windows.FrameworkPropertyMetadata>, a następnie różnych <xref:System.Windows.FrameworkPropertyMetadata> wartości właściwości są raportowane za pomocą prostego interfejsu użytkownika (tego nie pokazano).  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy.</summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta sygnatura inicjuje wszystkie wartości <xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A> domyślnych właściwości. <xref:System.Windows.PropertyMetadata.DefaultValue%2A> będzie `null`, a różnymi <xref:System.Windows.FrameworkPropertyMetadata> będzie logiczną właściwości `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zwykle dostarczonych jako wartość określonego typu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy z wartością określoną wartość domyślną.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości podanej dla `defaultValue` musi odpowiadać lub być związane z typem określonym w pierwotnej rejestracji właściwości zależności, która będzie dotyczyć tych metadanych. Niezgodność między typ wartości domyślnej metadanych i typu właściwości zależności, który jest stosowany do może być trudne do debugowania, ponieważ niezgodność nie jest wykrywalny podczas kompilacji. Właściwości systemu nie może oszacować efektywną wartość właściwości do czasu wykonywania, więc wynik niezgodność typów właściwości/typu wartości domyślnej jest błędów czasu wykonywania.  
  
 Wartość <xref:System.Windows.DependencyProperty.UnsetValue> ma specjalne znaczenie w systemie właściwości i nie można użyć jako wartości domyślnej właściwości zależności.  
  
   
  
## Examples  
 Poniższy przykład wywołuje ten konstruktor podpis:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> ustawiono <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, który system właściwości wywoła przy każdej zmianie wprowadzenia wartości właściwości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy z określonym <see cref="T:System.Windows.PropertyChangedCallback" /> wywołania zwrotnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład wywołuje ten konstruktor podpis:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zwykle dostarczonych jako wartość określonego typu.</param>
        <param name="flags">Flagi opcji metadane (kombinację <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> wartości). Te opcje określ cechy właściwości zależności współpracujące z systemów, takich jak powiązania danych lub układu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkPropertyMetadata" /> z wartości domyślnej podana i opcje poziomie struktury metadanych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości podanej dla `defaultValue` musi odpowiadać lub być związane z typem określonym w pierwotnej rejestracji właściwości zależności, która będzie dotyczyć tych metadanych. Niezgodność między typ wartości domyślnej metadanych i typu właściwości zależności, który jest stosowany do może być trudne do debugowania, ponieważ niezgodność nie jest wykrywalny podczas kompilacji. Właściwości systemu nie może oszacować efektywną wartość właściwości do czasu wykonywania, więc wynik niezgodność typów właściwości/typu wartości domyślnej jest błędów czasu wykonywania.  
  
 Wartość <xref:System.Windows.DependencyProperty.UnsetValue> ma specjalne znaczenie w systemie właściwości i nie można użyć jako wartości domyślnej właściwości zależności.  
  
 Wartości oznaczone jako flagi zestawu w `flags` zostanie ustawiona wartość logiczna <xref:System.Windows.FrameworkPropertyMetadata> właściwości, które zgodne <xref:System.Windows.FrameworkPropertyMetadataOptions> nazwę flagi `true`. Następnie można zmienić wartości właściwości w metadanych, tak długo, jak metadanych nie ma jeszcze zastosowane do operacji systemu określoną właściwość.  
  
   
  
## Examples  
 Poniższy przykład wywołuje ten konstruktor podpis:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> ustawiono <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zwykle dostarczonych jako wartość określonego typu.</param>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, który system właściwości wywoła przy każdej zmianie wprowadzenia wartości właściwości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy z wartością domyślną podana i określić <see cref="T:System.Windows.PropertyChangedCallback" /> wywołania zwrotnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości podanej dla `defaultValue` musi odpowiadać lub być związane z typem określonym w pierwotnej rejestracji właściwości zależności, która będzie dotyczyć tych metadanych. Niezgodność między typ wartości domyślnej metadanych i typu właściwości zależności, który jest stosowany do może być trudne do debugowania, ponieważ niezgodność nie jest wykrywalny podczas kompilacji. Właściwości systemu nie może oszacować efektywną wartość właściwości do czasu wykonywania, więc wynik niezgodność typów właściwości/typu wartości domyślnej jest błędów czasu wykonywania.  
  
 Wartość <xref:System.Windows.DependencyProperty.UnsetValue> ma specjalne znaczenie w systemie właściwości i nie można użyć jako wartości domyślnej właściwości zależności.  
  
   
  
## Examples  
 Poniższy przykład wywołuje ten konstruktor podpis:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> ustawiono <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, który system właściwości wywoła przy każdej zmianie wprowadzenia wartości właściwości.</param>
        <param name="coerceValueCallback">Odwołanie do implementacji programu obsługi będzie wywoływana przy każdym wywołań systemowych właściwości <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> dla tej właściwości zależności.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy z określonym wywołań zwrotnych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja wywołuje inicjatora podstawowego, a następnie dodaje `coerceValueCallback` ustawiając właściwość w wystąpieniu podstawowej.  
  
   
  
## Examples  
 Poniższy przykład wywołuje ten konstruktor podpis:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zwykle dostarczonych jako wartość określonego typu.</param>
        <param name="flags">Flagi opcji metadane (kombinację <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> wartości). Te opcje określ cechy właściwości zależności współpracujące z systemów, takich jak powiązania danych lub układu.</param>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, który system właściwości wywoła przy każdej zmianie wprowadzenia wartości właściwości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy z opcji domyślnych podana wartość i framework metadane, a określono <see cref="T:System.Windows.PropertyChangedCallback" /> wywołania zwrotnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości podanej dla `defaultValue` musi odpowiadać lub być związane z typem określonym w pierwotnej rejestracji właściwości zależności, która będzie dotyczyć tych metadanych. Niezgodność między typ wartości domyślnej metadanych i typu właściwości zależności, który jest stosowany do może być trudne do debugowania, ponieważ niezgodność nie jest wykrywalny podczas kompilacji. Właściwości systemu nie może oszacować efektywną wartość właściwości do czasu wykonywania, więc wynik niezgodność typów właściwości/typu wartości domyślnej jest błędów czasu wykonywania.  
  
 Wartość <xref:System.Windows.DependencyProperty.UnsetValue> ma specjalne znaczenie w systemie właściwości i nie można użyć jako wartości domyślnej właściwości zależności.  
  
 Wartości oznaczone jako flagi zestawu w `flags` zostanie ustawiona wartość logiczna <xref:System.Windows.FrameworkPropertyMetadata> właściwości, które zgodne <xref:System.Windows.FrameworkPropertyMetadataOptions> nazwę flagi `true`. Nadal można zmienić wartości właściwości w metadanych, tak długo, jak metadanych nie ma jeszcze zastosowane do operacji systemu określoną właściwość.  
  
   
  
## Examples  
 Poniższy przykład wywołuje ten konstruktor podpis:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> ustawiono <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zwykle dołączone jako określonego typu.</param>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, który system właściwości wywoła przy każdej zmianie wprowadzenia wartości właściwości.</param>
        <param name="coerceValueCallback">Odwołanie do implementacji programu obsługi, która będzie wywoływana, gdy wywołań systemowych właściwości <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> dla tej właściwości zależności.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkPropertyMetadata" /> z wartości domyślnej podana i określony wywołań zwrotnych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości podanej dla `defaultValue` musi odpowiadać lub być związane z typem określonym w pierwotnej rejestracji właściwości zależności, która będzie dotyczyć tych metadanych. Niezgodność między typ wartości domyślnej metadanych i typu właściwości zależności, który jest stosowany do może być trudne do debugowania, ponieważ niezgodność nie jest wykrywalny podczas kompilacji. Właściwości systemu nie może oszacować efektywną wartość właściwości do czasu wykonywania, więc wynik niezgodność typów właściwości/typu wartości domyślnej jest błędów czasu wykonywania.  
  
 Wartość <xref:System.Windows.DependencyProperty.UnsetValue> ma specjalne znaczenie w systemie właściwości i nie można użyć jako wartości domyślnej właściwości zależności.  
  
   
  
## Examples  
 Poniższy przykład wywołuje ten konstruktor podpis:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> ustawiono <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zwykle dołączone jako określonego typu.</param>
        <param name="flags">Flagi opcji metadane (kombinację <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> wartości). Te opcje określ cechy właściwości zależności współpracujące z systemów, takich jak powiązania danych lub układu.</param>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, który system właściwości wywoła przy każdej zmianie wprowadzenia wartości właściwości.</param>
        <param name="coerceValueCallback">Odwołanie do implementacji programu obsługi, która będzie wywoływana, gdy wywołań systemowych właściwości <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> względem tej właściwości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkPropertyMetadata" /> z wartości domyślnej podana i opcje metadanych framework i określonego wywołania zwrotne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości podanej dla `defaultValue` musi odpowiadać lub być związane z typem określonym w pierwotnej rejestracji właściwości zależności, która będzie dotyczyć tych metadanych. Niezgodność między typ wartości domyślnej metadanych i typu właściwości zależności, który jest stosowany do może być trudne do debugowania, ponieważ niezgodność nie jest wykrywalny podczas kompilacji. Właściwości systemu nie może oszacować efektywną wartość właściwości do czasu wykonywania, więc wynik niezgodność typów właściwości/typu wartości domyślnej jest błędów czasu wykonywania.  
  
 Wartość <xref:System.Windows.DependencyProperty.UnsetValue> ma specjalne znaczenie w systemie właściwości i nie można użyć jako wartości domyślnej właściwości zależności.  
  
 Wartości oznaczone jako flagi zestawu w `flags` zostanie ustawiona wartość logiczna <xref:System.Windows.FrameworkPropertyMetadata> właściwości, które zgodne <xref:System.Windows.FrameworkPropertyMetadataOptions> nazwę flagi `true`. Nadal można zmienić wartości właściwości w metadanych, tak długo, jak metadanych nie ma jeszcze zastosowane do operacji systemu określoną właściwość.  
  
   
  
## Examples  
 Poniższy przykład wywołuje ten konstruktor podpis:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> ustawiono <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zwykle dołączone jako określonego typu.</param>
        <param name="flags">Flagi opcji metadane (kombinację <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> wartości). Te opcje określ cechy właściwości zależności współpracujące z systemów, takich jak powiązania danych lub układu.</param>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, który system właściwości wywoła przy każdej zmianie wprowadzenia wartości właściwości.</param>
        <param name="coerceValueCallback">Odwołanie do implementacji programu obsługi, która będzie wywoływana, gdy wywołań systemowych właściwości <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> dla tej właściwości zależności.</param>
        <param name="isAnimationProhibited">
          <see langword="true" /> Aby zapobiec system właściwości animacji właściwość, która dotyczy tych metadanych. Takie właściwości zgłosi wyjątek czasu wykonywania, pochodzących z systemu właściwości animacji z nich są próbie. <see langword="false" /> Aby zezwolić na animowania właściwości. Wartość domyślna to <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkPropertyMetadata" /> z podanych domyślne opcje metadanych wartość i framework, określony wywołania zwrotne i wartość logiczna, która może służyć do animacji właściwość zapobiec.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości podanej dla `defaultValue` musi odpowiadać lub być związane z typem określonym w pierwotnej rejestracji właściwości zależności, która będzie dotyczyć tych metadanych. Niezgodność między typ wartości domyślnej metadanych i typu właściwości zależności, który jest stosowany do może być trudne do debugowania, ponieważ niezgodność nie jest wykrywalny podczas kompilacji. Właściwości systemu nie może oszacować efektywną wartość właściwości do czasu wykonywania, więc wynik niezgodność typów właściwości/typu wartości domyślnej jest błędów czasu wykonywania.  
  
 Wartość <xref:System.Windows.DependencyProperty.UnsetValue> ma specjalne znaczenie w systemie właściwości i nie można użyć jako wartości domyślnej właściwości zależności.  
  
 `isAnimationProhibited` Parametr ustawia wartość początkową <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> właściwość zadeklarowana z bezpośrednim podstawy <xref:System.Windows.UIPropertyMetadata> klasy.  
  
 Wartości oznaczone jako flagi zestawu w `flags` zostanie ustawiona wartość logiczna <xref:System.Windows.FrameworkPropertyMetadata> właściwości, które zgodne <xref:System.Windows.FrameworkPropertyMetadataOptions> nazwę flagi `true`. Nadal można zmienić wartości właściwości w metadanych, tak długo, jak metadanych nie ma jeszcze zastosowane do operacji systemu określoną właściwość.  
  
   
  
## Examples  
 Poniższy przykład wywołuje ten konstruktor podpis:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> ustawiono <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool * System.Windows.Data.UpdateSourceTrigger -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited, defaultUpdateSourceTrigger)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zwykle dołączone jako określonego typu.</param>
        <param name="flags">Flagi opcji metadane (kombinację <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> wartości). Te opcje określ cechy właściwości zależności współpracujące z systemów, takich jak powiązania danych lub układu.</param>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, który system właściwości wywoła przy każdej zmianie wprowadzenia wartości właściwości.</param>
        <param name="coerceValueCallback">Odwołanie do implementacji programu obsługi, która będzie wywoływana, gdy wywołań systemowych właściwości <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> względem tej właściwości.</param>
        <param name="isAnimationProhibited">
          <see langword="true" /> Aby zapobiec system właściwości animacji właściwość, która dotyczy tych metadanych. Takie właściwości zgłosi wyjątek czasu wykonywania, pochodzących z systemu właściwości animacji z nich są próbie. Wartość domyślna to <see langword="false" />.</param>
        <param name="defaultUpdateSourceTrigger">
          <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> Do użycia podczas powiązania dla tej właściwości są stosowane, które mają ich <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> ustawioną <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkPropertyMetadata" /> opcje klasy z podanych domyślne wartości i framework metadane, określony wywołań zwrotnych, wartość logiczna, która może służyć do zapobiec animacji właściwość i domyślnym wyzwalacza update powiązania danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości podanej dla `defaultValue` musi odpowiadać lub być związane z typem określonym w pierwotnej rejestracji właściwości zależności, która będzie dotyczyć tych metadanych. Niezgodność między typ wartości domyślnej metadanych i typu właściwości zależności, który jest stosowany do może być trudne do debugowania, ponieważ niezgodność nie jest wykrywalny podczas kompilacji. Właściwości systemu nie może oszacować efektywną wartość właściwości do czasu wykonywania, więc wynik niezgodność typów właściwości/typu wartości domyślnej jest błędów czasu wykonywania.  
  
 Wartość <xref:System.Windows.DependencyProperty.UnsetValue> ma specjalne znaczenie w systemie właściwości i nie można użyć jako wartości domyślnej właściwości zależności.  
  
 `isAnimationProhibited` Parametr ustawia wartość początkową <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> właściwość zadeklarowana z bezpośrednim podstawy <xref:System.Windows.UIPropertyMetadata> klasy.  
  
 Aby uzyskać więcej informacji dotyczących zachowania źródło aktualizacji dla powiązań, zobacz [omówienie powiązania danych](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 Wartości oznaczone jako flagi zestawu w `flags` zostanie ustawiona wartość logiczna <xref:System.Windows.FrameworkPropertyMetadata> właściwości, które zgodne <xref:System.Windows.FrameworkPropertyMetadataOptions> nazwę flagi `true`. Nadal można zmienić wartości właściwości w metadanych, tak długo, jak metadanych nie ma jeszcze zastosowane do operacji systemu określoną właściwość.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> ustawiono <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy właściwości zależności może potencjalnie dotyczyć przebiegu Rozmieść podczas operacji aparatu układu.</summary>
        <value>
          <see langword="true" /> Jeśli właściwość zależności, na którym te metadane istnieje potencjalnie ma wpływ na przebieg Rozmieść; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> i <xref:System.Windows.FrameworkContentElement> obejmują implementacja <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> która śledzi zmiany wartość efektywna na wszystkie właściwości zależności, które istnieją w elemencie. W ramach tej logiki, wartość właściwości zależności, które zmieniają obowiązującej, a ma metadanych z <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> ustawioną `true` zainicjuje odroczonego żądania w celu unieważnienia elementy wizualne dla tego elementu (wywołanie <xref:System.Windows.UIElement.InvalidateArrange%2A>). Ponieważ ta implementacja poziomie struktury WPF jest już w miejscu, zwykle nie należy do wyszukania właściwości zależności z <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> chyba, że są zasadniczo zastępowania lub modyfikowanie zachowania układu poziomie struktury WPF.  
  
 Niestandardowe <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementacje wybrać zachowują się podobnie zmiany właściwości zależności gdzie <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> jest `true`.  
  
 Właściwości klas pochodnych <xref:System.Windows.PropertyMetadata> są zazwyczaj definiowane w modelu obiektów w trybie odczytu i zapisu. Jest to, dlatego można je dostosować po zainicjowaniu wystąpienia. Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwość zostanie zapieczętować tego wystąpienia metadanych i właściwości, które udzielają szczegółowych informacji o metadanych są teraz uważany za niezmienialny. Trwa próba skonfigurowania tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są albo nie zwykle używanych w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Poniższy przykład uzyskuje dostęp do metadanych domyślne z różnych zależności pola właściwości, wysyła zapytanie do wartości różnych <xref:System.Windows.FrameworkPropertyMetadata> właściwości oraz informacje są używane do wypełnienia tabeli do zaimplementowania przeglądarką"metadanych".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane już zostały zastosowane do operacji właściwości zależności, dzięki czemu metadanych jest zapieczętowany i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy właściwości zależności może potencjalnie dotyczyć przebiegu miary podczas operacji aparatu układu.</summary>
        <value>
          <see langword="true" /> Jeśli właściwość zależności, na którym te metadane istnieje potencjalnie ma wpływ na przebieg miary; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> i <xref:System.Windows.FrameworkContentElement> obejmują implementacja <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> która śledzi zmiany wartość efektywna na wszystkie właściwości zależności, które istnieją w elemencie. W ramach tej logiki, wartość właściwości zależności, które zmieniają obowiązującej, a ma metadanych z <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> ustawioną `true` zainicjuje odroczonego żądania w celu unieważnienia elementy wizualne dla tego elementu. Ponieważ ta implementacja poziomie struktury WPF jest już w miejscu, zwykle nie należy do wyszukania właściwości zależności z <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> chyba, że są zasadniczo zastępowania lub modyfikowanie zachowania układu poziomie struktury WPF.  
  
 Niestandardowe <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementacje wybrać zachowują się podobnie zmiany właściwości zależności gdzie <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> jest `true`.  
  
 Właściwości klas pochodnych <xref:System.Windows.PropertyMetadata> są zazwyczaj definiowane w modelu obiektów w trybie odczytu i zapisu. Jest to, dlatego można je dostosować po zainicjowaniu wystąpienia. Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwość zostanie zapieczętować tego wystąpienia metadanych i właściwości, które udzielają szczegółowych informacji o metadanych są teraz uważany za niezmienialny. Trwa próba skonfigurowania tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Poniższy przykład uzyskuje dostęp do metadanych domyślne z różnych zależności pola właściwości, wysyła zapytanie do wartości różnych <xref:System.Windows.FrameworkPropertyMetadata> właściwości oraz informacje są używane do wypełnienia tabeli do zaimplementowania przeglądarką"metadanych".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane już zostały zastosowane do operacji właściwości zależności, dzięki czemu metadanych jest zapieczętowany i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy właściwości zależności może potencjalnie dotyczyć przebiegu Rozmieść układu elementem nadrzędnym elementu podczas operacji aparatu układu.</summary>
        <value>
          <see langword="true" /> Jeśli właściwość zależności, na którym te metadane istnieje potencjalnie ma wpływ na przebieg Rozmieść w szczególności na jego elementu nadrzędnego; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> i <xref:System.Windows.FrameworkContentElement> obejmują implementacja <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> która śledzi zmiany wartość efektywna na wszystkie właściwości zależności, które istnieją w elemencie. W ramach tej logiki, wartość właściwości zależności, które zmieniają obowiązującej, a ma metadanych z <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> ustawioną `true` zainicjuje odroczonego żądania w celu unieważnienia elementy wizualne dla elementu nadrzędnego.  
  
 Ogólnie rzecz biorąc, nie trzeba przeprowadzać zmiany w raporcie <xref:System.Windows.FrameworkElement> właściwości do elementu nadrzędnego przy użyciu <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> ponieważ samego elementu będą już mieć własny <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> jako `true`. Zwykle wystarczające, zazwyczaj inicjował zmiany w element podrzędny elementu nadrzędnego Rozmieść stosownych. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> Czasami jest używane dla <xref:System.Windows.FrameworkContentElement> klasy. W tym przypadku zestawów element podrzędny właściwość, ale a <xref:System.Windows.FrameworkContentElement> klasy pochodnej nie kontroluje własną renderowania. Renderowanie jest obsługiwany przez <xref:System.Windows.FrameworkElement> elementu nadrzędnego, który służy jako host zawartości. Na przykład zmień wartość <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> unieważnia dołączona właściwość przez element podrzędny Rozmieść elementu nadrzędnego, ponieważ musi zostać zmieniona pozycja elementu podrzędnego w obiekcie nadrzędnym. W związku z tym <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> dołączona właściwość ma metadane gdzie <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> jest `true`. Innym przykładem jest <xref:System.Windows.Controls.Control.Padding%2A>; po tej zmiany właściwości nadrzędnego może zmienić położenie elementu podrzędnego, w zależności od dostępnego miejsca.  
  
 Ponieważ ta implementacja poziomie struktury WPF jest już w miejscu, zwykle nie należy do wyszukania właściwości zależności z <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> chyba, że są zasadniczo zastępowania lub modyfikowanie zachowania układu poziomie struktury WPF.  
  
 Niestandardowe <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementacje wybrać zachowują się podobnie zmiany właściwości zależności gdzie <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> jest `true`.  
  
 Właściwości w dowolnej pochodnej klasy <xref:System.Windows.PropertyMetadata> są zazwyczaj definiowane w modelu obiektów w trybie odczytu i zapisu. Jest to, dlatego można je dostosować po zainicjowaniu wystąpienia. Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwość zostanie zapieczętować tego wystąpienia metadanych i właściwości, które udzielają szczegółowych informacji o metadanych są teraz uważany za niezmienialny. Trwa próba skonfigurowania tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane już zostały zastosowane do operacji właściwości zależności, dzięki czemu metadanych jest zapieczętowany i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy właściwości zależności może potencjalnie dotyczyć przebiegu miary układu elementem nadrzędnym elementu podczas operacji aparatu układu.</summary>
        <value>
          <see langword="true" /> Jeśli właściwość zależności, na którym te metadane istnieje potencjalnie ma wpływ na przebieg miar, w szczególności na jego elementu nadrzędnego; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> i <xref:System.Windows.FrameworkContentElement> obejmują implementacja <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> która śledzi zmiany wartość efektywna na wszystkie właściwości zależności, które istnieją w elemencie. W ramach tej logiki, wartość właściwości zależności, które zmieniają obowiązującej, a ma metadanych z <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> ustawioną `true` zainicjuje odroczonego żądania w celu unieważnienia elementy wizualne dla elementu nadrzędnego. Ponieważ ta implementacja poziomie struktury WPF jest już w miejscu, zwykle nie należy do wyszukania właściwości zależności z <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> chyba, że są zasadniczo zastępowania lub modyfikowanie zachowania układu poziomie struktury WPF.  
  
 Ogólnie rzecz biorąc, nie trzeba przeprowadzać zmiany w raporcie <xref:System.Windows.FrameworkElement> właściwości do elementu nadrzędnego przy użyciu <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> ponieważ samego elementu będą już mieć własny <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> jako `true`. To zwykle wystarczające, ponieważ zmiany elementu podrzędnego zazwyczaj inicjować przekazywanym miary nadrzędnego stosownych. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> Czasami jest używane dla <xref:System.Windows.FrameworkContentElement> klasy. W tym przypadku zestawów element podrzędny właściwość, ale a <xref:System.Windows.FrameworkContentElement> klasy pochodnej nie kontroluje własną renderowania. Renderowanie jest obsługiwany przez <xref:System.Windows.FrameworkElement> elementu nadrzędnego, który służy jako host zawartości. Na przykład zmień wartość <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> właściwości przez element podrzędny unieważnia miar elementu nadrzędnego, ponieważ względną odstępy akapitów może zmienić i może zwiększyć lub zmniejszyć rozmiar host zawartości. W związku z tym <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> właściwości ma metadane gdzie <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> jest `true`.  
  
 Elementy zawartości hosta Wyszukaj także często zmian właściwości zależności gdzie <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> jest `true`, jako część logiki renderowania zawartości hosta. Na przykład <xref:System.Windows.Controls.TextBox> elementu musi odpowiadać na pewnych zmian w tekście, który może wymaga, aby obwiedni <xref:System.Windows.Controls.TextBox> sam można zmienić.  
  
 Niestandardowe <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementacje wybrać zachowują się podobnie zmiany właściwości zależności gdzie <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> jest `true`.  
  
 Właściwości w dowolnej pochodnej klasy <xref:System.Windows.PropertyMetadata> są zazwyczaj definiowane w modelu obiektów w trybie odczytu i zapisu. Jest to, dlatego można je dostosować po zainicjowaniu wystąpienia. Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwość zostanie zapieczętować tego wystąpienia metadanych i właściwości, które udzielają szczegółowych informacji o metadanych są teraz uważany za niezmienialny. Trwa próba skonfigurowania tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane już zostały zastosowane do operacji właściwości zależności, dzięki czemu metadanych jest zapieczętowany i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy właściwości zależności może potencjalnie dotyczyć ogólny układ w inny sposób, który nie ma w szczególności wpływu rozmieszczenie lub miary, ale wymaga ponownego rysowania.</summary>
        <value>
          <see langword="true" /> Jeśli właściwość zależności, na którym znajduje się ta metadanych ma wpływ na renderowanie; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> i <xref:System.Windows.FrameworkContentElement> obejmują implementacja <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> która śledzi zmiany wartość efektywna na wszystkie właściwości zależności, które istnieją w elemencie. W ramach tej logiki, wartość właściwości zależności, które zmieniają obowiązującej, a ma metadanych z <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> ustawioną `true` zainicjuje odroczonego żądania w celu unieważnienia elementy wizualne dla tego elementu. Ponieważ ta implementacja poziomie struktury WPF jest już w miejscu, zwykle nie należy do wyszukania właściwości zależności z <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> chyba, że są zasadniczo zastępowania lub modyfikowanie zachowania układu poziomie struktury WPF.  
  
 Niestandardowe <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementacje wybrać zachowują się podobnie zmiany właściwości zależności gdzie <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> jest `true`.  
  
 Właściwości w dowolnej pochodnej klasy <xref:System.Windows.PropertyMetadata> są zazwyczaj definiowane w modelu obiektów w trybie odczytu i zapisu. Jest to, dlatego można je dostosować po zainicjowaniu wystąpienia. Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwość zostanie zapieczętować tego wystąpienia metadanych i właściwości, które udzielają szczegółowych informacji o metadanych są teraz uważany za niezmienialny. Trwa próba skonfigurowania tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Poniższy przykład uzyskuje dostęp do metadanych domyślne z różnych zależności pola właściwości, wysyła zapytanie do wartości różnych <xref:System.Windows.FrameworkPropertyMetadata> właściwości oraz informacje są używane do wypełnienia tabeli do zaimplementowania przeglądarką"metadanych".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane już zostały zastosowane do operacji właściwości zależności, dzięki czemu metadanych jest zapieczętowany i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BindsTwoWayByDefault : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy właściwość powiązanie dwukierunkowe domyślnie.</summary>
        <value>
          <see langword="true" /> Jeśli właściwość zależności, na którym znajduje się te metadane powiązanie dwukierunkowe domyślnie; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku braku tej właściwości jest `true`, powiązanie aktualizacje są domyślnie w oparciu o domyślne zachowanie jednokierunkowe <xref:System.Windows.Data.Binding> konstruktorów lub równoważnej [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] składni.  
  
 W istniejących elementów, zwykle można znaleźć tej właściwości wartość `true` metadanych dla właściwości zależności, zarówno raport stanu i są modyfikowane przez przez akcję użytkownika, na przykład <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>.  
  
 Ta właściwość raporty tylko domyślne parametry aktualizacji powiązania właściwości zależności ogólnie. Powiązania wartość tej właściwości dla wystąpienia lokalnego można ustawić <xref:System.Windows.Data.Binding.Mode%2A> właściwości powiązania i zmienić to ustawienie domyślne.  
  
 Właściwości w dowolnej pochodnej klasy <xref:System.Windows.PropertyMetadata> są zazwyczaj definiowane w modelu obiektów w trybie odczytu i zapisu. Jest to, dlatego można je dostosować po zainicjowaniu wystąpienia. Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwość zostanie zapieczętować tego wystąpienia metadanych i właściwości, które udzielają szczegółowych informacji o metadanych są teraz uważany za niezmienialny. Trwa próba skonfigurowania tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Poniższy przykład uzyskuje dostęp do metadanych domyślne z różnych zależności pola właściwości, wysyła zapytanie do wartości różnych <xref:System.Windows.FrameworkPropertyMetadata> właściwości oraz informacje są używane do wypełnienia tabeli do zaimplementowania przeglądarką"metadanych".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane już zostały zastosowane do operacji właściwości zależności, dzięki czemu metadanych jest zapieczętowany i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultUpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość domyślna dla <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> do użycia podczas wiązania dla właściwości o metadanych są stosowane, które mają ich <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> ustawioną <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</summary>
        <value>Wartość wyliczenia, inne niż <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości klas pochodnych <xref:System.Windows.PropertyMetadata> są zazwyczaj definiowane w modelu obiektów w trybie odczytu i zapisu. Jest to, dlatego można je dostosować po zainicjowaniu wystąpienia. Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwość zostanie zapieczętować tego wystąpienia metadanych i właściwości, które udzielają szczegółowych informacji o metadanych są teraz uważany za niezmienialny. Trwa próba skonfigurowania tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ta właściwość jest ustawiona na <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />; ustawiona wartość powinien stać się domyślnie powiązania na żądanie.</exception>
        <exception cref="T:System.InvalidOperationException">Metadane już zostały zastosowane do operacji właściwości zależności, dzięki czemu metadanych jest zapieczętowany i nie można ustawić właściwości metadanych.</exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Inherits : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy wartość właściwości zależności jest dziedziczone.</summary>
        <value>
          <see langword="true" /> Jeśli wartość właściwości jest dziedziczona; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dziedziczenie wartość właściwości jest funkcją [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] właściwości systemu na poziomie framework WPF, zgodnie z którymi niektórych właściwości zależności lokalnie na można ustawić elementu lub prawie katalog główny [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] element drzewa, a następnie ich dziedziczone przez wartość wszystkie elementy w drzewie logicznym elementy podrzędne, które również posiadają tej właściwości. Dziedziczenie wartość właściwości nie jest domyślnie włączona, a umożliwiając ma wpływ na wydajność. Aby uzyskać więcej informacji, zobacz [dziedziczenie wartości właściwości](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
> [!NOTE]
>  Mimo że dziedziczenie wartości właściwości mogą być wyświetlane dla właściwości zależności nie dołączony, zachowanie dziedziczenia nie dołączony właściwości przy użyciu określonych działów obiektu obiektu w drzewie środowiska uruchomieniowego jest niezdefiniowany. Zawsze używaj <xref:System.Windows.DependencyProperty.RegisterAttached%2A> można zarejestrować właściwości, w którym można określić <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> w metadanych.  
  
 Właściwości klas pochodnych <xref:System.Windows.PropertyMetadata> są zazwyczaj definiowane w modelu obiektów w trybie odczytu i zapisu. Jest to, dlatego można je dostosować po zainicjowaniu wystąpienia. Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwość zostanie zapieczętować tego wystąpienia metadanych i właściwości, które udzielają szczegółowych informacji o metadanych są teraz uważany za niezmienialny. Trwa próba skonfigurowania tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Poniższy przykład uzyskuje dostęp do metadanych domyślne z różnych zależności pola właściwości, wysyła zapytanie do wartości różnych <xref:System.Windows.FrameworkPropertyMetadata> właściwości oraz informacje są używane do wypełnienia tabeli do zaimplementowania przeglądarką"metadanych".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane już zostały zastosowane do operacji właściwości zależności, dzięki czemu metadanych jest zapieczętowany i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDataBindingAllowed : bool" Usage="System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy powiązanie danych jest obsługiwane dla właściwości zależności.</summary>
        <value>
          <see langword="true" /> Jeśli powiązanie danych jest obsługiwana we właściwości zależności, do którego stosuje się te metadane; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość raportuje `false` dla jednej z dwóch warunkach: albo powiązania danych właściwości zależności nie jest dozwolona, ponieważ właściwość zależności jest tylko do odczytu (zgodnie z raportem identyfikatora właściwości zależności nie metadanych), lub wartość inna właściwość metadane, <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>, ma ustawioną wartość `true` w metadanych. Ta właściwość jest ujawniona jako udogodnienie, dzięki czemu nie trzeba sprawdzić zarówno wywołań <xref:System.Windows.DependencyProperty.ReadOnly%2A> i <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>.  
  
 Jeśli próbujesz utworzyć metadanych, który określa, w przeciwnym razie właściwości odczytu/zapisu powinien obsługuje powiązanie danych, określ flagę <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable> (należy zwrócić uwagę niewielką różnicę konwencji nazewnictwa i <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>).  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Poniższy przykład uzyskuje dostęp do metadanych domyślne z różnych zależności pola właściwości, wysyła zapytanie do wartości różnych <xref:System.Windows.FrameworkPropertyMetadata> właściwości oraz informacje są używane do wypełnienia tabeli do zaimplementowania przeglądarką"metadanych".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsNotDataBindable : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy właściwości zależności obsługuje powiązanie danych.</summary>
        <value>
          <see langword="true" /> Jeśli właściwość nie obsługuje wiązania danych; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że ma ustawioną wartość tej właściwości metadanych `true` specjalnie dla właściwości, które nie powinny obsługiwać powiązania danych, mimo iż właściwości odczytu i zapisu. Oczekuje się, że w większości przypadków, w którym zadeklarowano właściwości zależności, wymagane jest powiązanie danych, ponieważ powiązanie danych jest jednym z kluczowych scenariuszy, w których właściwość zależności jest użyteczny. W przeciwieństwie do <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>, to nie tylko zmienić wartość domyślną, która może ulec zmianie w określonym powiązaniu. Ustawienie tej właściwości `true` w metadanych dla właściwości zależności metadanych wyłączy wszystkie powiązania z zastosowanie wartości za pomocą wyrażenia do tej właściwości zależności.  
  
 Powiązanie danych (ponieważ mają one odpowiednich zmienione wartości metody ustawiającej) nie obsługują właściwości zależności tylko do odczytu, ale nadal będzie raportu `false` dla <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>. Jest to spowodowane właściwości, które odpowiadają <xref:System.Windows.FrameworkPropertyMetadataOptions> wartości będzie zgłaszać parzystości z jak metadanych faktycznie ustalono, zamiast zawsze raportowanie nazw właściwości może oznaczać zachowanie wynik końcowy. Aby ustalić, czy danej właściwości zależności pozwala na powiązanie danych, zazwyczaj należy sprawdzić <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> zamiast tego. <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> jest wygodne sprawdzania zarówno <xref:System.Windows.DependencyProperty.ReadOnly%2A> i <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> jako pojedyncza operacja reaguje oczekiwany wynik.  
  
 Właściwości klas pochodnych <xref:System.Windows.PropertyMetadata> są zazwyczaj definiowane w modelu obiektów w trybie odczytu i zapisu. Jest to, dlatego można je dostosować po zainicjowaniu wystąpienia. Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwość zostanie zapieczętować tego wystąpienia metadanych i właściwości, które udzielają szczegółowych informacji o metadanych są teraz uważany za niezmienialny. Trwa próba skonfigurowania tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane już zostały zastosowane do operacji właściwości zależności, dzięki czemu metadanych jest zapieczętowany i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Journal : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy ta właściwość zawiera informacje rejestrowania, aplikacji lub powinny być przechowywane jako część wdrożenia rejestrowania.</summary>
        <value>
          <see langword="true" /> Jeśli rejestrowanie powinien być wykonywany na właściwość zależności stosowany metadanych. w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości klas pochodnych <xref:System.Windows.PropertyMetadata> są zazwyczaj definiowane w modelu obiektów w trybie odczytu i zapisu. Jest to, dlatego można je dostosować po zainicjowaniu wystąpienia. Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwość zostanie zapieczętować tego wystąpienia metadanych i właściwości, które udzielają szczegółowych informacji o metadanych są teraz uważany za niezmienialny. Trwa próba skonfigurowania tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane już zostały zastosowane do operacji właściwości zależności, dzięki czemu metadanych jest zapieczętowany i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="frameworkPropertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">Podstawowy metadanych scalania.</param>
        <param name="dp">Właściwości zależności te metadane są stosowane do.</param>
        <summary>Umożliwia scalania metadanych źródła z metadanymi podstawowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana wewnętrznie, jeśli metadane są zastępowane.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Klasy, które pochodzą z <see cref="T:System.Windows.PropertyMetadata" /> (lub ta klasa szczególnie) powinny przesłaniać tę metodę, aby uwzględnić wszystkie właściwości metadanych dodali do ich implementacji. Na przykład implementacji może dodano nową wartość wyliczenia flagwise i <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementacji następnie powinny mieć możliwość łączenia tych flag poprawnie.  Zawsze należy wywołać Podstawowa implementacja przed własne implementacji, ponieważ Podstawowa implementacja zajmuje się scalanie wszystkie właściwości, które są już zdefiniowane w poprzedniej typy w hierarchii.  Zachowanie dodane przez <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementacja <see cref="T:System.Windows.FrameworkPropertyMetadata" /> jest to, że określone właściwości poziomie struktury WPF w metadanych, takich jak <see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /> są łączone w bitowej lub operacji.  <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> Zachowanie implementuje również zachowanie podczas zastąpienia metadanych właściwości na istniejącej właściwości zależności przez wywołanie metody <see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />., przy użyciu metadanych zastąpienia, która jest <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="frameworkPropertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">Właściwości zależności, do którego zastosowano metadanych.</param>
        <param name="targetType">Typ skojarzony z metadanych, jeśli jest to metadanych określonego typu. Jeśli jest to domyślny metadanych, ta wartość może być <see langword="null" />.</param>
        <summary>Wywoływane, gdy zastosowano te metadane dla właściwości, co oznacza, że metadane jest zapieczętowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszelkie zmienność struktury danych <xref:System.Windows.FrameworkPropertyMetadata> wystąpienia powinien być oznaczony jako niezmienialny po wywołaniu tej metody.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.FrameworkPropertyMetadata" /> Implementacja tej metody nie robi nic poza wywołanie implementacji podstawowej.</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesInheritanceBehavior : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy oceny dziedziczenia wartość właściwości powinien obejmować niektórych bariery zawartości w drzewie logicznym elementów.</summary>
        <value>
          <see langword="true" /> Jeśli wartość dziedziczenia powinien obejmować niektórych bariery zawartości; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Te metadane raporty rzadko stosowana modyfikacji zachowania dziedziczenia wartość właściwości wszystkich obramowań elementów podrzędnych elementu nadrzędnego specjalnych. Canonical Przykładem takich granic jest zawartość <xref:System.Windows.Controls.Frame>, gdzie <xref:System.Windows.Controls.Frame> zawartości może pobrać załadowany ponownie, niezależnie od istnienia <xref:System.Windows.Controls.Frame>. Zachowanie systemu żądanej właściwości jest, że dziedziczenie wartości właściwości nie powinny przenoszenie zawartości <xref:System.Windows.Controls.Frame>, ponieważ te zawartość może być elementów, które hosting ramki aplikacji nie posiadanych lub kontrolowanych. Określanie metadanych z <xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> ustawioną `true`, oraz jak określanie <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> jako `true`, spowoduje, że właściwości, dla którego stosowana jest metadanych być dziedziczone nawet w poprzek <xref:System.Windows.Controls.Frame> granic lub podobne granic.  
  
 Właściwości klas pochodnych <xref:System.Windows.PropertyMetadata> są zazwyczaj definiowane w modelu obiektów w trybie odczytu i zapisu. Jest to, dlatego można je dostosować po zainicjowaniu wystąpienia. Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwość zostanie zapieczętować tego wystąpienia metadanych i właściwości, które udzielają szczegółowych informacji o metadanych są teraz uważany za niezmienialny. Trwa próba skonfigurowania tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane już zostały zastosowane do operacji właściwości zależności, dzięki czemu metadanych jest zapieczętowany i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SubPropertiesDoNotAffectRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy właściwości podrzędne właściwości zależności nie wpływają na renderowanie obiektu zawierającego.</summary>
        <value>
          <see langword="true" /> Jeśli zmiany wartości właściwości podrzędnej nie wpływają na renderowanie, jeśli zostały zmienione; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta opcja metadanych jest odpowiednie dla właściwości zależności, które są typów referencyjnych, lecz tego typu nie ma wartości właściwości własnych. Zazwyczaj logiki systemu układ jest założenie, że wszystkie właściwości zależności podrzędne właściwości potencjalnie wpływają na układ, ponieważ sprawdzanie, czy wszystkie podrzędne właściwości zmian jest więcej czasu niż rzeczywiście uruchomiony inny renderowania przebiegu. Ustawienie tej opcji na `true` przydaje się do optymalizacji wydajności implementacji systemu poziomu układu framework WPF.  
  
 Właściwości klas pochodnych <xref:System.Windows.PropertyMetadata> są zazwyczaj definiowane w modelu obiektów w trybie odczytu i zapisu. Jest to, dlatego można je dostosować po zainicjowaniu wystąpienia. Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwość zostanie zapieczętować tego wystąpienia metadanych i właściwości, które udzielają szczegółowych informacji o metadanych są teraz uważany za niezmienialny. Trwa próba skonfigurowania tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane już zostały zastosowane do operacji właściwości zależności, dzięki czemu metadanych jest zapieczętowany i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>
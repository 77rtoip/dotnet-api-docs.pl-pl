<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ba99bda134572e938946c434092cc0e4d72af0a5" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69434241" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <TypeSignature Language="F#" Value="type FrameworkPropertyMetadata = class&#xA;    inherit UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Raportuje lub stosuje metadane dla właściwości zależności, w tym w celu dodania charakterystyk systemu właściwości specyficznych dla platformy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa pochodzi od <xref:System.Windows.PropertyMetadata> (do <xref:System.Windows.UIPropertyMetadata>). W przypadku większości aplikacji <xref:System.Windows.FrameworkPropertyMetadata> na poziomie platformy WPF Framework jest typem używanym dla metadanych właściwości zależności, a nie podstawowych typów <xref:System.Windows.PropertyMetadata> metadanych lub <xref:System.Windows.UIPropertyMetadata>. Dotyczy to zarówno istniejących właściwości zależności, jak i dla większości scenariuszy niestandardowych właściwości zależności.  
  
 Elementy członkowskie zadeklarowane przez tę klasę, które <xref:System.Windows.PropertyMetadata> uzupełniają klasę bazową, obejmują różne właściwości logiczne, które określają lub raportują zachowanie systemu właściwości na poziomie platformy WPF, takie jak dziedziczenie właściwości, powiązanie danych i układ.  
  
 Kilka sygnatur konstruktorów do tworzenia <xref:System.Windows.FrameworkPropertyMetadata> wystąpienia <xref:System.Windows.FrameworkPropertyMetadataOptions> przyjmuje parametr. Wyliczenie jest używane tylko do określenia początkowego zachowania w konstruktorze i nie jest ujawniane w inny sposób <xref:System.Windows.FrameworkPropertyMetadata> po utworzeniu. <xref:System.Windows.FrameworkPropertyMetadataOptions> Z skonstruowanego wystąpienia można pobrać lub ustawić odpowiednie informacje za pośrednictwem różnych właściwości, które współużytkują nazwę wartości wyliczenia używanych w wywołaniu konstruktora.  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Ta klasa nie jest zwykle używana w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Poniższy przykład pobiera metadane dla właściwości zależności określonego właściciela jako początkowy typ podstawowy <xref:System.Windows.PropertyMetadata> . Metadane są rzutowane na <xref:System.Windows.FrameworkPropertyMetadata>. Jeśli rzutowanie zwróciło prawidłowy <xref:System.Windows.FrameworkPropertyMetadata>, różne <xref:System.Windows.FrameworkPropertyMetadata> wartości właściwości są raportowane za pomocą prostego interfejsu użytkownika (nie pokazano).  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy.</summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten podpis inicjuje wszystkie wartości <xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A> do ich wartości domyślnych właściwości. <xref:System.Windows.PropertyMetadata.DefaultValue%2A>i różne <xref:System.Windows.FrameworkPropertyMetadata> właściwości`false`logicznebędą. `null`  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zazwyczaj określona jako wartość określonego typu.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy z określoną wartością domyślną.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości podanej dla `defaultValue` musi być zgodny lub powiązany z typem określonym w oryginalnej rejestracji właściwości zależności, do której zostaną zastosowane te metadane. Niezgodność między domyślnym typem wartości metadanych a typem właściwości zależności, która jest stosowana, może być trudna do debugowania, ponieważ nie jest wykrywalna podczas kompilacji. System właściwości nie szacuje wartości efektywnej właściwości do momentu uruchomienia, dlatego wynik domyślnego typu wartości/niezgodności typów właściwości jest błędem czasu wykonywania.  
  
 Wartość <xref:System.Windows.DependencyProperty.UnsetValue> ma specjalne znaczenie w systemie właściwości i nie może być używana jako wartość domyślna właściwości zależności.  
  
   
  
## Examples  
 Poniższy przykład wywołuje ten podpis konstruktora:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" />jest ustawiony na <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, którą system właściwości wywoła po każdej zmianie wartości właściwości.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy z określonym <see cref="T:System.Windows.PropertyChangedCallback" /> wywołaniem zwrotnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład wywołuje ten podpis konstruktora:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zazwyczaj określona jako wartość określonego typu.</param>
        <param name="flags">Flagi opcji metadanych (kombinacja <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> wartości). Te opcje określają właściwości zależności, które współpracują z systemami, takimi jak układ lub powiązanie danych.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy z podaną wartością domyślną i opcjami metadanych poziomu platformy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości podanej dla `defaultValue` musi być zgodny lub powiązany z typem określonym w oryginalnej rejestracji właściwości zależności, do której zostaną zastosowane te metadane. Niezgodność między domyślnym typem wartości metadanych a typem właściwości zależności, która jest stosowana, może być trudna do debugowania, ponieważ nie jest wykrywalna podczas kompilacji. System właściwości nie szacuje wartości efektywnej właściwości do momentu uruchomienia, dlatego wynik domyślnego typu wartości/niezgodności typów właściwości jest błędem czasu wykonywania.  
  
 Wartość <xref:System.Windows.DependencyProperty.UnsetValue> ma specjalne znaczenie w systemie właściwości i nie może być używana jako wartość domyślna właściwości zależności.  
  
 Wartości oznaczone `flags` jako flagi zestawu w parametrze spowodują ustawienie <xref:System.Windows.FrameworkPropertyMetadata> wartości logicznej właściwości, które pasują <xref:System.Windows.FrameworkPropertyMetadataOptions> do nazwy tej flagi `true`do. Następnie można zmienić wartości właściwości w metadanych, o ile metadane nie zostały jeszcze zastosowane do określonej operacji systemu właściwości.  
  
   
  
## Examples  
 Poniższy przykład wywołuje ten podpis konstruktora:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" />jest ustawiony na <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zazwyczaj określona jako wartość określonego typu.</param>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, którą system właściwości wywoła po każdej zmianie wartości właściwości.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy za pomocą podanej wartości domyślnej i określonego <see cref="T:System.Windows.PropertyChangedCallback" /> wywołania zwrotnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości podanej dla `defaultValue` musi być zgodny lub powiązany z typem określonym w oryginalnej rejestracji właściwości zależności, do której zostaną zastosowane te metadane. Niezgodność między domyślnym typem wartości metadanych a typem właściwości zależności, która jest stosowana, może być trudna do debugowania, ponieważ nie jest wykrywalna podczas kompilacji. System właściwości nie szacuje wartości efektywnej właściwości do momentu uruchomienia, dlatego wynik domyślnego typu wartości/niezgodności typów właściwości jest błędem czasu wykonywania.  
  
 Wartość <xref:System.Windows.DependencyProperty.UnsetValue> ma specjalne znaczenie w systemie właściwości i nie może być używana jako wartość domyślna właściwości zależności.  
  
   
  
## Examples  
 Poniższy przykład wywołuje ten podpis konstruktora:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" />jest ustawiony na <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, którą system właściwości wywoła po każdej zmianie wartości właściwości.</param>
        <param name="coerceValueCallback">Odwołanie do implementacji programu obsługi zostanie wywołane za każdym razem, gdy system <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> właściwości wywoła tę właściwość zależności.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy z określonymi wywołaniami zwrotnymi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja wywołuje inicjatora podstawowego, a następnie dodaje `coerceValueCallback` przez ustawienie właściwości w wystąpieniu podstawowym.  
  
   
  
## Examples  
 Poniższy przykład wywołuje ten podpis konstruktora:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zazwyczaj określona jako wartość określonego typu.</param>
        <param name="flags">Flagi opcji metadanych (kombinacja <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> wartości). Te opcje określają właściwości zależności, które współpracują z systemami, takimi jak układ lub powiązanie danych.</param>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, którą system właściwości wywoła po każdej zmianie wartości właściwości.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy za pomocą podanej wartości domyślnej i opcji metadanych struktury i określonego <see cref="T:System.Windows.PropertyChangedCallback" /> wywołania zwrotnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości podanej dla `defaultValue` musi być zgodny lub powiązany z typem określonym w oryginalnej rejestracji właściwości zależności, do której zostaną zastosowane te metadane. Niezgodność między domyślnym typem wartości metadanych a typem właściwości zależności, która jest stosowana, może być trudna do debugowania, ponieważ nie jest wykrywalna podczas kompilacji. System właściwości nie szacuje wartości efektywnej właściwości do momentu uruchomienia, dlatego wynik domyślnego typu wartości/niezgodności typów właściwości jest błędem czasu wykonywania.  
  
 Wartość <xref:System.Windows.DependencyProperty.UnsetValue> ma specjalne znaczenie w systemie właściwości i nie może być używana jako wartość domyślna właściwości zależności.  
  
 Wartości oznaczone `flags` jako flagi zestawu w parametrze spowodują ustawienie <xref:System.Windows.FrameworkPropertyMetadata> wartości logicznej właściwości, które pasują <xref:System.Windows.FrameworkPropertyMetadataOptions> do nazwy tej flagi `true`do. Można nadal zmieniać wartości właściwości w metadanych, o ile metadane nie zostały jeszcze zastosowane do określonej operacji systemu właściwości.  
  
   
  
## Examples  
 Poniższy przykład wywołuje ten podpis konstruktora:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" />jest ustawiony na <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zazwyczaj określona jako określony typ.</param>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, którą system właściwości wywoła po każdej zmianie wartości właściwości.</param>
        <param name="coerceValueCallback">Odwołanie do implementacji programu obsługi, która będzie wywoływana za każdym razem, gdy system <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> właściwości wywoła tę właściwość zależności.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy z podaną wartością domyślną i określonymi wywołaniami zwrotnymi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości podanej dla `defaultValue` musi być zgodny lub powiązany z typem określonym w oryginalnej rejestracji właściwości zależności, do której zostaną zastosowane te metadane. Niezgodność między domyślnym typem wartości metadanych a typem właściwości zależności, która jest stosowana, może być trudna do debugowania, ponieważ nie jest wykrywalna podczas kompilacji. System właściwości nie szacuje wartości efektywnej właściwości do momentu uruchomienia, dlatego wynik domyślnego typu wartości/niezgodności typów właściwości jest błędem czasu wykonywania.  
  
 Wartość <xref:System.Windows.DependencyProperty.UnsetValue> ma specjalne znaczenie w systemie właściwości i nie może być używana jako wartość domyślna właściwości zależności.  
  
   
  
## Examples  
 Poniższy przykład wywołuje ten podpis konstruktora:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" />jest ustawiony na <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zazwyczaj określona jako określony typ.</param>
        <param name="flags">Flagi opcji metadanych (kombinacja <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> wartości). Te opcje określają właściwości zależności, które współpracują z systemami, takimi jak układ lub powiązanie danych.</param>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, którą system właściwości wywoła po każdej zmianie wartości właściwości.</param>
        <param name="coerceValueCallback">Odwołanie do implementacji programu obsługi, która będzie wywoływana za każdym razem, gdy system <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> właściwości wywoła tę właściwość.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy z podaną wartością domyślną i opcjami metadanych struktury oraz określonymi wywołaniami zwrotnymi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości podanej dla `defaultValue` musi być zgodny lub powiązany z typem określonym w oryginalnej rejestracji właściwości zależności, do której zostaną zastosowane te metadane. Niezgodność między domyślnym typem wartości metadanych a typem właściwości zależności, która jest stosowana, może być trudna do debugowania, ponieważ nie jest wykrywalna podczas kompilacji. System właściwości nie szacuje wartości efektywnej właściwości do momentu uruchomienia, dlatego wynik domyślnego typu wartości/niezgodności typów właściwości jest błędem czasu wykonywania.  
  
 Wartość <xref:System.Windows.DependencyProperty.UnsetValue> ma specjalne znaczenie w systemie właściwości i nie może być używana jako wartość domyślna właściwości zależności.  
  
 Wartości oznaczone `flags` jako flagi zestawu w parametrze spowodują ustawienie <xref:System.Windows.FrameworkPropertyMetadata> wartości logicznej właściwości, które pasują <xref:System.Windows.FrameworkPropertyMetadataOptions> do nazwy tej flagi `true`do. Można nadal zmieniać wartości właściwości w metadanych, o ile metadane nie zostały jeszcze zastosowane do określonej operacji systemu właściwości.  
  
   
  
## Examples  
 Poniższy przykład wywołuje ten podpis konstruktora:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" />jest ustawiony na <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zazwyczaj określona jako określony typ.</param>
        <param name="flags">Flagi opcji metadanych (kombinacja <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> wartości). Te opcje określają właściwości zależności, które współpracują z systemami, takimi jak układ lub powiązanie danych.</param>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, którą system właściwości wywoła po każdej zmianie wartości właściwości.</param>
        <param name="coerceValueCallback">Odwołanie do implementacji programu obsługi, która będzie wywoływana za każdym razem, gdy system <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> właściwości wywoła tę właściwość zależności.</param>
        <param name="isAnimationProhibited"><see langword="true" />Aby zapobiec animowaniu przez system właściwości właściwości, do której zastosowano te metadane. Takie właściwości spowodują wygenerowanie wyjątku czasu wykonywania pochodzącego z systemu właściwości, jeśli są podejmowane próby wykonania animacji. <see langword="false" />, aby zezwolić na animację właściwości. Wartość domyślna to <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy z podaną wartością domyślną i opcjami metadanych struktury, określonymi wywołaniami zwrotnymi i wartością logiczną, która może być używana do zapobiegania animacji właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości podanej dla `defaultValue` musi być zgodny lub powiązany z typem określonym w oryginalnej rejestracji właściwości zależności, do której zostaną zastosowane te metadane. Niezgodność między domyślnym typem wartości metadanych a typem właściwości zależności, która jest stosowana, może być trudna do debugowania, ponieważ nie jest wykrywalna podczas kompilacji. System właściwości nie szacuje wartości efektywnej właściwości do momentu uruchomienia, dlatego wynik domyślnego typu wartości/niezgodności typów właściwości jest błędem czasu wykonywania.  
  
 Wartość <xref:System.Windows.DependencyProperty.UnsetValue> ma specjalne znaczenie w systemie właściwości i nie może być używana jako wartość domyślna właściwości zależności.  
  
 Parametr ustawia początkową wartość <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> właściwości zadeklarowanej przez bezpośrednią klasę bazową <xref:System.Windows.UIPropertyMetadata>. `isAnimationProhibited`  
  
 Wartości oznaczone `flags` jako flagi zestawu w parametrze spowodują ustawienie <xref:System.Windows.FrameworkPropertyMetadata> wartości logicznej właściwości, które pasują <xref:System.Windows.FrameworkPropertyMetadataOptions> do nazwy tej flagi `true`do. Można nadal zmieniać wartości właściwości w metadanych, o ile metadane nie zostały jeszcze zastosowane do określonej operacji systemu właściwości.  
  
   
  
## Examples  
 Poniższy przykład wywołuje ten podpis konstruktora:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" />jest ustawiony na <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool * System.Windows.Data.UpdateSourceTrigger -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited, defaultUpdateSourceTrigger)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zazwyczaj określona jako określony typ.</param>
        <param name="flags">Flagi opcji metadanych (kombinacja <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> wartości). Te opcje określają właściwości zależności, które współpracują z systemami, takimi jak układ lub powiązanie danych.</param>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, którą system właściwości wywoła po każdej zmianie wartości właściwości.</param>
        <param name="coerceValueCallback">Odwołanie do implementacji programu obsługi, która będzie wywoływana za każdym razem, gdy system <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> właściwości wywoła tę właściwość.</param>
        <param name="isAnimationProhibited"><see langword="true" />Aby zapobiec animowaniu przez system właściwości właściwości, do której zastosowano te metadane. Takie właściwości spowodują wygenerowanie wyjątku czasu wykonywania pochodzącego z systemu właściwości, jeśli są podejmowane próby wykonania animacji. Wartość domyślna to <see langword="false" />.</param>
        <param name="defaultUpdateSourceTrigger">Używane, gdy są stosowane powiązania dla tej właściwości, które <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> mają ustawioną wartość <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />. <see cref="T:System.Windows.Data.UpdateSourceTrigger" /></param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.FrameworkPropertyMetadata" /> klasy z podaną wartością domyślną i opcjami metadanych struktury, określonymi wywołaniami zwrotnymi, wartością logiczną, która może służyć do zapobiegania animacji właściwości oraz domyślnego wyzwalacza aktualizacji powiązania danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości podanej dla `defaultValue` musi być zgodny lub powiązany z typem określonym w oryginalnej rejestracji właściwości zależności, do której zostaną zastosowane te metadane. Niezgodność między domyślnym typem wartości metadanych a typem właściwości zależności, która jest stosowana, może być trudna do debugowania, ponieważ nie jest wykrywalna podczas kompilacji. System właściwości nie szacuje wartości efektywnej właściwości do momentu uruchomienia, dlatego wynik domyślnego typu wartości/niezgodności typów właściwości jest błędem czasu wykonywania.  
  
 Wartość <xref:System.Windows.DependencyProperty.UnsetValue> ma specjalne znaczenie w systemie właściwości i nie może być używana jako wartość domyślna właściwości zależności.  
  
 Parametr ustawia początkową wartość <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> właściwości zadeklarowanej przez bezpośrednią klasę bazową <xref:System.Windows.UIPropertyMetadata>. `isAnimationProhibited`  
  
 Aby uzyskać więcej informacji na temat zachowania źródła aktualizacji dla powiązań, zobacz temat [powiązanie danych — omówienie](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 Wartości oznaczone `flags` jako flagi zestawu w parametrze spowodują ustawienie <xref:System.Windows.FrameworkPropertyMetadata> wartości logicznej właściwości, które pasują <xref:System.Windows.FrameworkPropertyMetadataOptions> do nazwy tej flagi `true`do. Można nadal zmieniać wartości właściwości w metadanych, o ile metadane nie zostały jeszcze zastosowane do określonej operacji systemu właściwości.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" />jest ustawiony na <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy właściwość zależności może mieć wpływ na przebieg rozmieszczenia podczas operacji aparatu układu.</summary>
        <value><see langword="true" />Jeśli właściwość zależności, na której istnieją metadane, prawdopodobnie ma wpływ na przebieg rozmieszczenia; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement>i <xref:System.Windows.FrameworkContentElement> obejmują<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> implementację, która monitoruje zmiany wartości efektywnej we wszystkich właściwościach zależności istniejących w elemencie. W ramach tej logiki właściwości zależności, które zmieniają wartość skuteczną i mają metadane z <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> ustawionym `true` na zainicjują odroczone żądanie unieważnienia wizualizacji tego elementu (wywołanie do <xref:System.Windows.UIElement.InvalidateArrange%2A>). Ponieważ ta implementacja na poziomie platformy WPF jest już na miejscu, zazwyczaj nie trzeba szukać właściwości <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> zależności, chyba że istotnie zastąpi lub zmodyfikujesz zachowanie układu platformy WPF.  
  
 Implementacje niestandardowe <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> mogą mieć podobne zachowanie w przypadku zmian właściwości zależności, <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> gdzie `true`is.  
  
 Właściwości klas <xref:System.Windows.PropertyMetadata> pochodnych są zwykle zdefiniowane w modelu obiektów jako do odczytu i zapisu. Jest to tak więc, aby można je było dostosować po zainicjowaniu wystąpienia. Jednak po wykorzystaniu metadanych jako części wywołania metody <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości spowoduje, że wystąpienie metadanych i właściwości, które przekażą określone metadane, są teraz traktowane jako niezmienne. Próba ustawienia tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> znajduje się `true` w tym wystąpieniu metadanych spowoduje wystąpienie wyjątku.  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w programie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Poniższy przykład pobiera domyślne metadane z różnych pól właściwości zależności, wysyła zapytanie do wartości różnych <xref:System.Windows.FrameworkPropertyMetadata> właściwości, a następnie używa informacji do wypełniania tabeli w celu zaimplementowania "przeglądarki metadanych".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane zostały już zastosowane do operacji właściwości zależności, dlatego metadane są zapieczętowane i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy właściwość zależności może wpływać na przebieg pomiaru podczas operacji aparatu układu.</summary>
        <value><see langword="true" />Jeśli właściwość zależności, na której istnieją metadane, może mieć wpływ na przebieg pomiaru; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement>i <xref:System.Windows.FrameworkContentElement> obejmują<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> implementację, która monitoruje zmiany wartości efektywnej we wszystkich właściwościach zależności istniejących w elemencie. W ramach tej logiki właściwości zależności, które zmieniają wartość skuteczną i mają metadane z <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> ustawionym `true` na zainicjują odroczone żądanie unieważnienia wizualizacji dla tego elementu. Ponieważ ta implementacja na poziomie platformy WPF jest już na miejscu, zazwyczaj nie trzeba szukać właściwości <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> zależności, chyba że istotnie zastąpi lub zmodyfikujesz zachowanie układu platformy WPF.  
  
 Implementacje niestandardowe <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> mogą mieć podobne zachowanie w przypadku zmian właściwości zależności, <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> gdzie `true`is.  
  
 Właściwości klas <xref:System.Windows.PropertyMetadata> pochodnych są zwykle zdefiniowane w modelu obiektów jako do odczytu i zapisu. Jest to tak więc, aby można je było dostosować po zainicjowaniu wystąpienia. Jednak po wykorzystaniu metadanych jako części wywołania metody <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości spowoduje, że wystąpienie metadanych i właściwości, które przekażą określone metadane, są teraz traktowane jako niezmienne. Próba ustawienia tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> znajduje się `true` w tym wystąpieniu metadanych spowoduje wystąpienie wyjątku.  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]programie.  
  
   
  
## Examples  
 Poniższy przykład pobiera domyślne metadane z różnych pól właściwości zależności, wysyła zapytanie do wartości różnych <xref:System.Windows.FrameworkPropertyMetadata> właściwości, a następnie używa informacji do wypełniania tabeli w celu zaimplementowania "przeglądarki metadanych".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane zostały już zastosowane do operacji właściwości zależności, dlatego metadane są zapieczętowane i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy właściwość zależności może wpływać na przebieg układu elementu nadrzędnego w trakcie operacji aparatu układu.</summary>
        <value><see langword="true" />Jeśli właściwość zależności, na której istnieją metadane, prawdopodobnie ma wpływ na przebieg uporządkowany w odniesieniu do jego elementu nadrzędnego; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement>i <xref:System.Windows.FrameworkContentElement> obejmują<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> implementację, która monitoruje zmiany wartości efektywnej we wszystkich właściwościach zależności istniejących w elemencie. W ramach tej logiki właściwości zależności, które zmieniają wartość skuteczną i mają metadane z <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> ustawionym `true` na zainicjują odroczone żądanie unieważnienia wizualizacji dla elementu nadrzędnego.  
  
 Ogólnie rzecz biorąc, <xref:System.Windows.FrameworkElement> nie trzeba raportować zmian właściwości do elementu nadrzędnego przy użyciu <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> , ponieważ sam element byłby `true`już własny <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> . Jest to zwykle wystarczające, ponieważ zmiany w elemencie podrzędnym zwykle inicjują rozmieszczenie obiektów nadrzędnych, gdy jest to konieczne. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>jest czasami używany dla <xref:System.Windows.FrameworkContentElement> klasy pochodnej. W tym przypadku element podrzędny ustawia właściwość, ale <xref:System.Windows.FrameworkContentElement> Klasa pochodna nie kontroluje własnego renderowania. Renderowanie jest obsługiwane przez <xref:System.Windows.FrameworkElement> element nadrzędny, który służy jako host zawartości. Na przykład zmiana wartości <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> właściwości dołączonej przez element podrzędny unieważnia kolejność elementu nadrzędnego, ponieważ należy zmienić położenie elementu podrzędnego w elemencie nadrzędnym. W związku z <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> tym dołączona właściwość zawiera <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> metadane `true`, gdzie is. Innym przykładem <xref:System.Windows.Controls.Control.Padding%2A>jest; w przypadku zmiany tej właściwości element nadrzędny może zmienić położenie elementu podrzędnego, w zależności od dostępnego miejsca.  
  
 Ponieważ ta implementacja na poziomie platformy WPF jest już na miejscu, zazwyczaj nie trzeba szukać właściwości <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> zależności, chyba że istotnie zastąpi lub zmodyfikujesz zachowanie układu platformy WPF.  
  
 Implementacje niestandardowe <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> mogą mieć podobne zachowanie w przypadku zmian właściwości zależności, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> gdzie `true`is.  
  
 Właściwości dla wszystkich klas <xref:System.Windows.PropertyMetadata> pochodnych są zwykle zdefiniowane w modelu obiektów jako do odczytu i zapisu. Jest to tak więc, aby można je było dostosować po zainicjowaniu wystąpienia. Jednak po wykorzystaniu metadanych jako części wywołania metody <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości spowoduje, że wystąpienie metadanych i właściwości, które przekażą określone metadane, są teraz traktowane jako niezmienne. Próba ustawienia tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> znajduje się `true` w tym wystąpieniu metadanych spowoduje wystąpienie wyjątku.  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]programie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane zostały już zastosowane do operacji właściwości zależności, dlatego metadane są zapieczętowane i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy właściwość zależności może wpływać na przebieg pomiaru układu elementu nadrzędnego w trakcie operacji aparatu układu.</summary>
        <value><see langword="true" />Jeśli właściwość zależności, na której istnieją metadane, prawdopodobnie ma wpływ na przebieg pomiaru w odniesieniu do jego elementu nadrzędnego; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement>i <xref:System.Windows.FrameworkContentElement> obejmują<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> implementację, która monitoruje zmiany wartości efektywnej we wszystkich właściwościach zależności istniejących w elemencie. W ramach tej logiki właściwości zależności, które zmieniają wartość skuteczną i mają metadane z <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> ustawionym `true` na zainicjują odroczone żądanie unieważnienia wizualizacji dla elementu nadrzędnego. Ponieważ ta implementacja na poziomie platformy WPF jest już na miejscu, zazwyczaj nie trzeba szukać właściwości <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> zależności, chyba że istotnie zastąpi lub zmodyfikujesz zachowanie układu platformy WPF.  
  
 Ogólnie rzecz biorąc, <xref:System.Windows.FrameworkElement> nie trzeba raportować zmian właściwości do elementu nadrzędnego przy użyciu <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> , ponieważ sam element byłby `true`już własny <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> . Jest to zwykle wystarczające, ponieważ zmiany w elemencie podrzędnym zwykle inicjują w razie potrzeby miarę nadrzędne. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>jest czasami używany dla <xref:System.Windows.FrameworkContentElement> klasy pochodnej. W tym przypadku element podrzędny ustawia właściwość, ale <xref:System.Windows.FrameworkContentElement> Klasa pochodna nie kontroluje własnego renderowania. Renderowanie jest obsługiwane przez <xref:System.Windows.FrameworkElement> element nadrzędny, który służy jako host zawartości. Na przykład zmiana wartości <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> właściwości przez element podrzędny unieważnia miarę elementu nadrzędnego, ponieważ względne Odstępy akapitu mogą ulec zmianie i mogą zwiększyć lub zmniejszyć rozmiar hosta zawartości. W związku z <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> tym Właściwość zawiera metadane <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> , `true`gdzie is.  
  
 Elementy hosta zawartości często wyszukują zmiany we właściwościach zależności, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> gdzie `true`is jest częścią logiki renderowania hosta zawartości. Na przykład <xref:System.Windows.Controls.TextBox> element musi odpowiedzieć na pewne zmiany w tekście, które mogą wymagać zmiany pola <xref:System.Windows.Controls.TextBox> ograniczenia samego siebie.  
  
 Implementacje niestandardowe <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> mogą mieć podobne zachowanie w przypadku zmian właściwości zależności, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> gdzie `true`is.  
  
 Właściwości dla wszystkich klas <xref:System.Windows.PropertyMetadata> pochodnych są zwykle zdefiniowane w modelu obiektów jako do odczytu i zapisu. Jest to tak więc, aby można je było dostosować po zainicjowaniu wystąpienia. Jednak po wykorzystaniu metadanych jako części wywołania metody <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości spowoduje, że wystąpienie metadanych i właściwości, które przekażą określone metadane, są teraz traktowane jako niezmienne. Próba ustawienia tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> znajduje się `true` w tym wystąpieniu metadanych spowoduje wystąpienie wyjątku.  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]programie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane zostały już zastosowane do operacji właściwości zależności, dlatego metadane są zapieczętowane i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy właściwość zależności może wpływać na układ ogólny w jakiś sposób, który nie wpływa na porozumienie lub pomiar, ale wymaga ponownego rysowania.</summary>
        <value><see langword="true" />Jeśli właściwość zależności, na której istnieją metadane, ma wpływ na renderowanie; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement>i <xref:System.Windows.FrameworkContentElement> obejmują<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> implementację, która monitoruje zmiany wartości efektywnej we wszystkich właściwościach zależności istniejących w elemencie. W ramach tej logiki właściwości zależności, które zmieniają wartość skuteczną i mają metadane z <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> ustawionym `true` na zainicjują odroczone żądanie unieważnienia wizualizacji dla tego elementu. Ponieważ ta implementacja na poziomie platformy WPF jest już na miejscu, zazwyczaj nie trzeba szukać właściwości <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> zależności, chyba że istotnie zastąpi lub zmodyfikujesz zachowanie układu platformy WPF.  
  
 Implementacje niestandardowe <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> mogą mieć podobne zachowanie w przypadku zmian właściwości zależności, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> gdzie `true`is.  
  
 Właściwości dla wszystkich klas <xref:System.Windows.PropertyMetadata> pochodnych są zwykle zdefiniowane w modelu obiektów jako do odczytu i zapisu. Jest to tak więc, aby można je było dostosować po zainicjowaniu wystąpienia. Jednak po wykorzystaniu metadanych jako części wywołania metody <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości spowoduje, że wystąpienie metadanych i właściwości, które przekażą określone metadane, są teraz traktowane jako niezmienne. Próba ustawienia tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> znajduje się `true` w tym wystąpieniu metadanych spowoduje wystąpienie wyjątku.  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]programie.  
  
   
  
## Examples  
 Poniższy przykład pobiera domyślne metadane z różnych pól właściwości zależności, wysyła zapytanie do wartości różnych <xref:System.Windows.FrameworkPropertyMetadata> właściwości, a następnie używa informacji do wypełniania tabeli w celu zaimplementowania "przeglądarki metadanych".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane zostały już zastosowane do operacji właściwości zależności, dlatego metadane są zapieczętowane i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BindsTwoWayByDefault : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy właściwość domyślnie wiąże się z dwukierunkową.</summary>
        <value><see langword="true" />Jeśli właściwość zależności, w której te metadane istnieje, domyślnie tworzy powiązanie dwukierunkowe; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku braku tej właściwości `true`, aktualizacje powiązań są domyślnie jednokierunkowe, na podstawie domyślnego zachowania <xref:System.Windows.Data.Binding> konstruktorów lub równoważnej [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] składni.  
  
 W istniejących elementach zwykle ta właściwość jest ustawiana na wartość `true` w metadanych dla właściwości zależności, których stan raportu i można modyfikować za pomocą akcji użytkownika, na <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>przykład.  
  
 Ta właściwość tylko raportuje domyślną charakterystykę aktualizacji powiązań właściwości zależności. Wszystkie powiązania ustawione na tę właściwość w wystąpieniu mogą lokalnie ustawić <xref:System.Windows.Data.Binding.Mode%2A> właściwość powiązania i zmienić to ustawienie domyślne.  
  
 Właściwości dla wszystkich klas <xref:System.Windows.PropertyMetadata> pochodnych są zwykle zdefiniowane w modelu obiektów jako do odczytu i zapisu. Jest to tak więc, aby można je było dostosować po zainicjowaniu wystąpienia. Jednak po wykorzystaniu metadanych jako części wywołania metody <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości spowoduje, że wystąpienie metadanych i właściwości, które przekażą określone metadane, są teraz traktowane jako niezmienne. Próba ustawienia tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> znajduje się `true` w tym wystąpieniu metadanych spowoduje wystąpienie wyjątku.  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]programie.  
  
   
  
## Examples  
 Poniższy przykład pobiera domyślne metadane z różnych pól właściwości zależności, wysyła zapytanie do wartości różnych <xref:System.Windows.FrameworkPropertyMetadata> właściwości, a następnie używa informacji do wypełniania tabeli w celu zaimplementowania "przeglądarki metadanych".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane zostały już zastosowane do operacji właściwości zależności, dlatego metadane są zapieczętowane i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultUpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia domyślną <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> wartość, która ma być używana podczas stosowania powiązań dla właściwości z tymi metadanymi, które <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> mają ustawioną wartość <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</summary>
        <value>Wartość wyliczenia, inna niż <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości klas <xref:System.Windows.PropertyMetadata> pochodnych są zwykle zdefiniowane w modelu obiektów jako do odczytu i zapisu. Jest to tak więc, aby można je było dostosować po zainicjowaniu wystąpienia. Jednak po wykorzystaniu metadanych jako części wywołania metody <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości spowoduje, że wystąpienie metadanych i właściwości, które przekażą określone metadane, są teraz traktowane jako niezmienne. Próba ustawienia tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> znajduje się `true` w tym wystąpieniu metadanych spowoduje wystąpienie wyjątku.  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]programie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ta właściwość jest ustawiona na <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />wartość; Przypuśćmy, że ustawianą wartością domyślną będzie żądana przez powiązania.</exception>
        <exception cref="T:System.InvalidOperationException">Metadane zostały już zastosowane do operacji właściwości zależności, dlatego metadane są zapieczętowane i nie można ustawić właściwości metadanych.</exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Inherits : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy wartość właściwości zależności jest dziedziczenia.</summary>
        <value><see langword="true" />Jeśli wartość właściwości jest dziedziczenia; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dziedziczenie wartości właściwości jest funkcją [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] systemu właściwości na poziomie platformy WPF, zgodnie z którym niektóre właściwości zależności mogą być ustawiane lokalnie dla elementu w katalogu głównym [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] drzewa elementu, a następnie mieć wartość dziedziczoną przez wszystkie elementy w drzewie logicznym elementów podrzędnych, które również posiadają tę właściwość. Dziedziczenie wartości właściwości nie jest domyślnie włączone i włączenie jej ma wpływ na wydajność. Aby uzyskać szczegółowe informacje, zobacz [dziedziczenie wartości właściwości](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
> [!NOTE]
>  Chociaż dziedziczenie wartości właściwości może wydawać się niedołączonymi właściwościami zależności, zachowanie dziedziczenia dla niedołączonej właściwości przy użyciu określonych oddziałów obiektów obiektu w drzewie środowiska uruchomieniowego jest niezdefiniowane. Zawsze używaj <xref:System.Windows.DependencyProperty.RegisterAttached%2A> do rejestrowania właściwości, które są <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> określone w metadanych.  
  
 Właściwości klas <xref:System.Windows.PropertyMetadata> pochodnych są zwykle zdefiniowane w modelu obiektów jako do odczytu i zapisu. Jest to tak więc, aby można je było dostosować po zainicjowaniu wystąpienia. Jednak po wykorzystaniu metadanych jako części wywołania metody <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości spowoduje, że wystąpienie metadanych i właściwości, które przekażą określone metadane, są teraz traktowane jako niezmienne. Próba ustawienia tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> znajduje się `true` w tym wystąpieniu metadanych spowoduje wystąpienie wyjątku.  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]programie.  
  
   
  
## Examples  
 Poniższy przykład pobiera domyślne metadane z różnych pól właściwości zależności, wysyła zapytanie do wartości różnych <xref:System.Windows.FrameworkPropertyMetadata> właściwości, a następnie używa informacji do wypełniania tabeli w celu zaimplementowania "przeglądarki metadanych".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane zostały już zastosowane do operacji właściwości zależności, dlatego metadane są zapieczętowane i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDataBindingAllowed : bool" Usage="System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wiązanie danych jest obsługiwane dla właściwości zależności.</summary>
        <value><see langword="true" />Jeśli powiązanie danych jest obsługiwane we właściwości zależności, której dotyczą te metadane; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zgłasza `false` jeden z dwóch możliwych warunków: powiązanie danych z właściwością zależności jest niedozwolone, ponieważ właściwość zależności jest tylko do odczytu (zgodnie z identyfikatorem właściwości zależności, a nie z metadanymi) lub wartością inna Właściwość metadanych, <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>, jest ustawiona na `true` wartość w tych metadanych. Ta właściwość jest narażona na wygodę, aby wywołujący nie musieli sprawdzać jednocześnie <xref:System.Windows.DependencyProperty.ReadOnly%2A> i <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>.  
  
 Jeśli podjęto próbę utworzenia metadanych, które określają, że właściwość odczytu/zapisu nie powinna obsługiwać powiązania danych, należy określić flagę <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable> (należy zwrócić uwagę na niewielką różnicę <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>konwencji nazewnictwa a).  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]programie.  
  
   
  
## Examples  
 Poniższy przykład pobiera domyślne metadane z różnych pól właściwości zależności, wysyła zapytanie do wartości różnych <xref:System.Windows.FrameworkPropertyMetadata> właściwości, a następnie używa informacji do wypełniania tabeli w celu zaimplementowania "przeglądarki metadanych".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsNotDataBindable : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy właściwość zależności obsługuje powiązanie danych.</summary>
        <value><see langword="true" />Jeśli właściwość nie obsługuje powiązania danych; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że ta właściwość metadanych jest `true` ustawiona na wartość specyficzną dla właściwości, które nie powinny obsługiwać powiązań danych, mimo że nie są właściwościami odczytu i zapisu. Oczekuje się, że w większości przypadków, gdy właściwość zależności jest zadeklarowana, powiązanie danych jest odpowiednie, ponieważ powiązanie danych jest jednym z kluczowych scenariuszy, w których właściwość zależności jest przydatna. W przeciwieństwie do <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>nie powoduje to jedynie zmiany domyślnego, który można później zmienić dla określonego powiązania. Ustawienie tej właściwości `true` w metadanych metadanych właściwości zależności spowoduje wyłączenie wszystkich powiązań z zastosowaniem ich wartości za pośrednictwem wyrażeń do tej właściwości zależności.  
  
 Właściwości zależności tylko do odczytu nie obsługują powiązań danych (ponieważ nie mają metody ustawiającej, która może stosować zmienione wartości), ale nadal będzie `false` zgłaszać <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>. Wynika to z faktu, że właściwości <xref:System.Windows.FrameworkPropertyMetadataOptions> , które odpowiadają wartości, będą raportować parzystość z zachowaniem metadanych, zamiast zawsze zgłaszać wynik końcowy, który może oznaczać, że nazwa właściwości. Aby określić, czy dana właściwość zależności zezwala na powiązanie danych, zamiast tego należy <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> zawsze sprawdzać. <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A>jest wygodą do sprawdzania obu <xref:System.Windows.DependencyProperty.ReadOnly%2A> i <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> jako jednej operacji, co daje oczekiwany wynik.  
  
 Właściwości klas <xref:System.Windows.PropertyMetadata> pochodnych są zwykle zdefiniowane w modelu obiektów jako do odczytu i zapisu. Jest to tak więc, aby można je było dostosować po zainicjowaniu wystąpienia. Jednak po wykorzystaniu metadanych jako części wywołania metody <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości spowoduje, że wystąpienie metadanych i właściwości, które przekażą określone metadane, są teraz traktowane jako niezmienne. Próba ustawienia tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> znajduje się `true` w tym wystąpieniu metadanych spowoduje wystąpienie wyjątku.  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]programie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane zostały już zastosowane do operacji właściwości zależności, dlatego metadane są zapieczętowane i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Journal : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy ta właściwość zawiera informacje dotyczące rejestrowania, które aplikacje mogą lub powinny być przechowywane w ramach implementacji rejestrowania.</summary>
        <value><see langword="true" />Jeśli należy wykonać dziennik na właściwości zależności, do której zastosowano te metadane; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości klas <xref:System.Windows.PropertyMetadata> pochodnych są zwykle zdefiniowane w modelu obiektów jako do odczytu i zapisu. Jest to tak więc, aby można je było dostosować po zainicjowaniu wystąpienia. Jednak po wykorzystaniu metadanych jako części wywołania metody <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości spowoduje, że wystąpienie metadanych i właściwości, które przekażą określone metadane, są teraz traktowane jako niezmienne. Próba ustawienia tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> znajduje się `true` w tym wystąpieniu metadanych spowoduje wystąpienie wyjątku.  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]programie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane zostały już zastosowane do operacji właściwości zależności, dlatego metadane są zapieczętowane i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="frameworkPropertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">Podstawowe metadane do scalenia.</param>
        <param name="dp">Właściwość zależności, do której są stosowane metadane.</param>
        <summary>Włącza scalanie metadanych źródłowych z podstawowymi metadanymi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana wewnętrznie w przypadku przesłaniania metadanych.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Klasy, które pochodzą <see cref="T:System.Windows.PropertyMetadata" /> z (lub klasy szczególnie), powinny zastąpić tę metodę w celu uwzględnienia wszelkich właściwości metadanych, które zostały dodane do ich implementacji. Na przykład Twoja implementacja mogła dodać nową wartość wyliczenia flagwise, a <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementacja powinna mieć możliwość poprawnego łączenia tych flag.  
  
Zawsze należy wywoływać implementację podstawową przed własną implementacją, ponieważ podstawowa implementacja ma na celu scalanie wszystkich właściwości, które są już zdefiniowane w poprzednich typach w hierarchii.  
  
Zachowanie dodane przez <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementację w programie <see cref="T:System.Windows.FrameworkPropertyMetadata" /> polega na tym, że określone właściwości na poziomie platformy WPF w metadanych <see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /> , takie jak są łączone w operacji bitowej lub.  
  
Zachowanie implementuje również zachowanie podczas przesłonięcia metadanych właściwości we właściwości zależności istniejącej przez wywołanie <see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />, <see cref="T:System.Windows.FrameworkPropertyMetadata" />przy użyciu zastąpień metadanych. <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /></para></block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="frameworkPropertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">Właściwość zależności, do której zastosowano metadane.</param>
        <param name="targetType">Typ skojarzony z tymi metadanymi, jeśli jest to metadane specyficzne dla określonego typu. Jeśli jest to metadane domyślne, ta wartość może być <see langword="null" />równa.</param>
        <summary>Wywoływana, gdy te metadane zostały zastosowane do właściwości, co oznacza, że metadane są zapieczętowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie zmienność struktury <xref:System.Windows.FrameworkPropertyMetadata> danych wystąpienia powinny być oznaczone jako niezmienne w przypadku wywołania tej metody.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="T:System.Windows.FrameworkPropertyMetadata" /> Implementacja tej metody nie wykonuje żadnych operacji poza wywołaniem podstawowej implementacji.</para></block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesInheritanceBehavior : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy Ocena dziedziczenia wartości właściwości powinna obejmować między określonymi granicami zawartości w drzewie logicznym elementów.</summary>
        <value><see langword="true" />Jeśli dziedziczenie wartości właściwości powinno obejmować między pewnymi granicami zawartości; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Te metadane raportują rzadko stosowane modyfikacje zachowania dziedziczenia wartości właściwości między specjalnym elementem nadrzędnym — granic elementów podrzędnych. Przykładem kanonicznym takiej granicy jest zawartość <xref:System.Windows.Controls.Frame>, w <xref:System.Windows.Controls.Frame> której zawartość może zostać załadowana ponownie niezależnie <xref:System.Windows.Controls.Frame>od istnienia. Żądane zachowanie systemu właściwości polega na tym, że dziedziczenie wartości właściwości nie powinno przechodzić do zawartości <xref:System.Windows.Controls.Frame>, ponieważ mogą to być elementy, które aplikacja obsługująca ramkę nie jest właścicielem ani nie kontroluje. Określenie <xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> metadanych mających <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> `true`ustawioną wartość, a także określenie `true`jako, spowoduje, że właściwość, w której zastosowano metadane, ma być dziedziczenia nawet <xref:System.Windows.Controls.Frame> przez granicę lub podobne granice.  
  
 Właściwości klas <xref:System.Windows.PropertyMetadata> pochodnych są zwykle zdefiniowane w modelu obiektów jako do odczytu i zapisu. Jest to tak więc, aby można je było dostosować po zainicjowaniu wystąpienia. Jednak po wykorzystaniu metadanych jako części wywołania metody <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości spowoduje, że wystąpienie metadanych i właściwości, które przekażą określone metadane, są teraz traktowane jako niezmienne. Próba ustawienia tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> znajduje się `true` w tym wystąpieniu metadanych spowoduje wystąpienie wyjątku.  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]programie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane zostały już zastosowane do operacji właściwości zależności, dlatego metadane są zapieczętowane i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SubPropertiesDoNotAffectRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy właściwości podrzędne właściwości Dependency nie wpływają na renderowanie zawierającego go obiektu.</summary>
        <value><see langword="true" />Jeśli zmiany wartości właściwości podrzędnych nie wpływają na renderowanie, Jeśli zmieniono; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta opcja metadanych jest przydatna dla właściwości zależności, które są typami odwołań, w których ten typ ma własne wartości właściwości. Zazwyczaj logika systemu układu polega na założeniu, że każda właściwość zależności z właściwościami podrzędnymi potencjalnie wpłynie na układ, ponieważ sprawdzanie wszystkich właściwości podrzędnych dla zmian jest czasochłonne niż w przypadku rzeczywistego uruchamiania innego przebiegu renderowania. Ustawienie tej opcji na `true` jest przydatne w celu optymalizacji wydajności implementacji systemu układu platformy WPF Framework.  
  
 Właściwości klas <xref:System.Windows.PropertyMetadata> pochodnych są zwykle zdefiniowane w modelu obiektów jako do odczytu i zapisu. Jest to tak więc, aby można je było dostosować po zainicjowaniu wystąpienia. Jednak po wykorzystaniu metadanych jako części wywołania metody <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości spowoduje, że wystąpienie metadanych i właściwości, które przekażą określone metadane, są teraz traktowane jako niezmienne. Próba ustawienia tej właściwości po <xref:System.Windows.PropertyMetadata.IsSealed%2A> znajduje się `true` w tym wystąpieniu metadanych spowoduje wystąpienie wyjątku.  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tej klasy nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]programie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metadane zostały już zastosowane do operacji właściwości zależności, dlatego metadane są zapieczętowane i nie można ustawić właściwości metadanych.</exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>

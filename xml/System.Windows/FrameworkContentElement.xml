<Type Name="FrameworkContentElement" FullName="System.Windows.FrameworkContentElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="40cb4d0e0e1a1ec18d9f9eb8795432cc852a95c3" /><Meta Name="ms.sourcegitcommit" Value="74239f3977d28923e5020663db2c4e91601bea79" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/24/2019" /><Meta Name="ms.locfileid" Value="68439491" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkContentElement&#xA;Inherits ContentElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkContentElement : System::Windows::ContentElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkContentElement = class&#xA;    inherit ContentElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.ContentElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see cref="T:System.Windows.FrameworkContentElement" />jest implementacją na poziomie platformy WPF i rozszerzeniem <see cref="T:System.Windows.ContentElement" /> klasy bazowej. <see cref="T:System.Windows.FrameworkContentElement" />dodaje obsługę dodatkowych wejściowych interfejsów API (w tym etykietek narzędzi i menu kontekstowych), scenorysów, kontekstu danych dla powiązania danych, obsługi stylów i interfejsów API pomocnika drzewa logicznego.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement>nie definiuje jeszcze własnych zachowań renderowania; utworzenie wystąpienia rzeczywistego <xref:System.Windows.FrameworkContentElement> wystąpienia klasy w kodzie lub znacznik jest możliwe, ale [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] w aplikacji [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]nie są wyświetlane żadne elementy. Logika renderowania musi być dostarczana przez klasy <xref:System.Windows.FrameworkContentElement> , które mają elementy podrzędne jako część modelu zawartości <xref:System.Windows.FrameworkContentElement> lub klasy pochodne.  
  
 <xref:System.Windows.FrameworkContentElement>celowo Parallels wiele z tych samych [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] jako <xref:System.Windows.FrameworkElement>. Należy zauważyć, [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] że niektóre <xref:System.Windows.FrameworkElement> znalezione na nie będą <xref:System.Windows.FrameworkContentElement> miały odpowiednika. Niektóre z <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] nich są przeznaczone do funkcji, takich jak reprezentacja geometryczna lub układ, które nie <xref:System.Windows.FrameworkContentElement>są istotne dla.  
  
 Większość istniejących <xref:System.Windows.FrameworkContentElement> klas pochodnych zostanie znalezionych <xref:System.Windows.Documents> w przestrzeni nazw. Wiele z tych klas pochodnych implementuje elementy dla modelu dokumentu przepływu. Niektóre klasy pochodne, takie <xref:System.Windows.Documents.Hyperlink> jak posiadają pewne funkcje podobne do kontroli, ale pochodzą od <xref:System.Windows.FrameworkContentElement> takich elementów, które mogą nadal uczestniczyć w modelu dokumentu przepływu.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.FrameworkElement" />
    <altmember cref="T:System.Windows.ContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkContentElement" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Element podrzędny, który ma zostać dodany.</param>
        <summary>Dodaje podany element jako element podrzędny tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może zgłosić wyjątek, jeśli zostanie wywołana w czasie, gdy Drzewo logiczne zostanie powtórzone przez inny proces.  
  
 Większość <xref:System.Windows.FrameworkContentElement> klas pochodnych uwidacznia dedykowane kolekcje, które są odpowiedzialne za zawieranie ( <xref:System.Windows.Documents.Span.Inlines%2A> na przykład <xref:System.Windows.Documents.Span> w klasie; <xref:System.Windows.Documents.Section.Blocks%2A> na klasie).<xref:System.Windows.Documents.Section> Zazwyczaj można uniknąć konieczności manipulowania drzewa logicznego bezpośrednio, jeśli pochodzą od tych klas. Praca z drzewem logicznym dla elementów zawartości jest zaawansowanym scenariuszem, który może wymagać wyspecjalizowanego analizatora lub wyspecjalizowanej <xref:System.Windows.FrameworkElement> , który działa jako element nadrzędny renderowania (host zawartości).  
  
 Aby uzyskać więcej informacji o sposobach <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> korzystania <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>z i, zobacz [drzewa w WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkContentElement.LogicalChildren" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkContentElement.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywoływana przed zainicjowaniem elementu.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Zastąp tę metodę, aby zapewnić specjalną obsługę, która powinna wystąpić przed zainicjowaniem elementu podczas procesu ładowania elementu.  
  
Implementacja powinna wywołać implementację podstawową, ponieważ implementacja podstawowa (domyślna) ustawia pewne flagi wewnętrzne, aby śledzić inicjalizację.  
  
Implementacja podstawowa zgłosi wyjątek, jeśli <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> jest wywoływana więcej niż jeden raz w tym samym elemencie przed osiągnięciem. <see cref="M:System.Windows.FrameworkContentElement.EndInit" /></para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna sekwencję akcji, które są zawarte w podanym scenorysie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkContentElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">Seria ujęć do rozpoczęcia.</param>
        <summary>Rozpoczyna sekwencję akcji, które są zawarte w podanym scenorysie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku podpisów, które nie używają `isControllable`parametru, lub gdy ten parametr jest określony `false`, zegary osi czasu skojarzone z animacją są usuwane zaraz po osiągnięciu okresu "Fill". W związku z tym nie można uruchomić ponownie animacji po uruchomieniu. Należy zauważyć, że kontrolowanie animacji wymaga również, aby scenorys miał nazwę lub dostępną jako wystąpienie w kodzie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">Seria ujęć do rozpoczęcia.</param>
        <param name="handoffBehavior">Wartość wyliczenia opisująca zachowanie, jeśli właściwość opisana w scenorysie jest już animowana.</param>
        <summary>Rozpoczyna sekwencję akcji, które są zawarte w podanym scenorysie, z opcjami określonymi dla tego, co powinno nastąpić, jeśli właściwość jest już animowana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku podpisów, które nie używają `isControllable`parametru, lub gdy ten parametr jest określony `false`, zegary osi czasu skojarzone z animacją są usuwane zaraz po osiągnięciu okresu "Fill". W związku z tym nie można uruchomić ponownie animacji po uruchomieniu. Należy zauważyć, że kontrolowanie animacji wymaga również, aby scenorys miał nazwę lub dostępną jako wystąpienie w kodzie.  
  
## <a name="using-the-compose-handoffbehavior"></a>Korzystanie z Compose HandoffBehavior  
 Po <xref:System.Windows.Media.Animation.Storyboard>zastosowaniu <xref:System.Windows.Media.Animation.Clock> , <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> do właściwości przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, wszystkie obiekty wcześniej skojarzone z tą właściwością nadal zużywają zasoby systemowe; system chronometrażu wykonuje nie usuwaj automatycznie zegarów.  
  
 Aby uniknąć problemów z wydajnością w przypadku stosowania dużej liczby zegarów przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>programu, należy usunąć z właściwości animowane zegary, po ich zakończeniu. Istnieje kilka sposobów usunięcia zegara:  
  
-   Aby usunąć wszystkie zegary z właściwości, użyj <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metody animowanego obiektu. Określ animowaną właściwość jako pierwszy parametr, a `null` w drugim. Spowoduje to usunięcie wszystkich zegarów animacji z właściwości.  
  
-   <xref:System.Windows.Media.Animation.AnimationClock> Aby usunąć określony z listy zegarów, <xref:System.Windows.Media.Animation.Clock.Controller%2A> Użyj właściwości <xref:System.Windows.Media.Animation.AnimationClock> do pobrania <xref:System.Windows.Media.Animation.ClockController>a <xref:System.Windows.Media.Animation.ClockController>, a następnie Wywołaj <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metodę. Jest to zazwyczaj wykonywane w programie <xref:System.Windows.Media.Animation.Clock.Completed> obsługi zdarzeń zegara. Należy zauważyć, że tylko zegary główne mogą być sterowane <xref:System.Windows.Media.Animation.ClockController>przez <xref:System.Windows.Media.Animation.Clock.Controller%2A> ; Właściwość zegara podrzędnego zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzenie nie zostanie zgłoszone, jeśli skuteczny czas trwania zegara jest nieograniczona.  W takim przypadku użytkownik musi określić, kiedy ma być wywoływana <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Jest to szczególnie problem w przypadku animacji na obiektach, które mają długi okres istnienia.  Gdy obiekt jest odzyskiwany, jego zegary również są rozłączone i odzyskiwane.  
  
 Aby uzyskać więcej informacji na temat obiektów zegara, zobacz [animacje i system chronometrażu — przegląd](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">Seria ujęć do rozpoczęcia.</param>
        <param name="handoffBehavior">Wartość wyliczenia opisująca zachowanie, jeśli właściwość opisana w scenorysie jest już animowana.</param>
        <param name="isControllable">Deklaruje, czy animacja jest sterowana (może zostać wstrzymana) po jej uruchomieniu.</param>
        <summary>Rozpoczyna sekwencję akcji, które są zawarte w podanym scenorysie, z określonym stanem kontroli animacji po jej uruchomieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku podpisów, które nie używają `isControllable`parametru, lub gdy ten parametr jest określony `false`, zegary osi czasu skojarzone z animacją są usuwane zaraz po osiągnięciu okresu "Fill". W związku z tym nie można uruchomić ponownie animacji po uruchomieniu. Należy zauważyć, że kontrolowanie animacji wymaga również, aby scenorys miał nazwę lub dostępną jako wystąpienie w kodzie.  
  
## <a name="using-the-compose-handoffbehavior"></a>Korzystanie z Compose HandoffBehavior  
 Po <xref:System.Windows.Media.Animation.Storyboard>zastosowaniu <xref:System.Windows.Media.Animation.Clock> , <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> do właściwości przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, wszystkie obiekty wcześniej skojarzone z tą właściwością nadal zużywają zasoby systemowe; system chronometrażu wykonuje nie usuwaj automatycznie tych zegarów.  
  
 Aby uniknąć problemów z wydajnością w przypadku stosowania dużej liczby zegarów przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>programu, należy usunąć z właściwości animowane zegary, po ich zakończeniu. Istnieje kilka sposobów usunięcia zegara:  
  
-   Aby usunąć wszystkie zegary z właściwości, użyj <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metody animowanego obiektu. Określ animowaną właściwość jako pierwszy parametr, a `null` w drugim. Spowoduje to usunięcie wszystkich zegarów animacji z właściwości.  
  
-   <xref:System.Windows.Media.Animation.AnimationClock> Aby usunąć określony z listy zegarów, <xref:System.Windows.Media.Animation.Clock.Controller%2A> Użyj właściwości <xref:System.Windows.Media.Animation.AnimationClock> do pobrania <xref:System.Windows.Media.Animation.ClockController>a <xref:System.Windows.Media.Animation.ClockController>, a następnie Wywołaj <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metodę. Jest to zazwyczaj wykonywane w programie <xref:System.Windows.Media.Animation.Clock.Completed> obsługi zdarzeń zegara. Należy zauważyć, że tylko zegary główne mogą być sterowane <xref:System.Windows.Media.Animation.ClockController>przez <xref:System.Windows.Media.Animation.Clock.Controller%2A> ; Właściwość zegara podrzędnego zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzenie nie zostanie zgłoszone, jeśli skuteczny czas trwania zegara jest nieograniczona.  W takim przypadku użytkownik musi określić, kiedy ma być wywoływana <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Jest to szczególnie problem w przypadku animacji na obiektach, które mają długi okres istnienia.  Gdy obiekt jest odzyskiwany, jego zegary również są rozłączone i odzyskiwane.  
  
 Aby uzyskać więcej informacji na temat obiektów zegara, zobacz [animacje i system chronometrażu — przegląd](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see cref="T:System.Windows.Data.BindingGroup" /> , która jest używana dla elementu.</summary>
        <value><see cref="T:System.Windows.Data.BindingGroup" /> Jest używany dla elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Data.BindingGroup> Można użyć do walidacji wartości wielu właściwości obiektu. Załóżmy na przykład, że aplikacja poprosi użytkownika o wprowadzenie `Address`adresu, a następnie wypełnia obiekt typu, który zawiera właściwości `Street`, `City`, `ZipCode`i `Country`, z wartościami, które użytkownik określonych. Aplikacja ma panel, który zawiera cztery <xref:System.Windows.Controls.TextBox> kontrolki, z których każdy jest powiązany z jednym z właściwości obiektu. Aby sprawdzić poprawność <xref:System.Windows.Controls.ValidationRule> `Address` obiektu <xref:System.Windows.Data.BindingGroup> , można użyć elementu in a. Na przykład, <xref:System.Windows.Controls.ValidationRule> można upewnić się, że kod pocztowy jest prawidłowy dla kraju/regionu adresu.  
  
 Elementy podrzędne dziedziczą <xref:System.Windows.Data.BindingGroup> elementy z elementów nadrzędnych, podobnie jak w przypadku każdej innej dziedziczonej właściwości.  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkContentElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Podejmuje próbę przełączenia tego elementu do widoku w obrębie dowolnego regionu przewijalnego, w którym jest zawarte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołując tę metodę, efektywnie wywołasz <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> każdy nadrzędny obszar przewijania, który zawiera element (element nadrzędny może być bardzo dobrze, a <xref:System.Windows.FrameworkElement>nie a <xref:System.Windows.FrameworkContentElement>). Jeśli ten element nie jest zawarty w przewijanym obszarze, zdarzenie jest nadal zgłaszane, ale nie będzie miało żadnego efektu.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms752352(v=vs.90)">Instrukcje: Utwórz ScrollViewer</related>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia element menu kontekstowego, który powinien być wyświetlany po zażądaniu menu [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] kontekstowego za pośrednictwem elementu w tym elemencie.</summary>
        <value>Menu kontekstowe używane przez ten element.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład umieszcza <xref:System.Windows.Controls.ContextMenu> <xref:System.Windows.Documents.Paragraph>w.  
  
 [!code-xaml[ContentElementsSmorgasbord#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#contextmenu)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje tuż przed zamknięciem dowolnego menu kontekstowego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby pominąć menu kontekstowe zamykania, programy obsługi zdarzenia powinny oznaczyć je jako obsłużone.  
  
 Aby użyć tego zdarzenia jako <xref:System.Windows.EventTrigger> stylu, należy odwołać się do podstawowego identyfikatora zdarzenia usługi:  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (To użycie jest wymagane, ponieważ implementacja <xref:System.Windows.FrameworkContentElement> zdarzeń, która ujawnia podstawowe zdarzenie usługi, nie <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> mapuje prawidłowo identyfikatora do użycia w wyzwalaczach).  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|  
|Strategia routingu|Propagacja|  
|Delegate|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
   
  
## Examples  
 W poniższym przykładzie jest implementowana procedura obsługi, która zmienia kursor w nazwany `DisplayArea` region (niepokazywany). Wskazówki <xref:System.Windows.UIElement> komentarzy do użycia, ale w rzeczywistości ten przykład jest identyczny, jeśli `DisplayArea` był <xref:System.Windows.FrameworkContentElement>.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje przegląd [zdarzeń kierowanych.](~/docs/framework/wpf/advanced/routed-events-overview.md) <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekty identyfikatorów zdarzeń są tworzone po zarejestrowaniu zdarzeń kierowanych <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>(zobacz) i mogą być używane do dodawania programów obsługi klasy ( <xref:System.Windows.EventManager.RegisterClassHandler%2A>Zobacz). Obiekty identyfikatorów zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu i metodę narzędzia do dodawania właścicieli dla zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po otwarciu dowolnego menu kontekstowego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby ręcznie otworzyć menu kontekstowe, programy obsługi zdarzeń powinny oznaczyć odpowiednie zdarzenie jako obsłużone. W przeciwnym razie istniejąca wartość <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> właściwości zostanie użyta do automatycznego otwarcia menu kontekstowego. Oznaczenie obsłużonego zdarzenia będzie efektywnie anulować akcję domyślną i może być możliwością zresetowania wartości <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> właściwości, a następnie otworzenia nowej. <xref:System.Windows.Controls.ContextMenu> Istnieje jednak problem z chronometrażem, którego należy wiedzieć. W celu całkowitego zastąpienia menu kontekstowego za pomocą <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> programu obsługi, początkowe menu kontekstowe nie może mieć wartości null ani być puste. Alternatywnie może być konieczne obsłużenie zdarzenia, a następnie ręczne otwarcie nowego menu kontekstowego. Aby uzyskać szczegółowe informacje [, zobacz How to: Obsłuż zdarzenie](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)ContextMenuOpening.  
  
 Aby użyć tego zdarzenia jako <xref:System.Windows.EventTrigger> stylu, należy odwołać się do podstawowego identyfikatora zdarzenia usługi:  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (To użycie jest wymagane, ponieważ implementacja <xref:System.Windows.FrameworkContentElement> zdarzeń, która ujawnia podstawowe zdarzenie usługi, nie <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> mapuje prawidłowo identyfikatora do użycia w wyzwalaczach).  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|  
|Strategia routingu|Propagacja|  
|Delegate|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje przegląd [zdarzeń kierowanych.](~/docs/framework/wpf/advanced/routed-events-overview.md) <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekty identyfikatorów zdarzeń są tworzone po zarejestrowaniu zdarzeń kierowanych <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>(zobacz) i mogą być używane do dodawania programów obsługi klasy ( <xref:System.Windows.EventManager.RegisterClassHandler%2A>Zobacz). Obiekty identyfikatorów zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu i metodę narzędzia do dodawania właścicieli dla zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkContentElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kursor wyświetlany, gdy wskaźnik myszy znajduje się nad tym elementem.</summary>
        <value>Kursor, który ma zostać wyświetlony. Wartość domyślna jest definiowana jako <see langword="null" /> dla tej właściwości zależności. Jednak praktyczne wartości domyślne w czasie wykonywania będą pochodzić z różnych czynników.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas ustawiania tej właściwości w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]programie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] procesor polega <xref:System.Windows.Input.Cursor> na konwersji typu dla klasy w celu obliczenia ciągu. Podany ciąg powinien być obliczany <xref:System.Windows.Input.CursorType> jako wartość. Aby <xref:System.Windows.Input.Cursor> uzyskać szczegółowe informacje, zobacz.  
  
 Określa, czy kursor ustalony przez tę właściwość lub nie będzie wyświetlany, gdy wskaźnik myszy znajduje się nad tym elementem również zależy od wartości <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> właściwości. Ponadto zagadnienia dotyczące zdarzenia, takie jak aktywne przeciąganie, przechwytywanie myszy, tryby edycji tekstu w kontrolkach i tak dalej, wpłyną również na kursor o wyższym priorytecie niż wartość określona w tej właściwości.  
  
 Aby przywrócić zachowanie ustawienia tej właściwości do ostatecznej wartości domyślnej, ustaw ją `null` ponownie.  
  
 `null` Ustawienie domyślne naprawdę oznacza, że określenie praktycznej wartości kursora jest odroczone i powinno zostać uzyskane z innego miejsca. Jeśli nie ma żadnych wartości programistycznych z żadnego źródła, kursor [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] domyślny dla aplikacji będzie strzałką.  
  
 Każdy ruch myszy nad [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] aplikacją <xref:System.Windows.ContentElement.QueryCursor> wywołuje zdarzenie. Bąbelki zdarzeń i każdy element na trasie mają możliwość obsługi zdarzenia i ustawiania wartości kursora za pośrednictwem argumentów tego zdarzenia. Jeśli tak się stanie, oznacza to, że zdarzenie jest obsługiwane i ma zmienioną wartość w argumentach ma pierwszeństwo przed wartością <xref:System.Windows.FrameworkContentElement.Cursor%2A> właściwości na dowolnym poziomie, chyba że <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> jest ustawiona.  
  
 Jeśli nie utworzysz kursora niestandardowego, zazwyczaj ustawiasz tę właściwość na wartość <xref:System.Windows.Input.Cursors> właściwości statycznej klasy.  
  
 <xref:System.Windows.Input.Cursor> Ustawienie wartości niestandardowej nie jest włączone w częściowej relacji zaufania. Aby uzyskać więcej informacji na temat niestandardowych kursorów, zobacz [przegląd danych wejściowych](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.CursorProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład ustawia wskaźnik na wartość niestandardową.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkContentElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkContentElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kontekst danych dla elementu, gdy uczestniczy w powiązaniu danych.</summary>
        <value>Obiekt, który ma być używany jako kontekst danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Kontekst danych* to koncepcja, która umożliwia elementom dziedziczenie informacji z ich elementów nadrzędnych o źródle powiązania, które jest używane do wiązania, a także innych właściwości powiązania, takich jak ścieżka.  
  
 Kontekst danych można ustawić bezpośrednio do [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] obiektu, z powiązaniami ocenianymi do właściwości tego obiektu. Alternatywnie można ustawić kontekst danych dla <xref:System.Windows.Data.DataSourceProvider> obiektu.  
  
 Ta właściwość zależności dziedziczy wartości właściwości. Jeśli istnieją elementy podrzędne, które nie mają żadnej innej <xref:System.Windows.FrameworkContentElement.DataContext%2A> wartości dla opcji ustalone za pomocą lokalnych wartości lub stylów, system właściwości ustawi wartość <xref:System.Windows.FrameworkContentElement.DataContext%2A> jako wartość najbliższego elementu nadrzędnego z przypisaną wartością.  
  
 Alternatywnie możesz użyć jednej <xref:System.Windows.Data.Binding> z następujących właściwości klasy, aby jawnie określić źródło powiązania: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, lub <xref:System.Windows.Data.Binding.RelativeSource%2A>. Aby uzyskać więcej informacji, zobacz [jak: Określ źródło](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)powiązania.  
  
 W [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]programie <xref:System.Windows.FrameworkContentElement.DataContext%2A> program jest najczęściej ustawiany jako <xref:System.Windows.Data.Binding> deklaracja. Można użyć składni elementu właściwości lub składni atrybutów. Składnia atrybutu jest pokazana w przykładzie na tej stronie. Możesz również ustawić <xref:System.Windows.FrameworkContentElement.DataContext%2A> w kodzie.  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```xaml
<object DataContext="bindingUsage"/>  
```

—lub—

```xaml
<object DataContext="{resourceExtension contextResourceKey}"/>  
```

<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *dataContextObject*  
 Obiekt bezpośrednio osadzony, który służy jako kontekst danych dla wszelkich powiązań w elemencie nadrzędnym. Zazwyczaj ten obiekt jest <xref:System.Windows.Data.Binding> lub inną <xref:System.Windows.Data.BindingBase> podklasą. Alternatywnie dane pierwotne dowolnego [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] typu obiektu przeznaczonego do powiązania mogą zostać umieszczone tutaj, z rzeczywistymi powiązaniami zdefiniowanymi w dalszej części.  
  
 *bindingUsage*  
 Użycie powiązania, które jest oceniane do odpowiedniego kontekstu danych. Aby uzyskać szczegółowe informacje, zobacz [Binding Markup Extension](~/docs/framework/wpf/advanced/binding-markup-extension.md).  
  
 *resourceExtension*  
 Jeden z następujących elementów: `StaticResource`, lub `DynamicResource`. To użycie jest używane w przypadku odwoływania się do danych pierwotnych zdefiniowanych jako obiekt w zasobach. Zobacz [zasoby XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *contextResourceKey*  
 Identyfikator klucza dla obiektu, z <xref:System.Windows.ResourceDictionary>którego zażądano.  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.DataContextProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Poniższy przykład ustawia powiązanie dla <xref:System.Windows.Documents.Paragraph> elementu, tworząc nowy obiekt danych niestandardowych, ustanawiając ten obiekt jako <xref:System.Windows.FrameworkContentElement.DataContext%2A>i ustawiając ścieżkę powiązania do właściwości w tym elemencie.  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zmienia się kontekst danych tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać wyjaśnienie kontekstów danych i powiązania danych, zobacz temat [powiązanie danych — omówienie](~/docs/framework/wpf/data/data-binding-overview.md).  
  
> [!IMPORTANT]
>  Po <xref:System.Windows.FrameworkContentElement.DataContext%2A> wprowadzeniu zmian elementu wszystkie właściwości powiązane z danymi w tym elemencie mogą być zagrożone. Dotyczy to wszystkich elementów, które są elementami podrzędnymi bieżącego elementu, które dziedziczą kontekst danych, a także bieżącego elementu. Wszystkie takie powiązania reinterpretują nowe <xref:System.Windows.FrameworkContentElement.DataContext%2A> , aby odzwierciedlały nową wartość w powiązaniach. Nie wprowadzono żadnej gwarancji dotyczącej kolejności tych zmian względem podniesienia <xref:System.Windows.FrameworkContentElement.DataContextChanged> zdarzenia.  Zmiany mogą wystąpić przed zdarzeniem, po zdarzeniu lub w dowolnej mieszance.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.DataContext" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia klucz do użycia w celu znalezienia szablonu stylu dla tej kontrolki w motywach.</summary>
        <value>Klucz stylu. Aby prawidłowo działać jako część wyszukiwania w stylu motywu, ta wartość powinna być <see cref="T:System.Type" /> wartością stylu elementu. <see langword="null" />jest zaakceptowaną wartością dla określonego przypadku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwykle nie jest ustawiana za pośrednictwem żadnej z jej metod ustawiających bezpośrednie. Zamiast tego przesłonić metadane specyficzne dla typu tej właściwości zależności za każdym razem, gdy tworzysz nową podklasę. Podczas podklasy należy wywołać <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> metodę <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> względem identyfikatora, w obrębie konstruktora statycznego podklasy Control.  
  
 Na przykład Klasa wbudowana, taka jak <xref:System.Windows.Documents.Bold> faktycznie, ma bardzo małą implementację poza <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> zastępowaniem metadanych w konstruktorze statycznym i uwidaczniając kilka konstruktorów wystąpień. Fakt <xref:System.Windows.Documents.Bold> , że elementy otoczone przez tag <xref:System.Windows.Documents.TextElement.FontWeight%2A> uzyskują Właściwość <xref:System.Windows.FontWeights.Bold%2A> jest zaimplementowany w stylu motywu, <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> do którego odwołuje się ustawienie wartości domyślnej na `typeof(Bold)`.  
  
 Jeśli chcesz, aby element lub formant nie używał stylów motywu, ustaw <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> właściwość na. `true`  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkContentElement.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywoływana natychmiast po zainicjowaniu elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zaimplementuj tę metodę, aby zapewnić specjalną obsługę, która powinna wystąpić, gdy element zostanie zainicjowany podczas procesu ładowania elementu.  
  
 Implementacja powinna wywołać implementację podstawową, ponieważ implementacja podstawowa (domyślna) ustawia pewne flagi wewnętrzne, aby śledzić inicjalizację.  
  
 Jeśli <xref:System.Windows.FrameworkContentElement.BeginInit%2A> została wcześniej wywołana, podstawowa implementacja spowoduje <xref:System.Windows.FrameworkContentElement.Initialized> wygenerowanie zdarzenia. W przeciwnym razie <xref:System.Windows.FrameworkContentElement.BeginInit%2A> , jeśli nie została wywołana lub nie można ustalić, <xref:System.Windows.FrameworkContentElement.BeginInit%2A> czy wywołano, zdarzenie nie zostało zgłoszone.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkContentElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa elementu do wyszukania.</param>
        <summary>Znajduje element o podanej nazwie identyfikatora.</summary>
        <returns>Żądany element. Może tak <see langword="null" /> być, jeśli nie znaleziono pasującego elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ten element ma elementy podrzędne, te elementy podrzędne są przeszukiwane cyklicznie dla żądanego nazwanego elementu.  
  
   
  
## Examples  
 Poniższy przykład ustawia właściwość dla elementu znalezionego przez nazwę w ramach odwołania <xref:System.Windows.Documents.FlowDocument> na stronie.  
  
 [!code-csharp[ContentElementsSmorgasbord#FindName](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findname)]
 [!code-vb[ContentElementsSmorgasbord#FindName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findname)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkContentElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Identyfikator klucza zasobu, który ma zostać znaleziony.</param>
        <summary>Wyszukuje zasób z określonym kluczem i zgłosi wyjątek, jeśli żądany zasób nie zostanie znaleziony.</summary>
        <returns>Znaleziono zasób lub <see langword="null" /> nie znaleziono pasującego zasobu (ale spowoduje to również zgłoszenie wyjątku w przypadku <see langword="null" />).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  W przypadku wywołania tej metody dla klucza, którego nie można znaleźć, zostanie zgłoszony wyjątek. Jeśli nie chcesz obsługiwać wyjątków dla tego przypadku, zamiast tego należy wywołać metodę <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>. <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>zwraca `null` wartość, gdy nie znaleziono zasobu i nie zgłasza wyjątku.  
  
 Jeśli zasób nie zostanie odnaleziony w elemencie wywołującym, drzewo nadrzędne będzie przeszukiwane przy użyciu drzewa logicznego w taki sam sposób, w jaki drzewo będzie przeszukiwane, jeśli zasób zażądał klucza w czasie wykonywania.  
  
 Zazwyczaj można natychmiast rzutować wartość zwracaną na typ właściwości, którą próbowano ustawić przy użyciu zwróconej wartości zasobu.  
  
   
  
## Examples  
 Poniższy przykład umożliwia znalezienie zasobu zdefiniowanego w znaczniku i zastosowanie go do pewnej właściwości elementu w odpowiedzi na zdarzenie kierowane.  
  
 [!code-csharp[ContentElementsSmorgasbord#FindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findresource)]
 [!code-vb[ContentElementsSmorgasbord#FindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findresource)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">Nie znaleziono żądanego klucza zasobu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceKey" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt, który umożliwia dostosowanie wyglądu, efektów lub innych cech stylu, które będą stosowane do tego elementu, gdy przechwytuje fokus klawiatury.</summary>
        <value>Żądany styl, który ma zostać zastosowany do fokusu. Wartość domyślna zadeklarowana we właściwości zależności jest pustą statyczną <see cref="T:System.Windows.Style" />. Jednak efektywna wartość w czasie wykonywania jest często (ale nie zawsze) stylem, zgodnie z obsługą motywu dla kontrolek.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas ustawiania tej właściwości w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]programie style są prawie zawsze zdefiniowane jako zasób, a nie jako element, a ten zasób jest zwykle przywoływany <xref:System.Windows.StaticResourceExtension>jako.  
  
 Należy zauważyć, że ta właściwość ma wpływ na wygląd wizualizacji, ale nie zgłasza tego w metadanych. Wynika to z faktu, że zmiana wyglądu wizualizacji jest sterowana zdarzeniami i może nie być stosowana przez cały czas i dlatego nie powinna raportować żadnych informacji wizualizacji lub układu w metadanych.  
  
 Koncepcyjnie, wizualne zachowanie fokusu zastosowany do kontrolki powinno być spójne z elementu do elementu. Najbardziej rozsądnym sposobem wymuszania spójności jest zmiana stylu wizualizacji fokusu tylko w przypadku redagowania całego motywu. Ustawienie tej właściwości dla poszczególnych stylów, a nie jako części motywu nie jest zamierzonym użyciem tej właściwości, ponieważ może to prowadzić do mylącego środowiska użytkownika dotyczącego fokusu klawiatury. Jeśli zamierzasz zachowywać zachowanie specyficzne dla elementu, które jest świadomie niespójne w motywie, znacznie lepszym rozwiązaniem jest użycie wyzwalaczy w stylach dla poszczególnych właściwości stanu wejściowego, <xref:System.Windows.UIElement.IsFocused%2A> takich <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>jak lub, i w taki sposób, aby nie wizualnie przeszkadza na dowolnym istniejącym stylu wizualizacji fokusu. Aby uzyskać więcej informacji na temat zamiaru <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> projektowania i właściwości alternatywnej ostrości, zobacz [Style dla fokusu w kontrolkach i FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *resourceExtension*  
 Jeden z następujących elementów:, lub. Zobacz [zasoby XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Klucz, który identyfikuje żądany styl. Klucz odnosi się do istniejącego zasobu w <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Składnia elementu właściwości jest technicznie możliwa, ale nie jest zalecana. Zobacz [wbudowane style i szablony](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).  Odwołanie do powiązania przy użyciu [szablonu TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md) lub <xref:System.Windows.Data.Binding> jest również możliwe, ale nietypowe.  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Windows.FrameworkContentElement" /> powinien [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] wymusić renderowanie kursora jako <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> zadeklarowanego przez właściwość tego wystąpienia.</summary>
        <value><see langword="true" />Aby wymusić prezentację kursora nad tym elementem, aby użyć ustawienia tego wystąpienia dla kursora (łącznie ze wszystkimi elementami podrzędnymi); w <see langword="false" />przeciwnym razie. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie tej właściwości na `true` spowoduje zastąpienie preferencji kursora określonych przez elementy podrzędne. Wykonanie tej operacji w ogólnej [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] aplikacji może być mylące dla użytkownika, szczególnie w przypadku, gdy elementy podrzędne próbują określić kursory. Ustawienie <xref:System.Windows.FrameworkElement.ForceCursor%2A> jest bardziej odpowiednie w scenariuszach podklasy kontroli lub składania.  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład wymusza przekroczenie kursora w elemencie.  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Element docelowy <see cref="T:System.Windows.DependencyProperty" /> , z którego ma zostać pobrane powiązanie.</param>
        <summary><see cref="T:System.Windows.Data.BindingExpression" /> Pobiera dla powiązania określonej właściwości.</summary>
        <returns>Zwraca wartość, <see langword="null" /> Jeśliobiektdocelowyjestpowiązanyzdanymi;wprzeciwnymrazie.<see cref="T:System.Windows.Data.BindingExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pobiera powiązanie przez zapytanie do właściwości.  
  
 [!code-csharp[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#getbindingexpression)]
 [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#getbindingexpression)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca alternatywny logiczny element nadrzędny dla tego elementu, jeśli nie istnieje obiekt nadrzędny. W takim przypadku <see cref="T:System.Windows.FrameworkContentElement" /> obiekt nadrzędny jest zawsze taka sama <see cref="P:System.Windows.FrameworkContentElement.Parent" /> jak wartość właściwości.</summary>
        <returns>Zwraca coś innego niż <see langword="null" /> za każdym razem, gdy implementacja tej metody na poziomie platformy WPF jest niewizualna.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca oczekiwany pojedynczy element nadrzędny Visual. Implementacje niestandardowe mogą zwracać alternatywne relacje nadrzędne.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zainicjowaniu tego <see cref="T:System.Windows.FrameworkContentElement" /> . Jest to zbieżne ze przypadkami, gdy wartość <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> właściwości zmienia się <see langword="false" /> z (lub niezdefiniowana <see langword="true" />) na.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie zostanie wywołane przy każdym <xref:System.Windows.FrameworkContentElement.EndInit%2A> wywołaniu <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> metody lub. Wywołania tych metod mogą zostać wykonane przez zamierzony kod lub [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] proces ładowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkContentElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kontekst używany przez <see cref="T:System.Windows.FrameworkContentElement" />dane wejściowe.</summary>
        <value>Zakres wejściowy, który modyfikuje sposób interpretacji danych wejściowych z alternatywnych metod wprowadzania. Wartość domyślna to <see langword="null" /> (w wyniku domyślnego sposobu obsługi poleceń).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zależności dziedziczy wartości właściwości. Jeśli istnieją elementy podrzędne, które nie mają żadnej innej <xref:System.Windows.FrameworkElement.InputScope%2A> wartości dla opcji ustalone za pomocą lokalnych wartości lub stylów, system właściwości ustawi wartość <xref:System.Windows.FrameworkElement.InputScope%2A> jako wartość najbliższego elementu nadrzędnego z przypisaną wartością.  
  
 Chociaż użycie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] składni jest wymienione i jest syntaktycznie dozwolone, ustawienie tej właściwości w nie jest wspólne. [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.InputScopeProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.InputScope" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten element został zainicjowany, przez załadowanie jako [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]lub przez jawne <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> wywołanie metody.</summary>
        <value><see langword="true" />Jeśli element jest zainicjowany dla powyższych wywołań ładowania lub metody; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość może być `true` również wtedy, gdy ten element został przeniesiony w drzewie elementów, tak że ma nowy element nadrzędny i dlatego zostanie ponownie załadowany.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten element został załadowany do prezentacji.</summary>
        <value><see langword="true" />Jeśli bieżący element jest dołączony do drzewa elementów i został renderowany; <see langword="false" /> Jeśli element nigdy nie został dołączony do załadowanego drzewa elementów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Od nowo skonstruowanego wystąpienia ta właściwość zaczyna się `false`i pozostaje `true` po ustawieniu na `true`, nawet jeśli później zostanie usunięta przez kod.  
  
   
  
## Examples  
 Poniższy przykładowy kod używa <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> jako warunkowego sprawdzania, aby upewnić się, że funkcja `displayData` (niepokazywana) będzie mieć poprawne elementy załadowane na stronie, aby działać w ramach obsługi na żądanie. Ta sama logika jest uruchamiana jako procedura obsługi <xref:System.Windows.FrameworkContentElement.Loaded>zdarzeń dla.  
  
 [!code-csharp[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#isloaded)]
 [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#isloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkContentElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkContentElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje o języku lokalizacji/globalizacji, które mają zastosowanie do pojedynczego elementu.</summary>
        <value>Informacje o kulturze dla tego elementu. Wartość domyślna to <see cref="T:System.Windows.Markup.XmlLanguage" /> wystąpienie <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> z wartością ustawioną na ciąg "en-us".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Formaty ciągów są zgodne ze standardem RFC 3066. Na przykład w Stanach Zjednoczonych Angielski to "pl-US". Aby <xref:System.Windows.Markup.XmlLanguage> uzyskać więcej informacji na temat wartości i formatu, zobacz.  
  
 Ta właściwość zależności dziedziczy wartości właściwości. Jeśli istnieją elementy podrzędne, które nie mają żadnej innej <xref:System.Windows.FrameworkElement.Language%2A> wartości dla opcji ustalone za pomocą lokalnych wartości lub stylów, system właściwości ustawi wartość <xref:System.Windows.FrameworkElement.Language%2A> jako wartość najbliższego elementu nadrzędnego z przypisaną wartością.  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.LanguageProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.Language" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy element jest określony, renderowany i gotowy do interakcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia kierowane bezpośrednio nie obserwują trasy, są obsługiwane tylko w obrębie tego samego elementu, w którym zostały zgłoszone. Zdarzenia kierowane bezpośrednio obsługują inne kierowane zdarzenia dotyczące zdarzeń: obsługują kolekcję programów obsługi i mogą być używane jako <xref:System.Windows.EventTrigger> style.  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.LoadedEvent>|  
|Strategia routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje przegląd [zdarzeń kierowanych.](~/docs/framework/wpf/advanced/routed-events-overview.md) <see cref="E:System.Windows.FrameworkContentElement.Loaded" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekty identyfikatorów zdarzeń są tworzone po zarejestrowaniu zdarzeń kierowanych <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>(zobacz) i mogą być używane do dodawania programów obsługi klasy ( <xref:System.Windows.EventManager.RegisterClassHandler%2A>Zobacz). Obiekty identyfikatorów zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu i metodę narzędzia do dodawania właścicieli dla zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduł wyliczający dla logicznych elementów podrzędnych tego elementu.</summary>
        <value>Moduł wyliczający dla logicznych elementów podrzędnych tego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat korzystania <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> z <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>i, zobacz [drzewa w WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkContentElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">Kierunek, który fokus ma zostać przeniesiony jako wartość wyliczenia.</param>
        <summary>Przenosi fokus klawiatury z tego elementu do innego elementu.</summary>
        <returns>Zwraca <see langword="true" /> wartość, jeśli fokus jest przenoszony pomyślnie; <see langword="false" /> Jeśli element docelowy w kierunku określonym przez nie istnieje.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkContentElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę identyfikującą elementu. Nazwa zawiera odwołanie do wystąpienia, dzięki czemu kod programistyczny, taki jak kod procedury obsługi zdarzeń, może odwoływać się do elementu, gdy jest konstruowany podczas analizowania [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</summary>
        <value>Nazwa elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najbardziej typowym użyciem tej właściwości jest określenie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] nazwy elementu w znaczniku.  
  
 Ta właściwość zasadniczo zapewnia wygodną właściwość na poziomie platformy WPF do ustawiania [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [dyrektywy x:Name](~/docs/framework/xaml-services/x-name-directive.md).  
  
 Pobieranie z kodu nie jest wspólne, ponieważ jeśli istnieje odpowiednie odwołanie w kodzie, można tylko wywołać metody i właściwości w odwołaniu do elementu i nie są zwykle <xref:System.Windows.FrameworkContentElement.Name%2A>potrzebne. <xref:System.Windows.FrameworkContentElement.Name%2A> Wyjątek polega na tym, że ciąg ma pewne przeciążone znaczenie, na przykład, jeśli jest przydatne do wyświetlania tej [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]nazwy w. Ustawienie wartości <xref:System.Windows.FrameworkContentElement.Name%2A> z kodu, Jeśli oryginał został ustawiony z znaczników jest również niezalecane i zmiana właściwości nie spowoduje zmiany odwołania do obiektu. <xref:System.Windows.FrameworkContentElement.Name%2A> Odwołania do obiektów są tworzone tylko wtedy, gdy bazowe Zakresy nazw WPF są jawnie tworzone [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] podczas ładowania.  
  
 Należy wywołać <xref:System.Windows.FrameworkContentElement.RegisterName%2A> , aby wprowadzić skuteczną zmianę <xref:System.Windows.FrameworkContentElement.Name%2A> właściwości już załadowanego elementu.  
  
 W przypadku, gdy ustawienie <xref:System.Windows.FrameworkContentElement.Name%2A> z kodu jest ważne dla elementów nazewnictwa, względem których będą uruchamiane Scenorysy. Przed zarejestrowaniem nazwy może również wystąpić potrzeba wystąpienia i przypisania <xref:System.Windows.NameScope> wystąpienia. Zapoznaj się z sekcją [](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)przykładu lub scenorysami.  
  
 Ustawienie <xref:System.Windows.FrameworkContentElement.Name%2A> z kodu ma ograniczone aplikacje, ale wyszukiwanie elementu według nazwy jest bardziej popularne, szczególnie w przypadku korzystania z modelu nawigacji, w którym strony ładują się ponownie do aplikacji, a kod czasu wykonywania nie musi być kodem związanym z tym odpowiedniej stronie. Metoda <xref:System.Windows.FrameworkContentElement.FindName%2A>narzędziowa, która jest dostępna z dowolnego <xref:System.Windows.FrameworkContentElement>elementu, może odróżniać <xref:System.Windows.FrameworkContentElement.Name%2A> każdy element według cyklicznego drzewa logicznego tego elementu. Można też użyć <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> statycznej <xref:System.Windows.LogicalTreeHelper>metody <xref:System.Windows.FrameworkContentElement.Name%2A> , która również przyjmuje ciąg jako argument.  
  
 Najczęściej używane elementy główne (<xref:System.Windows.Window> <xref:System.Windows.Controls.Page> na przykład) implementują interfejs <xref:System.Windows.Markup.INameScope>. Implementacje tego interfejsu powinny wymusić niejednoznaczność nazw w zakresie.  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.NameProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.Name" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Zawiera dane dotyczące zdarzenia.</param>
        <summary>Wywoływana za każdym <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> razem, gdy zdarzenie kierowane osiągnie tę klasę w swojej trasie. Zaimplementuj tę metodę, aby dodać obsługę klasy dla tego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma domyślnej implementacji. Należy nadal wywoływać implementację bazową w przypadku zaimplementowania tej metody przez klasę pośrednią w dziedziczeniu.  
  
 Celem tej metody jest nieco podobna do wzorca zdarzeń [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] w odniesieniu do * metod: udostępnia metodę do obsługi pasującego zdarzenia z klas pochodnych z obsługą klasy zamiast programu obsługi wystąpienia. W takim przypadku zdarzenie dopasowywania jest zdarzeniem kierowanym. Wzorzec implementacji metod on * jest różny dla zdarzeń kierowanych, ponieważ zdarzenie kierowane mogło zostać zgłoszone przez element podrzędny, niekoniecznie element, który wywoła procedury obsługi. W związku z tym implementacja będzie musiała przyjąć właściwości źródłowe argumentów zdarzenia (i nie powinna próbować ponownie podnieść zdarzenia w większości przypadków). Podklasy <xref:System.Windows.FrameworkContentElement> mogą wybierać wywołania metod obsługi klasy prywatnej, gdy zdarzenie jest odbierane wzdłuż trasy. Jednym z potencjalnych scenariuszy jest przejęcie argumentów zdarzenia i celowe oznaczenie zdarzenia jako obsłużonego w celu skrócenia trasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzenia dla zdarzenia.</param>
        <summary>Wywoływana za każdym <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> razem, gdy zdarzenie kierowane osiągnie tę klasę w swojej trasie. Zaimplementuj tę metodę, aby dodać obsługę klasy dla tego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma domyślnej implementacji. Należy nadal wywoływać metodę Base () w przypadku, gdy Klasa pośrednicząca w dziedziczeniu zaimplementował tę metody.  
  
 Celem tej metody jest nieco podobna do wzorca zdarzeń [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] w odniesieniu do * metod: udostępnia metodę do obsługi pasującego zdarzenia z klas pochodnych z obsługą klasy zamiast programu obsługi wystąpienia. W takim przypadku zdarzenie dopasowywania jest zdarzeniem kierowanym. Wzorzec implementacji metod on * jest różny w przypadku zdarzeń kierowanych, ponieważ zdarzenie kierowane mogło zostać zgłoszone przez element podrzędny, niekoniecznie element, który wywoła programy obsługi, więc implementacja będzie musiała przyjmować argumenty zdarzenia "Źródło". właściwości do konta (i nie powinny próbować ponownie podnieść zdarzenia w większości przypadków). Podklasy <xref:System.Windows.FrameworkContentElement> mogą wybierać wywołania metod obsługi klasy prywatnej, gdy zdarzenie jest odbierane wzdłuż trasy. Jednym z potencjalnych scenariuszy jest przejęcie argumentów zdarzenia i celowe oznaczenie zdarzenia jako obsłużonego w celu skrócenia trasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkContentElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzenia dla zdarzenia.</param>
        <summary>Obsługa klasy dla <see cref="E:System.Windows.ContentElement.GotFocus" /> zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta procedura obsługi klasy ustawia odpowiednie zachowanie ostrości dla tego elementu, jeśli zdarzenie pochodzi z tego elementu. Jeśli źródło zdarzenia było innym elementem w drzewie, program obsługi nie robi nic.  
  
 Zastąp tę metodę, aby zmienić domyślne zachowanie ukierunkowane na element.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkContentElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzenia dla zdarzenia.</param>
        <summary><see cref="E:System.Windows.FrameworkContentElement.Initialized" /> Podnosi zdarzenie. Ta metoda jest wywoływana za <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> każdym razem, <see langword="true" />gdy jest ustawiona na.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody wirtualnej wywołuje zdarzenie zgodnie z opisem we wcześniejszej części tego tematu. Zastąpienia powinny wywołać metodę Base (), aby zachować to zachowanie.  
  
 Należy zauważyć, <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> że właściwość jest tylko do odczytu. W związku z tym nie można ustawić, aby wymusić zachowanie inicjalizacji. Ustawienie inicjacji jest przeznaczone do wykonania tylko przez [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] platformę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkContentElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzenia opisujące modyfikowaną właściwość, w tym stare i nowe wartości.</param>
        <summary>Wywoływana za każdym razem, gdy wartość skuteczna każdej właściwości <see cref="T:System.Windows.FrameworkContentElement" /> zależności na tej stronie została zaktualizowana. Określona właściwość zależności, która została zmieniona, jest raportowana w parametrze argumenty. Zastąpień <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest przeznaczona do ogólnego wykrywania zmian właściwości lub Unieważnień. Zamiast tego jest przeznaczony do modyfikacji ogólnego wzorca unieważnienia, jeśli pewne informacje są znane o szerokiej klasyfikacji właściwości.  
  
 Ta metoda jest potencjalnie wywoływana wiele razy w okresie istnienia obiektu. W związku z tym można osiągnąć lepszą wydajność w przypadku zastąpienia metadanych określonych właściwości, a następnie dołączenia <xref:System.Windows.CoerceValueCallback> lub <xref:System.Windows.PropertyChangedCallback> funkcji dla poszczególnych właściwości. Należy jednak użyć tej metody, jeśli <xref:System.Windows.FrameworkContentElement> zawiera znaczną liczbę właściwości zależności z wartościami, lub jeśli zawiera logikę, taką jak zachowanie renderowania, które należy uruchomić ponownie dla kilku powiązanych przypadków Unieważnień właściwości.  
  
 Należy zauważyć, że istnieje taka sama metoda `OnPropertyChanged` o nazwie z inną sygnaturą (typ parametru to <xref:System.ComponentModel.PropertyChangedEventArgs>), która może być wyświetlana w wielu klasach. Jest używany do powiadomień obiektów danych i jest częścią kontraktu dla <xref:System.ComponentModel.INotifyPropertyChanged>. `OnPropertyChanged`  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Zawsze Wywołaj implementację podstawową, jako pierwszą operację w implementacji. Niewykonanie tej czynności spowoduje znacząco wyłączenie całego [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] systemu właściwości, co spowoduje zgłoszenie nieprawidłowych wartości.</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkContentElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">Stary styl.</param>
        <param name="newStyle">Nowy styl.</param>
        <summary>Wywoływana, gdy styl używany przez ten element zostanie zmieniony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma implementację domyślną, która ustawia wewnętrzną flagę zwracającą warunek zmiany stylu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Zawsze Wywołaj implementację podstawową, w przeciwnym razie nie można zastosować stylów. Scenariusze przesłaniania tej metody mogą obejmować, jeśli Klasa pochodna ma wyspecjalizowany selektor stylów lub buforuje wartości stylu. Zmiany motywu będą potencjalnie wywoływały tę metodę.</para></block>
        <altmember cref="P:System.Windows.FrameworkContentElement.Style" />
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Zawiera dane dotyczące zdarzenia.</param>
        <summary>Wywoływana za każdym <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> razem, gdy zdarzenie kierowane osiągnie tę klasę w swojej trasie. Zaimplementuj tę metodę, aby dodać obsługę klasy dla tego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma domyślnej implementacji. Należy nadal wywoływać metodę Base () w przypadku, gdy Klasa pośrednicząca w dziedziczeniu zaimplementował tę metody.  
  
 Celem tej metody jest nieco podobna do wzorca zdarzeń [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] w odniesieniu do * metod: udostępnia metodę do obsługi pasującego zdarzenia z klas pochodnych z obsługą klasy zamiast programu obsługi wystąpienia. W takim przypadku zdarzenie dopasowywania jest zdarzeniem kierowanym. Wzorzec implementacji metod on * jest różny w przypadku zdarzeń kierowanych, ponieważ zdarzenie kierowane mogło zostać zgłoszone przez element podrzędny, niekoniecznie element, który wywoła programy obsługi, więc implementacja będzie musiała przyjmować argumenty zdarzenia "Źródło". właściwości do konta (i nie powinny próbować ponownie podnieść zdarzenia w większości przypadków). Podklasy <xref:System.Windows.FrameworkContentElement> mogą wybierać wywołania metod obsługi klasy prywatnej, gdy zdarzenie jest odbierane wzdłuż trasy. Jednym z potencjalnych scenariuszy jest przejęcie argumentów zdarzenia i celowe oznaczenie zdarzenia jako obsłużonego w celu skrócenia trasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Zawiera dane dotyczące zdarzenia.</param>
        <summary>Wywoływana za każdym <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> razem, gdy zdarzenie kierowane osiągnie tę klasę w swojej trasie. Zaimplementuj tę metodę, aby dodać obsługę klasy dla tego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma domyślnej implementacji. Należy nadal wywoływać metodę Base () w przypadku, gdy Klasa pośrednicząca w dziedziczeniu zaimplementował tę metody.  
  
 Celem tej metody jest nieco podobna do wzorca zdarzeń [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] w odniesieniu do * metod: udostępnia metodę do obsługi pasującego zdarzenia z klas pochodnych z obsługą klasy zamiast programu obsługi wystąpienia. W takim przypadku zdarzenie dopasowywania jest zdarzeniem kierowanym. Wzorzec implementacji metod on * jest różny dla zdarzeń kierowanych, ponieważ zdarzenie kierowane mogło zostać zgłoszone przez element podrzędny, niekoniecznie jest to element, który wywoła programy obsługi, więc implementacja będzie musiała mieć wartość "Źródło" argumentów zdarzeń właściwości do konta (i nie powinny próbować ponownie podnieść zdarzenia w większości przypadków). Podklasy <xref:System.Windows.FrameworkContentElement> mogą wybierać wywołania metod obsługi klasy prywatnej, gdy zdarzenie jest odbierane wzdłuż trasy. Jednym z potencjalnych scenariuszy jest przejęcie argumentów zdarzenia i celowe oznaczenie zdarzenia jako obsłużonego w celu skrócenia trasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy ten element zawiera właściwości stylu motywu.</summary>
        <value><see langword="true" />Jeśli ten element nie używa właściwości stylu motywu; wszystkie właściwości pochodzące z stylu pochodzą ze stylów aplikacji lokalnych, a właściwości stylu motywu nie są stosowane. <see langword="false" />Jeśli style aplikacji są stosowane w pierwszej kolejności, a następnie style motywu stosują się do właściwości, które nie zostały jawnie ustawione w stylach aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najbardziej typowym użyciem tej właściwości jest pośrednie użycie w metodzie ustawiającej stylu, który dostarcza styl z motywem.  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera element nadrzędny w drzewie logicznym dla tego elementu.</summary>
        <value>Logiczny element nadrzędny dla tego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy zauważyć, że logiczny element nadrzędny elementu może ulec zmianie w zależności od funkcjonalności aplikacji i utrzymywania wartości tej właściwości nie będzie odzwierciedlała tej zmiany. Zwykle należy uzyskać wartość bezpośrednio przed jej użyciem.  
  
 Zobacz [drzewa w WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) , aby uzyskać więcej informacji na temat przechodzenia między drzewa logiczne, oraz scenariusze, w których takie podejście odbywa się w celu odnajdywania elementów.  
  
 System właściwości może ponownie obliczyć wszystkie wartości właściwości elementu, gdy zostanie on oddany, ponieważ niektóre właściwości dziedziczą wartości za pomocą drzewa logicznego. Obiekt <xref:System.Windows.FrameworkContentElement.DataContext%2A> , który ma zastosowanie do powiązań, również zmienia się w przypadku zmiany elementów nadrzędnych.  
  
 Zmiana elementu nadrzędnego jest zazwyczaj wykonywane tylko przez manipulowanie kolekcjami przy użyciu dedykowanych metod dodawania lub usuwania lub ustawiania właściwości zawartości elementów.  
  
 Najbardziej typowym scenariuszem użycia <xref:System.Windows.FrameworkContentElement.Parent%2A> właściwości jest uzyskanie odwołania, a następnie uzyskanie różnych <xref:System.Windows.FrameworkContentElement> wartości właściwości z elementu nadrzędnego. W przypadku szablonów `null`zostanie <xref:System.Windows.FrameworkContentElement.Parent%2A> ostatecznie zadany szablon. Aby przejść do poprzedniego punktu i przekroczyć Drzewo logiczne, w którym faktycznie zastosowano szablon, <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>Użyj.  
  
   
  
## Examples  
 Poniższy przykład sprawdza, <xref:System.Windows.FrameworkContentElement.Parent%2A> czy element a <xref:System.Windows.Documents.TextPointer> jest określonego typu.  
  
 [!code-csharp[TextPointer_snippets#FCEParent](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#fceparent)]
 [!code-vb[TextPointer_snippets#FCEParent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#fceparent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Kierunek, dla którego należy określić potencjalną zmianę fokusu.</param>
        <summary>Określa następny element, który będzie miał fokus względem tego elementu dla podanego kierunku przenoszenia fokusu, ale nie przesuwa fokusu. Ta metoda jest zapieczętowana i nie może zostać przesłonięta.</summary>
        <returns>Następny element, który koncentruje się na tym, jeśli fokus został rzeczywiście przesunięty. Może zwracać <see langword="null" /> , jeśli fokus nie może zostać przeniesiony względem tego elementu dla danego kierunku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement.MoveFocus%2A>jest pokrewną metodą, która rzeczywiście przenosi fokus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Określono <see cref="T:System.Windows.Input.TraversalRequest" />jeden z następujących kierunków w: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />. Te wskazówki nie są prawne dla <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> programu (ale są prawne dla <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkContentElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa do użycia dla określonego mapowania nazwa-obiekt.</param>
        <param name="scopedElement">Obiekt mapowania.</param>
        <summary>Zapewnia metodę dostępu, która upraszcza dostęp do <see cref="T:System.Windows.NameScope" /> metody rejestracji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wygodną metodą wywoływania <xref:System.Windows.NameScope.RegisterName%2A>. Implementacja sprawdzi kolejne elementy nadrzędne do momentu znalezienia odpowiedniej <xref:System.Windows.NameScope> implementacji, która jest znaleziona przez znalezienie elementu, który implementuje. <xref:System.Windows.Markup.INameScope> Aby uzyskać więcej informacji na temat zakresy nazw WPF, zobacz [WPF XAML Zakresy nazw WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 Wywołanie <xref:System.Windows.FrameworkContentElement.RegisterName%2A> jest niezbędne w celu poprawnego podłączania scenorysów animacji dla aplikacji tworzonych w kodzie. Wynika to z faktu, że jedna z właściwości <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>klucza scenorysu, używa wyszukiwania nazw w czasie wykonywania, zamiast można wykonać odwołanie do elementu docelowego. Jest to prawdziwe, nawet jeśli ten element jest dostępny przez odwołanie z kodu. Aby uzyskać więcej informacji na temat tego, dlaczego należy zarejestrować nazwy dla obiektów docelowych scenorysów, zobacz [Omówienie scenorysów](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md). Animacje dla elementów zawartości są mniej typowe niż animacje w kontrolkach. [Przegląd scenorysów](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md) koncentruje się na scenariuszach kontroli.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Element do usunięcia.</param>
        <summary>Usuwa określony element z drzewa logicznego dla tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] to szczególnie istotne w przypadku scenariuszy pochodnych klasy podczas dodawania obsługi dla kolekcji podrzędnych.  
  
 Większość <xref:System.Windows.FrameworkContentElement> klas pochodnych uwidacznia dedykowane kolekcje, które są odpowiedzialne za zawieranie ( <xref:System.Windows.Documents.Span.Inlines%2A> na przykład <xref:System.Windows.Documents.Span> w klasie; <xref:System.Windows.Documents.Section.Blocks%2A> na klasie).<xref:System.Windows.Documents.Section> Wyprowadzanie z takich klas zazwyczaj może uniknąć konieczności bezpośredniego manipulowania drzewa logicznego.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkContentElement.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżący zdefiniowany lokalnie słownik zasobów.</summary>
        <value>Bieżące zdefiniowane lokalnie zasoby. Jest to słownik zasobów, w przypadku których zasoby w słowniku są dostępne za pomocą klucza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Słowniki zasobów, które mogą być zdefiniowane w całości [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] lub częściowo w programie, są zwykle tworzone jako element właściwości i zazwyczaj znajdują się na elemencie głównym dla każdej pojedynczej strony lub aplikacji. Umieszczenie słownika zasobów na tym poziomie ułatwia znalezienie poszczególnych elementów podrzędnych na stronie (lub z dowolnej strony w przypadku aplikacji). W większości scenariuszy aplikacji zaleca się zdefiniowanie stylów jako elementów obiektów w słowniku zasobów lub zdefiniowanie ich jako zasobów zewnętrznych, aby cały zasób stylu mógł być niezależny (to podejście ułatwia oddzielny Projektant obowiązki z obowiązków deweloperów przez oddzielenie plików fizycznych, które należy edytować).  
  
 Należy zauważyć, że ta właściwość zwraca tylko słownik zasobów zadeklarowany bezpośrednio w tym elemencie. Jest to inny niż rzeczywisty proces wyszukiwania zasobów, gdzie element podrzędny może uzyskać dostęp do dowolnego zasobu zdefiniowanego w każdym elemencie nadrzędnym, co umożliwia cykliczne wyszukiwanie w górę.  
  
 Do zasobów można także odwoływać się za pomocą kodu z kolekcji, ale należy pamiętać, że zasoby [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] utworzone w programie nie będą dostępne <xref:System.Windows.FrameworkContentElement.Loaded> do momentu zgłoszenia przez element, który deklaruje słownik. W rzeczywistości zasoby są analizowane asynchronicznie, a nawet <xref:System.Windows.FrameworkContentElement.Loaded> nie jest to gwarantowane, że można odwołać się do [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] określonego zasobu. Z tego powodu zazwyczaj należy uzyskać dostęp do [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] określonych zasobów tylko w ramach kodu czasu wykonywania lub za innymi [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] technikami, takimi jak style lub odwołania do rozszerzenia zasobu dla wartości atrybutów. Gdy uzyskujesz dostęp do zasobów za pośrednictwem kodu, jest to [](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) zasadniczo równoważne z DynamicResource — [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]odwołaniem z.  
  
 Podstawowa <xref:System.Windows.ResourceDictionary> obsługa metod wymaganych do dodawania, usuwania lub wykonywania zapytań dotyczących zasobów w kolekcji przy użyciu kodu. Właściwość jest settable, aby obsługiwać scenariusz całkowitego zastąpienia kolekcji Resources elementu, aby była nową lub inną <xref:System.Windows.ResourceDictionary>. <xref:System.Windows.FrameworkContentElement.Resources%2A>  
  
 Zauważ, że [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] pokazana składnia nie zawiera elementu <xref:System.Windows.ResourceDictionary>dla. Jest to przykład niejawnej składni kolekcji; Tag reprezentujący element kolekcji można pominąć. Zamiast tego można określić elementy, które są dodawane jako elementy do kolekcji. Aby uzyskać więcej informacji na temat kolekcji [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]niejawnych i, zobacz [Szczegóły składni XAML](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md). Jeden przypadek, w <xref:System.Windows.ResourceDictionary> którym jest w dalszym ciągu jawnie określony jako element, jeśli wprowadzasz scalony słownik, w którym to przypadku zazwyczaj nie ma elementów podrzędnych <xref:System.Windows.ResourceDictionary>dla tego elementu. Aby uzyskać szczegółowe informacje, zobacz [scalone słowniki zasobów](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *oneOrMoreResourceElements*  
 Jeden lub więcej elementów obiektów, z których każdy definiuje zasób. Każdy element właściwości zasobu w ramach <xref:System.Windows.ResourceDictionary> każdej z nich musi mieć unikatową wartość dla [dyrektywy x:Key](~/docs/framework/xaml-services/x-key-directive.md), która służy jako unikatowy klucz, gdy wartości <xref:System.Windows.ResourceDictionary>są pobierane z.  
  
   
  
## Examples  
 Poniższy przykład ustanawia <xref:System.Windows.FrameworkContentElement.Resources%2A> kolekcję <xref:System.Windows.Documents.FlowDocument> na elemencie głównym. <xref:System.Windows.Documents.FlowDocument>jest typową opcją, ponieważ jest jedną z kilku <xref:System.Windows.FrameworkContentElement> klas, które mają sens jako element główny, a zasoby są zwykle przechowywane w katalogu głównym strony lub nawet na wyższych poziomach, takich jak w aplikacji.  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza powiązanie do tego elementu dla określonej właściwości zależności.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">Identyfikuje właściwość powiązaną.</param>
        <param name="path">Nazwa właściwości źródłowej lub ścieżka do właściwości użytej dla powiązania.</param>
        <summary>Dołącza powiązanie do tego elementu, na podstawie podanej nazwy właściwości źródłowej jako ścieżki kwalifikacji do źródła danych.</summary>
        <returns>Rejestruje warunki powiązania. Ta wartość zwracana może być przydatna do sprawdzania błędów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>Metoda jest wygodną metodą wywołania, która przekazuje bieżące wystąpienie <xref:System.Windows.DependencyObject>jako i tworzy nowy <xref:System.Windows.Data.Binding> na podstawie podanego `path` parametru. Ten podpis jest wygodniejszy, jeśli tworzysz proste domyślne powiązanie. Jeśli musisz określić dowolne właściwości powiązania z warunkami niedomyślnymi lub chcesz użyć <xref:System.Windows.Data.MultiBinding> lub <xref:System.Windows.Data.PriorityBinding> <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> , należy użyć podpisu.  
  
   
  
## Examples  
 Poniższy przykład ustawia powiązanie dla <xref:System.Windows.Documents.Paragraph> elementu, tworząc nowy obiekt danych niestandardowych, ustanawiając ten obiekt jako <xref:System.Windows.FrameworkContentElement.DataContext%2A>i ustawiając ścieżkę powiązania do właściwości w tym elemencie.  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkContentElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">Identyfikuje właściwość powiązaną.</param>
        <param name="binding">Reprezentuje powiązanie danych.</param>
        <summary>Dołącza powiązanie do tego elementu na podstawie podanego obiektu powiązania.</summary>
        <returns>Rejestruje warunki powiązania. Ta wartość zwracana może być przydatna do sprawdzania błędów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wygodną metodą wywołania <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, która przekazuje bieżące wystąpienie <xref:System.Windows.DependencyObject>jako.  
  
   
  
## Examples  
 Poniższy przykład ustawia powiązanie dla <xref:System.Windows.Documents.Paragraph> elementu, tworząc nowe <xref:System.Windows.Data.Binding> i ustawiając Źródło dla nowo skompilowanego `DateTime` obiektu.  
  
 [!code-csharp[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#setbinding)]
 [!code-vb[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#setbinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkContentElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Właściwość, z którą jest powiązany zasób.</param>
        <param name="name">Nazwa zasobu.</param>
        <summary>Wyszukuje zasób o określonej nazwie i konfiguruje odwołanie do zasobu dla określonej właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Odwołanie do zasobu jest podobne do użycia [rozszerzenia znacznika DynamicResource —](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) w znaczniku. Odwołanie do zasobu tworzy wyrażenie wewnętrzne, które dostarcza wartość określonej właściwości w oparciu o odroczony czas wykonywania. Wyrażenie zostanie obliczone ponowne, gdy słownik zasobów wskazuje zmianę wartości za pomocą wewnętrznych zdarzeń, lub gdy bieżący element zostanie odtworzony jako obiekt nadrzędny (zmiana nadrzędna spowodowałaby zmianę ścieżki wyszukiwania słownika).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy procesy serializacji powinny serializować zawartość <see cref="P:System.Windows.FrameworkContentElement.Resources" /> właściwości w wystąpieniach tej klasy.</summary>
        <returns><see langword="true" />Jeśli wartość <see langword="false" />właściwości powinna być serializowana; w przeciwnym razie,. <see cref="P:System.Windows.FrameworkContentElement.Resources" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spowoduje to zwrócenie `true` tego miejsca, o ile w lokalnym <xref:System.Windows.FrameworkContentElement.Resources%2A>miejscu istnieje co najmniej jeden zasób z kluczem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy procesy serializacji powinny serializować zawartość <see cref="P:System.Windows.FrameworkContentElement.Style" /> właściwości w wystąpieniach tej klasy.</summary>
        <returns><see langword="true" />Jeśli wartość <see langword="false" />właściwości powinna być serializowana; w przeciwnym razie,. <see cref="P:System.Windows.FrameworkContentElement.Style" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spowoduje to zwrócenie `true` , <xref:System.Windows.Style> Jeśli zestaw jest ustawiony lokalnie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy dowolne skojarzone źródło danych uczestniczy w powiązaniu w tym elemencie zostanie zmienione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie <xref:System.Windows.Data.Binding.SourceUpdated> wskazuje zdarzenie, które jest zgłaszane przez wszystkie <xref:System.Windows.Data.Binding> skojarzone z tym elementem.  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object SourceUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia styl, który będzie używany przez ten element.</summary>
        <value>Stosowany, niedomyślny styl elementu, jeśli jest obecny. W przeciwnym razie. <see langword="null" /> Wartość domyślna dla konstruowanej <see cref="T:System.Windows.FrameworkContentElement" /> domyślnie to. <see langword="null" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący styl jest często dostarczany przy użyciu stylu domyślnego z motywów lub stylów zwykle stosowanych do obiektów tego typu według zasobów na poziomie strony lub aplikacji (styl niejawny). Ta właściwość nie ustawia ani nie zwraca domyślnych stylów (motywu), ale zwraca styl niejawny lub jawny styl. W przypadku niejawnych lub jawnych stylów nie ma znaczenia, czy styl jest dostępny jako zasób lub zdefiniowany lokalnie.  
  
 Ustawienie stylów ma pewne ograniczenia. W dowolnym momencie możesz zresetować <xref:System.Windows.FrameworkContentElement.Style%2A> całą Właściwość <xref:System.Windows.Style> , co spowoduje wymuszenie przetworzenia układu. Jednakże, gdy tylko ten styl jest umieszczany przez załadowany element, <xref:System.Windows.Style> powinien być uważany za zapieczętowany. Podjęto próbę dokonania zmiany we właściwościach w stylu w użyciu (takich jak wszystkie elementy w kolekcji <xref:System.Windows.Style.Setters%2A>), co powoduje zgłoszenie wyjątku. Styl zdefiniowany w znacznikach jest traktowany jako używany zaraz po załadowaniu go ze słownika zasobów (dla zasobów) lub strony, w której jest zawarty w programie, jest ładowany (dla stylów wbudowanych).  
  
 <xref:System.Windows.FrameworkContentElement.Style%2A>jest właściwością zależności z specjalnym pierwszeństwem. Lokalnie ustawiony styl zazwyczaj działa przy najwyższym priorytecie w systemie właściwości. Jeśli w tym momencie mawartośćnull,podczasładowaniasystemuwłaściwościsprawdzaniejawnestylejakozdefiniowanezasoby,któreokreślajątentyp.<xref:System.Windows.FrameworkContentElement.Style%2A> Jeśli styl nadal ma wartość null po wykonaniu tego kroku, styl pochodzi z domyślnego stylu (motywu), ale styl domyślny nie jest zwracany w <xref:System.Windows.FrameworkContentElement.Style%2A> wartości właściwości. Zobacz [pierwszeństwo wartości właściwości zależności](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object Style="{resourceExtension StyleResourceKey}"/>  
```  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *resourceExtension*  
 Jeden z następujących elementów:, lub. Zobacz [zasoby XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Klucz, który identyfikuje żądany styl. Klucz odnosi się do istniejącego zasobu w <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Składnia elementu właściwości jest technicznie możliwa, ale nie jest zalecana. Zobacz [wbudowane style i szablony](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).  Odwołanie do powiązania przy użyciu [szablonu TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md) lub <xref:System.Windows.Data.Binding> jest również możliwe, ale nietypowe.  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.StyleProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 Poniższy przykład ustanawia <xref:System.Windows.FrameworkContentElement.Resources%2A> kolekcję <xref:System.Windows.Documents.FlowDocument> na elemencie głównym, a następnie odwołuje się do niego jako zasób jako określony styl dla <xref:System.Windows.Documents.Paragraph>.  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.Style" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nazwa żądanej właściwości otoczenia.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> metodę.</summary>
        <returns><see langword="true" />Jeśli <paramref name="propertyName" /> jest dostępna; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.FrameworkContentElement> gdy wystąpienie jest rzutowane <xref:System.Windows.Markup.IQueryAmbient> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkContentElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia dowolną wartość obiektu, która może być używana do przechowywania informacji niestandardowych o tym elemencie.</summary>
        <value>Zamierzona wartość. Ta właściwość nie ma wartości domyślnej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest analogiczna do właściwości tagów w innych modelach programowania firmy Microsoft, takich jak Visual Basic for Applications lub Windows Forms. Należy zapewnić istniejące miejsce do przechowywania niektórych podstawowych informacji niestandardowych o dowolnym elemencie bez wymuszania stosowania podklasy przez deweloperów aplikacji.  
  
<a name="xamlValues_Tag"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 Ponieważ ta właściwość przyjmuje obiekt, należy użyć opcji użycie elementu właściwości w celu ustawienia <xref:System.Windows.FrameworkContentElement.Tag%2A> właściwości w języku XAML na coś innego niż obiekt z znanym i wbudowanym konwerterem typów, takim jak ciąg. Obiekty używane w ten sposób zwykle nie znajdują się w standardowych przestrzeniach nazw WPF i w związku z tym mogą wymagać mapowania przestrzeni nazw do zewnętrznej przestrzeni nazw, aby można było je wprowadzić jako elementy XAML.  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.TagProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.Tag" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy dowolna skojarzona właściwość docelowa uczestniczy w powiązaniu dla tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie <xref:System.Windows.Data.Binding.TargetUpdated> wskazuje zdarzenie, które jest zgłaszane przez wszystkie <xref:System.Windows.Data.Binding> skojarzone z tym elementem. Zazwyczaj oznacza to, że powiązanie w powiązaniu jest powiązaniem dwukierunkowym i że właściwość zależności powiązanej potwierdza unieważnienie poprzedniej wartości właściwości na dowolnym schemacie walidacji lub buforowania obsługiwanym przez właściwość.  
  
 Argumenty zdarzeń tego zdarzenia będą informować o zmianie powiązanej właściwości.  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object TargetUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do elementu nadrzędnego szablonu tego elementu. Ta właściwość nie jest istotna, jeśli element nie został utworzony za pomocą szablonu.</summary>
        <value><see cref="T:System.Windows.FrameworkTemplate" /> Element<see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> , który spowodował utworzenie tego elementu. Ta wartość jest często <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Szablony są faktycznie udostępnionymi obiektami, gdzie zawartość szablonu jest tworzona tylko raz. W związku z tym, Jeśli uzyskujesz odwołanie do obiektu, który pochodzi z szablonu, może się okazać, że jawne Drzewo logiczne nie dociera do głównego elementu strony. Aby można było połączyć takie odwołanie szablonu z drzewem logicznym strony, należy uzyskać <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> wartość i kontynuować nawigowanie w drzewie elementów zgodnie z potrzebami.  
  
 <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>często są `null` używane w przypadku wspólnych obiektów, ponieważ w przypadku uzyskania odwołania do obiektu z zewnątrz strony w aplikacji za pośrednictwem typowych metod ten element prawdopodobnie nie został utworzony na podstawie szablonu. Przypadki, <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> w których mogą `null` nie być uwzględniane operacje, takie jak testowanie trafień, obsługa zdarzeń dla pewnych zdarzeń wejściowych niskiego poziomu lub praca z modułami wyliczającymi, które mogą zwrócić elementy, które pochodzą z szablonów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkContentElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt etykietki narzędzia, który jest wyświetlany dla tego elementu w [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</summary>
        <value>Obiekt ToolTip.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość tej właściwości jest typu <xref:System.Windows.Controls.ToolTip>, to jest etykietka narzędzia, która będzie używana [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]w.  Jeśli wartość jest dowolnego innego typu, ta wartość będzie używana jako *zawartość* dla <xref:System.Windows.Controls.ToolTip> dostarczonego (konstruowanego) przez system. Aby uzyskać więcej informacji <xref:System.Windows.Controls.ToolTipService>, zobacz. Klasa usługi zawiera dołączone właściwości, których można użyć w celu dodatkowego dostosowania etykietki narzędzia.  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```xaml 
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
```

—lub—

```xaml
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```

<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *toolTipContent*  
 Ciąg, który zmienia się w tekście <xref:System.Windows.FrameworkContentElement.ToolTip%2A>wyświetlanym.  
  
 *toolTipObjectContent*  
 Niektóre obiekty, podane w formularzu elementu obiektu, które powinny być używane jako zawartość <xref:System.Windows.FrameworkContentElement> . Zwykle jest <xref:System.Windows.FrameworkElement> to lub inny element, który tworzy składanie układu <xref:System.Windows.FrameworkContentElement.ToolTip%2A>dla, ostatecznie zawierający zawartość tekstową w ramach składania. <xref:System.Windows.Controls.ToolTip> W tym użyciu element jest tworzony niejawnie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]z przeanalizowanej, a zawartość *toolTipObjectContent* jest ustawiana jako jej <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> właściwość.  
  
 <`ToolTip` .../>  
 Zobacz <xref:System.Windows.Controls.ToolTip>.  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.ToolTipProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład ustawia wartość <xref:System.Windows.FrameworkElement.ToolTip%2A> właściwości bezpośrednio na ciąg.  
  
 [!code-csharp[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/csharp/VS_Snippets_Wpf/TableSnippets2/CSharp/Window1.xaml.cs#_table_rowgroups_maniprows)]
 [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TableSnippets2/visualbasic/window1.xaml.vb#_table_rowgroups_maniprows)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje tuż przed zamknięciem dowolnej etykietki narzędzia w elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby pominąć zamykanie etykietki narzędzia, procedury obsługi zdarzenia powinny oznaczać ją jako obsłużoną.  
  
 To zdarzenie nie może być <xref:System.Windows.EventTrigger> w stylu. Jest to spowodowane tym, że pole Identyfikator tego zdarzenia ponownie używa implementacji z usługi, która nie uwidacznia metod Add/Remove dla zdarzenia.  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|  
|Strategia routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje przegląd [zdarzeń kierowanych.](~/docs/framework/wpf/advanced/routed-events-overview.md) <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekty identyfikatorów zdarzeń są tworzone po zarejestrowaniu zdarzeń kierowanych <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>(zobacz) i mogą być używane do dodawania programów obsługi klasy ( <xref:System.Windows.EventManager.RegisterClassHandler%2A>Zobacz). Obiekty identyfikatorów zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu i metodę narzędzia do dodawania właścicieli dla zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po otwarciu dowolnej etykietki narzędzia w elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby ręcznie otworzyć etykietki narzędzi, programy obsługi zdarzeń powinny oznaczyć odpowiednie zdarzenie jako obsłużone. W przeciwnym razie wartość <xref:System.Windows.FrameworkContentElement.ToolTip%2A> właściwości zostanie użyta do automatycznego otwarcia menu kontekstowego. Oznaczenie obsłużonego zdarzenia będzie efektywnie anulować akcję domyślną i może być możliwością zresetowania wartości <xref:System.Windows.FrameworkContentElement.ToolTip%2A> właściwości, a następnie otworzenia nowej. <xref:System.Windows.Controls.ContextMenu> Należy zauważyć, że to zdarzenie nie zostanie wywołane, jeśli <xref:System.Windows.FrameworkContentElement.ToolTip%2A> jest odwołaniem o wartości null lub w inny sposób.  
  
 To zdarzenie nie może być <xref:System.Windows.EventTrigger> w stylu. Jest to spowodowane tym, że pole Identyfikator tego zdarzenia ponownie używa implementacji z usługi, która nie uwidacznia metod Add/Remove dla zdarzenia.  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|  
|Strategia routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje przegląd [zdarzeń kierowanych.](~/docs/framework/wpf/advanced/routed-events-overview.md) <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekty identyfikatorów zdarzeń są tworzone po zarejestrowaniu zdarzeń kierowanych <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>(zobacz) i mogą być używane do dodawania programów obsługi klasy ( <xref:System.Windows.EventManager.RegisterClassHandler%2A>Zobacz). Obiekty identyfikatorów zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu i metodę narzędzia do dodawania właścicieli dla zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.ToolTip" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkContentElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Identyfikator klucza zasobu, który ma zostać znaleziony.</param>
        <summary>Wyszukuje zasób z określonym kluczem i zwraca ten zasób, jeśli został znaleziony.</summary>
        <returns>Znaleziony zasób. Jeśli żaden zasób nie został znaleziony <see langword="null" /> , jest zwracany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zasób nie zostanie odnaleziony w elemencie wywołującym, drzewo nadrzędne będzie przeszukiwane przy użyciu drzewa logicznego w taki sam sposób, w jaki drzewo będzie przeszukiwane, jeśli w czasie wykonywania zażądano dynamicznego odwołania do zasobu.  
  
 Zazwyczaj można natychmiast rzutować wartość zwracaną na typ właściwości, którą próbowano ustawić przy użyciu zwróconej wartości zasobu.  
  
 <xref:System.Windows.FrameworkContentElement.FindResource%2A> Metoda ma podobne zachowanie, z tą różnicą, że zgłosi wyjątek w przypadku braku znajdowania zasobu z podanym kluczem.  
  
   
  
## Examples  
 Poniższy przykład umożliwia znalezienie zasobu zdefiniowanego w znaczniku i zastosowanie go do pewnej właściwości elementu w odpowiedzi na zdarzenie kierowane.  
  
 [!code-csharp[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#tryfindresource)]
 [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#tryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy element zostanie usunięty z drzewa elementów załadowanych elementów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia kierowane bezpośrednio nie obserwują trasy, są obsługiwane tylko w obrębie tego samego elementu, w którym zostały zgłoszone. Zdarzenia kierowane bezpośrednio obsługują inne kierowane zdarzenia dotyczące zdarzeń: obsługują kolekcję programów obsługi i mogą być używane jako <xref:System.Windows.EventTrigger> style.  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.UnloadedEvent>|  
|Strategia routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje przegląd [zdarzeń kierowanych.](~/docs/framework/wpf/advanced/routed-events-overview.md) <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekty identyfikatorów zdarzeń są tworzone po zarejestrowaniu zdarzeń kierowanych <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>(zobacz) i mogą być używane do dodawania programów obsługi klasy ( <xref:System.Windows.EventManager.RegisterClassHandler%2A>Zobacz). Obiekty identyfikatorów zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu i metodę narzędzia do dodawania właścicieli dla zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkContentElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa pary nazwa-obiekt do usunięcia z bieżącego zakresu.</param>
        <summary>Upraszcza dostęp do <see cref="T:System.Windows.NameScope" /> metody Wycofaj rejestrację.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Musisz wyrejestrować nazwy tylko wtedy, gdy zamierzasz ponownie zarejestrować inny element o tej samej nazwie.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkContentElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stosuje domyślny styl do bieżącego <see cref="T:System.Windows.FrameworkContentElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
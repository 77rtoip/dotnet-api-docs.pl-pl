<Type Name="FrameworkContentElement" FullName="System.Windows.FrameworkContentElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8ea19870aeed3af5201d5437a911c5c486d40e5f" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55331604" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkContentElement&#xA;Inherits ContentElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkContentElement : System::Windows::ContentElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkContentElement = class&#xA;    inherit ContentElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.ContentElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see cref="T:System.Windows.FrameworkContentElement" /> Implementacja poziomie struktury WPF i rozszerzenie <see cref="T:System.Windows.ContentElement" /> klasy bazowej. <see cref="T:System.Windows.FrameworkContentElement" /> dodaje obsługę dodatkowe interfejsy API danych wejściowych (w tym menu etykietek narzędzi i kontekstu), scenorysów, kontekst danych dla powiązania danych, obsługę stylów i drzewo logiczne Pomocnik APIs.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement> jeszcze nie definiuje swój własny sposób renderowania; utworzenie wystąpienia rzeczywistego <xref:System.Windows.FrameworkContentElement> wystąpienie klasy w kodu lub języka znaczników jest możliwe, ale nie wyświetla żadnego obrazu w [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] aplikacji [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]. Renderowanie logiki musi być podana według klasy, które przyjmują <xref:System.Windows.FrameworkContentElement> elementy podrzędne w ramach ich model zawartości lub w <xref:System.Windows.FrameworkContentElement> klas pochodnych.  
  
 <xref:System.Windows.FrameworkContentElement> celowo równoleżnikami wiele takich samych [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] jako <xref:System.Windows.FrameworkElement>. Pamiętaj, że niektóre [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] znalezione na <xref:System.Windows.FrameworkElement> nie będzie miał <xref:System.Windows.FrameworkContentElement> równoważne. Kilka <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] są funkcje, takie jak reprezentacji geometry ani układu, które nie są istotne dla <xref:System.Windows.FrameworkContentElement>.  
  
 Większość istniejących <xref:System.Windows.FrameworkContentElement> klasach pochodnych można znaleźć w <xref:System.Windows.Documents> przestrzeni nazw. Wiele z tych klas pochodnych zaimplementuj elementy modelu dokument przepływu. Niektórych klas pochodnych, takich jak <xref:System.Windows.Documents.Hyperlink> mają pewne funkcje podobne do kontroli, ale są uzyskiwane z <xref:System.Windows.FrameworkContentElement> taki sposób, że elementy sterowania przypominającej nadal mogą uczestniczyć w modelu dokument przepływu.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.FrameworkElement" />
    <altmember cref="T:System.Windows.ContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkContentElement" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Element podrzędny, która ma zostać dodana.</param>
        <summary>Dodaje podany element jako element podrzędny tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może zgłosić wyjątek, jeśli wywołano w danym momencie, gdy drzewo logiczne jest on postanowiliśmy przez inny proces.  
  
 Większość <xref:System.Windows.FrameworkContentElement> klasy pochodne ujawnić dedykowany kolekcji, które są odpowiedzialne za zawierania (na przykład <xref:System.Windows.Documents.Span.Inlines%2A> na <xref:System.Windows.Documents.Span> klasy; <xref:System.Windows.Documents.Section.Blocks%2A> na <xref:System.Windows.Documents.Section> klasy). Zazwyczaj można uniknąć konieczności manipulowania drzewo logiczne bezpośrednio w przypadku klasy wyprowadzonej z klasy te zamiast tego. Praca z drzewa logicznego dla elementów zawartości jest zaawansowanym scenariuszu, które mogą wymagać wyspecjalizowane parser lub wyspecjalizowanego <xref:System.Windows.FrameworkElement> działającego jako element nadrzędny renderowania (host zawartości).  
  
 Aby uzyskać więcej informacji o sposobie używania <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> i <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, zobacz [drzewa w WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkContentElement.LogicalChildren" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkContentElement.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Metoda wywoływana przed elementem jest zainicjowany.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Zastępuje tę metodę, aby zapewnić specjalnej obsługi, która powinna występować przed swoje element jest inicjowany podczas element proces ładowania.  
  
Twoja implementacja powinny wywoływać implementację podstawową, ponieważ implementacja base (ustawienie domyślne) ustawia niektóre wewnętrznego flagi do śledzenia inicjowania.  
  
Podstawowa implementacja spowoduje zgłoszenie wyjątku, jeśli <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> jest wywoływana więcej niż jeden raz w tym samym elemencie przed osiągnięciem <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna się Sekwencja akcji, które znajdują się w podanej scenorysu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkContentElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">Scenorysu, aby rozpocząć.</param>
        <summary>Rozpoczyna się Sekwencja akcji, które znajdują się w podanej scenorysu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Związane z sygnaturami, które nie korzystają z `isControllable`, parametr, lub gdy określono tego parametru `false`, zegary osi czasu, skojarzone z animacji są usuwane, zaraz po osiągnięciu okresu "Fill". W związku z tym animacji nie może zostać uruchomione ponownie po są uruchamiane jeden raz. Należy pamiętać, że kontrolowanie animacji również wymaga scenorysu nazwana lub dostępne w momencie wystąpienia w kodzie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">Scenorysu, aby rozpocząć.</param>
        <param name="handoffBehavior">Wartość wyliczenia, opisujący zachowanie do użycia, jeśli właściwość opisanego w serii ujęć już jest animowany.</param>
        <summary>Rozpoczyna się Sekwencja akcji, które znajdują się w podanej scenorysu, za pomocą opcji określonych dla co powinno nastąpić, jeśli właściwość jest już animowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Związane z sygnaturami, które nie korzystają z `isControllable`, parametr, lub gdy określono tego parametru `false`, zegary osi czasu, skojarzone z animacji są usuwane, zaraz po osiągnięciu okresu "Fill". W związku z tym animacji nie może zostać uruchomione ponownie po są uruchamiane jeden raz. Należy pamiętać, że kontrolowanie animacji również wymaga scenorysu nazwana lub dostępne w momencie wystąpienia w kodzie.  
  
## <a name="using-the-compose-handoffbehavior"></a>Korzystanie z Compose HandoffBehavior  
 Po zastosowaniu <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> do właściwości przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> obiektów była poprzednio skojarzona z tą właściwością, kontynuując zużywanie zasobów systemowych; nie system chronometrażu Automatycznie usuwaj zegary.  
  
 Aby uniknąć problemów z wydajnością, po zastosowaniu dużej liczby zegary przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, tworzenie zegary należy usunąć z animowanych właściwości po ich zakończeniu. Istnieje kilka sposobów, aby usunąć zegar:  
  
-   Aby usunąć wszystkie zegary z właściwością, należy użyć <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metoda obiekt animowany. Określa właściwość, jest animowany podczas pierwszego parametru i `null` jako drugiego. Spowoduje to usunięcie wszystkie zegary animacji z właściwości.  
  
-   Aby usunąć określony <xref:System.Windows.Media.Animation.AnimationClock> z listy zegary, użyj <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość <xref:System.Windows.Media.Animation.AnimationClock> można pobrać <xref:System.Windows.Media.Animation.ClockController>, następnie wywołać <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metody <xref:System.Windows.Media.Animation.ClockController>. Jest to zazwyczaj wykonywane <xref:System.Windows.Media.Animation.Clock.Completed> program obsługi zdarzeń dla zegara. Należy pamiętać, że tylko zegary głównego można kontrolować, <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość zegara podrzędne zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzeń nie jest inicjowane, jeśli efektywnym czasem trwania zegara jest nieskończona.  W takim przypadku użytkownik musi określić, kiedy do wywołania <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Jest to głównie problemu dla animacji na obiekty, które mają długi okres istnienia.  Gdy obiekt jest bezużyteczne, jego zegary również są odłączone i wyrzucania.  
  
 Aby uzyskać więcej informacji o obiektach zegara, zobacz [Animacja i System chronometrażu w — Przegląd](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">Scenorysu, aby rozpocząć.</param>
        <param name="handoffBehavior">Wartość wyliczenia, opisujący zachowanie do użycia, jeśli właściwość opisanego w serii ujęć już jest animowany.</param>
        <param name="isControllable">Deklaruje, czy animacja jest kontrolowane (może być wstrzymana) po jej ponownym uruchomieniu.</param>
        <summary>Rozpoczyna się sekwencję akcji, które są zawarte w podanej scenorysu, o określonym stanie dla formantu animacji po jej ponownym uruchomieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Związane z sygnaturami, które nie korzystają z `isControllable`, parametr, lub gdy określono tego parametru `false`, zegary osi czasu, skojarzone z animacji są usuwane, zaraz po osiągnięciu okresu "Fill". W związku z tym animacji nie może zostać uruchomione ponownie po są uruchamiane jeden raz. Należy pamiętać, że kontrolowanie animacji również wymaga scenorysu nazwana lub dostępne w momencie wystąpienia w kodzie.  
  
## <a name="using-the-compose-handoffbehavior"></a>Korzystanie z Compose HandoffBehavior  
 Po zastosowaniu <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> do właściwości przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> obiektów była poprzednio skojarzona z tą właściwością, kontynuując zużywanie zasobów systemowych; nie system chronometrażu Automatycznie usuwaj zegary.  
  
 Aby uniknąć problemów z wydajnością, po zastosowaniu dużej liczby zegary przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, tworzenie zegary należy usunąć z animowanych właściwości po ich zakończeniu. Istnieje kilka sposobów, aby usunąć zegar:  
  
-   Aby usunąć wszystkie zegary z właściwością, należy użyć <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metoda obiekt animowany. Określa właściwość, jest animowany podczas pierwszego parametru i `null` jako drugiego. Spowoduje to usunięcie wszystkie zegary animacji z właściwości.  
  
-   Aby usunąć określony <xref:System.Windows.Media.Animation.AnimationClock> z listy zegary, użyj <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość <xref:System.Windows.Media.Animation.AnimationClock> można pobrać <xref:System.Windows.Media.Animation.ClockController>, następnie wywołać <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metody <xref:System.Windows.Media.Animation.ClockController>. Jest to zazwyczaj wykonywane <xref:System.Windows.Media.Animation.Clock.Completed> program obsługi zdarzeń dla zegara. Należy pamiętać, że tylko zegary głównego można kontrolować, <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość zegara podrzędne zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzeń nie jest inicjowane, jeśli efektywnym czasem trwania zegara jest nieskończona.  W takim przypadku użytkownik musi określić, kiedy do wywołania <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Jest to głównie problemu dla animacji na obiekty, które mają długi okres istnienia.  Gdy obiekt jest bezużyteczne, jego zegary również są odłączone i wyrzucania.  
  
 Aby uzyskać więcej informacji o obiektach zegara, zobacz [Animacja i System chronometrażu w — Przegląd](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Data.BindingGroup" /> używany dla elementu.</summary>
        <value><see cref="T:System.Windows.Data.BindingGroup" /> Używany dla elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Element <xref:System.Windows.Data.BindingGroup> może służyć do sprawdzania poprawności wartości wielu właściwości obiektu. Na przykład załóżmy, że aplikacja monituje użytkownika o podanie adresu, a następnie wypełnia obiekt typu `Address`, który ma właściwości `Street`, `City`, `ZipCode`, i `Country`, przy użyciu wartości, użytkownik podana. Aplikacja ma panel, który zawiera cztery <xref:System.Windows.Controls.TextBox> formantów, z których każdy jest powiązane z jedną z właściwości obiektu. Możesz użyć <xref:System.Windows.Controls.ValidationRule> w <xref:System.Windows.Data.BindingGroup> do sprawdzania poprawności `Address` obiektu. Na przykład <xref:System.Windows.Controls.ValidationRule> można upewnić się, że kod pocztowy jest prawidłowy dla kraju adresu.  
  
 Elementy podrzędne dziedziczą <xref:System.Windows.Data.BindingGroup> z ich elementów nadrzędnych, tak jak w przypadku wszystkich innych właściwości dziedziczonych.  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkContentElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Próbuje przenieść ten element do wyświetlenia w ramach przewijany regionów, który jest zawarty w.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przez wywołanie tej metody, efektywnie wywołasz <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> na wszelkie przewijany obszar nadrzędny, który zawiera element (element nadrzędny bardzo dobrze może być <xref:System.Windows.FrameworkElement>, a nie <xref:System.Windows.FrameworkContentElement>). Jeśli ten element nie jest zawarta w przewijanym obszarze, zdarzenie jest zgłaszane w dalszym ciągu, ale nie będzie żadnego efektu.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms752352(v=vs.90)">Instrukcje: Utwórz ScrollViewer</related>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia element menu kontekstowego, który powinien zostać wyświetlony każdorazowo żądania za pomocą menu kontekstowego [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] z w ramach tego elementu.</summary>
        <value>Menu kontekstowe, która używa tego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Przykład w następujących miejscach <xref:System.Windows.Controls.ContextMenu> na <xref:System.Windows.Documents.Paragraph>.  
  
 [!code-xaml[ContentElementsSmorgasbord#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#contextmenu)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje zaraz przed zamknięciem dowolnego menu kontekstowego w elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby pominąć zamknięcia menu kontekstowe, programy obsługi zdarzeń należy oznaczyć go jako obsługiwane.  
  
 Aby użyć tego zdarzenia jako <xref:System.Windows.EventTrigger> w stylu, musi odwoływać się podstawowy identyfikator zdarzenia usługi:  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (Tego użycia jest wymagana, ponieważ implementacja zdarzeń w <xref:System.Windows.FrameworkContentElement> czy uwidacznia bazowe zdarzenie usługi nie jest poprawnie mapowany <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> identyfikatora do użycia w wyzwalacze).  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|  
|Strategii routingu|Propagacja|  
|Delegate|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
   
  
## Examples  
 Poniższy przykład wykonuje program obsługi, który zmienia kursora nad obszarem nazwane `DisplayArea` (niewyświetlany). Komentarz wskazówki w <xref:System.Windows.UIElement> użycia, ale w rzeczywistości w tym przykładzie będzie taka sama Jeśli `DisplayArea` zostały <xref:System.Windows.FrameworkContentElement>.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [kierowane Przegląd zdarzeń](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekty identyfikator zdarzenia są tworzone podczas zarejestrowanych zdarzeń trasowanych (zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) i następnie można dodać funkcje obsługi klas (zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Identyfikator obiekty zawierają nazwę identyfikującą typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po otwarciu dowolnego menu kontekstowego w elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby ręcznie otworzyć menu kontekstowe, programy obsługi zdarzeń należy oznaczyć istotnych zdarzeń jako obsługiwane. W przeciwnym razie istniejącej wartości <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> zostanie użyta właściwość, aby automatycznie otworzyć menu kontekstowe. Oznaczanie zdarzeń obsługiwane skutecznie spowoduje anulowanie domyślnej akcji i może być możliwość resetowania wartości <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> właściwości, a następnie otwórz nowy <xref:System.Windows.Controls.ContextMenu>. Jednak jest błąd chronometrażu, których należy wiedzieć. W celu całkowitego zastąpienia menu kontekstowego za pośrednictwem <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> obsługi menu kontekstowe początkowej nie mogą być null / puste. Alternatywnie może być konieczne obsługi zdarzeń, a następnie ręcznie Otwórz nowe menu kontekstowego. Aby uzyskać więcej informacji, zobacz [jak: Obsługa zdarzenia ContextMenuOpening](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).  
  
 Aby użyć tego zdarzenia jako <xref:System.Windows.EventTrigger> w stylu, musi odwoływać się podstawowy identyfikator zdarzenia usługi:  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (Tego użycia jest wymagana, ponieważ implementacja zdarzeń w <xref:System.Windows.FrameworkContentElement> czy uwidacznia bazowe zdarzenie usługi nie jest poprawnie mapowany <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> identyfikatora do użycia w wyzwalacze).  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|  
|Strategii routingu|Propagacja|  
|Delegate|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [kierowane Przegląd zdarzeń](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekty identyfikator zdarzenia są tworzone podczas zarejestrowanych zdarzeń trasowanych (zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) i następnie można dodać funkcje obsługi klas (zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Identyfikator obiekty zawierają nazwę identyfikującą typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkContentElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kursor wyświetlany, gdy wskaźnik myszy znajduje się nad tym elementem.</summary>
        <value>Kursor do wyświetlenia. Wartość domyślna jest zdefiniowany jako <see langword="null" /> dla tej właściwości zależności. Jednak domyślnie praktyczne w czasie wykonywania będą pochodzić z różnych czynników.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas ustawiania tej właściwości w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] procesora zależy od typu konwersji dla <xref:System.Windows.Input.Cursor> klasy można obliczyć wartości ciągu. Podany ciąg powinna być wyliczana jako <xref:System.Windows.Input.CursorType> wartość. Zobacz <xref:System.Windows.Input.Cursor> Aby uzyskać szczegółowe informacje.  
  
 Czy kursor zgodnie z ustaleniami tej właściwości będzie lub nie będą wyświetlane, gdy wskaźnik myszy znajduje się nad tym elementem jest również zależny od wartości <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> właściwości. Ponadto zdarzenie powiązane zagadnienia, takich jak active przeciągnij, przechwytywanie myszy, tryby w ramach kontrolki i tak dalej, edycji tekstu wpłynie również na kursora o wyższym priorytecie niż wartość, którą określisz w tej właściwości.  
  
 Aby cofnąć ustawienie tej właściwości do ostatecznej domyślne zachowanie, ustaw ją na `null` ponownie.  
  
 `null` Domyślne tak naprawdę oznacza, że określenie wartości praktyczne kursora jest odroczone tutaj mają być uzyskiwane z innego miejsca. Jeśli prezentowany żadnych programowe wartości z dowolnego źródła domyślnego kursora nad [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] aplikacja będzie strzałki.  
  
 Każdy przepływ wskaźnik myszy nad [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] aplikacji zgłasza <xref:System.Windows.ContentElement.QueryCursor> zdarzeń. Bąbelków zdarzeń, a każdy element wzdłuż trasy ma możliwość obsługi zdarzenia i ustawić wartość kursora za pośrednictwem argumentów tego zdarzenia. Jeśli tak się stanie, fakt, że zdarzenie jest obsługiwane i została zmieniona wartość w argumentach mają pierwszeństwo przed wartością <xref:System.Windows.FrameworkContentElement.Cursor%2A> właściwości na dowolnym poziomie, chyba że <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> jest ustawiona.  
  
 Jeśli kursor niestandardowe nie są tworzone, zwykle możesz ustawić tę właściwość na wartość właściwości statycznej <xref:System.Windows.Input.Cursors> klasy.  
  
 Ustawienie <xref:System.Windows.Input.Cursor> niestandardowej wartości nie jest włączone w częściowej relacji zaufania. Aby uzyskać więcej informacji na temat niestandardowych kursorów, zobacz [przegląd danych wejściowych](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.CursorProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład ustawia kursor niestandardowej wartości.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkContentElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkContentElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kontekst danych dla elementu, gdy uczestniczy w powiązaniu danych.</summary>
        <value>Obiekt do użycia jako kontekstu danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Kontekst danych* pojęcie, która umożliwia elementom dziedziczenie informacji z ich elementów nadrzędnych źródło powiązania, która jest używana do powiązania, a także innych charakterystyk powiązania, takich jak ścieżka.  
  
 Kontekst danych można ustawić bezpośrednio do [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] obiektu z powiązaniami oceny właściwości tego obiektu. Alternatywnie, można ustawić kontekstu danych <xref:System.Windows.Data.DataSourceProvider> obiektu.  
  
 Ta właściwość zależności dziedziczy wartości właściwości. Jeśli są elementami podrzędnymi bez innych wartości dla <xref:System.Windows.FrameworkContentElement.DataContext%2A> nawiązane, przy użyciu wartości lokalnych lub style, system właściwość ustawi wartość <xref:System.Windows.FrameworkContentElement.DataContext%2A> tę wartość przypisaną wartością najbliższym elemencie nadrzędnym.  
  
 Alternatywnie można użyć jednej z następujących właściwości <xref:System.Windows.Data.Binding> klasy, aby jawnie określić źródło wiążące: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, lub <xref:System.Windows.Data.Binding.RelativeSource%2A>. Aby uzyskać więcej informacji, zobacz [jak: Określ źródło wiążące](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).  
  
 W [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkContentElement.DataContext%2A> najczęściej jest ustawiony jako <xref:System.Windows.Data.Binding> deklaracji. Można użyć składni elementu właściwości lub Składnia atrybutu. Składnia atrybutu jest wyświetlana w przykładzie pokazanym na tej stronie. Można również ustawić <xref:System.Windows.FrameworkContentElement.DataContext%2A> w kodzie.  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *dataContextObject*  
 Bezpośrednio osadzonego obiektu, który służy jako kontekst danych dla powiązań w elemencie nadrzędnym. Zazwyczaj ten obiekt jest <xref:System.Windows.Data.Binding> lub inne <xref:System.Windows.Data.BindingBase> podklasę. Alternatywnie nieprzetworzone dane, dowolnego [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] przeznaczone dla powiązania mogą być umieszczane w tym miejscu przy użyciu rzeczywistego powiązania zdefiniowane w dalszej części typu obiektu.  
  
 *bindingUsage*  
 Użycie powiązania, który ocenia do kontekstu odpowiednie dane. Aby uzyskać więcej informacji, zobacz [— rozszerzenie znaczników powiązania](~/docs/framework/wpf/advanced/binding-markup-extension.md).  
  
 *resourceExtension*  
 Jedną z następujących: `StaticResource`, lub `DynamicResource`. Użycie tych jest używana przy odwoływaniu się do danych pierwotnych definiowana jako obiekt w zasobach. Zobacz [zasoby XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *contextResourceKey*  
 Identyfikator klucza dla obiektu żądanego z poziomu <xref:System.Windows.ResourceDictionary>.  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.DataContextProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Poniższy przykład ustawia powiązanie <xref:System.Windows.Documents.Paragraph> elementu, tworząc nowy obiekt danych niestandardowych ustanowienie tego obiektu jako <xref:System.Windows.FrameworkContentElement.DataContext%2A>i ustawienie ścieżka powiązania z właściwością znajdujący się w nim.  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie kontekstu danych tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Opis kontekstów danych i powiązanie danych można znaleźć [Data Binding Overview](~/docs/framework/wpf/data/data-binding-overview.md).  
  
> [!IMPORTANT]
>  Gdy element <xref:System.Windows.FrameworkContentElement.DataContext%2A> potencjalnie dotyczą zmiany, wszystkie właściwości powiązanych z danymi w tym elemencie. Dotyczy to żadnych elementów, które są elementy podrzędne bieżącego elementu, które dziedziczą kontekst danych, oraz bieżącego elementu. Wszystkie takie powiązania ponownego interpretowania nowy <xref:System.Windows.FrameworkContentElement.DataContext%2A> aby odzwierciedlały nową wartość w powiązaniach. Nie ma żadnej gwarancji, informacje dotyczące zamówienia o tych zmianach względem gromadzenia <xref:System.Windows.FrameworkContentElement.DataContextChanged> zdarzeń.  Zmiany mogą wystąpić przed wydarzeniem, po wystąpieniu zdarzenia lub w dowolnej mieszanki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.DataContext" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia klucz do użycia można znaleźć szablonu stylu dla tego formantu w kompozycji.</summary>
        <value>Klucz stylu. Działała prawidłowo, jako część wyszukiwania style motyw, to jest oczekiwaną wartością <see cref="T:System.Type" /> elementu są różne. <see langword="null" /> jest dopuszczalne wartości dla niektórych przypadków.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zazwyczaj nie ustawiono za pomocą dowolnego z jego bezpośrednich metod ustawiających. Zamiast tego możesz zastąpić metadanych specyficznych dla typu tej właściwości zależności, każdorazowo podczas tworzenia nowego podklasę. Po użytkownik podklasy, wywołanie <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> metoda względem <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> identyfikator w konstruktorze statycznym podklasy kontrolki.  
  
 Na przykład klasy wewnętrznej takich jak <xref:System.Windows.Documents.Bold> faktycznie ma bardzo mało implementacji, poza zastępowanie <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> metadanych w jego konstruktorze statycznym i udostępnia kilka konstruktorów wystąpienia. Fakt, że elementy otoczony <xref:System.Windows.Documents.Bold> tag korzyści <xref:System.Windows.Documents.TextElement.FontWeight%2A> właściwość <xref:System.Windows.FontWeights.Bold%2A> jest zaimplementowana w obrębie stylu motywu przywoływany przez ustawienie wartości domyślne <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> do `typeof(Bold)`.  
  
 Jeśli chcesz, elementu lub formantu, aby celowo nie używać stylów motywu, należy ustawić <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> właściwość `true`.  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkContentElement.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywołuje się po zainicjowaniu elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zaimplementuj tę metodę, aby zapewnić obsługę specjalne, które powinny być wykonywane, gdy Twoje element jest inicjowany podczas element proces ładowania.  
  
 Twoja implementacja powinny wywoływać implementację podstawową, ponieważ implementacja base (ustawienie domyślne) ustawia niektóre wewnętrznego flagi do śledzenia inicjowania.  
  
 Jeśli <xref:System.Windows.FrameworkContentElement.BeginInit%2A> był wcześniej nazywany programem, base zgłosi implementacji <xref:System.Windows.FrameworkContentElement.Initialized> zdarzeń. W przeciwnym razie, jeśli <xref:System.Windows.FrameworkContentElement.BeginInit%2A> nie została wywołana lub nie można ustalić, czy <xref:System.Windows.FrameworkContentElement.BeginInit%2A> została wywołana, zdarzenie nie jest inicjowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkContentElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa elementu do wyszukania.</param>
        <summary>Wyszukuje element, który ma nazwę podany identyfikator.</summary>
        <returns>Żądany element. Może być <see langword="null" /> Jeśli nie została odnaleziona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ten element ma elementy podrzędne, te elementy podrzędne są wszystkie cyklicznie wyszukiwanych dla żądanego o nazwie elementu.  
  
   
  
## Examples  
 W poniższym przykładzie ustawiono właściwości w elemencie odnaleziono według nazwy w obrębie odwoływany <xref:System.Windows.Documents.FlowDocument> na stronie.  
  
 [!code-csharp[ContentElementsSmorgasbord#FindName](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findname)]
 [!code-vb[ContentElementsSmorgasbord#FindName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findname)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkContentElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Identyfikator klucza zasobu, który ma zostać odnaleziona.</param>
        <summary>Wyszukuje zasób z określonym kluczem i będzie zgłosić wyjątek, jeśli nie odnaleziono żądanego zasobu.</summary>
        <returns>Znaleziono zasobu lub <see langword="null" /> Jeśli znaleziono nie pasującego zasobu (, ale również zgłosi wyjątek, jeśli <see langword="null" />).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Jeśli chcesz wywołać tę metodę dla klucza, którego nie można odnaleźć jest zgłaszany wyjątek. Jeśli chcesz obsługiwać wyjątki dla tego przypadku, należy zamiast tego wywołać <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>. <xref:System.Windows.FrameworkContentElement.TryFindResource%2A> Zwraca `null` gdy zostanie znaleziony żaden zasób, a nie zgłasza wyjątku.  
  
 Jeśli zasób nie zostanie znaleziony w elemencie wywołującym, drzewa nadrzędnego jest przeszukiwany przy użyciu drzewa logicznego, w taki sam sposób, który będzie drzewa zażądano wyszukiwanych w przypadku zasobów według klucza w czasie wykonywania.  
  
 Zwykle będzie od razu rzutować wartości zwróconej na typ właściwości, które próbowano ustawić za pomocą wartości zwracane zasobów.  
  
   
  
## Examples  
 Poniższy przykład umożliwia znalezienie zasobów zgodnie z definicją w znacznikach i stosuje je do niektórych właściwości elementu w odpowiedzi na zdarzenia trasowanego.  
  
 [!code-csharp[ContentElementsSmorgasbord#FindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findresource)]
 [!code-vb[ContentElementsSmorgasbord#FindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findresource)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">Nie znaleziono klucza żądanego zasobu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceKey" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt, który umożliwia dostosowanie wyglądu, efekty lub innych właściwości stylu, które będą miały zastosowanie do tego elementu po jego przechwyceniu fokus klawiatury.</summary>
        <value>Żądany styl można zastosować fokus. Wartość domyślna, ponieważ nie zadeklarowano właściwości zależności jest pusty statyczne <see cref="T:System.Windows.Style" />. Jednakże, efektywną wartość w czasie wykonywania jest często (ale nie zawsze) styl dostarczony przez dział pomocy technicznej motywie dla kontrolki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas ustawiania tej właściwości w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]style prawie zawsze są definiowane jako zasobu, zamiast wbudowanego jako element i zasobów jest zwykle określany jako <xref:System.Windows.StaticResourceExtension>.  
  
 Pamiętaj, że ta właściwość ma wpływ na wygląd, ale nie raportuje czynności w metadanych. Jest to spowodowane zmianami wygląd jest oparte na zdarzeniach i nie mogą mieć zastosowanie przez cały czas i związku z tym należy zwykle będą zgłaszać żadnych informacji wizualizacji i układów w metadanych.  
  
 Model visual zachowanie fokus do formantu powinna być spójnego element po elemencie. Najbardziej rozsądne sposób, aby wymusić spójność jest tylko zmienić styl wizualny fokusu, jeśli redagowania całego motywu. Ustawienie tej właściwości na określone style, a nie jako część motywu nie jest zamierzone użycie tej właściwości, ponieważ może dojść do mylące czynności użytkownika dotyczących fokus klawiatury. Sygnalizuje pomyślny przebieg operacji zachowanie specyficzne dla elementów, które celowo nie jest spójny we motyw, możesz znacznie lepszym rozwiązaniem jest Użyj wyzwalaczy w stylach właściwości poszczególnych stanu danych wejściowych, takich jak <xref:System.Windows.UIElement.IsFocused%2A> lub <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>i aby to zrobić w sposób, który nie zawiera wizualnie kolidować z wszelkie istniejące styl wizualny fokusu. Aby uzyskać więcej informacji na temat projektowania zamiar <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> i alternatywne skupić się właściwości, zobacz [style dla fokusu w formantach i FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *resourceExtension*  
 Jedną z następujących:, lub. Zobacz [zasoby XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Klucz, który identyfikuje styl żądanej. Klucz, który odwołuje się do istniejącego zasobu w <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Składnia elementu właściwości jest technicznie możliwe, ale niezalecane. Zobacz [style i Szablony wbudowane](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).  Odwołanie do wiązania za pomocą lub <xref:System.Windows.Data.Binding> jest również możliwe, ale rzadko.  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą czy to <see cref="T:System.Windows.FrameworkContentElement" /> ma wymusić [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] do renderowania kursora w postaci zadeklarowanej przez to wystąpienie <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> właściwości.</summary>
        <value><see langword="true" /> Aby wymusić prezentacji kursor nad elementem do użycia z tym wystąpieniem przez ustawienie dla kursora (w tym na wszystkie elementy podrzędne); w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie tej właściwości na `true` spowoduje przesłonięcie preferencje kursora ustanowione przez elementy podrzędne. Spowoduje to więc ogólnie rzecz biorąc aplikacji [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] może być mylące dla użytkowników, szczególnie w przypadku, gdy próbujesz określić kursory elementów podrzędnych. Ustawienie <xref:System.Windows.FrameworkElement.ForceCursor%2A> jest bardziej odpowiednie w scenariuszach podklasy lub składania kontroli.  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład powoduje kursor znajduje się nad elementem.  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Element docelowy <see cref="T:System.Windows.DependencyProperty" /> z którego można pobrać powiązania.</param>
        <summary>Pobiera <see cref="T:System.Windows.Data.BindingExpression" /> dla określonej właściwości powiązania.</summary>
        <returns>Zwraca <see cref="T:System.Windows.Data.BindingExpression" /> Jeśli obiektem docelowym są danymi powiązanymi; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pobiera powiązania, badając właściwości.  
  
 [!code-csharp[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#getbindingexpression)]
 [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#getbindingexpression)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca alternatywny nadrzędny logicznych dla tego elementu, jeśli nie określono visual elementu nadrzędnego. W tym przypadku <see cref="T:System.Windows.FrameworkContentElement" /> nadrzędnego jest zawsze taka sama wartość jak <see cref="P:System.Windows.FrameworkContentElement.Parent" /> właściwości.</summary>
        <returns>Zwraca coś innego niż <see langword="null" /> zawsze, gdy WPF poziomie struktury implementacja tej metody ma połączenie nadrzędne innym niż wizualny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca pojedynczy oczekiwanego visual element nadrzędny. Niestandardowe implementacje może zwrócić alternatywny nadrzędny relacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy to <see cref="T:System.Windows.FrameworkContentElement" /> został zainicjowany. Pokrywa się to z przypadkami, w którym wartość <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> właściwość zmienia się z <see langword="false" /> (lub undefined) na <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest wywoływane zawsze, gdy <xref:System.Windows.FrameworkContentElement.EndInit%2A> lub <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> metody są wywoływane. Wywołania tych metod można zostały wprowadzone przez kod zamierzonego lub przez [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] proces ładowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkContentElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kontekst dla danych wejściowych używanych przez to <see cref="T:System.Windows.FrameworkContentElement" />.</summary>
        <value>Zakresu wejściowego, który modyfikuje interpretacji danych wejściowych z alternatywnych metod danych wejściowych. Wartość domyślna to <see langword="null" /> (które powoduje domyślna obsługa poleceń).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zależności dziedziczy wartości właściwości. Jeśli są elementami podrzędnymi bez innych wartości dla <xref:System.Windows.FrameworkElement.InputScope%2A> nawiązane, przy użyciu wartości lokalnych lub style, system właściwość ustawi wartość <xref:System.Windows.FrameworkElement.InputScope%2A> tę wartość przypisaną wartością najbliższym elemencie nadrzędnym.  
  
 Mimo że [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] użycie składni znajduje się na liście i składniowo jest dozwolony, ustawienie tej właściwości [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] nie jest powszechne.  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.InputScopeProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.InputScope" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten element został zainicjowany, albo przez ładowany jako [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], albo przez jawne zdefiniowanie jego <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> metodę o nazwie.</summary>
        <value><see langword="true" /> Jeśli element jest inicjowany za wyżej wywołań ładowania lub metoda; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość może być również `true` Jeśli ten element został przeniesiony w obrębie drzewa elementu taki sposób, że ma nowy element nadrzędny i w związku z tym staje się ponownie ponownie załadowany.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten element został załadowany do prezentacji.</summary>
        <value><see langword="true" /> Jeśli bieżący element jest dołączony do drzewa elementów i zostało wyrenderowane; <see langword="false" /> Jeśli element nigdy nie został dołączony do drzewa załadowanych elementów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Z wystąpienia nowo skonstruowany, ta właściwość rozpoczyna się `false`, a pozostaje `true` po jest równa `true`, nawet jeśli później usunięte przez kod.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> jako warunkowego wyboru, aby mieć pewność, że funkcja `displayData` (niewyświetlany) będą prawidłowe elementy załadowano na stronie, aby pracować w ramach programu obsługi na żądanie. Czy ta sama logika jest uruchamiany jako program obsługi zdarzeń dla <xref:System.Windows.FrameworkContentElement.Loaded>.  
  
 [!code-csharp[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#isloaded)]
 [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#isloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkContentElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkContentElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje o języku lokalizacji/globalizacji, który ma zastosowanie do danego elementu.</summary>
        <value>Informacji o kulturze dla tego elementu. Wartość domyślna to <see cref="T:System.Windows.Markup.XmlLanguage" /> wystąpienia z jego <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> wartość na ciąg "en US".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Formaty ciągu zgodne ze standardem RFC 3066. Na przykład w Stanach Zjednoczonych Język angielski jest "en US". Zobacz <xref:System.Windows.Markup.XmlLanguage> Aby uzyskać więcej informacji na temat wartości i formatu.  
  
 Ta właściwość zależności dziedziczy wartości właściwości. Jeśli są elementami podrzędnymi bez innych wartości dla <xref:System.Windows.FrameworkElement.Language%2A> nawiązane, przy użyciu wartości lokalnych lub style, system właściwość ustawi wartość <xref:System.Windows.FrameworkElement.Language%2A> tę wartość przypisaną wartością najbliższym elemencie nadrzędnym.  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.LanguageProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.Language" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy element jest poukładany, wyrenderowany i gotowy do interakcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia trasowane bezpośrednie nie wykonuj trasy, są obsługiwane tylko w obrębie tego samego elementu, na którym są wywoływane. Bezpośrednie zdarzenia trasowane obsługują innych zachowań zdarzenia trasowanego: zbieranie dostępne programy obsługi pomocy technicznej i mogą być używane jako <xref:System.Windows.EventTrigger> w stylu.  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.LoadedEvent>|  
|Strategii routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [kierowane Przegląd zdarzeń](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekty identyfikator zdarzenia są tworzone podczas zarejestrowanych zdarzeń trasowanych (zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) i następnie można dodać funkcje obsługi klas (zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Identyfikator obiekty zawierają nazwę identyfikującą typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduł wyliczający dla podrzędnych logicznego elementu.</summary>
        <value>Moduł wyliczający dla elementów podrzędnych logicznego tego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat sposobu użycia <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> i <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, zobacz [drzewa w WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkContentElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">Kierunku, w którym fokus ma zostać przesunięta, jako wartość wyliczenia.</param>
        <summary>Przenosi fokus klawiatury z tego elementu do innego elementu.</summary>
        <returns>Zwraca <see langword="true" /> Jeśli fokus zostanie przeniesiony pomyślnie; <see langword="false" /> Jeśli elementem docelowym, w kierunku co określona, nie istnieje.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkContentElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę identyfikującą elementu. Nazwa zawiera odwołania do wystąpienia tak, aby programowe związane z kodem, takie jak kod procedury obsługi zdarzeń, mogą odwoływać się do elementu, gdy jest tworzony podczas analizowania [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</summary>
        <value>Nazwa elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najbardziej typowe użycia tej właściwości jest podczas określania [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] nazwa elementu w znacznikach.  
  
 Ta właściwość zapewnia zasadniczo można ustawić właściwości wygody poziomie struktury WPF [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [x: Name — dyrektywa](~/docs/framework/xaml-services/x-name-directive.md).  
  
 Wprowadzenie <xref:System.Windows.FrameworkContentElement.Name%2A> z kodu nie jest powszechne, ponieważ jeśli już masz odpowiednie odwołania w kodzie, można wywoływać tylko metody i właściwości w elemencie odwołać się i nie jest zazwyczaj potrzeba <xref:System.Windows.FrameworkContentElement.Name%2A>. Wyjątkiem jest, czy ciąg ma pewne przeciążona to znaczy, na przykład jeśli jest przydatne wyświetlić tą nazwą w [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]. Ustawienie <xref:System.Windows.FrameworkContentElement.Name%2A> z kodu Jeśli oryginalny <xref:System.Windows.FrameworkContentElement.Name%2A> był zestaw z kodu znaczników nie zaleca się i zmiana właściwości nie zmieni się odwołanie do obiektu. Odwołania do takich obiektów są tworzone tylko wtedy, gdy podstawowy zakresy nazw są jawnie tworzone podczas [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] ładowania.  
  
 W szczególności należy wywołać <xref:System.Windows.FrameworkContentElement.RegisterName%2A> aby zmiana na <xref:System.Windows.FrameworkContentElement.Name%2A> właściwość elementu już załadowana.  
  
 Warto jeden przypadek, w przypadku, gdy ustawienie <xref:System.Windows.FrameworkContentElement.Name%2A> z kodu jest ważne jest dla nazw elementów, które scenorysy będą uruchamiane. Przed zarejestrowaniem nazwę, może wystąpić konieczność tworzenia instancji i przypisać <xref:System.Windows.NameScope> wystąpienia. Sekcja przykład lub [Przegląd Scenorysy](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
 Ustawienie <xref:System.Windows.FrameworkContentElement.Name%2A> z kodu ma ograniczoną aplikacji, ale Trwa wyszukiwanie elementu o nazwie jest częściej używana, szczególnie w przypadku, gdy są wykorzystujących model nawigacji, gdzie stron Załaduj ponownie do aplikacji i kodu w czasie wykonywania niekoniecznie jest kodem, który odpowiednie strony. Metoda narzędzie <xref:System.Windows.FrameworkContentElement.FindName%2A>, który jest dostępny z dowolnego <xref:System.Windows.FrameworkContentElement>, można znaleźć dowolnego elementu przez <xref:System.Windows.FrameworkContentElement.Name%2A> w rekursywnie drzewo logiczne tego elementu. Możesz też <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> metoda statyczna <xref:System.Windows.LogicalTreeHelper>, która również korzysta <xref:System.Windows.FrameworkContentElement.Name%2A> ciągu jako argument.  
  
 Najczęściej używane elementy główne (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> na przykład) implementować interfejs <xref:System.Windows.Markup.INameScope>. Implementacje tego interfejsu powinny wymuszanie nazwy się jednoznaczna w obrębie swojego zakresu.  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.NameProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.Name" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Udostępnia dane o zdarzeniu.</param>
        <summary>Wywoływane, gdy <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> zdarzenia trasowanego osiągnie tej klasy w jego trasę. Zaimplementuj tę metodę, aby dodać obsługę klasy dla tego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma domyślnej implementacji. Nadal powinny wywoływać implementację podstawową, w przypadku, gdy klasa pośrednicząca w dziedziczeniu zaimplementowała tej metody.  
  
 Celem tej metody jest nieco podobne do [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] wzorzec zdarzeń na * metody: zapewnia mechanizmy do obsługi zdarzeń zgodnych z klas pochodnych z obsługi klasy, zamiast do obsługi wystąpienia. W tym przypadku pasującego zdarzenia to zdarzenia trasowanego. Wzorzec implementacji metody On * są różne dla zdarzenia trasowane, ponieważ zdarzenie trasowane został zgłoszony przez element podrzędny nie musi to być element, który będzie wywoływać procedury obsługi. W związku z tym Twoja implementacja musi uwzględniać zdarzenia właściwości źródła argumentów (i nie należy próbować ponownie zgłosić zdarzenie, które w większości przypadków). Podklasy <xref:System.Windows.FrameworkContentElement> może wybrać do wywołania metody obsługi Klasa prywatna, po odebraniu zdarzenia wzdłuż trasy. Jeden scenariusz potencjalnych jest przyjmują argumentów zdarzenia i celowo oznaczyć zdarzenia jako obsłużony, skrócenie czasu trasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzeń dla zdarzenia.</param>
        <summary>Wywoływane, gdy <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> zdarzenia trasowanego osiągnie tej klasy w jego trasę. Zaimplementuj tę metodę, aby dodać obsługę klasy dla tego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma domyślnej implementacji. Nadal należy wywołać base(), w przypadku, gdy klasa pośrednicząca w dziedziczeniu zaimplementowała tej metody.  
  
 Celem tej metody jest nieco podobne do [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] wzorzec zdarzeń na * metody: zapewnia mechanizmy do obsługi zdarzeń zgodnych z klas pochodnych z obsługi klasy, zamiast do obsługi wystąpienia. W tym przypadku pasującego zdarzenia to zdarzenia trasowanego. Wzorzec implementacji metody On * różni się dla zdarzenia trasowane ponieważ zdarzenia trasowanego został zgłoszony przez element podrzędny nie musi to być element, który będzie wywoływać procedury obsługi, więc Twoja implementacja będzie musiał weź źródło argumenty zdarzenia właściwości pod uwagę (i nie należy próbować ponownie zgłosić zdarzenie, które w większości przypadków). Podklasy <xref:System.Windows.FrameworkContentElement> może wybrać do wywołania metody obsługi Klasa prywatna, po odebraniu zdarzenia wzdłuż trasy. Jeden scenariusz potencjalnych jest przyjmują argumentów zdarzenia i celowo oznaczyć zdarzenia jako obsłużony, skrócenie czasu trasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkContentElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzeń dla zdarzenia.</param>
        <summary>Obsługa klasy <see cref="E:System.Windows.ContentElement.GotFocus" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten program obsługi klasy Ustawia fokus odpowiednie zachowanie w tym elemencie, jeśli pochodzi z tego elementu. Jeśli źródło zdarzenia innego elementu w drzewie, program obsługi nie działa.  
  
 Zastępuje tę metodę, aby zmienić te domyślne, skupiając się zachowanie w elemencie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkContentElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzeń dla zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.FrameworkContentElement.Initialized" /> zdarzeń. Ta metoda jest wywoływana zawsze wtedy, gdy <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> ustawiono <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody wirtualnej zgłasza zdarzenie, zgodnie z opisem we wcześniejszej części tego tematu. Zastąpienia należy wywołać base(), aby zachować to zachowanie.  
  
 Należy pamiętać, że <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> właściwość jest tylko do odczytu. W związku z tym nie można ustawić, aby wymusić zachowanie inicjowania w ten sposób. Ustawienia ma odbywać się tylko przez [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkContentElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzenia, który opisuje właściwość, która będzie zmieniona, w tym starej i nowej wartości.</param>
        <summary>Wywoływane, gdy wartość dowolnej właściwości zależności, w tym <see cref="T:System.Windows.FrameworkContentElement" /> został zaktualizowany. Zmieniona właściwość konkretnej zależności jest zgłaszany w parametrze argumentów. Zastępuje <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest przeznaczona do zwykle wykrywać zmiany właściwości lub invalidations. Zamiast tego ma na celu modyfikacji wzorca ogólnego unieważniania Jeśli znane jest niektórych informacji o klasyfikacjach szerokiego właściwości.  
  
 Ta metoda jest potencjalnie wywoływana wiele razy w okresie istnienia obiektu. W związku z tym, można osiągnąć lepszą wydajność, jeśli zastąpić metadane z określonych właściwości, a następnie dołącz <xref:System.Windows.CoerceValueCallback> lub <xref:System.Windows.PropertyChangedCallback> funkcje dla poszczególnych właściwości. Jednak jeśli może użyć tej metody <xref:System.Windows.FrameworkContentElement> obejmuje szereg istotnych właściwości zależności powiązanych wartości, lub jeśli zawiera logikę, takie jak zachowanie renderowania, który musi zostać uruchomiony ponownie dla kilku powiązanych przypadków invalidations właściwości.  
  
 Należy pamiętać, że o identycznej nazwie `OnPropertyChanged` metody z innym podpisem (typ parametru jest <xref:System.ComponentModel.PropertyChangedEventArgs>), mogą być wyświetlane na liczby klas. Czy `OnPropertyChanged` jest używany dla danych obiektu powiadomień i jest częścią kontraktu dla <xref:System.ComponentModel.INotifyPropertyChanged>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Zawsze należy wywołać implementację podstawową jako pierwszą operacją w danej implementacji. Niewykonanie tej czynności to znacznie spowoduje wyłączenie całego [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] właściwości systemu, co powoduje, że nieprawidłowe wartości należy podać.</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkContentElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">Stary styl.</param>
        <param name="newStyle">Nowy styl.</param>
        <summary>Wywoływane, gdy styl jest używany w tym zmiany elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma domyślną implementację, która ustawia flagi wewnętrznej, biorąc pod uwagę warunek styl zmienione.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Zawsze wywoływać implementację podstawową, w przeciwnym razie nie można stosować style. Scenariusze dotyczące przesłaniania tej metody może obejmować, jeśli Klasa pochodna ma selektora wyspecjalizowane style lub przechowuje wartości stylu. Zmiany motywu potencjalnie spowoduje wywołanie tej metody.</para></block>
        <altmember cref="P:System.Windows.FrameworkContentElement.Style" />
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Udostępnia dane o zdarzeniu.</param>
        <summary>Wywoływane, gdy <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> zdarzenia trasowanego osiągnie tej klasy w jego trasę. Zaimplementuj tę metodę, aby dodać obsługę klasy dla tego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma domyślnej implementacji. Nadal należy wywołać base(), w przypadku, gdy klasa pośrednicząca w dziedziczeniu zaimplementowała tej metody.  
  
 Celem tej metody jest nieco podobne do [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] wzorzec zdarzeń na * metody: zapewnia mechanizmy do obsługi zdarzeń zgodnych z klas pochodnych z obsługi klasy, zamiast do obsługi wystąpienia. W tym przypadku pasującego zdarzenia to zdarzenia trasowanego. Wzorzec implementacji metody On * różni się dla zdarzenia trasowane ponieważ zdarzenia trasowanego został zgłoszony przez element podrzędny nie musi to być element, który będzie wywoływać procedury obsługi, więc Twoja implementacja będzie musiał weź źródło argumenty zdarzenia właściwości pod uwagę (i nie należy próbować ponownie zgłosić zdarzenie, które w większości przypadków). Podklasy <xref:System.Windows.FrameworkContentElement> może wybrać do wywołania metody obsługi Klasa prywatna, po odebraniu zdarzenia wzdłuż trasy. Jeden scenariusz potencjalnych jest przyjmują argumentów zdarzenia i celowo oznaczyć zdarzenia jako obsłużony, skrócenie czasu trasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Udostępnia dane o zdarzeniu.</param>
        <summary>Wywoływane, gdy <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> zdarzenia trasowanego osiągnie tej klasy w jego trasę. Zaimplementuj tę metodę, aby dodać obsługę klasy dla tego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma domyślnej implementacji. Nadal należy wywołać base(), w przypadku, gdy klasa pośrednicząca w dziedziczeniu zaimplementowała tej metody.  
  
 Celem tej metody jest nieco podobne do [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] wzorzec zdarzeń na * metody: zapewnia mechanizmy do obsługi zdarzeń zgodnych z klas pochodnych z obsługi klasy, zamiast do obsługi wystąpienia. W tym przypadku pasującego zdarzenia to zdarzenia trasowanego. Wzorzec implementacji metody On * różni się dla zdarzenia trasowane ponieważ zdarzenia trasowanego został zgłoszony przez element podrzędny nie musi to być element, który będzie wywoływać procedury obsługi, więc implementacji należy weź źródło argumenty zdarzenia właściwości pod uwagę (i nie należy próbować ponownie zgłosić zdarzenie, które w większości przypadków). Podklasy <xref:System.Windows.FrameworkContentElement> może wybrać do wywołania metody obsługi Klasa prywatna, po odebraniu zdarzenia wzdłuż trasy. Jeden scenariusz potencjalnych jest przyjmują argumentów zdarzenia i celowo oznaczyć zdarzenia jako obsłużony, skrócenie czasu trasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy ten element uwzględnia właściwości stylu ze stylów motywu.</summary>
        <value><see langword="true" /> Jeśli ten element nie zawiera funkcji ponownego obliczenia właściwości stylu motywu; wszystkie właściwości stylu pochodzące pochodzą style aplikacji lokalnej i ponownego obliczenia właściwości stylu motywu nie mają zastosowania. <see langword="false" /> Jeśli najpierw zastosuj style aplikacji, a następnie Zastosuj style motywów dla właściwości, które nie zostały wyraźnie ustawione w stylach aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najbardziej typowe użycia tej właściwości jest pośrednich użycie w ramach metody ustawiającej stylu, który udostępnia styl z motywem.  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera element nadrzędny w drzewie logicznym dla tego elementu.</summary>
        <value>Logiczne element nadrzędny tego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że logiczne nadrzędnego elementu nie może zmienić w zależności od funkcjonalność swojej aplikacji i utrzymania wartość tej właściwości nie zreflektuje tej zmiany. Można zwykle uzyskać wartość natychmiast, zanim zajdzie potrzeba jej.  
  
 Zobacz [drzewa w WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) Aby uzyskać więcej informacji dotyczących nakierowanych drzewa logicznego i scenariusze, których wykonanie tego podejścia do odnajdywania element jest właściwe.  
  
 System właściwości potencjalnie ponownych wartości wszystkich właściwości elementu po jego pokrewnym, ponieważ niektóre właściwości dziedziczą wartości za pomocą drzewo logiczne. <xref:System.Windows.FrameworkContentElement.DataContext%2A> Która odnosi się do powiązania można również zmienić, gdy elementy są pokrewnym.  
  
 Zmiana elementu nadrzędnego zwykle tylko odbywa się za pośrednictwem manipulowanie kolekcjami, za pomocą dedykowanego metod dodawania i usuwania, lub przez ustawienie właściwości zawartości elementów.  
  
 Najbardziej typowym scenariuszem przy użyciu <xref:System.Windows.FrameworkContentElement.Parent%2A> właściwość jest do uzyskania odwołania, a następnie różnych <xref:System.Windows.FrameworkContentElement> wartości właściwości z obiektu nadrzędnego. Dla szablonów <xref:System.Windows.FrameworkContentElement.Parent%2A> szablonu ostatecznie będzie `null`. Aby usunąć ten punkt i rozszerzanie na drzewo logiczne, w którym szablon jest rzeczywiście stosowane, użyj <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.  
  
   
  
## Examples  
 Poniższy przykład sprawdza, czy <xref:System.Windows.FrameworkContentElement.Parent%2A> z <xref:System.Windows.Documents.TextPointer> jest określonego typu.  
  
 [!code-csharp[TextPointer_snippets#FCEParent](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#fceparent)]
 [!code-vb[TextPointer_snippets#FCEParent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#fceparent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Kierunek, dla której powinna zostać określona zmiana potencjalnych fokus.</param>
        <summary>Określa następnego elementu, który otrzyma fokus względem tego elementu dla kierunku przepływu podana fokus, ale faktycznie nie Przenieś fokus. Ta metoda jest zapieczętowany i nie może być zastąpiona.</summary>
        <returns>Następny element, który skupić się spowoduje przeniesienie do fokus rzeczywiście zostały przesunięta. Może zwracać <see langword="null" /> Jeśli fokus nie można przenieść względem tego elementu, dla podanego kierunku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement.MoveFocus%2A> jest powiązane metody, która faktycznie Przenieś fokus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Określić jedną z następujących wskazówek w <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />. Te wskazówki są niedozwolone dla <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (ale prawne dla <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkContentElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa do użycia dla określonego mapowania nazwy obiektu.</param>
        <param name="scopedElement">Obiekt do mapowania.</param>
        <summary>Udostępnia metodę dostępu, która upraszcza dostęp do <see cref="T:System.Windows.NameScope" /> metodę rejestracji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest to wygodna metoda do wywołania <xref:System.Windows.NameScope.RegisterName%2A>. Implementacja sprawdzi elementy nadrzędne kolejnych, aż znajdzie odpowiednią <xref:System.Windows.NameScope> wdrażania, który zostanie znaleziony, wyszukując element, który implementuje <xref:System.Windows.Markup.INameScope>. Aby uzyskać więcej informacji na temat zakresy nazw, zobacz [zakresy WPF XAML nazw](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 Wywoływanie <xref:System.Windows.FrameworkContentElement.RegisterName%2A> jest niezbędne, aby można było poprawnie obsługiwać animacji scenorys dla aplikacji utworzonych w kodzie. Jest to spowodowane scenorysu jednego z kluczowych właściwości <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, używa nazw czasu wykonywania wyszukiwania zamiast będzie mogła wykonać odwołanie do elementu docelowego. Ta zasada obowiązuje, nawet jeśli ten element jest dostępny za pomocą odwołania z kodu. Aby uzyskać więcej informacji na temat Dlaczego trzeba zarejestrować nazwy dla celów scenorysu, zobacz [Przegląd Scenorysy](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md). Animacje dla elementów zawartości są rzadziej niż animacji, formantów, [Przegląd Scenorysy](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md) koncentruje się na scenariuszach kontroli.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Element do usunięcia.</param>
        <summary>Usuwa określony element z drzewa logicznego dla tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] dotyczy głównie dziedziczenia klasy scenariuszy, dodając obsługę kolekcje elementów podrzędnych.  
  
 Większość <xref:System.Windows.FrameworkContentElement> klasy pochodne ujawnić dedykowany kolekcji, które są odpowiedzialne za zawierania (na przykład <xref:System.Windows.Documents.Span.Inlines%2A> na <xref:System.Windows.Documents.Span> klasy; <xref:System.Windows.Documents.Section.Blocks%2A> na <xref:System.Windows.Documents.Section> klasy). Wyprowadzanie z tych klas, zazwyczaj można uniknąć konieczności bezpośrednio modyfikować drzewo logiczne.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkContentElement.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżący słownik zasobów lokalnie zdefiniowane.</summary>
        <value>Bieżące zasoby zdefiniowane lokalnie. Jest to słownika zasobów, w którym dostęp do zasobów w słowniku według klucza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Słowniki zasobów, które mogą być definiowane częściowo lub całkowicie w [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] są zazwyczaj tworzone jako prvek Vlastnosti i zwykle znajdują się na element główny dla dowolnej pojedynczej strony lub aplikacji. Wprowadzenie do słownika zasobów na tym poziomie sprawia, że łatwiej odnaleźć z elementów podrzędnych poszczególne strony (lub na dowolnej stronie w przypadku aplikacji). W większości scenariuszy aplikacji, zaleca się, że style można zdefiniować jako obiekt elementów w słowniku zasobów, lub można zdefiniować jako zasobów zewnętrznych, tak aby zasobu stylu całej może być samodzielne (takie podejście pomaga oddzielne projektanta obowiązki z odpowiedzialności dla deweloperów, oddzielając pliki fizyczne, które powinny być edytowane).  
  
 Należy pamiętać, że właściwość ta zwraca tylko słownik zasobów zadeklarowany bezpośrednio w ramach tego elementu. Stanowi to odmianę proces wyszukiwania zasobów rzeczywistych, w którym nie zawiera elementu podrzędnego ma dostęp do zasobów zdefiniowane w każdym elemencie nadrzędnym, wyszukiwanie cyklicznie w górę.  
  
 Zasobów także mogą być przywoływane przez kod z kolekcji, ale należy pamiętać, że zasoby są tworzone w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] zdecydowanie nie będą dostępne do czasu po <xref:System.Windows.FrameworkContentElement.Loaded> jest wywoływane przez element, który deklaruje słownika. W rzeczywistości są parsowane asynchronicznie zasobów i nie jest jeszcze <xref:System.Windows.FrameworkContentElement.Loaded> zdarzeń jest zapewnienie, że możesz odwoływać się do [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] zdefiniowany zasób. Z tego powodu należy zwykle tylko dostęp [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] określonych zasobów w ramach kodu w czasie wykonywania, lub za pośrednictwem innych [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] technik, takich jak style lub odwołania do rozszerzenia zasobu dla wartości atrybutów. Gdy uzyskujesz dostęp do zasobów za pomocą kodu jest zasadniczo odpowiednikiem odniesienia z [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 Podstawowe <xref:System.Windows.ResourceDictionary> obsługuje metody wymagane do dodawania, usuwania lub zbadać zasobów w kolekcji za pomocą kodu. <xref:System.Windows.FrameworkContentElement.Resources%2A> Właściwość jest do ustawienia scenariusza całkowicie zamiany kolekcji zasobów w nowej lub innego elementu <xref:System.Windows.ResourceDictionary>.  
  
 Należy zauważyć, że [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] składni przedstawionej nie zawiera element dla <xref:System.Windows.ResourceDictionary>. Jest to przykład składni niejawnej kolekcji; Znacznik reprezentujący element w kolekcji można pominąć. Elementy, które są dodawane jako elementy do kolekcji są określane w zamian. Aby uzyskać więcej informacji o kolekcjach niejawne i [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], zobacz [składnia XAML w szczegółów](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md). Jeden przypadek gdzie <xref:System.Windows.ResourceDictionary> nadal jawnie określono, ponieważ są wprowadzające scalonych słowników, w którym to przypadku czy zwykle Brak elementów podrzędnych do tego elementu <xref:System.Windows.ResourceDictionary>. Aby uzyskać więcej informacji, zobacz [scalone słowniki zasobów](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *oneOrMoreResourceElements*  
 Jeden lub więcej elementów obiektu, z których każdy definiuje zasób. Każdy element właściwości zasobów w ramach każdej <xref:System.Windows.ResourceDictionary> musi mieć unikatową wartość dla [x: Key — dyrektywa](~/docs/framework/xaml-services/x-key-directive.md), który służy jako unikatowego klucza, gdy są one pobierane <xref:System.Windows.ResourceDictionary>.  
  
   
  
## Examples  
 Poniższy przykład ustanawia <xref:System.Windows.FrameworkContentElement.Resources%2A> kolekcji na <xref:System.Windows.Documents.FlowDocument> elementu głównego. <xref:System.Windows.Documents.FlowDocument> jest typowym wyborem, ponieważ jest to jeden z kilku <xref:System.Windows.FrameworkContentElement> klas, które mają sens jako element główny i zasoby są zazwyczaj przechowywane w katalogu głównym strony lub na poziomie nawet wyższy przykład w aplikacji.  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza powiązania do tego elementu, dla właściwości określonej zależności.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">Umożliwia określenie właściwości powiązanej.</param>
        <param name="path">Nazwa właściwości źródłowego lub ścieżka do właściwości użytej dla wiązania.</param>
        <summary>Dołącza powiązania do tego elementu, w oparciu o nazwę właściwości podane źródło jako kwalifikacją ścieżka do źródła danych.</summary>
        <returns>Rejestruje warunki powiązania. Zwrócona wartość może być przydatne w przypadku sprawdzania błędów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest to wygodna metoda do wywoływania <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, która przekazuje bieżącego wystąpienia jako <xref:System.Windows.DependencyObject>i tworzy nowy <xref:System.Windows.Data.Binding> na podstawie udostępnionych `path` parametru. Podpis ten jest bardziej wygodne podczas ustanawiania powiązania prostym, domyślnym. Jeśli jest konieczne określanie żadnych właściwości powiązania do wartości niedomyślnej warunków lub chcesz użyć <xref:System.Windows.Data.MultiBinding> lub <xref:System.Windows.Data.PriorityBinding>, należy użyć <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> podpisu.  
  
   
  
## Examples  
 Poniższy przykład ustawia powiązanie <xref:System.Windows.Documents.Paragraph> elementu, tworząc nowy obiekt danych niestandardowych ustanowienie tego obiektu jako <xref:System.Windows.FrameworkContentElement.DataContext%2A>i ustawienie ścieżka powiązania z właściwością znajdujący się w nim.  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkContentElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">Umożliwia określenie właściwości powiązanej.</param>
        <param name="binding">Reprezentuje powiązanie danych.</param>
        <summary>Dołącza powiązania do tego elementu, na podstawie obiektu podane powiązanie.</summary>
        <returns>Rejestruje warunki powiązania. Zwrócona wartość może być przydatne w przypadku sprawdzania błędów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest to wygodna metoda do wywoływania <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, która przekazuje bieżącego wystąpienia jako <xref:System.Windows.DependencyObject>.  
  
   
  
## Examples  
 Poniższy przykład ustawia powiązanie <xref:System.Windows.Documents.Paragraph> elementu, tworząc nowe <xref:System.Windows.Data.Binding> i Ustawianie źródła do nowo utworzonych `DateTime` obiektu.  
  
 [!code-csharp[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#setbinding)]
 [!code-vb[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#setbinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkContentElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Właściwość, do której zasób jest powiązany.</param>
        <param name="name">Nazwa zasobu.</param>
        <summary>Wyszukuje zasób o określonej nazwie i konfiguruje zasobu odwołanie do niej dla określonej właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Odwołanie do zasobu jest podobny do stosowania [dynamicresource — rozszerzenie znaczników](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) w znacznikach. Odwołanie do zasobu tworzy wyrażenie wewnętrzne, które dostarcza wartość określonej właściwości na podstawie odroczonego czasu wykonywania. Będzie można ponownie obliczyć wyrażenia zawsze wtedy, gdy słownik zasobów zmienione wskazuje wartość informującą za pośrednictwem wewnętrznego zdarzenia lub zawsze wtedy, gdy bieżącym elementem pokrewnym (zmiany elementu nadrzędnego zmienić ścieżki wyszukiwania słownik).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca, czy procesy serializacji należy serializować zawartość <see cref="P:System.Windows.FrameworkContentElement.Resources" /> właściwości wystąpienia tej klasy.</summary>
        <returns><see langword="true" /> Jeśli <see cref="P:System.Windows.FrameworkContentElement.Resources" /> wartość właściwości powinna być Zserializowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spowoduje to zwrócenie `true` tak długo, jak istnieje co najmniej jeden zasób z kluczem w lokalnej <xref:System.Windows.FrameworkContentElement.Resources%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca, czy procesy serializacji należy serializować zawartość <see cref="P:System.Windows.FrameworkContentElement.Style" /> właściwości wystąpienia tej klasy.</summary>
        <returns><see langword="true" /> Jeśli <see cref="P:System.Windows.FrameworkContentElement.Style" /> wartość właściwości powinna być Zserializowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spowoduje to zwrócenie `true` Jeśli <xref:System.Windows.Style> lokalnie jest ustawiona.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie dowolnego skojarzonego źródła danych uczestniczącego w powiązaniu w elemencie zmiany tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powierzchnie tego zdarzenia <xref:System.Windows.Data.Binding.SourceUpdated> zdarzenia, które jest wywoływane przez żaden <xref:System.Windows.Data.Binding> skojarzone z tym elementem.  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object SourceUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia styl, który będzie używany przez ten element.</summary>
        <value>Zastosowane, styl niestandardowy element, jeśli jest obecny. W przeciwnym razie <see langword="null" />. Wartość domyślna dla zbudowanego domyślnie <see cref="T:System.Windows.FrameworkContentElement" /> jest <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący styl często jest zapewniana przez domyślny styl z motywy lub style ogólne zastosowanie do obiektów tego typu przez zasoby na poziomie strony lub aplikacji (styl niejawny). Ta właściwość jest domyślny nie zostały ustawione lub zwrotu style (motyw), ale przywraca niejawne stylu lub jawnego. W przypadku jawnego lub niejawnego stylów nie ma znaczenia, czy styl nie jest dostępny jako zasób lub zdefiniowane lokalnie.  
  
 Ustawianie stylów mają pewne ograniczenia. Możesz zresetować całą <xref:System.Windows.FrameworkContentElement.Style%2A> nową właściwość <xref:System.Windows.Style> w dowolnym momencie, która wymusi recomposition układu. Jednak niezwłocznie po stylu jest umieszczany w użyciu przez element załadować <xref:System.Windows.Style> powinny być traktowane jako zapieczętowany. Podjęto próbę dokonania zmiany do żadnej poszczególne właściwości stylu w użyciu (takie jak niczego w obrębie kolekcji <xref:System.Windows.Style.Setters%2A>) powoduje zgłoszenie wyjątku. Styl, który jest zdefiniowany w znacznikach uznaje się będzie używana zaraz po jego załadowaniu ze słownika zasobów (dla zasobów) lub strony, w której znajduje się w obrębie ładowania (style wbudowane).  
  
 <xref:System.Windows.FrameworkContentElement.Style%2A> jest to właściwość zależności o priorytecie specjalne. Lokalnie ustawiony styl ogólnie operuje na najwyższy priorytet w systemie właściwości. Jeśli <xref:System.Windows.FrameworkContentElement.Style%2A> ma wartość null w tym momencie podczas ładowania właściwości system sprawdza, czy niejawna style jako zdefiniowanych zasoby, które określają tego typu. Jeśli styl nadal o wartości null po wykonaniu tego kroku, a następnie styl pochodzi z styl domyślny (motyw), ale domyślny styl nie jest zwracana w <xref:System.Windows.FrameworkContentElement.Style%2A> wartości właściwości. Zobacz [następstwo wartości właściwości](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object Style="{resourceExtension StyleResourceKey}"/>  
```  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *resourceExtension*  
 Jedną z następujących:, lub. Zobacz [zasoby XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Klucz, który identyfikuje styl żądanej. Klucz, który odwołuje się do istniejącego zasobu w <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Składnia elementu właściwości jest technicznie możliwe, ale niezalecane. Zobacz [style i Szablony wbudowane](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).  Odwołanie do wiązania za pomocą lub <xref:System.Windows.Data.Binding> jest również możliwe, ale rzadko.  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.StyleProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 Poniższy przykład ustanawia <xref:System.Windows.FrameworkContentElement.Resources%2A> kolekcji na <xref:System.Windows.Documents.FlowDocument> elementu głównego i następnie odwołuje się do niej jako zasób jako konkretnego stylu dla <xref:System.Windows.Documents.Paragraph>.  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.Style" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nazwa żądanej właściwości otoczenia.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> metody.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="propertyName" /> jest dostępna; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.FrameworkContentElement> wystąpienia jest rzutowany na <xref:System.Windows.Markup.IQueryAmbient> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkContentElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość dowolnego obiektu, który może służyć do przechowywania informacji niestandardowych o tym elemencie.</summary>
        <value>Wartość zamierzona. Ta właściwość nie ma wartości domyślnej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest odpowiednikiem właściwości tagu w modelach programowania inne firmy Microsoft, takie jak Visual Basic dla aplikacji lub Windows Forms. Jest on przeznaczony do istniejącego miejsca do przechowywania niestandardowych podstawowych informacji o dowolny element bez wymuszania programistom podklasę.  
  
<a name="xamlValues_Tag"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 Ponieważ ta właściwość ma obiektu, należy użyć użycie elementu właściwości, aby ustawić <xref:System.Windows.FrameworkContentElement.Tag%2A> właściwości w XAML coś innego niż obiekt, za pomocą konwertera typu znane i wbudowane, takie jak ciąg. Obiekty używane w ten sposób nie są zwykle w ramach standardowych przestrzeni nazw WPF i w związku z tym może wymagać mapowanie przestrzeni nazw do obszaru nazw zewnętrznych w celu wprowadzone jako elementy XAML.  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.TagProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.Tag" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy dowolna skojarzona właściwość docelowa uczestniczącego w powiązaniu o zmianach tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powierzchnie tego zdarzenia <xref:System.Windows.Data.Binding.TargetUpdated> zdarzenia, które jest wywoływane przez żaden <xref:System.Windows.Data.Binding> skojarzone z tym elementem. Zwykle oznacza to, czy powiązanie w danym jest powiązanie dwustronne i potwierdza, czy właściwość zależności powiązane unieważniania poprzednią wartość właściwości na dowolnym sprawdzania poprawności lub pamięci podręcznej schematu, który obsługuje właściwości.  
  
 Argumenty zdarzenia tego zdarzenia poinformuje, że użytkownik, który powiązany właściwości została zmieniona.  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object TargetUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do szablonu elementu nadrzędnego tego elementu. Ta właściwość nie jest istotne, jeśli element nie został utworzony za pomocą szablonu.</summary>
        <value>Element którego <see cref="T:System.Windows.FrameworkTemplate" /> <see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> spowodował ten element ma zostać utworzony. Ta wartość jest często <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Szablony są obiektami faktycznie udostępnionych, w których zawartość szablonu są tworzone tylko raz. W związku z tym Jeśli możesz uzyskać odwołanie do obiektu do elementu, który pochodzi z szablonem, może się okazać, że jawnego drzewo logiczne nie dociera do głównej strony. Aby połączyć takie odwołanie szablonu do drzewa logicznego strony, należy pobrać <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> wartości i dalsze przechodzenie tego drzewa elementów zgodnie z potrzebami.  
  
 <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> często będzie `null` dla wspólnych obiektów, ponieważ Jeśli odwołanie do obiektu przebywając za strony został uzyskany w aplikacji w typowy sposób, ten element prawdopodobnie nie został utworzony z szablonu. Przypadków, gdy <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> może nie być `null` obejmuje operacje, takie jak testowanie trafień zdarzenia obsługi dla niektórych zdarzeń wejściowych niskiego poziomu, lub podczas pracy z wyliczenia, które mogą zostać zwrócona elementów pochodzących z szablonów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkContentElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt etykietki narzędzia, która jest wyświetlana dla tego elementu w [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</summary>
        <value>Obiekt etykietki narzędzia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość tej właściwości jest typu <xref:System.Windows.Controls.ToolTip>, następnie jest etykietka narzędzia, które będą używane w [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].  Jeśli wartość jest innego typu, a następnie ta wartość będzie służyć jako *zawartości* dla <xref:System.Windows.Controls.ToolTip> udostępniane (wykonane), przez system. Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Controls.ToolTipService>. Klasa usługi zawiera dołączone właściwości, które mogą służyć do dalszego dostosowywania etykietki narzędzia.  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *toolTipContent*  
 Ciąg, który będzie wyświetlany tekst dla <xref:System.Windows.FrameworkContentElement.ToolTip%2A>.  
  
 *toolTipObjectContent*  
 Niektórych obiektów w formularzu elementów obiektu, który ma zostać użyty jako zawartość dla <xref:System.Windows.FrameworkContentElement> . Zazwyczaj powinien to być <xref:System.Windows.FrameworkElement> lub inny element, który tworzy składania układu dla <xref:System.Windows.FrameworkContentElement.ToolTip%2A>, po pewnym czasie zawierające tekst w obrębie składania. W tym użycie <xref:System.Windows.Controls.ToolTip> zostanie utworzony element niejawnie z przeanalizowany element [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]i *toolTipObjectContent* zawartości jest ustawiony jako jego <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> właściwości.  
  
 <`ToolTip` .../>  
 Zobacz <xref:System.Windows.Controls.ToolTip>.  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.ToolTipProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 W poniższym przykładzie ustawiono wartość <xref:System.Windows.FrameworkElement.ToolTip%2A> właściwość bezpośrednio na ciąg.  
  
 [!code-csharp[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/csharp/VS_Snippets_Wpf/TableSnippets2/CSharp/Window1.xaml.cs#_table_rowgroups_maniprows)]
 [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TableSnippets2/visualbasic/window1.xaml.vb#_table_rowgroups_maniprows)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje zaraz przed zamknięciem dowolnej etykietki narzędzia w elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby pominąć zamykanie etykietki narzędzia, programy obsługi zdarzeń należy oznaczyć go jako obsługiwane.  
  
 To zdarzenie nie może być <xref:System.Windows.EventTrigger> w stylu. Jest to spowodowane pole identyfikatora tego zdarzenia ponownie używa implementacji usługi, który nie ujawnia metody dodawania i usuwania dla zdarzenia.  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|  
|Strategii routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [kierowane Przegląd zdarzeń](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekty identyfikator zdarzenia są tworzone podczas zarejestrowanych zdarzeń trasowanych (zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) i następnie można dodać funkcje obsługi klas (zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Identyfikator obiekty zawierają nazwę identyfikującą typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po otwarciu dowolnej etykietki narzędzia w elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można ręcznie otworzyć etykietki narzędzi, programy obsługi zdarzeń należy oznaczyć istotnych zdarzeń jako obsługiwane. W przeciwnym razie wartość <xref:System.Windows.FrameworkContentElement.ToolTip%2A> zostanie użyta właściwość, aby automatycznie otworzyć menu kontekstowe. Oznaczanie zdarzeń obsługiwane skutecznie spowoduje anulowanie domyślnej akcji i może być możliwość resetowania wartości <xref:System.Windows.FrameworkContentElement.ToolTip%2A> właściwości, a następnie otwórz nowy <xref:System.Windows.Controls.ContextMenu>. Należy pamiętać, że to zdarzenie nie zostaną wywołane Jeśli <xref:System.Windows.FrameworkContentElement.ToolTip%2A> jest odwołanie o wartości null lub w inny sposób nie ustawiono.  
  
 To zdarzenie nie może być <xref:System.Windows.EventTrigger> w stylu. Jest to spowodowane pole identyfikatora tego zdarzenia ponownie używa implementacji usługi, który nie ujawnia metody dodawania i usuwania dla zdarzenia.  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|  
|Strategii routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [kierowane Przegląd zdarzeń](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekty identyfikator zdarzenia są tworzone podczas zarejestrowanych zdarzeń trasowanych (zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) i następnie można dodać funkcje obsługi klas (zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Identyfikator obiekty zawierają nazwę identyfikującą typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.ToolTip" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkContentElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Identyfikator klucza zasobu, który ma zostać odnaleziona.</param>
        <summary>Wyszukuje zasób z określonym kluczem, a następnie zwraca tego zasobu, jeśli znaleziono.</summary>
        <returns>Znaleziono zasobu. Jeśli nie znaleziono zasobu, <see langword="null" /> jest zwracana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zasób nie zostanie znaleziony w elemencie wywołującym, drzewa nadrzędnego jest przeszukiwany przy użyciu drzewa logicznego w taki sam sposób, który będzie drzewa przeszukiwane, jeśli odwołanie do zasobu dynamicznego zażądano według klucza w czasie wykonywania.  
  
 Zwykle będzie od razu rzutować wartości zwróconej na typ właściwości, które próbowano ustawić za pomocą wartości zwracane zasobów.  
  
 <xref:System.Windows.FrameworkContentElement.FindResource%2A> Metoda ma zachowanie podobne, z tą różnicą, że jej spowoduje zgłoszenie wyjątku w przypadku nie możesz znaleźć zasobu przy użyciu podanego klucza.  
  
   
  
## Examples  
 Poniższy przykład umożliwia znalezienie zasobów zgodnie z definicją w znacznikach i stosuje je do niektórych właściwości elementu w odpowiedzi na zdarzenia trasowanego.  
  
 [!code-csharp[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#tryfindresource)]
 [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#tryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy element zostanie usunięty z obrębu drzewa elementów załadowanych elementów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia trasowane bezpośrednie nie wykonuj trasy, są obsługiwane tylko w obrębie tego samego elementu, na którym są wywoływane. Bezpośrednie zdarzenia trasowane obsługują innych zachowań zdarzenia trasowanego: zbieranie dostępne programy obsługi pomocy technicznej i mogą być używane jako <xref:System.Windows.EventTrigger> w stylu.  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.UnloadedEvent>|  
|Strategii routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [kierowane Przegląd zdarzeń](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekty identyfikator zdarzenia są tworzone podczas zarejestrowanych zdarzeń trasowanych (zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) i następnie można dodać funkcje obsługi klas (zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Identyfikator obiekty zawierają nazwę identyfikującą typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkContentElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa pary nazwa obiektu do usunięcia z bieżącego zakresu.</param>
        <summary>Upraszcza dostęp do <see cref="T:System.Windows.NameScope" /> cofnięcia rejestracji metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystarczy wyrejestrować nazwy Jeśli zamierzasz ponownie zarejestrować inny element o takiej samej nazwie.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkContentElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ponowne zastosowanie domyślnego stylu do bieżącego <see cref="T:System.Windows.FrameworkContentElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
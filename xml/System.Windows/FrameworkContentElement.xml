<Type Name="FrameworkContentElement" FullName="System.Windows.FrameworkContentElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0153b7e8a724d59d0262abb505f5f2e36f1cdef0" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36460536" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkContentElement&#xA;Inherits ContentElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkContentElement : System::Windows::ContentElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkContentElement = class&#xA;    inherit ContentElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.ContentElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <see cref="T:System.Windows.FrameworkContentElement" /> Implementacja poziomie struktury WPF i rozszerzenie <see cref="T:System.Windows.ContentElement" /> klasy podstawowej. <see cref="T:System.Windows.FrameworkContentElement" /> dodaje obsługę dodatkowych wejściowych interfejsów API (w tym menu etykietki narzędzi i kontekst), scenorys, kontekst danych dla powiązania danych, Obsługa stylów i pomocnika drzewa logicznego interfejsów API.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement> jeszcze nie definiować własne sposób renderowania; Tworzenie wystąpień rzeczywistego <xref:System.Windows.FrameworkContentElement> wystąpienie klasy w kod lub znacznik jest możliwe, ale nie wyświetla żadnego obrazu w [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] aplikacji [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]. Renderowanie logiki musi być dostarczona przez klasy, które przyjmują <xref:System.Windows.FrameworkContentElement> elementy podrzędne w ramach ich modelu zawartości lub w <xref:System.Windows.FrameworkContentElement> klas pochodnych.  
  
 <xref:System.Windows.FrameworkContentElement> celowo równoleżnikami wiele takich samych [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] jako <xref:System.Windows.FrameworkElement>. Uwaga, że niektóre [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] na <xref:System.Windows.FrameworkElement> nie będą miały <xref:System.Windows.FrameworkContentElement> równoważne. Kilka <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] są funkcje, takie jak Geometria reprezentacja lub układ, które nie są istotne dla <xref:System.Windows.FrameworkContentElement>.  
  
 Większość istniejących <xref:System.Windows.FrameworkContentElement> klas pochodnych zostaną znalezione w <xref:System.Windows.Documents> przestrzeni nazw. Wiele z tych klas pochodnych implementować elementy modelu przepływu dokumentu. Niektórych klas pochodnych, takich jak <xref:System.Windows.Documents.Hyperlink> mają niektóre funkcje sterowania podobne, ale są uzyskiwane z <xref:System.Windows.FrameworkContentElement> taki sposób, że elementy sterowania przypominającej nadal mogą uczestniczyć w modelu przepływu dokumentu.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.FrameworkElement" />
    <altmember cref="T:System.Windows.ContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkContentElement" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Element podrzędny, która ma zostać dodana.</param>
        <summary>Dodaje podany element jako element podrzędny tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może zgłosić wyjątek, jeśli wywołana w chwili, gdy drzewa logicznego jest on iterowane przez inny proces.  
  
 Większość <xref:System.Windows.FrameworkContentElement> klas pochodnych ujawnia dedykowanych kolekcje, które są odpowiedzialne za zawierania (na przykład <xref:System.Windows.Documents.Span.Inlines%2A> na <xref:System.Windows.Documents.Span> klasy; <xref:System.Windows.Documents.Section.Blocks%2A> na <xref:System.Windows.Documents.Section> klasy). Zazwyczaj można uniknąć konieczności modyfikowania drzewa logicznego bezpośrednio, jeśli pochodzi z tych klas zamiast tego. Praca z drzewa logicznego elementów zawartości jest bardziej zaawansowany scenariusz, które mogą wymagać specjalnych analizatora składni lub specjalistycznej <xref:System.Windows.FrameworkElement> działający jako renderowania elementu nadrzędnego (host zawartości).  
  
 Aby uzyskać więcej informacji o sposobie używania <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> i <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, zobacz [drzewa WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkContentElement.LogicalChildren" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkContentElement.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywołuje się przed zainicjowaniem elementu.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Przesłonić tę metodę w celu zapewnienia specjalnej obsługi, która powinna wystąpić przed zainicjowaniem danego elementu w elemencie proces ładowania.  Implementacji powinny wywoływać implementację podstawową, ponieważ niektóre wewnętrzny flagi do śledzenia inicjowania ustawia implementacji base (ustawienie domyślne).  Podstawowa implementacja spowoduje zgłoszenie wyjątku, jeśli <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> zostanie wywołany więcej niż jeden raz dla tego samego elementu przed osiągnięciem <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna się sekwencję akcji uwzględnionych w podanych scenorysu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkContentElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">Scenorysu, aby rozpocząć.</param>
        <summary>Rozpoczyna się sekwencję akcji uwzględnionych w podanych scenorysu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku podpisów, które nie korzystają z `isControllable`, parametr, lub gdy został określony parametr parametru `false`, zegary osi czasu skojarzone z nią zostaną usunięte natychmiast po osiągnięciu okresu "Fill". W związku z tym animacji nie może zostać uruchomiony ponownie po raz uruchomione. Należy pamiętać, że animacja kontrolowanie również wymaga, aby scenorysu nazwanych lub dostępne w momencie wystąpienia w kodzie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">Scenorysu, aby rozpocząć.</param>
        <param name="handoffBehavior">Wartość wyliczenia opisujący zachowanie do użycia, jeśli właściwość opisanego w scenorysu jest już animowany.</param>
        <summary>Rozpoczyna się Sekwencja akcji, które są zawarte w podanych scenorysu, z opcjami dla co ma nastąpić, jeśli właściwość jest już animowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku podpisów, które nie korzystają z `isControllable`, parametr, lub gdy został określony parametr parametru `false`, zegary osi czasu skojarzone z nią zostaną usunięte natychmiast po osiągnięciu okresu "Fill". W związku z tym animacji nie może zostać uruchomiony ponownie po raz uruchomione. Należy pamiętać, że animacja kontrolowanie również wymaga, aby scenorysu nazwanych lub dostępne w momencie wystąpienia w kodzie.  
  
## <a name="using-the-compose-handoffbehavior"></a>Korzystanie z Compose HandoffBehavior  
 Po zastosowaniu <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> właściwości przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>oraz <xref:System.Windows.Media.Animation.Clock> obiekty wcześniej skojarzone z tą właściwością nadal zużywają zasoby systemowe, ale ma system chronometrażu Automatycznie usuwaj zegary.  
  
 Aby uniknąć problemów z wydajnością, podczas stosowania dużej liczby zegary za pomocą <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, tworzenie zegary należy usunąć z właściwości animowany po ich zakończeniu. Istnieje kilka sposobów, aby usunąć zegar:  
  
-   Aby usunąć wszystkie zegary z właściwości, należy użyć <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metody animowany obiektu. Określ właściwość animowanej jako pierwszego parametru oraz `null` jako drugiego. Spowoduje to usunięcie wszystkich zegary animacji z właściwości.  
  
-   Aby usunąć określony <xref:System.Windows.Media.Animation.AnimationClock> z listy zegary, użyj <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość <xref:System.Windows.Media.Animation.AnimationClock> można pobrać <xref:System.Windows.Media.Animation.ClockController>, następnie wywołaj <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metody <xref:System.Windows.Media.Animation.ClockController>. Jest to zazwyczaj wykonywane <xref:System.Windows.Media.Animation.Clock.Completed> programu obsługi zdarzeń dla zegara. Należy pamiętać, że tylko zegary głównego mogą być kontrolowane przez <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość zegara podrzędnych zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzenie nie jest wywoływane, jeśli efektywny czas trwania zegar jest nieskończoność.  W takim przypadku użytkownik musi określić, kiedy wywołać metodę <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 To przede wszystkim problemu dla animacji na obiektach, które mają długi okres istnienia.  Gdy obiekt jest bezużytecznych, jego zegary również są odłączone i w ramach odzyskiwania pamięci.  
  
 Aby uzyskać więcej informacji o obiektach zegara, zobacz [animacji i Przegląd systemu chronometrażu](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">Scenorysu, aby rozpocząć.</param>
        <param name="handoffBehavior">Wartość wyliczenia opisujący zachowanie do użycia, jeśli właściwość opisanego w scenorysu jest już animowany.</param>
        <param name="isControllable">Deklaruje, czy animacja jest kontrolowane (może być wstrzymane) po jej uruchomieniu.</param>
        <summary>Rozpoczyna się sekwencję akcji uwzględnionych w podanych scenorysu, o określonym stanie dla formantu animacji po jej uruchomieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku podpisów, które nie korzystają z `isControllable`, parametr, lub gdy został określony parametr parametru `false`, zegary osi czasu skojarzone z nią zostaną usunięte natychmiast po osiągnięciu okresu "Fill". W związku z tym animacji nie może zostać uruchomiony ponownie po raz uruchomione. Należy pamiętać, że animacja kontrolowanie również wymaga, aby scenorysu nazwanych lub dostępne w momencie wystąpienia w kodzie.  
  
## <a name="using-the-compose-handoffbehavior"></a>Korzystanie z Compose HandoffBehavior  
 Po zastosowaniu <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> właściwości przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>oraz <xref:System.Windows.Media.Animation.Clock> obiekty wcześniej skojarzone z tą właściwością nadal zużywają zasoby systemowe, ale ma system chronometrażu Automatycznie usuwaj zegary.  
  
 Aby uniknąć problemów z wydajnością, podczas stosowania dużej liczby zegary za pomocą <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, tworzenie zegary należy usunąć z właściwości animowany po ich zakończeniu. Istnieje kilka sposobów, aby usunąć zegar:  
  
-   Aby usunąć wszystkie zegary z właściwości, należy użyć <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metody animowany obiektu. Określ właściwość animowanej jako pierwszego parametru oraz `null` jako drugiego. Spowoduje to usunięcie wszystkich zegary animacji z właściwości.  
  
-   Aby usunąć określony <xref:System.Windows.Media.Animation.AnimationClock> z listy zegary, użyj <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość <xref:System.Windows.Media.Animation.AnimationClock> można pobrać <xref:System.Windows.Media.Animation.ClockController>, następnie wywołaj <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metody <xref:System.Windows.Media.Animation.ClockController>. Jest to zazwyczaj wykonywane <xref:System.Windows.Media.Animation.Clock.Completed> programu obsługi zdarzeń dla zegara. Należy pamiętać, że tylko zegary głównego mogą być kontrolowane przez <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość zegara podrzędnych zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzenie nie jest wywoływane, jeśli efektywny czas trwania zegar jest nieskończoność.  W takim przypadku użytkownik musi określić, kiedy wywołać metodę <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 To przede wszystkim problemu dla animacji na obiektach, które mają długi okres istnienia.  Gdy obiekt jest bezużytecznych, jego zegary również są odłączone i w ramach odzyskiwania pamięci.  
  
 Aby uzyskać więcej informacji o obiektach zegara, zobacz [animacji i Przegląd systemu chronometrażu](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Data.BindingGroup" /> używany dla elementu.</summary>
        <value>
          <see cref="T:System.Windows.Data.BindingGroup" /> Używany dla elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Data.BindingGroup> może służyć do sprawdzania poprawności wartości wielu właściwości obiektu. Załóżmy na przykład, że aplikacja monituje użytkownika o podanie adresu i wypełnienie klasy obiektu typu `Address`, który zawiera właściwości `Street`, `City`, `ZipCode`, i `Country`, wartościami, który użytkownika podane. Aplikacja ma panelu, który zawiera cztery <xref:System.Windows.Controls.TextBox> formantów, z których każdy jest powiązany z jedną z właściwości obiektu. Można użyć <xref:System.Windows.Controls.ValidationRule> w <xref:System.Windows.Data.BindingGroup> do sprawdzania poprawności `Address` obiektu. Na przykład <xref:System.Windows.Controls.ValidationRule> można zapewnić, że kod pocztowy jest prawidłowy dla kraju adresu.  
  
 Elementy podrzędne dziedziczą <xref:System.Windows.Data.BindingGroup> z ich elementów nadrzędnych, po prostu tak jak w przypadku innych właściwości dziedziczonych.  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|  
|Wartość właściwości metadanych **true**|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkContentElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Podejmuje próbę wprowadzenia tego elementu w widoku w ramach żadnych przewijanego regionów, który jest zawarty w.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołując tę metodę można skutecznie wywoła <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> na wszelkie przewijany obszar nadrzędny, który zawiera element (element nadrzędny bardzo dobrze może być <xref:System.Windows.FrameworkElement>, a nie <xref:System.Windows.FrameworkContentElement>). Jeśli ten element nie jest zawarta w przewijany obszar, jest nadal zdarzenia, ale nie będzie żadnego skutku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia element menu kontekstowego, który powinien zostać wyświetlony każdorazowo zażądano za pomocą menu kontekstowego [! INCLUDE[TLA#tla_ui](~/includes/tlasharptla-UI-MD.MD)] z wewnątrz tego elementu.</summary>
        <value>Menu kontekstowe, która używa tego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 W następujących miejscach przykład <xref:System.Windows.Controls.ContextMenu> na <xref:System.Windows.Documents.Paragraph>.  
  
 [!code-xaml[ContentElementsSmorgasbord#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#contextmenu)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje zaraz przed zamknięciem dowolnego menu kontekstowego w elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby pominąć zamknięcia menu kontekstowe, programy obsługi zdarzenia należy oznaczyć go jako obsłużone.  
  
 Aby użyć tego zdarzenia jako <xref:System.Windows.EventTrigger> w stylu, musi odwoływać się podstawowy identyfikator zdarzenia usługi:  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (To użycie jest konieczne, ponieważ implementacja zdarzeń na <xref:System.Windows.FrameworkContentElement> czy ujawnia odpowiadające mu zdarzenie usługi nie jest poprawnie mapowany <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> identyfikator do użycia w wyzwalaczy).  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|  
|Strategii routingu|Propagacji|  
|Delegate|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
   
  
## Examples  
 Poniższy przykład zawiera implementację programu obsługi, który zmienia kursor nad obszarem o nazwie `DisplayArea` (tego nie pokazano). Komentarz wskazówek w <xref:System.Windows.UIElement> użycia, ale w rzeczywistości tego przykładu może być taki sam Jeśli `DisplayArea` zostały <xref:System.Windows.FrameworkContentElement>.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [kierowane Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekty identyfikator zdarzenia są tworzone podczas kierowane zdarzenia są rejestrowane (zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>), a następnie można dodać obsługę klas (zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Identyfikator obiekty zawierają nazwę identyfikującą, typ właściciela typ obsługi, strategii routingu i metodę narzędzia na potrzeby dodawania właścicieli dla zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po otwarciu dowolnego menu kontekstowego w elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można ręcznie otworzyć menu kontekstowe, programy obsługi zdarzeń należy oznaczyć dane zdarzenie jako obsłużone. W przeciwnym razie wartość istniejących <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> właściwości będzie można użyć do automatycznego otwierania menu kontekstowego. Oznaczenie zdarzenia obsługiwane skutecznie spowoduje anulowanie domyślne działanie i może być możliwość resetowania wartości <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> właściwości, a następnie otwórz nową <xref:System.Windows.Controls.ContextMenu>. Jednak jest to problem chronometrażu, które należy zwrócić uwagę. Aby całkowicie zastąpić menu kontekstowe za pośrednictwem <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> programu obsługi, menu kontekstowe początkowy nie może być, null / puste. Alternatywnie konieczne może być zdarzenie, a następnie ręcznie otworzyć nowego menu kontekstowego. Aby uzyskać więcej informacji, zobacz [porady: Obsługa zdarzenia ContextMenuOpening](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).  
  
 Aby użyć tego zdarzenia jako <xref:System.Windows.EventTrigger> w stylu, musi odwoływać się podstawowy identyfikator zdarzenia usługi:  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (To użycie jest konieczne, ponieważ implementacja zdarzeń na <xref:System.Windows.FrameworkContentElement> czy ujawnia odpowiadające mu zdarzenie usługi nie jest poprawnie mapowany <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> identyfikator do użycia w wyzwalaczy).  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|  
|Strategii routingu|Propagacji|  
|Delegate|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [kierowane Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekty identyfikator zdarzenia są tworzone podczas kierowane zdarzenia są rejestrowane (zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>), a następnie można dodać obsługę klas (zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Identyfikator obiekty zawierają nazwę identyfikującą, typ właściciela typ obsługi, strategii routingu i metodę narzędzia na potrzeby dodawania właścicieli dla zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkContentElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kursor wyświetlany, gdy wskaźnik myszy znajduje się nad tym elementem.</summary>
        <value>Kursor do wyświetlenia. Wartością domyślną jest zdefiniowany jako <see langword="null" /> na ta właściwość zależności. Jednak domyślnie praktyczne w czasie wykonywania będzie pochodził z różnych czynników.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas ustawiania tej właściwości w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] procesora zależy od typu konwersji <xref:System.Windows.Input.Cursor> klasę, aby ocenić ten ciąg. Podany ciąg powinno zostać oszacowane <xref:System.Windows.Input.CursorType> wartość. Zobacz <xref:System.Windows.Input.Cursor> szczegółowe informacje.  
  
 Czy kursor zgodnie z ustaleniami tej właściwości będzie lub nie będą wyświetlane, gdy wskaźnik myszy znajduje się nad tym elementem również jest zależny od wartości <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> właściwości. Ponadto związane ze zdarzeniami zagadnienia, takie jak active przeciągania, przechwytywanie myszy, tryby w kontrolek i tak dalej do edycji tekstu wpłynie również na kursor mające wyższy priorytet niż określona wartość określoną w tej właściwości.  
  
 Aby przywrócić zachowanie ostatecznego domyślne ustawienie dla tej właściwości, należy ustawić ją na `null` ponownie.  
  
 `null` Domyślne naprawdę oznacza, że określenie wartości praktyczne kursora została odroczona tutaj mają być uzyskiwane z innej lokalizacji. Jeśli przedstawione bez programowe wartości z dowolnego źródła, gdy kursor domyślny za pośrednictwem [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] aplikacja będzie strzałka.  
  
 Każdy przepływ myszy nad [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] zgłasza aplikacji <xref:System.Windows.ContentElement.QueryCursor> zdarzeń. Dymki zdarzeń, a każdy element marszruty ma możliwość obsługi zdarzenia i ustawić wartość kursora za pośrednictwem argumentów tego zdarzenia. Jeśli tak się stanie, fakt, że zdarzenie jest obsługiwana i została zmieniona wartość w argumentach ma pierwszeństwo przed wartością <xref:System.Windows.FrameworkContentElement.Cursor%2A> właściwości na dowolnym poziomie, chyba że <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> jest ustawiona.  
  
 Jeśli nie są tworzone niestandardowych kursorów, zwykle zostanie ustawiona na wartość właściwości statycznej <xref:System.Windows.Input.Cursors> klasy.  
  
 Ustawienie <xref:System.Windows.Input.Cursor> do niestandardowej wartości nie jest włączone w częściowej relacji zaufania. Aby uzyskać więcej informacji o niestandardowych kursorów, zobacz [omówienie wprowadzania](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.CursorProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład ustawia kursor do niestandardowej wartości.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkContentElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkContentElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kontekst danych dla elementu, gdy uczestniczy w powiązaniu danych.</summary>
        <value>Obiekt, który ma być używana jako kontekst danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Kontekst danych* to pojęcie umożliwia elementom dziedziczenie informacji z ich elementów nadrzędnych o źródle powiązania, używany do wiązania, a także innych charakterystyk powiązania, takich jak ścieżka.  
  
 Kontekst danych można ustawić bezpośrednio do [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] obiektu z powiązaniami obliczane do właściwości tego obiektu. Alternatywnie można ustawić kontekstu danych <xref:System.Windows.Data.DataSourceProvider> obiektu.  
  
 Ta właściwość zależności dziedziczy wartości właściwości. Jeśli istnieją elementy podrzędne z ma inne wartości <xref:System.Windows.FrameworkContentElement.DataContext%2A> nawiązane za pomocą wartości lokalnej lub style, system właściwość zostanie ustaw wartość na <xref:System.Windows.FrameworkContentElement.DataContext%2A> wartości najbliższym elemencie nadrzędnym z tej wartości przypisane.  
  
 Alternatywnie można użyć jednej z następujących właściwości <xref:System.Windows.Data.Binding> klasę, aby jawnie określić źródło powiązania: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, lub <xref:System.Windows.Data.Binding.RelativeSource%2A>. Aby uzyskać więcej informacji, zobacz [porady: Określanie powiązania źródła](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).  
  
 W [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkContentElement.DataContext%2A> najczęściej jest ustawiony jako <xref:System.Windows.Data.Binding> deklaracji. Można użyć składni elementu właściwości lub Składnia atrybutu. Składnia atrybutu jest pokazano w przykładzie na tej stronie. Można również ustawić <xref:System.Windows.FrameworkContentElement.DataContext%2A> w kodzie.  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *dataContextObject*  
 Bezpośrednio osadzonego obiektu, który służy jako kontekst danych dla powiązań w elemencie nadrzędnym. Zazwyczaj jest to obiekt <xref:System.Windows.Data.Binding> lub innym <xref:System.Windows.Data.BindingBase> podklasy. Alternatywnie nieprzetworzone dane dowolnego [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] przeznaczone do powiązania mogą być umieszczane w tym miejscu z rzeczywistego powiązań zdefiniowanych później typu obiektu.  
  
 *bindingUsage*  
 Użycie powiązanie daje w wyniku kontekstu odpowiednich danych. Aby uzyskać więcej informacji, zobacz [powiązanie — rozszerzenie znaczników](~/docs/framework/wpf/advanced/binding-markup-extension.md).  
  
 *resourceExtension*  
 Jedną z następujących: `StaticResource`, lub `DynamicResource`. To użycie jest używany podczas odwoływania się do danych pierwotnych definiowana jako obiekt w zasobach. Zobacz [zasobów XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *contextResourceKey*  
 Identyfikator klucza dla żądanej za pomocą obiektu <xref:System.Windows.ResourceDictionary>.  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.DataContextProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Poniższy przykład przedstawia powiązanie na <xref:System.Windows.Documents.Paragraph> elementu, tworząc nowy obiekt danych niestandardowych ustanawianie obiektu jako <xref:System.Windows.FrameworkContentElement.DataContext%2A>i ustawianie ścieżki powiązania z właściwością w niej.  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie kontekstu danych tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać informacje o kontekstach danych i powiązania danych, zobacz [omówienie powiązania danych](~/docs/framework/wpf/data/data-binding-overview.md).  
  
> [!IMPORTANT]
>  Gdy element <xref:System.Windows.FrameworkContentElement.DataContext%2A> potencjalnie uwzględnianych zmian, wszystkie właściwości powiązanych z danymi w tym elemencie. Dotyczy to elementów, które elementy podrzędne bieżącego elementu, dziedziczących kontekstu danych, a także bieżącego elementu. Wszystkie takie powiązania ponownie zinterpretować nowe <xref:System.Windows.FrameworkContentElement.DataContext%2A> aby odzwierciedlić nową wartość w powiązaniach. Nie ma żadnej gwarancji, informacje dotyczące kolejności tych zmian względem gromadzenia <xref:System.Windows.FrameworkContentElement.DataContextChanged> zdarzeń.  Zmiany mogą wystąpić przed zdarzeniem, po zdarzeniu lub w dowolnej kombinacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.DataContext" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia klucz do użycia można znaleźć szablonu stylu dla tego formantu w kompozycji.</summary>
        <value>Klucz stylu. Działała prawidłowo, jako część wyszukiwania stylów motywu, ta wartość powinna być <see cref="T:System.Type" /> elementu trwa stylem. <see langword="null" /> jest akceptowane wartości dla niektórych sprawy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zazwyczaj nie ustawiono przez dowolne jego bezpośredniego ustawiające. Zamiast tego można zastąpić metadane specyficzne dla typu ta właściwość zależności, za każdym razem, gdy utworzysz nową podklasę. Gdy użytkownik podklasy, wywołaj <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> metody przed <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> identyfikator w konstruktorze statycznym podklasy formantu.  
  
 Na przykład klasę wbudowany, taką jak <xref:System.Windows.Documents.Bold> faktycznie ma bardzo mało implementację poza zastępowanie <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> metadanych w jego Konstruktor statyczny i udostępnia kilka konstruktorów wystąpienia. Fakt, że elementy otoczona <xref:System.Windows.Documents.Bold> tagu korzyści <xref:System.Windows.Documents.TextElement.FontWeight%2A> właściwość <xref:System.Windows.FontWeights.Bold%2A> jest zaimplementowana w obrębie stylu motywu przywoływany przez ustawienie wartości domyślne <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> do `typeof(Bold)`.  
  
 Jeśli chcesz, elementu lub formantu celowo nie style kompozycji, ustawić <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> właściwości `true`.  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkContentElement.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywoływana natychmiast po zainicjowaniu elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zaimplementuj tę metodę w celu zapewnienia specjalnej obsługi, która powinna wystąpić po zainicjowaniu danego elementu w elemencie proces ładowania.  
  
 Implementacji powinny wywoływać implementację podstawową, ponieważ niektóre wewnętrzny flagi do śledzenia inicjowania ustawia implementacji base (ustawienie domyślne).  
  
 Jeśli <xref:System.Windows.FrameworkContentElement.BeginInit%2A> wcześniej została wywołana, podstawowym zgłosi implementacji <xref:System.Windows.FrameworkContentElement.Initialized> zdarzeń. W przeciwnym razie, jeśli <xref:System.Windows.FrameworkContentElement.BeginInit%2A> nie została wywołana lub nie można ustalić, czy <xref:System.Windows.FrameworkContentElement.BeginInit%2A> została wywołana, zdarzenie nie jest wywoływane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkContentElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa elementu do wyszukania.</param>
        <summary>Odnajduje element o podanym identyfikatorze nazwie.</summary>
        <returns>Żądany element. Może być <see langword="null" /> , jeśli nie został znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ten element ma elementy podrzędne, te elementy podrzędne są wszystkie rekursywnie przeszukiwane dla żądanego o nazwie elementu.  
  
   
  
## Examples  
 Poniższy przykład przedstawia właściwości w elemencie znaleziono według nazwy w odwoływany <xref:System.Windows.Documents.FlowDocument> na stronie.  
  
 [!code-csharp[ContentElementsSmorgasbord#FindName](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findname)]
 [!code-vb[ContentElementsSmorgasbord#FindName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findname)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkContentElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Identyfikator klucza zasobu, który ma zostać odnaleziona.</param>
        <summary>Wyszukuje zasób z określonym kluczem i zostanie Zgłoś wyjątek, jeśli nie odnaleziono żądanego zasobu.</summary>
        <returns>Znaleziono zasobu lub <see langword="null" /> Jeżeli nie znaleziono pasującego zasobów (ale również zgłosi wyjątek, jeśli <see langword="null" />).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Jeśli ta metoda jest wywoływana dla klucza, którego nie można znaleźć, jest zwracany wyjątek. Jeśli nie chcesz obsługi wyjątków dla tej sprawy, należy zamiast tego wywołać <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>. <xref:System.Windows.FrameworkContentElement.TryFindResource%2A> Zwraca `null` po zostanie znaleziony żaden z zasobów, a nie zgłasza wyjątek.  
  
 Jeśli nie można znaleźć zasobu w elemencie wywołującym, drzewa nadrzędnego jest przeszukiwana przy użyciu drzewa logicznego, w taki sam sposób, która byłaby drzewa przeszukane Jeśli zasobów prosili klucza w czasie wykonywania.  
  
 Zwykle będzie natychmiast rzutowania wartości zwracanej typu właściwości, którą próbujesz ustawić o wartości zwracane zasobów.  
  
   
  
## Examples  
 Poniższy przykład umożliwia znalezienie zasobów zgodnie z definicją w znaczniku i stosuje je do niektórych właściwości elementu w odpowiedzi na kierowanego zdarzenia.  
  
 [!code-csharp[ContentElementsSmorgasbord#FindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findresource)]
 [!code-vb[ContentElementsSmorgasbord#FindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findresource)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">Nie znaleziono klucza żądanego zasobu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceKey" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt, który umożliwia dostosowanie wyglądu, efekty lub inne właściwości stylu, które zostaną zastosowane do tego elementu po zarejestrowaniu fokus klawiatury.</summary>
        <value>Żądany styl, aby zastosować na fokus. Wartość domyślna, zgodnie z deklaracją w właściwości zależności jest pusty statyczne <see cref="T:System.Windows.Style" />. Jednak wartość w czasie wykonywania jest często (ale nie zawsze) styl dostarczony przez motywu obsługę formantów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas ustawiania tej właściwości w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], style prawie zawsze są zdefiniowane jako zasób, zamiast wbudowanego jako elementu i że zasób jest zwykle przywoływany jako <xref:System.Windows.StaticResourceExtension>.  
  
 Należy pamiętać, że ta właściwość ma wpływ na wygląd, ale nie zgłasza to w metadanych. To dlatego Zmień wygląd jest sterowane zdarzeniami i nie może być stosowane przez cały czas i w związku z tym należy nie ogólnie raportować żadnych informacji visual ani układu w metadanych.  
  
 Koncepcyjnie visual zachowanie fokus do formantu powinna być spójne element elementu. Najbardziej za pośrednictwem sposób, aby wymusić spójność jest tylko zmiana fokusu stylu wizualnego. w przypadku redagowania całego motywu. Ustawienie tej właściwości na poszczególnych stylów, a nie jako część kompozycji nie jest zamierzone użycie tej właściwości, ponieważ może dojść do mylące czynności użytkownika dotyczących fokus klawiatury. Jeśli są mają zostać zachowanie specyficzne dla elementu celowo nie jest spójny we motywu, dużo lepszym rozwiązaniem jest używanie wyzwalaczy w stylach właściwości poszczególnych stanu danych wejściowych, takich jak <xref:System.Windows.UIElement.IsFocused%2A> lub <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>i aby to zrobić w taki sposób, który nie obsługuje wizualne zakłócać wszelkie istniejące stylu wizualnego fokus. Aby uzyskać więcej informacji na zamiar projektu <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> i alternatywne skupić się właściwości, zobacz [style dla zespołu w formantach i FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *resourceExtension*  
 Jedną z następujących:, lub. Zobacz [zasobów XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Klucz identyfikujący styl żądanej. Klucz odnosi się do istniejącego zasobu w <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Składni elementu właściwości jest technicznie możliwe, ale nie jest zalecane. Zobacz [style wbudowane i szablony](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).  Odwołanie do wiązania za pomocą lub <xref:System.Windows.Data.Binding> jest także możliwe, ale rzadko.  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą czy to <see cref="T:System.Windows.FrameworkContentElement" /> powinien wymusić [! INCLUDE[TLA#tla_ui](~/includes/tlasharptla-UI-MD.MD)] do renderowania kursora w postaci zadeklarowanej przez to wystąpienie w <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> właściwości.</summary>
        <value>
          <see langword="true" /> Aby wymusić prezentacji kursora za pośrednictwem tego elementu, aby użyć tego wystąpienia obiektu ustawienie kursora (w tym na wszystkie elementy podrzędne); w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie tej właściwości na `true` spowoduje zastąpienie preferencje kursora ustala elementy podrzędne. To dlatego na ogół aplikacji [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] może być mylące dla użytkownika, zwłaszcza w przypadku, gdy próbuje określić kursory elementy podrzędne. Ustawienie <xref:System.Windows.FrameworkElement.ForceCursor%2A> jest bardziej odpowiednie w scenariuszach podklasy lub składania formantu.  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład powoduje kursor znajduje się nad elementem.  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Element docelowy <see cref="T:System.Windows.DependencyProperty" /> służący do pobierania powiązania.</param>
        <summary>Pobiera <see cref="T:System.Windows.Data.BindingExpression" /> dla określonej właściwości powiązania.</summary>
        <returns>Zwraca <see cref="T:System.Windows.Data.BindingExpression" /> Jeśli obiektem docelowym są danymi powiązanymi; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pobiera powiązanie zapytania dotyczącego właściwości.  
  
 [!code-csharp[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#getbindingexpression)]
 [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#getbindingexpression)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca alternatywnych logiczny obiekt nadrzędny dla tego elementu, jeśli nie elementu nadrzędnego visual. W takim przypadku <see cref="T:System.Windows.FrameworkContentElement" /> nadrzędny jest zawsze taką samą wartość jak <see cref="P:System.Windows.FrameworkContentElement.Parent" /> właściwości.</summary>
        <returns>Zwraca coś innego niż <see langword="null" /> po każdej zmianie WPF poziomie struktury implementacja tej metody ma połączenie Niewizualne nadrzędnej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca Oczekiwano jednego nadrzędnego visual. Implementacje niestandardowe mogą zwracać relacje alternatywny nadrzędny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy to <see cref="T:System.Windows.FrameworkContentElement" /> został zainicjowany. Pokrywa się to z przypadkami, w którym wartość <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> właściwość zmienia się z <see langword="false" /> (lub niezdefiniowaną) do <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Będzie to zdarzenie wywoływane, gdy <xref:System.Windows.FrameworkContentElement.EndInit%2A> lub <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> metody są wywoływane. Wywołania tych metod można zostały dokonane przez kod zamierzonego lub przez [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] proces ładowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkContentElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kontekst dla danych wejściowych używanych przez to <see cref="T:System.Windows.FrameworkContentElement" />.</summary>
        <value>Wejściowych zakresu, który modyfikuje interpretacji danych wejściowych z alternatywne metody wprowadzania tekstu. Wartość domyślna to <see langword="null" /> (które powoduje domyślna obsługa poleceń).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zależności dziedziczy wartości właściwości. Jeśli istnieją elementy podrzędne z ma inne wartości <xref:System.Windows.FrameworkElement.InputScope%2A> nawiązane za pomocą wartości lokalnej lub style, system właściwość zostanie ustaw wartość na <xref:System.Windows.FrameworkElement.InputScope%2A> wartości najbliższym elemencie nadrzędnym z tej wartości przypisane.  
  
 Mimo że [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] składni użycia ma na liście i składnia jest dozwolona, ustawienie dla tej właściwości [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] nie jest często.  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.InputScopeProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.InputScope" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten element został zainicjowany, albo przez ładowany jako [! INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-XAML-MD.MD)] albo przez zdefiniowanie jawnie jego <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> wywołana metoda.</summary>
        <value>
          <see langword="true" /> Jeśli element jest inicjowana na wyżej wymienione ładowania lub metody wywołań; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość może być również `true` Jeśli ten element został przeniesiony w obrębie drzewa element taki sposób, że ma nowy element nadrzędny, a w związku z tym staje się ponownie załadowana ponownie.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten element został załadowany do prezentacji.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący element jest dołączona do drzewa i wyrenderowaniu; <see langword="false" /> Jeśli element nigdy nie został dołączony do drzewa załadowanych elementów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Z nowo utworzone wystąpienie, ta właściwość jest uruchamiany `false`i pozostaje `true` po ustawieniu `true`, nawet jeśli później usunięte przez kod.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> jako warunkowego wyboru, aby mieć pewność, że funkcja `displayData` (tego nie pokazano) będzie elementów prawidłową załadowany na stronie, aby pracować, jako część programu obsługi na żądanie. Czy samej logiki jest uruchamiany jako program obsługi zdarzeń dla <xref:System.Windows.FrameworkContentElement.Loaded>.  
  
 [!code-csharp[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#isloaded)]
 [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#isloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkContentElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkContentElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje języka lokalizacji/globalizacji, który dotyczy pojedynczego elementu.</summary>
        <value>Informacje o ustawieniach kulturowych dla tego elementu. Wartość domyślna to <see cref="T:System.Windows.Markup.XmlLanguage" /> wystąpienia z jego <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> wartość ciągu "en US".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Formaty ciągu zgodne ze standardem RFC 3066. Na przykład stany USA Język angielski jest "en US". Zobacz <xref:System.Windows.Markup.XmlLanguage> uzyskać więcej informacji o wartości i formatu.  
  
 Ta właściwość zależności dziedziczy wartości właściwości. Jeśli istnieją elementy podrzędne z ma inne wartości <xref:System.Windows.FrameworkElement.Language%2A> nawiązane za pomocą wartości lokalnej lub style, system właściwość zostanie ustaw wartość na <xref:System.Windows.FrameworkElement.Language%2A> wartości najbliższym elemencie nadrzędnym z tej wartości przypisane.  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.LanguageProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.Language" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy element jest poukładany, wyrenderowany i gotowy do interakcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezpośrednie kierowane zdarzenia nie wykonuj trasy, są obsługiwane tylko w obrębie tego samego elementu, na którym jest uruchamiany. Bezpośrednie kierowane zdarzenia obsługuje inne zachowanie kierowanego zdarzenia: obsługują dostępny obsługi kolekcji i mogą być używane jako <xref:System.Windows.EventTrigger> w stylu.  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.LoadedEvent>|  
|Strategii routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [kierowane Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekty identyfikator zdarzenia są tworzone podczas kierowane zdarzenia są rejestrowane (zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>), a następnie można dodać obsługę klas (zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Identyfikator obiekty zawierają nazwę identyfikującą, typ właściciela typ obsługi, strategii routingu i metodę narzędzia na potrzeby dodawania właścicieli dla zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduł wyliczający logicznym podrzędnym elementy tego elementu.</summary>
        <value>Moduł wyliczający dla elementów podrzędnych logicznej tego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat sposobu użycia <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> i <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, zobacz [drzewa WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkContentElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">Kierunek, który koncentruje się na przenoszenie jako wartość wyliczenia.</param>
        <summary>Przenosi fokus klawiatury z tego elementu do innego elementu.</summary>
        <returns>Zwraca <see langword="true" /> Jeśli fokus zostanie przeniesiony pomyślnie; <see langword="false" /> Jeśli określony element docelowy w kierunku nie istnieje.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkContentElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę identyfikującą elementu. Nazwa zawiera odwołania do wystąpienia, aby po jest tworzony podczas analizowania programowe związane z kodem, takie jak kod obsługi zdarzeń, może odwoływać się do elementu [! INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-XAML-MD.MD)].</summary>
        <value>Nazwa elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najbardziej typowe użycie tej właściwości jest podczas określania [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] nazwy elementu w znaczniku.  
  
 Ta właściwość zapewnia zasadniczo można ustawić właściwości wygody poziomie struktury WPF [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [x: Name — dyrektywa](~/docs/framework/xaml-services/x-name-directive.md).  
  
 Pobieranie <xref:System.Windows.FrameworkContentElement.Name%2A> z kodu nie jest często, ponieważ jeśli już ma odwołanie do odpowiedniego w kodzie, po prostu można wywoływać metod i właściwości w elemencie odwołania, a nie zawierają zazwyczaj potrzeba <xref:System.Windows.FrameworkContentElement.Name%2A>. Wyjątek ma, gdy ciąg ma, na przykład niektóre przeciążone oznacza Jeśli przydaje się do wyświetlania tej nazwy w [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]. Ustawienie <xref:System.Windows.FrameworkContentElement.Name%2A> z kodu Jeśli oryginalny <xref:System.Windows.FrameworkContentElement.Name%2A> został zestaw na podstawie znaczników nie zaleca się i zmiana właściwości nie zmieni się odwołanie do obiektu. Odwołania do takich obiektów są tworzone tylko wtedy, gdy podstawowy namescopes jawnie są tworzone podczas [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] ładowania.  
  
 W szczególności należy wywołać <xref:System.Windows.FrameworkContentElement.RegisterName%2A> aby zmiana na <xref:System.Windows.FrameworkContentElement.Name%2A> właściwość elementu już załadowana.  
  
 Godny uwagi jeden przypadek, w przypadku, gdy ustawienie <xref:System.Windows.FrameworkContentElement.Name%2A> z kodu jest ważne dla nazw elementów, które scenorys będzie uruchamiana. Przed zarejestrowaniem nazwę może także zajść potrzeba utworzenia wystąpienia i przypisz <xref:System.Windows.NameScope> wystąpienia. Zobacz sekcję przykład lub [omówienie Scenorys](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
 Ustawienie <xref:System.Windows.FrameworkContentElement.Name%2A> z kodu ma ograniczoną aplikacji, ale wyszukiwania według nazwy elementu jest bardziej popularne, zwłaszcza w przypadku, gdy są wykorzystujących model nawigacji, gdzie stron ponownie załadować do aplikacji i kodu w czasie wykonywania nie jest kodem tego odpowiednich strony. Metoda narzędzie <xref:System.Windows.FrameworkContentElement.FindName%2A>, która jest dostępna z dowolnego <xref:System.Windows.FrameworkContentElement>, można znaleźć żadnych elementu przez <xref:System.Windows.FrameworkContentElement.Name%2A> w rekursywnie drzewa logicznego tego elementu. Lub użyć <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> metody statycznej z <xref:System.Windows.LogicalTreeHelper>, który przyjmuje również <xref:System.Windows.FrameworkContentElement.Name%2A> ciągu jako argument.  
  
 Najczęściej używanych elementów głównych (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> na przykład) implementować interfejs <xref:System.Windows.Markup.INameScope>. Implementacje tego interfejsu powinny wymuszanie nazwy być jednoznaczne w swoim zakresie.  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.NameProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.Name" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Zapewnia dane o zdarzeniu.</param>
        <summary>Wywoływane, gdy <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> kierowanego zdarzenia osiągnie tej klasy w jego trasy. Zaimplementuj tę metodę, aby dodać klasę obsługi dla tego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma domyślnej implementacji. Nadal powinny wywoływać implementację podstawową, w przypadku, gdy klasa pośrednicząca w dziedziczenia zaimplementowała tej metody.  
  
 Celem tej metody przypomina trochę [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] wzorzec zdarzeń na * metody: zapewnia sposób obsługi pasujące zdarzenie z klasy pochodnej z klasy obsługi zamiast obsługi wystąpienia. W takim przypadku pasujące zdarzenie jest kierowanego zdarzenia. Wzorzec implementacji metod On * są różne dla kierowane zdarzenia, ponieważ kierowanego zdarzenia został zgłoszony przez element podrzędny, niekoniecznie element wywołujący programów obsługi. W związku z tym implementacji, należy uwzględnić zdarzenia właściwości źródła argumentów (i nie należy próbować ponownie zgłosić zdarzenie, które w większości przypadków). Podklasy <xref:System.Windows.FrameworkContentElement> można wywoływać metod obsługi Klasa prywatna, po odebraniu zdarzenia wzdłuż trasy. Jednym ze scenariuszy potencjalnych jest przyjmują argumentów zdarzenia i celowo oznaczanie zdarzenia jako obsługiwane w celu skrócenia trasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzeń dla zdarzenia.</param>
        <summary>Wywoływane, gdy <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> kierowanego zdarzenia osiągnie tej klasy w jego trasy. Zaimplementuj tę metodę, aby dodać klasę obsługi dla tego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma domyślnej implementacji. Nadal należy wywołać base() w przypadku, gdy klasa pośrednicząca w dziedziczenia zaimplementowała tej metody.  
  
 Celem tej metody przypomina trochę [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] wzorzec zdarzeń na * metody: zapewnia sposób obsługi pasujące zdarzenie z klasy pochodnej z klasy obsługi zamiast obsługi wystąpienia. W takim przypadku pasujące zdarzenie jest kierowanego zdarzenia. Wzorzec implementacji metod On * są różne dla kierowane zdarzenia, ponieważ kierowanego zdarzenia został zgłoszony przez element podrzędny, niekoniecznie element wywołujący programów obsługi, więc implementacji będzie musiała źródła argumenty zdarzenia właściwości pod uwagę (i nie należy próbować ponownie zgłosić zdarzenie, które w większości przypadków). Podklasy <xref:System.Windows.FrameworkContentElement> można wywoływać metod obsługi Klasa prywatna, po odebraniu zdarzenia wzdłuż trasy. Jednym ze scenariuszy potencjalnych jest przyjmują argumentów zdarzenia i celowo oznaczanie zdarzenia jako obsługiwane w celu skrócenia trasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkContentElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzeń dla zdarzenia.</param>
        <summary>Klasy obsługi <see cref="E:System.Windows.ContentElement.GotFocus" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten program obsługi klasy Ustawia zachowanie odpowiednie fokus w tym elemencie, jeśli pochodzi z tego elementu. Jeśli źródło zdarzenia innego elementu w drzewie, program obsługi nie działa.  
  
 Zastępuje tę metodę, aby zmienić domyślne koncentrujących się zachowanie w elemencie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkContentElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzeń dla zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.FrameworkContentElement.Initialized" /> zdarzeń. Ta metoda jest wywoływana przy każdym <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> ma ustawioną wartość <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody wirtualnej zgłasza zdarzenie, zgodnie z opisem we wcześniejszej części tego tematu. Zastąpienia powinny wywoływać base(), aby zachować to zachowanie.  
  
 Należy pamiętać, że <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> właściwość jest tylko do odczytu. W związku z tym nie można ustawić, aby wymusić zachowanie inicjowania w ten sposób. Ustawienia ma być wykonywane tylko przez [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkContentElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzenia, które opisano zmiany, w tym starej i nowej wartości właściwości.</param>
        <summary>Wywoływane, gdy wartość efektywna dowolnej właściwości zależności na tym <see cref="T:System.Windows.FrameworkContentElement" /> została zaktualizowana. Właściwości określonych zależności, które zmienić jest zgłaszana w parametrze argumentów. Zastępuje <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest przeznaczona do ogólnie wykrycia zmian właściwości lub invalidations. Zamiast tego ma ona modyfikacji wzorca ogólne unieważniania Jeśli znane jest niektórych informacji o klasyfikacjach szeroki właściwości.  
  
 Tej metody jest potencjalnie wywołana wiele razy w okresie istnienia obiektu. W związku z tym można osiągnąć lepszą wydajność, jeśli Zastępowanie metadanych określonych właściwości, a następnie dołącz <xref:System.Windows.CoerceValueCallback> lub <xref:System.Windows.PropertyChangedCallback> funkcje dla poszczególnych właściwości. Jednak czy użyć tej metody, jeśli <xref:System.Windows.FrameworkContentElement> obejmuje znaczących właściwości zależności powiązanych wartości, lub jeśli zawiera logikę, takich jak zachowanie renderowania, który musi zostać uruchomiony ponownie dla kilku powiązanych przypadków invalidations właściwości.  
  
 Należy pamiętać, że o identycznej nazwie `OnPropertyChanged` metody o innym podpisie (typ parametru jest <xref:System.ComponentModel.PropertyChangedEventArgs>) wyświetlanych na liczbę klas. Czy `OnPropertyChanged` jest używany dla powiadomienia obiektu danych i jest częścią kontraktu dla <xref:System.ComponentModel.INotifyPropertyChanged>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zawsze należy wywoływać implementację podstawową, jako pierwszą operacją w implementacji. Błąd w tym celu znacznie spowoduje wyłączenie całego [! System właściwości include[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-MD.MD)], co powoduje, że nieprawidłowe wartości należy podać.</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkContentElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">Stary styl.</param>
        <param name="newStyle">Nowy styl.</param>
        <summary>Wywoływane, gdy styl jest używany w przypadku zmiany tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma domyślną implementację, która ustawia flaga wewnętrzna, biorąc pod uwagę warunek zmieniony styl.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zawsze wywoływać implementację podstawową, w przeciwnym razie nie można zastosować style. Scenariusze dotyczące przesłaniania tej metody może zawierać klasy pochodnej ma selektor stylu specjalne lub buforuje wartości stylu. Zmiany motywu potencjalnie będzie wywoływać tej metody.</para>
        </block>
        <altmember cref="P:System.Windows.FrameworkContentElement.Style" />
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Zapewnia dane o zdarzeniu.</param>
        <summary>Wywoływane, gdy <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> kierowanego zdarzenia osiągnie tej klasy w jego trasy. Zaimplementuj tę metodę, aby dodać klasę obsługi dla tego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma domyślnej implementacji. Nadal należy wywołać base() w przypadku, gdy klasa pośrednicząca w dziedziczenia zaimplementowała tej metody.  
  
 Celem tej metody przypomina trochę [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] wzorzec zdarzeń na * metody: zapewnia sposób obsługi pasujące zdarzenie z klasy pochodnej z klasy obsługi zamiast obsługi wystąpienia. W takim przypadku pasujące zdarzenie jest kierowanego zdarzenia. Wzorzec implementacji metod On * są różne dla kierowane zdarzenia, ponieważ kierowanego zdarzenia został zgłoszony przez element podrzędny, niekoniecznie element wywołujący programów obsługi, więc implementacji będzie musiała źródła argumenty zdarzenia właściwości pod uwagę (i nie należy próbować ponownie zgłosić zdarzenie, które w większości przypadków). Podklasy <xref:System.Windows.FrameworkContentElement> można wywoływać metod obsługi Klasa prywatna, po odebraniu zdarzenia wzdłuż trasy. Jednym ze scenariuszy potencjalnych jest przyjmują argumentów zdarzenia i celowo oznaczanie zdarzenia jako obsługiwane w celu skrócenia trasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Zapewnia dane o zdarzeniu.</param>
        <summary>Wywoływane, gdy <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> kierowanego zdarzenia osiągnie tej klasy w jego trasy. Zaimplementuj tę metodę, aby dodać klasę obsługi dla tego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma domyślnej implementacji. Nadal należy wywołać base() w przypadku, gdy klasa pośrednicząca w dziedziczenia zaimplementowała tej metody.  
  
 Celem tej metody przypomina trochę [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] wzorzec zdarzeń na * metody: zapewnia sposób obsługi pasujące zdarzenie z klasy pochodnej z klasy obsługi zamiast obsługi wystąpienia. W takim przypadku pasujące zdarzenie jest kierowanego zdarzenia. Wzorzec implementacji metod On * są różne dla kierowane zdarzenia, ponieważ kierowanego zdarzenia został zgłoszony przez element podrzędny, niekoniecznie element wywołujący programów obsługi, więc implementacji, musisz podjąć źródła argumenty zdarzenia właściwości pod uwagę (i nie należy próbować ponownie zgłosić zdarzenie, które w większości przypadków). Podklasy <xref:System.Windows.FrameworkContentElement> można wywoływać metod obsługi Klasa prywatna, po odebraniu zdarzenia wzdłuż trasy. Jednym ze scenariuszy potencjalnych jest przyjmują argumentów zdarzenia i celowo oznaczanie zdarzenia jako obsługiwane w celu skrócenia trasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy ten element uwzględnia właściwości stylu ze stylów motywu.</summary>
        <value>
          <see langword="true" /> Jeśli ten element nie używa właściwości style kompozycji; wszystkie właściwości stylu pochodzące pochodzą z aplikacji lokalnej style i właściwości style kompozycji nie mają zastosowania. <see langword="false" /> Jeśli style aplikacji się najpierw, a następnie Zastosuj style kompozycji dla właściwości, które nie zostały ustawione w szczególności w stylach aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najbardziej typowe użycie tej właściwości jest pośrednie użycia w ramach metody ustawiającej stylu dostarczające style motywów.  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera element nadrzędny w drzewie logicznym dla tego elementu.</summary>
        <value>Element nadrzędny logicznego dla tego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zauważ, że logiczny obiekt nadrzędny elementu nie może zmienić w zależności od funkcji z aplikacji, i utrzymywanie wartość tej właściwości nie zreflektuje tej zmiany. Należy zwykle pobrać wartość natychmiast, zanim zajdzie taka potrzeba.  
  
 Zobacz [drzewa WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) uzyskać więcej informacji o przechodzenie drzewa logiczne oraz scenariusze, gdy biorąc to podejście do elementu odnajdywania jest odpowiedni.  
  
 System właściwości potencjalnie ponownych wszystkich wartości właściwości elementu po jego pokrewnym, ponieważ niektóre właściwości dziedziczenia wartości za pośrednictwem drzewa logicznego. <xref:System.Windows.FrameworkContentElement.DataContext%2A> Dotyczący dla powiązania można również zmienić, gdy elementy są pokrewnym.  
  
 Zmienianie elementu nadrzędnego zwykle tylko odbywa się za pośrednictwem manipulowania kolekcje, za pomocą dedykowanego metod dodawania i usuwania, lub przez ustawienie właściwości elementów zawartości.  
  
 Najbardziej typowym scenariuszem stosowania <xref:System.Windows.FrameworkContentElement.Parent%2A> właściwości ma otrzymać odwołanie, a następnie zachęcić różnych <xref:System.Windows.FrameworkContentElement> wartości właściwości z obiektu nadrzędnego. Dla szablonów <xref:System.Windows.FrameworkContentElement.Parent%2A> szablonu po pewnym czasie będzie `null`. Aby uzyskać po tym punkcie i rozszerzyć w drzewie logicznym, w której faktycznie zastosować ten szablon, użyj <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.  
  
   
  
## Examples  
 Poniższy przykład sprawdza, czy <xref:System.Windows.FrameworkContentElement.Parent%2A> z <xref:System.Windows.Documents.TextPointer> jest określonego typu.  
  
 [!code-csharp[TextPointer_snippets#FCEParent](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#fceparent)]
 [!code-vb[TextPointer_snippets#FCEParent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#fceparent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Kierunek, dla której można ustalić zmiany potencjalnego fokus.</param>
        <summary>Określa następnego elementu, który może odbierać fokus względem tego elementu dla kierunku przepływu podana fokus, ale faktycznie nie przenosi fokus. Ta metoda jest zapieczętowany i nie może zostać zastąpiona.</summary>
        <returns>Następny element, który skupić się były przenoszone do, jeśli faktycznie był przekształcić fokus. Może zwrócić <see langword="null" /> Jeśli fokus nie można przenieść względem tego elementu dla podanego kierunku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement.MoveFocus%2A> jest to metoda pokrewne faktycznie Przenieś fokus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Określić jedną z następujących wskazówek w <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />. Te kroki są niedozwolone dla <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (ale dozwolony dla <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkContentElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa do użycia dla określonego mapowania nazwy obiektu.</param>
        <param name="scopedElement">Obiekt do mapowania.</param>
        <summary>Udostępnia metody dostępu, które ułatwiają dostęp do <see cref="T:System.Windows.NameScope" /> metoda rejestracji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest metodą wygody wywołania <xref:System.Windows.NameScope.RegisterName%2A>. Implementacja będzie sprawdzać elementy nadrzędne kolejnych, aż do znalezienia odpowiednich <xref:System.Windows.NameScope> wdrożenia, który znajduje się przez wyszukiwanie elementu, który implementuje <xref:System.Windows.Markup.INameScope>. Aby uzyskać więcej informacji o namescopes, zobacz [WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 Wywoływanie <xref:System.Windows.FrameworkContentElement.RegisterName%2A> jest potrzebne do poprawnie Połącz scenorys animacji dla aplikacji, podczas tworzenia w kodzie. Jest to spowodowane jedną klucza scenorysu właściwości <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, używa środowiska wykonawczego nazw wyszukiwania zamiast możliwość odwołania do elementu docelowego. Dotyczy to nawet, jeśli ten element jest dostępny przez odwołanie z kodu. Aby uzyskać więcej informacji na czego potrzebujesz do rejestracji nazw dla celów scenorysu, zobacz [omówienie Scenorys](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md). Animacji dla elementów zawartości są mniej typowe niż animacji na formanty, [omówienie Scenorys](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md) koncentruje się na scenariuszach kontroli.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Element do usunięcia.</param>
        <summary>Usuwa określony element z drzewa logicznego dla tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] dotyczy głównie klasy wywodzące scenariuszy, podczas dodawania obsługi dla kolekcji podrzędnych.  
  
 Większość <xref:System.Windows.FrameworkContentElement> klas pochodnych ujawnia dedykowanych kolekcje, które są odpowiedzialne za zawierania (na przykład <xref:System.Windows.Documents.Span.Inlines%2A> na <xref:System.Windows.Documents.Span> klasy; <xref:System.Windows.Documents.Section.Blocks%2A> na <xref:System.Windows.Documents.Section> klasy). Wyprowadzanie z klas takich zazwyczaj można uniknąć konieczności modyfikowania drzewa logicznego bezpośrednio.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkContentElement.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżący słownik zasobów zdefiniowane lokalnie.</summary>
        <value>Bieżące zasoby zdefiniowane lokalnie. Jest to słownik zasobów, w którym dostęp do zasobów w słowniku według klucza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Słowniki zasobów, które mogą być definiowane w całości lub częściowo w [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] są zazwyczaj tworzone jako elementu właściwości i są zwykle w elemencie głównym dla dowolnego pojedynczej strony lub aplikacji. Wprowadzenie do słownika zasobów na tym poziomie ułatwia odnaleźć podrzędne poszczególnych elementów na stronie (lub z dowolnej strony w przypadku aplikacji). W większości scenariuszy aplikacji, firma Microsoft zaleca, że style można zdefiniować jako elementy obiekt słownika zasobów lub zdefiniowane jako zasobów zewnętrznych, aby umożliwić zasób stylu całej niezależne (to rozwiązanie pomaga w oddzielnych projektanta obowiązki związane z obowiązki developer, oddziel pliki fizyczne, które powinny być edytowane).  
  
 Należy pamiętać, że ta właściwość zwraca tylko słownik zasobów zadeklarowany bezpośrednio z poziomu tego elementu. To jest inny niż proces wyszukiwania zasobów rzeczywistych, umożliwiający elementu podrzędnego dostęp do dowolnych zasobów zdefiniowane w każdy element nadrzędny, wyszukiwanie rekursywnie w górę.  
  
 Zasoby mogą się też odwoływać przez kod kolekcji, ale należy pamiętać, że zasoby są tworzone w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] ostatecznie nie będzie dostępny dopiero po <xref:System.Windows.FrameworkContentElement.Loaded> zostanie wywołane przez element, który deklaruje słownika. W rzeczywistości zasoby są parsowane asynchronicznie, a nie nawet <xref:System.Windows.FrameworkContentElement.Loaded> zdarzenie jest zapewnienie, że można się odwołać [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] zdefiniowanych zasobów. Z tego powodu należy zwykle tylko dostęp [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] zdefiniowane jako część kodu w czasie wykonywania, lub za pośrednictwem innych zasobów [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] technik, takich jak style lub odwołania do rozszerzenia zasobu dla wartości atrybutu. Gdy uzyskujesz dostęp do zasobów przy użyciu kodu jest zasadniczo odpowiednikiem odniesienia z [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 Podstawowa <xref:System.Windows.ResourceDictionary> obsługuje metody wymagane do dodawania, usuwania lub zbadać zasobów w w kolekcji przy użyciu kodu. <xref:System.Windows.FrameworkContentElement.Resources%2A> Właściwość jest można ustawić na potrzeby scenariusza całkowicie zastąpienia kolekcji zasobów jako nowy lub innego elementu <xref:System.Windows.ResourceDictionary>.  
  
 Zwróć uwagę, że [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] składni pokazano nie zawiera elementu dla <xref:System.Windows.ResourceDictionary>. Jest to przykład składni niejawnej kolekcji; Znacznik reprezentujący element kolekcji można pominąć. Zamiast tego określono elementy, które są dodawane jako elementy w kolekcji. Aby uzyskać więcej informacji o kolekcjach niejawne i [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], zobacz [szczegółów w składni języka XAML](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md). Jeden przypadek gdzie <xref:System.Windows.ResourceDictionary> nadal jawnie określono, ponieważ element jest Jeśli udostępniono połączony słownik, w takim przypadku nie są zwykle żadnych elementów podrzędnych w tym <xref:System.Windows.ResourceDictionary>. Aby uzyskać więcej informacji, zobacz [scalić słowniki zasobów](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *oneOrMoreResourceElements*  
 Co najmniej jeden obiekt elementów, z których każdy definiuje zasób. Każdy element właściwości zasobów w ramach każdej <xref:System.Windows.ResourceDictionary> musi mieć unikatową wartość [dyrektywy x: Key](~/docs/framework/xaml-services/x-key-directive.md), która służy jako unikatowy klucz, gdy są one pobierane <xref:System.Windows.ResourceDictionary>.  
  
   
  
## Examples  
 Poniższy przykład ustanawia <xref:System.Windows.FrameworkContentElement.Resources%2A> kolekcji na <xref:System.Windows.Documents.FlowDocument> elementu głównego. <xref:System.Windows.Documents.FlowDocument> jest wybór typowe, ponieważ jest jednym z kilku <xref:System.Windows.FrameworkContentElement> klasy, które warto jako element główny i zasoby zwykle są przechowywane w katalogu głównym strony lub na przykład w aplikacji nawet wyższy poziomach.  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza powiązanie z tym elementem dla właściwości zależności określony.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">Identyfikuje właściwość powiązania.</param>
        <param name="path">Nazwa właściwości źródła lub ścieżka do właściwości używane dla wiązania.</param>
        <summary>Dołącza powiązanie do tego elementu, na podstawie podanego źródła właściwości nazwy jako kwalifikacji ścieżki do źródła danych.</summary>
        <returns>Rejestruje warunków powiązania. Zwrócona wartość może być przydatne do kontroli błędów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest metodą wygody wywoływania <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, która przechodzi bieżącego wystąpienia jako <xref:System.Windows.DependencyObject>i tworzy nowy <xref:System.Windows.Data.Binding> na podstawie udostępnionych `path` parametru. Podpis jest wygodniejsze podczas ustanawiania domyślne proste powiązania. Jeśli trzeba określić żadnych właściwości powiązania do warunków innych niż domyślne lub chcesz użyć <xref:System.Windows.Data.MultiBinding> lub <xref:System.Windows.Data.PriorityBinding>, należy użyć <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> podpisu.  
  
   
  
## Examples  
 Poniższy przykład przedstawia powiązanie na <xref:System.Windows.Documents.Paragraph> elementu, tworząc nowy obiekt danych niestandardowych ustanawianie obiektu jako <xref:System.Windows.FrameworkContentElement.DataContext%2A>i ustawianie ścieżki powiązania z właściwością w niej.  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkContentElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">Identyfikuje właściwość powiązania.</param>
        <param name="binding">Reprezentuje powiązanie danych.</param>
        <summary>Dołącza powiązanie do tego elementu, oparte na obiekt podana powiązania.</summary>
        <returns>Rejestruje warunków powiązania. Zwrócona wartość może być przydatne do kontroli błędów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest metodą wygody wywoływania <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, która przechodzi bieżącego wystąpienia jako <xref:System.Windows.DependencyObject>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia powiązanie na <xref:System.Windows.Documents.Paragraph> elementu, tworząc nowe <xref:System.Windows.Data.Binding> i Ustawianie źródła do nowo zbudowany `DateTime` obiektu.  
  
 [!code-csharp[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#setbinding)]
 [!code-vb[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#setbinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkContentElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Właściwość, z którym powiązany jest zasobu.</param>
        <param name="name">Nazwa zasobu.</param>
        <summary>Wyszukuje zasób o określonej nazwie i konfiguruje zasobów odwołanie do niej dla określonej właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Odwołanie do zasobu jest podobny do stosowania [DynamicResource — rozszerzenie znaczników](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) w znaczniku. Odwołanie do zasobu tworzy wyrażenie wewnętrznego, które dostarcza wartość określonej właściwości na podstawie odroczonego czasu wykonywania. Wyrażenie będą ponownie oceniane po każdym słownika zasobów wskazuje zmienione za pośrednictwem wewnętrznego zdarzenia lub gdy pokrewnym bieżącego elementu (Zmiana nadrzędnej zmieniłby słownika ścieżki wyszukiwania).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy procesy serializacji powinny serializować zawartości <see cref="P:System.Windows.FrameworkContentElement.Resources" /> właściwości wystąpienia tej klasy.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="P:System.Windows.FrameworkContentElement.Resources" /> wartość właściwości powinny być serializowane; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spowoduje to zwrócenie `true` tak długo, jak istnieje co najmniej jeden zasób z kluczem w lokalnej <xref:System.Windows.FrameworkContentElement.Resources%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy procesy serializacji powinny serializować zawartości <see cref="P:System.Windows.FrameworkContentElement.Style" /> właściwości wystąpienia tej klasy.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="P:System.Windows.FrameworkContentElement.Style" /> wartość właściwości powinny być serializowane; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spowoduje to zwrócenie `true` Jeśli <xref:System.Windows.Style> lokalnie jest ustawiona.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy dowolne skojarzone źródło danych uczestniczącej w powiązaniu na zmiany tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powierzchnie tego zdarzenia <xref:System.Windows.Data.Binding.SourceUpdated> zdarzenie, które jest wywoływane przez żadną <xref:System.Windows.Data.Binding> skojarzony z tym elementem.  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object SourceUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia styl, który ma być używany przez ten element.</summary>
        <value>Styl niestandardowy zastosowane, dla elementu, jeśli jest obecny. w przeciwnym razie <see langword="null" />. Wartością domyślną skonstruowany domyślne <see cref="T:System.Windows.FrameworkContentElement" /> jest <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący styl często są udostępniane przez domyślny styl z motywów lub style zazwyczaj stosowane do obiektów tego typu przez zasobów na poziomie strony lub aplikacji (styl niejawne). Ta właściwość jest nie ustawiona lub jest zwracany domyślny styl (motywu), ale zwrócony niejawne stylu lub jawna. W przypadku bezpośredniego lub pośredniego style nie ma znaczenia, czy styl jest dostępne jako zasób zdefiniowany lokalnie.  
  
 Ustawianie stylów ma pewne ograniczenia. Możesz przywrócić cały <xref:System.Windows.FrameworkContentElement.Style%2A> właściwości na nowy <xref:System.Windows.Style> w dowolnym momencie, która wymusi recomposition układu. Jednak niezwłocznie po stylu jest umieszczona używany przez element załadować <xref:System.Windows.Style> należy traktować jako sealed. Podjęto próbę dokonania zmiany do żadnej poszczególnych właściwości stylu w użyciu (np. wszystkich elementów w kolekcji <xref:System.Windows.Style.Setters%2A>) powoduje, że wyjątek zostanie wygenerowany. Styl, który jest zdefiniowany w znaczniku jest uznawany za będzie używana natychmiast po załadowaniu go ze słownika zasobów (dla zasobów) lub załadowanej strony, który jest zawarty w (dla style wbudowane).  
  
 <xref:System.Windows.FrameworkContentElement.Style%2A> jest to właściwość zależności o priorytecie specjalnych. Lokalnie ustawiony styl zazwyczaj operuje na najwyższy priorytet w systemie właściwości. Jeśli <xref:System.Windows.FrameworkContentElement.Style%2A> ma wartość null w tym momencie podczas ładowania właściwości system sprawdza, czy style niejawne jako zdefiniowanych zasoby, które określają tego typu. Jeżeli styl jest nadal null po wykonaniu tego kroku, a następnie styl pochodzi z styl domyślny (motywu), ale domyślnym stylu nie są zwracane w <xref:System.Windows.FrameworkContentElement.Style%2A> wartości właściwości. Zobacz [pierwszeństwo wartość właściwości zależności](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object Style="{resourceExtension StyleResourceKey}"/>  
```  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *resourceExtension*  
 Jedną z następujących:, lub. Zobacz [zasobów XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Klucz identyfikujący styl żądanej. Klucz odnosi się do istniejącego zasobu w <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Składni elementu właściwości jest technicznie możliwe, ale nie jest zalecane. Zobacz [style wbudowane i szablony](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).  Odwołanie do wiązania za pomocą lub <xref:System.Windows.Data.Binding> jest także możliwe, ale rzadko.  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.StyleProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 Poniższy przykład ustanawia <xref:System.Windows.FrameworkContentElement.Resources%2A> kolekcji na <xref:System.Windows.Documents.FlowDocument> elementu głównego, a następnie odwołuje się jako zasób jako styl określonych dla <xref:System.Windows.Documents.Paragraph>.  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.Style" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nazwa żądanej właściwości otoczenia.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> metody.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="propertyName" /> są dostępne, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Windows.FrameworkContentElement> wystąpienia jest rzutowane na <xref:System.Windows.Markup.IQueryAmbient> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkContentElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość dowolnego obiektu, który może służyć do przechowywania informacji niestandardowych o tym elemencie.</summary>
        <value>Wartość docelowa. Ta właściwość nie ma wartości domyślnej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest odpowiednikiem właściwości znacznika w modelach programowania inne firmy Microsoft, takich jak Visual Basic for Applications lub formularze systemu Windows. Jest on przeznaczony do istniejącego miejsca do przechowywania kilku podstawowych informacji niestandardowych o dowolnym elemencie bez wymuszania deweloperzy aplikacji do podklasy.  
  
<a name="xamlValues_Tag"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 Ponieważ ta właściwość ma obiekt, należy użyć użycie elementu właściwości, aby ustawić <xref:System.Windows.FrameworkContentElement.Tag%2A> właściwości w języku XAML na inny niż obiekt, za pomocą konwertera typu znane i wbudowane, takiego jak ciąg. Obiekty używane w ten sposób nie są zwykle w ramach standardowego przestrzenie nazw WPF i w związku z tym mogą wymagać mapowania przestrzeni nazw do zewnętrznego przestrzeni nazw, aby wprowadzić jako elementów XAML.  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.TagProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.Tag" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy dowolnej skojarzonej właściwości docelowej uczestniczącej w powiązaniu zmian tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powierzchnie tego zdarzenia <xref:System.Windows.Data.Binding.TargetUpdated> zdarzenie, które jest wywoływane przez żadną <xref:System.Windows.Data.Binding> skojarzony z tym elementem. Zwykle oznacza to, że powiązanie zagrożona jest powiązanie dwukierunkowe i potwierdza, że właściwości zależności powiązane unieważniania poprzedniej wartości właściwości dla dowolnego sprawdzania poprawności lub schemat buforowania, że właściwość obsługuje.  
  
 Argumenty zdarzeń tego zdarzenia informuje, które powiązane właściwości zostało zmienione.  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object TargetUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do szablonu elementu nadrzędnego tego elementu. Ta właściwość nie jest ważna, jeśli element nie został utworzony za pomocą szablonu.</summary>
        <value>Element których <see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> spowodował ten element ma zostać utworzony. Ta wartość jest często <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Szablony są faktycznie udostępnionych obiektów, których zawartość szablonu są tworzone tylko raz. W związku z tym po uzyskaniu odwołania do obiektu do elementu, który pochodzi z szablonu, może się okazać, że jawnego drzewa logicznego nie dotrze do strony głównej. Aby można było połączyć szablonu odniesienie do drzewa logicznego strony, należy pobrać <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> wartości i kontynuować tree elementu zgodnie z potrzebami.  
  
 <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> często będą `null` dla wspólnych obiektów, ponieważ Jeśli uzyskasz spoza stroną odwołanie do obiektu w aplikacji w typowy sposób, że element prawdopodobnie nie utworzono z szablonu. Przypadków, gdy <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> może nie być `null` obejmują operacje takie jak zdarzenia testowania trafień obsługi dla niektórych niskiego poziomu zdarzenia wejściowe lub Praca z wyliczenia, które mogą zwrócone elementy, które nadeszły z szablonów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkContentElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt etykietki narzędzia, która jest wyświetlana dla tego elementu w [! INCLUDE[TLA#tla_ui](~/includes/tlasharptla-UI-MD.MD)].</summary>
        <value>Obiekt etykietki narzędzia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość tej właściwości jest typu <xref:System.Windows.Controls.ToolTip>, następnie jest etykietka narzędzia używanego w [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].  Jeśli wartość jest innego typu, a następnie ta wartość będzie służyć jako *zawartości* dla <xref:System.Windows.Controls.ToolTip> podane (skonstruowany) przez system. Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Controls.ToolTipService>. Klasa usługi zawiera dołączone właściwości, które można dostosować etykietka narzędzia.  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *toolTipContent*  
 Ciąg, który będzie wyświetlany tekst <xref:System.Windows.FrameworkContentElement.ToolTip%2A>.  
  
 *toolTipObjectContent*  
 Niektórych obiektów w formularzu elementu obiektów, które mają być używane jako zawartość dla <xref:System.Windows.FrameworkContentElement> . Zazwyczaj powinien to być <xref:System.Windows.FrameworkElement> lub innego elementu tworzy składania układu dla <xref:System.Windows.FrameworkContentElement.ToolTip%2A>, po pewnym czasie zawierające tekst w obrębie składania. W ten sposób użycia <xref:System.Windows.Controls.ToolTip> utworzyć elementu niejawnie z przeanalizowany [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]i *toolTipObjectContent* zawartości jest ustawiony jako jego <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> właściwości.  
  
 <`ToolTip` .../>  
 Zobacz <xref:System.Windows.Controls.ToolTip>.  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.ToolTipProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 W poniższym przykładzie ustawiono wartość <xref:System.Windows.FrameworkElement.ToolTip%2A> właściwości bezpośrednio na ciąg.  
  
 [!code-csharp[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/csharp/VS_Snippets_Wpf/TableSnippets2/CSharp/Window1.xaml.cs#_table_rowgroups_maniprows)]
 [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TableSnippets2/visualbasic/window1.xaml.vb#_table_rowgroups_maniprows)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje zaraz przed zamknięciem dowolnej etykietki narzędzia w elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby pominąć zamknięcia etykietka narzędzia, obsługi zdarzenia należy oznaczyć go jako obsługi.  
  
 To zdarzenie nie może być <xref:System.Windows.EventTrigger> w stylu. Jest to spowodowane pola Identyfikator zdarzenia wykorzystuje ponownie implementacja z usługą, która nie ujawnia metody dodawania/usuwania na zdarzenia.  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|  
|Strategii routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [kierowane Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekty identyfikator zdarzenia są tworzone podczas kierowane zdarzenia są rejestrowane (zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>), a następnie można dodać obsługę klas (zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Identyfikator obiekty zawierają nazwę identyfikującą, typ właściciela typ obsługi, strategii routingu i metodę narzędzia na potrzeby dodawania właścicieli dla zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po otwarciu dowolnej etykietki narzędzia w elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można ręcznie otworzyć etykietki narzędzi, programy obsługi zdarzeń należy oznaczyć dane zdarzenie jako obsłużone. W przeciwnym razie wartość <xref:System.Windows.FrameworkContentElement.ToolTip%2A> właściwości będzie można użyć do automatycznego otwierania menu kontekstowego. Oznaczenie zdarzenia obsługiwane skutecznie spowoduje anulowanie domyślne działanie i może być możliwość resetowania wartości <xref:System.Windows.FrameworkContentElement.ToolTip%2A> właściwości, a następnie otwórz nową <xref:System.Windows.Controls.ContextMenu>. Należy pamiętać, że to zdarzenie nie będą zgłaszane Jeśli <xref:System.Windows.FrameworkContentElement.ToolTip%2A> jest odwołanie o wartości null lub w inny sposób nie ustawiono.  
  
 To zdarzenie nie może być <xref:System.Windows.EventTrigger> w stylu. Jest to spowodowane pola Identyfikator zdarzenia wykorzystuje ponownie implementacja z usługą, która nie ujawnia metody dodawania/usuwania na zdarzenia.  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|  
|Strategii routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [kierowane Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekty identyfikator zdarzenia są tworzone podczas kierowane zdarzenia są rejestrowane (zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>), a następnie można dodać obsługę klas (zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Identyfikator obiekty zawierają nazwę identyfikującą, typ właściciela typ obsługi, strategii routingu i metodę narzędzia na potrzeby dodawania właścicieli dla zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkContentElement.ToolTip" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkContentElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Identyfikator klucza zasobu, który ma zostać odnaleziona.</param>
        <summary>Wyszukuje zasób z określonym kluczem, a zwraca tego zasobu, jeśli znaleziono.</summary>
        <returns>Znaleziono zasobu. Jeśli nie znaleziono zasobu, <see langword="null" /> jest zwracany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zasób nie zostanie znaleziony w elemencie wywołującym, drzewa nadrzędnego jest przeszukiwana przy użyciu drzewa logicznego w taki sam sposób jak drzewo będzie przeszukiwana, jeśli odwołaniem zasobu dynamicznego prosili klucza w czasie wykonywania.  
  
 Zwykle będzie natychmiast rzutowania wartości zwracanej typu właściwości, którą próbujesz ustawić o wartości zwracane zasobów.  
  
 <xref:System.Windows.FrameworkContentElement.FindResource%2A> Metody zachowanie jest podobne, z tą różnicą, że spowoduje zgłoszenie wyjątku w przypadku nie możesz znaleźć zasobu z podanego klucza.  
  
   
  
## Examples  
 Poniższy przykład umożliwia znalezienie zasobów zgodnie z definicją w znaczniku i stosuje je do niektórych właściwości elementu w odpowiedzi na kierowanego zdarzenia.  
  
 [!code-csharp[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#tryfindresource)]
 [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#tryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy element zostanie usunięty z drzewa elementów załadowanych elementów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezpośrednie kierowane zdarzenia nie wykonuj trasy, są obsługiwane tylko w obrębie tego samego elementu, na którym jest uruchamiany. Bezpośrednie kierowane zdarzenia obsługuje inne zachowanie kierowanego zdarzenia: obsługują dostępny obsługi kolekcji i mogą być używane jako <xref:System.Windows.EventTrigger> w stylu.  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkContentElement.UnloadedEvent>|  
|Strategii routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [kierowane Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekty identyfikator zdarzenia są tworzone podczas kierowane zdarzenia są rejestrowane (zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>), a następnie można dodać obsługę klas (zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Identyfikator obiekty zawierają nazwę identyfikującą, typ właściciela typ obsługi, strategii routingu i metodę narzędzia na potrzeby dodawania właścicieli dla zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkContentElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa pary nazwa obiektu do usunięcia z bieżącego zakresu.</param>
        <summary>Ułatwiają dostęp do <see cref="T:System.Windows.NameScope" /> rejestracji do metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystarczy wyrejestrować nazwy Jeśli chcesz ponownie zarejestrować inny element o takiej samej nazwie.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkContentElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przywrócenie styl domyślny do bieżącego <see cref="T:System.Windows.FrameworkContentElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="FrameworkContentElement" FullName="System.Windows.FrameworkContentElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="795f404ff87bbd28008ec94119903b543f07513e" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69444658" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkContentElement&#xA;Inherits ContentElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkContentElement : System::Windows::ContentElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkContentElement = class&#xA;    inherit ContentElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.ContentElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="da2da-101"><see cref="T:System.Windows.FrameworkContentElement" />jest implementacją na poziomie platformy WPF i rozszerzeniem <see cref="T:System.Windows.ContentElement" /> klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="da2da-101"><see cref="T:System.Windows.FrameworkContentElement" /> is the WPF framework-level implementation and expansion of the <see cref="T:System.Windows.ContentElement" /> base class.</span></span> <span data-ttu-id="da2da-102"><see cref="T:System.Windows.FrameworkContentElement" />dodaje obsługę dodatkowych wejściowych interfejsów API (w tym etykietek narzędzi i menu kontekstowych), scenorysów, kontekstu danych dla powiązania danych, obsługi stylów i interfejsów API pomocnika drzewa logicznego.</span><span class="sxs-lookup"><span data-stu-id="da2da-102"><see cref="T:System.Windows.FrameworkContentElement" /> adds support for additional input APIs (including tooltips and context menus), storyboards, data context for data binding, styles support, and logical tree helper APIs.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-103"><xref:System.Windows.FrameworkContentElement>nie definiuje jeszcze własnych zachowań renderowania; utworzenie wystąpienia rzeczywistego <xref:System.Windows.FrameworkContentElement> wystąpienia klasy w kodzie lub znacznik jest możliwe, ale [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] w aplikacji [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]nie są wyświetlane żadne elementy.</span><span class="sxs-lookup"><span data-stu-id="da2da-103"><xref:System.Windows.FrameworkContentElement> does not yet define its own rendering behavior; instantiating an actual <xref:System.Windows.FrameworkContentElement> class instance in code or markup is possible but displays nothing in a [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] application [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="da2da-104">Logika renderowania musi być dostarczana przez klasy <xref:System.Windows.FrameworkContentElement> , które mają elementy podrzędne jako część modelu zawartości <xref:System.Windows.FrameworkContentElement> lub klasy pochodne.</span><span class="sxs-lookup"><span data-stu-id="da2da-104">Rendering logic must be provided by classes that take <xref:System.Windows.FrameworkContentElement> child elements as part of their content model, or in <xref:System.Windows.FrameworkContentElement> derived classes.</span></span>  
  
 <span data-ttu-id="da2da-105"><xref:System.Windows.FrameworkContentElement>celowo Parallels wiele z tych samych [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] jako <xref:System.Windows.FrameworkElement>.</span><span class="sxs-lookup"><span data-stu-id="da2da-105"><xref:System.Windows.FrameworkContentElement> deliberately parallels many of the same [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] as <xref:System.Windows.FrameworkElement>.</span></span> <span data-ttu-id="da2da-106">Należy zauważyć, [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] że niektóre <xref:System.Windows.FrameworkElement> znalezione na nie będą <xref:System.Windows.FrameworkContentElement> miały odpowiednika.</span><span class="sxs-lookup"><span data-stu-id="da2da-106">Note that certain [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] found on <xref:System.Windows.FrameworkElement> will not have a <xref:System.Windows.FrameworkContentElement> equivalent.</span></span> <span data-ttu-id="da2da-107">Niektóre z <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] nich są przeznaczone do funkcji, takich jak reprezentacja geometryczna lub układ, które nie <xref:System.Windows.FrameworkContentElement>są istotne dla.</span><span class="sxs-lookup"><span data-stu-id="da2da-107">Several of the <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] are for functionality such as geometry representation or layout, which are not relevant for a <xref:System.Windows.FrameworkContentElement>.</span></span>  
  
 <span data-ttu-id="da2da-108">Większość istniejących <xref:System.Windows.FrameworkContentElement> klas pochodnych zostanie znalezionych <xref:System.Windows.Documents> w przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="da2da-108">The majority of existing <xref:System.Windows.FrameworkContentElement> derived classes will be found in the <xref:System.Windows.Documents> namespace.</span></span> <span data-ttu-id="da2da-109">Wiele z tych klas pochodnych implementuje elementy dla modelu dokumentu przepływu.</span><span class="sxs-lookup"><span data-stu-id="da2da-109">Many of these derived classes implement elements for the flow document model.</span></span> <span data-ttu-id="da2da-110">Niektóre klasy pochodne, takie <xref:System.Windows.Documents.Hyperlink> jak posiadają pewne funkcje podobne do kontroli, ale pochodzą od <xref:System.Windows.FrameworkContentElement> takich elementów, które mogą nadal uczestniczyć w modelu dokumentu przepływu.</span><span class="sxs-lookup"><span data-stu-id="da2da-110">Certain derived classes such as <xref:System.Windows.Documents.Hyperlink> have some control-like functionality, but are derived from <xref:System.Windows.FrameworkContentElement> such that the control-like elements can still participate in the flow document model.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.FrameworkElement" />
    <altmember cref="T:System.Windows.ContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="da2da-111">Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkContentElement" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="da2da-111">Initializes a new instance of the <see cref="T:System.Windows.FrameworkContentElement" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child"><span data-ttu-id="da2da-112">Element podrzędny, który ma zostać dodany.</span><span class="sxs-lookup"><span data-stu-id="da2da-112">The child element to be added.</span></span></param>
        <summary><span data-ttu-id="da2da-113">Dodaje podany element jako element podrzędny tego elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-113">Adds the provided element as a child of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-114">Ta metoda może zgłosić wyjątek, jeśli zostanie wywołana w czasie, gdy Drzewo logiczne zostanie powtórzone przez inny proces.</span><span class="sxs-lookup"><span data-stu-id="da2da-114">This method can throw an exception if called at a time when the logical tree is being iterated by another process.</span></span>  
  
 <span data-ttu-id="da2da-115">Większość <xref:System.Windows.FrameworkContentElement> klas pochodnych uwidacznia dedykowane kolekcje, które są odpowiedzialne za zawieranie ( <xref:System.Windows.Documents.Span.Inlines%2A> na przykład <xref:System.Windows.Documents.Span> w klasie; <xref:System.Windows.Documents.Section.Blocks%2A> na klasie).<xref:System.Windows.Documents.Section></span><span class="sxs-lookup"><span data-stu-id="da2da-115">Most <xref:System.Windows.FrameworkContentElement> derived classes expose dedicated collections that are responsible for containment (for example, <xref:System.Windows.Documents.Span.Inlines%2A> on the <xref:System.Windows.Documents.Span> class; <xref:System.Windows.Documents.Section.Blocks%2A> on the <xref:System.Windows.Documents.Section> class).</span></span> <span data-ttu-id="da2da-116">Zazwyczaj można uniknąć konieczności manipulowania drzewa logicznego bezpośrednio, jeśli pochodzą od tych klas.</span><span class="sxs-lookup"><span data-stu-id="da2da-116">You can typically avoid any need to manipulate the logical tree directly if you derive from these classes instead.</span></span> <span data-ttu-id="da2da-117">Praca z drzewem logicznym dla elementów zawartości jest zaawansowanym scenariuszem, który może wymagać wyspecjalizowanego analizatora lub wyspecjalizowanej <xref:System.Windows.FrameworkElement> , który działa jako element nadrzędny renderowania (host zawartości).</span><span class="sxs-lookup"><span data-stu-id="da2da-117">Working with the logical tree for content elements is an advanced scenario that may require a specialized parser or a specialized <xref:System.Windows.FrameworkElement> that acts as the parent rendering element (content host).</span></span>  
  
 <span data-ttu-id="da2da-118">Aby uzyskać więcej informacji o sposobach <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> korzystania <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>z i, zobacz [drzewa w WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span><span class="sxs-lookup"><span data-stu-id="da2da-118">For more information about how to use <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> and <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, see [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkContentElement.LogicalChildren" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkContentElement.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="da2da-119">Wywoływana przed zainicjowaniem elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-119">Called before an element is initialized.</span></span></summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="da2da-120">Zastąp tę metodę, aby zapewnić specjalną obsługę, która powinna wystąpić przed zainicjowaniem elementu podczas procesu ładowania elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-120">Override this method to provide special handling that should occur before your element is initialized during the element loading process.</span></span>  
  
<span data-ttu-id="da2da-121">Implementacja powinna wywołać implementację podstawową, ponieważ implementacja podstawowa (domyślna) ustawia pewne flagi wewnętrzne, aby śledzić inicjalizację.</span><span class="sxs-lookup"><span data-stu-id="da2da-121">Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</span></span>  
  
<span data-ttu-id="da2da-122">Implementacja podstawowa zgłosi wyjątek, jeśli <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> jest wywoływana więcej niż jeden raz w tym samym elemencie przed osiągnięciem. <see cref="M:System.Windows.FrameworkContentElement.EndInit" /></span><span class="sxs-lookup"><span data-stu-id="da2da-122">The base implementation will throw an exception if <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> is called more than one time on the same element prior to reaching <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</span></span></para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="da2da-123">Rozpoczyna sekwencję akcji, które są zawarte w podanym scenorysie.</span><span class="sxs-lookup"><span data-stu-id="da2da-123">Begins the sequence of actions that are contained in the provided storyboard.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkContentElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard"><span data-ttu-id="da2da-124">Seria ujęć do rozpoczęcia.</span><span class="sxs-lookup"><span data-stu-id="da2da-124">The storyboard to begin.</span></span></param>
        <summary><span data-ttu-id="da2da-125">Rozpoczyna sekwencję akcji, które są zawarte w podanym scenorysie.</span><span class="sxs-lookup"><span data-stu-id="da2da-125">Begins the sequence of actions that are contained in the provided storyboard.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-126">W przypadku podpisów, które nie używają `isControllable`parametru, lub gdy ten parametr jest określony `false`, zegary osi czasu skojarzone z animacją są usuwane zaraz po osiągnięciu okresu "Fill".</span><span class="sxs-lookup"><span data-stu-id="da2da-126">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="da2da-127">W związku z tym nie można uruchomić ponownie animacji po uruchomieniu.</span><span class="sxs-lookup"><span data-stu-id="da2da-127">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="da2da-128">Należy zauważyć, że kontrolowanie animacji wymaga również, aby scenorys miał nazwę lub dostępną jako wystąpienie w kodzie.</span><span class="sxs-lookup"><span data-stu-id="da2da-128">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard"><span data-ttu-id="da2da-129">Seria ujęć do rozpoczęcia.</span><span class="sxs-lookup"><span data-stu-id="da2da-129">The storyboard to begin.</span></span></param>
        <param name="handoffBehavior"><span data-ttu-id="da2da-130">Wartość wyliczenia opisująca zachowanie, jeśli właściwość opisana w scenorysie jest już animowana.</span><span class="sxs-lookup"><span data-stu-id="da2da-130">A value of the enumeration that describes behavior to use if a property described in the storyboard is already animated.</span></span></param>
        <summary><span data-ttu-id="da2da-131">Rozpoczyna sekwencję akcji, które są zawarte w podanym scenorysie, z opcjami określonymi dla tego, co powinno nastąpić, jeśli właściwość jest już animowana.</span><span class="sxs-lookup"><span data-stu-id="da2da-131">Begins the sequence of actions that are contained in the provided storyboard, with options specified for what should occur if the property is already animated.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-132">W przypadku podpisów, które nie używają `isControllable`parametru, lub gdy ten parametr jest określony `false`, zegary osi czasu skojarzone z animacją są usuwane zaraz po osiągnięciu okresu "Fill".</span><span class="sxs-lookup"><span data-stu-id="da2da-132">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="da2da-133">W związku z tym nie można uruchomić ponownie animacji po uruchomieniu.</span><span class="sxs-lookup"><span data-stu-id="da2da-133">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="da2da-134">Należy zauważyć, że kontrolowanie animacji wymaga również, aby scenorys miał nazwę lub dostępną jako wystąpienie w kodzie.</span><span class="sxs-lookup"><span data-stu-id="da2da-134">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
## <a name="using-the-compose-handoffbehavior"></a><span data-ttu-id="da2da-135">Korzystanie z Compose HandoffBehavior</span><span class="sxs-lookup"><span data-stu-id="da2da-135">Using the Compose HandoffBehavior</span></span>  
 <span data-ttu-id="da2da-136">Po <xref:System.Windows.Media.Animation.Storyboard>zastosowaniu <xref:System.Windows.Media.Animation.Clock> , <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> do właściwości przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, wszystkie obiekty wcześniej skojarzone z tą właściwością nadal zużywają zasoby systemowe; system chronometrażu wykonuje nie usuwaj automatycznie zegarów.</span><span class="sxs-lookup"><span data-stu-id="da2da-136">When you apply a <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, or <xref:System.Windows.Media.Animation.AnimationClock> to a property by using the <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> objects previously associated with that property continue to consume system resources; the timing system does not remove the clocks automatically.</span></span>  
  
 <span data-ttu-id="da2da-137">Aby uniknąć problemów z wydajnością w przypadku stosowania dużej liczby zegarów przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>programu, należy usunąć z właściwości animowane zegary, po ich zakończeniu.</span><span class="sxs-lookup"><span data-stu-id="da2da-137">To avoid performance issues when you apply a large number of clocks by using <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, you should remove composing clocks from the animated property after they complete.</span></span> <span data-ttu-id="da2da-138">Istnieje kilka sposobów usunięcia zegara:</span><span class="sxs-lookup"><span data-stu-id="da2da-138">There are several ways to remove a clock:</span></span>  
  
-   <span data-ttu-id="da2da-139">Aby usunąć wszystkie zegary z właściwości, użyj <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metody animowanego obiektu.</span><span class="sxs-lookup"><span data-stu-id="da2da-139">To remove all clocks from a property, use the <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> or <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> method of the animated object.</span></span> <span data-ttu-id="da2da-140">Określ animowaną właściwość jako pierwszy parametr, a `null` w drugim.</span><span class="sxs-lookup"><span data-stu-id="da2da-140">Specify the property being animated as the first parameter, and `null` as the second.</span></span> <span data-ttu-id="da2da-141">Spowoduje to usunięcie wszystkich zegarów animacji z właściwości.</span><span class="sxs-lookup"><span data-stu-id="da2da-141">This removes all animation clocks from the property.</span></span>  
  
-   <span data-ttu-id="da2da-142"><xref:System.Windows.Media.Animation.AnimationClock> Aby usunąć określony z listy zegarów, <xref:System.Windows.Media.Animation.Clock.Controller%2A> Użyj właściwości <xref:System.Windows.Media.Animation.AnimationClock> do pobrania <xref:System.Windows.Media.Animation.ClockController>a <xref:System.Windows.Media.Animation.ClockController>, a następnie Wywołaj <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="da2da-142">To remove a specific <xref:System.Windows.Media.Animation.AnimationClock> from a list of clocks, use the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of the <xref:System.Windows.Media.Animation.AnimationClock> to retrieve a <xref:System.Windows.Media.Animation.ClockController>, then call the <xref:System.Windows.Media.Animation.ClockController.Remove%2A> method of the <xref:System.Windows.Media.Animation.ClockController>.</span></span> <span data-ttu-id="da2da-143">Jest to zazwyczaj wykonywane w programie <xref:System.Windows.Media.Animation.Clock.Completed> obsługi zdarzeń zegara.</span><span class="sxs-lookup"><span data-stu-id="da2da-143">This is typically done in the <xref:System.Windows.Media.Animation.Clock.Completed> event handler for a clock.</span></span> <span data-ttu-id="da2da-144">Należy zauważyć, że tylko zegary główne mogą być sterowane <xref:System.Windows.Media.Animation.ClockController>przez <xref:System.Windows.Media.Animation.Clock.Controller%2A> ; Właściwość zegara podrzędnego zwraca `null`.</span><span class="sxs-lookup"><span data-stu-id="da2da-144">Note that only root clocks can be controlled by a <xref:System.Windows.Media.Animation.ClockController>; the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of a child clock returns `null`.</span></span> <span data-ttu-id="da2da-145">Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzenie nie zostanie zgłoszone, jeśli skuteczny czas trwania zegara jest nieograniczona.</span><span class="sxs-lookup"><span data-stu-id="da2da-145">Note also that the <xref:System.Windows.Media.Animation.Clock.Completed> event is not raised if the effective duration of the clock is forever.</span></span>  <span data-ttu-id="da2da-146">W takim przypadku użytkownik musi określić, kiedy ma być wywoływana <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span><span class="sxs-lookup"><span data-stu-id="da2da-146">In that case, the user must determine when to call <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span></span>  
  
 <span data-ttu-id="da2da-147">Jest to szczególnie problem w przypadku animacji na obiektach, które mają długi okres istnienia.</span><span class="sxs-lookup"><span data-stu-id="da2da-147">This is primarily an issue for animations on objects that have a long lifetime.</span></span>  <span data-ttu-id="da2da-148">Gdy obiekt jest odzyskiwany, jego zegary również są rozłączone i odzyskiwane.</span><span class="sxs-lookup"><span data-stu-id="da2da-148">When an object is garbage collected, its clocks are also disconnected and garbage collected.</span></span>  
  
 <span data-ttu-id="da2da-149">Aby uzyskać więcej informacji na temat obiektów zegara, zobacz [animacje i system chronometrażu — przegląd](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span><span class="sxs-lookup"><span data-stu-id="da2da-149">For more information about clock objects, see [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard"><span data-ttu-id="da2da-150">Seria ujęć do rozpoczęcia.</span><span class="sxs-lookup"><span data-stu-id="da2da-150">The storyboard to begin.</span></span></param>
        <param name="handoffBehavior"><span data-ttu-id="da2da-151">Wartość wyliczenia opisująca zachowanie, jeśli właściwość opisana w scenorysie jest już animowana.</span><span class="sxs-lookup"><span data-stu-id="da2da-151">A value of the enumeration that describes behavior to use if a  property described in the storyboard is already animated.</span></span></param>
        <param name="isControllable"><span data-ttu-id="da2da-152">Deklaruje, czy animacja jest sterowana (może zostać wstrzymana) po jej uruchomieniu.</span><span class="sxs-lookup"><span data-stu-id="da2da-152">Declares whether the animation is controllable (can be paused) after it is started.</span></span></param>
        <summary><span data-ttu-id="da2da-153">Rozpoczyna sekwencję akcji, które są zawarte w podanym scenorysie, z określonym stanem kontroli animacji po jej uruchomieniu.</span><span class="sxs-lookup"><span data-stu-id="da2da-153">Begins the sequence of actions that are contained in the provided storyboard, with specified state for control of the animation after it is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-154">W przypadku podpisów, które nie używają `isControllable`parametru, lub gdy ten parametr jest określony `false`, zegary osi czasu skojarzone z animacją są usuwane zaraz po osiągnięciu okresu "Fill".</span><span class="sxs-lookup"><span data-stu-id="da2da-154">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="da2da-155">W związku z tym nie można uruchomić ponownie animacji po uruchomieniu.</span><span class="sxs-lookup"><span data-stu-id="da2da-155">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="da2da-156">Należy zauważyć, że kontrolowanie animacji wymaga również, aby scenorys miał nazwę lub dostępną jako wystąpienie w kodzie.</span><span class="sxs-lookup"><span data-stu-id="da2da-156">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
## <a name="using-the-compose-handoffbehavior"></a><span data-ttu-id="da2da-157">Korzystanie z Compose HandoffBehavior</span><span class="sxs-lookup"><span data-stu-id="da2da-157">Using the Compose HandoffBehavior</span></span>  
 <span data-ttu-id="da2da-158">Po <xref:System.Windows.Media.Animation.Storyboard>zastosowaniu <xref:System.Windows.Media.Animation.Clock> , <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> do właściwości przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, wszystkie obiekty wcześniej skojarzone z tą właściwością nadal zużywają zasoby systemowe; system chronometrażu wykonuje nie usuwaj automatycznie tych zegarów.</span><span class="sxs-lookup"><span data-stu-id="da2da-158">When you apply a <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, or <xref:System.Windows.Media.Animation.AnimationClock> to a property by using the <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> objects previously associated with that property continue to consume system resources; the timing system does not remove these clocks automatically.</span></span>  
  
 <span data-ttu-id="da2da-159">Aby uniknąć problemów z wydajnością w przypadku stosowania dużej liczby zegarów przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>programu, należy usunąć z właściwości animowane zegary, po ich zakończeniu.</span><span class="sxs-lookup"><span data-stu-id="da2da-159">To avoid performance issues when you apply a large number of clocks by using <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, you should remove composing clocks from the animated property after they complete.</span></span> <span data-ttu-id="da2da-160">Istnieje kilka sposobów usunięcia zegara:</span><span class="sxs-lookup"><span data-stu-id="da2da-160">There are several ways to remove a clock:</span></span>  
  
-   <span data-ttu-id="da2da-161">Aby usunąć wszystkie zegary z właściwości, użyj <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metody animowanego obiektu.</span><span class="sxs-lookup"><span data-stu-id="da2da-161">To remove all clocks from a property, use the <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> or <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> method of the animated object.</span></span> <span data-ttu-id="da2da-162">Określ animowaną właściwość jako pierwszy parametr, a `null` w drugim.</span><span class="sxs-lookup"><span data-stu-id="da2da-162">Specify the property being animated as the first parameter, and `null` as the second.</span></span> <span data-ttu-id="da2da-163">Spowoduje to usunięcie wszystkich zegarów animacji z właściwości.</span><span class="sxs-lookup"><span data-stu-id="da2da-163">This removes all animation clocks from the property.</span></span>  
  
-   <span data-ttu-id="da2da-164"><xref:System.Windows.Media.Animation.AnimationClock> Aby usunąć określony z listy zegarów, <xref:System.Windows.Media.Animation.Clock.Controller%2A> Użyj właściwości <xref:System.Windows.Media.Animation.AnimationClock> do pobrania <xref:System.Windows.Media.Animation.ClockController>a <xref:System.Windows.Media.Animation.ClockController>, a następnie Wywołaj <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="da2da-164">To remove a specific <xref:System.Windows.Media.Animation.AnimationClock> from a list of clocks, use the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of the <xref:System.Windows.Media.Animation.AnimationClock> to retrieve a <xref:System.Windows.Media.Animation.ClockController>, then call the <xref:System.Windows.Media.Animation.ClockController.Remove%2A> method of the <xref:System.Windows.Media.Animation.ClockController>.</span></span> <span data-ttu-id="da2da-165">Jest to zazwyczaj wykonywane w programie <xref:System.Windows.Media.Animation.Clock.Completed> obsługi zdarzeń zegara.</span><span class="sxs-lookup"><span data-stu-id="da2da-165">This is typically done in the <xref:System.Windows.Media.Animation.Clock.Completed> event handler for a clock.</span></span> <span data-ttu-id="da2da-166">Należy zauważyć, że tylko zegary główne mogą być sterowane <xref:System.Windows.Media.Animation.ClockController>przez <xref:System.Windows.Media.Animation.Clock.Controller%2A> ; Właściwość zegara podrzędnego zwraca `null`.</span><span class="sxs-lookup"><span data-stu-id="da2da-166">Note that only root clocks can be controlled by a <xref:System.Windows.Media.Animation.ClockController>; the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of a child clock returns `null`.</span></span> <span data-ttu-id="da2da-167">Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzenie nie zostanie zgłoszone, jeśli skuteczny czas trwania zegara jest nieograniczona.</span><span class="sxs-lookup"><span data-stu-id="da2da-167">Note also that the <xref:System.Windows.Media.Animation.Clock.Completed> event is not raised if the effective duration of the clock is forever.</span></span>  <span data-ttu-id="da2da-168">W takim przypadku użytkownik musi określić, kiedy ma być wywoływana <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span><span class="sxs-lookup"><span data-stu-id="da2da-168">In that case, the user must determine when to call <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span></span>  
  
 <span data-ttu-id="da2da-169">Jest to szczególnie problem w przypadku animacji na obiektach, które mają długi okres istnienia.</span><span class="sxs-lookup"><span data-stu-id="da2da-169">This is primarily an issue for animations on objects that have a long lifetime.</span></span>  <span data-ttu-id="da2da-170">Gdy obiekt jest odzyskiwany, jego zegary również są rozłączone i odzyskiwane.</span><span class="sxs-lookup"><span data-stu-id="da2da-170">When an object is garbage collected, its clocks are also disconnected and garbage collected.</span></span>  
  
 <span data-ttu-id="da2da-171">Aby uzyskać więcej informacji na temat obiektów zegara, zobacz [animacje i system chronometrażu — przegląd](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span><span class="sxs-lookup"><span data-stu-id="da2da-171">For more information about clock objects, see [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-172">Pobiera lub ustawia wartość <see cref="T:System.Windows.Data.BindingGroup" /> , która jest używana dla elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-172">Gets or sets the <see cref="T:System.Windows.Data.BindingGroup" /> that is used for the element.</span></span></summary>
        <value><span data-ttu-id="da2da-173"><see cref="T:System.Windows.Data.BindingGroup" /> Jest używany dla elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-173">The <see cref="T:System.Windows.Data.BindingGroup" /> that is used for the element.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-174"><xref:System.Windows.Data.BindingGroup> Można użyć do walidacji wartości wielu właściwości obiektu.</span><span class="sxs-lookup"><span data-stu-id="da2da-174">A <xref:System.Windows.Data.BindingGroup> can be used to validate the values of multiple properties of an object.</span></span> <span data-ttu-id="da2da-175">Załóżmy na przykład, że aplikacja poprosi użytkownika o wprowadzenie `Address`adresu, a następnie wypełnia obiekt typu, który zawiera właściwości `Street`, `City`, `ZipCode`i `Country`, z wartościami, które użytkownik określonych.</span><span class="sxs-lookup"><span data-stu-id="da2da-175">For example, suppose that an application prompts the user to enter an address and then populates an object of type `Address`, which has the properties `Street`, `City`, `ZipCode`, and `Country`, with the values that the user provided.</span></span> <span data-ttu-id="da2da-176">Aplikacja ma panel, który zawiera cztery <xref:System.Windows.Controls.TextBox> kontrolki, z których każdy jest powiązany z jednym z właściwości obiektu.</span><span class="sxs-lookup"><span data-stu-id="da2da-176">The application has a panel that contains four <xref:System.Windows.Controls.TextBox> controls, each of which is bound to one of the object's properties.</span></span> <span data-ttu-id="da2da-177">Aby sprawdzić poprawność <xref:System.Windows.Controls.ValidationRule> `Address` obiektu <xref:System.Windows.Data.BindingGroup> , można użyć elementu in a.</span><span class="sxs-lookup"><span data-stu-id="da2da-177">You can use a <xref:System.Windows.Controls.ValidationRule> in a <xref:System.Windows.Data.BindingGroup> to validate the `Address` object.</span></span> <span data-ttu-id="da2da-178">Na przykład, <xref:System.Windows.Controls.ValidationRule> można upewnić się, że kod pocztowy jest prawidłowy dla kraju/regionu adresu.</span><span class="sxs-lookup"><span data-stu-id="da2da-178">For example, the <xref:System.Windows.Controls.ValidationRule> can ensure that the zip code is valid for the country/region of the address.</span></span>  
  
 <span data-ttu-id="da2da-179">Elementy podrzędne dziedziczą <xref:System.Windows.Data.BindingGroup> elementy z elementów nadrzędnych, podobnie jak w przypadku każdej innej dziedziczonej właściwości.</span><span class="sxs-lookup"><span data-stu-id="da2da-179">Child elements inherit the <xref:System.Windows.Data.BindingGroup> from their parent elements, just as with any other inheritable property.</span></span>  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="da2da-180">Informacje dotyczące właściwości zależności</span><span class="sxs-lookup"><span data-stu-id="da2da-180">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="da2da-181">Pole identyfikatora</span><span class="sxs-lookup"><span data-stu-id="da2da-181">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|  
|<span data-ttu-id="da2da-182">Właściwości metadanych ustawione na`true`</span><span class="sxs-lookup"><span data-stu-id="da2da-182">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-183">Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /> zależności.</span><span class="sxs-lookup"><span data-stu-id="da2da-183">Identifies the <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkContentElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="da2da-184">Podejmuje próbę przełączenia tego elementu do widoku w obrębie dowolnego regionu przewijalnego, w którym jest zawarte.</span><span class="sxs-lookup"><span data-stu-id="da2da-184">Attempts to bring this element into view, within any scrollable regions it is contained within.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-185">Wywołując tę metodę, efektywnie wywołasz <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> każdy nadrzędny obszar przewijania, który zawiera element (element nadrzędny może być bardzo dobrze, a <xref:System.Windows.FrameworkElement>nie a <xref:System.Windows.FrameworkContentElement>).</span><span class="sxs-lookup"><span data-stu-id="da2da-185">By calling this method, you effectively will call <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> on any parent scrollable area that contains the element (the parent may very well be a <xref:System.Windows.FrameworkElement>, not a <xref:System.Windows.FrameworkContentElement>).</span></span> <span data-ttu-id="da2da-186">Jeśli ten element nie jest zawarty w przewijanym obszarze, zdarzenie jest nadal zgłaszane, ale nie będzie miało żadnego efektu.</span><span class="sxs-lookup"><span data-stu-id="da2da-186">If this element is not contained in a scrollable area, the event is still raised, but there will be no effect.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms752352(v=vs.90)"><span data-ttu-id="da2da-187">Instrukcje: Utwórz ScrollViewer</span><span class="sxs-lookup"><span data-stu-id="da2da-187">How to: Create a ScrollViewer</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-188">Pobiera lub ustawia element menu kontekstowego, który powinien być wyświetlany po zażądaniu menu [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] kontekstowego za pośrednictwem elementu w tym elemencie.</span><span class="sxs-lookup"><span data-stu-id="da2da-188">Gets or sets the context menu element that should appear whenever the context menu is requested via [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] from within this element.</span></span></summary>
        <value><span data-ttu-id="da2da-189">Menu kontekstowe używane przez ten element.</span><span class="sxs-lookup"><span data-stu-id="da2da-189">The context menu that this element uses.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="da2da-190">Informacje dotyczące właściwości zależności</span><span class="sxs-lookup"><span data-stu-id="da2da-190">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="da2da-191">Pole identyfikatora</span><span class="sxs-lookup"><span data-stu-id="da2da-191">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|  
|<span data-ttu-id="da2da-192">Właściwości metadanych ustawione na`true`</span><span class="sxs-lookup"><span data-stu-id="da2da-192">Metadata properties set to `true`</span></span>|<span data-ttu-id="da2da-193">Brak</span><span class="sxs-lookup"><span data-stu-id="da2da-193">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="da2da-194">Poniższy przykład umieszcza <xref:System.Windows.Controls.ContextMenu> <xref:System.Windows.Documents.Paragraph>w.</span><span class="sxs-lookup"><span data-stu-id="da2da-194">The following example places a <xref:System.Windows.Controls.ContextMenu> on a <xref:System.Windows.Documents.Paragraph>.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#contextmenu)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-195">Występuje tuż przed zamknięciem dowolnego menu kontekstowego elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-195">Occurs just before any context menu on the element is closed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-196">Aby pominąć menu kontekstowe zamykania, programy obsługi zdarzenia powinny oznaczyć je jako obsłużone.</span><span class="sxs-lookup"><span data-stu-id="da2da-196">To suppress closing context menus, handlers of the event should mark it as handled.</span></span>  
  
 <span data-ttu-id="da2da-197">Aby użyć tego zdarzenia jako <xref:System.Windows.EventTrigger> stylu, należy odwołać się do podstawowego identyfikatora zdarzenia usługi:</span><span class="sxs-lookup"><span data-stu-id="da2da-197">To use this event as an <xref:System.Windows.EventTrigger> in a style, you must reference the underlying service event identifier:</span></span>  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 <span data-ttu-id="da2da-198">(To użycie jest wymagane, ponieważ implementacja <xref:System.Windows.FrameworkContentElement> zdarzeń, która ujawnia podstawowe zdarzenie usługi, nie <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> mapuje prawidłowo identyfikatora do użycia w wyzwalaczach).</span><span class="sxs-lookup"><span data-stu-id="da2da-198">(This usage is required because the event implementation on <xref:System.Windows.FrameworkContentElement> that exposes the underlying service event does not correctly map the <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> identifier for use in triggers).</span></span>  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="da2da-199">Informacje dotyczące kierowanego zdarzenia</span><span class="sxs-lookup"><span data-stu-id="da2da-199">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="da2da-200">Pole identyfikatora</span><span class="sxs-lookup"><span data-stu-id="da2da-200">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|  
|<span data-ttu-id="da2da-201">Strategia routingu</span><span class="sxs-lookup"><span data-stu-id="da2da-201">Routing strategy</span></span>|<span data-ttu-id="da2da-202">Propagacja</span><span class="sxs-lookup"><span data-stu-id="da2da-202">Bubbling</span></span>|  
|<span data-ttu-id="da2da-203">Delegate</span><span class="sxs-lookup"><span data-stu-id="da2da-203">Delegate</span></span>|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
   
  
## Examples  
 <span data-ttu-id="da2da-204">W poniższym przykładzie jest implementowana procedura obsługi, która zmienia kursor w nazwany `DisplayArea` region (niepokazywany).</span><span class="sxs-lookup"><span data-stu-id="da2da-204">The following example implements a handler that changes the cursor over a named region `DisplayArea` (not shown).</span></span> <span data-ttu-id="da2da-205">Wskazówki <xref:System.Windows.UIElement> komentarzy do użycia, ale w rzeczywistości ten przykład jest identyczny, jeśli `DisplayArea` był <xref:System.Windows.FrameworkContentElement>.</span><span class="sxs-lookup"><span data-stu-id="da2da-205">The comment hints at a <xref:System.Windows.UIElement> usage, but in fact this sample would be identical if `DisplayArea` were a <xref:System.Windows.FrameworkContentElement>.</span></span>  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-206">Identyfikuje przegląd [zdarzeń kierowanych.](~/docs/framework/wpf/advanced/routed-events-overview.md) <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /></span><span class="sxs-lookup"><span data-stu-id="da2da-206">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-207">Obiekty identyfikatorów zdarzeń są tworzone po zarejestrowaniu zdarzeń kierowanych <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>(zobacz) i mogą być używane do dodawania programów obsługi klasy ( <xref:System.Windows.EventManager.RegisterClassHandler%2A>Zobacz).</span><span class="sxs-lookup"><span data-stu-id="da2da-207">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="da2da-208">Obiekty identyfikatorów zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu i metodę narzędzia do dodawania właścicieli dla zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="da2da-208">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-209">Występuje po otwarciu dowolnego menu kontekstowego elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-209">Occurs when any context menu on the element is opened.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-210">Aby ręcznie otworzyć menu kontekstowe, programy obsługi zdarzeń powinny oznaczyć odpowiednie zdarzenie jako obsłużone.</span><span class="sxs-lookup"><span data-stu-id="da2da-210">To manually open context menus, handlers of the events should mark the relevant event as handled.</span></span> <span data-ttu-id="da2da-211">W przeciwnym razie istniejąca wartość <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> właściwości zostanie użyta do automatycznego otwarcia menu kontekstowego.</span><span class="sxs-lookup"><span data-stu-id="da2da-211">Otherwise, the existing value of the <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> property will be used to automatically open a context menu.</span></span> <span data-ttu-id="da2da-212">Oznaczenie obsłużonego zdarzenia będzie efektywnie anulować akcję domyślną i może być możliwością zresetowania wartości <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> właściwości, a następnie otworzenia nowej. <xref:System.Windows.Controls.ContextMenu></span><span class="sxs-lookup"><span data-stu-id="da2da-212">Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> property and then open the new <xref:System.Windows.Controls.ContextMenu>.</span></span> <span data-ttu-id="da2da-213">Istnieje jednak problem z chronometrażem, którego należy wiedzieć.</span><span class="sxs-lookup"><span data-stu-id="da2da-213">However, there is a timing issue you should be aware of.</span></span> <span data-ttu-id="da2da-214">W celu całkowitego zastąpienia menu kontekstowego za pomocą <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> programu obsługi, początkowe menu kontekstowe nie może mieć wartości null ani być puste.</span><span class="sxs-lookup"><span data-stu-id="da2da-214">In order to completely replace the context menu through a <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> handler, the initial context menu must not be null / empty.</span></span> <span data-ttu-id="da2da-215">Alternatywnie może być konieczne obsłużenie zdarzenia, a następnie ręczne otwarcie nowego menu kontekstowego.</span><span class="sxs-lookup"><span data-stu-id="da2da-215">Alternatively, you might need to handle the event and then manually open a new context menu.</span></span> <span data-ttu-id="da2da-216">Aby uzyskać szczegółowe informacje [, zobacz How to: Obsłuż zdarzenie](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)ContextMenuOpening.</span><span class="sxs-lookup"><span data-stu-id="da2da-216">For details, see [How to: Handle the ContextMenuOpening Event](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).</span></span>  
  
 <span data-ttu-id="da2da-217">Aby użyć tego zdarzenia jako <xref:System.Windows.EventTrigger> stylu, należy odwołać się do podstawowego identyfikatora zdarzenia usługi:</span><span class="sxs-lookup"><span data-stu-id="da2da-217">To use this event as an <xref:System.Windows.EventTrigger> in a style, you must reference the underlying service event identifier:</span></span>  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 <span data-ttu-id="da2da-218">(To użycie jest wymagane, ponieważ implementacja <xref:System.Windows.FrameworkContentElement> zdarzeń, która ujawnia podstawowe zdarzenie usługi, nie <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> mapuje prawidłowo identyfikatora do użycia w wyzwalaczach).</span><span class="sxs-lookup"><span data-stu-id="da2da-218">(This usage is required because the event implementation on <xref:System.Windows.FrameworkContentElement> that exposes the underlying service event does not correctly map the <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> identifier for use in triggers).</span></span>  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="da2da-219">Informacje dotyczące kierowanego zdarzenia</span><span class="sxs-lookup"><span data-stu-id="da2da-219">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="da2da-220">Pole identyfikatora</span><span class="sxs-lookup"><span data-stu-id="da2da-220">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|  
|<span data-ttu-id="da2da-221">Strategia routingu</span><span class="sxs-lookup"><span data-stu-id="da2da-221">Routing strategy</span></span>|<span data-ttu-id="da2da-222">Propagacja</span><span class="sxs-lookup"><span data-stu-id="da2da-222">Bubbling</span></span>|  
|<span data-ttu-id="da2da-223">Delegate</span><span class="sxs-lookup"><span data-stu-id="da2da-223">Delegate</span></span>|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-224">Identyfikuje przegląd [zdarzeń kierowanych.](~/docs/framework/wpf/advanced/routed-events-overview.md) <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /></span><span class="sxs-lookup"><span data-stu-id="da2da-224">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-225">Obiekty identyfikatorów zdarzeń są tworzone po zarejestrowaniu zdarzeń kierowanych <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>(zobacz) i mogą być używane do dodawania programów obsługi klasy ( <xref:System.Windows.EventManager.RegisterClassHandler%2A>Zobacz).</span><span class="sxs-lookup"><span data-stu-id="da2da-225">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="da2da-226">Obiekty identyfikatorów zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu i metodę narzędzia do dodawania właścicieli dla zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="da2da-226">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-227">Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /> zależności.</span><span class="sxs-lookup"><span data-stu-id="da2da-227">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkContentElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-228">Pobiera lub ustawia kursor wyświetlany, gdy wskaźnik myszy znajduje się nad tym elementem.</span><span class="sxs-lookup"><span data-stu-id="da2da-228">Gets or sets the cursor that displays when the mouse pointer is over this element.</span></span></summary>
        <value><span data-ttu-id="da2da-229">Kursor, który ma zostać wyświetlony.</span><span class="sxs-lookup"><span data-stu-id="da2da-229">The cursor to display.</span></span> <span data-ttu-id="da2da-230">Wartość domyślna jest definiowana jako <see langword="null" /> dla tej właściwości zależności.</span><span class="sxs-lookup"><span data-stu-id="da2da-230">The default value is defined as <see langword="null" /> per this dependency property.</span></span> <span data-ttu-id="da2da-231">Jednak praktyczne wartości domyślne w czasie wykonywania będą pochodzić z różnych czynników.</span><span class="sxs-lookup"><span data-stu-id="da2da-231">However, the practical default at run time will come from a variety of factors.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-232">Podczas ustawiania tej właściwości w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]programie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] procesor polega <xref:System.Windows.Input.Cursor> na konwersji typu dla klasy w celu obliczenia ciągu.</span><span class="sxs-lookup"><span data-stu-id="da2da-232">When setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] processor relies on type conversion for the <xref:System.Windows.Input.Cursor> class to evaluate the string.</span></span> <span data-ttu-id="da2da-233">Podany ciąg powinien być obliczany <xref:System.Windows.Input.CursorType> jako wartość.</span><span class="sxs-lookup"><span data-stu-id="da2da-233">The provided string should evaluate to a <xref:System.Windows.Input.CursorType> value.</span></span> <span data-ttu-id="da2da-234">Aby <xref:System.Windows.Input.Cursor> uzyskać szczegółowe informacje, zobacz.</span><span class="sxs-lookup"><span data-stu-id="da2da-234">See <xref:System.Windows.Input.Cursor> for details.</span></span>  
  
 <span data-ttu-id="da2da-235">Określa, czy kursor ustalony przez tę właściwość lub nie będzie wyświetlany, gdy wskaźnik myszy znajduje się nad tym elementem również zależy od wartości <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="da2da-235">Whether the cursor as established by this property will or will not display when the mouse pointer is over this element is also dependent on the value of the <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> property.</span></span> <span data-ttu-id="da2da-236">Ponadto zagadnienia dotyczące zdarzenia, takie jak aktywne przeciąganie, przechwytywanie myszy, tryby edycji tekstu w kontrolkach i tak dalej, wpłyną również na kursor o wyższym priorytecie niż wartość określona w tej właściwości.</span><span class="sxs-lookup"><span data-stu-id="da2da-236">Also, event-related considerations such as an active drag, mouse capture, text editing modes within controls, and so on, will also affect the cursor with higher priority than the value you specify in this property.</span></span>  
  
 <span data-ttu-id="da2da-237">Aby przywrócić zachowanie ustawienia tej właściwości do ostatecznej wartości domyślnej, ustaw ją `null` ponownie.</span><span class="sxs-lookup"><span data-stu-id="da2da-237">To revert the behavior of setting this property to the eventual default, set it to `null` again.</span></span>  
  
 <span data-ttu-id="da2da-238">`null` Ustawienie domyślne naprawdę oznacza, że określenie praktycznej wartości kursora jest odroczone i powinno zostać uzyskane z innego miejsca.</span><span class="sxs-lookup"><span data-stu-id="da2da-238">The `null` default really means that determination of the practical cursor value is deferred here and should be obtained from elsewhere.</span></span> <span data-ttu-id="da2da-239">Jeśli nie ma żadnych wartości programistycznych z żadnego źródła, kursor [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] domyślny dla aplikacji będzie strzałką.</span><span class="sxs-lookup"><span data-stu-id="da2da-239">If presented with no programmatic values from any source, the default cursor over a [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] application will be an arrow.</span></span>  
  
 <span data-ttu-id="da2da-240">Każdy ruch myszy nad [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] aplikacją <xref:System.Windows.ContentElement.QueryCursor> wywołuje zdarzenie.</span><span class="sxs-lookup"><span data-stu-id="da2da-240">Each movement of the mouse over a [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] application raises a <xref:System.Windows.ContentElement.QueryCursor> event.</span></span> <span data-ttu-id="da2da-241">Bąbelki zdarzeń i każdy element na trasie mają możliwość obsługi zdarzenia i ustawiania wartości kursora za pośrednictwem argumentów tego zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="da2da-241">The event bubbles, and any element along the route has the opportunity to handle the event and to set the value of the cursor via the arguments of this event.</span></span> <span data-ttu-id="da2da-242">Jeśli tak się stanie, oznacza to, że zdarzenie jest obsługiwane i ma zmienioną wartość w argumentach ma pierwszeństwo przed wartością <xref:System.Windows.FrameworkContentElement.Cursor%2A> właściwości na dowolnym poziomie, chyba że <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> jest ustawiona.</span><span class="sxs-lookup"><span data-stu-id="da2da-242">If that happens, the fact that the event is handled and has a changed value in the arguments takes precedence over the value of the <xref:System.Windows.FrameworkContentElement.Cursor%2A> property at any level, unless <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> is set.</span></span>  
  
 <span data-ttu-id="da2da-243">Jeśli nie utworzysz kursora niestandardowego, zazwyczaj ustawiasz tę właściwość na wartość <xref:System.Windows.Input.Cursors> właściwości statycznej klasy.</span><span class="sxs-lookup"><span data-stu-id="da2da-243">If not creating a custom cursor, typically you set this property to a static property value of the <xref:System.Windows.Input.Cursors> class.</span></span>  
  
 <span data-ttu-id="da2da-244"><xref:System.Windows.Input.Cursor> Ustawienie wartości niestandardowej nie jest włączone w częściowej relacji zaufania.</span><span class="sxs-lookup"><span data-stu-id="da2da-244">Setting the <xref:System.Windows.Input.Cursor> to a custom value is not enabled in partial trust.</span></span> <span data-ttu-id="da2da-245">Aby uzyskać więcej informacji na temat niestandardowych kursorów, zobacz [przegląd danych wejściowych](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="da2da-245">For more information on custom cursors, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="da2da-246">Informacje dotyczące właściwości zależności</span><span class="sxs-lookup"><span data-stu-id="da2da-246">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="da2da-247">Pole identyfikatora</span><span class="sxs-lookup"><span data-stu-id="da2da-247">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.CursorProperty>|  
|<span data-ttu-id="da2da-248">Właściwości metadanych ustawione na`true`</span><span class="sxs-lookup"><span data-stu-id="da2da-248">Metadata properties set to `true`</span></span>|<span data-ttu-id="da2da-249">Brak</span><span class="sxs-lookup"><span data-stu-id="da2da-249">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="da2da-250">Poniższy przykład ustawia wskaźnik na wartość niestandardową.</span><span class="sxs-lookup"><span data-stu-id="da2da-250">The following example sets the cursor to a custom value.</span></span>  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkContentElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-251">Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> zależności.</span><span class="sxs-lookup"><span data-stu-id="da2da-251">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkContentElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-252">Pobiera lub ustawia kontekst danych dla elementu, gdy uczestniczy w powiązaniu danych.</span><span class="sxs-lookup"><span data-stu-id="da2da-252">Gets or sets the data context for an element when it participates in data binding.</span></span></summary>
        <value><span data-ttu-id="da2da-253">Obiekt, który ma być używany jako kontekst danych.</span><span class="sxs-lookup"><span data-stu-id="da2da-253">The object to use as data context.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-254">*Kontekst danych* to koncepcja, która umożliwia elementom dziedziczenie informacji z ich elementów nadrzędnych o źródle powiązania, które jest używane do wiązania, a także innych właściwości powiązania, takich jak ścieżka.</span><span class="sxs-lookup"><span data-stu-id="da2da-254">*Data context* is a concept that allows elements to inherit information from their parent elements about the binding source that is used for binding, as well as other characteristics of the binding such as the path.</span></span>  
  
 <span data-ttu-id="da2da-255">Kontekst danych można ustawić bezpośrednio do [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] obiektu, z powiązaniami ocenianymi do właściwości tego obiektu.</span><span class="sxs-lookup"><span data-stu-id="da2da-255">Data context can be set directly to a [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] object, with the bindings evaluating to properties of that object.</span></span> <span data-ttu-id="da2da-256">Alternatywnie można ustawić kontekst danych dla <xref:System.Windows.Data.DataSourceProvider> obiektu.</span><span class="sxs-lookup"><span data-stu-id="da2da-256">Alternatively, you can set the data context to a <xref:System.Windows.Data.DataSourceProvider> object.</span></span>  
  
 <span data-ttu-id="da2da-257">Ta właściwość zależności dziedziczy wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="da2da-257">This dependency property inherits property values.</span></span> <span data-ttu-id="da2da-258">Jeśli istnieją elementy podrzędne, które nie mają żadnej innej <xref:System.Windows.FrameworkContentElement.DataContext%2A> wartości dla opcji ustalone za pomocą lokalnych wartości lub stylów, system właściwości ustawi wartość <xref:System.Windows.FrameworkContentElement.DataContext%2A> jako wartość najbliższego elementu nadrzędnego z przypisaną wartością.</span><span class="sxs-lookup"><span data-stu-id="da2da-258">If there are child elements with no other value for <xref:System.Windows.FrameworkContentElement.DataContext%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkContentElement.DataContext%2A> value of the nearest parent element with this value assigned.</span></span>  
  
 <span data-ttu-id="da2da-259">Alternatywnie możesz użyć jednej <xref:System.Windows.Data.Binding> z następujących właściwości klasy, aby jawnie określić źródło powiązania: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, lub <xref:System.Windows.Data.Binding.RelativeSource%2A>.</span><span class="sxs-lookup"><span data-stu-id="da2da-259">Alternatively, you can use one of the following properties of the <xref:System.Windows.Data.Binding> class to specify the binding source explicitly: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, or <xref:System.Windows.Data.Binding.RelativeSource%2A>.</span></span> <span data-ttu-id="da2da-260">Aby uzyskać więcej informacji, zobacz [jak: Określ źródło](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)powiązania.</span><span class="sxs-lookup"><span data-stu-id="da2da-260">For more information, see [How to: Specify the Binding Source](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).</span></span>  
  
 <span data-ttu-id="da2da-261">W [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]programie <xref:System.Windows.FrameworkContentElement.DataContext%2A> program jest najczęściej ustawiany jako <xref:System.Windows.Data.Binding> deklaracja.</span><span class="sxs-lookup"><span data-stu-id="da2da-261">In [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkContentElement.DataContext%2A> is most commonly set to as a <xref:System.Windows.Data.Binding> declaration.</span></span> <span data-ttu-id="da2da-262">Można użyć składni elementu właściwości lub składni atrybutów.</span><span class="sxs-lookup"><span data-stu-id="da2da-262">You can use either property element syntax or attribute syntax.</span></span> <span data-ttu-id="da2da-263">Składnia atrybutu jest pokazana w przykładzie na tej stronie.</span><span class="sxs-lookup"><span data-stu-id="da2da-263">Attribute syntax is shown in the example on this page.</span></span> <span data-ttu-id="da2da-264">Możesz również ustawić <xref:System.Windows.FrameworkContentElement.DataContext%2A> w kodzie.</span><span class="sxs-lookup"><span data-stu-id="da2da-264">You can also set <xref:System.Windows.FrameworkContentElement.DataContext%2A> in code.</span></span>  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="da2da-265">Użycie elementu właściwości języka XAML</span><span class="sxs-lookup"><span data-stu-id="da2da-265">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="da2da-266">Użycie atrybutu języka XAML</span><span class="sxs-lookup"><span data-stu-id="da2da-266">XAML Attribute Usage</span></span>  
  
```xaml
<object DataContext="bindingUsage"/>  
```

<span data-ttu-id="da2da-267">—lub—</span><span class="sxs-lookup"><span data-stu-id="da2da-267">-or-</span></span>

```xaml
<object DataContext="{resourceExtension contextResourceKey}"/>  
```

<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a><span data-ttu-id="da2da-268">Wartości XAML</span><span class="sxs-lookup"><span data-stu-id="da2da-268">XAML Values</span></span>  
 <span data-ttu-id="da2da-269">*dataContextObject*</span><span class="sxs-lookup"><span data-stu-id="da2da-269">*dataContextObject*</span></span>  
 <span data-ttu-id="da2da-270">Obiekt bezpośrednio osadzony, który służy jako kontekst danych dla wszelkich powiązań w elemencie nadrzędnym.</span><span class="sxs-lookup"><span data-stu-id="da2da-270">A directly embedded object that serves as data context for any bindings within the parent element.</span></span> <span data-ttu-id="da2da-271">Zazwyczaj ten obiekt jest <xref:System.Windows.Data.Binding> lub inną <xref:System.Windows.Data.BindingBase> podklasą.</span><span class="sxs-lookup"><span data-stu-id="da2da-271">Typically, this object is a <xref:System.Windows.Data.Binding> or another <xref:System.Windows.Data.BindingBase> subclass.</span></span> <span data-ttu-id="da2da-272">Alternatywnie dane pierwotne dowolnego [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] typu obiektu przeznaczonego do powiązania mogą zostać umieszczone tutaj, z rzeczywistymi powiązaniami zdefiniowanymi w dalszej części.</span><span class="sxs-lookup"><span data-stu-id="da2da-272">Alternatively, raw data of any [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] object type intended for binding may be placed here, with the actual bindings defined later.</span></span>  
  
 <span data-ttu-id="da2da-273">*bindingUsage*</span><span class="sxs-lookup"><span data-stu-id="da2da-273">*bindingUsage*</span></span>  
 <span data-ttu-id="da2da-274">Użycie powiązania, które jest oceniane do odpowiedniego kontekstu danych.</span><span class="sxs-lookup"><span data-stu-id="da2da-274">A binding usage that evaluates to an appropriate data context.</span></span> <span data-ttu-id="da2da-275">Aby uzyskać szczegółowe informacje, zobacz [Binding Markup Extension](~/docs/framework/wpf/advanced/binding-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="da2da-275">For details, see [Binding Markup Extension](~/docs/framework/wpf/advanced/binding-markup-extension.md).</span></span>  
  
 <span data-ttu-id="da2da-276">*resourceExtension*</span><span class="sxs-lookup"><span data-stu-id="da2da-276">*resourceExtension*</span></span>  
 <span data-ttu-id="da2da-277">Jeden z następujących elementów: `StaticResource`, lub `DynamicResource`.</span><span class="sxs-lookup"><span data-stu-id="da2da-277">One of the following: `StaticResource`, or `DynamicResource`.</span></span> <span data-ttu-id="da2da-278">To użycie jest używane w przypadku odwoływania się do danych pierwotnych zdefiniowanych jako obiekt w zasobach.</span><span class="sxs-lookup"><span data-stu-id="da2da-278">This usage is used when referring to raw data defined as an object in resources.</span></span> <span data-ttu-id="da2da-279">Zobacz [zasoby XAML](~/docs/framework/wpf/advanced/xaml-resources.md).</span><span class="sxs-lookup"><span data-stu-id="da2da-279">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="da2da-280">*contextResourceKey*</span><span class="sxs-lookup"><span data-stu-id="da2da-280">*contextResourceKey*</span></span>  
 <span data-ttu-id="da2da-281">Identyfikator klucza dla obiektu, z <xref:System.Windows.ResourceDictionary>którego zażądano.</span><span class="sxs-lookup"><span data-stu-id="da2da-281">The key identifier for the object being requested from within a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="da2da-282">Informacje dotyczące właściwości zależności</span><span class="sxs-lookup"><span data-stu-id="da2da-282">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="da2da-283">Pole identyfikatora</span><span class="sxs-lookup"><span data-stu-id="da2da-283">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.DataContextProperty>|  
|<span data-ttu-id="da2da-284">Właściwości metadanych ustawione na`true`</span><span class="sxs-lookup"><span data-stu-id="da2da-284">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 <span data-ttu-id="da2da-285">Poniższy przykład ustawia powiązanie dla <xref:System.Windows.Documents.Paragraph> elementu, tworząc nowy obiekt danych niestandardowych, ustanawiając ten obiekt jako <xref:System.Windows.FrameworkContentElement.DataContext%2A>i ustawiając ścieżkę powiązania do właściwości w tym elemencie.</span><span class="sxs-lookup"><span data-stu-id="da2da-285">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as <xref:System.Windows.FrameworkContentElement.DataContext%2A>, and setting the binding path to a property within it.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-286">Występuje, gdy zmienia się kontekst danych tego elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-286">Occurs when this element's data context changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-287">Aby uzyskać wyjaśnienie kontekstów danych i powiązania danych, zobacz temat [powiązanie danych — omówienie](~/docs/framework/wpf/data/data-binding-overview.md).</span><span class="sxs-lookup"><span data-stu-id="da2da-287">For an explanation of data contexts and data binding, see [Data Binding Overview](~/docs/framework/wpf/data/data-binding-overview.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="da2da-288">Po <xref:System.Windows.FrameworkContentElement.DataContext%2A> wprowadzeniu zmian elementu wszystkie właściwości powiązane z danymi w tym elemencie mogą być zagrożone.</span><span class="sxs-lookup"><span data-stu-id="da2da-288">When an element's <xref:System.Windows.FrameworkContentElement.DataContext%2A> changes, all data-bound properties on this element are potentially affected.</span></span> <span data-ttu-id="da2da-289">Dotyczy to wszystkich elementów, które są elementami podrzędnymi bieżącego elementu, które dziedziczą kontekst danych, a także bieżącego elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-289">This applies to any elements that are descendant elements of the current element, which inherit the data context, and also the current element itself.</span></span> <span data-ttu-id="da2da-290">Wszystkie takie powiązania reinterpretują nowe <xref:System.Windows.FrameworkContentElement.DataContext%2A> , aby odzwierciedlały nową wartość w powiązaniach.</span><span class="sxs-lookup"><span data-stu-id="da2da-290">All such bindings re-interpret the new <xref:System.Windows.FrameworkContentElement.DataContext%2A> to reflect the new value in bindings.</span></span> <span data-ttu-id="da2da-291">Nie wprowadzono żadnej gwarancji dotyczącej kolejności tych zmian względem podniesienia <xref:System.Windows.FrameworkContentElement.DataContextChanged> zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="da2da-291">There is no guarantee made about the order of these changes relative to the raising of the <xref:System.Windows.FrameworkContentElement.DataContextChanged> event.</span></span>  <span data-ttu-id="da2da-292">Zmiany mogą wystąpić przed zdarzeniem, po zdarzeniu lub w dowolnej mieszance.</span><span class="sxs-lookup"><span data-stu-id="da2da-292">The changes can occur before the event, after the event, or in any mixture.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-293">Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.DataContext" /> zależności.</span><span class="sxs-lookup"><span data-stu-id="da2da-293">Identifies the <see cref="P:System.Windows.FrameworkContentElement.DataContext" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-294">Pobiera lub ustawia klucz do użycia w celu znalezienia szablonu stylu dla tej kontrolki w motywach.</span><span class="sxs-lookup"><span data-stu-id="da2da-294">Gets or sets the key to use to find the style template for this control in themes.</span></span></summary>
        <value><span data-ttu-id="da2da-295">Klucz stylu.</span><span class="sxs-lookup"><span data-stu-id="da2da-295">The style key.</span></span> <span data-ttu-id="da2da-296">Aby prawidłowo działać jako część wyszukiwania w stylu motywu, ta wartość powinna być <see cref="T:System.Type" /> wartością stylu elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-296">To work correctly as part of theme style lookup, this value is expected to be the <see cref="T:System.Type" /> of the element being styled.</span></span> <span data-ttu-id="da2da-297"><see langword="null" />jest zaakceptowaną wartością dla określonego przypadku.</span><span class="sxs-lookup"><span data-stu-id="da2da-297"><see langword="null" /> is an accepted value for a certain case.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-298">Ta właściwość zwykle nie jest ustawiana za pośrednictwem żadnej z jej metod ustawiających bezpośrednie.</span><span class="sxs-lookup"><span data-stu-id="da2da-298">This property is typically not set through any of its direct setters.</span></span> <span data-ttu-id="da2da-299">Zamiast tego przesłonić metadane specyficzne dla typu tej właściwości zależności za każdym razem, gdy tworzysz nową podklasę.</span><span class="sxs-lookup"><span data-stu-id="da2da-299">Instead, you override the type-specific metadata of this dependency property every time you create a new subclass.</span></span> <span data-ttu-id="da2da-300">Podczas podklasy należy wywołać <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> metodę <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> względem identyfikatora, w obrębie konstruktora statycznego podklasy Control.</span><span class="sxs-lookup"><span data-stu-id="da2da-300">When you subclass, call the <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method against the <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> identifier, within the static constructor of the control subclass.</span></span>  
  
 <span data-ttu-id="da2da-301">Na przykład Klasa wbudowana, taka jak <xref:System.Windows.Documents.Bold> faktycznie, ma bardzo małą implementację poza <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> zastępowaniem metadanych w konstruktorze statycznym i uwidaczniając kilka konstruktorów wystąpień.</span><span class="sxs-lookup"><span data-stu-id="da2da-301">For instance, an inline class such as <xref:System.Windows.Documents.Bold> actually has very little implementation beyond overriding the <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> metadata in its static constructor, and exposing several instance constructors.</span></span> <span data-ttu-id="da2da-302">Fakt <xref:System.Windows.Documents.Bold> , że elementy otoczone przez tag <xref:System.Windows.Documents.TextElement.FontWeight%2A> uzyskują Właściwość <xref:System.Windows.FontWeights.Bold%2A> jest zaimplementowany w stylu motywu, <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> do którego odwołuje się ustawienie wartości domyślnej na `typeof(Bold)`.</span><span class="sxs-lookup"><span data-stu-id="da2da-302">The fact that elements surrounded by the <xref:System.Windows.Documents.Bold> tag gain a <xref:System.Windows.Documents.TextElement.FontWeight%2A> property of <xref:System.Windows.FontWeights.Bold%2A> is implemented within the theme style that was referenced by setting the default value of <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> to `typeof(Bold)`.</span></span>  
  
 <span data-ttu-id="da2da-303">Jeśli chcesz, aby element lub formant nie używał stylów motywu, ustaw <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> właściwość na. `true`</span><span class="sxs-lookup"><span data-stu-id="da2da-303">If you want your element or control to deliberately not use theme styles, set the <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> property to `true`.</span></span>  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="da2da-304">Informacje dotyczące właściwości zależności</span><span class="sxs-lookup"><span data-stu-id="da2da-304">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="da2da-305">Pole identyfikatora</span><span class="sxs-lookup"><span data-stu-id="da2da-305">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|  
|<span data-ttu-id="da2da-306">Właściwości metadanych ustawione na`true`</span><span class="sxs-lookup"><span data-stu-id="da2da-306">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-307">Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /> zależności.</span><span class="sxs-lookup"><span data-stu-id="da2da-307">Identifies the <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkContentElement.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="da2da-308">Wywoływana natychmiast po zainicjowaniu elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-308">Called immediately after an element is initialized.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-309">Zaimplementuj tę metodę, aby zapewnić specjalną obsługę, która powinna wystąpić, gdy element zostanie zainicjowany podczas procesu ładowania elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-309">Implement this method to provide special handling that should occur when your element is initialized during the element loading process.</span></span>  
  
 <span data-ttu-id="da2da-310">Implementacja powinna wywołać implementację podstawową, ponieważ implementacja podstawowa (domyślna) ustawia pewne flagi wewnętrzne, aby śledzić inicjalizację.</span><span class="sxs-lookup"><span data-stu-id="da2da-310">Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</span></span>  
  
 <span data-ttu-id="da2da-311">Jeśli <xref:System.Windows.FrameworkContentElement.BeginInit%2A> została wcześniej wywołana, podstawowa implementacja spowoduje <xref:System.Windows.FrameworkContentElement.Initialized> wygenerowanie zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="da2da-311">If <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was previously called, the base implementation will raise the <xref:System.Windows.FrameworkContentElement.Initialized> event.</span></span> <span data-ttu-id="da2da-312">W przeciwnym razie <xref:System.Windows.FrameworkContentElement.BeginInit%2A> , jeśli nie została wywołana lub nie można ustalić, <xref:System.Windows.FrameworkContentElement.BeginInit%2A> czy wywołano, zdarzenie nie zostało zgłoszone.</span><span class="sxs-lookup"><span data-stu-id="da2da-312">Otherwise, if <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was not called or it could not be determined whether <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was called, the event is not raised.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkContentElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="da2da-313">Nazwa elementu do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="da2da-313">Name of the element to search for.</span></span></param>
        <summary><span data-ttu-id="da2da-314">Znajduje element o podanej nazwie identyfikatora.</span><span class="sxs-lookup"><span data-stu-id="da2da-314">Finds an element that has the provided identifier name.</span></span></summary>
        <returns><span data-ttu-id="da2da-315">Żądany element.</span><span class="sxs-lookup"><span data-stu-id="da2da-315">The requested element.</span></span> <span data-ttu-id="da2da-316">Może tak <see langword="null" /> być, jeśli nie znaleziono pasującego elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-316">May be <see langword="null" /> if no matching element was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-317">Jeśli ten element ma elementy podrzędne, te elementy podrzędne są przeszukiwane cyklicznie dla żądanego nazwanego elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-317">If this element has child elements, these child elements are all searched recursively for the requested named element.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="da2da-318">Poniższy przykład ustawia właściwość dla elementu znalezionego przez nazwę w ramach odwołania <xref:System.Windows.Documents.FlowDocument> na stronie.</span><span class="sxs-lookup"><span data-stu-id="da2da-318">The following example sets a property on an element found by name within a referenced <xref:System.Windows.Documents.FlowDocument> on a page.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#FindName](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findname)]
 [!code-vb[ContentElementsSmorgasbord#FindName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findname)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkContentElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey"><span data-ttu-id="da2da-319">Identyfikator klucza zasobu, który ma zostać znaleziony.</span><span class="sxs-lookup"><span data-stu-id="da2da-319">Key identifier of the resource to be found.</span></span></param>
        <summary><span data-ttu-id="da2da-320">Wyszukuje zasób z określonym kluczem i zgłosi wyjątek, jeśli żądany zasób nie zostanie znaleziony.</span><span class="sxs-lookup"><span data-stu-id="da2da-320">Searches for a resource with the specified key, and will throw an exception if the requested resource is not found.</span></span></summary>
        <returns><span data-ttu-id="da2da-321">Znaleziono zasób lub <see langword="null" /> nie znaleziono pasującego zasobu (ale spowoduje to również zgłoszenie wyjątku w przypadku <see langword="null" />).</span><span class="sxs-lookup"><span data-stu-id="da2da-321">The found resource, or <see langword="null" /> if no matching resource was found (but will also throw an exception if <see langword="null" />).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="da2da-322">W przypadku wywołania tej metody dla klucza, którego nie można znaleźć, zostanie zgłoszony wyjątek.</span><span class="sxs-lookup"><span data-stu-id="da2da-322">If you call this method for a key that cannot be found, an exception is thrown.</span></span> <span data-ttu-id="da2da-323">Jeśli nie chcesz obsługiwać wyjątków dla tego przypadku, zamiast tego należy wywołać metodę <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>.</span><span class="sxs-lookup"><span data-stu-id="da2da-323">If you do not want to handle exceptions for this case, you should instead call <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>.</span></span> <span data-ttu-id="da2da-324"><xref:System.Windows.FrameworkContentElement.TryFindResource%2A>zwraca `null` wartość, gdy nie znaleziono zasobu i nie zgłasza wyjątku.</span><span class="sxs-lookup"><span data-stu-id="da2da-324"><xref:System.Windows.FrameworkContentElement.TryFindResource%2A> returns `null` when no resource is found, and does not throw an exception.</span></span>  
  
 <span data-ttu-id="da2da-325">Jeśli zasób nie zostanie odnaleziony w elemencie wywołującym, drzewo nadrzędne będzie przeszukiwane przy użyciu drzewa logicznego w taki sam sposób, w jaki drzewo będzie przeszukiwane, jeśli zasób zażądał klucza w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="da2da-325">If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a resource were requested by key at run-time.</span></span>  
  
 <span data-ttu-id="da2da-326">Zazwyczaj można natychmiast rzutować wartość zwracaną na typ właściwości, którą próbowano ustawić przy użyciu zwróconej wartości zasobu.</span><span class="sxs-lookup"><span data-stu-id="da2da-326">Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="da2da-327">Poniższy przykład umożliwia znalezienie zasobu zdefiniowanego w znaczniku i zastosowanie go do pewnej właściwości elementu w odpowiedzi na zdarzenie kierowane.</span><span class="sxs-lookup"><span data-stu-id="da2da-327">The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#FindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findresource)]
 [!code-vb[ContentElementsSmorgasbord#FindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findresource)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException"><span data-ttu-id="da2da-328">Nie znaleziono żądanego klucza zasobu.</span><span class="sxs-lookup"><span data-stu-id="da2da-328">The requested resource key was not found.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="da2da-329"><paramref name="resourceKey" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="da2da-329"><paramref name="resourceKey" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-330">Pobiera lub ustawia obiekt, który umożliwia dostosowanie wyglądu, efektów lub innych cech stylu, które będą stosowane do tego elementu, gdy przechwytuje fokus klawiatury.</span><span class="sxs-lookup"><span data-stu-id="da2da-330">Gets or sets an object that enables customization of appearance, effects, or other style characteristics that will apply to this element when it captures keyboard focus.</span></span></summary>
        <value><span data-ttu-id="da2da-331">Żądany styl, który ma zostać zastosowany do fokusu.</span><span class="sxs-lookup"><span data-stu-id="da2da-331">The desired style to apply on focus.</span></span> <span data-ttu-id="da2da-332">Wartość domyślna zadeklarowana we właściwości zależności jest pustą statyczną <see cref="T:System.Windows.Style" />.</span><span class="sxs-lookup"><span data-stu-id="da2da-332">The default value as declared in the dependency property is an empty static <see cref="T:System.Windows.Style" />.</span></span> <span data-ttu-id="da2da-333">Jednak efektywna wartość w czasie wykonywania jest często (ale nie zawsze) stylem, zgodnie z obsługą motywu dla kontrolek.</span><span class="sxs-lookup"><span data-stu-id="da2da-333">However, the effective value at run time is often (but not always) a style as supplied by theme support for controls.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-334">Podczas ustawiania tej właściwości w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]programie style są prawie zawsze zdefiniowane jako zasób, a nie jako element, a ten zasób jest zwykle przywoływany <xref:System.Windows.StaticResourceExtension>jako.</span><span class="sxs-lookup"><span data-stu-id="da2da-334">When setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], styles are almost always defined as a resource, rather than inline as an element, and that resource is usually referenced as a <xref:System.Windows.StaticResourceExtension>.</span></span>  
  
 <span data-ttu-id="da2da-335">Należy zauważyć, że ta właściwość ma wpływ na wygląd wizualizacji, ale nie zgłasza tego w metadanych.</span><span class="sxs-lookup"><span data-stu-id="da2da-335">Note that this property affects visual appearance but does not report so in metadata.</span></span> <span data-ttu-id="da2da-336">Wynika to z faktu, że zmiana wyglądu wizualizacji jest sterowana zdarzeniami i może nie być stosowana przez cały czas i dlatego nie powinna raportować żadnych informacji wizualizacji lub układu w metadanych.</span><span class="sxs-lookup"><span data-stu-id="da2da-336">This is because the visual appearance change is event-driven and may not apply at all times, and thus should not generally report any visual or layout information in metadata.</span></span>  
  
 <span data-ttu-id="da2da-337">Koncepcyjnie, wizualne zachowanie fokusu zastosowany do kontrolki powinno być spójne z elementu do elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-337">Conceptually, the visual behavior of focus applied to a control should be coherent from element to element.</span></span> <span data-ttu-id="da2da-338">Najbardziej rozsądnym sposobem wymuszania spójności jest zmiana stylu wizualizacji fokusu tylko w przypadku redagowania całego motywu.</span><span class="sxs-lookup"><span data-stu-id="da2da-338">The most sensible way to enforce coherence is to only change the focus visual style if you are composing an entire theme.</span></span> <span data-ttu-id="da2da-339">Ustawienie tej właściwości dla poszczególnych stylów, a nie jako części motywu nie jest zamierzonym użyciem tej właściwości, ponieważ może to prowadzić do mylącego środowiska użytkownika dotyczącego fokusu klawiatury.</span><span class="sxs-lookup"><span data-stu-id="da2da-339">Setting this property on individual styles and not as part of a theme is not the intended usage of this property, because it may lead to a confusing user experience regarding keyboard focus.</span></span> <span data-ttu-id="da2da-340">Jeśli zamierzasz zachowywać zachowanie specyficzne dla elementu, które jest świadomie niespójne w motywie, znacznie lepszym rozwiązaniem jest użycie wyzwalaczy w stylach dla poszczególnych właściwości stanu wejściowego, <xref:System.Windows.UIElement.IsFocused%2A> takich <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>jak lub, i w taki sposób, aby nie wizualnie przeszkadza na dowolnym istniejącym stylu wizualizacji fokusu.</span><span class="sxs-lookup"><span data-stu-id="da2da-340">If you are intending element-specific behavior that is deliberately not coherent across a theme, a much better approach is to use triggers in styles for individual input state properties, such as <xref:System.Windows.UIElement.IsFocused%2A> or <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>, and to do so in a way that does not visually interfere with any existing focus visual style.</span></span> <span data-ttu-id="da2da-341">Aby uzyskać więcej informacji na temat zamiaru <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> projektowania i właściwości alternatywnej ostrości, zobacz [Style dla fokusu w kontrolkach i FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).</span><span class="sxs-lookup"><span data-stu-id="da2da-341">For more information on the design intention of <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> and alternative focus properties, see [Styling for Focus in Controls, and FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).</span></span>  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="da2da-342">Użycie atrybutu języka XAML</span><span class="sxs-lookup"><span data-stu-id="da2da-342">XAML Attribute Usage</span></span>  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="da2da-343">Użycie elementu właściwości języka XAML</span><span class="sxs-lookup"><span data-stu-id="da2da-343">XAML Property Element Usage</span></span>  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a><span data-ttu-id="da2da-344">Wartości XAML</span><span class="sxs-lookup"><span data-stu-id="da2da-344">XAML Values</span></span>  
 <span data-ttu-id="da2da-345">*resourceExtension*</span><span class="sxs-lookup"><span data-stu-id="da2da-345">*resourceExtension*</span></span>  
 <span data-ttu-id="da2da-346">Jeden z następujących elementów:, lub.</span><span class="sxs-lookup"><span data-stu-id="da2da-346">One of the following: , or .</span></span> <span data-ttu-id="da2da-347">Zobacz [zasoby XAML](~/docs/framework/wpf/advanced/xaml-resources.md).</span><span class="sxs-lookup"><span data-stu-id="da2da-347">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="da2da-348">*styleResourceKey*</span><span class="sxs-lookup"><span data-stu-id="da2da-348">*styleResourceKey*</span></span>  
 <span data-ttu-id="da2da-349">Klucz, który identyfikuje żądany styl.</span><span class="sxs-lookup"><span data-stu-id="da2da-349">The key that identifies the style being requested.</span></span> <span data-ttu-id="da2da-350">Klucz odnosi się do istniejącego zasobu w <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="da2da-350">The key refers to an existing resource in a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="da2da-351">Składnia elementu właściwości jest technicznie możliwa, ale nie jest zalecana.</span><span class="sxs-lookup"><span data-stu-id="da2da-351">Property element syntax is technically possible, but not recommended.</span></span> <span data-ttu-id="da2da-352">Zobacz [wbudowane style i szablony](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span><span class="sxs-lookup"><span data-stu-id="da2da-352">See [Inline Styles and Templates](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span></span>  <span data-ttu-id="da2da-353">Odwołanie do powiązania przy użyciu [szablonu TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md) lub <xref:System.Windows.Data.Binding> jest również możliwe, ale nietypowe.</span><span class="sxs-lookup"><span data-stu-id="da2da-353">A binding reference using [TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md) or <xref:System.Windows.Data.Binding> is also possible, but uncommon.</span></span>  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="da2da-354">Informacje dotyczące właściwości zależności</span><span class="sxs-lookup"><span data-stu-id="da2da-354">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="da2da-355">Pole identyfikatora</span><span class="sxs-lookup"><span data-stu-id="da2da-355">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|  
|<span data-ttu-id="da2da-356">Właściwości metadanych ustawione na`true`</span><span class="sxs-lookup"><span data-stu-id="da2da-356">Metadata properties set to `true`</span></span>|<span data-ttu-id="da2da-357">Brak</span><span class="sxs-lookup"><span data-stu-id="da2da-357">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-358">Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /> zależności.</span><span class="sxs-lookup"><span data-stu-id="da2da-358">Identifies the <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-359">Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Windows.FrameworkContentElement" /> powinien [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] wymusić renderowanie kursora jako <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> zadeklarowanego przez właściwość tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="da2da-359">Gets or sets a value indicating whether this <see cref="T:System.Windows.FrameworkContentElement" /> should force the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] to render the cursor as declared by this instance's <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> property.</span></span></summary>
        <value><span data-ttu-id="da2da-360"><see langword="true" />Aby wymusić prezentację kursora nad tym elementem, aby użyć ustawienia tego wystąpienia dla kursora (łącznie ze wszystkimi elementami podrzędnymi); w <see langword="false" />przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="da2da-360"><see langword="true" /> to force cursor presentation while over this element to use this instance's setting for the cursor (including on all child elements); otherwise <see langword="false" />.</span></span> <span data-ttu-id="da2da-361">Wartość domyślna to <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="da2da-361">The default value is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-362">Ustawienie tej właściwości na `true` spowoduje zastąpienie preferencji kursora określonych przez elementy podrzędne.</span><span class="sxs-lookup"><span data-stu-id="da2da-362">Setting this property to `true` will override the cursor preferences established by child elements.</span></span> <span data-ttu-id="da2da-363">Wykonanie tej operacji w ogólnej [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] aplikacji może być mylące dla użytkownika, szczególnie w przypadku, gdy elementy podrzędne próbują określić kursory.</span><span class="sxs-lookup"><span data-stu-id="da2da-363">Doing so in general application [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] might be confusing for the user, particularly if child elements are attempting to specify cursors.</span></span> <span data-ttu-id="da2da-364">Ustawienie <xref:System.Windows.FrameworkElement.ForceCursor%2A> jest bardziej odpowiednie w scenariuszach podklasy kontroli lub składania.</span><span class="sxs-lookup"><span data-stu-id="da2da-364">Setting <xref:System.Windows.FrameworkElement.ForceCursor%2A> is more appropriate in control subclassing or compositing scenarios.</span></span>  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="da2da-365">Informacje dotyczące właściwości zależności</span><span class="sxs-lookup"><span data-stu-id="da2da-365">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="da2da-366">Pole identyfikatora</span><span class="sxs-lookup"><span data-stu-id="da2da-366">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|  
|<span data-ttu-id="da2da-367">Właściwości metadanych ustawione na`true`</span><span class="sxs-lookup"><span data-stu-id="da2da-367">Metadata properties set to `true`</span></span>|<span data-ttu-id="da2da-368">Brak</span><span class="sxs-lookup"><span data-stu-id="da2da-368">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="da2da-369">Poniższy przykład wymusza przekroczenie kursora w elemencie.</span><span class="sxs-lookup"><span data-stu-id="da2da-369">The following example forces the cursor while over the element.</span></span>  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-370">Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /> zależności.</span><span class="sxs-lookup"><span data-stu-id="da2da-370">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="da2da-371">Element docelowy <see cref="T:System.Windows.DependencyProperty" /> , z którego ma zostać pobrane powiązanie.</span><span class="sxs-lookup"><span data-stu-id="da2da-371">The target <see cref="T:System.Windows.DependencyProperty" /> from which to get the binding.</span></span></param>
        <summary><span data-ttu-id="da2da-372"><see cref="T:System.Windows.Data.BindingExpression" /> Pobiera dla powiązania określonej właściwości.</span><span class="sxs-lookup"><span data-stu-id="da2da-372">Gets the <see cref="T:System.Windows.Data.BindingExpression" /> for the specified property's binding.</span></span></summary>
        <returns><span data-ttu-id="da2da-373">Zwraca wartość, <see langword="null" /> Jeśliobiektdocelowyjestpowiązanyzdanymi;wprzeciwnymrazie.<see cref="T:System.Windows.Data.BindingExpression" /></span><span class="sxs-lookup"><span data-stu-id="da2da-373">Returns a <see cref="T:System.Windows.Data.BindingExpression" /> if the target is data bound; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="da2da-374">Poniższy przykład pobiera powiązanie przez zapytanie do właściwości.</span><span class="sxs-lookup"><span data-stu-id="da2da-374">The following example retrieves a binding by querying a property.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#getbindingexpression)]
 [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#getbindingexpression)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="da2da-375">Zwraca alternatywny logiczny element nadrzędny dla tego elementu, jeśli nie istnieje obiekt nadrzędny.</span><span class="sxs-lookup"><span data-stu-id="da2da-375">Returns an alternative logical parent for this element if there is no visual parent.</span></span> <span data-ttu-id="da2da-376">W takim przypadku <see cref="T:System.Windows.FrameworkContentElement" /> obiekt nadrzędny jest zawsze taka sama <see cref="P:System.Windows.FrameworkContentElement.Parent" /> jak wartość właściwości.</span><span class="sxs-lookup"><span data-stu-id="da2da-376">In this case, a <see cref="T:System.Windows.FrameworkContentElement" /> parent is always the same value as the <see cref="P:System.Windows.FrameworkContentElement.Parent" /> property.</span></span></summary>
        <returns><span data-ttu-id="da2da-377">Zwraca coś innego niż <see langword="null" /> za każdym razem, gdy implementacja tej metody na poziomie platformy WPF jest niewizualna.</span><span class="sxs-lookup"><span data-stu-id="da2da-377">Returns something other than <see langword="null" /> whenever a WPF framework-level implementation of this method has a non-visual parent connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-378">Domyślna implementacja zwraca oczekiwany pojedynczy element nadrzędny Visual.</span><span class="sxs-lookup"><span data-stu-id="da2da-378">The default implementation returns the expected single visual parent.</span></span> <span data-ttu-id="da2da-379">Implementacje niestandardowe mogą zwracać alternatywne relacje nadrzędne.</span><span class="sxs-lookup"><span data-stu-id="da2da-379">Custom implementations might return alternate parent relationships.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-380">Występuje po zainicjowaniu tego <see cref="T:System.Windows.FrameworkContentElement" /> .</span><span class="sxs-lookup"><span data-stu-id="da2da-380">Occurs when this <see cref="T:System.Windows.FrameworkContentElement" /> is initialized.</span></span> <span data-ttu-id="da2da-381">Jest to zbieżne ze przypadkami, gdy wartość <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> właściwości zmienia się <see langword="false" /> z (lub niezdefiniowana <see langword="true" />) na.</span><span class="sxs-lookup"><span data-stu-id="da2da-381">This coincides with cases where the value of the <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> property changes from <see langword="false" /> (or undefined) to <see langword="true" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-382">To zdarzenie zostanie wywołane przy każdym <xref:System.Windows.FrameworkContentElement.EndInit%2A> wywołaniu <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> metody lub.</span><span class="sxs-lookup"><span data-stu-id="da2da-382">This event will be raised whenever the <xref:System.Windows.FrameworkContentElement.EndInit%2A> or <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> methods are called.</span></span> <span data-ttu-id="da2da-383">Wywołania tych metod mogą zostać wykonane przez zamierzony kod lub [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] proces ładowania.</span><span class="sxs-lookup"><span data-stu-id="da2da-383">Calls to these methods could have been made by deliberate code, or by the [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] loading process.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkContentElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-384">Pobiera lub ustawia kontekst używany przez <see cref="T:System.Windows.FrameworkContentElement" />dane wejściowe.</span><span class="sxs-lookup"><span data-stu-id="da2da-384">Gets or sets the context for input used by this <see cref="T:System.Windows.FrameworkContentElement" />.</span></span></summary>
        <value><span data-ttu-id="da2da-385">Zakres wejściowy, który modyfikuje sposób interpretacji danych wejściowych z alternatywnych metod wprowadzania.</span><span class="sxs-lookup"><span data-stu-id="da2da-385">The input scope, which modifies how input from alternative input methods is interpreted.</span></span> <span data-ttu-id="da2da-386">Wartość domyślna to <see langword="null" /> (w wyniku domyślnego sposobu obsługi poleceń).</span><span class="sxs-lookup"><span data-stu-id="da2da-386">The default value is <see langword="null" /> (which results in a default handling of commands).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-387">Ta właściwość zależności dziedziczy wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="da2da-387">This dependency property inherits property values.</span></span> <span data-ttu-id="da2da-388">Jeśli istnieją elementy podrzędne, które nie mają żadnej innej <xref:System.Windows.FrameworkElement.InputScope%2A> wartości dla opcji ustalone za pomocą lokalnych wartości lub stylów, system właściwości ustawi wartość <xref:System.Windows.FrameworkElement.InputScope%2A> jako wartość najbliższego elementu nadrzędnego z przypisaną wartością.</span><span class="sxs-lookup"><span data-stu-id="da2da-388">If there are child elements with no other value for <xref:System.Windows.FrameworkElement.InputScope%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkElement.InputScope%2A> value of the nearest parent element with this value assigned.</span></span>  
  
 <span data-ttu-id="da2da-389">Chociaż użycie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] składni jest wymienione i jest syntaktycznie dozwolone, ustawienie tej właściwości w nie jest wspólne. [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</span><span class="sxs-lookup"><span data-stu-id="da2da-389">Although a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax usage is listed and is syntactically allowed, setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] is not common.</span></span>  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="da2da-390">Informacje dotyczące właściwości zależności</span><span class="sxs-lookup"><span data-stu-id="da2da-390">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="da2da-391">Pole identyfikatora</span><span class="sxs-lookup"><span data-stu-id="da2da-391">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.InputScopeProperty>|  
|<span data-ttu-id="da2da-392">Właściwości metadanych ustawione na`true`</span><span class="sxs-lookup"><span data-stu-id="da2da-392">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-393">Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.InputScope" /> zależności.</span><span class="sxs-lookup"><span data-stu-id="da2da-393">Identifies the <see cref="P:System.Windows.FrameworkContentElement.InputScope" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-394">Pobiera wartość wskazującą, czy ten element został zainicjowany, przez załadowanie jako [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]lub przez jawne <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> wywołanie metody.</span><span class="sxs-lookup"><span data-stu-id="da2da-394">Gets a value indicating whether this element has been initialized, either by being loaded as [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], or by explicitly having its <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> method called.</span></span></summary>
        <value><span data-ttu-id="da2da-395"><see langword="true" />Jeśli element jest zainicjowany dla powyższych wywołań ładowania lub metody; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="da2da-395"><see langword="true" /> if the element is initialized per the aforementioned loading or method calls; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-396">Ta właściwość może być `true` również wtedy, gdy ten element został przeniesiony w drzewie elementów, tak że ma nowy element nadrzędny i dlatego zostanie ponownie załadowany.</span><span class="sxs-lookup"><span data-stu-id="da2da-396">This property may also be `true` if this element has been moved within the element tree such that it has a new parent element, and therefore becomes reloaded again.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-397">Pobiera wartość wskazującą, czy ten element został załadowany do prezentacji.</span><span class="sxs-lookup"><span data-stu-id="da2da-397">Gets a value indicating whether this element has been loaded for presentation.</span></span></summary>
        <value><span data-ttu-id="da2da-398"><see langword="true" />Jeśli bieżący element jest dołączony do drzewa elementów i został renderowany; <see langword="false" /> Jeśli element nigdy nie został dołączony do załadowanego drzewa elementów.</span><span class="sxs-lookup"><span data-stu-id="da2da-398"><see langword="true" /> if the current element is attached to an element tree and has been rendered; <see langword="false" /> if the element has never been attached to a loaded element tree.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-399">Od nowo skonstruowanego wystąpienia ta właściwość zaczyna się `false`i pozostaje `true` po ustawieniu na `true`, nawet jeśli później zostanie usunięta przez kod.</span><span class="sxs-lookup"><span data-stu-id="da2da-399">From a newly constructed instance, this property starts off `false`, and remains `true` once it is set to `true`, even if subsequently removed by  code.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="da2da-400">Poniższy przykładowy kod używa <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> jako warunkowego sprawdzania, aby upewnić się, że funkcja `displayData` (niepokazywana) będzie mieć poprawne elementy załadowane na stronie, aby działać w ramach obsługi na żądanie.</span><span class="sxs-lookup"><span data-stu-id="da2da-400">The following example code uses <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> as a conditional check to assure that a function `displayData` (not shown) will have valid elements loaded on the page to work against, as part of an on-demand handler.</span></span> <span data-ttu-id="da2da-401">Ta sama logika jest uruchamiana jako procedura obsługi <xref:System.Windows.FrameworkContentElement.Loaded>zdarzeń dla.</span><span class="sxs-lookup"><span data-stu-id="da2da-401">That same logic is run as an event handler for <xref:System.Windows.FrameworkContentElement.Loaded>.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#isloaded)]
 [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#isloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkContentElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkContentElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-402">Pobiera lub ustawia informacje o języku lokalizacji/globalizacji, które mają zastosowanie do pojedynczego elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-402">Gets or sets localization/globalization language information that applies to an individual element.</span></span></summary>
        <value><span data-ttu-id="da2da-403">Informacje o kulturze dla tego elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-403">The culture information for this element.</span></span> <span data-ttu-id="da2da-404">Wartość domyślna to <see cref="T:System.Windows.Markup.XmlLanguage" /> wystąpienie <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> z wartością ustawioną na ciąg "en-us".</span><span class="sxs-lookup"><span data-stu-id="da2da-404">The default value is an <see cref="T:System.Windows.Markup.XmlLanguage" /> instance with its <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> value set to the string "en-US".</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-405">Formaty ciągów są zgodne ze standardem RFC 3066.</span><span class="sxs-lookup"><span data-stu-id="da2da-405">The string formats follow the RFC 3066 standard.</span></span> <span data-ttu-id="da2da-406">Na przykład w Stanach Zjednoczonych Angielski to "pl-US".</span><span class="sxs-lookup"><span data-stu-id="da2da-406">For example, U.S. English is "en-US".</span></span> <span data-ttu-id="da2da-407">Aby <xref:System.Windows.Markup.XmlLanguage> uzyskać więcej informacji na temat wartości i formatu, zobacz.</span><span class="sxs-lookup"><span data-stu-id="da2da-407">See <xref:System.Windows.Markup.XmlLanguage> for more information on the values and format.</span></span>  
  
 <span data-ttu-id="da2da-408">Ta właściwość zależności dziedziczy wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="da2da-408">This dependency property inherits property values.</span></span> <span data-ttu-id="da2da-409">Jeśli istnieją elementy podrzędne, które nie mają żadnej innej <xref:System.Windows.FrameworkElement.Language%2A> wartości dla opcji ustalone za pomocą lokalnych wartości lub stylów, system właściwości ustawi wartość <xref:System.Windows.FrameworkElement.Language%2A> jako wartość najbliższego elementu nadrzędnego z przypisaną wartością.</span><span class="sxs-lookup"><span data-stu-id="da2da-409">If there are child elements with no other value for <xref:System.Windows.FrameworkElement.Language%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkElement.Language%2A> value of the nearest parent element with this value assigned.</span></span>  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="da2da-410">Informacje dotyczące właściwości zależności</span><span class="sxs-lookup"><span data-stu-id="da2da-410">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="da2da-411">Pole identyfikatora</span><span class="sxs-lookup"><span data-stu-id="da2da-411">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.LanguageProperty>|  
|<span data-ttu-id="da2da-412">Właściwości metadanych ustawione na`true`</span><span class="sxs-lookup"><span data-stu-id="da2da-412">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-413">Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.Language" /> zależności.</span><span class="sxs-lookup"><span data-stu-id="da2da-413">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Language" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-414">Występuje, gdy element jest określony, renderowany i gotowy do interakcji.</span><span class="sxs-lookup"><span data-stu-id="da2da-414">Occurs when the element is laid out, rendered, and ready for interaction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-415">Zdarzenia kierowane bezpośrednio nie obserwują trasy, są obsługiwane tylko w obrębie tego samego elementu, w którym zostały zgłoszone.</span><span class="sxs-lookup"><span data-stu-id="da2da-415">Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</span></span> <span data-ttu-id="da2da-416">Zdarzenia kierowane bezpośrednio obsługują inne kierowane zdarzenia dotyczące zdarzeń: obsługują kolekcję programów obsługi i mogą być używane jako <xref:System.Windows.EventTrigger> style.</span><span class="sxs-lookup"><span data-stu-id="da2da-416">Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <xref:System.Windows.EventTrigger> in a style.</span></span>  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="da2da-417">Informacje dotyczące kierowanego zdarzenia</span><span class="sxs-lookup"><span data-stu-id="da2da-417">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="da2da-418">Pole identyfikatora</span><span class="sxs-lookup"><span data-stu-id="da2da-418">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.LoadedEvent>|  
|<span data-ttu-id="da2da-419">Strategia routingu</span><span class="sxs-lookup"><span data-stu-id="da2da-419">Routing strategy</span></span>|<span data-ttu-id="da2da-420">Bezpośrednie</span><span class="sxs-lookup"><span data-stu-id="da2da-420">Direct</span></span>|  
|<span data-ttu-id="da2da-421">Delegate</span><span class="sxs-lookup"><span data-stu-id="da2da-421">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-422">Identyfikuje przegląd [zdarzeń kierowanych.](~/docs/framework/wpf/advanced/routed-events-overview.md) <see cref="E:System.Windows.FrameworkContentElement.Loaded" /></span><span class="sxs-lookup"><span data-stu-id="da2da-422">Identifies the <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-423">Obiekty identyfikatorów zdarzeń są tworzone po zarejestrowaniu zdarzeń kierowanych <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>(zobacz) i mogą być używane do dodawania programów obsługi klasy ( <xref:System.Windows.EventManager.RegisterClassHandler%2A>Zobacz).</span><span class="sxs-lookup"><span data-stu-id="da2da-423">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="da2da-424">Obiekty identyfikatorów zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu i metodę narzędzia do dodawania właścicieli dla zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="da2da-424">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-425">Pobiera moduł wyliczający dla logicznych elementów podrzędnych tego elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-425">Gets an enumerator for the logical child elements of this element.</span></span></summary>
        <value><span data-ttu-id="da2da-426">Moduł wyliczający dla logicznych elementów podrzędnych tego elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-426">An enumerator for logical child elements of this element.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-427">Aby uzyskać więcej informacji na temat korzystania <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> z <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>i, zobacz [drzewa w WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span><span class="sxs-lookup"><span data-stu-id="da2da-427">For more information on how to use <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> and <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, see [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkContentElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request"><span data-ttu-id="da2da-428">Kierunek, który fokus ma zostać przeniesiony jako wartość wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="da2da-428">The direction that focus is to be moved, as a value of the enumeration.</span></span></param>
        <summary><span data-ttu-id="da2da-429">Przenosi fokus klawiatury z tego elementu do innego elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-429">Moves the keyboard focus from this element to another element.</span></span></summary>
        <returns><span data-ttu-id="da2da-430">Zwraca <see langword="true" /> wartość, jeśli fokus jest przenoszony pomyślnie; <see langword="false" /> Jeśli element docelowy w kierunku określonym przez nie istnieje.</span><span class="sxs-lookup"><span data-stu-id="da2da-430">Returns <see langword="true" /> if focus is moved successfully; <see langword="false" /> if the target element in direction as specified does not exist.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkContentElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-431">Pobiera lub ustawia nazwę identyfikującą elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-431">Gets or sets the identifying name of the element.</span></span> <span data-ttu-id="da2da-432">Nazwa zawiera odwołanie do wystąpienia, dzięki czemu kod programistyczny, taki jak kod procedury obsługi zdarzeń, może odwoływać się do elementu, gdy jest konstruowany podczas analizowania [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="da2da-432">The name provides an instance reference so that programmatic code-behind, such as event handler code, can refer to an element once it is constructed during parsing of [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span></summary>
        <value><span data-ttu-id="da2da-433">Nazwa elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-433">The name of the element.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-434">Najbardziej typowym użyciem tej właściwości jest określenie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] nazwy elementu w znaczniku.</span><span class="sxs-lookup"><span data-stu-id="da2da-434">The most common usage of this property is when specifying a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] element name in markup.</span></span>  
  
 <span data-ttu-id="da2da-435">Ta właściwość zasadniczo zapewnia wygodną właściwość na poziomie platformy WPF do ustawiania [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [dyrektywy x:Name](~/docs/framework/xaml-services/x-name-directive.md).</span><span class="sxs-lookup"><span data-stu-id="da2da-435">This property essentially provides a WPF framework-level convenience property to set the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [x:Name Directive](~/docs/framework/xaml-services/x-name-directive.md).</span></span>  
  
 <span data-ttu-id="da2da-436">Pobieranie z kodu nie jest wspólne, ponieważ jeśli istnieje odpowiednie odwołanie w kodzie, można tylko wywołać metody i właściwości w odwołaniu do elementu i nie są zwykle <xref:System.Windows.FrameworkContentElement.Name%2A>potrzebne. <xref:System.Windows.FrameworkContentElement.Name%2A></span><span class="sxs-lookup"><span data-stu-id="da2da-436">Getting a <xref:System.Windows.FrameworkContentElement.Name%2A> from code is not common, because if you have the appropriate reference in code already, you can just call methods and properties on the element reference and do not generally need the <xref:System.Windows.FrameworkContentElement.Name%2A>.</span></span> <span data-ttu-id="da2da-437">Wyjątek polega na tym, że ciąg ma pewne przeciążone znaczenie, na przykład, jeśli jest przydatne do wyświetlania tej [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]nazwy w.</span><span class="sxs-lookup"><span data-stu-id="da2da-437">An exception is if the string has some overloaded meaning, for instance if it is useful to display that name in [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="da2da-438">Ustawienie wartości <xref:System.Windows.FrameworkContentElement.Name%2A> z kodu, Jeśli oryginał został ustawiony z znaczników jest również niezalecane i zmiana właściwości nie spowoduje zmiany odwołania do obiektu. <xref:System.Windows.FrameworkContentElement.Name%2A></span><span class="sxs-lookup"><span data-stu-id="da2da-438">Setting a <xref:System.Windows.FrameworkContentElement.Name%2A> from code if the original <xref:System.Windows.FrameworkContentElement.Name%2A> was set from markup is also not recommended, and changing the property will not change the object reference.</span></span> <span data-ttu-id="da2da-439">Odwołania do obiektów są tworzone tylko wtedy, gdy bazowe Zakresy nazw WPF są jawnie tworzone [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] podczas ładowania.</span><span class="sxs-lookup"><span data-stu-id="da2da-439">Such object references are created only when the underlying namescopes are explicitly created during [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] loading.</span></span>  
  
 <span data-ttu-id="da2da-440">Należy wywołać <xref:System.Windows.FrameworkContentElement.RegisterName%2A> , aby wprowadzić skuteczną zmianę <xref:System.Windows.FrameworkContentElement.Name%2A> właściwości już załadowanego elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-440">You must specifically call <xref:System.Windows.FrameworkContentElement.RegisterName%2A> to make an effective change on the <xref:System.Windows.FrameworkContentElement.Name%2A> property of an already loaded element.</span></span>  
  
 <span data-ttu-id="da2da-441">W przypadku, gdy ustawienie <xref:System.Windows.FrameworkContentElement.Name%2A> z kodu jest ważne dla elementów nazewnictwa, względem których będą uruchamiane Scenorysy.</span><span class="sxs-lookup"><span data-stu-id="da2da-441">One notable case where setting <xref:System.Windows.FrameworkContentElement.Name%2A> from  code is important is for naming elements that storyboards will run against.</span></span> <span data-ttu-id="da2da-442">Przed zarejestrowaniem nazwy może również wystąpić potrzeba wystąpienia i przypisania <xref:System.Windows.NameScope> wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="da2da-442">Before you can register a name, might also need to instantiate and assign a <xref:System.Windows.NameScope> instance.</span></span> <span data-ttu-id="da2da-443">Zapoznaj się z sekcją [](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)przykładu lub scenorysami.</span><span class="sxs-lookup"><span data-stu-id="da2da-443">See the Example section, or [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span></span>  
  
 <span data-ttu-id="da2da-444">Ustawienie <xref:System.Windows.FrameworkContentElement.Name%2A> z kodu ma ograniczone aplikacje, ale wyszukiwanie elementu według nazwy jest bardziej popularne, szczególnie w przypadku korzystania z modelu nawigacji, w którym strony ładują się ponownie do aplikacji, a kod czasu wykonywania nie musi być kodem związanym z tym odpowiedniej stronie.</span><span class="sxs-lookup"><span data-stu-id="da2da-444">Setting <xref:System.Windows.FrameworkContentElement.Name%2A> from code has limited applications, but looking up an element by name is more common, particularly if you are employing a navigation model where pages reload into the application and the run-time code is not necessarily the code-behind of that respective page.</span></span> <span data-ttu-id="da2da-445">Metoda <xref:System.Windows.FrameworkContentElement.FindName%2A>narzędziowa, która jest dostępna z dowolnego <xref:System.Windows.FrameworkContentElement>elementu, może odróżniać <xref:System.Windows.FrameworkContentElement.Name%2A> każdy element według cyklicznego drzewa logicznego tego elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-445">The utility method <xref:System.Windows.FrameworkContentElement.FindName%2A>, which is available from any <xref:System.Windows.FrameworkContentElement>, can find any element by <xref:System.Windows.FrameworkContentElement.Name%2A> in that element's logical tree recursively.</span></span> <span data-ttu-id="da2da-446">Można też użyć <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> statycznej <xref:System.Windows.LogicalTreeHelper>metody <xref:System.Windows.FrameworkContentElement.Name%2A> , która również przyjmuje ciąg jako argument.</span><span class="sxs-lookup"><span data-stu-id="da2da-446">Or you can use the <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> static method of <xref:System.Windows.LogicalTreeHelper>, which also takes the <xref:System.Windows.FrameworkContentElement.Name%2A> string as an argument.</span></span>  
  
 <span data-ttu-id="da2da-447">Najczęściej używane elementy główne (<xref:System.Windows.Window> <xref:System.Windows.Controls.Page> na przykład) implementują interfejs <xref:System.Windows.Markup.INameScope>.</span><span class="sxs-lookup"><span data-stu-id="da2da-447">Commonly used root elements (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> for example) implement the interface <xref:System.Windows.Markup.INameScope>.</span></span> <span data-ttu-id="da2da-448">Implementacje tego interfejsu powinny wymusić niejednoznaczność nazw w zakresie.</span><span class="sxs-lookup"><span data-stu-id="da2da-448">Implementations of this interface are expected to enforce that names be unambiguous within their scope.</span></span>  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="da2da-449">Informacje dotyczące właściwości zależności</span><span class="sxs-lookup"><span data-stu-id="da2da-449">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="da2da-450">Pole identyfikatora</span><span class="sxs-lookup"><span data-stu-id="da2da-450">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.NameProperty>|  
|<span data-ttu-id="da2da-451">Właściwości metadanych ustawione na`true`</span><span class="sxs-lookup"><span data-stu-id="da2da-451">Metadata properties set to `true`</span></span>|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-452">Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.Name" /> zależności.</span><span class="sxs-lookup"><span data-stu-id="da2da-452">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Name" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="da2da-453">Zawiera dane dotyczące zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="da2da-453">Provides data about the event.</span></span></param>
        <summary><span data-ttu-id="da2da-454">Wywoływana za każdym <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> razem, gdy zdarzenie kierowane osiągnie tę klasę w swojej trasie.</span><span class="sxs-lookup"><span data-stu-id="da2da-454">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> routed event reaches this class in its route.</span></span> <span data-ttu-id="da2da-455">Zaimplementuj tę metodę, aby dodać obsługę klasy dla tego zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="da2da-455">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-456">Ta metoda nie ma domyślnej implementacji.</span><span class="sxs-lookup"><span data-stu-id="da2da-456">This method has no default implementation.</span></span> <span data-ttu-id="da2da-457">Należy nadal wywoływać implementację bazową w przypadku zaimplementowania tej metody przez klasę pośrednią w dziedziczeniu.</span><span class="sxs-lookup"><span data-stu-id="da2da-457">You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="da2da-458">Celem tej metody jest nieco podobna do wzorca zdarzeń [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] w odniesieniu do \* metod: udostępnia metodę do obsługi pasującego zdarzenia z klas pochodnych z obsługą klasy zamiast programu obsługi wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="da2da-458">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="da2da-459">W takim przypadku zdarzenie dopasowywania jest zdarzeniem kierowanym.</span><span class="sxs-lookup"><span data-stu-id="da2da-459">In this case the matching event is a routed event.</span></span> <span data-ttu-id="da2da-460">Wzorzec implementacji metod on \* jest różny dla zdarzeń kierowanych, ponieważ zdarzenie kierowane mogło zostać zgłoszone przez element podrzędny, niekoniecznie element, który wywoła procedury obsługi.</span><span class="sxs-lookup"><span data-stu-id="da2da-460">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="da2da-461">W związku z tym implementacja będzie musiała przyjąć właściwości źródłowe argumentów zdarzenia (i nie powinna próbować ponownie podnieść zdarzenia w większości przypadków).</span><span class="sxs-lookup"><span data-stu-id="da2da-461">Therefore, your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="da2da-462">Podklasy <xref:System.Windows.FrameworkContentElement> mogą wybierać wywołania metod obsługi klasy prywatnej, gdy zdarzenie jest odbierane wzdłuż trasy.</span><span class="sxs-lookup"><span data-stu-id="da2da-462">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="da2da-463">Jednym z potencjalnych scenariuszy jest przejęcie argumentów zdarzenia i celowe oznaczenie zdarzenia jako obsłużonego w celu skrócenia trasy.</span><span class="sxs-lookup"><span data-stu-id="da2da-463">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="da2da-464">Dane zdarzenia dla zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="da2da-464">Event data for the event.</span></span></param>
        <summary><span data-ttu-id="da2da-465">Wywoływana za każdym <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> razem, gdy zdarzenie kierowane osiągnie tę klasę w swojej trasie.</span><span class="sxs-lookup"><span data-stu-id="da2da-465">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> routed event reaches this class in its route.</span></span> <span data-ttu-id="da2da-466">Zaimplementuj tę metodę, aby dodać obsługę klasy dla tego zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="da2da-466">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-467">Ta metoda nie ma domyślnej implementacji.</span><span class="sxs-lookup"><span data-stu-id="da2da-467">This method has no default implementation.</span></span> <span data-ttu-id="da2da-468">Należy nadal wywoływać metodę Base () w przypadku, gdy Klasa pośrednicząca w dziedziczeniu zaimplementował tę metody.</span><span class="sxs-lookup"><span data-stu-id="da2da-468">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="da2da-469">Celem tej metody jest nieco podobna do wzorca zdarzeń [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] w odniesieniu do \* metod: udostępnia metodę do obsługi pasującego zdarzenia z klas pochodnych z obsługą klasy zamiast programu obsługi wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="da2da-469">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="da2da-470">W takim przypadku zdarzenie dopasowywania jest zdarzeniem kierowanym.</span><span class="sxs-lookup"><span data-stu-id="da2da-470">In this case the matching event is a routed event.</span></span> <span data-ttu-id="da2da-471">Wzorzec implementacji metod on \* jest różny w przypadku zdarzeń kierowanych, ponieważ zdarzenie kierowane mogło zostać zgłoszone przez element podrzędny, niekoniecznie element, który wywoła programy obsługi, więc implementacja będzie musiała przyjmować argumenty zdarzenia "Źródło". właściwości do konta (i nie powinny próbować ponownie podnieść zdarzenia w większości przypadków).</span><span class="sxs-lookup"><span data-stu-id="da2da-471">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="da2da-472">Podklasy <xref:System.Windows.FrameworkContentElement> mogą wybierać wywołania metod obsługi klasy prywatnej, gdy zdarzenie jest odbierane wzdłuż trasy.</span><span class="sxs-lookup"><span data-stu-id="da2da-472">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="da2da-473">Jednym z potencjalnych scenariuszy jest przejęcie argumentów zdarzenia i celowe oznaczenie zdarzenia jako obsłużonego w celu skrócenia trasy.</span><span class="sxs-lookup"><span data-stu-id="da2da-473">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkContentElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="da2da-474">Dane zdarzenia dla zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="da2da-474">Event data for the event.</span></span></param>
        <summary><span data-ttu-id="da2da-475">Obsługa klasy dla <see cref="E:System.Windows.ContentElement.GotFocus" /> zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="da2da-475">Class handler for the <see cref="E:System.Windows.ContentElement.GotFocus" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-476">Ta procedura obsługi klasy ustawia odpowiednie zachowanie ostrości dla tego elementu, jeśli zdarzenie pochodzi z tego elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-476">This class handler sets appropriate focus behavior on this element if the event originated from this element.</span></span> <span data-ttu-id="da2da-477">Jeśli źródło zdarzenia było innym elementem w drzewie, program obsługi nie robi nic.</span><span class="sxs-lookup"><span data-stu-id="da2da-477">If the event's source was another element in the tree, the handler does nothing.</span></span>  
  
 <span data-ttu-id="da2da-478">Zastąp tę metodę, aby zmienić domyślne zachowanie ukierunkowane na element.</span><span class="sxs-lookup"><span data-stu-id="da2da-478">Override this method in order to change these default focusing behavior on your element.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkContentElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="da2da-479">Dane zdarzenia dla zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="da2da-479">Event data for the event.</span></span></param>
        <summary><span data-ttu-id="da2da-480"><see cref="E:System.Windows.FrameworkContentElement.Initialized" /> Podnosi zdarzenie.</span><span class="sxs-lookup"><span data-stu-id="da2da-480">Raises the <see cref="E:System.Windows.FrameworkContentElement.Initialized" /> event.</span></span> <span data-ttu-id="da2da-481">Ta metoda jest wywoływana za <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> każdym razem, <see langword="true" />gdy jest ustawiona na.</span><span class="sxs-lookup"><span data-stu-id="da2da-481">This method is invoked whenever <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> is set to <see langword="true" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-482">Domyślna implementacja tej metody wirtualnej wywołuje zdarzenie zgodnie z opisem we wcześniejszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="da2da-482">The default implementation of this virtual method raises the event as described earlier in this topic.</span></span> <span data-ttu-id="da2da-483">Zastąpienia powinny wywołać metodę Base (), aby zachować to zachowanie.</span><span class="sxs-lookup"><span data-stu-id="da2da-483">Overrides should call base() to preserve this behavior.</span></span>  
  
 <span data-ttu-id="da2da-484">Należy zauważyć, <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> że właściwość jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="da2da-484">Note that the <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> property is read-only.</span></span> <span data-ttu-id="da2da-485">W związku z tym nie można ustawić, aby wymusić zachowanie inicjalizacji.</span><span class="sxs-lookup"><span data-stu-id="da2da-485">Therefore, you cannot set it to force initialization behavior that way.</span></span> <span data-ttu-id="da2da-486">Ustawienie inicjacji jest przeznaczone do wykonania tylko przez [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] platformę.</span><span class="sxs-lookup"><span data-stu-id="da2da-486">Initialization setting is intended to be done only by the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkContentElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="da2da-487">Dane zdarzenia opisujące modyfikowaną właściwość, w tym stare i nowe wartości.</span><span class="sxs-lookup"><span data-stu-id="da2da-487">The event data that describes the property that changed, including the old and new values.</span></span></param>
        <summary><span data-ttu-id="da2da-488">Wywoływana za każdym razem, gdy wartość skuteczna każdej właściwości <see cref="T:System.Windows.FrameworkContentElement" /> zależności na tej stronie została zaktualizowana.</span><span class="sxs-lookup"><span data-stu-id="da2da-488">Invoked whenever the effective value of any dependency property on this <see cref="T:System.Windows.FrameworkContentElement" /> has been updated.</span></span> <span data-ttu-id="da2da-489">Określona właściwość zależności, która została zmieniona, jest raportowana w parametrze argumenty.</span><span class="sxs-lookup"><span data-stu-id="da2da-489">The specific dependency property that changed is reported in the arguments parameter.</span></span> <span data-ttu-id="da2da-490">Zastąpień <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</span><span class="sxs-lookup"><span data-stu-id="da2da-490">Overrides <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-491">Ta metoda nie jest przeznaczona do ogólnego wykrywania zmian właściwości lub Unieważnień.</span><span class="sxs-lookup"><span data-stu-id="da2da-491">This method is not intended to generally detect property changes or invalidations.</span></span> <span data-ttu-id="da2da-492">Zamiast tego jest przeznaczony do modyfikacji ogólnego wzorca unieważnienia, jeśli pewne informacje są znane o szerokiej klasyfikacji właściwości.</span><span class="sxs-lookup"><span data-stu-id="da2da-492">It is instead intended for modifications of the general invalidation pattern if certain information is known about wide classifications of properties.</span></span>  
  
 <span data-ttu-id="da2da-493">Ta metoda jest potencjalnie wywoływana wiele razy w okresie istnienia obiektu.</span><span class="sxs-lookup"><span data-stu-id="da2da-493">This method is potentially invoked many times during the life of an object.</span></span> <span data-ttu-id="da2da-494">W związku z tym można osiągnąć lepszą wydajność w przypadku zastąpienia metadanych określonych właściwości, a następnie dołączenia <xref:System.Windows.CoerceValueCallback> lub <xref:System.Windows.PropertyChangedCallback> funkcji dla poszczególnych właściwości.</span><span class="sxs-lookup"><span data-stu-id="da2da-494">Therefore, you can achieve better performance if you override the metadata of specific properties and then attach <xref:System.Windows.CoerceValueCallback> or <xref:System.Windows.PropertyChangedCallback> functions for individual properties.</span></span> <span data-ttu-id="da2da-495">Należy jednak użyć tej metody, jeśli <xref:System.Windows.FrameworkContentElement> zawiera znaczną liczbę właściwości zależności z wartościami, lub jeśli zawiera logikę, taką jak zachowanie renderowania, które należy uruchomić ponownie dla kilku powiązanych przypadków Unieważnień właściwości.</span><span class="sxs-lookup"><span data-stu-id="da2da-495">However, you would use this method if a <xref:System.Windows.FrameworkContentElement> includes a significant number of value-interrelated dependency properties, or if it includes logic such as rendering behavior that must be rerun for several related cases of property invalidations.</span></span>  
  
 <span data-ttu-id="da2da-496">Należy zauważyć, że istnieje taka sama metoda `OnPropertyChanged` o nazwie z inną sygnaturą (typ parametru to <xref:System.ComponentModel.PropertyChangedEventArgs>), która może być wyświetlana w wielu klasach.</span><span class="sxs-lookup"><span data-stu-id="da2da-496">Note that there is an identically named `OnPropertyChanged` method with a different signature (the parameter type is <xref:System.ComponentModel.PropertyChangedEventArgs>) that can appear on a number of classes.</span></span> <span data-ttu-id="da2da-497">Jest używany do powiadomień obiektów danych i jest częścią kontraktu dla <xref:System.ComponentModel.INotifyPropertyChanged>. `OnPropertyChanged`</span><span class="sxs-lookup"><span data-stu-id="da2da-497">That `OnPropertyChanged` is used for data object notifications, and is part of the contract for <xref:System.ComponentModel.INotifyPropertyChanged>.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="da2da-498">Zawsze Wywołaj implementację podstawową, jako pierwszą operację w implementacji.</span><span class="sxs-lookup"><span data-stu-id="da2da-498">Always call the base implementation, as the first operation in your implementation.</span></span> <span data-ttu-id="da2da-499">Niewykonanie tej czynności spowoduje znacząco wyłączenie całego [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] systemu właściwości, co spowoduje zgłoszenie nieprawidłowych wartości.</span><span class="sxs-lookup"><span data-stu-id="da2da-499">Failure to do this will significantly disable the entire [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system, which causes incorrect values to be reported.</span></span></para></block>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkContentElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle"><span data-ttu-id="da2da-500">Stary styl.</span><span class="sxs-lookup"><span data-stu-id="da2da-500">The old style.</span></span></param>
        <param name="newStyle"><span data-ttu-id="da2da-501">Nowy styl.</span><span class="sxs-lookup"><span data-stu-id="da2da-501">The new style.</span></span></param>
        <summary><span data-ttu-id="da2da-502">Wywoływana, gdy styl używany przez ten element zostanie zmieniony.</span><span class="sxs-lookup"><span data-stu-id="da2da-502">Invoked when the style that is in use on this element changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-503">Ta metoda ma implementację domyślną, która ustawia wewnętrzną flagę zwracającą warunek zmiany stylu.</span><span class="sxs-lookup"><span data-stu-id="da2da-503">This method has a default implementation that sets an internal flag noting the style changed condition.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="da2da-504">Zawsze Wywołaj implementację podstawową, w przeciwnym razie nie można zastosować stylów.</span><span class="sxs-lookup"><span data-stu-id="da2da-504">Always call the base implementation, otherwise styles cannot be applied.</span></span> <span data-ttu-id="da2da-505">Scenariusze przesłaniania tej metody mogą obejmować, jeśli Klasa pochodna ma wyspecjalizowany selektor stylów lub buforuje wartości stylu.</span><span class="sxs-lookup"><span data-stu-id="da2da-505">Scenarios for overriding this method might include if your derived class has a specialized style selector, or caches style values.</span></span> <span data-ttu-id="da2da-506">Zmiany motywu będą potencjalnie wywoływały tę metodę.</span><span class="sxs-lookup"><span data-stu-id="da2da-506">Theme changes will potentially invoke this method.</span></span></para></block>
        <altmember cref="P:System.Windows.FrameworkContentElement.Style" />
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="da2da-507">Zawiera dane dotyczące zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="da2da-507">Provides data about the event.</span></span></param>
        <summary><span data-ttu-id="da2da-508">Wywoływana za każdym <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> razem, gdy zdarzenie kierowane osiągnie tę klasę w swojej trasie.</span><span class="sxs-lookup"><span data-stu-id="da2da-508">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> routed event reaches this class in its route.</span></span> <span data-ttu-id="da2da-509">Zaimplementuj tę metodę, aby dodać obsługę klasy dla tego zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="da2da-509">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-510">Ta metoda nie ma domyślnej implementacji.</span><span class="sxs-lookup"><span data-stu-id="da2da-510">This method has no default implementation.</span></span> <span data-ttu-id="da2da-511">Należy nadal wywoływać metodę Base () w przypadku, gdy Klasa pośrednicząca w dziedziczeniu zaimplementował tę metody.</span><span class="sxs-lookup"><span data-stu-id="da2da-511">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="da2da-512">Celem tej metody jest nieco podobna do wzorca zdarzeń [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] w odniesieniu do \* metod: udostępnia metodę do obsługi pasującego zdarzenia z klas pochodnych z obsługą klasy zamiast programu obsługi wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="da2da-512">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="da2da-513">W takim przypadku zdarzenie dopasowywania jest zdarzeniem kierowanym.</span><span class="sxs-lookup"><span data-stu-id="da2da-513">In this case the matching event is a routed event.</span></span> <span data-ttu-id="da2da-514">Wzorzec implementacji metod on \* jest różny w przypadku zdarzeń kierowanych, ponieważ zdarzenie kierowane mogło zostać zgłoszone przez element podrzędny, niekoniecznie element, który wywoła programy obsługi, więc implementacja będzie musiała przyjmować argumenty zdarzenia "Źródło". właściwości do konta (i nie powinny próbować ponownie podnieść zdarzenia w większości przypadków).</span><span class="sxs-lookup"><span data-stu-id="da2da-514">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="da2da-515">Podklasy <xref:System.Windows.FrameworkContentElement> mogą wybierać wywołania metod obsługi klasy prywatnej, gdy zdarzenie jest odbierane wzdłuż trasy.</span><span class="sxs-lookup"><span data-stu-id="da2da-515">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="da2da-516">Jednym z potencjalnych scenariuszy jest przejęcie argumentów zdarzenia i celowe oznaczenie zdarzenia jako obsłużonego w celu skrócenia trasy.</span><span class="sxs-lookup"><span data-stu-id="da2da-516">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="da2da-517">Zawiera dane dotyczące zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="da2da-517">Provides data about the event.</span></span></param>
        <summary><span data-ttu-id="da2da-518">Wywoływana za każdym <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> razem, gdy zdarzenie kierowane osiągnie tę klasę w swojej trasie.</span><span class="sxs-lookup"><span data-stu-id="da2da-518">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> routed event reaches this class in its route.</span></span> <span data-ttu-id="da2da-519">Zaimplementuj tę metodę, aby dodać obsługę klasy dla tego zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="da2da-519">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-520">Ta metoda nie ma domyślnej implementacji.</span><span class="sxs-lookup"><span data-stu-id="da2da-520">This method has no default implementation.</span></span> <span data-ttu-id="da2da-521">Należy nadal wywoływać metodę Base () w przypadku, gdy Klasa pośrednicząca w dziedziczeniu zaimplementował tę metody.</span><span class="sxs-lookup"><span data-stu-id="da2da-521">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="da2da-522">Celem tej metody jest nieco podobna do wzorca zdarzeń [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] w odniesieniu do \* metod: udostępnia metodę do obsługi pasującego zdarzenia z klas pochodnych z obsługą klasy zamiast programu obsługi wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="da2da-522">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="da2da-523">W takim przypadku zdarzenie dopasowywania jest zdarzeniem kierowanym.</span><span class="sxs-lookup"><span data-stu-id="da2da-523">In this case the matching event is a routed event.</span></span> <span data-ttu-id="da2da-524">Wzorzec implementacji metod on \* jest różny dla zdarzeń kierowanych, ponieważ zdarzenie kierowane mogło zostać zgłoszone przez element podrzędny, niekoniecznie jest to element, który wywoła programy obsługi, więc implementacja będzie musiała mieć wartość "Źródło" argumentów zdarzeń właściwości do konta (i nie powinny próbować ponownie podnieść zdarzenia w większości przypadków).</span><span class="sxs-lookup"><span data-stu-id="da2da-524">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="da2da-525">Podklasy <xref:System.Windows.FrameworkContentElement> mogą wybierać wywołania metod obsługi klasy prywatnej, gdy zdarzenie jest odbierane wzdłuż trasy.</span><span class="sxs-lookup"><span data-stu-id="da2da-525">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="da2da-526">Jednym z potencjalnych scenariuszy jest przejęcie argumentów zdarzenia i celowe oznaczenie zdarzenia jako obsłużonego w celu skrócenia trasy.</span><span class="sxs-lookup"><span data-stu-id="da2da-526">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-527">Pobiera lub ustawia wartość wskazującą, czy ten element zawiera właściwości stylu motywu.</span><span class="sxs-lookup"><span data-stu-id="da2da-527">Gets or sets a value indicating whether this element incorporates style properties from theme styles.</span></span></summary>
        <value><span data-ttu-id="da2da-528"><see langword="true" />Jeśli ten element nie używa właściwości stylu motywu; wszystkie właściwości pochodzące z stylu pochodzą ze stylów aplikacji lokalnych, a właściwości stylu motywu nie są stosowane.</span><span class="sxs-lookup"><span data-stu-id="da2da-528"><see langword="true" /> if this element does not use theme style properties; all style-originating properties come from local application styles, and theme style properties do not apply.</span></span> <span data-ttu-id="da2da-529"><see langword="false" />Jeśli style aplikacji są stosowane w pierwszej kolejności, a następnie style motywu stosują się do właściwości, które nie zostały jawnie ustawione w stylach aplikacji.</span><span class="sxs-lookup"><span data-stu-id="da2da-529"><see langword="false" /> if application styles apply first, and then theme styles apply for properties that were not specifically set in application styles.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-530">Najbardziej typowym użyciem tej właściwości jest pośrednie użycie w metodzie ustawiającej stylu, który dostarcza styl z motywem.</span><span class="sxs-lookup"><span data-stu-id="da2da-530">The most common usage of this property is an indirect usage within the setter of a style that is supplying a themed style.</span></span>  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="da2da-531">Informacje dotyczące właściwości zależności</span><span class="sxs-lookup"><span data-stu-id="da2da-531">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="da2da-532">Pole identyfikatora</span><span class="sxs-lookup"><span data-stu-id="da2da-532">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|  
|<span data-ttu-id="da2da-533">Właściwości metadanych ustawione na`true`</span><span class="sxs-lookup"><span data-stu-id="da2da-533">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-534">Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /> zależności.</span><span class="sxs-lookup"><span data-stu-id="da2da-534">Identifies the <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-535">Pobiera element nadrzędny w drzewie logicznym dla tego elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-535">Gets the parent in the logical tree for this element.</span></span></summary>
        <value><span data-ttu-id="da2da-536">Logiczny element nadrzędny dla tego elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-536">The logical parent for this element.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-537">Należy zauważyć, że logiczny element nadrzędny elementu może ulec zmianie w zależności od funkcjonalności aplikacji i utrzymywania wartości tej właściwości nie będzie odzwierciedlała tej zmiany.</span><span class="sxs-lookup"><span data-stu-id="da2da-537">Note that the logical parent of an element can potentially change depending on your application functionality, and keeping the value of this property will not reflect that change.</span></span> <span data-ttu-id="da2da-538">Zwykle należy uzyskać wartość bezpośrednio przed jej użyciem.</span><span class="sxs-lookup"><span data-stu-id="da2da-538">You typically should get the value immediately before you need it.</span></span>  
  
 <span data-ttu-id="da2da-539">Zobacz [drzewa w WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) , aby uzyskać więcej informacji na temat przechodzenia między drzewa logiczne, oraz scenariusze, w których takie podejście odbywa się w celu odnajdywania elementów.</span><span class="sxs-lookup"><span data-stu-id="da2da-539">See [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) for more information about traversing logical trees, and the scenarios where taking this approach towards element discovery is appropriate.</span></span>  
  
 <span data-ttu-id="da2da-540">System właściwości może ponownie obliczyć wszystkie wartości właściwości elementu, gdy zostanie on oddany, ponieważ niektóre właściwości dziedziczą wartości za pomocą drzewa logicznego.</span><span class="sxs-lookup"><span data-stu-id="da2da-540">The property system will potentially recalculate all property values of an element when it is reparented, because some properties inherit values through the logical tree.</span></span> <span data-ttu-id="da2da-541">Obiekt <xref:System.Windows.FrameworkContentElement.DataContext%2A> , który ma zastosowanie do powiązań, również zmienia się w przypadku zmiany elementów nadrzędnych.</span><span class="sxs-lookup"><span data-stu-id="da2da-541">The <xref:System.Windows.FrameworkContentElement.DataContext%2A> that applies for bindings can also change when elements are reparented.</span></span>  
  
 <span data-ttu-id="da2da-542">Zmiana elementu nadrzędnego jest zazwyczaj wykonywane tylko przez manipulowanie kolekcjami przy użyciu dedykowanych metod dodawania lub usuwania lub ustawiania właściwości zawartości elementów.</span><span class="sxs-lookup"><span data-stu-id="da2da-542">Changing an element's parent is typically only done through manipulation of collections, by using dedicated add or remove methods, or through setting content properties of elements.</span></span>  
  
 <span data-ttu-id="da2da-543">Najbardziej typowym scenariuszem użycia <xref:System.Windows.FrameworkContentElement.Parent%2A> właściwości jest uzyskanie odwołania, a następnie uzyskanie różnych <xref:System.Windows.FrameworkContentElement> wartości właściwości z elementu nadrzędnego.</span><span class="sxs-lookup"><span data-stu-id="da2da-543">The most typical scenario for using the <xref:System.Windows.FrameworkContentElement.Parent%2A> property is to obtain a reference and then get various <xref:System.Windows.FrameworkContentElement> property values from the parent.</span></span> <span data-ttu-id="da2da-544">W przypadku szablonów `null`zostanie <xref:System.Windows.FrameworkContentElement.Parent%2A> ostatecznie zadany szablon.</span><span class="sxs-lookup"><span data-stu-id="da2da-544">For templates, the <xref:System.Windows.FrameworkContentElement.Parent%2A> of the template eventually will be `null`.</span></span> <span data-ttu-id="da2da-545">Aby przejść do poprzedniego punktu i przekroczyć Drzewo logiczne, w którym faktycznie zastosowano szablon, <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>Użyj.</span><span class="sxs-lookup"><span data-stu-id="da2da-545">To get past this point and extend into the logical tree where the template is actually applied, use <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="da2da-546">Poniższy przykład sprawdza, <xref:System.Windows.FrameworkContentElement.Parent%2A> czy element a <xref:System.Windows.Documents.TextPointer> jest określonego typu.</span><span class="sxs-lookup"><span data-stu-id="da2da-546">The following example checks to see whether the <xref:System.Windows.FrameworkContentElement.Parent%2A> of a <xref:System.Windows.Documents.TextPointer> is of a particular type.</span></span>  
  
 [!code-csharp[TextPointer_snippets#FCEParent](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#fceparent)]
 [!code-vb[TextPointer_snippets#FCEParent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#fceparent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction"><span data-ttu-id="da2da-547">Kierunek, dla którego należy określić potencjalną zmianę fokusu.</span><span class="sxs-lookup"><span data-stu-id="da2da-547">The direction for which a prospective focus change should be determined.</span></span></param>
        <summary><span data-ttu-id="da2da-548">Określa następny element, który będzie miał fokus względem tego elementu dla podanego kierunku przenoszenia fokusu, ale nie przesuwa fokusu.</span><span class="sxs-lookup"><span data-stu-id="da2da-548">Determines the next element that would receive focus relative to this element for a provided focus movement direction, but does not actually move the focus.</span></span> <span data-ttu-id="da2da-549">Ta metoda jest zapieczętowana i nie może zostać przesłonięta.</span><span class="sxs-lookup"><span data-stu-id="da2da-549">This method is sealed and cannot be overridden.</span></span></summary>
        <returns><span data-ttu-id="da2da-550">Następny element, który koncentruje się na tym, jeśli fokus został rzeczywiście przesunięty.</span><span class="sxs-lookup"><span data-stu-id="da2da-550">The next element that focus would move to if focus were actually traversed.</span></span> <span data-ttu-id="da2da-551">Może zwracać <see langword="null" /> , jeśli fokus nie może zostać przeniesiony względem tego elementu dla danego kierunku.</span><span class="sxs-lookup"><span data-stu-id="da2da-551">May return <see langword="null" /> if focus cannot be moved relative to this element for the provided direction.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-552"><xref:System.Windows.FrameworkContentElement.MoveFocus%2A>jest pokrewną metodą, która rzeczywiście przenosi fokus.</span><span class="sxs-lookup"><span data-stu-id="da2da-552"><xref:System.Windows.FrameworkContentElement.MoveFocus%2A> is the related method that actually does move focus.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="da2da-553">Określono <see cref="T:System.Windows.Input.TraversalRequest" />jeden z następujących kierunków w: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />.</span><span class="sxs-lookup"><span data-stu-id="da2da-553">Specified one of the following directions in the <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />.</span></span> <span data-ttu-id="da2da-554">Te wskazówki nie są prawne dla <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> programu (ale są prawne dla <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</span><span class="sxs-lookup"><span data-stu-id="da2da-554">These directions are not legal for <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (but they are legal for <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkContentElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="da2da-555">Nazwa do użycia dla określonego mapowania nazwa-obiekt.</span><span class="sxs-lookup"><span data-stu-id="da2da-555">Name to use for the specified name-object mapping.</span></span></param>
        <param name="scopedElement"><span data-ttu-id="da2da-556">Obiekt mapowania.</span><span class="sxs-lookup"><span data-stu-id="da2da-556">Object for the mapping.</span></span></param>
        <summary><span data-ttu-id="da2da-557">Zapewnia metodę dostępu, która upraszcza dostęp do <see cref="T:System.Windows.NameScope" /> metody rejestracji.</span><span class="sxs-lookup"><span data-stu-id="da2da-557">Provides an accessor that simplifies access to the <see cref="T:System.Windows.NameScope" /> registration method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-558">Ta metoda jest wygodną metodą wywoływania <xref:System.Windows.NameScope.RegisterName%2A>.</span><span class="sxs-lookup"><span data-stu-id="da2da-558">This method is a convenience method for calling <xref:System.Windows.NameScope.RegisterName%2A>.</span></span> <span data-ttu-id="da2da-559">Implementacja sprawdzi kolejne elementy nadrzędne do momentu znalezienia odpowiedniej <xref:System.Windows.NameScope> implementacji, która jest znaleziona przez znalezienie elementu, który implementuje. <xref:System.Windows.Markup.INameScope></span><span class="sxs-lookup"><span data-stu-id="da2da-559">The implementation will check successive parent elements until it finds the applicable <xref:System.Windows.NameScope> implementation, which is found by finding an element that implements <xref:System.Windows.Markup.INameScope>.</span></span> <span data-ttu-id="da2da-560">Aby uzyskać więcej informacji na temat zakresy nazw WPF, zobacz [WPF XAML Zakresy nazw WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).</span><span class="sxs-lookup"><span data-stu-id="da2da-560">For more information about namescopes, see [WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).</span></span>  
  
 <span data-ttu-id="da2da-561">Wywołanie <xref:System.Windows.FrameworkContentElement.RegisterName%2A> jest niezbędne w celu poprawnego podłączania scenorysów animacji dla aplikacji tworzonych w kodzie.</span><span class="sxs-lookup"><span data-stu-id="da2da-561">Calling <xref:System.Windows.FrameworkContentElement.RegisterName%2A> is necessary in order to correctly hook up animation storyboards for applications when created in code.</span></span> <span data-ttu-id="da2da-562">Wynika to z faktu, że jedna z właściwości <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>klucza scenorysu, używa wyszukiwania nazw w czasie wykonywania, zamiast można wykonać odwołanie do elementu docelowego.</span><span class="sxs-lookup"><span data-stu-id="da2da-562">This is because one of the key storyboard properties, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, uses a run-time name lookup instead of being able to take a reference to a target element.</span></span> <span data-ttu-id="da2da-563">Jest to prawdziwe, nawet jeśli ten element jest dostępny przez odwołanie z kodu.</span><span class="sxs-lookup"><span data-stu-id="da2da-563">This is true even if that element is accessible by reference from the code.</span></span> <span data-ttu-id="da2da-564">Aby uzyskać więcej informacji na temat tego, dlaczego należy zarejestrować nazwy dla obiektów docelowych scenorysów, zobacz [Omówienie scenorysów](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span><span class="sxs-lookup"><span data-stu-id="da2da-564">For more information on why you need to register names for storyboard targets, see [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span></span> <span data-ttu-id="da2da-565">Animacje dla elementów zawartości są mniej typowe niż animacje w kontrolkach. [Przegląd scenorysów](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md) koncentruje się na scenariuszach kontroli.</span><span class="sxs-lookup"><span data-stu-id="da2da-565">Animations for content elements are less common than animations on controls, the [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md) concentrates on control scenarios.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child"><span data-ttu-id="da2da-566">Element do usunięcia.</span><span class="sxs-lookup"><span data-stu-id="da2da-566">The element to remove.</span></span></param>
        <summary><span data-ttu-id="da2da-567">Usuwa określony element z drzewa logicznego dla tego elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-567">Removes the specified element from the logical tree for this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-568">Jest [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] to szczególnie istotne w przypadku scenariuszy pochodnych klasy podczas dodawania obsługi dla kolekcji podrzędnych.</span><span class="sxs-lookup"><span data-stu-id="da2da-568">This [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] is mainly relevant for class deriving scenarios, when adding support for child collections.</span></span>  
  
 <span data-ttu-id="da2da-569">Większość <xref:System.Windows.FrameworkContentElement> klas pochodnych uwidacznia dedykowane kolekcje, które są odpowiedzialne za zawieranie ( <xref:System.Windows.Documents.Span.Inlines%2A> na przykład <xref:System.Windows.Documents.Span> w klasie; <xref:System.Windows.Documents.Section.Blocks%2A> na klasie).<xref:System.Windows.Documents.Section></span><span class="sxs-lookup"><span data-stu-id="da2da-569">Most <xref:System.Windows.FrameworkContentElement> derived classes expose dedicated collections that are responsible for containment (for example, <xref:System.Windows.Documents.Span.Inlines%2A> on the <xref:System.Windows.Documents.Span> class; <xref:System.Windows.Documents.Section.Blocks%2A> on the <xref:System.Windows.Documents.Section> class).</span></span> <span data-ttu-id="da2da-570">Wyprowadzanie z takich klas zazwyczaj może uniknąć konieczności bezpośredniego manipulowania drzewa logicznego.</span><span class="sxs-lookup"><span data-stu-id="da2da-570">Deriving from such classes typically can avoid any need to manipulate the logical tree directly.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkContentElement.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-571">Pobiera lub ustawia bieżący zdefiniowany lokalnie słownik zasobów.</span><span class="sxs-lookup"><span data-stu-id="da2da-571">Gets or sets the current locally-defined resource dictionary.</span></span></summary>
        <value><span data-ttu-id="da2da-572">Bieżące zdefiniowane lokalnie zasoby.</span><span class="sxs-lookup"><span data-stu-id="da2da-572">The current locally-defined resources.</span></span> <span data-ttu-id="da2da-573">Jest to słownik zasobów, w przypadku których zasoby w słowniku są dostępne za pomocą klucza.</span><span class="sxs-lookup"><span data-stu-id="da2da-573">This is a dictionary of resources, where resources within the dictionary are accessed by key.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-574">Słowniki zasobów, które mogą być zdefiniowane w całości [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] lub częściowo w programie, są zwykle tworzone jako element właściwości i zazwyczaj znajdują się na elemencie głównym dla każdej pojedynczej strony lub aplikacji.</span><span class="sxs-lookup"><span data-stu-id="da2da-574">Resource dictionaries that can be defined completely or partially in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] are typically created as a property element, and are typically on the root element for any individual page or for the application.</span></span> <span data-ttu-id="da2da-575">Umieszczenie słownika zasobów na tym poziomie ułatwia znalezienie poszczególnych elementów podrzędnych na stronie (lub z dowolnej strony w przypadku aplikacji).</span><span class="sxs-lookup"><span data-stu-id="da2da-575">Placing the resource dictionary at this level makes it easier to find from individual child elements in the page (or from any page, in the application case).</span></span> <span data-ttu-id="da2da-576">W większości scenariuszy aplikacji zaleca się zdefiniowanie stylów jako elementów obiektów w słowniku zasobów lub zdefiniowanie ich jako zasobów zewnętrznych, aby cały zasób stylu mógł być niezależny (to podejście ułatwia oddzielny Projektant obowiązki z obowiązków deweloperów przez oddzielenie plików fizycznych, które należy edytować).</span><span class="sxs-lookup"><span data-stu-id="da2da-576">In most application scenarios, we recommend that styles be defined as object elements within a resource dictionary, or be defined as external resources so that the entire style resource can be self-contained (this approach helps separate designer responsibilities from developer responsibilities by separating the physical files that need to be edited).</span></span>  
  
 <span data-ttu-id="da2da-577">Należy zauważyć, że ta właściwość zwraca tylko słownik zasobów zadeklarowany bezpośrednio w tym elemencie.</span><span class="sxs-lookup"><span data-stu-id="da2da-577">Note that this property returns only the resource dictionary declared directly within that element.</span></span> <span data-ttu-id="da2da-578">Jest to inny niż rzeczywisty proces wyszukiwania zasobów, gdzie element podrzędny może uzyskać dostęp do dowolnego zasobu zdefiniowanego w każdym elemencie nadrzędnym, co umożliwia cykliczne wyszukiwanie w górę.</span><span class="sxs-lookup"><span data-stu-id="da2da-578">This is different than the actual resource lookup process, where a child element can access any of the resources defined in each parent element, searching recursively upwards.</span></span>  
  
 <span data-ttu-id="da2da-579">Do zasobów można także odwoływać się za pomocą kodu z kolekcji, ale należy pamiętać, że zasoby [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] utworzone w programie nie będą dostępne <xref:System.Windows.FrameworkContentElement.Loaded> do momentu zgłoszenia przez element, który deklaruje słownik.</span><span class="sxs-lookup"><span data-stu-id="da2da-579">Resources can also be referenced by code from within the collection, but be aware that resources created in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] will definitely not be accessible until after <xref:System.Windows.FrameworkContentElement.Loaded> is raised by the element that declares the dictionary.</span></span> <span data-ttu-id="da2da-580">W rzeczywistości zasoby są analizowane asynchronicznie, a nawet <xref:System.Windows.FrameworkContentElement.Loaded> nie jest to gwarantowane, że można odwołać się do [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] określonego zasobu.</span><span class="sxs-lookup"><span data-stu-id="da2da-580">In fact, resources are parsed asynchronously, and not even the <xref:System.Windows.FrameworkContentElement.Loaded> event is an assurance that you can reference a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] defined resource.</span></span> <span data-ttu-id="da2da-581">Z tego powodu zazwyczaj należy uzyskać dostęp do [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] określonych zasobów tylko w ramach kodu czasu wykonywania lub za innymi [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] technikami, takimi jak style lub odwołania do rozszerzenia zasobu dla wartości atrybutów.</span><span class="sxs-lookup"><span data-stu-id="da2da-581">For this reason you should generally only access [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] defined resources as part of run-time code, or through other [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] techniques such as styles or resource extension references for attribute values.</span></span> <span data-ttu-id="da2da-582">Gdy uzyskujesz dostęp do zasobów za pośrednictwem kodu, jest to [](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) zasadniczo równoważne z DynamicResource — [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]odwołaniem z.</span><span class="sxs-lookup"><span data-stu-id="da2da-582">When you access resources through code, it is essentially equivalent to a [DynamicResource](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) reference made from [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 <span data-ttu-id="da2da-583">Podstawowa <xref:System.Windows.ResourceDictionary> obsługa metod wymaganych do dodawania, usuwania lub wykonywania zapytań dotyczących zasobów w kolekcji przy użyciu kodu.</span><span class="sxs-lookup"><span data-stu-id="da2da-583">The underlying <xref:System.Windows.ResourceDictionary> supports the methods required to add, remove, or query resources from within the collection by using code.</span></span> <span data-ttu-id="da2da-584">Właściwość jest settable, aby obsługiwać scenariusz całkowitego zastąpienia kolekcji Resources elementu, aby była nową lub inną <xref:System.Windows.ResourceDictionary>. <xref:System.Windows.FrameworkContentElement.Resources%2A></span><span class="sxs-lookup"><span data-stu-id="da2da-584">The <xref:System.Windows.FrameworkContentElement.Resources%2A> property is settable to support the scenario of completely replacing the resources collection of an element to be a new or different <xref:System.Windows.ResourceDictionary>.</span></span>  
  
 <span data-ttu-id="da2da-585">Zauważ, że [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] pokazana składnia nie zawiera elementu <xref:System.Windows.ResourceDictionary>dla.</span><span class="sxs-lookup"><span data-stu-id="da2da-585">Notice that the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax shown does not include an element for the <xref:System.Windows.ResourceDictionary>.</span></span> <span data-ttu-id="da2da-586">Jest to przykład niejawnej składni kolekcji; Tag reprezentujący element kolekcji można pominąć.</span><span class="sxs-lookup"><span data-stu-id="da2da-586">This is an example of implicit collection syntax; a tag representing the collection element can be omitted.</span></span> <span data-ttu-id="da2da-587">Zamiast tego można określić elementy, które są dodawane jako elementy do kolekcji.</span><span class="sxs-lookup"><span data-stu-id="da2da-587">The elements that are added as items to the collection are specified instead.</span></span> <span data-ttu-id="da2da-588">Aby uzyskać więcej informacji na temat kolekcji [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]niejawnych i, zobacz [Szczegóły składni XAML](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="da2da-588">For more information about implicit collections and [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], see [XAML Syntax In Detail](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="da2da-589">Jeden przypadek, w <xref:System.Windows.ResourceDictionary> którym jest w dalszym ciągu jawnie określony jako element, jeśli wprowadzasz scalony słownik, w którym to przypadku zazwyczaj nie ma elementów podrzędnych <xref:System.Windows.ResourceDictionary>dla tego elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-589">One case where a <xref:System.Windows.ResourceDictionary> is still specified explicitly as an element is if you are introducing a merged dictionary, in which case there are typically no child elements for that <xref:System.Windows.ResourceDictionary>.</span></span> <span data-ttu-id="da2da-590">Aby uzyskać szczegółowe informacje, zobacz [scalone słowniki zasobów](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).</span><span class="sxs-lookup"><span data-stu-id="da2da-590">For details, see [Merged Resource Dictionaries](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).</span></span>  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="da2da-591">Użycie elementu właściwości języka XAML</span><span class="sxs-lookup"><span data-stu-id="da2da-591">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a><span data-ttu-id="da2da-592">Wartości XAML</span><span class="sxs-lookup"><span data-stu-id="da2da-592">XAML Values</span></span>  
 <span data-ttu-id="da2da-593">*oneOrMoreResourceElements*</span><span class="sxs-lookup"><span data-stu-id="da2da-593">*oneOrMoreResourceElements*</span></span>  
 <span data-ttu-id="da2da-594">Jeden lub więcej elementów obiektów, z których każdy definiuje zasób.</span><span class="sxs-lookup"><span data-stu-id="da2da-594">One or more object elements, each of which defines a resource.</span></span> <span data-ttu-id="da2da-595">Każdy element właściwości zasobu w ramach <xref:System.Windows.ResourceDictionary> każdej z nich musi mieć unikatową wartość dla [dyrektywy x:Key](~/docs/framework/xaml-services/x-key-directive.md), która służy jako unikatowy klucz, gdy wartości <xref:System.Windows.ResourceDictionary>są pobierane z.</span><span class="sxs-lookup"><span data-stu-id="da2da-595">Each resource property element within each <xref:System.Windows.ResourceDictionary> must have a unique value for the [x:Key Directive](~/docs/framework/xaml-services/x-key-directive.md), which serves as the unique key when values are retrieved from the <xref:System.Windows.ResourceDictionary>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="da2da-596">Poniższy przykład ustanawia <xref:System.Windows.FrameworkContentElement.Resources%2A> kolekcję <xref:System.Windows.Documents.FlowDocument> na elemencie głównym.</span><span class="sxs-lookup"><span data-stu-id="da2da-596">The following example establishes a <xref:System.Windows.FrameworkContentElement.Resources%2A> collection on a <xref:System.Windows.Documents.FlowDocument> root element.</span></span> <span data-ttu-id="da2da-597"><xref:System.Windows.Documents.FlowDocument>jest typową opcją, ponieważ jest jedną z kilku <xref:System.Windows.FrameworkContentElement> klas, które mają sens jako element główny, a zasoby są zwykle przechowywane w katalogu głównym strony lub nawet na wyższych poziomach, takich jak w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="da2da-597"><xref:System.Windows.Documents.FlowDocument> is a typical choice because it is one of the few <xref:System.Windows.FrameworkContentElement> classes that make sense as a root element, and resources are generally stored at the page root or at even higher levels such as in the application.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="da2da-598">Dołącza powiązanie do tego elementu dla określonej właściwości zależności.</span><span class="sxs-lookup"><span data-stu-id="da2da-598">Attaches a binding to this element for the specified dependency property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="da2da-599">Identyfikuje właściwość powiązaną.</span><span class="sxs-lookup"><span data-stu-id="da2da-599">Identifies the bound property.</span></span></param>
        <param name="path"><span data-ttu-id="da2da-600">Nazwa właściwości źródłowej lub ścieżka do właściwości użytej dla powiązania.</span><span class="sxs-lookup"><span data-stu-id="da2da-600">The source property name or the path to the property used for the binding.</span></span></param>
        <summary><span data-ttu-id="da2da-601">Dołącza powiązanie do tego elementu, na podstawie podanej nazwy właściwości źródłowej jako ścieżki kwalifikacji do źródła danych.</span><span class="sxs-lookup"><span data-stu-id="da2da-601">Attaches a binding to this element, based on the provided source property name as a path qualification to the data source.</span></span></summary>
        <returns><span data-ttu-id="da2da-602">Rejestruje warunki powiązania.</span><span class="sxs-lookup"><span data-stu-id="da2da-602">Records the conditions of the binding.</span></span> <span data-ttu-id="da2da-603">Ta wartość zwracana może być przydatna do sprawdzania błędów.</span><span class="sxs-lookup"><span data-stu-id="da2da-603">This return value can be useful for error checking.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-604">Ta <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>Metoda jest wygodną metodą wywołania, która przekazuje bieżące wystąpienie <xref:System.Windows.DependencyObject>jako i tworzy nowy <xref:System.Windows.Data.Binding> na podstawie podanego `path` parametru.</span><span class="sxs-lookup"><span data-stu-id="da2da-604">This method is a convenience method for calling <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, which passes the current instance as the <xref:System.Windows.DependencyObject>, and creates a new <xref:System.Windows.Data.Binding> based on the provided `path` parameter.</span></span> <span data-ttu-id="da2da-605">Ten podpis jest wygodniejszy, jeśli tworzysz proste domyślne powiązanie.</span><span class="sxs-lookup"><span data-stu-id="da2da-605">This signature is more convenient if you are establishing a simple default binding.</span></span> <span data-ttu-id="da2da-606">Jeśli musisz określić dowolne właściwości powiązania z warunkami niedomyślnymi lub chcesz użyć <xref:System.Windows.Data.MultiBinding> lub <xref:System.Windows.Data.PriorityBinding> <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> , należy użyć podpisu.</span><span class="sxs-lookup"><span data-stu-id="da2da-606">If you need to specify any binding properties to non-default conditions, or want to use a <xref:System.Windows.Data.MultiBinding> or <xref:System.Windows.Data.PriorityBinding>,you should use the <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> signature.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="da2da-607">Poniższy przykład ustawia powiązanie dla <xref:System.Windows.Documents.Paragraph> elementu, tworząc nowy obiekt danych niestandardowych, ustanawiając ten obiekt jako <xref:System.Windows.FrameworkContentElement.DataContext%2A>i ustawiając ścieżkę powiązania do właściwości w tym elemencie.</span><span class="sxs-lookup"><span data-stu-id="da2da-607">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as <xref:System.Windows.FrameworkContentElement.DataContext%2A>, and setting the binding path to a property within it.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkContentElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="da2da-608">Identyfikuje właściwość powiązaną.</span><span class="sxs-lookup"><span data-stu-id="da2da-608">Identifies the bound property.</span></span></param>
        <param name="binding"><span data-ttu-id="da2da-609">Reprezentuje powiązanie danych.</span><span class="sxs-lookup"><span data-stu-id="da2da-609">Represents a data binding.</span></span></param>
        <summary><span data-ttu-id="da2da-610">Dołącza powiązanie do tego elementu na podstawie podanego obiektu powiązania.</span><span class="sxs-lookup"><span data-stu-id="da2da-610">Attaches a binding to this element, based on the provided binding object.</span></span></summary>
        <returns><span data-ttu-id="da2da-611">Rejestruje warunki powiązania.</span><span class="sxs-lookup"><span data-stu-id="da2da-611">Records the conditions of the binding.</span></span> <span data-ttu-id="da2da-612">Ta wartość zwracana może być przydatna do sprawdzania błędów.</span><span class="sxs-lookup"><span data-stu-id="da2da-612">This return value can be useful for error checking.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-613">Ta metoda jest wygodną metodą wywołania <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, która przekazuje bieżące wystąpienie <xref:System.Windows.DependencyObject>jako.</span><span class="sxs-lookup"><span data-stu-id="da2da-613">This method is a convenience method for calling <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, which passes the current instance as the <xref:System.Windows.DependencyObject>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="da2da-614">Poniższy przykład ustawia powiązanie dla <xref:System.Windows.Documents.Paragraph> elementu, tworząc nowe <xref:System.Windows.Data.Binding> i ustawiając Źródło dla nowo skompilowanego `DateTime` obiektu.</span><span class="sxs-lookup"><span data-stu-id="da2da-614">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new <xref:System.Windows.Data.Binding> and setting the source to a newly built `DateTime` object.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#setbinding)]
 [!code-vb[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#setbinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkContentElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="da2da-615">Właściwość, z którą jest powiązany zasób.</span><span class="sxs-lookup"><span data-stu-id="da2da-615">The property to which the resource is bound.</span></span></param>
        <param name="name"><span data-ttu-id="da2da-616">Nazwa zasobu.</span><span class="sxs-lookup"><span data-stu-id="da2da-616">The name of the resource.</span></span></param>
        <summary><span data-ttu-id="da2da-617">Wyszukuje zasób o określonej nazwie i konfiguruje odwołanie do zasobu dla określonej właściwości.</span><span class="sxs-lookup"><span data-stu-id="da2da-617">Searches for a resource with the specified name and sets up a resource reference to it for the specified property.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-618">Odwołanie do zasobu jest podobne do użycia [rozszerzenia znacznika DynamicResource —](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) w znaczniku.</span><span class="sxs-lookup"><span data-stu-id="da2da-618">A resource reference is similar to the use of a [DynamicResource Markup Extension](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) in markup.</span></span> <span data-ttu-id="da2da-619">Odwołanie do zasobu tworzy wyrażenie wewnętrzne, które dostarcza wartość określonej właściwości w oparciu o odroczony czas wykonywania.</span><span class="sxs-lookup"><span data-stu-id="da2da-619">The resource reference creates an internal expression that supplies the value of the specified property on a run-time deferred basis.</span></span> <span data-ttu-id="da2da-620">Wyrażenie zostanie obliczone ponowne, gdy słownik zasobów wskazuje zmianę wartości za pomocą wewnętrznych zdarzeń, lub gdy bieżący element zostanie odtworzony jako obiekt nadrzędny (zmiana nadrzędna spowodowałaby zmianę ścieżki wyszukiwania słownika).</span><span class="sxs-lookup"><span data-stu-id="da2da-620">The expression will be re-evaluated whenever the resource dictionary indicates a changed value through internal events, or whenever the current element is reparented (a parent change would change the dictionary lookup path).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="da2da-621">Zwraca czy procesy serializacji powinny serializować zawartość <see cref="P:System.Windows.FrameworkContentElement.Resources" /> właściwości w wystąpieniach tej klasy.</span><span class="sxs-lookup"><span data-stu-id="da2da-621">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.FrameworkContentElement.Resources" /> property on instances of this class.</span></span></summary>
        <returns><span data-ttu-id="da2da-622"><see langword="true" />Jeśli wartość <see langword="false" />właściwości powinna być serializowana; w przeciwnym razie,. <see cref="P:System.Windows.FrameworkContentElement.Resources" /></span><span class="sxs-lookup"><span data-stu-id="da2da-622"><see langword="true" /> if the <see cref="P:System.Windows.FrameworkContentElement.Resources" /> property value should be serialized; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-623">Spowoduje to zwrócenie `true` tego miejsca, o ile w lokalnym <xref:System.Windows.FrameworkContentElement.Resources%2A>miejscu istnieje co najmniej jeden zasób z kluczem.</span><span class="sxs-lookup"><span data-stu-id="da2da-623">This will return `true` so long as there is at least one keyed resource in the local <xref:System.Windows.FrameworkContentElement.Resources%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="da2da-624">Zwraca czy procesy serializacji powinny serializować zawartość <see cref="P:System.Windows.FrameworkContentElement.Style" /> właściwości w wystąpieniach tej klasy.</span><span class="sxs-lookup"><span data-stu-id="da2da-624">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.FrameworkContentElement.Style" /> property on instances of this class.</span></span></summary>
        <returns><span data-ttu-id="da2da-625"><see langword="true" />Jeśli wartość <see langword="false" />właściwości powinna być serializowana; w przeciwnym razie,. <see cref="P:System.Windows.FrameworkContentElement.Style" /></span><span class="sxs-lookup"><span data-stu-id="da2da-625"><see langword="true" /> if the <see cref="P:System.Windows.FrameworkContentElement.Style" /> property value should be serialized; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-626">Spowoduje to zwrócenie `true` , <xref:System.Windows.Style> Jeśli zestaw jest ustawiony lokalnie.</span><span class="sxs-lookup"><span data-stu-id="da2da-626">This will return `true` if the <xref:System.Windows.Style> is locally set.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-627">Występuje, gdy dowolne skojarzone źródło danych uczestniczy w powiązaniu w tym elemencie zostanie zmienione.</span><span class="sxs-lookup"><span data-stu-id="da2da-627">Occurs when any associated data source participating in a binding on this element changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-628">To zdarzenie <xref:System.Windows.Data.Binding.SourceUpdated> wskazuje zdarzenie, które jest zgłaszane przez wszystkie <xref:System.Windows.Data.Binding> skojarzone z tym elementem.</span><span class="sxs-lookup"><span data-stu-id="da2da-628">This event surfaces the <xref:System.Windows.Data.Binding.SourceUpdated> event that is raised by any <xref:System.Windows.Data.Binding> associated with this element.</span></span>  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="da2da-629">Użycie atrybutu języka XAML</span><span class="sxs-lookup"><span data-stu-id="da2da-629">XAML Attribute Usage</span></span>  
  
```  
<object SourceUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-630">Pobiera lub ustawia styl, który będzie używany przez ten element.</span><span class="sxs-lookup"><span data-stu-id="da2da-630">Gets or sets the style to be used by this element.</span></span></summary>
        <value><span data-ttu-id="da2da-631">Stosowany, niedomyślny styl elementu, jeśli jest obecny.</span><span class="sxs-lookup"><span data-stu-id="da2da-631">The applied, nondefault style for the element, if present.</span></span> <span data-ttu-id="da2da-632">W przeciwnym razie. <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="da2da-632">Otherwise, <see langword="null" />.</span></span> <span data-ttu-id="da2da-633">Wartość domyślna dla konstruowanej <see cref="T:System.Windows.FrameworkContentElement" /> domyślnie to. <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="da2da-633">The default for a default-constructed <see cref="T:System.Windows.FrameworkContentElement" /> is <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-634">Bieżący styl jest często dostarczany przy użyciu stylu domyślnego z motywów lub stylów zwykle stosowanych do obiektów tego typu według zasobów na poziomie strony lub aplikacji (styl niejawny).</span><span class="sxs-lookup"><span data-stu-id="da2da-634">The current style is often provided by a default style from theming, or from styles generally applied to objects of that type by resources at page or application level (an implicit style).</span></span> <span data-ttu-id="da2da-635">Ta właściwość nie ustawia ani nie zwraca domyślnych stylów (motywu), ale zwraca styl niejawny lub jawny styl.</span><span class="sxs-lookup"><span data-stu-id="da2da-635">This property does not set or return default (theme) styles, but it does return the implicit style or an explicit style.</span></span> <span data-ttu-id="da2da-636">W przypadku niejawnych lub jawnych stylów nie ma znaczenia, czy styl jest dostępny jako zasób lub zdefiniowany lokalnie.</span><span class="sxs-lookup"><span data-stu-id="da2da-636">In the case of implicit or explicit styles, it does not matter whether the style is accessed as a resource or defined locally.</span></span>  
  
 <span data-ttu-id="da2da-637">Ustawienie stylów ma pewne ograniczenia.</span><span class="sxs-lookup"><span data-stu-id="da2da-637">Setting the styles has some restrictions.</span></span> <span data-ttu-id="da2da-638">W dowolnym momencie możesz zresetować <xref:System.Windows.FrameworkContentElement.Style%2A> całą Właściwość <xref:System.Windows.Style> , co spowoduje wymuszenie przetworzenia układu.</span><span class="sxs-lookup"><span data-stu-id="da2da-638">You can reset the entire <xref:System.Windows.FrameworkContentElement.Style%2A> property to a new <xref:System.Windows.Style> at any time, which will force a layout recomposition.</span></span> <span data-ttu-id="da2da-639">Jednakże, gdy tylko ten styl jest umieszczany przez załadowany element, <xref:System.Windows.Style> powinien być uważany za zapieczętowany.</span><span class="sxs-lookup"><span data-stu-id="da2da-639">However, as soon as that style is placed in use by a loaded element, the <xref:System.Windows.Style> should be considered sealed.</span></span> <span data-ttu-id="da2da-640">Podjęto próbę dokonania zmiany we właściwościach w stylu w użyciu (takich jak wszystkie elementy w kolekcji <xref:System.Windows.Style.Setters%2A>), co powoduje zgłoszenie wyjątku.</span><span class="sxs-lookup"><span data-stu-id="da2da-640">Attempting to make a change to any individual property of an in-use style (such as anything within the collection of <xref:System.Windows.Style.Setters%2A>) causes an exception to be thrown.</span></span> <span data-ttu-id="da2da-641">Styl zdefiniowany w znacznikach jest traktowany jako używany zaraz po załadowaniu go ze słownika zasobów (dla zasobów) lub strony, w której jest zawarty w programie, jest ładowany (dla stylów wbudowanych).</span><span class="sxs-lookup"><span data-stu-id="da2da-641">A style that is defined in markup is considered to be in use as soon as it is loaded from a resource dictionary (for resources), or the page it is contained within is loaded (for inline styles).</span></span>  
  
 <span data-ttu-id="da2da-642"><xref:System.Windows.FrameworkContentElement.Style%2A>jest właściwością zależności z specjalnym pierwszeństwem.</span><span class="sxs-lookup"><span data-stu-id="da2da-642"><xref:System.Windows.FrameworkContentElement.Style%2A> is a dependency property with special precedence.</span></span> <span data-ttu-id="da2da-643">Lokalnie ustawiony styl zazwyczaj działa przy najwyższym priorytecie w systemie właściwości.</span><span class="sxs-lookup"><span data-stu-id="da2da-643">The locally set style generally operates at the highest precedence in the property system.</span></span> <span data-ttu-id="da2da-644">Jeśli w tym momencie mawartośćnull,podczasładowaniasystemuwłaściwościsprawdzaniejawnestylejakozdefiniowanezasoby,któreokreślajątentyp.<xref:System.Windows.FrameworkContentElement.Style%2A></span><span class="sxs-lookup"><span data-stu-id="da2da-644">If the <xref:System.Windows.FrameworkContentElement.Style%2A> is null at this point, during loading the property system checks for implicit styles as defined resources that specify that type.</span></span> <span data-ttu-id="da2da-645">Jeśli styl nadal ma wartość null po wykonaniu tego kroku, styl pochodzi z domyślnego stylu (motywu), ale styl domyślny nie jest zwracany w <xref:System.Windows.FrameworkContentElement.Style%2A> wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="da2da-645">If the style is still null after this step, then the style comes from the default (theme) style, but the default style is not returned in the <xref:System.Windows.FrameworkContentElement.Style%2A> property value.</span></span> <span data-ttu-id="da2da-646">Zobacz [pierwszeństwo wartości właściwości zależności](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span><span class="sxs-lookup"><span data-stu-id="da2da-646">See [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span></span>  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="da2da-647">Użycie atrybutu języka XAML</span><span class="sxs-lookup"><span data-stu-id="da2da-647">XAML Attribute Usage</span></span>  
  
```  
<object Style="{resourceExtension StyleResourceKey}"/>  
```  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a><span data-ttu-id="da2da-648">Wartości XAML</span><span class="sxs-lookup"><span data-stu-id="da2da-648">XAML Values</span></span>  
 <span data-ttu-id="da2da-649">*resourceExtension*</span><span class="sxs-lookup"><span data-stu-id="da2da-649">*resourceExtension*</span></span>  
 <span data-ttu-id="da2da-650">Jeden z następujących elementów:, lub.</span><span class="sxs-lookup"><span data-stu-id="da2da-650">One of the following: , or .</span></span> <span data-ttu-id="da2da-651">Zobacz [zasoby XAML](~/docs/framework/wpf/advanced/xaml-resources.md).</span><span class="sxs-lookup"><span data-stu-id="da2da-651">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="da2da-652">*styleResourceKey*</span><span class="sxs-lookup"><span data-stu-id="da2da-652">*styleResourceKey*</span></span>  
 <span data-ttu-id="da2da-653">Klucz, który identyfikuje żądany styl.</span><span class="sxs-lookup"><span data-stu-id="da2da-653">The key that identifies the style being requested.</span></span> <span data-ttu-id="da2da-654">Klucz odnosi się do istniejącego zasobu w <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="da2da-654">The key refers to an existing resource in a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="da2da-655">Składnia elementu właściwości jest technicznie możliwa, ale nie jest zalecana.</span><span class="sxs-lookup"><span data-stu-id="da2da-655">Property element syntax is technically possible, but not recommended.</span></span> <span data-ttu-id="da2da-656">Zobacz [wbudowane style i szablony](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span><span class="sxs-lookup"><span data-stu-id="da2da-656">See [Inline Styles and Templates](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span></span>  <span data-ttu-id="da2da-657">Odwołanie do powiązania przy użyciu [szablonu TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md) lub <xref:System.Windows.Data.Binding> jest również możliwe, ale nietypowe.</span><span class="sxs-lookup"><span data-stu-id="da2da-657">A binding reference using [TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md) or <xref:System.Windows.Data.Binding> is also possible, but uncommon.</span></span>  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="da2da-658">Informacje dotyczące właściwości zależności</span><span class="sxs-lookup"><span data-stu-id="da2da-658">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="da2da-659">Pole identyfikatora</span><span class="sxs-lookup"><span data-stu-id="da2da-659">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.StyleProperty>|  
|<span data-ttu-id="da2da-660">Właściwości metadanych ustawione na`true`</span><span class="sxs-lookup"><span data-stu-id="da2da-660">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 <span data-ttu-id="da2da-661">Poniższy przykład ustanawia <xref:System.Windows.FrameworkContentElement.Resources%2A> kolekcję <xref:System.Windows.Documents.FlowDocument> na elemencie głównym, a następnie odwołuje się do niego jako zasób jako określony styl dla <xref:System.Windows.Documents.Paragraph>.</span><span class="sxs-lookup"><span data-stu-id="da2da-661">The following example establishes a <xref:System.Windows.FrameworkContentElement.Resources%2A> collection on a <xref:System.Windows.Documents.FlowDocument> root element and then references it as a resource as a specific style for a <xref:System.Windows.Documents.Paragraph>.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-662">Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.Style" /> zależności.</span><span class="sxs-lookup"><span data-stu-id="da2da-662">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Style" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName"><span data-ttu-id="da2da-663">Nazwa żądanej właściwości otoczenia.</span><span class="sxs-lookup"><span data-stu-id="da2da-663">The name of the requested ambient property.</span></span></param>
        <summary><span data-ttu-id="da2da-664">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> metodę.</span><span class="sxs-lookup"><span data-stu-id="da2da-664">For a description of this member, see the <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> method.</span></span></summary>
        <returns><span data-ttu-id="da2da-665"><see langword="true" />Jeśli <paramref name="propertyName" /> jest dostępna; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="da2da-665"><see langword="true" /> if <paramref name="propertyName" /> is available; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-666">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="da2da-666">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="da2da-667">Może być używana tylko wtedy, <xref:System.Windows.FrameworkContentElement> gdy wystąpienie jest rzutowane <xref:System.Windows.Markup.IQueryAmbient> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="da2da-667">It can be used only when the <xref:System.Windows.FrameworkContentElement> instance is cast to an <xref:System.Windows.Markup.IQueryAmbient> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkContentElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-668">Pobiera lub ustawia dowolną wartość obiektu, która może być używana do przechowywania informacji niestandardowych o tym elemencie.</span><span class="sxs-lookup"><span data-stu-id="da2da-668">Gets or sets an arbitrary object value that can be used to store custom information about this element.</span></span></summary>
        <value><span data-ttu-id="da2da-669">Zamierzona wartość.</span><span class="sxs-lookup"><span data-stu-id="da2da-669">The intended value.</span></span> <span data-ttu-id="da2da-670">Ta właściwość nie ma wartości domyślnej.</span><span class="sxs-lookup"><span data-stu-id="da2da-670">This property has no default value.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-671">Ta właściwość jest analogiczna do właściwości tagów w innych modelach programowania firmy Microsoft, takich jak Visual Basic for Applications lub Windows Forms.</span><span class="sxs-lookup"><span data-stu-id="da2da-671">This property is analogous to Tag properties in other Microsoft programming models, such as Visual Basic for Applications or Windows Forms.</span></span> <span data-ttu-id="da2da-672">Należy zapewnić istniejące miejsce do przechowywania niektórych podstawowych informacji niestandardowych o dowolnym elemencie bez wymuszania stosowania podklasy przez deweloperów aplikacji.</span><span class="sxs-lookup"><span data-stu-id="da2da-672">It is intended to provide a pre-existing place to store some basic custom information about any element without forcing application developers to subclass.</span></span>  
  
<a name="xamlValues_Tag"></a>   
## <a name="xaml-values"></a><span data-ttu-id="da2da-673">Wartości XAML</span><span class="sxs-lookup"><span data-stu-id="da2da-673">XAML Values</span></span>  
 <span data-ttu-id="da2da-674">Ponieważ ta właściwość przyjmuje obiekt, należy użyć opcji użycie elementu właściwości w celu ustawienia <xref:System.Windows.FrameworkContentElement.Tag%2A> właściwości w języku XAML na coś innego niż obiekt z znanym i wbudowanym konwerterem typów, takim jak ciąg.</span><span class="sxs-lookup"><span data-stu-id="da2da-674">Because this property takes an object, you need to use the property element usage in order to set the <xref:System.Windows.FrameworkContentElement.Tag%2A> property in XAML to anything other than an object with a known and built-in type converter, such as a string.</span></span> <span data-ttu-id="da2da-675">Obiekty używane w ten sposób zwykle nie znajdują się w standardowych przestrzeniach nazw WPF i w związku z tym mogą wymagać mapowania przestrzeni nazw do zewnętrznej przestrzeni nazw, aby można było je wprowadzić jako elementy XAML.</span><span class="sxs-lookup"><span data-stu-id="da2da-675">Objects used in this way are typically not within the standard WPF namespaces and therefore may require namespace mapping to the external namespace in order to be introduced as XAML elements.</span></span>  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="da2da-676">Informacje dotyczące właściwości zależności</span><span class="sxs-lookup"><span data-stu-id="da2da-676">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="da2da-677">Pole identyfikatora</span><span class="sxs-lookup"><span data-stu-id="da2da-677">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.TagProperty>|  
|<span data-ttu-id="da2da-678">Właściwości metadanych ustawione na`true`</span><span class="sxs-lookup"><span data-stu-id="da2da-678">Metadata properties set to `true`</span></span>|<span data-ttu-id="da2da-679">Brak</span><span class="sxs-lookup"><span data-stu-id="da2da-679">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-680">Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.Tag" /> zależności.</span><span class="sxs-lookup"><span data-stu-id="da2da-680">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Tag" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-681">Występuje, gdy dowolna skojarzona właściwość docelowa uczestniczy w powiązaniu dla tego elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-681">Occurs when any associated target property participating in a binding on this element changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-682">To zdarzenie <xref:System.Windows.Data.Binding.TargetUpdated> wskazuje zdarzenie, które jest zgłaszane przez wszystkie <xref:System.Windows.Data.Binding> skojarzone z tym elementem.</span><span class="sxs-lookup"><span data-stu-id="da2da-682">This event surfaces the <xref:System.Windows.Data.Binding.TargetUpdated> event that is raised by any <xref:System.Windows.Data.Binding> associated with this element.</span></span> <span data-ttu-id="da2da-683">Zazwyczaj oznacza to, że powiązanie w powiązaniu jest powiązaniem dwukierunkowym i że właściwość zależności powiązanej potwierdza unieważnienie poprzedniej wartości właściwości na dowolnym schemacie walidacji lub buforowania obsługiwanym przez właściwość.</span><span class="sxs-lookup"><span data-stu-id="da2da-683">This usually means that the binding in question is a two-way binding, and that the bound  dependency property affirms an invalidation of the previous property value per any validation or caching scheme that the property supports.</span></span>  
  
 <span data-ttu-id="da2da-684">Argumenty zdarzeń tego zdarzenia będą informować o zmianie powiązanej właściwości.</span><span class="sxs-lookup"><span data-stu-id="da2da-684">The event arguments of this event will inform you which bound property was changed.</span></span>  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="da2da-685">Użycie atrybutu języka XAML</span><span class="sxs-lookup"><span data-stu-id="da2da-685">XAML Attribute Usage</span></span>  
  
```  
<object TargetUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-686">Pobiera odwołanie do elementu nadrzędnego szablonu tego elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-686">Gets a reference to the template parent of this element.</span></span> <span data-ttu-id="da2da-687">Ta właściwość nie jest istotna, jeśli element nie został utworzony za pomocą szablonu.</span><span class="sxs-lookup"><span data-stu-id="da2da-687">This property is not relevant if the element was not created through a template.</span></span></summary>
        <value><span data-ttu-id="da2da-688"><see cref="T:System.Windows.FrameworkTemplate" /> Element<see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> , który spowodował utworzenie tego elementu.</span><span class="sxs-lookup"><span data-stu-id="da2da-688">The element whose <see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> caused this element to be created.</span></span> <span data-ttu-id="da2da-689">Ta wartość jest często <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="da2da-689">This value is frequently <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-690">Szablony są faktycznie udostępnionymi obiektami, gdzie zawartość szablonu jest tworzona tylko raz.</span><span class="sxs-lookup"><span data-stu-id="da2da-690">Templates are actually shared objects, where the contents of the template are created only once.</span></span> <span data-ttu-id="da2da-691">W związku z tym, Jeśli uzyskujesz odwołanie do obiektu, który pochodzi z szablonu, może się okazać, że jawne Drzewo logiczne nie dociera do głównego elementu strony.</span><span class="sxs-lookup"><span data-stu-id="da2da-691">Therefore, if you obtain an object reference to an element that came from a template, you may find that the apparent logical tree does not reach to the page root.</span></span> <span data-ttu-id="da2da-692">Aby można było połączyć takie odwołanie szablonu z drzewem logicznym strony, należy uzyskać <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> wartość i kontynuować nawigowanie w drzewie elementów zgodnie z potrzebami.</span><span class="sxs-lookup"><span data-stu-id="da2da-692">In order to connect such a template reference to the page's logical tree, you should get the <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> value and continue to navigate that element tree as desired.</span></span>  
  
 <span data-ttu-id="da2da-693"><xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>często są `null` używane w przypadku wspólnych obiektów, ponieważ w przypadku uzyskania odwołania do obiektu z zewnątrz strony w aplikacji za pośrednictwem typowych metod ten element prawdopodobnie nie został utworzony na podstawie szablonu.</span><span class="sxs-lookup"><span data-stu-id="da2da-693"><xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> will frequently be `null` for common objects, because if you have obtained an object reference from out of a page in your application through typical means, that element probably was not created from a template.</span></span> <span data-ttu-id="da2da-694">Przypadki, <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> w których mogą `null` nie być uwzględniane operacje, takie jak testowanie trafień, obsługa zdarzeń dla pewnych zdarzeń wejściowych niskiego poziomu lub praca z modułami wyliczającymi, które mogą zwrócić elementy, które pochodzą z szablonów.</span><span class="sxs-lookup"><span data-stu-id="da2da-694">Cases where <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> might not be `null` would include operations such as hit-testing, event handling for certain low-level input events, or working with enumerators, which may have returned elements that came from templates.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkContentElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-695">Pobiera lub ustawia obiekt etykietki narzędzia, który jest wyświetlany dla tego elementu w [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="da2da-695">Gets or sets the tool-tip object that is displayed for this element in the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span></span></summary>
        <value><span data-ttu-id="da2da-696">Obiekt ToolTip.</span><span class="sxs-lookup"><span data-stu-id="da2da-696">The tooltip object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-697">Jeśli wartość tej właściwości jest typu <xref:System.Windows.Controls.ToolTip>, to jest etykietka narzędzia, która będzie używana [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]w.</span><span class="sxs-lookup"><span data-stu-id="da2da-697">If the value of this property is of type <xref:System.Windows.Controls.ToolTip>, then that is the tool-tip that will be used in the [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span>  <span data-ttu-id="da2da-698">Jeśli wartość jest dowolnego innego typu, ta wartość będzie używana jako *zawartość* dla <xref:System.Windows.Controls.ToolTip> dostarczonego (konstruowanego) przez system.</span><span class="sxs-lookup"><span data-stu-id="da2da-698">If the value is of any other type, then that value will be used as the *content* for a <xref:System.Windows.Controls.ToolTip> provided (constructed) by the system.</span></span> <span data-ttu-id="da2da-699">Aby uzyskać więcej informacji <xref:System.Windows.Controls.ToolTipService>, zobacz.</span><span class="sxs-lookup"><span data-stu-id="da2da-699">For more information see <xref:System.Windows.Controls.ToolTipService>.</span></span> <span data-ttu-id="da2da-700">Klasa usługi zawiera dołączone właściwości, których można użyć w celu dodatkowego dostosowania etykietki narzędzia.</span><span class="sxs-lookup"><span data-stu-id="da2da-700">The service class provides attached properties that can be used to further customize a tool-tip.</span></span>  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="da2da-701">Użycie atrybutu języka XAML</span><span class="sxs-lookup"><span data-stu-id="da2da-701">XAML Attribute Usage</span></span>  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="da2da-702">Użycie elementu właściwości języka XAML</span><span class="sxs-lookup"><span data-stu-id="da2da-702">XAML Property Element Usage</span></span>  
  
```xaml 
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
```

<span data-ttu-id="da2da-703">—lub—</span><span class="sxs-lookup"><span data-stu-id="da2da-703">-or-</span></span>

```xaml
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```

<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a><span data-ttu-id="da2da-704">Wartości XAML</span><span class="sxs-lookup"><span data-stu-id="da2da-704">XAML Values</span></span>  
 <span data-ttu-id="da2da-705">*toolTipContent*</span><span class="sxs-lookup"><span data-stu-id="da2da-705">*toolTipContent*</span></span>  
 <span data-ttu-id="da2da-706">Ciąg, który zmienia się w tekście <xref:System.Windows.FrameworkContentElement.ToolTip%2A>wyświetlanym.</span><span class="sxs-lookup"><span data-stu-id="da2da-706">A string that becomes the display text for the <xref:System.Windows.FrameworkContentElement.ToolTip%2A>.</span></span>  
  
 <span data-ttu-id="da2da-707">*toolTipObjectContent*</span><span class="sxs-lookup"><span data-stu-id="da2da-707">*toolTipObjectContent*</span></span>  
 <span data-ttu-id="da2da-708">Niektóre obiekty, podane w formularzu elementu obiektu, które powinny być używane jako zawartość <xref:System.Windows.FrameworkContentElement> .</span><span class="sxs-lookup"><span data-stu-id="da2da-708">Some object, provided in object element form, that should be used as the content for the <xref:System.Windows.FrameworkContentElement> .</span></span> <span data-ttu-id="da2da-709">Zwykle jest <xref:System.Windows.FrameworkElement> to lub inny element, który tworzy składanie układu <xref:System.Windows.FrameworkContentElement.ToolTip%2A>dla, ostatecznie zawierający zawartość tekstową w ramach składania.</span><span class="sxs-lookup"><span data-stu-id="da2da-709">Typically this would be a <xref:System.Windows.FrameworkElement> or some other element that creates layout compositing for the <xref:System.Windows.FrameworkContentElement.ToolTip%2A>, eventually containing text content within the compositing.</span></span> <span data-ttu-id="da2da-710"><xref:System.Windows.Controls.ToolTip> W tym użyciu element jest tworzony niejawnie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]z przeanalizowanej, a zawartość *toolTipObjectContent* jest ustawiana jako jej <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> właściwość.</span><span class="sxs-lookup"><span data-stu-id="da2da-710">In this usage, the <xref:System.Windows.Controls.ToolTip> element is created implicitly from the parsed [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], and the *toolTipObjectContent* content is set as its <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="da2da-711"><`ToolTip` .../></span><span class="sxs-lookup"><span data-stu-id="da2da-711"><`ToolTip` .../></span></span>  
 <span data-ttu-id="da2da-712">Zobacz <xref:System.Windows.Controls.ToolTip>.</span><span class="sxs-lookup"><span data-stu-id="da2da-712">See <xref:System.Windows.Controls.ToolTip>.</span></span>  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="da2da-713">Informacje dotyczące właściwości zależności</span><span class="sxs-lookup"><span data-stu-id="da2da-713">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="da2da-714">Pole identyfikatora</span><span class="sxs-lookup"><span data-stu-id="da2da-714">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipProperty>|  
|<span data-ttu-id="da2da-715">Właściwości metadanych ustawione na`true`</span><span class="sxs-lookup"><span data-stu-id="da2da-715">Metadata properties set to `true`</span></span>|<span data-ttu-id="da2da-716">Brak</span><span class="sxs-lookup"><span data-stu-id="da2da-716">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="da2da-717">Poniższy przykład ustawia wartość <xref:System.Windows.FrameworkElement.ToolTip%2A> właściwości bezpośrednio na ciąg.</span><span class="sxs-lookup"><span data-stu-id="da2da-717">The following example sets the value of the <xref:System.Windows.FrameworkElement.ToolTip%2A> property directly to a string.</span></span>  
  
 [!code-csharp[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/csharp/VS_Snippets_Wpf/TableSnippets2/CSharp/Window1.xaml.cs#_table_rowgroups_maniprows)]
 [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TableSnippets2/visualbasic/window1.xaml.vb#_table_rowgroups_maniprows)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-718">Występuje tuż przed zamknięciem dowolnej etykietki narzędzia w elemencie.</span><span class="sxs-lookup"><span data-stu-id="da2da-718">Occurs just before any tooltip on the element is closed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-719">Aby pominąć zamykanie etykietki narzędzia, procedury obsługi zdarzenia powinny oznaczać ją jako obsłużoną.</span><span class="sxs-lookup"><span data-stu-id="da2da-719">To suppress closing the tooltip, handlers of the event should mark it as handled.</span></span>  
  
 <span data-ttu-id="da2da-720">To zdarzenie nie może być <xref:System.Windows.EventTrigger> w stylu.</span><span class="sxs-lookup"><span data-stu-id="da2da-720">This event cannot be an <xref:System.Windows.EventTrigger> in a style.</span></span> <span data-ttu-id="da2da-721">Jest to spowodowane tym, że pole Identyfikator tego zdarzenia ponownie używa implementacji z usługi, która nie uwidacznia metod Add/Remove dla zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="da2da-721">This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</span></span>  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="da2da-722">Informacje dotyczące kierowanego zdarzenia</span><span class="sxs-lookup"><span data-stu-id="da2da-722">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="da2da-723">Pole identyfikatora</span><span class="sxs-lookup"><span data-stu-id="da2da-723">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|  
|<span data-ttu-id="da2da-724">Strategia routingu</span><span class="sxs-lookup"><span data-stu-id="da2da-724">Routing strategy</span></span>|<span data-ttu-id="da2da-725">Bezpośrednie</span><span class="sxs-lookup"><span data-stu-id="da2da-725">Direct</span></span>|  
|<span data-ttu-id="da2da-726">Delegate</span><span class="sxs-lookup"><span data-stu-id="da2da-726">Delegate</span></span>|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-727">Identyfikuje przegląd [zdarzeń kierowanych.](~/docs/framework/wpf/advanced/routed-events-overview.md) <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /></span><span class="sxs-lookup"><span data-stu-id="da2da-727">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-728">Obiekty identyfikatorów zdarzeń są tworzone po zarejestrowaniu zdarzeń kierowanych <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>(zobacz) i mogą być używane do dodawania programów obsługi klasy ( <xref:System.Windows.EventManager.RegisterClassHandler%2A>Zobacz).</span><span class="sxs-lookup"><span data-stu-id="da2da-728">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="da2da-729">Obiekty identyfikatorów zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu i metodę narzędzia do dodawania właścicieli dla zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="da2da-729">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-730">Występuje po otwarciu dowolnej etykietki narzędzia w elemencie.</span><span class="sxs-lookup"><span data-stu-id="da2da-730">Occurs when any tooltip on the element is opened.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-731">Aby ręcznie otworzyć etykietki narzędzi, programy obsługi zdarzeń powinny oznaczyć odpowiednie zdarzenie jako obsłużone.</span><span class="sxs-lookup"><span data-stu-id="da2da-731">To manually open tooltips, handlers of the events should mark the relevant event as handled.</span></span> <span data-ttu-id="da2da-732">W przeciwnym razie wartość <xref:System.Windows.FrameworkContentElement.ToolTip%2A> właściwości zostanie użyta do automatycznego otwarcia menu kontekstowego.</span><span class="sxs-lookup"><span data-stu-id="da2da-732">Otherwise, the value of the <xref:System.Windows.FrameworkContentElement.ToolTip%2A> property will be used to automatically open a context menu.</span></span> <span data-ttu-id="da2da-733">Oznaczenie obsłużonego zdarzenia będzie efektywnie anulować akcję domyślną i może być możliwością zresetowania wartości <xref:System.Windows.FrameworkContentElement.ToolTip%2A> właściwości, a następnie otworzenia nowej. <xref:System.Windows.Controls.ContextMenu></span><span class="sxs-lookup"><span data-stu-id="da2da-733">Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <xref:System.Windows.FrameworkContentElement.ToolTip%2A> property and then open the new <xref:System.Windows.Controls.ContextMenu>.</span></span> <span data-ttu-id="da2da-734">Należy zauważyć, że to zdarzenie nie zostanie wywołane, jeśli <xref:System.Windows.FrameworkContentElement.ToolTip%2A> jest odwołaniem o wartości null lub w inny sposób.</span><span class="sxs-lookup"><span data-stu-id="da2da-734">Note that this event will not be raised if <xref:System.Windows.FrameworkContentElement.ToolTip%2A> is a null reference or otherwise unset.</span></span>  
  
 <span data-ttu-id="da2da-735">To zdarzenie nie może być <xref:System.Windows.EventTrigger> w stylu.</span><span class="sxs-lookup"><span data-stu-id="da2da-735">This event cannot be an <xref:System.Windows.EventTrigger> in a style.</span></span> <span data-ttu-id="da2da-736">Jest to spowodowane tym, że pole Identyfikator tego zdarzenia ponownie używa implementacji z usługi, która nie uwidacznia metod Add/Remove dla zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="da2da-736">This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</span></span>  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="da2da-737">Informacje dotyczące kierowanego zdarzenia</span><span class="sxs-lookup"><span data-stu-id="da2da-737">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="da2da-738">Pole identyfikatora</span><span class="sxs-lookup"><span data-stu-id="da2da-738">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|  
|<span data-ttu-id="da2da-739">Strategia routingu</span><span class="sxs-lookup"><span data-stu-id="da2da-739">Routing strategy</span></span>|<span data-ttu-id="da2da-740">Bezpośrednie</span><span class="sxs-lookup"><span data-stu-id="da2da-740">Direct</span></span>|  
|<span data-ttu-id="da2da-741">Delegate</span><span class="sxs-lookup"><span data-stu-id="da2da-741">Delegate</span></span>|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-742">Identyfikuje przegląd [zdarzeń kierowanych.](~/docs/framework/wpf/advanced/routed-events-overview.md) <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /></span><span class="sxs-lookup"><span data-stu-id="da2da-742">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-743">Obiekty identyfikatorów zdarzeń są tworzone po zarejestrowaniu zdarzeń kierowanych <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>(zobacz) i mogą być używane do dodawania programów obsługi klasy ( <xref:System.Windows.EventManager.RegisterClassHandler%2A>Zobacz).</span><span class="sxs-lookup"><span data-stu-id="da2da-743">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="da2da-744">Obiekty identyfikatorów zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu i metodę narzędzia do dodawania właścicieli dla zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="da2da-744">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-745">Identyfikuje właściwość <see cref="P:System.Windows.FrameworkContentElement.ToolTip" /> zależności.</span><span class="sxs-lookup"><span data-stu-id="da2da-745">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ToolTip" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkContentElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey"><span data-ttu-id="da2da-746">Identyfikator klucza zasobu, który ma zostać znaleziony.</span><span class="sxs-lookup"><span data-stu-id="da2da-746">Key identifier of the resource to be found.</span></span></param>
        <summary><span data-ttu-id="da2da-747">Wyszukuje zasób z określonym kluczem i zwraca ten zasób, jeśli został znaleziony.</span><span class="sxs-lookup"><span data-stu-id="da2da-747">Searches for a resource with the specified key, and returns that resource if found.</span></span></summary>
        <returns><span data-ttu-id="da2da-748">Znaleziony zasób.</span><span class="sxs-lookup"><span data-stu-id="da2da-748">The found resource.</span></span> <span data-ttu-id="da2da-749">Jeśli żaden zasób nie został znaleziony <see langword="null" /> , jest zwracany.</span><span class="sxs-lookup"><span data-stu-id="da2da-749">If no resource was found, <see langword="null" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-750">Jeśli zasób nie zostanie odnaleziony w elemencie wywołującym, drzewo nadrzędne będzie przeszukiwane przy użyciu drzewa logicznego w taki sam sposób, w jaki drzewo będzie przeszukiwane, jeśli w czasie wykonywania zażądano dynamicznego odwołania do zasobu.</span><span class="sxs-lookup"><span data-stu-id="da2da-750">If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a dynamic resource reference were requested by key at run-time.</span></span>  
  
 <span data-ttu-id="da2da-751">Zazwyczaj można natychmiast rzutować wartość zwracaną na typ właściwości, którą próbowano ustawić przy użyciu zwróconej wartości zasobu.</span><span class="sxs-lookup"><span data-stu-id="da2da-751">Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</span></span>  
  
 <span data-ttu-id="da2da-752"><xref:System.Windows.FrameworkContentElement.FindResource%2A> Metoda ma podobne zachowanie, z tą różnicą, że zgłosi wyjątek w przypadku braku znajdowania zasobu z podanym kluczem.</span><span class="sxs-lookup"><span data-stu-id="da2da-752">The <xref:System.Windows.FrameworkContentElement.FindResource%2A> method has similar behavior, except that it will throw an exception in the case of not finding a resource with the provided key.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="da2da-753">Poniższy przykład umożliwia znalezienie zasobu zdefiniowanego w znaczniku i zastosowanie go do pewnej właściwości elementu w odpowiedzi na zdarzenie kierowane.</span><span class="sxs-lookup"><span data-stu-id="da2da-753">The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#tryfindresource)]
 [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#tryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-754">Występuje, gdy element zostanie usunięty z drzewa elementów załadowanych elementów.</span><span class="sxs-lookup"><span data-stu-id="da2da-754">Occurs when the element is removed from an element tree of loaded elements.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-755">Zdarzenia kierowane bezpośrednio nie obserwują trasy, są obsługiwane tylko w obrębie tego samego elementu, w którym zostały zgłoszone.</span><span class="sxs-lookup"><span data-stu-id="da2da-755">Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</span></span> <span data-ttu-id="da2da-756">Zdarzenia kierowane bezpośrednio obsługują inne kierowane zdarzenia dotyczące zdarzeń: obsługują kolekcję programów obsługi i mogą być używane jako <xref:System.Windows.EventTrigger> style.</span><span class="sxs-lookup"><span data-stu-id="da2da-756">Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <xref:System.Windows.EventTrigger> in a style.</span></span>  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="da2da-757">Informacje dotyczące kierowanego zdarzenia</span><span class="sxs-lookup"><span data-stu-id="da2da-757">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="da2da-758">Pole identyfikatora</span><span class="sxs-lookup"><span data-stu-id="da2da-758">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.UnloadedEvent>|  
|<span data-ttu-id="da2da-759">Strategia routingu</span><span class="sxs-lookup"><span data-stu-id="da2da-759">Routing strategy</span></span>|<span data-ttu-id="da2da-760">Bezpośrednie</span><span class="sxs-lookup"><span data-stu-id="da2da-760">Direct</span></span>|  
|<span data-ttu-id="da2da-761">Delegate</span><span class="sxs-lookup"><span data-stu-id="da2da-761">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="da2da-762">Identyfikuje przegląd [zdarzeń kierowanych.](~/docs/framework/wpf/advanced/routed-events-overview.md) <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /></span><span class="sxs-lookup"><span data-stu-id="da2da-762">Identifies the <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-763">Obiekty identyfikatorów zdarzeń są tworzone po zarejestrowaniu zdarzeń kierowanych <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>(zobacz) i mogą być używane do dodawania programów obsługi klasy ( <xref:System.Windows.EventManager.RegisterClassHandler%2A>Zobacz).</span><span class="sxs-lookup"><span data-stu-id="da2da-763">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="da2da-764">Obiekty identyfikatorów zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu i metodę narzędzia do dodawania właścicieli dla zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="da2da-764">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkContentElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="da2da-765">Nazwa pary nazwa-obiekt do usunięcia z bieżącego zakresu.</span><span class="sxs-lookup"><span data-stu-id="da2da-765">Name of the name-object pair to remove from the current scope.</span></span></param>
        <summary><span data-ttu-id="da2da-766">Upraszcza dostęp do <see cref="T:System.Windows.NameScope" /> metody Wycofaj rejestrację.</span><span class="sxs-lookup"><span data-stu-id="da2da-766">Simplifies access to the <see cref="T:System.Windows.NameScope" /> de-registration method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="da2da-767">Musisz wyrejestrować nazwy tylko wtedy, gdy zamierzasz ponownie zarejestrować inny element o tej samej nazwie.</span><span class="sxs-lookup"><span data-stu-id="da2da-767">You only need to un-register names if you intend to re-register another element with that same name.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkContentElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="da2da-768">Stosuje domyślny styl do bieżącego <see cref="T:System.Windows.FrameworkContentElement" />.</span><span class="sxs-lookup"><span data-stu-id="da2da-768">Reapplies the default style to the current <see cref="T:System.Windows.FrameworkContentElement" />.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

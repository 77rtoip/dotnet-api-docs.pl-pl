<Type Name="FrameworkElement" FullName="System.Windows.FrameworkElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="52bb34d9daddff99314e23014e5d61909a488206" />
    <Meta Name="ms.sourcegitcommit" Value="058bfa0b75b777d3171411d35da8f11617fc06b0" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="05/04/2018" />
    <Meta Name="ms.locfileid" Value="33660153" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkElement : System.Windows.UIElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkElement extends System.Windows.UIElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkElement&#xA;Inherits UIElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkElement : System::Windows::UIElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia poziomie struktury WPF zbiór właściwości, zdarzeń i metody dla elementów Windows Presentation Foundation (WPF). Ta klasa reprezentuje WPF poziomie struktury implementacji zbudowanej na interfejsów API core poziomie WPF, które są definiowane przez <see cref="T:System.Windows.UIElement" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> to punkt połączenia między klasami element poziomie struktury WPF i poziom core WPF zbiór <xref:System.Windows.UIElement> usług prezentacji. Aby uzyskać więcej informacji dotyczących tych pojęć, zobacz [architektura WPF](~/docs/framework/wpf/advanced/wpf-architecture.md).  
  
 <xref:System.Windows.FrameworkElement> Rozszerza <xref:System.Windows.UIElement> i dodaje następujące możliwości:  
  
-   **Układ systemu definicji**: <xref:System.Windows.FrameworkElement> zapewnia określonej implementacji poziomie struktury WPF dla niektórych metod, które zostały zdefiniowane jako wirtualnych elementów członkowskich w <xref:System.Windows.UIElement>. Głównie <xref:System.Windows.FrameworkElement> uszczelnienia niektórych zastąpienia układu core poziomie WPF i przekazuje odpowiednika poziomie struktury WPF klasy pochodne powinny przesłaniać zamiast tego. Na przykład <xref:System.Windows.FrameworkElement> zamknięcia <xref:System.Windows.UIElement.ArrangeCore%2A> , ale zawierają <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>. Te zmiany odzwierciedlają fakt, że w WPF poziomie struktury jest pełną układu systemu w miejscu, umożliwiający renderowanie żadnego <xref:System.Windows.FrameworkElement> klasy. W podsystemie WPF podstawowego poziomu, niektóre elementy członkowskie, które będą struktury ogólne [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozwiązanie oparte na układ są stosowane, ale rzeczywisty aparatu układu systemu nie jest zdefiniowany. Aby uzyskać więcej informacji, zobacz [układu](~/docs/framework/wpf/advanced/layout.md).  
  
-   **Drzewa logicznego:** ogólne [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] często wyrażonych trwa drzewa elementów modelu programowania. Obsługa wyrażenia drzewa elementów jako drzewa logicznego i towarzyszące pomocy technicznej dla definiowania tree w znaczniku jest zaimplementowana w <xref:System.Windows.FrameworkElement> poziom. Uwaga mimo że <xref:System.Windows.FrameworkElement> celowo nie definiuje model zawartości i pozostawia tego odpowiedzialność za klas pochodnych. Aby uzyskać więcej informacji, zobacz [drzewa WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
-   **Obiekt zdarzenia okresu istnienia:** jest często warto wiedzieć, kiedy element został zainicjowany (wywołania konstruktora) lub jeśli element najpierw zostanie załadowana do drzewa logicznego. <xref:System.Windows.FrameworkElement> definiuje kilka zdarzeń związanych z okres istnienia obiektów zawierających przydatne punkty zaczepienia operacje związane z kodem, które obejmują elementy, takie jak dodanie więcej elementów podrzędnych. Aby uzyskać więcej informacji, zobacz [zdarzenia okresu istnienia obiektu](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
-   **Obsługa wiązania z danymi i odwołania do zasobów dynamicznej:** obsługę poziomu właściwości powiązania danych i zasobów jest implementowany przez <xref:System.Windows.DependencyProperty> klasy i zawarte w systemie właściwości, ale możliwość rozpoznania wartości elementu członkowskiego, który jest przechowywane jako <xref:System.Windows.Expression> (programowania konstrukcja źródłową zarówno powiązania danych i zasobów dynamicznych) jest implementowany przez <xref:System.Windows.FrameworkElement>. Aby uzyskać więcej informacji, zobacz [omówienie powiązania danych](~/docs/framework/wpf/data/data-binding-overview.md) i [zasobów XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
-   **Style:** <xref:System.Windows.FrameworkElement> definiuje <xref:System.Windows.FrameworkElement.Style%2A> właściwości. Jednak <xref:System.Windows.FrameworkElement> nie została jeszcze zdefiniować Obsługa szablonów lub obsługuje elementów decorator. Te funkcje są wprowadzone przez klasy formantów, takich jak <xref:System.Windows.Controls.Control> i <xref:System.Windows.Controls.ContentControl>.  
  
-   **Więcej pomocy technicznej animacji:** niektórych animacji Obsługa została już zdefiniowana na poziomie core WPF, ale <xref:System.Windows.FrameworkElement> rozszerza to zaimplementowanie <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> oraz powiązane elementy członkowskie.  
  
 Jak wynika z hierarchii klas wiele [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] pochodną klasy <xref:System.Windows.FrameworkElement>, bezpośrednio lub za pośrednictwem pośredniej klasy podstawowej takich jak <xref:System.Windows.Controls.Panel> lub <xref:System.Windows.Controls.Control>.  
  
 Jeśli zamierzasz używać <xref:System.Windows.FrameworkElement> jako klasę podstawową, należy najpierw sprawdzić istniejące klasy pochodnej. <xref:System.Windows.FrameworkElement> zapewnia obsługę wielu podstawowych operacji, ale również nie zawiera szereg funkcji, które są pożądane "elementu" w tym sensie bloku konstrukcyjnego, którego można używać do tworzenia [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] w [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. Na przykład <xref:System.Windows.FrameworkElement> nie definiuje true modelu zawartości; <xref:System.Windows.FrameworkElement> jako klasa podstawowa nie definiuje właściwości, który może tworzyć [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] elementy podrzędne. W szczególności należy przyjrzeć się <xref:System.Windows.Controls.Control> i <xref:System.Windows.Controls.ContentControl>.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.FrameworkContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkElement" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeight">
      <MemberSignature Language="C#" Value="public double ActualHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualHeight { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera renderowanych wysokość tego elementu.</summary>
        <value>Wysokość elementu, jako wartość [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Wartością domyślną jest 0 (zero).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest wartością obliczoną na podstawie danych wejściowych innych wysokości i układu systemu. Wartość jest ustawiana przez system układu, oparty na przebieg rzeczywiste renderowania i może w związku z tym opóźniona nieco ustaw wartość właściwości takich jak <xref:System.Windows.FrameworkElement.Height%2A> będące podstawą wprowadzania zmian.  
  
 Ponieważ <xref:System.Windows.FrameworkElement.ActualHeight%2A> jest obliczoną wartością, pamiętaj, że może istnieć wiele zgłoszonych przyrostowe zmiany lub go wyniku różne operacje przez system układu. Układ systemu może obliczanie miejsca wymaganego miary dla elementów podrzędnych, ograniczenia przez element nadrzędny i tak dalej.  
  
 Mimo że nie można ustawić tę właściwość z [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], można utworzyć <xref:System.Windows.Trigger> po jego wartość w stylu.  
  
<a name="dependencyPropertyInfo_ActualHeight"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ActualHeightProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono różne właściwości wysokość.  
  
 [!code-csharp[HeightMinHeightMaxHeight#3](~/samples/snippets/csharp/VS_Snippets_Wpf/HeightMinHeightMaxHeight/CSharp/Window1.xaml.cs#3)]
 [!code-vb[HeightMinHeightMaxHeight#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HeightMinHeightMaxHeight/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualHeightProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.ActualHeight" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidth">
      <MemberSignature Language="C#" Value="public double ActualWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualWidth { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera szerokość renderowanych tego elementu.</summary>
        <value>Szerokość elementu, jako wartość [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Wartością domyślną jest 0 (zero).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest wartością obliczoną na podstawie danych wejściowych innych szerokości i układu systemu. Wartość jest ustawiana przez system układu, oparty na przebieg rzeczywiste renderowania i może w związku z tym opóźniona nieco ustaw wartość właściwości takich jak <xref:System.Windows.FrameworkElement.Width%2A> będące podstawą wprowadzania zmian.  
  
 Ponieważ <xref:System.Windows.FrameworkElement.ActualWidth%2A> jest obliczoną wartością, pamiętaj, że może istnieć wiele zgłoszonych przyrostowe zmiany lub go wyniku różne operacje przez system układu. Układ systemu może obliczanie miejsca wymaganego miary dla elementów podrzędnych, ograniczenia przez element nadrzędny i tak dalej.  
  
 Mimo że nie można ustawić tę właściwość z [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], można utworzyć <xref:System.Windows.Trigger> po jego wartość w stylu.  
  
<a name="dependencyPropertyInfo_ActualWidth"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ActualWidthProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono różne właściwości width.  
  
 [!code-csharp[WidthMinWidthMaxWidth#3](~/samples/snippets/csharp/VS_Snippets_Wpf/WidthMinWidthMaxWidth/CSharp/Window1.xaml.cs#3)]
 [!code-vb[WidthMinWidthMaxWidth#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WidthMinWidthMaxWidth/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualWidthProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.ActualWidth" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Element podrzędny, która ma zostać dodana.</param>
        <summary>Dodaje podany obiekt do drzewa logicznego tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do wykonania kolekcje w obiektach, które reprezentują elementy podrzędne logicznej elementu. Obsługa kolekcji kolekcji elementu podrzędnego może odbywać się w pobierających właściwości lub metody ustawiające, klasa obsługi zdarzeń zmienione, konstruktorów, lub w ramach same typy kolekcji.  
  
 Dla autorów kontroli manipulowanie drzewa logicznego na tym poziomie nie jest zalecana praktyka Brak modeli zawartości określonych dla klasy bazowej dostępne nie znajdują się odpowiednie dla danego scenariusza formantu. Należy wziąć pod uwagę podklasy na poziomie <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>, i <xref:System.Windows.Controls.HeaderedItemsControl>. Te klasy Podaj modelu zawartości z konkretnym wymuszania elementów podrzędnych drzewa logicznego za pośrednictwem dedykowanej [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)], oraz obsługę innych funkcji, które są zwykle pożądane w [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] kontroli, takich jak style za pomocą szablonów. Aby uzyskać więcej informacji na temat sposobu użycia <xref:System.Windows.FrameworkElement.LogicalChildren%2A> i <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>, zobacz [drzewa WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 <xref:System.Windows.FrameworkElement.AddLogicalChild%2A> może zgłosić wyjątek, jeśli wywołana w chwili, gdy drzewa logicznego jest on iterowane przez inny proces.  
  
   
  
## Examples  
 Poniższy przykład implementuje `Child` właściwości niestandardowego <xref:System.Windows.FrameworkElement> wykonuje własną implementację visual warstwy. Metoda ustawiająca właściwości zaprojektowano tak, aby w przypadku zmiany wartości, stara wartość zostanie usunięty z drzewa logicznego, a także wizualna kolekcja specyficzne dla klasy. Wartość właściwości są buforowane, a następnie nowa wartość jest dodane do drzewa logicznego i niestandardowych wizualna kolekcja.  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyTemplate">
      <MemberSignature Language="C#" Value="public bool ApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyTemplate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ApplyTemplate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy drzewa wizualnego bieżący szablon w razie potrzeby i zwraca wartość wskazującą, czy drzewa wizualnego został odbudowany przez to wywołanie.</summary>
        <returns>
          <see langword="true" /> Jeśli elementy wizualne zostały dodane do drzewa; Zwraca <see langword="false" /> inaczej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacje mogą wywoływać tej metody, aby zagwarantować zakończeniu drzewa wizualnego elementu. Ten krok gwarancji może być konieczne, jeśli kod zostanie Sprawdzanie elementów podrzędnych w drzewie. Typowy element logiki w aplikacjach, wywoływania <xref:System.Windows.FrameworkElement.ApplyTemplate%2A> nie jest konieczne, ponieważ szablony zostaną zastosowane do elementów w momencie odpowiednie w ich okresy istnienia automatycznie.  
  
 <xref:System.Windows.FrameworkElement.ApplyTemplate%2A> jest wywoływane dla każdego miary jest przekazywany za pomocą systemu układu poziomie struktury WPF.  
  
 <xref:System.Windows.FrameworkElement> klasy pochodne mogą używać <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> klasy obsługi, aby otrzymywać powiadomienia o przypadkach, gdy ta metoda została wywołana jawnie ani przez system układu. <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> jest wywoływana po szablonu jest całkowicie wygenerowany i dołączyć do drzewa logicznego.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ControlTemplate" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeCore">
      <MemberSignature Language="C#" Value="protected override sealed void ArrangeCore (System.Windows.Rect finalRect);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ArrangeCore(valuetype System.Windows.Rect finalRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Sub ArrangeCore (finalRect As Rect)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ArrangeCore(System::Windows::Rect finalRect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalRect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="finalRect">Obszar końcowego nadrzędnym, która powinna być używana przez ten element ułożyć się i jego elementów podrzędnych.</param>
        <summary>Implementuje <see cref="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" /> (zdefiniowany jako wirtualny w <see cref="T:System.Windows.UIElement" />) oraz uszczelnienia implementacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest zapieczętowany. Aby zastąpić logikę nazwę niestandardowego elementu specjalnie z myślą o przebiegu Rozmieść układu elementu z <xref:System.Windows.FrameworkElement> klasy pochodne muszą przesłaniać <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size ArrangeOverride (System.Windows.Size finalSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size finalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ArrangeOverride (finalSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size ArrangeOverride(System::Windows::Size finalSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="finalSize">Obszar końcowego nadrzędnym, która powinna być używana przez ten element ułożyć się i jego elementów podrzędnych.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, określa położenie elementów podrzędnych i określa rozmiar <see cref="T:System.Windows.FrameworkElement" /> klasy.</summary>
        <returns>Rzeczywisty rozmiar używane.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Formant autorami dostosować przebiegu Rozmieść przetwarzania układu powinny przesłaniać tę metodę. Wzorzec implementacji powinny wywoływać <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> na każdego elementu podrzędnego widoczne i przebiegu ostatecznych żądany rozmiar dla każdego elementu podrzędnego jako <paramref name="finalRect" /> parametru. Elementy nadrzędne powinny wywoływać <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> na poszczególne elementy podrzędne, w przeciwnym razie elementy podrzędne nie są wyświetlane.  
  
 Wiele klas pochodnych oferują implementacje tej metody. Wyraźne te obejmują: <see cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />, <see cref="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" /> i <see cref="M:System.Windows.Controls.Control.ArrangeOverride(System.Windows.Size)" />.</para>
        </block>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia proces inicjowania dla tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tę metodę można wywołać na poszczególne elementy, jeśli dostosowując je w sposób, w którym nie została jeszcze ujawnia lub element nawiązać połączenia z dowolnego elementu drzewa. Na przykład może utworzono nową <xref:System.Windows.FrameworkElement>, ale nie jeszcze podłączył go do dowolnego drzewa logicznego. Lub drzewa logicznego danego elementu w przypadku elementu podrzędnego w nim może nie być połączony z okna lub strony aplikacji.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zaimplementuj tę metodę w celu zapewnienia obsługi specjalnej powinno się zdarzyć, przed zainicjowaniem danego elementu w elemencie proces ładowania.  
  
 Implementacji powinny wywoływać implementację podstawową, ponieważ niektóre wewnętrzny flagi do śledzenia inicjowania ustawia implementacji base (ustawienie domyślne). Jedna implementacja możliwe jest do używania tej metody jako punktu zaczepienia do własnych procedury inicjowania klasy prywatne, które nie są już włączone przez konstruktorów.  
  
 Podstawowa implementacja spowoduje zgłoszenie wyjątku, jeśli <see cref="M:System.Windows.FrameworkElement.BeginInit" /> zostanie wywołany więcej niż jeden raz dla tego samego elementu przed <see cref="M:System.Windows.FrameworkElement.EndInit" /> wywoływane.</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.EndInit" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna się sekwencję akcji zawartych w podanych scenorysu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">Scenorysu, aby rozpocząć.</param>
        <summary>Rozpoczyna się sekwencję akcji uwzględnionych w podanych scenorysu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najbardziej typowe scenariusze animacji nie należy używać tej metody. Zazwyczaj w celu utworzenia <xref:System.Windows.Media.Animation.Storyboard> lub <xref:System.Windows.Media.Animation.BeginStoryboard> element znaczników, a następnie umieść je jako <xref:System.Windows.EventTrigger> zawartości elementu. Po wyzwoleniu przez zdarzenie uruchamia następnie animacji. Większości aspektów kontroli <xref:System.Windows.Media.Animation.Storyboard> może zostać zlikwidowane przez właściwości, które są dostępne w znaczniku.  
  
 W przypadku podpisów, które nie korzystają z `isControllable`, parametr, lub gdy został określony parametr parametru `false`, zegary osi czasu, które są skojarzone z nią zostaną usunięte natychmiast animacji osiągnie okres "Fill". W związku z tym animacji nie można uruchomić ponownie po uruchomieniu raz. Kontrolowanie animacji również musi mieć scenorysu [x: Name — dyrektywa](~/docs/framework/xaml-services/x-name-directive.md) lub udostępniane przez odwołanie w kodzie.  
  
   
  
## Examples  
 Poniższy przykład pobiera <xref:System.Windows.Media.Animation.Storyboard> z zasobów, a następnie uruchomi, który <xref:System.Windows.Media.Animation.Storyboard> po klasy obsługiwane przez zdarzenie wewnętrzne.  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">Scenorysu, aby rozpocząć.</param>
        <param name="handoffBehavior">Wartość wyliczenia opisujący zachowanie do użycia, jeśli właściwość opisanego w scenorysu jest już animowany.</param>
        <summary>Rozpoczyna się sekwencję akcji zawartych w podanych scenorysu, z opcjami dla co powinno się zdarzyć, jeśli właściwość jest już animowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najbardziej typowe scenariusze animacji nie należy używać tej metody. Zazwyczaj w celu utworzenia <xref:System.Windows.Media.Animation.Storyboard> lub <xref:System.Windows.Media.Animation.BeginStoryboard> element znaczników, a następnie umieść je jako <xref:System.Windows.EventTrigger> zawartości elementu. Po wyzwoleniu przez zdarzenie uruchamia następnie animacji. Większości aspektów kontroli <xref:System.Windows.Media.Animation.Storyboard> może zostać zlikwidowane przez właściwości, które są dostępne w znaczniku.  
  
 W przypadku podpisów, które nie korzystają z `isControllable`, parametr, lub gdy został określony parametr parametru `false`, zegary osi czasu, które są skojarzone z nią zostaną usunięte natychmiast animacji osiągnie okres "Fill". W związku z tym animacji nie można uruchomić ponownie po uruchomieniu raz. Kontrolowanie animacji również musi mieć scenorysu [x: Name — dyrektywa](~/docs/framework/xaml-services/x-name-directive.md) lub udostępniane przez odwołanie w kodzie.  
  
 Można określić zachowanie przekazaniem jako atrybut <xref:System.Windows.Media.Animation.BeginStoryboard>.  
  
## <a name="using-the-compose-handoffbehavior"></a>Korzystanie z Compose HandoffBehavior  
 Po zastosowaniu <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> właściwości przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>oraz <xref:System.Windows.Media.Animation.Clock> obiekty wcześniej skojarzone z tą właściwością nadal zużywają zasoby systemowe, ale ma system chronometrażu Automatycznie usuwaj zegary.  
  
 Aby uniknąć problemów z wydajnością, podczas stosowania dużej liczby zegary za pomocą <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, tworzenie zegary należy usunąć z właściwości animowany po ich zakończeniu. Istnieje kilka sposobów, aby usunąć zegar:  
  
-   Aby usunąć wszystkie zegary z właściwości, należy użyć <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metody animowany obiektu. Określ właściwość animowanej jako pierwszego parametru oraz `null` jako drugiego. Spowoduje to usunięcie wszystkich zegary animacji z właściwości.  
  
-   Aby usunąć określony <xref:System.Windows.Media.Animation.AnimationClock> z listy zegary, użyj <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość <xref:System.Windows.Media.Animation.AnimationClock> można pobrać <xref:System.Windows.Media.Animation.ClockController>, następnie wywołaj <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metody <xref:System.Windows.Media.Animation.ClockController>. Jest to zazwyczaj wykonywane <xref:System.Windows.Media.Animation.Clock.Completed> programu obsługi zdarzeń dla zegara. Należy pamiętać, że tylko zegary głównego mogą być kontrolowane przez <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość zegara podrzędnych zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzenie nie jest wywoływane, jeśli efektywny czas trwania zegar jest nieskończoność.  W takim przypadku użytkownik musi określić, kiedy wywołać metodę <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 To przede wszystkim problemu dla animacji na obiektach, które mają długi okres istnienia.  Gdy obiekt jest bezużytecznych, jego zegary również są odłączone i w ramach odzyskiwania pamięci.  
  
 Aby uzyskać więcej informacji o obiektach zegara, zobacz [animacji i Przegląd systemu chronometrażu](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 Poniższy przykład pobiera <xref:System.Windows.Media.Animation.Storyboard> z zasobów, a następnie uruchomi, który <xref:System.Windows.Media.Animation.Storyboard> po klasy obsługiwane przez zdarzenie wewnętrzne.  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">Scenorysu, aby rozpocząć.</param>
        <param name="handoffBehavior">Wartość wyliczenia opisujący zachowanie do użycia, jeśli właściwość opisanego w scenorysu jest już animowany.</param>
        <param name="isControllable">Deklaruje, czy animacja jest kontrolowane (może być wstrzymane) po jej uruchomieniu.</param>
        <summary>Rozpoczyna się sekwencję akcji zawartych w podanych scenorysu, o określonym stanie dla formantu animacji po jej uruchomieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najbardziej typowe scenariusze animacji nie należy używać tej metody. Zazwyczaj w celu utworzenia <xref:System.Windows.Media.Animation.Storyboard> lub <xref:System.Windows.Media.Animation.BeginStoryboard> element znaczników, a następnie umieść je jako <xref:System.Windows.EventTrigger> zawartości elementu. Po wyzwoleniu przez zdarzenie uruchamia następnie animacji. Większości aspektów kontroli <xref:System.Windows.Media.Animation.Storyboard> może zostać zlikwidowane przez właściwości, które są dostępne w znaczniku.  
  
 W przypadku podpisów, które nie korzystają z `isControllable`, parametr, lub gdy został określony parametr parametru `false`, zegary osi czasu, które są skojarzone z nią zostaną usunięte natychmiast animacji osiągnie okres "Fill". W związku z tym animacji nie można uruchomić ponownie po uruchomieniu raz. Kontrolowanie animacji również musi mieć scenorysu [x: Name — dyrektywa](~/docs/framework/xaml-services/x-name-directive.md) lub udostępniane przez odwołanie w kodzie.  
  
 Można określić zachowanie przekazaniem jako atrybut <xref:System.Windows.Media.Animation.BeginStoryboard>.  
  
## <a name="using-the-compose-handoffbehavior"></a>Korzystanie z Compose HandoffBehavior  
 Po zastosowaniu <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> właściwości przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>oraz <xref:System.Windows.Media.Animation.Clock> obiekty wcześniej skojarzone z tą właściwością nadal zużywają zasoby systemowe, ale ma system chronometrażu Automatycznie usuwaj zegary.  
  
 Aby uniknąć problemów z wydajnością, podczas stosowania dużej liczby zegary za pomocą <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, tworzenie zegary należy usunąć z właściwości animowany po ich zakończeniu. Istnieje kilka sposobów, aby usunąć zegar:  
  
-   Aby usunąć wszystkie zegary z właściwości, należy użyć <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metody animowany obiektu. Określ właściwość animowanej jako pierwszego parametru oraz `null` jako drugiego. Spowoduje to usunięcie wszystkich zegary animacji z właściwości.  
  
-   Aby usunąć określony <xref:System.Windows.Media.Animation.AnimationClock> z listy zegary, użyj <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość <xref:System.Windows.Media.Animation.AnimationClock> można pobrać <xref:System.Windows.Media.Animation.ClockController>, następnie wywołaj <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metody <xref:System.Windows.Media.Animation.ClockController>. Jest to zazwyczaj wykonywane <xref:System.Windows.Media.Animation.Clock.Completed> programu obsługi zdarzeń dla zegara. Należy pamiętać, że tylko zegary głównego mogą być kontrolowane przez <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość zegara podrzędnych zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzenie nie jest wywoływane, jeśli efektywny czas trwania zegar jest nieskończoność.  W takim przypadku użytkownik musi określić, kiedy wywołać metodę <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 To przede wszystkim problemu dla animacji na obiektach, które mają długi okres istnienia.  Gdy obiekt jest bezużytecznych, jego zegary również są odłączone i w ramach odzyskiwania pamięci.  
  
 Aby uzyskać więcej informacji o obiektach zegara, zobacz [animacji i Przegląd systemu chronometrażu](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Data.BindingGroup" /> używany dla elementu.</summary>
        <value>
          <see cref="T:System.Windows.Data.BindingGroup" /> Używany dla elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Data.BindingGroup> może służyć do sprawdzania poprawności wartości wielu właściwości obiektu. Załóżmy na przykład, że aplikacja monituje użytkownika o podanie adresu i wypełnienie klasy obiektu typu `Address`, który zawiera właściwości `Street`, `City`, `ZipCode`, i `Country`, wartościami, który użytkownika podane. Aplikacja ma panelu, który zawiera cztery <xref:System.Windows.Controls.TextBox> formantów, z których każdy jest powiązany z jedną z właściwości obiektu. Można użyć <xref:System.Windows.Controls.ValidationRule> w <xref:System.Windows.Data.BindingGroup> do sprawdzania poprawności `Address` obiektu. Na przykład <xref:System.Windows.Controls.ValidationRule> można zapewnić, że kod pocztowy jest prawidłowy dla kraju adresu.  
  
 Elementy podrzędne dziedziczą <xref:System.Windows.Data.BindingGroup> z ich elementów nadrzędnych, po prostu tak jak w przypadku innych właściwości dziedziczonych.  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.BindingGroupProperty>|  
|Wartość właściwości metadanych **true**|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Poniższe przykłady są częścią aplikacji, która sprawdza, czy użytkownik ma wartość właściwości dwa obiekty równe wartości. W pierwszym przykładzie jest tworzony dwa <xref:System.Windows.Controls.TextBox> formantów, z których każdy jest powiązany z innym źródłem danych. <xref:System.Windows.Controls.StackPanel> Ma <xref:System.Windows.Data.BindingGroup> zawierający <xref:System.Windows.Controls.ValidationRule> która sprawdza, czy dwa ciągi są takie same.  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupComplete](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupcomplete)]  
  
 W poniższym przykładzie przedstawiono <xref:System.Windows.Controls.ValidationRule> używającej w poprzednim przykładzie.  W <xref:System.Windows.Controls.ValidationRule.Validate%2A> zastąpienie metody przykładzie pobiera każdego obiektu źródłowego z <xref:System.Windows.Data.BindingGroup> i sprawdza, czy właściwości obiektów są takie same.  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 Aby wywołać <xref:System.Windows.Controls.ValidationRule>, wywołaj <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> metody.  Następujące przykładowe wywołania <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> gdy wystąpi zdarzenie kliknięcia przycisku.  
  
 [!code-csharp[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#updatesourcesclick)]
 [!code-vb[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#updatesourcesclick)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.BindingGroup" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BringIntoView">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Podejmuje próbę wprowadzenia tego elementu w widoku w ramach żadnych przewijanego regionów, który jest zawarty w.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Podejmuje próbę wprowadzenia tego elementu w widoku w ramach żadnych przewijanego regionów, który jest zawarty w.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołując tę metodę, zostanie podniesiony <xref:System.Windows.FrameworkElement.RequestBringIntoView> zdarzenie, które pochodzą z bieżącego elementu. To zdarzenie jest zgłaszane, dzięki czemu mogą być obsługiwane przez <xref:System.Windows.Controls.ScrollViewer>, lub klasy pochodnej lub podobny. Oczekiwane zachowanie jest, że zdarzenie jest obsługiwane przez element nadrzędny, oznaczone obsługiwanego w danych zdarzenia i źródło zdarzenia jest przeznaczone do wyświetlenia za pomocą logiki osadzone w <xref:System.Windows.Controls.ScrollViewer> formantu. Ani <xref:System.Windows.FrameworkElement.RequestBringIntoView> zdarzeń ani <xref:System.Windows.FrameworkElement.BringIntoView%2A> — metoda przekazuje wszystkie informacje o powodzeniu lub niepowodzeniu, innym niż zdarzenie jest zwykle oznaczony jako obsługiwany na powodzenie. Możliwe przyczyny niepowodzenia sytuacji takich jak ustawienia elementu <xref:System.Windows.UIElement.Visibility%2A> są niektóre wartości innych niż <xref:System.Windows.Visibility.Visible>.  
  
 Jeśli używasz podpisu, która nie określa `targetRectangle`, niż rozmiar całego elementu (jego <xref:System.Windows.UIElement.RenderSize%2A>) będą widoczne.  
  
 Wywołując tę metodę, możesz potencjalnie wywoła <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> na wszelkie przewijany obszar nadrzędny, który zawiera element. Jeśli ten element nie jest zawarta w przewijany obszar <xref:System.Windows.FrameworkElement.RequestBringIntoView> nadal zdarzenia, ale nie będzie żadnego skutku ponieważ istnieją nie odbiorników zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład implementuje obsługi dla zdarzenia nawigacji aplikacji, które odpowiada w każdym przypadku, gdy [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] trwa przejście obejmuje fragmentu. Fragment jest nazywane [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] po znak kratki (#), i zachowanie zaimplementowanym powoduje, że element przewiń do widoku w ramce. <xref:System.Windows.FrameworkElement.BringIntoView%2A> i <xref:System.Windows.FrameworkElement.RequestBringIntoView> żądania to zachowanie przewijania w przykładzie.  
  
 [!code-csharp[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/csharp/VS_Snippets_Wpf/FragmentNavigationSample/CSharp/MainWindow.xaml.cs#febringintoview)]
 [!code-vb[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FragmentNavigationSample/VisualBasic/MainWindow.xaml.vb#febringintoview)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView (System.Windows.Rect targetRectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView(valuetype System.Windows.Rect targetRectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView (targetRectangle As Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView(System::Windows::Rect targetRectangle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetRectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="targetRectangle">Określony rozmiar elementu, który również należy dostosować do widoku.</param>
        <summary>Podejmuje próbę wprowadzenia rozmiar podany region tego elementu w widoku w ramach żadnych przewijanego regionów, który jest zawarty w.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołując tę metodę, zostanie podniesiony <xref:System.Windows.FrameworkElement.RequestBringIntoView> zdarzenie, które pochodzą z bieżącego elementu. To zdarzenie jest zgłaszane, dzięki czemu mogą być obsługiwane przez <xref:System.Windows.Controls.ScrollViewer>, lub klasy pochodnej lub podobny. Oczekiwane zachowanie jest, że zdarzenie jest obsługiwane przez element nadrzędny, oznaczone obsługiwanego w danych zdarzenia i źródło zdarzenia jest przeznaczone do wyświetlenia za pomocą logiki osadzone w <xref:System.Windows.Controls.ScrollViewer> formantu. Ani <xref:System.Windows.FrameworkElement.RequestBringIntoView> zdarzeń ani <xref:System.Windows.FrameworkElement.BringIntoView%2A> — metoda przekazuje wszystkie informacje o powodzeniu lub niepowodzeniu, innym niż zdarzenie jest zwykle oznaczony jako obsługiwany na powodzenie. Możliwe przyczyny niepowodzenia sytuacji takich jak ustawienia elementu <xref:System.Windows.UIElement.Visibility%2A> są niektóre wartości innych niż <xref:System.Windows.Visibility.Visible>.  
  
 Jeśli używasz podpisu, która nie określa `targetRectangle`, niż rozmiar całego elementu (jego <xref:System.Windows.UIElement.RenderSize%2A>) będą widoczne.  
  
 Wywołując tę metodę, możesz potencjalnie wywoła <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> na wszelkie przewijany obszar nadrzędny, który zawiera element. Jeśli ten element nie jest zawarta w przewijany obszar <xref:System.Windows.FrameworkElement.RequestBringIntoView> nadal zdarzenia, ale nie będzie żadnego skutku ponieważ istnieją nie odbiorników zdarzeń.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono dużej grafiki w regionie ograniczonego przewijania. Przycisk na stronie ma obsługi, który przewija widok w określonym regionie dużej grafiki.  
  
 [!code-xaml[BaseElementsSmorgasbord#BringIntoViewRectMarkup](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml#bringintoviewrectmarkup)]  
  
 [!code-csharp[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#bringintoviewrectcode)]
 [!code-vb[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#bringintoviewrectcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.FlowDocumentScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia element menu kontekstowego, który powinien zostać wyświetlony każdorazowo menu kontekstowe jest wymagane przez [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] z wewnątrz tego elementu.</summary>
        <value>Menu kontekstowe przypisane do tego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ContextMenu> jest <xref:System.Windows.FrameworkElement> klasy i jest technicznie możliwe w dla <xref:System.Windows.Controls.ContextMenu> do ma <xref:System.Windows.FrameworkElement.ContextMenu%2A> właściwości. Jednak spowoduje to utworzenie mylące obsługi menu kontekstowego dla użytkownika i takie rozwiązanie nie jest zalecane.  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ContextMenuProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje zaraz przed zamknięciem dowolnego menu kontekstowego w elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby pominąć zamknięcia menu kontekstowe, programy obsługi zdarzenia należy oznaczyć go jako obsłużone.  
  
 Aby użyć tego zdarzenia jako <xref:System.Windows.EventTrigger> w stylu, musi odwoływać się podległej usłudze definicji zdarzenia:  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (To użycie jest konieczne, ponieważ implementacja zdarzeń na <xref:System.Windows.FrameworkElement> czy ujawnia odpowiadające mu zdarzenie usługi nie został zmapowany <xref:System.Windows.FrameworkElement.ContextMenuClosing> identyfikator tak, aby można go użyć jako wyzwalacz).  
  
 <xref:System.Windows.Controls.ContextMenu> jest <xref:System.Windows.FrameworkElement> klasy, ale <xref:System.Windows.FrameworkElement.ContextMenuClosing> zdarzeń nie będą zgłaszane przez menu kontekstowe bezpośrednio. Zamiast tego zdarzenie jest wywoływane z elementu "właścicielem" jako właściwość menu kontekstowego, który jest wywoływany tylko wtedy, gdy użytkownik próbuje zamknąć menu kontekstowego w interfejsie użytkownika. Jednak możliwe jest <xref:System.Windows.Controls.ContextMenu> do ma <xref:System.Windows.FrameworkElement.ContextMenu%2A> właściwości (menu kontekstowe zagnieżdżonych). W takim przypadku <xref:System.Windows.Controls.ContextMenu> naprawdę właścicielem zagnieżdżone <xref:System.Windows.Controls.ContextMenu> i może zgłosić zdarzenie, ze źródłem zdarzenia jest menu kontekstowe zagnieżdżonych.  
  
 <xref:System.Windows.Controls.ContextMenu> Sama klasa ma również podobne zdarzenia (<xref:System.Windows.Controls.ContextMenu.Closed>), ale <xref:System.Windows.Controls.ContextMenu.Closed> zdarzeń nie daje możliwość anulowania akcji użytkownika.  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ContextMenuClosingEvent>|  
|Strategii routingu|Propagacji|  
|Delegate|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   Zastąpienie <xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A> do zaimplementowania klasy obsługi dla tego zdarzenia w klasach pochodnych.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /> kierowanego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory kierowanego zdarzenia są tworzone, gdy kierowane zdarzenia są rejestrowane. Te identyfikatory zawiera nazwę identyfikującą, typ właściciela, typ obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia. Aby dodać obsługę klas, można użyć tych identyfikatorów.  
  
 Aby uzyskać więcej informacji na temat rejestrowania kierowane zdarzenia, zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Aby uzyskać więcej informacji o używaniu identyfikatorów kierowanego zdarzenia, aby dodać obsługę klas, zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po otwarciu dowolnego menu kontekstowego w elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można ręcznie otworzyć menu kontekstowe, programy obsługi zdarzeń należy oznaczyć dane zdarzenie jako obsłużone. W przeciwnym razie wartość istniejących <xref:System.Windows.FrameworkElement.ContextMenu%2A> właściwości będzie można użyć do automatycznego otwierania menu kontekstowego. Oznaczenie zdarzenia obsługiwane skutecznie spowoduje anulowanie domyślne działanie i może być możliwość resetowania wartości <xref:System.Windows.FrameworkElement.ContextMenu%2A> właściwości, a następnie otwórz nową <xref:System.Windows.Controls.ContextMenu>. Jednak jest to problem chronometrażu, które należy zwrócić uwagę. Aby całkowicie zastąpić menu kontekstowe za pośrednictwem <xref:System.Windows.FrameworkElement.ContextMenuOpening> programu obsługi, menu kontekstowe początkowy nie może być, null / puste. Alternatywnie konieczne może być zdarzenie, a następnie ręcznie otworzyć nowego menu kontekstowego. Aby uzyskać więcej informacji, zobacz [porady: Obsługa zdarzenia ContextMenuOpening](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).  
  
 Aby użyć tego zdarzenia jako <xref:System.Windows.EventTrigger> w stylu, musi odwoływać się podstawowym dołączone zdarzenie:  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (To użycie jest konieczne, ponieważ implementacja zdarzeń na <xref:System.Windows.FrameworkElement> czy ujawnia odpowiadające mu zdarzenie usługi nie został zmapowany <xref:System.Windows.FrameworkElement.ContextMenuOpening> identyfikator taki sposób, że może być używany w wyzwalaczy).  
  
 <xref:System.Windows.Controls.ContextMenu> jest <xref:System.Windows.FrameworkElement> klasy, ale to zdarzenie nie zostanie wygenerowany z menu kontekstowego otwierany jako źródło. Zdarzenie jest wywoływane z elementu "właścicielem" jako właściwość menu kontekstowego, który jest wywoływany tylko wtedy, gdy użytkownik próbuje otworzyć menu kontekstowego w interfejsie użytkownika. Istnieje możliwość <xref:System.Windows.Controls.ContextMenu> do ma <xref:System.Windows.FrameworkElement.ContextMenu%2A> właściwości, ale należy unikać w tym scenariuszu (Aby uzyskać więcej informacji, zobacz <xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType>).  
  
 <xref:System.Windows.Controls.ContextMenu> Sama klasa ma również podobne zdarzenia (<xref:System.Windows.Controls.ContextMenu.Opened>), ale <xref:System.Windows.Controls.ContextMenu.Opened> nie zapewnia możliwość anulowania akcji użytkownika.  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ContextMenuOpeningEvent>|  
|Strategii routingu|Propagacji|  
|Delegate|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   Zastąpienie <xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A> do zaimplementowania klasy obsługi dla tego zdarzenia w klasach pochodnych.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> kierowanego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory kierowanego zdarzenia są tworzone, gdy kierowane zdarzenia są rejestrowane. Te identyfikatory zawiera nazwę identyfikującą, typ właściciela, typ obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia. Aby dodać obsługę klas, można użyć tych identyfikatorów.  
  
 Aby uzyskać więcej informacji na temat rejestrowania kierowane zdarzenia, zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Aby uzyskać więcej informacji o używaniu identyfikatorów kierowanego zdarzenia, aby dodać obsługę klas, zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.ContextMenu" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kursor wyświetlany, gdy wskaźnik myszy znajduje się nad tym elementem.</summary>
        <value>Kursor do wyświetlenia. Wartością domyślną jest zdefiniowany jako <see langword="null" /> na ta właściwość zależności. Jednak domyślnie praktyczne w czasie wykonywania będzie pochodził z różnych czynników.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta właściwość jest ustawiona w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] procesora zależy od typu konwersji <xref:System.Windows.Input.Cursor> klasę, aby ocenić ten ciąg. Podany ciąg powinno zostać oszacowane <xref:System.Windows.Input.CursorType> wartość. Zobacz <xref:System.Windows.Input.Cursor> szczegółowe informacje.  
  
 Czy kursor zgodnie z ustaleniami tej właściwości będzie lub nie będą wyświetlane, gdy wskaźnik myszy znajduje się nad tym elementem również jest zależny od wartości <xref:System.Windows.FrameworkElement.ForceCursor%2A> właściwości. Ponadto związane ze zdarzeniami zagadnienia, takie jak active przeciągania, przechwytywanie myszy, tryby w kontrolek i tak dalej do edycji tekstu wpłynie również na kursor mające wyższy priorytet niż określona wartość określoną w tej właściwości.  
  
 Aby przywrócić zachowanie ostatecznego domyślne ustawienie dla tej właściwości, należy ustawić ją na `null` ponownie.  
  
 `null` Domyślne naprawdę oznacza, że określenie wartości praktyczne kursora została odroczona tutaj mają być uzyskiwane z innej lokalizacji. Jeżeli bez programowe wartości z dowolnego źródła, kursor domyślny to wizualne ponad [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] aplikacja będzie strzałka. Jednak zmiany przejściowej kursora nie ustawiono <xref:System.Windows.FrameworkElement.Cursor%2A> wartości elementów, gdy są one przekazywane za pośrednictwem. <xref:System.Windows.FrameworkElement.Cursor%2A> Właściwość zostanie tylko raportu zerowe wartości w przypadkach, w którym została faktycznie ustawiona, na przykład za pomocą kodu lub stylu. Każdy przepływ myszy nad [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] zgłasza aplikacji <xref:System.Windows.UIElement.QueryCursor> zdarzeń. Dymki zdarzeń, a każdy element marszruty ma możliwość obsługi zdarzenia i ustawić wartość kursora argumenty to zdarzenie. Jest to mechanizm, który tworzy wizualnie jawnego kursora w większości przypadków. Jeśli <xref:System.Windows.UIElement.QueryCursor> obsługi zwraca wynik kursora, a następnie fakt, że zdarzenie jest obsługiwana i została zmieniona wartość w argumentach mają pierwszeństwo przed wartością <xref:System.Windows.FrameworkElement.Cursor%2A> właściwości na dowolnym poziomie, chyba że <xref:System.Windows.FrameworkElement.ForceCursor%2A> jest ustawiona.  
  
 Jeśli nie są tworzone niestandardowych kursorów, zwykle Ustaw tą właściwość na wartość właściwości statycznej <xref:System.Windows.Input.Cursors> klasy. Ustawienie <xref:System.Windows.FrameworkElement.Cursor%2A> w kodzie wymaga jednej z następujących czynności:  
  
-   Wywołanie <xref:System.Windows.Input.Cursor> konstruktora, aby pobrać <xref:System.Windows.Input.Cursor> wystąpienia. Zarówno sygnatur <xref:System.Windows.Input.Cursor> strumieni lub plików, w oczekiwaniu tworzonego użyć konstruktora <xref:System.Windows.Input.Cursor> obiektu dla niestandardowych kursora.  
  
-   Użyj <xref:System.Windows.Input.CursorConverter> klasy i jej <xref:System.Windows.Input.CursorConverter.ConvertFrom%2A> metodę, aby określić kursora przez <xref:System.Windows.Input.CursorType>, lub ciąg, który może być <xref:System.Windows.Input.CursorType>i wróć do rzutowania <xref:System.Windows.Input.Cursor>.  
  
 Ustawienie <xref:System.Windows.Input.Cursor> do niestandardowej wartości nie jest włączone w częściowej relacji zaufania. Aby uzyskać więcej informacji o niestandardowych kursorów, zobacz [omówienie wprowadzania](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.CursorProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak ustawić celowo grafiki kursora.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.Cursor" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kontekst danych dla elementu, gdy uczestniczy w powiązaniu danych.</summary>
        <value>Obiekt, który ma być używana jako kontekst danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Kontekst danych* to pojęcie umożliwia elementom dziedziczenie informacji z ich elementów nadrzędnych dotyczące źródła danych, która jest używana do wiązania, a także innych charakterystyk powiązania, takich jak ścieżka.  
  
 Kontekst danych można ustawić bezpośrednio do [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] obiektu z powiązaniami obliczane do właściwości tego obiektu. Alternatywnie można ustawić kontekstu danych <xref:System.Windows.Data.DataSourceProvider> obiektu.  
  
 Ta właściwość zależności dziedziczy wartości właściwości. Jeśli istnieją elementy podrzędne bez innych wartości <xref:System.Windows.FrameworkElement.DataContext%2A> ustanowić za pośrednictwem style, lub wartości lokalnej, a następnie system właściwość zostanie ustaw wartość na <xref:System.Windows.FrameworkElement.DataContext%2A> wartości najbliższym elemencie nadrzędnym z tej wartości przypisane.  
  
 Alternatywnie można użyć jednej z następujących właściwości <xref:System.Windows.Data.Binding> klasę, aby jawnie określić źródło powiązania: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, lub <xref:System.Windows.Data.Binding.RelativeSource%2A>. Aby uzyskać więcej informacji, zobacz [porady: Określanie powiązania źródła](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).  
  
 W [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkElement.DataContext%2A> najczęściej jest ustawiony jako <xref:System.Windows.Data.Binding> deklaracji. Można użyć składni elementu właściwości lub Składnia atrybutu. Składnia atrybutu jest pokazano w przykładzie na tej stronie. Można również użyć kodu można ustawić <xref:System.Windows.FrameworkElement.DataContext%2A>.  
  
 <xref:System.Windows.FrameworkElement.DataContext%2A> jest właściwości możliwej do wiązania, aby ułatwić scenariusze, w którym jednego kontekstu może być powiązana do innego. Jednak jeśli powiązać z <xref:System.Windows.FrameworkElement.DataContext%2A>, należy zachować ostrożność, aby nie były tworzone powiązanie cykliczne odwołania (nie powiązuj <xref:System.Windows.FrameworkElement.DataContext%2A> do samej siebie, który jest możliwe z powodu właściwości wartość dziedziczenia rodzaj <xref:System.Windows.FrameworkElement.DataContext%2A> właściwości).  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *dataContextObject*  
 Bezpośrednio osadzonego obiektu, który służy jako kontekst danych dla powiązań w elemencie nadrzędnym. Zazwyczaj jest to obiekt <xref:System.Windows.Data.Binding> lub innym <xref:System.Windows.Data.BindingBase> klasy. Alternatywnie nieprzetworzone dane dowolnego [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] przeznaczone do powiązania mogą być umieszczane w tym miejscu z rzeczywistego powiązań zdefiniowanych później typu obiektu.  
  
 *bindingUsage*  
 Użycie powiązanie daje w wyniku kontekstu odpowiednich danych. Aby uzyskać więcej informacji, zobacz [powiązanie — rozszerzenie znaczników](~/docs/framework/wpf/advanced/binding-markup-extension.md).  
  
 *resourceExtension*  
 Jedną z następujących: lub. To użycie jest używany podczas odwoływania się do danych pierwotnych definiowana jako obiekt w zasobach. Zobacz [zasobów XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *contextResourceKey*  
 Identyfikator klucza dla żądanej za pomocą obiektu <xref:System.Windows.ResourceDictionary>.  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.DataContextProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono sposób działania kontekstu danych w przypadku powiązania oraz zawiera informacje, które definiuje określone wartości we właściwościach powiązania.  
  
 [!code-xaml[MasterDetail#DataContextProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty)]  
[!code-xaml[MasterDetail#DataContextProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty2)]  
[!code-xaml[MasterDetail#DataContextProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie kontekstu danych dla tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać informacje o kontekstach danych i powiązania danych, zobacz [omówienie powiązania danych](~/docs/framework/wpf/data/data-binding-overview.md).  
  
> [!IMPORTANT]
>  Gdy <xref:System.Windows.FrameworkElement.DataContext%2A> zmiany elementu potencjalnie dotyczy wszystkich właściwości powiązanych z danymi w tym elemencie. Dotyczy to elementów, które są elementy podrzędne bieżącego elementu w drzewie logicznym, które dziedziczą z kontekstu danych, a także bieżącego elementu. Takie istniejących powiązań musi ponownie zinterpretować nowe <xref:System.Windows.FrameworkElement.DataContext%2A> i będzie obliczyć ponownie wyniki powiązania. Aparat wiązania danych nie jest deterministyczna o zamówieniu te reevaluations względem gromadzenia <xref:System.Windows.FrameworkElement.DataContextChanged> zdarzeń. Reevaluations może wystąpić przed zdarzeniem, po zdarzeniu lub w dowolnej kombinacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.DataContext" />
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.DataContext" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia klucz do użycia, aby odwołać stylu dla tego formantu, gdy style kompozycji są używane lub zdefiniowany.</summary>
        <value>Klucz stylu. Działała prawidłowo, jako część wyszukiwania stylów motywu, ta wartość powinna być <see cref="T:System.Type" /> formantu jest stylem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zazwyczaj nie ustawiono za pomocą dowolnej z metod dostępu do jej bezpośredniego właściwości. Zamiast tego należy zastąpić metadane specyficzne dla typu ta właściwość zależności przy tworzeniu nowego <xref:System.Windows.FrameworkElement> klasy. Gdy pochodzi formantu, wywołaj <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> metoda przed <xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty> identyfikator w konstruktorze statycznym formantu pochodnej klasy (lub równoważne klasy inicjowania).  
  
 Formant zazwyczaj domyślnej wartości tej właściwości do własnej typu, ale w niektórych przypadkach można użyć również typu podstawowego, dla której istnieje styl słowników motywu. Jest to tylko praktyczne szablonów kontrolki podstawowej kontrolki całkowicie zdefiniować wizualną reprezentację tego formantu pochodnej, a niezależnie od dodatkowych członków ujawnia typy pochodne nie wymagają dodatkowych elementów w ramach kontroli szablonu.  
  
 Jeśli chcesz, elementu lub formantu celowo nie style kompozycji, ustawić <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> właściwości `true`.  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie Zastępowanie metadanych właściwości zależności omówione w uwagi. Ten kod definiuje klasę formantu niestandardowego `NumericUpDown` przeznaczony do użycia z zestawu biblioteki dedykowanej formantu. Ilustrowane Konstruktor statyczny odwołuje się do niektórych funkcji inicjowania prywatne, rejestruje obsługi klasy (inny typowy scenariusz podklasy formantu; zobacz [oznaczenie kierowane zdarzenia jako Handled i obsługa klasy](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)), a na koniec zastępuje <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> metadanych właściwości zależności na `NumericUpDown` klasy. <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> zawsze zwraca jego własnego typu jako zamierzone klucz, który jest Konwencji używanym przez system stylów motywu do odszukania stylu dla niektórych dowolnego inaczej niż styl formantu. Kompletne przykładowe definiuje również rzeczywistą kontrolę styl motywu, który odwołuje się do tego klucza; zobacz [numericupdown — formant niestandardowy motyw i przykładowe Obsługa automatyzacji interfejsu użytkownika](http://go.microsoft.com/fwlink/?LinkID=160025).  
  
 [!code-csharp[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/NumericUpDown.cs#staticctorofcustomclasscommontasks)]
 [!code-vb[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/numericupdown.vb#staticctorofcustomclasscommontasks)]  
[!code-csharp[CustomControlNumericUpDown#Close](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/NumericUpDown.cs#close)]
[!code-vb[CustomControlNumericUpDown#Close](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/numericupdown.vb#close)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.DefaultStyleKey" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, że proces inicjowania elementu jest pełny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.FrameworkElement.BeginInit%2A> wcześniej została wywołana, podstawowym zgłosi implementacji <xref:System.Windows.FrameworkElement.Initialized> zdarzeń. W przeciwnym razie, jeśli <xref:System.Windows.FrameworkElement.BeginInit%2A> nie została wywołana lub nie można ustalić, czy <xref:System.Windows.FrameworkElement.BeginInit%2A> została wywołana <xref:System.Windows.FrameworkElement.Initialized> nie jest wywoływane i zamiast tego jest zgłaszany wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.FrameworkElement.EndInit" /> Wywołano bez <see cref="M:System.Windows.FrameworkElement.BeginInit" /> o wcześniej nazywane w elemencie.</exception>
        <block subset="none" type="overrides">
          <para>Zaimplementuj tę metodę w celu zapewnienia specjalnej obsługi, które powinno się zdarzyć, gdy zainicjowano danego elementu w elemencie proces ładowania.  
  
 Implementacji powinny wywoływać implementację podstawową, ponieważ niektóre wewnętrzny flagi do śledzenia inicjowania ustawia implementacji base (ustawienie domyślne).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa żądanego elementu.</param>
        <summary>Odnajduje element o podanym identyfikatorze nazwie.</summary>
        <returns>Żądany element. Może to być <see langword="null" /> , jeśli nie został znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli element ma elementy podrzędne, te elementy podrzędne są wszystkie rekursywnie przeszukiwane dla żądanego o nazwie elementu.  
  
 <xref:System.Windows.FrameworkElement.FindName%2A> działa w namescope bieżącego elementu. Aby uzyskać więcej informacji, zobacz [WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Identyfikator klucza w odniesieniu do żądanego zasobu.</param>
        <summary>Wyszukuje zasób z określonym kluczem i zgłasza wyjątek, jeśli nie odnaleziono żądanego zasobu.</summary>
        <returns>Żądany zasób. Jeśli nie znaleziono zasobów przy użyciu podanego klucza, jest zwracany wyjątek. <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> Wartość może być również zwrócony w przypadku wyjątku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Jeśli ta metoda jest wywoływana dla klucza, którego nie można znaleźć, jest zwracany wyjątek. Jeśli nie chcesz obsługi wyjątków, wynikających z wywołaniem <xref:System.Windows.FrameworkElement.FindResource%2A>, wywołaj <xref:System.Windows.FrameworkElement.TryFindResource%2A> zamiast tego. <xref:System.Windows.FrameworkElement.TryFindResource%2A> Zwraca `null` gdy nie można odnaleźć żądanego zasobu, a nie zgłasza wyjątek.  
  
 Jeśli zasób nie zostanie znaleziony w elemencie wywołującym, elementu nadrzędnego w drzewie logicznym jest przeszukane dalej, a następnie aplikacji, a następnie kompozycje, a na końcu zasobów systemowych. Tej metody wyszukiwania jest identyczna jak przeszukiwany jest drzewa, jeśli zasób prosili odwołaniem zasobu dynamicznego w znaczniku. Aby uzyskać więcej informacji na temat wyszukiwania zasobów, zobacz [zasobów XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 Zwykle, możesz od razu rzutowania <xref:System.Windows.FrameworkElement.FindResource%2A> powrót wartości na typ właściwości który ustawienie z wartością zwrócony zasobów.  
  
 Klucze zasobów niekoniecznie ciągów. Na przykład style dla formantów na poziomie motywu celowo określonemu <xref:System.Type> sterowania i aplikacji lub strony style dla jest zazwyczaj używana formanty klucza Konwencji. Aby uzyskać więcej informacji, zobacz [stylami i tworzenia szablonów](~/docs/framework/wpf/controls/styling-and-templating.md) lub [zasobów XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
   
  
## Examples  
 Poniższy przykład uzyskuje nazwanego zasobu i rzutuje odpowiedniego typu, aby wypełnić właściwości.  
  
 [!code-csharp[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page3.xaml.cs#resourceproceduralget)]
 [!code-vb[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page3.xaml.vb#resourceproceduralget)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">
          <paramref name="resourceKey" /> Nie można odnaleźć i program obsługi zdarzeń nie istnieje dla <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /> zdarzeń.  
  
 —lub—  
  
 <paramref name="resourceKey" /> Nie można odnaleźć i <see cref="P:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled" /> właściwość jest <see langword="false" /> w <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /> zdarzeń.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceKey" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FlowDirection">
      <MemberSignature Language="C#" Value="public System.Windows.FlowDirection FlowDirection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FlowDirection FlowDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FlowDirection" />
      <MemberSignature Language="VB.NET" Value="Public Property FlowDirection As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FlowDirection FlowDirection { System::Windows::FlowDirection get(); void set(System::Windows::FlowDirection value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia kierunek, tekst i inne [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] elementy przepływ w żadnym elementem nadrzędnym, który kontroluje ich układ.</summary>
        <value>Kierunek tekstu i inne [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] elementy przepływu w ramach jego elementu nadrzędnego jako wartość wyliczenia. Wartość domyślna to <see cref="F:System.Windows.FlowDirection.LeftToRight" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestawy użycia właściwości zależności <xref:System.Windows.FrameworkElement.FlowDirection%2A> w tym elemencie. Ze względu na wartość dziedziczenia, ustawienie <xref:System.Windows.FrameworkElement.FlowDirection%2A> potencjalnie można ustawić w elemencie <xref:System.Windows.FrameworkElement.FlowDirection%2A> na wszystkie elementy podrzędne, które nie ustawione <xref:System.Windows.FrameworkElement.FlowDirection%2A> lokalnie lub jednak innych środków, takich jak style.  
  
 Tej właściwości nie jest automatycznie ustawiony jako część żadnych informacji o kulturze aplikacji, ponieważ element może zawierać zawartość, która nie jest zawsze przeznaczony do wyświetlane zgodnie z kierunkiem ogólny przebieg implikowana przez informacji o kulturze. Aby uzyskać więcej informacji dotyczących zagadnienia dotyczące globalizacji, zobacz [globalizacji dla WPF](~/docs/framework/wpf/advanced/globalization-for-wpf.md).  
  
 Ta właściwość nie ma zdefiniowanych [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] metody dostępu właściwości, aby działała jako właściwość zależności. Jednak pozostanie on również zarejestrowany jako dołączony, dzięki czemu może również działać jako dołączona właściwość. Dołączone rejestracji jest głównie, aby wartość dziedziczenia jest obsługiwana, ale właściwość mogą służyć jako true dołączona właściwość. Dołączona właściwość jest tylko istotne, jeśli chcesz ustawić kierunek przepływu dla obiekt ma <xref:System.Windows.FrameworkElement> elementu nadrzędnego, który wykonuje układu stronę, jest nie <xref:System.Windows.FrameworkElement>i nie ma jeszcze bardziej bezpośrednio zdefiniowanych `FlowDirection` Właściwość. (Niektóre przepływu dokumentu klas takich jak <xref:System.Windows.Documents.Block> i <xref:System.Windows.Documents.Inline> definiować własne `FlowDirection`, a ta właściwość można ustawić kierunku przepływu. Wartość właściwości jest następnie odczytywane przez ostatecznego host zawartości bez konieczności użycia dołączona właściwość.)  
  
<a name="xamlAttributeUsage_FlowDirection"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
 \<*obiekt* **wartość FlowDirection**= "<xref:System.Windows.FlowDirection>" / >  
  
<a name="xamlTextUsage_FlowDirection"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Można również ustawić tę właściwość na klasy, które nie są <xref:System.Windows.FrameworkElement> pochodzi z klasy, co następuje [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] dołączona właściwość użycia:  
  
 `<` *obiekt* `FrameworkElement.` **wartość FlowDirection**= "<xref:System.Windows.FlowDirection>`"/>`  
  
<a name="dependencyPropertyInfo_FlowDirection"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.FlowDirectionProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 Ta właściwość jest właściwością zależności i dołączona właściwość; Zobacz uwagi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlowDirectionProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FlowDirectionProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FlowDirectionProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FlowDirectionProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FlowDirectionProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia właściwość, która umożliwia dostosowanie wyglądu, efekty lub inne właściwości stylu, które zostaną zastosowane do tego elementu po zarejestrowaniu fokus klawiatury.</summary>
        <value>Żądany styl, aby zastosować na fokus. Wartość domyślna, zgodnie z deklaracją w właściwości zależności jest pusty statyczne <see cref="T:System.Windows.Style" />. Jednak wartość w czasie wykonywania jest często (ale nie zawsze) styl dostarczony przez motywu obsługę formantów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość ma wpływ na wygląd, ale nie raportuje <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> w metadanych. To dlatego Zmień wygląd jest sterowane zdarzeniami i nie może być stosowane przez cały czas i w związku z tym należy nie ogólnie raportować żadnych informacji visual ani układu w metadanych.  
  
 Koncepcyjnie visual zachowanie fokus do formantu powinna być spójne z formantami. Najbardziej za pośrednictwem sposób, aby wymusić spójność jest tylko zmiana fokusu stylu wizualnego. w przypadku redagowania całego motywu. Ustawienie tej właściwości na style poszczególnych kontrolek, a nie jako część kompozycji nie jest zamierzone użycie tej właściwości, ponieważ może dojść do mylące czynności użytkownika dotyczących fokus klawiatury. Jeśli są mają zostać zachowanie specyficzne dla formantu celowo nie jest spójny we motywu, znacznie lepszym rozwiązaniem jest używać Wyzwalacze w stylach właściwości poszczególnych stanu danych wejściowych, takich jak <xref:System.Windows.UIElement.IsFocused%2A> lub <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>i aby to zrobić w taki sposób, który nie obsługuje wizualne zakłócać wszelkie istniejące stylu wizualnego fokus. Aby uzyskać więcej informacji na zamiar projektu <xref:System.Windows.FrameworkElement.FocusVisualStyle%2A> i alternatywne skupić się właściwości, zobacz [style dla zespołu w formantach i FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *resourceExtension*  
 Jedną z następujących:, lub. Zobacz [zasobów XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Klucz identyfikujący styl żądanej. Klucz odnosi się do istniejącego zasobu w <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Składni elementu właściwości jest technicznie możliwe, ale nie jest zalecane. Zobacz [style wbudowane i szablony](~/docs/framework/wpf/advanced/inline-styles-and-templates.md). Odwołanie do wiązania za pomocą lub <xref:System.Windows.Data.Binding> jest także możliwe, ale rzadko.  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.FocusVisualStyleProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.FocusVisualStyle" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy to <see cref="T:System.Windows.FrameworkElement" /> powinien wymusić [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] do renderowania kursora w postaci zadeklarowanej przez <see cref="P:System.Windows.FrameworkElement.Cursor" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli prezentacji kursor znajduje się nad tym elementem wymuszono Użyj bieżącego <see cref="P:System.Windows.FrameworkElement.Cursor" /> ustawienia dla kursora (w tym na wszystkie elementy podrzędne); w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta właściwość jest ustawiona na `true` spowoduje zastąpienie preferencje kursora ustala elementy podrzędne. To dlatego na ogół aplikacji [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] może być mylące dla użytkownika, zwłaszcza w przypadku, gdy próbuje określić kursory elementy podrzędne. Ustawienie <xref:System.Windows.FrameworkElement.ForceCursor%2A> jest bardziej odpowiednie w scenariuszach podklasy lub składania formantu.  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ForceCursorProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład powoduje wartość kursora.  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.ForceCursor" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Element docelowy <see cref="T:System.Windows.DependencyProperty" /> uzyskać powiązania z.</param>
        <summary>Zwraca <see cref="T:System.Windows.Data.BindingExpression" /> reprezentujący powiązania dla określonej właściwości.</summary>
        <returns>A <see cref="T:System.Windows.Data.BindingExpression" /> Jeśli właściwość target ma powiązanie active; w przeciwnym razie zwraca <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sprawdzanie wartości zwracanej przez `null` to technika służy do ustalania, czy właściwość ma aktywne powiązania.  
  
 Ta metoda jest w rzeczywistości po prostu wygody otokę <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType> metody. <xref:System.Windows.FrameworkElement.GetBindingExpression%2A> przekazuje bieżącego wystąpienia i `dp` parametr <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Data.BindingOperations" />
      </Docs>
    </Member>
    <Member MemberName="GetFlowDirection">
      <MemberSignature Language="C#" Value="public static System.Windows.FlowDirection GetFlowDirection (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FlowDirection GetFlowDirection(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFlowDirection (element As DependencyObject) As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FlowDirection GetFlowDirection(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Element, aby zwrócić <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> dla.</param>
        <summary>Pobiera wartość <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> dołączona właściwość dla określonego <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Kierunek przepływu żądanego jako wartość wyliczenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Głównym celem tej metody jest obsługuje składnia dołączonej właściwości <xref:System.Windows.FrameworkElement.FlowDirection%2A> właściwości, w związku z tym stosowanie podrzędne elementy podana <xref:System.Windows.FrameworkElement> do określania kierunku przepływu dla rozmieszczenia w ramach jego elementu nadrzędnego. Można uzyskać wartość na bieżącej <xref:System.Windows.FrameworkElement>, użyj bezpośrednio [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] akcesor <xref:System.Windows.FrameworkElement.FlowDirection%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="GetLayoutClip">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Geometry GetLayoutClip(valuetype System.Windows.Size layoutSlotSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetLayoutClip (layoutSlotSize As Size) As Geometry" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Geometry ^ GetLayoutClip(System::Windows::Size layoutSlotSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layoutSlotSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="layoutSlotSize">Rozmiar część elementu, który wykonuje wizualną prezentację.</param>
        <summary>Zwraca geometrii maski wycinka. Maska ma zastosowanie, gdy system układu próbuje Rozmieść element, który jest większy niż dostępny ekran.</summary>
        <returns>Geometria wycinka.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Marginesy zostanie odjęta od `layoutSlotSize` jako część układu zachowanie systemu.  
  
 Odwołanie o wartości null zwracane wskazuje, czy wycinka nie zostanie przeprowadzona. Domyślna implementacja zawsze zwraca `null` podczas <xref:System.Windows.UIElement.ClipToBounds%2A> jest `false`. Ta metoda zastępuje <xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=nameWithType>. <xref:System.Windows.FrameworkElement> Implementacja używa <xref:System.Windows.FrameworkElement.MaxHeight%2A> i <xref:System.Windows.FrameworkElement.MaxWidth%2A> w obliczeniach. Kilka podklasy <xref:System.Windows.FrameworkElement> ponownie przesłonić tę metodę. <xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=nameWithType>, zastępuje do zawsze powrotu `null` ponieważ modułu definiowania układu kodu są często celowo poza granicami zwykłej. <xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=nameWithType> i <xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=nameWithType> zwracać `null` Jeśli <xref:System.Windows.UIElement.ClipToBounds%2A> jest `false`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Domyślna implementacja zawsze zwraca <see langword="null" /> podczas <see cref="P:System.Windows.UIElement.ClipToBounds" /> jest <see langword="false" />. Zastąpienia zwykle powinny zachować to zachowanie, mimo że istnieją wyjątki, w zależności od relacji i cel klasy pochodnej i jego logiki układu, w przeciwieństwie do klasy podstawowej.</para>
        </block>
        <altmember cref="P:System.Windows.UIElement.Clip" />
        <altmember cref="P:System.Windows.UIElement.ClipToBounds" />
      </Docs>
    </Member>
    <Member MemberName="GetTemplateChild">
      <MemberSignature Language="C#" Value="protected internal System.Windows.DependencyObject GetTemplateChild (string childName);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Windows.DependencyObject GetTemplateChild(string childName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetTemplateChild (childName As String) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Windows::DependencyObject ^ GetTemplateChild(System::String ^ childName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="childName">Nazwa elementu podrzędnego można znaleźć.</param>
        <summary>Zwraca nazwanego elementu w drzewie wizualnym skonkretyzowanym <see cref="T:System.Windows.Controls.ControlTemplate" />.</summary>
        <returns>Żądany element. Może być <see langword="null" /> Jeśli żądana nazwa nie zawiera żadnego elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Szablony w [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] mają niezależne namescope. Jest tak, ponieważ szablony są ponownie używane, a nie pozostają unikatowy dowolną nazwę zdefiniowane w szablonie, gdy wiele wystąpień formantu każdego wystąpienia szablonu. Wywołanie <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> metody, aby przywrócić odwołania do obiektów, które pochodzą z szablonu, po zostanie on uruchomiony. Nie można użyć <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> metody, aby znaleźć elementy z szablonów, ponieważ <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> pełni więcej ogólnie zakresu, i istnieje połączenie między <xref:System.Windows.Controls.ControlTemplate> klasy się i wystąpień szablonu po jego zastosowanie.  
  
 <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> udostępnia taką samą funkcję jak tej metody. <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> publicznego, a nie jest chroniona i wykorzystuje poprawny zakres nazwa zagadnienia zezwolenie na dostęp do szablonu w obrębie elementu i Znajdź nazwanych elementów w niej. Użyj <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> kiedy trzeba uzyskać elementu poza kontrolki nadrzędnej.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkTemplate.FindName(System.String,System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca alternatywnych logiczny obiekt nadrzędny dla tego elementu, jeśli nie elementu nadrzędnego visual.</summary>
        <returns>Zwraca coś innego niż <see langword="null" /> po każdej zmianie WPF poziomie struktury implementacja tej metody ma połączenie Niewizualne nadrzędnej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=nameWithType>. Wartość domyślna <xref:System.Windows.FrameworkElement> implementacja zwraca Oczekiwano jednego nadrzędnego visual, czyli takiego samego wyniku jako pierwsze <xref:System.Windows.FrameworkElement.Parent%2A> wartość. Implementacje Klasa pochodna może zwrócić relacje alternatywny nadrzędny.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu podrzędnego żądanego elementu w kolekcji.</param>
        <summary>Zastępuje <see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" />i zwraca element podrzędny o określonym indeksie kolekcji elementów podrzędnych.</summary>
        <returns>Element podrzędny żądanej. To nie może zwracać <see langword="null" />; Jeśli podany indeks jest poza zakresu, jest zgłaszany wyjątek.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W <xref:System.Windows.FrameworkElement> implementacji, jedyną prawidłową indeksu wynosi zero. Model zawartości dla <xref:System.Windows.FrameworkElement.GetVisualChild%2A> obsługuje elementy podrzędne zero lub, nie jest kolekcją.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak niestandardowy moduł definiowania układu kodu używa wartości zadeklarowanych przez <xref:System.Windows.Media.VisualCollection> obsługujący wiele podrzędnych visual. Te wartości są zgłaszane przy użyciu zastąpień z <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> i <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ta implementacja jest prawidłowa tylko dla elementów, które nie obsługują żadnych opisowej kolekcję elementów podrzędnych visual. Elementów, które mają takie kolekcji należy przesłonić tę metodę i mapowania indeksu na równoważne indeksu w podrzędnej kolekcji elementu, który jest obsługiwany przez ten element. Indeks w zakresie od 0 do <see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /> (minus jeden) powinien zwrócić prawidłowego elementu; innych indeks powinien zgłosić wyjątek out-of-range. Przykład typu elementu, który obsługuje podrzędnej kolekcji i zastępuje <see cref="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" /> aby powrócić do więcej niż jeden element podrzędny możliwe jest <see cref="T:System.Windows.Controls.Panel" />.  
  
 Domyślna implementacja w <see cref="T:System.Windows.FrameworkElement" /> zakłada visual tylko jeden element podrzędny. Dowolna wartość przekazana do <paramref name="index" /> innej niż zero przyczyny wyjątek, który występuje zostanie wygenerowany. Typowe elementy, takie jak elementów decorator, modułu definiowania układu kodu lub elementy z renderowaniem specjalne zastąpienie <see cref="T:System.Windows.FrameworkElement" /> wdrożenia (wykonanie pośrednich klas podstawowych). Niektóre implementacje nadal wymusić jeden element podrzędny visual, podczas gdy inne umożliwiają kolekcji.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public double Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Height" />
      <MemberSignature Language="VB.NET" Value="Public Property Height As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Height { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia sugerowany wysokość elementu.</summary>
        <value>Wysokość elementu w [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Wartość domyślna to <see cref="F:System.Double.NaN" />. Ta wartość musi być równa lub większa niż 0,0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Height%2A> jest jednym z trzech właściwości zapisu na <xref:System.Windows.FrameworkElement> określające wysokość informacji. Są dwa inne <xref:System.Windows.FrameworkElement.MinHeight%2A> i <xref:System.Windows.FrameworkElement.MaxHeight%2A>. Jeśli występuje konflikt między tych wartości, kolejność stosowania ustalania wysokości rzeczywistego jest to, że pierwszy <xref:System.Windows.FrameworkElement.MinHeight%2A> musi zostać wdrożona, następnie <xref:System.Windows.FrameworkElement.MaxHeight%2A>, a na końcu granice, jeśli <xref:System.Windows.FrameworkElement.Height%2A>.  
  
 Jeśli ten element jest elementu podrzędnego w obrębie niektórych innych elementów, następnie ustawienie dla tej właściwości na wartość to naprawdę sugerowane wartości. System układ, a także logikę układu elementu nadrzędnego wartość zostanie użyta jako nonbinding dane wejściowe podczas procesu układu. W praktyce <xref:System.Windows.FrameworkElement> prawie zawsze jest elementem podrzędnym czegoś innego; nawet wtedy, gdy ustawisz <xref:System.Windows.FrameworkElement.Height%2A> na <xref:System.Windows.Window>. (Dla <xref:System.Windows.Window>, czy wartość jest używana, gdy odpowiedni model aplikacji ustanawia założeń podstawowe renderowania, które utworzyć Hwnd, które obsługuje aplikację.)  
  
 Ponadto do akceptowalnego <xref:System.Double> wartości tej właściwości można też <xref:System.Double.NaN?displayProperty=nameWithType>. Jest to, jak określić zachowanie ustalania rozmiaru automatycznie w kodzie. W [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] zostanie ustawiona wartość ciągu "Auto" (bez uwzględniania wielkości liter) umożliwiające automatycznej zmiany rozmiaru zachowanie. Automatycznej zmiany rozmiaru zachowanie oznacza element zapełnienie wysokość dostępne. Należy jednak pamiętać, że kontrolek często podać wartości domyślnych za pośrednictwem ich domyślne style kompozycji, które spowoduje wyłączenie automatycznego ustalania rozmiaru zachowanie, o ile nie dotyczy w szczególności ponownie włączyć.  
  
 Zwracane wartości tej właściwości jest zawsze taki sam jak każdą wartość, która została ustawiona do niego. Natomiast wartość <xref:System.Windows.FrameworkElement.ActualHeight%2A> może się różnić. Może to się zdarzyć albo statycznie układ odrzucone sugerowany rozmiar jakiegoś powodu lub na chwilę. System układu działa asynchronicznie względem systemu właściwość zbiór <xref:System.Windows.FrameworkElement.Height%2A> i nie mogą być przetwarzane to określonego rozmiaru jeszcze zmiany właściwości.  
  
 Ograniczenia dotyczące wartości na <xref:System.Double> wartości są wymuszane przez <xref:System.Windows.ValidateValueCallback> mechanizmu. Jeśli spróbujesz ustawić wartość jest nieprawidłowa, zwracany jest wyjątek czasu wykonywania.  
  
 Oprócz sprawdzania poprawności jest niedeterministyczne górna wartość przeznaczony dla <xref:System.Windows.FrameworkElement.Height%2A> który jest wymuszana przez system układu (jest bardzo duża liczba większa niż <xref:System.Single.MaxValue?displayProperty=nameWithType> ale mniejszy niż <xref:System.Double.MaxValue?displayProperty=nameWithType>). Jeśli przekroczysz ten powiązany, nie będzie renderować element, a nie wyjątek. Nie ustawiaj <xref:System.Windows.FrameworkElement.Height%2A> jest znacznie większa niż maksymalny rozmiar dowolnego wyświetlacza możliwe, lub może przekroczyć to niedeterministyczna górna granica wartości.  
  
<a name="xamlAttributeUsage_Height"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object Height="double"/>  
- or -  
<object Height="qualifiedDouble"/>  
- or -  
<object Height="Auto"/>  
```  
  
<a name="xamlValues_Height"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *double*  
 <xref:System.Double>  
  
 Reprezentacja ciągu <xref:System.Double> wartość równą lub większą niż 0,0. Górna granica informacji, zobacz uwagi. Ta wartość jest interpretowana jako [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] miary. Ciągi nie musi zawierać jawnie miejsc dziesiętnych. Na przykład wartość `1` jest dopuszczalna.  
  
 *qualifiedDouble*  
 A *podwójne* wartość jak opisano powyżej, a następnie za pomocą jednej z następujących ciągów jednostki w deklaracji: `px`, `in`, `cm`, `pt`.  
  
 `px` (domyślnie) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm` jest cm; 1cm==(96/2.54) pikseli  
  
 `pt` jest punktów. 1pt==(96/72) pikseli  
  
 **Auto**  
 Włącza zachowanie automatyczna zmiana rozmiaru. Zobacz uwagi.  
  
<a name="dependencyPropertyInfo_Height"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.HeightProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.ActualHeight" />
      </Docs>
    </Member>
    <Member MemberName="HeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HeightProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.Height" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.HorizontalAlignment HorizontalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.HorizontalAlignment HorizontalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalAlignment As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::HorizontalAlignment HorizontalAlignment { System::Windows::HorizontalAlignment get(); void set(System::Windows::HorizontalAlignment value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia charakterystyki wyrównania poziomego stosowane do tego elementu, gdy wchodzi on w ramach elementu nadrzędnego, takiego jak panel lub kontrolka elementów.</summary>
        <value>Ustawienie wyrównania poziomego jako wartość wyliczenia. Wartość domyślna to <see cref="F:System.Windows.HorizontalAlignment.Stretch" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.FrameworkElement.Height%2A> i <xref:System.Windows.FrameworkElement.Width%2A> w elemencie są jawnie ustawione właściwości, pomiarów zająć wyższa część podczas układ i spowoduje anulowanie typowe skutki ustawienie <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> do <xref:System.Windows.HorizontalAlignment.Stretch>.  
  
 <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> jest [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] metody dostępu właściwości dla co to jest w rzeczywistości właściwości zależności. Ta właściwość zależności określonego dość często ma wartość jawnego "domyślną" ustawione inaczej w elementach podklasą, szczególnie kontrolki. Zwykle ma to miejsce w jeden z dwóch sposobów: właściwość zależności jest ponownie zarejestrowane podklasą określonej, ale różne metadane do ustawiania wartości domyślnych; lub istnieje domyślny styl są stosowane, która ustawia wartości tej właściwości zależności inaczej. Na przykład jawnego "domyślną" <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> dla <xref:System.Windows.Controls.Label> formant będzie <xref:System.Windows.HorizontalAlignment.Left>, nawet jeśli <xref:System.Windows.Controls.Label> dziedziczy <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> bezpośrednio z <xref:System.Windows.FrameworkElement>. Jest to spowodowane resetowania tej wartości w ramach domyślnego stylu <xref:System.Windows.Controls.Label>, w obrębie stylu kontrolki szablonu.  
  
 <xref:System.Windows.Controls.Canvas> nie używa <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> podczas tworzenia układu, ponieważ <xref:System.Windows.Controls.Canvas> opiera się na bezwzględny.  
  
 Gdy dziedziczone przez <xref:System.Windows.Controls.Label> lub pochodzi z klasy, <xref:System.Windows.Controls.Label> ponownie definiuje wartość domyślna tej właściwości zależności jako <xref:System.Windows.HorizontalAlignment.Left>.  
  
<a name="dependencyPropertyInfo_HorizontalAlignment"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.HorizontalAlignmentProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HorizontalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HorizontalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HorizontalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HorizontalAlignmentProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.HorizontalAlignment" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InheritanceBehavior">
      <MemberSignature Language="C#" Value="protected internal System.Windows.InheritanceBehavior InheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.InheritanceBehavior InheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property InheritanceBehavior As InheritanceBehavior" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::InheritanceBehavior InheritanceBehavior { System::Windows::InheritanceBehavior get(); void set(System::Windows::InheritanceBehavior value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.InheritanceBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia limity zakresu dziedziczenie wartości właściwości, klucza wyszukiwania zasobów i wyszukiwania RelativeSource FindAncestor.</summary>
        <value>Wartość wyliczenia. Wartość domyślna to <see cref="F:System.Windows.InheritanceBehavior.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określone granice w elemencie drzewa zestawu <xref:System.Windows.FrameworkElement.InheritanceBehavior%2A> można zdecydowanie ograniczyć zachowanie dziedziczenia, w celu wyszukiwania zasobów Wymuś Aby sprawdzić zasoby aplikacji lub uniemożliwiają wyszukiwania RelativeSource FindAncestor zapytań bieżącego elementu lub kolejnych. RelativeSource FindAncestor wyszukiwania występuje po powiązaniu używa <xref:System.Windows.Data.RelativeSource> mający jego <xref:System.Windows.Data.RelativeSource.Mode%2A> ustawioną właściwość <xref:System.Windows.Data.RelativeSourceMode.FindAncestor?displayProperty=nameWithType> wartość.  
  
 Jeśli chcesz z klasy pochodnej, aby ustawić tę właściwość, należy wykonać to w konstruktorze statycznym lub inne procedury inicjowania.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Frame" />
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy to <see cref="T:System.Windows.FrameworkElement" /> został zainicjowany. To zdarzenie pokrywa się to z przypadkami, w którym wartość <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> właściwość zmienia się z <see langword="false" /> (lub niezdefiniowaną) do <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Będzie to zdarzenie wywoływane, gdy <xref:System.Windows.FrameworkElement.EndInit%2A> lub <xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A> metody są wywoływane. Wywołania metody albo może pochodzić z kodu aplikacji, lub za pomocą [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] zachowanie procesora podczas [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] przetwarzania strony.  
  
 Określa, czy użytkownik chce obsługiwać <xref:System.Windows.FrameworkElement.Loaded> lub <xref:System.Windows.FrameworkElement.Initialized> zależy od wymagań. Nie należy do odczytu właściwości elementu Zamierzasz zresetować właściwości i nie wymagają żadnych informacji o układzie <xref:System.Windows.FrameworkElement.Initialized> mogą być lepiej zdarzeń działanie. Jeśli potrzebne są wszystkie właściwości elementu mają być dostępne i zostaną ustawienie właściwości, które mogą zresetować układ, <xref:System.Windows.FrameworkElement.Loaded> mogą być lepiej zdarzeń działanie. Należy zachować ostrożność z wielobieżność, jeśli Twoje obsługi resetuje wszystkie właściwości, które będą interpretowane przez system układu oznacza, że nowy przebieg układu jest wymagany. (Może być konieczne w celu sprawdzenia <xref:System.Windows.FrameworkPropertyMetadata> przekazać wartości dla właściwości, jeśli nie wiesz o właściwości, które mogą wymagać nowego układu, w przypadku ich zmiany.)  
  
 Aby uzyskać więcej informacji o sekwencji zdarzeń obiektu <xref:System.Windows.FrameworkElement>i również kilka związanych z aplikacji i klasy elementów, zobacz [zdarzenia okresu istnienia obiektu](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kontekst dla danych wejściowych używanych przez to <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <value>Wejściowych zakresu, który modyfikuje interpretacji danych wejściowych z alternatywne metody wprowadzania tekstu. Wartość domyślna to <see langword="null" /> (które powoduje domyślna obsługa poleceń).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zależności dziedziczy wartości właściwości. Jeśli istnieją elementy podrzędne bez innych wartości <xref:System.Windows.FrameworkElement.InputScope%2A> ustanowić za pośrednictwem style, lub wartości lokalnej, a następnie system właściwość zostanie ustaw wartość na <xref:System.Windows.FrameworkElement.InputScope%2A> wartość najbliższej element nadrzędny o tej wartości przypisane.  
  
 Mimo że [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] składni użycia ma na liście i składnia jest dozwolona, ustawienie dla tej właściwości [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] nie jest często.  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.InputScopeProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.InputScope" />
        <altmember cref="T:System.Windows.IInputElement" />
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.InputScope" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten element został zainicjowany, albo w trakcie przetwarzania przez [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] procesora, albo przez zdefiniowanie jawnie jego <see cref="M:System.Windows.FrameworkElement.EndInit" /> wywołana metoda.</summary>
        <value>
          <see langword="true" /> Jeśli element jest inicjowana na wyżej wymienionych [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] przetwarzania lub metody wywołań; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość może być również `true` Jeśli ten element został przeniesiony w drzewie logicznym taki sposób, że ma nowy element nadrzędny, a w związku z tym staje się ponownie załadowana ponownie.  
  
 Ta właściwość jest przydatna, jeśli również używasz <xref:System.Windows.FrameworkElement.BeginInit%2A> i <xref:System.Windows.FrameworkElement.EndInit%2A>. Elementy w drzewie logicznym, która jest ładowana przez [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] zapewni procesora do zainicjowania. Elementy nie znajduje się w drzewie logicznym są inicjowane przy <xref:System.Windows.FrameworkElement.EndInit%2A> jest wywoływana. W przypadku braku dowolnego obsługę określonych <xref:System.Windows.FrameworkElement.BeginInit%2A> i <xref:System.Windows.FrameworkElement.EndInit%2A>, dzieje się tak, jak konstruktora zwraca wynik zainicjowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten element został załadowany do prezentacji.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący element jest podłączona do drzewa; <see langword="false" /> Jeśli element nigdy nie został dołączony do drzewa załadowanych elementów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Z nowo utworzone <xref:System.Windows.FrameworkElement>, ta właściwość rozpoczyna się `false`i pozostaje `true` po jego ustawieniu `true`nawet wtedy, gdy element jest później usunięte z połączonych drzewa logicznego przez kod. `true` stan jest ustawiony przez logikę ogólne prezentacji, gdy elementy są ładowane do aparatu prezentacji.  
  
 Zazwyczaj załadowanych elementów są odtwarzane, ale nie wszystkie <xref:System.Windows.FrameworkElement> klasy pochodnej mają prezentacji i inne właściwości, takie jak <xref:System.Windows.UIElement.Visibility%2A> mogą mieć wpływ na prezentacji.  
  
   
  
## Examples  
 Poniższy przykład implementuje dwóch metod obsługi: jeden obsługuje <xref:System.Windows.FrameworkElement.Loaded> zdarzenia, elementu głównego, więc ma pewności, że element główny strony jest załadowany, ponieważ jest to istotności zdarzenia. Program obsługi jest powiązana z formantu użytkownika i wywołania <xref:System.Windows.FrameworkElement.IsLoaded%2A> aby mieć pewność, że element główny jest załadowany całkowicie. Oba programy obsługi wywołanie funkcji samej (tego nie pokazano) wypełniająca elementów podrzędnych o nowe dane.  
  
 [!code-csharp[GroupBoxExample#FEIsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupBoxExample/CSharp/Page1.xaml.cs#feisloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje dotyczące języka lokalizacji/globalizacji, który stosuje się do elementu.</summary>
        <value>Informacje o języku dla tego elementu. Wartość domyślna to <see cref="T:System.Windows.Markup.XmlLanguage" /> z jego <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> wartość ciągu "en US".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Formaty ciągu zgodne ze standardem RFC 3066. Na przykład stany USA Język angielski jest "en US". Aby uzyskać więcej informacji o wartości i formatu, zobacz <xref:System.Windows.Markup.XmlLanguage>.  
  
 Ta właściwość zależności dziedziczy wartości właściwości. Jeśli istnieją elementy podrzędne bez innych wartości <xref:System.Windows.FrameworkElement.Language%2A> nawiązane za pomocą wartości lokalnej lub style, system właściwość zostanie ustaw wartość na <xref:System.Windows.FrameworkElement.Language%2A> wartość najbliższej element nadrzędny o tej wartości przypisane.  
  
 [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)] Definiuje ogólne znaczenie `xml:lang` atrybutu. <xref:System.Windows.FrameworkElement.Language%2A> zasadniczo przedstawia znaczenie tego atrybutu jako właściwość zależności. <xref:System.Windows.FrameworkElement.Language%2A> można dostosować programowo i mogą uczestniczyć w dziedziczenie wartości właściwości systemu w taki sposób, aby równoleżnikami jak `xml:lang` atrybut może dziedziczyć do zakresu elementu podrzędnego w [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]. Jeśli ustawisz <xref:System.Windows.FrameworkElement.Language%2A>, ta wartość staje się `xml:lang` i zastępuje wszystkie wcześniejsze wartości. Aby uzyskać więcej informacji, zobacz [XML: lang — Obsługa w XAML](~/docs/framework/xaml-services/xml-lang-handling-in-xaml.md).  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.LanguageProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.Language" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform LayoutTransform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform LayoutTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LayoutTransform" />
      <MemberSignature Language="VB.NET" Value="Public Property LayoutTransform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Transform ^ LayoutTransform { System::Windows::Media::Transform ^ get(); void set(System::Windows::Media::Transform ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia transformację grafiki, która powinna zostać zastosowana do tego elementu podczas stosowania układu.</summary>
        <value>Transformacja należy używać tego elementu. Wartość domyślna to <see cref="P:System.Windows.Media.Transform.Identity" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrast do <xref:System.Windows.UIElement.RenderTransform%2A>, <xref:System.Windows.FrameworkElement.LayoutTransform%2A> będzie mieć wpływ na wyniki układu.  
  
 Ustawienie transformacji zapewnia zaawansowane możliwości skalowania i obracanie. Jednak <xref:System.Windows.FrameworkElement.LayoutTransform%2A> ignoruje <xref:System.Windows.Media.TranslateTransform> operacji. Jest to spowodowane układu zachowanie systemowe dla elementów podrzędnych elementu <xref:System.Windows.FrameworkElement> automatycznie koryguje kompensacji położenie skalowana lub obrócony elementu w układzie i współrzędnych elementu nadrzędnego.  
  
 <xref:System.Windows.FrameworkElement.LayoutTransform%2A> może doprowadzić do niską wydajnością, jeśli można wywołać w scenariuszu, który nie wymaga pełnej przekazywanym przez system układu. Po zastosowaniu <xref:System.Windows.FrameworkElement.LayoutTransform%2A> do <xref:System.Windows.Controls.Panel.Children%2A> Kolekcja <xref:System.Windows.Controls.Panel>, wyzwoli nowe przekazywanym przez system układ i wymusza wszystkich na ekranie obiekty pomiaru i zmieniać kolejności. Jeśli aktualizujesz kompletna aplikacja [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)], ta funkcja może być dokładnie co jest potrzebne. Jeśli nie trzeba przebiegu pełne układu, jednak użyć <xref:System.Windows.UIElement.RenderTransform%2A> właściwość, która nie jest wywoływany systemu układ i dlatego jest zwykle lepszym rozwiązaniem dla tego scenariusza.  
  
 Przykładowe scenariusze gdzie <xref:System.Windows.FrameworkElement.LayoutTransform%2A> byłoby obejmują: obracanie elementów, takich jak składniki menu z poziomego do pionowego lub odwrotnie, skalowania elementów (powiększania) przy aktywnym fokusie, zapewniając edycji itp.  
  
<a name="dependencyPropertyInfo_LayoutTransform"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.LayoutTransformProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób zastosowania <xref:System.Windows.FrameworkElement.LayoutTransform%2A> do elementu. W przykładzie jest tworzony wystąpienia <xref:System.Windows.Controls.Button> i znajduje się w obrębie nadrzędnego <xref:System.Windows.Controls.Grid>. Ponadto użyto <xref:System.Windows.FrameworkElement.LayoutTransform%2A> właściwości, aby zastosować <xref:System.Windows.Media.RotateTransform> do <xref:System.Windows.Controls.Button>.  
  
 [!code-cpp[LayoutTransform#1](~/samples/snippets/cpp/VS_Snippets_Wpf/LayoutTransform/CPP/LayoutTransform.cpp#1)]
 [!code-csharp[LayoutTransform#1](~/samples/snippets/csharp/VS_Snippets_Wpf/LayoutTransform/CSharp/LayoutTransform.cs#1)]
 [!code-vb[LayoutTransform#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/LayoutTransform/VisualBasic/LayoutTransform.vb#1)]
 [!code-xaml[LayoutTransform#1](~/samples/snippets/xaml/VS_Snippets_Wpf/LayoutTransform/XAML/default.xaml#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransformProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LayoutTransformProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LayoutTransformProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LayoutTransformProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LayoutTransformProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.LayoutTransform" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy element jest poukładany, wyrenderowany i gotowy do interakcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Loaded> jest zwykle ostatniego zdarzenia wywoływane w kolejności inicjowania elementu. Zostanie wygenerowany zawsze po <xref:System.Windows.FrameworkElement.Initialized>. Określa, czy użytkownik chce obsługiwać <xref:System.Windows.FrameworkElement.Loaded> lub <xref:System.Windows.FrameworkElement.Initialized> zależy od wymagań. Nie należy do odczytu właściwości elementu Zamierzasz zresetować właściwości i nie wymagają żadnych informacji o układzie <xref:System.Windows.FrameworkElement.Initialized> mogą być lepiej zdarzeń działanie. Jeśli potrzebne są wszystkie właściwości elementu mają być dostępne i zostaną ustawienie właściwości, które mogą zresetować układ, <xref:System.Windows.FrameworkElement.Loaded> mogą być lepiej zdarzeń działanie. Należy zachować ostrożność z wielobieżność, jeśli Twoje obsługi resetuje wszystkie właściwości, które będą interpretowane przez system układu oznacza, że nowy przebieg układu jest wymagany. (Może być konieczne w celu sprawdzenia <xref:System.Windows.FrameworkPropertyMetadata> przekazać wartości dla właściwości, jeśli nie wiesz o właściwości, które mogą wymagać nowego układu, w przypadku ich zmiany.)  
  
 Aby uzyskać więcej informacji o sekwencji zdarzeń obiektu <xref:System.Windows.FrameworkElement>i również kilka związanych z aplikacji i klasy elementów, zobacz [zdarzenia okresu istnienia obiektu](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
 Bezpośrednie kierowane zdarzenia nie wykonuj trasy, są obsługiwane tylko w obrębie tego samego elementu, na którym jest uruchamiany. Bezpośrednie kierowane zdarzenia obsługuje inne zachowanie kierowanego zdarzenia: obsługują dostępny obsługi kolekcji i mogą być używane jako <xref:System.Windows.EventTrigger> w stylu.  
  
 <xref:System.Windows.FrameworkElement.Loaded> i <xref:System.Windows.FrameworkElement.Unloaded> może jednocześnie zostać wywołane na formanty w wyniku zmian kompozycji systemu zainicjowanego przez użytkownika. Zmień motyw powoduje unieważnienie szablon formantu i zawartych w niej drzewa wizualnego, co z kolei powoduje, że cały formant zwolnienie i ponowne załadowanie. W związku z tym <xref:System.Windows.FrameworkElement.Loaded> nie zakłada się, że występuje, gdy strona jest najpierw ładować tylko za pośrednictwem nawigacji do strony.  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.LoadedEvent>|  
|Strategii routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkElement.Loaded" /> kierowanego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory kierowanego zdarzenia są tworzone, gdy kierowane zdarzenia są rejestrowane. Te identyfikatory zawiera nazwę identyfikującą, typ właściciela, typ obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia. Aby dodać obsługę klas, można użyć tych identyfikatorów.  
  
 Aby uzyskać więcej informacji na temat rejestrowania kierowane zdarzenia, zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Aby uzyskać więcej informacji o używaniu identyfikatorów kierowanego zdarzenia, aby dodać obsługę klas, zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduł wyliczający dla elementów podrzędnych logicznej tego elementu.</summary>
        <value>Moduł wyliczający dla elementów podrzędnych logicznej tego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.LogicalChildren%2A> Służy do wykonywania iteracji elementów podrzędnych. Jest to przydatne dla elementów, które mogą ma kolekcję zdefiniowanych, dedykowane, ale nadal zawierać więcej niż jeden element podrzędny, szczególnie <xref:System.Windows.FrameworkContentElement> elementy podrzędne.  
  
 Aby uzyskać więcej informacji na temat sposobu użycia <xref:System.Windows.FrameworkElement.LogicalChildren%2A> i <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>, zobacz [drzewa WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Margin { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zewnętrzny margines elementu.</summary>
        <value>Udostępnia wartości margines elementu. Wartość domyślna to <see cref="T:System.Windows.Thickness" /> z wszystkich właściwości równa 0 (zero).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Margines to obszar między tym elementem i innymi elementami, które będą sąsiadować podczas tworzenia przez układ [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]. Elementy udostępnionych może być elementów równorzędnych (na przykład inne elementy w kolekcji formantu nadrzędnego wspólnego) lub może być również tego elementu nadrzędnego.  
  
 <xref:System.Windows.FrameworkElement.Margin%2A> jest ustawiony jako <xref:System.Windows.Thickness> struktury, a nie jako liczbę, dzięki czemu można ustawić asymetrycznie margines. <xref:System.Windows.Thickness> Struktury sama obsługuje konwersji typu ciąg, dzięki czemu można określić asymetrycznego <xref:System.Windows.FrameworkElement.Margin%2A> w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] również atrybutu składni.  
  
 Margines niezerowy stosuje miejsca poza układu elementu <xref:System.Windows.FrameworkElement.ActualWidth%2A> i <xref:System.Windows.FrameworkElement.ActualHeight%2A>.  
  
 Marginesy są dodatku dla elementów równorzędnych w układzie; na przykład dwóch sąsiadujących ze sobą elementy, które marginesu 30 ustawione na krawędzi sąsiadujących musi 60 jednostek odstęp między nimi.  
  
 Elementów, które mają ustawiony marginesy nie będzie zazwyczaj Ogranicz rozmiar określonego <xref:System.Windows.FrameworkElement.Margin%2A> Jeśli miejsca przydzielonego prostokąt nie jest wystarczająco duży dla marginesu oraz obszaru zawartości elementu. Obszar zawartości elementu można ograniczyć zamiast tego, gdy układ jest obliczana. Tylko wówczas, gdy marginesy czy ograniczonego jest również, jeśli zawartość jest już ograniczona do zera.  
  
<a name="xamlAttributeUsage_Margin"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object Margin="left,top,right,bottom"/>  
- or -  
<object Margin="left,top"/>  
- or -  
<object Margin="thicknessReference"/>  
```  
  
<a name="xamlPropertyElementUsage_Margin"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.Margin>  
    <Thickness Left="left" Top="top" Right="right" Bottom="bottom"/>  
  </object.Margin>  
</object>  
```  
  
<a name="xamlValues_Margin"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *po lewej stronie górnej, prawej, dolnej*  
 Liczba wartości w zakresie od 0 i <xref:System.Double.PositiveInfinity> określające czterech właściwości wymiaru możliwe <xref:System.Windows.Thickness> struktury.  
  
 Użycie atrybutu również będzie akceptować skróconej wartości, które są stosowane w kolejności, pod warunkiem, symetrycznie i logicznie. Na przykład `Margin="20"` zostanie potraktowany oznacza <xref:System.Windows.Thickness> z wszystkich właściwości wartość 20. `Margin="20,50"` zostanie potraktowany oznacza <xref:System.Windows.Thickness> z <xref:System.Windows.Thickness.Left%2A> i <xref:System.Windows.Thickness.Right%2A> wartość 20, i <xref:System.Windows.Thickness.Top%2A> i <xref:System.Windows.Thickness.Bottom%2A> ustawiona na 50.  
  
 Wartość jednostki <xref:System.Windows.Thickness> miara jest [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]. Inne jednostki można również określić, dodając parametry typu jednostki `cm`, `in`, lub `pt` do dowolna z miar.  
  
 Liczba wartości w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] atrybutów nie trzeba określać miejsc dziesiętnych (0 jest dopuszczalne, nie ma zostać podany jako 0,0). Aby uzyskać więcej informacji na temat [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] użycia, zobacz <xref:System.Windows.Thickness>.  
  
 *thicknessReference*  
 Odwołanie do obiektu do istniejącego <xref:System.Windows.Thickness>. Może to być `}`,, lub `}` odwołania. Aby uzyskać więcej informacji na temat [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] użycia, zobacz <xref:System.Windows.Thickness>.  
  
<a name="dependencyPropertyInfo_Margin"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.MarginProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Thickness" />
      </Docs>
    </Member>
    <Member MemberName="MarginProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MarginProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MarginProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MarginProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MarginProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MarginProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.Margin" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeight">
      <MemberSignature Language="C#" Value="public double MaxHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxHeight { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ograniczenie maksymalnej wysokości elementu.</summary>
        <value>Maksymalna wysokość elementu w [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Wartość domyślna to <see cref="F:System.Double.PositiveInfinity" />. Ta wartość może mieć dowolną wartość równą lub większą niż 0,0. <see cref="F:System.Double.PositiveInfinity" /> jest również jest nieprawidłowy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to jeden z trzech właściwości na <xref:System.Windows.FrameworkElement> określające wysokość informacji. Są dwa inne <xref:System.Windows.FrameworkElement.MinHeight%2A> i <xref:System.Windows.FrameworkElement.Height%2A>.  Jeśli występuje konflikt między tymi wartościami, kolejność stosowania ustalania wysokości rzeczywistego jest pierwszym <xref:System.Windows.FrameworkElement.MinHeight%2A> musi zostać wdrożona, następnie <xref:System.Windows.FrameworkElement.MaxHeight%2A>, a na końcu Jeśli każdego z tych należą granice, <xref:System.Windows.FrameworkElement.Height%2A>.  
  
 Ograniczenia dotyczące wartości na <xref:System.Double> wartości są wymuszane przez <xref:System.Windows.ValidateValueCallback> mechanizmu. Jeśli spróbujesz ustawić nieprawidłową wartość zwracany jest wyjątek czasu wykonywania.  
  
<a name="xamlAttributeUsage_MaxHeight"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object MaxHeight="double"/>  
- or –  
<object MaxHeight ="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MaxHeight"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *double*  
 <xref:System.Double>  
  
 Reprezentacja ciągu <xref:System.Double> wartość równą lub większą niż 0,0. To jest interpretowana jako [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] miary. Ciągi nie musi zawierać jawnie miejsc dziesiętnych. Na przykład wartość `1` jest dopuszczalna.  
  
 Taki sam <xref:System.Double> zastosować ograniczenia zakresu, jak wspomniano w sekcji wartości właściwości, z wyjątkiem tego, czy należy użyć [x: Static — rozszerzenie znaczników](~/docs/framework/xaml-services/x-static-markup-extension.md) Musisz jawnie ustaw wartość na <xref:System.Double.PositiveInfinity>.  
  
 *qualifiedDouble*  
 A *podwójne* wartość jak opisano powyżej, a następnie za pomocą jednej z następujących ciągów jednostki w deklaracji: `px`, `in`, `cm`, `pt`.  
  
 `px` (domyślnie) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm` jest cm; 1cm==(96/2.54) pikseli  
  
 `pt` jest punktów. 1pt==(96/72) pikseli  
  
<a name="dependencyPropertyInfo_MaxHeight"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.MaxHeightProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxHeightProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.MaxHeight" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidth">
      <MemberSignature Language="C#" Value="public double MaxWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxWidth { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ograniczenie maksymalnej szerokości elementu.</summary>
        <value>Maksymalna szerokość elementu w [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Wartość domyślna to <see cref="F:System.Double.PositiveInfinity" />. Ta wartość może mieć dowolną wartość równą lub większą niż 0,0. <see cref="F:System.Double.PositiveInfinity" /> jest również jest nieprawidłowy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to jeden z trzech właściwości na <xref:System.Windows.FrameworkElement> określające szerokość informacji. Są dwa inne <xref:System.Windows.FrameworkElement.MinWidth%2A> i <xref:System.Windows.FrameworkElement.Width%2A>. Jeśli występuje konflikt między tymi wartościami, kolejność aplikacji do oznaczania rzeczywista szerokość jest pierwszym <xref:System.Windows.FrameworkElement.MinWidth%2A> musi zostać wdrożona, następnie <xref:System.Windows.FrameworkElement.MaxWidth%2A>, a na końcu w przypadku każdego z tych należą granice, <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 Ograniczenia dotyczące wartości na <xref:System.Double> wartości są wymuszane przez <xref:System.Windows.ValidateValueCallback> mechanizmu. Jeśli spróbujesz ustawić wartość jest nieprawidłowa, zwracany jest wyjątek czasu wykonywania.  
  
<a name="xamlAttributeUsage_MaxWidth"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object MaxWidth="double"/>  
- or -  
<object MaxWidth="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MaxWidth"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *double*  
 <xref:System.Double>  
  
 Reprezentacja ciągu <xref:System.Double> wartość równą lub większą niż 0,0. To jest interpretowana jako [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] miary. Ciągi nie musi zawierać jawnie miejsc dziesiętnych. Na przykład wartość `1` jest dopuszczalna.  
  
 Taki sam <xref:System.Double> zastosować ograniczenia zakresu, jak wspomniano w sekcji wartości właściwości, z wyjątkiem tego, czy należy użyć [x: Static — rozszerzenie znaczników](~/docs/framework/xaml-services/x-static-markup-extension.md) można ustawić wartość <xref:System.Double.PositiveInfinity>.  
  
 *qualifiedDouble*  
 A *podwójne* wartość jak opisano powyżej, a następnie za pomocą jednej z następujących ciągów jednostki w deklaracji: `px`, `in`, `cm`, `pt`.  
  
 `px` (domyślnie) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm` jest cm; 1cm==(96/2.54) pikseli  
  
 `pt` jest punktów. 1pt==(96/72) pikseli  
  
<a name="dependencyPropertyInfo_MaxWidth"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.MaxWidthProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxWidthProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.MaxWidth" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureCore">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Size MeasureCore (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureCore(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function MeasureCore (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureCore(System::Windows::Size availableSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Dostępny rozmiar elementu nadrzędnego, które pozwala na elementy podrzędne.</param>
        <summary>Implementuje basic miary przebiegu układu zachowanie systemowe <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <returns>Wymagany rozmiar tego elementu w układzie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType> Podłączanie poziomie core WPF i implementacje miary układu poziomie struktury WPF. <xref:System.Windows.FrameworkElement> Implementacji uszczelnienia metody. Aby dostosować zachowanie układu przebiegu miary dowolny element opiera się na poziomie struktury WPF, Zastąp <xref:System.Windows.FrameworkElement.MeasureOverride%2A> zamiast tego. Aby dostosować miary przekazać zachowanie układu elementu, który celowo nie kompilacji na WPF poziomie struktury lub użyj <xref:System.Windows.FrameworkElement>, Zastąp <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Dostępny rozmiar tego elementu może być elementów podrzędnych. Infinity można określić jako wartość, aby wskazać, czy rozmiar elementu zostanie zmieniony na niezależnie od zawartość jest dostępna.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, mierzy rozmiar w układzie wymaganych elementów podrzędnych i określa rozmiar <see cref="T:System.Windows.FrameworkElement" />-klasy.</summary>
        <returns>Rozmiar ten element określa ona musi podczas układu, na podstawie jego obliczeń rozmiary elementu podrzędnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastąpienie <xref:System.Windows.FrameworkElement.MeasureOverride%2A> do zaimplementowania niestandardowego układu zachowanie ustalania rozmiaru dla danego elementu, ponieważ uczestniczy w [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] układu systemu. Implementacji, należy wykonać następujące czynności:  
  
1.  Iterowanie nazwę elementu danej kolekcji elementów podrzędnych, które są częścią układu, wywołanie <xref:System.Windows.UIElement.Measure%2A> dla każdego elementu podrzędnego.  
  
2.  Natychmiast pobrać <xref:System.Windows.UIElement.DesiredSize%2A> w elemencie podrzędnym (to jest ustawiony jako właściwości po <xref:System.Windows.UIElement.Measure%2A> nosi nazwę).  
  
3.  Obliczenia bazy danych net wymagany rozmiar elementu nadrzędnego ustalane na podstawie miary elementów podrzędnych.  
  
 Wartość zwracana <xref:System.Windows.FrameworkElement.MeasureOverride%2A> powinny mieć rozmiar elementu własne potrzeby, która staje się miara danych wejściowych dla elementu nadrzędnego bieżącego elementu. Ten sam proces nadal za pośrednictwem systemu układu, aż do osiągnięcia elementu głównego strony.  
  
 W trakcie tego procesu może zwrócić większego elementy podrzędne <xref:System.Windows.UIElement.DesiredSize%2A> rozmiar niż początkowej `availableSize` wskazująca, że element podrzędny potrzebuje więcej miejsca. Może to być obsługiwane w własną implementację dzięki zastosowaniu przewijanego regionu, zmieniając formantu nadrzędnego, ustanawiając jakikolwiek sposób skumulowany kolejności lub dowolną liczbę rozwiązań do pomiaru lub rozmieszczanie zawartości.  
  
> [!IMPORTANT]
>  Elementy powinny wywoływać <xref:System.Windows.UIElement.Measure%2A> na poszczególne elementy podrzędne w trakcie tego procesu, w przeciwnym razie elementy podrzędne nie zostanie poprawnie o rozmiarze ani ułożone.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Poniższy kod kompilowanie przedstawia tego wzorca implementacji.  <c>VisualChildren</c> reprezentuje właściwość wyliczalny kolekcji elementów podrzędnych definiujące własnego elementu. Właściwość może być nazwany żadnych czynności. <c>VisualChildren</c> jest nazwą symbolu zastępczego na potrzeby tego przykładu <c>VisualChildren</c> nie jest [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] zgodnie z [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] lub część wzorzec nazewnictwa.  
  
 [!code-csharp[CorePseudocode#FEMeasureOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#femeasureoverride)]
 [!code-vb[CorePseudocode#FEMeasureOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#femeasureoverride)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="MinHeight">
      <MemberSignature Language="C#" Value="public double MinHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MinHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinHeight { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ograniczenie minimalnej wysokości elementu.</summary>
        <value>Minimalna wysokość elementu w [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Wartość domyślna to 0,0. Ta wartość może mieć dowolną wartość równą lub większą niż 0,0. Jednak <see cref="F:System.Double.PositiveInfinity" /> nie jest prawidłowy, ani <see cref="F:System.Double.NaN" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to jeden z trzech właściwości na <xref:System.Windows.FrameworkElement> określające wysokość informacji.  Są dwa inne <xref:System.Windows.FrameworkElement.Height%2A> i <xref:System.Windows.FrameworkElement.MaxHeight%2A>. Jeśli występuje konflikt między tymi wartościami, kolejność stosowania ustalania wysokości rzeczywistego jest pierwszym <xref:System.Windows.FrameworkElement.MinHeight%2A> musi zostać wdrożona, następnie <xref:System.Windows.FrameworkElement.MaxHeight%2A>, a na końcu Jeśli każdego z tych należą granice, <xref:System.Windows.FrameworkElement.Height%2A>.  
  
 Ograniczenia dotyczące wartości na <xref:System.Double> wartości są wymuszane przez <xref:System.Windows.ValidateValueCallback> mechanizmu. Jeśli spróbujesz ustawić wartość jest nieprawidłowa, zwracany jest wyjątek czasu wykonywania.  
  
<a name="xamlAttributeUsage_MinHeight"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object MinHeight="double"/>  
- or -  
<object MinHeight="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MinHeight"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *double*  
 <xref:System.Double>  
  
 Reprezentacja ciągu <xref:System.Double> wartość równą lub większą niż 0,0. To jest interpretowana jako [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] miary. Ciągi nie musi zawierać jawnie miejsc dziesiętnych. Na przykład wartość `1` jest dopuszczalna.  
  
 Taki sam <xref:System.Double> obowiązują ograniczenia zakresu, jak wspomniano w sekcji wartości właściwości.  
  
 *qualifiedDouble*  
 A *podwójne* wartość jak opisano powyżej, a następnie za pomocą jednej z następujących ciągów jednostki w deklaracji: `px`, `in`, `cm`, `pt`.  
  
 `px` (domyślnie) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm` jest cm; 1cm==(96/2.54) pikseli  
  
 `pt` jest punktów. 1pt==(96/72) pikseli  
  
<a name="dependencyPropertyInfo_MinHeight"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.MinHeightProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinHeightProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.MinHeight" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidth">
      <MemberSignature Language="C#" Value="public double MinWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinWidth { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ograniczenie minimalnej szerokości elementu.</summary>
        <value>Minimalna szerokość elementu w [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Wartość domyślna to 0,0. Ta wartość może mieć dowolną wartość równą lub większą niż 0,0. Jednak <see cref="F:System.Double.PositiveInfinity" /> jest nieprawidłowy, podobnie jak <see cref="F:System.Double.NaN" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to jeden z trzech właściwości na <xref:System.Windows.FrameworkElement> określające szerokość informacji.  Są dwa inne <xref:System.Windows.FrameworkElement.Width%2A> i <xref:System.Windows.FrameworkElement.MaxWidth%2A>.  Jeśli występuje konflikt między tymi wartościami, kolejność aplikacji do oznaczania rzeczywista szerokość jest pierwszym <xref:System.Windows.FrameworkElement.MinWidth%2A> musi zostać wdrożona, następnie <xref:System.Windows.FrameworkElement.MaxWidth%2A>, a na końcu w przypadku każdego z tych należą granice, <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 Ograniczenia dotyczące wartości na <xref:System.Double> wartości są wymuszane przez <xref:System.Windows.ValidateValueCallback> mechanizmu. Jeśli spróbujesz ustawić wartość jest nieprawidłowa, zwracany jest wyjątek czasu wykonywania.  
  
<a name="xamlAttributeUsage_MinWidth"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object MinWidth="double"/>  
- or -  
<object MinWidth="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MinWidth"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *double*  
 <xref:System.Double>  
  
 Reprezentacja ciągu <xref:System.Double> wartość równą lub większą niż 0,0. To jest interpretowana jako [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] miary. Ciągi nie musi zawierać jawnie miejsc dziesiętnych. Na przykład wartość `1` jest dopuszczalna.  
  
 Taki sam <xref:System.Double> obowiązują ograniczenia zakresu, jak wspomniano w sekcji wartości właściwości.  
  
 *qualifiedDouble*  
 A *podwójne* wartość jak opisano powyżej, a następnie za pomocą jednej z następujących ciągów jednostki w deklaracji: `px`, `in`, `cm`, `pt`.  
  
 `px` (domyślnie) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm` jest cm; 1cm==(96/2.54) pikseli  
  
 `pt` jest punktów. 1pt==(96/72) pikseli  
  
<a name="dependencyPropertyInfo_MinWidth"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.MinWidthProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinWidthProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.MinWidth" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">Kierunek, który koncentruje się na przenoszenie jako wartość wyliczenia.</param>
        <summary>Przenosi fokus klawiatury od tego elementu i do innego elementu w kierunku przechodzenie podana.</summary>
        <returns>Zwraca <see langword="true" /> Jeśli fokus zostanie przeniesiony pomyślnie; <see langword="false" /> Jeśli określony element docelowy w kierunku nie istnieje lub może nie być klawiatura fokus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja zastępuje <xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=nameWithType> oraz uszczelnienia metody.  
  
   
  
## Examples  
 Poniższy przykład implementuje obsługi, która obsługuje kilka możliwych przycisk danych wejściowych. Każdy przycisk reprezentuje możliwego <xref:System.Windows.Input.FocusNavigationDirection>. Program obsługi śledzi element z bieżącego fokus klawiatury i wywołania <xref:System.Windows.FrameworkElement.MoveFocus%2A> dla tego elementu, określając odpowiedni <xref:System.Windows.Input.FocusNavigationDirection> jako inicjowania dla <xref:System.Windows.Input.TraversalRequest> podany parametr typu.  
  
 [!code-csharp[FocusSample#FocusSampleMoveFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#focussamplemovefocus)]
 [!code-vb[FocusSample#FocusSampleMoveFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#focussamplemovefocus)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Markup.DesignerSerializationOptions</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę identyfikującą elementu. Nazwa znajdują się informacje, dzięki czemu kodem, takie jak kod obsługi zdarzeń, mogą odwoływać się do elementu znaczników po jest tworzony podczas przetwarzania przez [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] procesora.</summary>
        <value>Nazwa elementu. Wartość domyślna to ciąg pusty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najbardziej typowe użycie tej właściwości jest określenie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] nazwy elementu jako atrybut w znaczniku.  
  
 Ta właściwość zapewnia zasadniczo można ustawić właściwości wygody poziomie struktury WPF [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [x: Name — dyrektywa](~/docs/framework/xaml-services/x-name-directive.md).  
  
 Nazwy muszą być unikatowe w obrębie namescope. Aby uzyskać więcej informacji, zobacz [WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 Pobieranie <xref:System.Windows.FrameworkElement.Name%2A> elementów w przypadku tworzenia kodu nie jest często. Jeśli już ma odwołanie do odpowiedniego w kodzie, po prostu można wywoływać metod i właściwości w elemencie odwołania, a nie ogólnie potrzeby <xref:System.Windows.FrameworkElement.Name%2A>. Wyjątkiem jest Jeśli <xref:System.Windows.FrameworkElement.Name%2A> ciąg ma, niektóre przeciążone to znaczy, na przykład jeśli przydaje się do wyświetlania tej nazwy w [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]. Ustawienie <xref:System.Windows.FrameworkElement.Name%2A> z kodem — Jeśli oryginalny <xref:System.Windows.FrameworkElement.Name%2A> została ustawiona z poziomu znacznika nie zaleca się i zmiana właściwości po załadowaniu [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] nie zmieni się odwołanie do oryginalnego obiektu. Odwołania do obiektów są tworzone tylko wtedy, gdy podstawowy namescopes jawnie są tworzone podczas analizy. W szczególności należy wywołać <xref:System.Windows.FrameworkElement.RegisterName%2A> do wprowadzenia zmiany do <xref:System.Windows.FrameworkElement.Name%2A> właściwość elementu już załadowana.  
  
 Godny uwagi jeden przypadek, w przypadku, gdy ustawienie <xref:System.Windows.FrameworkElement.Name%2A> z kodu jest ważne jest podczas rejestrowania nazw dla elementów, które scenorys będzie uruchamiana, dzięki czemu może być przywoływany w czasie wykonywania. Przed zarejestrowaniem nazwę może także zajść potrzeba utworzenia wystąpienia i przypisz <xref:System.Windows.NameScope> wystąpienia. Zobacz sekcję przykład lub [omówienie Scenorys](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
 Ustawienie <xref:System.Windows.FrameworkElement.Name%2A> z kodu jest ograniczona aplikacje, ale pobieranie elementu <xref:System.Windows.FrameworkElement.Name%2A> najczęściej. Jednego scenariusza jest, jeśli aplikacja obsługuje model nawigacji, gdzie stron ponowne ładowanie do aplikacji i kodu w czasie wykonywania nie jest kodem zdefiniowane dla tej strony. Metoda narzędzie <xref:System.Windows.FrameworkElement.FindName%2A>, która jest dostępna z dowolnego <xref:System.Windows.FrameworkElement>, można znaleźć żadnych elementu przez <xref:System.Windows.FrameworkElement.Name%2A> w drzewie logicznym dla tego elementu, wyszukiwanie rekursywnie drzewa w razie potrzeby. Lub użyć <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> metody statycznej z <xref:System.Windows.LogicalTreeHelper>, który przyjmuje również <xref:System.Windows.FrameworkElement.Name%2A> ciągu jako argument.  
  
 Zwykle używanych elementów głównych (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> na przykład) implementować interfejs <xref:System.Windows.Markup.INameScope>. Implementacje tego interfejsu powinny wymuszanie nazwy być jednoznaczne w swoim zakresie. Elementy główne, które definiują ten interfejs również zdefiniować granice zachowanie namescope dla wszystkich powiązanych [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)].  
  
 <xref:System.Windows.FrameworkElement.Name%2A> Właściwości służy również jako identyfikator dla innych procesów. Na przykład [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] użyje modelu automatyzacji <xref:System.Windows.FrameworkElement.Name%2A> jako AutomationId dla klientów i dostawców.  
  
 Wartości ciągu używanych na <xref:System.Windows.FrameworkElement.Name%2A> ma pewne ograniczenia, jak powodowanego przez podstawową [x: Name — dyrektywa](~/docs/framework/xaml-services/x-name-directive.md) zdefiniowane przez [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] specyfikacji. Głównie <xref:System.Windows.FrameworkElement.Name%2A> musi rozpoczynać się od litery lub znaku podkreślenia (_) i może zawierać tylko litery, cyfry i znaki podkreślenia. Aby uzyskać więcej informacji, zobacz [WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 <xref:System.Windows.FrameworkElement.Name%2A> jest jednym z bardzo kilka właściwości zależności, których nie można animować (<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> jest `true` w metadanych), ponieważ nazwa jest przeznaczony do animacji. Powiązanie danych <xref:System.Windows.FrameworkElement.Name%2A> jest technicznie możliwe, ale jest to bardzo rzadko scenariusz, ponieważ z danymi <xref:System.Windows.FrameworkElement.Name%2A> nie może obsługiwać głównego przeznaczenie właściwości: identyfikator punkt połączenia należy przewidzieć związane z kodem.  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.NameProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
   
  
## Examples  
 W poniższym przykładzie <xref:System.Windows.FrameworkElement.Name%2A> właściwości w kodzie, a następnie rejestruje nazwę do nowo utworzony <xref:System.Windows.NameScope> przez wywołanie metody <xref:System.Windows.FrameworkElement.RegisterName%2A>. Techniki przedstawione w tym miejscu jest wymagana do animacji z scenorys, ponieważ scenorys wymagają przeznaczonych dla przez <xref:System.Windows.FrameworkElement.Name%2A>i nie może być celem przez odwołanie do obiektu.  
  
 [!code-csharp[animateHeight_procedural#FEName](~/samples/snippets/csharp/VS_Snippets_Wpf/animateHeight_procedural/CSharp/AnimatedHeightExample.cs#fename)]
 [!code-vb[animateHeight_procedural#FEName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animateHeight_procedural/visualbasic/animatedheightexample.vb#fename)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.Name" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public virtual void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnApplyTemplate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnApplyTemplate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, jest wywoływane zawsze, gdy kod aplikacji lub procesami wewnętrznymi wywołanie <see cref="M:System.Windows.FrameworkElement.ApplyTemplate" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma domyślnej implementacji.  
  
 Szablony są części elementu ukończone drzewa wizualnego pochodzi z właściwości szablonu <xref:System.Windows.Style> który jest stosowany dla elementu. Aby uzyskać więcej informacji, zobacz [stylami i tworzenia szablonów](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Klasy pochodnej <see cref="T:System.Windows.FrameworkElement" /> tej metody można użyć jako powiadomienie dla różnych możliwych scenariuszy:  
  
-   Możesz wywołać implementacji kodu, która tworzy w pozostałej części drzewa wizualnego elementu.  
  
-   Można uruchomić kod, który opiera się na drzewie wizualnym z szablonów mających zostały zastosowane, takich jak uzyskanie odwołania do nazwanych elementów, które pochodzi z szablonu.  
  
-   Można wprowadzać tylko sensu istnieje po zakończeniu drzewa wizualnego z szablonów usługi.  
  
-   Można ustawić Stany i właściwości elementów w szablonie, które są zależne od innych czynników. Na przykład wartości właściwości mogą być tylko wykrywalny znając elementu nadrzędnego lub otrzymane określonej klasy używa wspólnego szablonu.  
  
 Implementacje zawsze powinny wywoływać implementację podstawową przed ich implementacji. <see cref="T:System.Windows.FrameworkElement" /> sam nie ma wartości domyślnej implementacji, ale klas pośredniczących może.  
  
 <see cref="T:System.Windows.Controls.Control" /> oferuje podobne override, <see cref="M:System.Windows.Controls.Control.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Zapewnia dane o zdarzeniu.</param>
        <summary>Wywoływane zawsze, gdy jest to nieobsługiwany <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /> kierowanego zdarzenia osiągnie tej klasy w jego trasy. Zaimplementuj tę metodę, aby dodać klasę obsługi dla tego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma domyślnej implementacji. Nadal powinny wywoływać implementację podstawową, w przypadku, gdy klasa pośrednicząca w dziedziczenia zaimplementowała tej metody.  
  
 Celem tej metody przypomina trochę [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] wzorzec zdarzeń na * metody: zapewnia sposób obsługi pasujące zdarzenie z klasy pochodnej z klasy obsługi zamiast obsługi wystąpienia. W takim przypadku pasujące zdarzenie jest kierowanego zdarzenia. Wzorzec implementacji metod On * są różne dla kierowane zdarzenia, ponieważ kierowanego zdarzenia został zgłoszony przez element podrzędny, niekoniecznie element wywołujący programów obsługi, więc implementacji, musisz podjąć źródła argumenty zdarzenia właściwości pod uwagę (i nie należy próbować ponownie zgłosić zdarzenie, które w większości przypadków). Podklasy <xref:System.Windows.FrameworkElement> można wywoływać metod obsługi Klasa prywatna, po odebraniu zdarzenia wzdłuż trasy. Jednym ze scenariuszy potencjalnych jest przyjmują argumentów zdarzenia i celowo oznaczanie zdarzenia jako obsługiwane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.RoutedEventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywoływane zawsze, gdy jest to nieobsługiwany <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> kierowanego zdarzenia osiągnie tej klasy w jego trasy. Zaimplementuj tę metodę, aby dodać klasę obsługi dla tego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma domyślnej implementacji. Nadal powinny wywoływać implementację podstawową, w przypadku, gdy klasa pośrednicząca w dziedziczenia zaimplementowała tej metody.  
  
 Celem tej metody przypomina trochę [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] wzorzec zdarzeń na * metody: zapewnia sposób obsługi pasujące zdarzenie z klasy pochodnej z klasy obsługi zamiast obsługi wystąpienia. W takim przypadku pasujące zdarzenie jest kierowanego zdarzenia. Wzorzec implementacji metod On * są różne dla kierowane zdarzenia, ponieważ kierowanego zdarzenia został zgłoszony przez element podrzędny, niekoniecznie element wywołujący programów obsługi, więc implementacji, musisz podjąć źródła argumenty zdarzenia właściwości pod uwagę (i nie należy próbować ponownie zgłosić zdarzenie, które w większości przypadków). Podklasy <xref:System.Windows.FrameworkElement> można wywoływać metod obsługi Klasa prywatna, po odebraniu zdarzenia wzdłuż trasy. Jednym ze scenariuszy potencjalnych jest przyjmują argumentów zdarzenia i celowo oznaczanie zdarzenia jako obsługiwane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.RoutedEventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywoływane zawsze, gdy jest to nieobsługiwany <see cref="E:System.Windows.UIElement.GotFocus" /> zdarzeń osiągnie tego elementu w jego trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od niektórych innych na * metody ujawnione przez podstawowe elementy <xref:System.Windows.FrameworkElement.OnGotFocus%2A> mają domyślną implementację. W szczególności ma implementację, która zastępuje null implementacji na poziomie następnego elementu podstawowego, <xref:System.Windows.UIElement.OnGotFocus%2A>. Gdy została wywołana, <xref:System.Windows.FrameworkElement.OnGotFocus%2A> Ustawia zachowanie odpowiednie fokus w tym elemencie w przypadkach, z którego pochodzi z bieżącego elementu z powodu fokus klawiatury. <xref:System.Windows.FrameworkElement.OnGotFocus%2A> Program obsługi nie są oznaczane argumenty zdarzeń jako obsługiwany, nawet wtedy, gdy fokus jest ustawiony do bieżącego elementu. Jeśli źródło zdarzenia innego elementu w drzewie (nie bieżący element), program obsługi nie działa.  
  
 Mogą przesłaniać tę metodę, aby zmienić domyślne zachowanie fokus w elemencie, ale należy pamiętać, że zmiany zachowania fokusu w ten sposób mogą można lepiej zrealizować, nie zezwalając element ma być focusable w ogóle (zobacz <xref:System.Windows.UIElement.Focusable%2A>).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Jeśli zamierzasz oznaczyć obsługiwane w argumentach zdarzenia, należy zwrócić uwagę wpływ na Obsługa zdarzeń w inne elementy nadrzędne w drzewie elementu. Ponieważ ten program obsługi działa na zdarzenie propagacji routingu, ustawienie fokus na bieżący <paramref name="sender" /> na zdarzenie argumenty mogą nie być odpowiednie. Fokus może być konieczne przejdź do elementu podrzędnego złożonego lub do elementu nadrzędnego, w zależności od składania niektórych formantów. W związku z tym oznaczenie zdarzeń fokusu, jak obsługiwane tylko jest zalecane, jeśli całości drzewa wizualnego routingiem zdarzenia za pośrednictwem wchodzi w skład składania formant, który zostanie utworzony.</para>
        </block>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.RoutedEventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.FrameworkElement.Initialized" /> zdarzeń. Ta metoda jest wywoływana przy każdym <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> ustawiono <see langword="true" /> wewnętrznie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej konkretnej na * metoda nie jest haku obsługi klasy. Nie jest on dokładnie zgodna ustalonych [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] na * Konwencji metody że pasujące zdarzenie można pominąć tej metody i nie wywołuje metody Podstawowa implementacja.  
  
 Należy pamiętać, że <xref:System.Windows.FrameworkElement.IsInitialized%2A> właściwość jest tylko do odczytu, więc nie można ustawić <xref:System.Windows.FrameworkElement.IsInitialized%2A> Aby wymusić zachowanie inicjowania. Ustawianie stanu inicjowania ma być przeprowadzane tylko w programie [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Domyślna implementacja tej metody wirtualnej zgłasza zdarzenie, zgodnie z powyższym opisem. Zastąpienia powinny wywoływać implementację podstawową w celu zachowania tego zachowania. Jeśli nie można wywoływać implementację podstawową, nie tylko możesz nie będą powodowały <see cref="E:System.Windows.FrameworkElement.Initialized" /> zdarzeń zgodnie z działaniem oczekiwanym <see cref="T:System.Windows.FrameworkElement" /> klasy, ale będzie również pominąć dwie ważne styl i motyw styl inicjowania operacje, które są implementowana przez tę implementację podstawową.</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.OnApplyTemplate" />
        <altmember cref="E:System.Windows.FrameworkElement.Initialized" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzenia, opisujące właściwość zmienione, a także starej i nowej wartości.</param>
        <summary>Wywoływane, gdy wartość efektywna dowolnej właściwości zależności na tym <see cref="T:System.Windows.FrameworkElement" /> została zaktualizowana. Właściwości określonych zależności, które zmienić jest zgłaszana w parametrze argumentów. Zastępuje <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest przeznaczona do ogólnie wykrycia zmian właściwości lub invalidations. Zamiast tego ma ona modyfikacji wzorca ogólne unieważniania Jeśli znane jest niektórych informacji o klasyfikacjach szeroki właściwości.  
  
 Tej metody jest potencjalnie wywołana wiele razy w okresie istnienia obiektu. W związku z tym można osiągnąć lepszą wydajność, jeśli Zastępowanie metadanych określonych właściwości, a następnie dołącz <xref:System.Windows.CoerceValueCallback> lub <xref:System.Windows.PropertyChangedCallback> funkcje dla poszczególnych właściwości. Jednak czy użyć tej metody, jeśli <xref:System.Windows.FrameworkElement> obejmuje znaczących właściwości zależności powiązanych wartości, lub jeśli zawiera logikę, takich jak zachowanie renderowania, który musi zostać uruchomiony ponownie dla kilku powiązanych przypadków invalidations właściwości.  
  
 Należy pamiętać, że o identycznej nazwie `OnPropertyChanged` metody o innym podpisie (typ parametru jest <xref:System.ComponentModel.PropertyChangedEventArgs>) wyświetlanych na liczbę klas. Czy `OnPropertyChanged` jest używany dla powiadomienia obiektu danych i jest częścią kontraktu dla <xref:System.ComponentModel.INotifyPropertyChanged>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zawsze należy wywoływać implementację podstawową, jako pierwszą operacją w implementacji. Błąd w tym celu znacznie spowoduje wyłączenie całą [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] właściwości systemu, co powoduje, że nieprawidłowe wartości należy podać. Konkretnym <see cref="T:System.Windows.FrameworkElement" /> implementacja również jest odpowiedzialny za konserwację stanu właściwe dla różnych właściwości, które mają wpływ na interfejsie użytkownika widoczne. Obejmują one unieważnia drzewa wizualnego, na podstawie zmian do nadawania stylu w odpowiednim czasie.</para>
        </block>
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="T:System.Windows.PropertyChangedCallback" />
      </Docs>
    </Member>
    <Member MemberName="OnRenderSizeChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnRenderSizeChanged (System.Windows.SizeChangedInfo sizeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnRenderSizeChanged(class System.Windows.SizeChangedInfo sizeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnRenderSizeChanged (sizeInfo As SizeChangedInfo)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnRenderSizeChanged(System::Windows::SizeChangedInfo ^ sizeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sizeInfo" Type="System.Windows.SizeChangedInfo" />
      </Parameters>
      <Docs>
        <param name="sizeInfo">Szczegóły stary i nowy rozmiar objętego zmiany.</param>
        <summary>Zgłasza <see cref="E:System.Windows.FrameworkElement.SizeChanged" /> zdarzeń, korzystając z informacji określony jako część danych ostatecznego zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.Windows.UIElement.OnRenderSizeChanged%2A>. Jeśli ta metoda jest wywoływana spowoduje zresetowanie <xref:System.Windows.FrameworkElement.ActualWidth%2A> właściwość <xref:System.Windows.FrameworkElement.ActualHeight%2A> właściwości i/lub, w zależności od tego, co jest określony jako zmienione w podanych argumentów i będzie zawsze podniesieniu zdarzenia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Nie zastępuj tej metody dla układu typowych scenariuszy. System układu działa w sposób celowo asynchroniczne, aby mieć pewność, że Rozmieść wszystkie możliwe układ i przypadków miary są rozliczane dla. Układ systemu Przesłaniaj metody <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /> i <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" /> są zwykle wystarczające do dostosowania wszelkie wymagane układu. <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /> jest ujawniona jako wirtualny. Można zastąpić <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /> aby wyeliminować wyjątku, której zmiana zachowania czasu wykonywania związane z danych wejściowych zdarzenia połączone za pomocą formantu recomposition w odpowiedzi może podać informacje o układzie niedokładne.  
  
 Nadal może przesłonić tę metodę w klasach pochodnych (on jest chroniona, ale nie jest zapieczętowany). Zawsze wywoływać implementację podstawową, aby zachować zachowanie wymienionych powyżej, chyba że masz bardzo specyficznego przyczyny wyłączenia domyślne zachowanie renderowania poziomie struktury WPF. Nie można podnieść <see cref="E:System.Windows.FrameworkElement.SizeChanged" /> zdarzeń spowoduje zachowanie niestandardowy układ, jeśli przy użyciu standardowej implementacji systemu układu poziomie struktury WPF.</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">Stary styl.</param>
        <param name="newStyle">Nowy styl.</param>
        <summary>Wywoływane, gdy zmienia się styl używany w tym elemencie, który spowoduje unieważnienie układu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma domyślną implementację, która ustawia flaga wewnętrzna, który służy do odnotowania warunku zmieniony styl.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Nie zwykle powinna mieć przesłonić tę metodę. Wszelkie Zmień styl, który obejmuje miary lub Rozmieść zmiany już wywołałoby inny cykl renderowania, przy założeniu Typowa implementacja <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />  /  <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />, lub wartości domyślne. Zastępuje z <see cref="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" /> może być odpowiednie Jeśli Twoje <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />  /  <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /> implementacje zostały celowo optymalizacji lub Obsługa częściowej aktualizacji, ale nadal chcieli stosowania zmian do stylów bardziej bezpośrednio. (Aktualizacje częściowe byłoby próbę uniknięcia wielu wywołań przyrostowe <see cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" /> i <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> na wszystkie elementy podrzędne).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Zapewnia dane o zdarzeniu.</param>
        <summary>Wywoływane zawsze, gdy jest to nieobsługiwany <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /> kierowanego zdarzenia osiągnie tej klasy w jego trasy. Zaimplementuj tę metodę, aby dodać klasę obsługi dla tego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma domyślnej implementacji. Nadal powinny wywoływać implementację podstawową, w przypadku, gdy klasa pośrednicząca w dziedziczenia zaimplementowała tej metody.  
  
 Celem tej metody przypomina trochę [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] wzorzec zdarzeń na * metody: zapewnia sposób obsługi pasujące zdarzenie z klasy pochodnej z klasy obsługi zamiast obsługi wystąpienia. W takim przypadku pasujące zdarzenie jest kierowanego zdarzenia. Wzorzec implementacji metod On * są różne dla kierowane zdarzenia, ponieważ kierowanego zdarzenia został zgłoszony przez element podrzędny, niekoniecznie element wywołujący programów obsługi, więc implementacji, musisz podjąć źródła argumenty zdarzenia właściwości pod uwagę (i nie należy próbować ponownie zgłosić zdarzenie, które w większości przypadków). Podklasy <xref:System.Windows.FrameworkElement> można wywoływać metod obsługi Klasa prywatna, po odebraniu zdarzenia wzdłuż trasy. Jednym ze scenariuszy potencjalnych jest przyjmują argumentów zdarzenia i celowo oznaczanie zdarzenia jako obsługiwane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Zapewnia dane o zdarzeniu.</param>
        <summary>Wywoływane, gdy <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /> kierowanego zdarzenia osiągnie tej klasy w jego trasy. Zaimplementuj tę metodę, aby dodać klasę obsługi dla tego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma domyślnej implementacji. Nadal powinny wywoływać implementację podstawową, w przypadku, gdy klasa pośrednicząca w dziedziczenia zaimplementowała tej metody.  
  
 Celem tej metody przypomina trochę [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] wzorzec zdarzeń na * metody: zapewnia sposób obsługi pasujące zdarzenie z klasy pochodnej z klasy obsługi zamiast obsługi wystąpienia. W takim przypadku pasujące zdarzenie jest kierowanego zdarzenia. Wzorzec implementacji metod On * są różne dla kierowane zdarzenia, ponieważ kierowanego zdarzenia został zgłoszony przez element podrzędny, niekoniecznie element wywołujący programów obsługi, więc implementacji, musisz podjąć źródła argumenty zdarzenia właściwości pod uwagę (i nie należy próbować ponownie zgłosić zdarzenie, które w większości przypadków). Podklasy <xref:System.Windows.FrameworkElement> można wywoływać metod obsługi Klasa prywatna, po odebraniu zdarzenia wzdłuż trasy. Jednym ze scenariuszy potencjalnych jest przyjmują argumentów zdarzenia i celowo oznaczanie zdarzenia jako obsługiwane w celu skrócenia trasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Starego elementu nadrzędnego. Może być <see langword="null" /> wskazująca, że element nie miał wcześniej wizualny obiekt nadrzędny.</param>
        <summary>Wywoływane, gdy element nadrzędny tego elementu w drzewie wizualnym zostanie zmieniona. Zastępuje <see cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Drzewa wizualnego jest potencjalnie innego z drzewa logicznego, ponieważ to ciąg elementy, które nie są efekty wizualne, takich jak kolekcje i rozwija niektóre elementy na podstawie ich składania styl i motyw. Aby uzyskać więcej informacji, zobacz [drzewa WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Domyślna implementacja tej metody wirtualnej kwerendy o nowym rekordem nadrzędnym, zgłasza różnych zdarzeń inicjowania i ustawia flagi wewnętrzny o stanie inicjowania <see cref="T:System.Windows.FrameworkElement" /> odpowiednio. Na koniec wywołuje kolejnych podstawowych implementacji podaną przez <see cref="T:System.Windows.UIElement" />, który z kolei odwołuje się jego elementów bazowych <see cref="T:System.Windows.Media.Visual" />. Zawsze wywoływać implementację podstawową, aby zachować to zachowanie, w przeciwnym razie zachowanie drzewa element dla tego elementu, gdy jest zadeklarowany jako element podrzędny innego elementu nie może być zgodnie z oczekiwaniami.  
  
 Kilka istniejących [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] klasy przesłonić tę metodę, na przykład: <see cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />, <see cref="M:System.Windows.Controls.ListBoxItem.OnVisualParentChanged(System.Windows.DependencyObject)" />. Najbardziej typowym scenariuszem jest wymuszenie, że nowy element nadrzędny musi być określonego typu. Może to obejmować zgłoszeniu wyjątku, jeśli jakikolwiek sposób test typu nie powiodła się nowym rekordem nadrzędnym. Specjalna wersja w tym scenariuszu istnieje we wdrożeniach dla elementów listy i elementów menu, które nie mają sensu żadnych poza elementu nadrzędnego visual należące do kolekcji odpowiednie do przechowywania ich w. Należy pamiętać, że tych przypadkach może nie zgłaszaj wyjątków, ponieważ może to być projektanta scenariusze, które opierają się na reparenting elementów, które znajdują się na chwilę bez nadrzędnych "regularne".  
  
 Ta metoda jest również zastąpiona w niektórych elementach, które są zazwyczaj elementu głównego, takich jak <see cref="T:System.Windows.Window" />. Inny przypadek jest elementów, które są widoczne główny element znaczników, ale automatyczne generowanie większej infrastruktury w skompilowanych drzewa logicznego (takie jak <see cref="T:System.Windows.Controls.Page" />). <see cref="T:System.Windows.Window" /> i <see cref="T:System.Windows.Controls.Page" /> implementacje celowo Zapieczętuj metody.</para>
        </block>
        <altmember cref="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy ten element uwzględnia właściwości stylu ze stylów motywu.</summary>
        <value>
          <see langword="true" /> Jeśli ten element nie używa właściwości style kompozycji; wszystkie właściwości stylu pochodzące pochodzą z aplikacji lokalnej style i właściwości style kompozycji nie mają zastosowania. <see langword="false" /> Jeśli style aplikacji się najpierw, a następnie Zastosuj style kompozycji dla właściwości, które nie zostały ustawione w szczególności w stylach aplikacji. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najbardziej typowe użycie tej właściwości jest pośrednie użycia w ramach metody ustawiającej stylu dostarczające style motywów.  
  
> [!IMPORTANT]
>  Jeśli ustawisz <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> do `true` w formancie zostanie pomijanie domyślnego szablonu formantu dostarczonych przez style kompozycji. Ten szablon formantu zwykle zawiera prezenterze zawartości i inne elementy połączone, które zapewniają podstawowy [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] funkcjonalność i wizualizacji dla formantu. Jeśli chcesz kontrolować w dalszym ciągu obsługuje te same funkcje co domyślne style kompozycji, należy podać alternatywne stylu z szablonu formantu, który replikuje taką samą strukturę. Aby uzyskać więcej informacji, zobacz [informacje o formancie tworzenia](~/docs/framework/wpf/controls/control-authoring-overview.md).  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.OverridesDefaultStyleProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera element logiczny obiekt nadrzędny tego elementu.</summary>
        <value>Ten element logiczny obiekt nadrzędny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Parent%2A> może być `null` w przypadkach, w którym utworzono wystąpienie elementu, ale nie jest podłączona do drzewa logicznego, po pewnym czasie podłączony do strony elementu poziomu głównego, lub obiekt aplikacji.  
  
 Zauważ, że logiczny obiekt nadrzędny elementu nie może zmienić w zależności od funkcji aplikacji, i utrzymywanie wartość tej właściwości nie zreflektuje tej zmiany. Należy zwykle pobrać wartość natychmiast, zanim zajdzie taka potrzeba.  
  
 Zobacz [drzewa WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) Aby uzyskać więcej informacji na temat przechodzenia drzewa logicznego i scenariusze w przypadku, gdy przy użyciu <xref:System.Windows.FrameworkElement.Parent%2A> jako technika elementu nadrzędnego jest odnajdowanie.  
  
 Aparat właściwości potencjalnie ponownych wszystkich wartości właściwości elementu po jego pokrewnym, ponieważ niektóre właściwości dziedziczenia wartości za pośrednictwem drzewa logicznego. <xref:System.Windows.FrameworkElement.DataContext%2A> Dotyczący dla powiązania można również zmienić, gdy elementy są pokrewnym.  
  
 Zmienianie elementu nadrzędnego zwykle tylko odbywa się za pośrednictwem manipulowania kolekcje, za pomocą dedykowanego metod dodawania i usuwania, lub przez ustawienie właściwości elementów zawartości.  
  
 Najbardziej typowym scenariuszem stosowania <xref:System.Windows.FrameworkElement.Parent%2A> właściwości ma otrzymać odwołanie, a następnie zachęcić różnych <xref:System.Windows.FrameworkElement> wartości właściwości z obiektu nadrzędnego. Dla szablonów <xref:System.Windows.FrameworkElement.Parent%2A> szablonu po pewnym czasie będzie `null`. Aby uzyskać po tym punkcie i rozszerzyć w drzewie logicznym, w której faktycznie zastosować ten szablon, użyj <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.  
  
 Należy pamiętać, że tej właściwości nie raportuje nadrzędnych drzewo wizualne w przypadkach, w którym mogą nadrzędnych drzewa logicznego. Nadrzędnych drzewa wizualnego nie są zwykle ważne w przypadku aplikacji głównej, ale może być elementy nadrzędne żądaną w niektórych przypadkach poziomu visual. Zobacz <xref:System.Windows.Media.VisualTreeHelper>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia kod, który sprawdza, czy element nadrzędny, a następnie używa wartości właściwości z obiektu nadrzędnego można ustawić właściwości dla elementu podrzędnego do dopasowania. W tym przypadku są to właściwości, które mają wpływ na rozmiar renderowania.  
  
 [!code-csharp[GeometryDesigner#FEParentProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometryDesigner/CSharp/Window1.xaml.cs#feparentproperty)]
 [!code-vb[GeometryDesigner#FEParentProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometryDesigner/visualbasic/window1.xaml.vb#feparentproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.TemplatedParent" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="ParentLayoutInvalidated">
      <MemberSignature Language="C#" Value="protected internal virtual void ParentLayoutInvalidated (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void ParentLayoutInvalidated(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub ParentLayoutInvalidated (child As UIElement)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void ParentLayoutInvalidated(System::Windows::UIElement ^ child);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">Element podrzędny raportowania zmiany.</param>
        <summary>Obsługuje implementacje przyrostową układu w specjalne podklasy <see cref="T:System.Windows.FrameworkElement" />. <see cref="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" /> wywoływane, gdy element podrzędny unieważnił właściwości, która jest oznaczony w metadanych jako wpływu na element nadrzędny miary lub rozmieszczania przebiegi podczas układu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ten element ma element podrzędny, na którym została unieważniona niektórych właściwości i właściwość została oznaczona jako <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> lub <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> w metadanych właściwości podczas rejestracji, ta metoda jest wywoływana. Wywołanie metody powiadamia element nadrzędny, w których element podrzędny określonego musi być ponownie zmierzone, jeśli ten element obsługuje częściowej aktualizacji (przyrostową) układu.  
  
 Domyślnie <xref:System.Windows.FrameworkElement> nie obsługuje przyrostowych układ i <xref:System.Windows.FrameworkElement> klasy to metoda ma domyślnej implementacji. Scenariusz, w którym przesłaniania tej metody będą niezbędne nie jest często, ponieważ można zmodyfikować zachowanie domyślne układu system wymaga.  
  
 Przykładowy scenariusz wdrażania może być, jeśli klasa ma ograniczenia typu dla elementów podrzędnych możliwe, które są znacznie bardziej restrykcyjny niż system układu poziomie struktury WPF. Z powodu charakter te elementy niestandardowe zmiany właściwości można celowo odroczone podczas implementowania niektóre zachowania niestandardowego układu. Na przykład miary/Rozmieść zamienników metod które spróbuj zoptymalizować elementu podrzędnego renderowania przebiegu, można odroczone dla niektórych typów zmian, które umożliwiałyby zwykle w innym przebiegu układu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Kierunek, dla której można ustalić zmiany potencjalnego fokus.</param>
        <summary>Określa następnego elementu, który może odbierać fokus względem tego elementu dla kierunku przepływu podana fokus, ale faktycznie nie przenosi fokus.</summary>
        <returns>Następny element, który skupić się były przenoszone do, jeśli faktycznie był przekształcić fokus. Może zwrócić <see langword="null" /> Jeśli fokus nie można przenieść względem tego elementu dla podanego kierunku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.MoveFocus%2A> jest to metoda pokrewne faktycznie Przenieś fokus.  
  
   
  
## Examples  
 Poniższy przykład implementuje obsługi, która obsługuje kilka możliwych przycisk wejść, każdy przycisk reprezentujący potencjalnie <xref:System.Windows.Input.FocusNavigationDirection>. Program obsługi śledzi element z bieżącego fokus klawiatury i wywołania <xref:System.Windows.FrameworkElement.PredictFocus%2A> dla tego elementu i określa odpowiednie <xref:System.Windows.Input.FocusNavigationDirection> jako inicjowania dla <xref:System.Windows.Input.TraversalRequest> podany parametr typu. Zamiast przechodzenia do tego elementu jako <xref:System.Windows.FrameworkElement.MoveFocus%2A> zrobić, program obsługi zmiany wymiary fizyczne przeznaczenia przewidywane fokus do celów wizualizacji.  
  
 [!code-csharp[FocusSample#FEPredictFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#fepredictfocus)]
 [!code-vb[FocusSample#FEPredictFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#fepredictfocus)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Określić jedną z następujących wskazówek w <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />. Te kroki są niedozwolone dla <see cref="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (ale dozwolony dla <see cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</exception>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa do użycia dla określonego mapowania nazwy obiektu.</param>
        <param name="scopedElement">Obiekt do mapowania.</param>
        <summary>Udostępnia metody dostępu, które ułatwiają dostęp do <see cref="T:System.Windows.NameScope" /> metoda rejestracji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest metodą wygody wywołania <xref:System.Windows.NameScope.RegisterName%2A>. Implementacja będzie sprawdzać elementy nadrzędne kolejnych, aż do znalezienia odpowiednich <xref:System.Windows.NameScope> wdrożenia, który znajduje się przez wyszukiwanie elementu, który implementuje <xref:System.Windows.Markup.INameScope>. Aby uzyskać więcej informacji o namescopes, zobacz [WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 Wywoływanie <xref:System.Windows.FrameworkElement.RegisterName%2A> jest potrzebne do poprawnie Połącz scenorys animacji dla aplikacji, podczas tworzenia w kodzie. Jest to spowodowane jedną klucza scenorysu właściwości <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, używa środowiska wykonawczego nazw wyszukiwania zamiast możliwość odwołania do elementu docelowego. Dotyczy to nawet, jeśli ten element jest dostępny przez odwołanie z kodu. Aby uzyskać więcej informacji na czego potrzebujesz do rejestracji nazw dla celów scenorysu, zobacz [omówienie Scenorys](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
   
  
## Examples  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/ScopeExample.cs#namescopeexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/scopeexample.vb#namescopeexample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.NameScope.RegisterName(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Element do usunięcia.</param>
        <summary>Usuwa podany obiekt z drzewa logicznego tego elementu. <see cref="T:System.Windows.FrameworkElement" /> Aktualizuje wskaźniki nadrzędnego dotyczy drzewa logicznego do synchronizowania podczas usuwania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do wykonania w kolekcji obiektów, które reprezentują logiczne elementy podrzędne danego elementu. To może odbywać się w pobierających właściwości lub metody ustawiające, obsługę klas z `Changed` zdarzenia, konstruktorów, lub w kolekcji typów samodzielnie.  
  
 Dla autorów kontroli manipulowanie drzewa logicznego na tym poziomie nie jest zalecana praktyka Brak modeli zawartości określonych w klasie bazowej podana nie znajdują się odpowiednie. Należy wziąć pod uwagę podklasy na poziomie <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>, i <xref:System.Windows.Controls.HeaderedItemsControl>. Tych klas Podaj modelu zawartości z konkretnym wymuszania logiczne elementy podrzędne za pośrednictwem dedykowanej [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)], a także obsługę innych funkcji, które są zwykle pożądane w [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] kontroli, takich jak style za pomocą szablonów.  
  
   
  
## Examples  
 Poniższy przykład implementuje `Child` właściwości niestandardowego <xref:System.Windows.FrameworkElement> wykonuje własną implementację visual warstwy. Metoda ustawiająca właściwości zaprojektowano tak, aby w przypadku zmiany wartości, stara wartość zostanie usunięty z drzewa logicznego, a także wizualna kolekcja specyficzne dla klasy. Wartości są buforowane, a następnie nową wartość są dodawane zarówno standardowe WPF framework poziomu drzewa logicznego, jak i niestandardowe kolekcji visual.  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoView">
      <MemberSignature Language="C#" Value="public event System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.RequestBringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RequestBringIntoView As RequestBringIntoViewEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RequestBringIntoViewEventHandler ^ RequestBringIntoView;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RequestBringIntoViewEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" /> jest wywoływana w tym elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie wskazuje, aby element nadrzędny <xref:System.Windows.Controls.ScrollViewer> (lub pochodne klasy) czy element który zgłasza <xref:System.Windows.FrameworkElement.RequestBringIntoView> zdarzeń powinny być widoczne w obrębie regionu przewijanego. <xref:System.Windows.Controls.ScrollViewer> Następnie oznaczy <xref:System.Windows.FrameworkElement.RequestBringIntoView> zdarzenie, ponieważ obsługiwane przy użyciu klasy obsługi zdarzenia. Ogólnie rzecz biorąc <xref:System.Windows.FrameworkElement.RequestBringIntoView> zdarzeń danych nie powinna być oznaczona jako obsługiwany przez wszystkie klasy, która kontrolować regionie przewijania lub za pomocą dowolnej wystąpienie programu obsługi, ponieważ dzięki temu może zakłócać celem danego elementu, który wywołuje <xref:System.Windows.FrameworkElement.BringIntoView%2A>.  
  
<a name="routedEventInfo_RequestBringIntoView"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.RequestBringIntoViewEvent>|  
|Strategii routingu|Propagacji|  
|Delegate|<xref:System.Windows.RequestBringIntoViewEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoViewEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent RequestBringIntoViewEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent RequestBringIntoViewEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly RequestBringIntoViewEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ RequestBringIntoViewEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /> kierowanego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia słownik zasobów zdefiniowane lokalnie.</summary>
        <value>Bieżący zdefiniowane lokalnie słownik zasobów, w której każdy z zasobów są dostępne dla klucza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Słowniki zasobów, które mogą być definiowane w całości lub częściowo w [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] są zazwyczaj tworzone jako elementu właściwości i są zwykle w elemencie głównym dla dowolnego pojedynczej strony lub aplikacji. Wprowadzenie do słownika zasobów na tym poziomie ułatwia odnaleźć podrzędne poszczególnych elementów na stronie (lub z dowolnej strony w przypadku aplikacji). W większości scenariuszy aplikacji, firma Microsoft zaleca, że style można zdefiniować jako elementy obiekt słownika zasobów lub zdefiniowane jako zasobów zewnętrznych, aby umożliwić zasób stylu całej niezależne (to rozwiązanie pomaga w oddzielnych projektanta obowiązki związane z obowiązki developer, oddziel pliki fizyczne, które powinny być edytowane).  
  
 Należy pamiętać, że ta właściwość zwraca tylko słownik zasobów zadeklarowany bezpośrednio z poziomu tego elementu. To jest inny niż proces wyszukiwania zasobów rzeczywistych, umożliwiający elementu podrzędnego dostęp do dowolnych zasobów zdefiniowane w każdy element nadrzędny, wyszukiwanie rekursywnie w górę.  
  
 Zasoby mogą się też odwoływać przez kod kolekcji, ale należy pamiętać, że zasoby są tworzone w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] ostatecznie nie będzie dostępny dopiero po <xref:System.Windows.FrameworkElement.Loaded> zostanie wywołane przez element, który deklaruje słownika. W rzeczywistości zasoby są parsowane asynchronicznie i nie nawet <xref:System.Windows.FrameworkElement.Loaded> zdarzenie jest zapewnienie, że można się odwołać [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] zdefiniowanych zasobów. Z tego powodu należy zwykle tylko dostęp [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] zdefiniowane jako część kodu w czasie wykonywania, lub za pośrednictwem innych zasobów [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] technik, takich jak style lub odwołania do rozszerzenia zasobu dla wartości atrybutu. Gdy uzyskujesz dostęp do zasobów przy użyciu kodu jest zasadniczo odpowiednikiem odniesienia z [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 Podstawowa <xref:System.Windows.ResourceDictionary> obsługuje metody wymagane do dodawania, usuwania lub zbadać zasobów w w kolekcji przy użyciu kodu. <xref:System.Windows.FrameworkElement.Resources%2A> Właściwość jest można ustawić na potrzeby scenariusza całkowicie zastąpienia kolekcji zasobów jako nowy lub innego elementu <xref:System.Windows.ResourceDictionary>.  
  
 Zwróć uwagę, że [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] składni pokazano nie zawiera elementu dla <xref:System.Windows.ResourceDictionary>. Jest to przykład składni niejawnej kolekcji; Znacznik reprezentujący element kolekcji można pominąć. Zamiast tego określono elementy, które są dodawane jako elementy w kolekcji. Aby uzyskać więcej informacji o kolekcjach niejawne i [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], zobacz [szczegółów w składni języka XAML](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md). Jeden przypadek gdzie <xref:System.Windows.ResourceDictionary> nadal jawnie określono, ponieważ element jest Jeśli udostępniono połączony słownik, w takim przypadku nie są zwykle żadnych elementów podrzędnych w tym <xref:System.Windows.ResourceDictionary>. Aby uzyskać więcej informacji, zobacz [scalić słowniki zasobów](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *oneOrMoreResourceElements*  
 Co najmniej jeden obiekt elementów, z których każdy definiuje zasób. Każdy element właściwości zasobów w ramach każdej <xref:System.Windows.ResourceDictionary> musi mieć unikatową wartość [dyrektywy x: Key](~/docs/framework/xaml-services/x-key-directive.md), która służy jako unikatowy klucz, gdy są one pobierane <xref:System.Windows.ResourceDictionary>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza powiązanie z tym elementem dla właściwości zależności określony.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">Identyfikuje właściwość docelowego, gdzie należy ustanowić powiązanie.</param>
        <param name="path">Nazwa właściwości źródła lub ścieżka do właściwości używane dla wiązania.</param>
        <summary>Dołącza powiązanie do tego elementu, na podstawie podanego źródła właściwości nazwy jako kwalifikacji ścieżki do źródła danych.</summary>
        <returns>Rejestruje warunków powiązania. Zwrócona wartość może być przydatne do kontroli błędów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest metodą wygody wywoływania <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, która przechodzi bieżącego wystąpienia jako <xref:System.Windows.DependencyObject>i tworzy nowy <xref:System.Windows.Data.Binding> na podstawie udostępnionych `path` parametru. Podpis jest wygodniejsze podczas ustanawiania domyślne proste powiązania. Jeśli trzeba określić żadnych właściwości powiązania do warunków innych niż domyślne lub chcesz użyć <xref:System.Windows.Data.MultiBinding> lub <xref:System.Windows.Data.PriorityBinding>, należy użyć <xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> podpisu.  
  
   
  
## Examples  
 Poniższy przykład przedstawia powiązanie przy użyciu określonej ścieżki.  
  
 [!code-csharp[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#setbindingpath)]
 [!code-vb[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#setbindingpath)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">Określa właściwość, której należy ustanowić powiązanie.</param>
        <param name="binding">Przedstawia szczegółowe informacje na temat wiązania danych.</param>
        <summary>Dołącza powiązanie do tego elementu, oparte na obiekt podana powiązania.</summary>
        <returns>Rejestruje warunków powiązania. Zwrócona wartość może być przydatne do kontroli błędów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest metodą wygody wywoływania <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, która przechodzi bieżącego wystąpienia jako <xref:System.Windows.DependencyObject>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetFlowDirection">
      <MemberSignature Language="C#" Value="public static void SetFlowDirection (System.Windows.DependencyObject element, System.Windows.FlowDirection value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFlowDirection(class System.Windows.DependencyObject element, valuetype System.Windows.FlowDirection value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFlowDirection (element As DependencyObject, value As FlowDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFlowDirection(System::Windows::DependencyObject ^ element, System::Windows::FlowDirection value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FlowDirection" />
      </Parameters>
      <Docs>
        <param name="element">Element, który określa kierunek przepływu.</param>
        <param name="value">Wartość wyliczenia określania kierunku.</param>
        <summary>Ustawia wartość <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> dołączona właściwość dla podanego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda obsługuje składnia dołączonej właściwości <xref:System.Windows.FrameworkElement.FlowDirection%2A> właściwości, w związku z tym stosowanie podrzędne elementy podana <xref:System.Windows.FrameworkElement> do określania kierunku przepływu dla rozmieszczenia w ramach jego elementu nadrzędnego. Można ustawić wartości na bieżącej <xref:System.Windows.FrameworkElement>, użyj bezpośrednio [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] akcesor <xref:System.Windows.FrameworkElement.FlowDirection%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Właściwość, z którym powiązany jest zasobu.</param>
        <param name="name">Nazwa zasobu.</param>
        <summary>Wyszukuje zasób o określonej nazwie i konfiguruje zasobów odwołanie do niej dla określonej właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Odwołanie do zasobu jest podobny do stosowania [DynamicResource — rozszerzenie znaczników](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) w znaczniku. Odwołanie do zasobu tworzy wyrażenie wewnętrznego, które dostarcza wartość określonej właściwości na podstawie odroczonego czasu wykonywania. Wyrażenie będą ponownie oceniane po każdym słownika zasobów wskazuje zmienione za pośrednictwem wewnętrznego zdarzenia lub gdy pokrewnym bieżącego elementu (Zmiana nadrzędnej zmieniłby słownika ścieżki wyszukiwania).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy procesy serializacji powinny serializować zawartości <see cref="P:System.Windows.FrameworkElement.Resources" /> właściwości.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="P:System.Windows.FrameworkElement.Resources" /> wartość właściwości powinny być serializowane; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spowoduje to zwrócenie `true` tak długo, jak istnieje co najmniej jeden zasób z kluczem w lokalnej <xref:System.Windows.FrameworkElement.Resources%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy procesy serializacji powinny serializować zawartości <see cref="P:System.Windows.FrameworkElement.Style" /> właściwości.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="P:System.Windows.FrameworkElement.Style" /> wartość właściwości powinny być serializowane; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spowoduje to zwrócenie `true` Jeśli <xref:System.Windows.Style> lokalnie jest ustawiona.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTriggers">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTriggers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTriggers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeTriggers" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTriggers () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTriggers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy procesy serializacji powinny serializować zawartości <see cref="P:System.Windows.FrameworkElement.Triggers" /> właściwości.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="P:System.Windows.FrameworkElement.Triggers" /> wartość właściwości powinny być serializowane; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca `true` Jeśli <xref:System.Windows.FrameworkElement.Triggers%2A> lokalnie ustawiono właściwość.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.SizeChangedEventHandler SizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SizeChangedEventHandler SizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SizeChanged As SizeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SizeChangedEventHandler ^ SizeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy albo <see cref="P:System.Windows.FrameworkElement.ActualHeight" /> lub <see cref="P:System.Windows.FrameworkElement.ActualWidth" /> właściwości Zmień wartość w tym elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezpośrednie kierowane zdarzenia nie wykonuj trasy, są obsługiwane tylko w obrębie tego samego elementu, na którym jest uruchamiany. Bezpośrednie kierowane zdarzenia obsługuje inne zachowanie kierowanego zdarzenia: obsługują dostępny obsługi kolekcji i mogą być używane jako <xref:System.Windows.EventTrigger> w stylu.  
  
 System układu odczytuje właściwości <xref:System.Windows.SizeChangedEventArgs> klasy argument tego zdarzenia, aby określić, czy zmiany rozmiaru zgłoszone należy traktować jako istotne. Dzięki temu system układ lub implementacjach użytkownika układu specyficzne dla kontroli w celu uniknięcia wymuszania zmiany układu z powodu wizualnie imperceptible różnice między starym i nowym wysokość lub szerokość wartości. Imperceptible różnice mogą wynikać z zaokrąglania lub takiego samego wyniku obliczenia typów danych zmiennoprzecinkowych.  
  
<a name="routedEventInfo_SizeChanged"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.SizeChangedEvent>|  
|Strategii routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.SizeChangedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Height" />
        <altmember cref="P:System.Windows.FrameworkElement.Width" />
      </Docs>
    </Member>
    <Member MemberName="SizeChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent SizeChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent SizeChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ SizeChangedEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkElement.SizeChanged" /> kierowanego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory kierowanego zdarzenia są tworzone, gdy kierowane zdarzenia są rejestrowane. Te identyfikatory zawiera nazwę identyfikującą, typ właściciela, typ obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia. Aby dodać obsługę klas, można użyć tych identyfikatorów.  
  
 Aby uzyskać więcej informacji na temat rejestrowania kierowane zdarzenia, zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Aby uzyskać więcej informacji o używaniu identyfikatorów kierowanego zdarzenia, aby dodać obsługę klas, zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zmienia się wartość źródła żadnych istniejących właściwości powiązania w tym elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie tworzy alias dla <xref:System.Windows.Data.Binding.SourceUpdated> zdarzenie, które jest wywoływane przez żadną <xref:System.Windows.Data.Binding> skojarzony z tym elementem.  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object SourceUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.SourceUpdated" />
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia styl używany przez ten element, gdy jest on renderowany.</summary>
        <value>Styl niestandardowy zastosowane, dla elementu, jeśli jest obecny. W przeciwnym razie <see langword="null" />. Wartością domyślną skonstruowany domyślne <see cref="T:System.Windows.FrameworkElement" /> jest <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku kontrolek bieżący styl jest często udostępniane przez domyślny styl z motywów kontroli, lub ze stylów zazwyczaj stosowane do formantów tego typu przez zasobów na poziomie strony lub aplikacji (styl niejawne). Ta właściwość jest nie ustawiona lub jest zwracany domyślny styl (motywu), ale zwraca, albo niejawne stylu lub jawne działającego w elemencie. W przypadku bezpośredniego lub pośredniego style nie ma znaczenia, czy styl jest określony jako zasób zdefiniowany lokalnie.  
  
 Ustawianie stylów ma pewne ograniczenia. Możesz przywrócić cały <xref:System.Windows.FrameworkElement.Style%2A> właściwości na nowy <xref:System.Windows.Style> w dowolnym momencie, która wymusi recomposition układu. Jednak niezwłocznie po stylu jest umieszczona używany przez element załadować <xref:System.Windows.Style> należy traktować jako sealed. Podjęto próbę dokonania zmiany do żadnej poszczególnych właściwości stylu w użyciu (np. wszystkich elementów w kolekcji <xref:System.Windows.Style.Setters%2A>) powoduje, że wyjątek zostanie wygenerowany. Styl, który jest zdefiniowany w znaczniku jest uznawany za będzie używana natychmiast po załadowaniu go ze słownika zasobów (dla zasobów) lub załadowanej strony, który jest zawarty w (dla style wbudowane).  
  
 <xref:System.Windows.FrameworkElement.Style%2A> jest to właściwość zależności o priorytecie specjalnych. Lokalnie ustawiony styl zazwyczaj operuje na najwyższy priorytet w systemie właściwości. Jeśli <xref:System.Windows.FrameworkElement.Style%2A> ma wartość null w tym momencie podczas ładowania właściwości system sprawdza, czy niejawne style w aplikacji lub lokalnych zasobów, które Określ tego typu. Jeśli styl jest nadal null po wykonaniu tego kroku, a następnie styl działając w celach prezentacji zazwyczaj pochodzą z styl domyślny (motywu), ale domyślnym stylu nie są zwracane w <xref:System.Windows.FrameworkElement.Style%2A> wartości właściwości. Zobacz [pierwszeństwo wartość właściwości zależności](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md) lub [stylami i tworzenia szablonów](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object Style="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_Style"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *resourceExtension*  
 Jedną z następujących:, lub. Zobacz [zasobów XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Klucz identyfikujący styl żądanej. Klucz odnosi się do istniejącego zasobu w <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Składni elementu właściwości jest technicznie możliwe, ale nie jest zalecane dla większości scenariuszy stylu. Zobacz [style wbudowane i szablony](~/docs/framework/wpf/advanced/inline-styles-and-templates.md). Odwołanie do wiązania za pomocą lub <xref:System.Windows.Data.Binding> jest także możliwe, ale rzadko.  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.StyleProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano stylu ze słownika zasobów.  
  
 [!code-xaml[FEResource#StyleProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty)]  
[!code-xaml[FEResource#StyleProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty2)]  
[!code-xaml[FEResource#StyleProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty3)]  
[!code-xaml[FEResource#StyleProperty4](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.Style" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nazwa żądanej właściwości otoczenia.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> metody.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="propertyName" /> są dostępne, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Windows.FrameworkElement> wystąpienia jest rzutowane na <xref:System.Windows.Markup.IQueryAmbient> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość dowolnego obiektu, który może służyć do przechowywania informacji niestandardowych o tym elemencie.</summary>
        <value>Wartość docelowa. Ta właściwość nie ma wartości domyślnej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest odpowiednikiem właściwości znacznika w modelach programowania inne firmy Microsoft, takich jak Visual Basic for Applications lub formularze systemu Windows. <xref:System.Windows.FrameworkElement.Tag%2A> mają na celu dostarczenie istniejące właściwość lokalizacji przechowywania kilku podstawowych informacji niestandardowych o <xref:System.Windows.FrameworkElement> bez konieczności do podklasy elementu.  
  
 Ponieważ ta właściwość ma obiekt, należy użyć użycie elementu właściwości, aby ustawić <xref:System.Windows.FrameworkElement.Tag%2A> właściwości w języku XAML na inny niż obiekt, za pomocą konwertera typu znane i wbudowane, takiego jak ciąg. Obiekty używane w ten sposób nie są zwykle w ramach standardowego przestrzenie nazw WPF i w związku z tym mogą wymagać mapowania przestrzeni nazw do zewnętrznego przestrzeni nazw, aby wprowadzić jako elementów XAML. Aby uzyskać więcej informacji, zobacz [przestrzeń nazw XAML i Namespace mapowanie WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md) i [XAML oraz klas niestandardowych dla WPF](~/docs/framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md).  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.TagProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.Tag" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość docelowa dla żadnego powiązania właściwości w tym elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie tworzy alias dla <xref:System.Windows.Data.Binding.TargetUpdated> zdarzenie, które jest wywoływane przez żadną <xref:System.Windows.Data.Binding> skojarzony z tym elementem. Zwykle oznacza to, że wiązanie dwukierunkowe jest zagrożona powiązania i właściwości zależności powiązane potwierdza, że poprzednia wartość właściwości teraz jest nieprawidłowa przy uwzględnieniu żadnych sprawdzania poprawności lub schemat buforowania właściwość lub źródło danych obsługuje.  
  
 Wykorzystanie danych zdarzenia <xref:System.Windows.FrameworkElement.TargetUpdated> zdarzenia w celu określenia konkretną właściwością zgłaszających aktualizacji wartości docelowej.  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object TargetUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.TargetUpdated" />
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do szablonu elementu nadrzędnego tego elementu. Ta właściwość nie jest ważna, jeśli element nie został utworzony za pomocą szablonu.</summary>
        <value>Element których <see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> spowodował ten element ma zostać utworzony. Ta wartość jest często <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.TemplatedParent%2A> często `null` dla obiektów, które są tworzone w znaczników aplikacji lub kodu. Jest to spowodowane bezpośrednio, utworzyć te obiekty nie za pomocą szablonu. Obiekt odwołania uzyskany przez przejście od katalogu głównego drzewa logicznego lub Typowa nazwa odwołania, nie pochodzą z szablonu.  
  
 Przypadków, gdy <xref:System.Windows.FrameworkElement.TemplatedParent%2A> może nie być `null` obejmują operacje takie jak testowania trafień obsługi zdarzeń dla niektórych niskiego poziomu zdarzenia wejściowe przejście drzewa wizualnego z <xref:System.Windows.Media.VisualTreeHelper>, lub Praca z wyliczenia, które mogą zwracać elementy, które nadeszły za pomocą szablonów. Inny zdarza się, jeśli w szczególności wywołujesz <xref:System.Windows.FrameworkTemplate.FindName%2A> przed istniejące <xref:System.Windows.FrameworkTemplate> i pracować z zwrócony obiekt.  
  
 Szablony są faktycznie udostępnionych obiektów, których zawartość szablonu są tworzone tylko raz. W związku z tym po uzyskaniu odwołania do obiektu do elementu, który pochodzi z szablonu, może się okazać, że jawnego drzewa logicznego nie dotrze do strony głównej. Aby można było połączyć szablonu odniesienie do drzewa logicznego strony, należy pobrać <xref:System.Windows.FrameworkElement.TemplatedParent%2A> wartości i kontynuować tree elementu zgodnie z potrzebami.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.ToolTip)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt etykietki narzędzia, która jest wyświetlana dla tego elementu w [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</summary>
        <value>Obiekt etykietki narzędzia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość tej właściwości jest typu <xref:System.Windows.Controls.ToolTip>, a następnie ta wartość jest etykietka narzędzia używanego w [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].  Jeśli wartość jest innego typu, a następnie ta wartość będzie służyć jako *zawartości* dla <xref:System.Windows.Controls.ToolTip> podane (skonstruowany) przez system. Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Controls.ToolTipService>. Klasa usługi udostępnia dołączone właściwości, które można dostosować <xref:System.Windows.Controls.ToolTip>.  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *toolTipContent*  
 Ciąg, który będzie wyświetlany tekst <xref:System.Windows.FrameworkElement.ToolTip%2A>.  
  
 *toolTipObjectContent*  
 Niektórych obiektów w formularzu elementu obiektów, które mają być używane jako zawartość dla <xref:System.Windows.FrameworkElement> . Zazwyczaj powinien to być <xref:System.Windows.FrameworkElement> lub innego elementu tworzy składania układu dla <xref:System.Windows.FrameworkElement.ToolTip%2A>, po pewnym czasie zawierające tekst w obrębie składania. W ten sposób użycia <xref:System.Windows.Controls.ToolTip> utworzyć elementu niejawnie z przeanalizowany [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]i *toolTipObjectContent* zawartości jest ustawiony jako jego <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> właściwości.  
  
 <`ToolTip` .../>  
 Zobacz <xref:System.Windows.Controls.ToolTip>.  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ToolTipProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Windows.Controls.ToolTip> w kodzie, a następnie ustawia <xref:System.Windows.FrameworkElement.ToolTip%2A> właściwość <xref:System.Windows.Controls.Primitives.StatusBar> formantu.  
  
 [!code-csharp[StatusBar#MakeProgressBar](~/samples/snippets/csharp/VS_Snippets_Wpf/StatusBar/CSharp/Window1.xaml.cs#makeprogressbar)]
 [!code-vb[StatusBar#MakeProgressBar](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StatusBar/visualbasic/window1.xaml.vb#makeprogressbar)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje zaraz przed zamknięciem dowolnej etykietki narzędzia w elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oznaczenie <xref:System.Windows.FrameworkElement.ToolTipClosing> zdarzeń jako obsługi nie spowoduje anulowania zamknięcia etykietka narzędzia. Po wyświetleniu etykietki narzędzia zamknięcia etykietkę narzędzia odbywa się tylko w odpowiedzi na interakcję użytkownika z interfejsu użytkownika.  
  
 To zdarzenie nie może być <xref:System.Windows.EventTrigger> w stylu. Jest to spowodowane pola Identyfikator zdarzenia wykorzystuje ponownie implementacja z usługą, która nie ujawnia metody zdarzeń dodawania i usuwania zdarzenia poziomu usług.  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ToolTipClosingEvent>|  
|Strategii routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   Zastąpienie <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> do zaimplementowania klasy obsługi dla tego zdarzenia w klasach pochodnych.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /> kierowanego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory kierowanego zdarzenia są tworzone, gdy kierowane zdarzenia są rejestrowane. Te identyfikatory zawiera nazwę identyfikującą, typ właściciela, typ obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia. Aby dodać obsługę klas, można użyć tych identyfikatorów.  
  
 Aby uzyskać więcej informacji na temat rejestrowania kierowane zdarzenia, zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Aby uzyskać więcej informacji o używaniu identyfikatorów kierowanego zdarzenia, aby dodać obsługę klas, zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po otwarciu dowolnej etykietki narzędzia w elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uniknąć etykietka narzędzia w interfejsie użytkownika programu obsługi dla <xref:System.Windows.FrameworkElement.ToolTipOpening> można oznaczyć <xref:System.Windows.Controls.ToolTipEventArgs> obsługi danych zdarzenia. W przeciwnym razie zostanie wyświetlony komunikat informujący, przy użyciu wartości <xref:System.Windows.FrameworkElement.ToolTip%2A> właściwość jako zawartość etykietka narzędzia. Inny możliwy scenariusz jest, że można zapisać obsługi, która wartość <xref:System.Windows.FrameworkElement.ToolTip%2A> właściwości dla elementu, który jest źródłem zdarzeń, tuż przed wyświetleniem etykietka narzędzia.  
  
 <xref:System.Windows.FrameworkElement.ToolTipOpening> nie zostanie wygenerowany, jeśli wartość <xref:System.Windows.FrameworkElement.ToolTip%2A> jest `null` lub w inny sposób nie ustawiono. Nie należy ustawiać celowo <xref:System.Windows.FrameworkElement.ToolTip%2A> do `null` podczas, gdy etykietka narzędzia jest otwarte lub otwierania; to nie przyniesie efektu zamknięcia etykietka narzędzia, a zamiast tego zostanie utworzona niepożądanych artefaktu visual w interfejsie użytkownika.  
  
 <xref:System.Windows.FrameworkElement.ToolTipOpening> Zdarzeń nie może być <xref:System.Windows.EventTrigger> w stylu. Jest to spowodowane pola Identyfikator zdarzenia wykorzystuje ponownie implementacja z usługą, która nie ujawnia metody zdarzeń dodawania i usuwania zdarzenia poziomu usług.  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ToolTipOpeningEvent>|  
|Strategii routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   Zastąpienie <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> do zaimplementowania klasy obsługi dla tego zdarzenia w klasach pochodnych.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /> kierowanego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory kierowanego zdarzenia są tworzone, gdy kierowane zdarzenia są rejestrowane. Te identyfikatory zawiera nazwę identyfikującą, typ właściciela, typ obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia. Aby dodać obsługę klas, można użyć tych identyfikatorów.  
  
 Aby uzyskać więcej informacji na temat rejestrowania kierowane zdarzenia, zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Aby uzyskać więcej informacji o używaniu identyfikatorów kierowanego zdarzenia, aby dodać obsługę klas, zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.ToolTip" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Triggers">
      <MemberSignature Language="C#" Value="public System.Windows.TriggerCollection Triggers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TriggerCollection Triggers" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Triggers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Triggers As TriggerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TriggerCollection ^ Triggers { System::Windows::TriggerCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.TriggerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję wyzwalaczy ustanowić bezpośrednio na ten element lub elementy podrzędne.</summary>
        <value>Kolekcja jednoznacznie <see cref="T:System.Windows.Trigger" /> obiektów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Tej właściwości można ustawić tylko [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] za pomocą składni kolekcji pokazano lub uzyskiwania dostępu do obiektu kolekcji i używając jej różnych metod, takich jak dodawanie. Właściwość do samego obiektu kolekcji jest tylko do odczytu, sama kolekcja odczytu i zapisu. Właściwość istnieje tylko w przypadku elementów głównych; próbuje znaleźć lub ustaw go w innym miejscu spowoduje wyjątków.  
  
 Ta właściwość nie umożliwiają zbadać wyzwalaczy, które istnieją w ramach używane w tym elemencie style. Zgłasza tylko kolekcja wyzwalaczy dosłownie dodawanych do kolekcji, w znaczników lub kodu. Elementy zwykle nie mają takich elementów istniejących domyślnie (przy użyciu szablonu dla wystąpienia); jest to częściej wyzwalacze, które pochodzą z formantu składania określone w stylach zamiast tego.  
  
 Pod względem zachowanie (i próby ustanowienia, który pochodzi od deklarowana przez który element <xref:System.Windows.FrameworkElement.Triggers%2A> kolekcji), zarówno warunku wyzwalania efekt wyzwalacza może być w tym elemencie i może znajdować się na jego elementy podrzędne w drzewie logicznym. Należy pamiętać, że jeśli używasz takich jak zdarzenia okresu istnienia <xref:System.Windows.FrameworkElement.Loaded> można pobrać tej kolekcji, element podrzędny wyzwalaczy może nie jeszcze być całkowicie załadowany i kolekcji będą mniejsze niż rzeczywiście byłoby w czasie wykonywania.  
  
 Należy pamiętać, że kolekcja wyzwalaczy na element obsługuje tylko <xref:System.Windows.EventTrigger>, nie wyzwalaczy właściwości (<xref:System.Windows.Trigger>). Jeśli potrzebujesz wyzwalaczy właściwości, należy umieścić je w obrębie stylu lub szablonie, a następnie przypisz tego stylu lub szablonie albo do elementu za pomocą <xref:System.Windows.FrameworkElement.Style%2A> właściwości, lub pośrednio przez odwołanie niejawne.  
  
<a name="xamlPropertyElementUsage_Triggers"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.Triggers>  
    oneOrMoreTriggers  
  </object.Triggers>  
</object>  
```  
  
<a name="xamlValues_Triggers"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *oneOrMoreTriggers*  
 Co najmniej jedna definicja <xref:System.Windows.EventTrigger> elementów. Każdy taki wyzwalacz powinien zawierać prawidłowe scenorysu akcje i odwołania. Należy pamiętać, że tej kolekcji można ustalić wyłącznie w elemencie głównym strony. Aby uzyskać więcej informacji, zobacz [omówienie Scenorys](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.EventTrigger" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Identyfikator klucza zasobu, który ma zostać odnaleziona.</param>
        <summary>Wyszukuje zasób z określonym kluczem, a zwraca tego zasobu, jeśli znaleziono.</summary>
        <returns>Znaleziono zasobu lub <see langword="null" /> Jeśli żaden z zasobów z dostarczonych <paramref name="key" /> został znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie można znaleźć zasobu w elemencie wywołującym, drzewa zasobu nadrzędnego jest wyszukiwana w górę za pośrednictwem drzewa logicznego, w taki sam sposób, która byłaby drzewa przeszukane Jeśli zasobów prosili klucza w czasie wykonywania. Metoda zwraca `null` tylko wtedy, gdy żaden z zasobów tego klucza istniał dowolne miejsce w drzewie zasobów na istniejących warunków drzewa w czasie który <xref:System.Windows.FrameworkElement.TryFindResource%2A> jest wywoływana.  
  
 Zwykle będzie natychmiast rzutowania wartości zwracanej typu właściwości, którą próbujesz ustawić o wartości zwracane zasobów.  
  
 <xref:System.Windows.FrameworkElement.FindResource%2A> Metody zachowanie jest podobne, z tą różnicą, że zgłasza wyjątek, jeśli został zwrócony żaden zasób z podanego klucza.  
  
   
  
## Examples  
 Poniższy przykład jest zaimplementowany jako program obsługi przycisku, gdy przycisk zostanie kliknięty zestawów do zdefiniowany zasób pędzla tła można uzyskać przez wywołanie <xref:System.Windows.FrameworkElement.TryFindResource%2A> od siebie samego. To przegląda drzewo elementu i klient znajdzie zasobu (zasobu, sam jest zdefiniowany w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] i nie jest wyświetlany).  
  
 [!code-csharp[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#fetryfindresource)]
 [!code-vb[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#fetryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy element zostanie usunięty z obrębu drzewa elementów załadowanych elementów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezpośrednie kierowane zdarzenia nie wykonuj trasy, są obsługiwane tylko w obrębie tego samego elementu, na którym jest uruchamiany. Bezpośrednie kierowane zdarzenia obsługuje inne zachowanie kierowanego zdarzenia: obsługują dostępny obsługi kolekcji i mogą być używane jako <xref:System.Windows.EventTrigger> w stylu.  
  
 <xref:System.Windows.FrameworkElement.Loaded> i <xref:System.Windows.FrameworkElement.Unloaded> może jednocześnie zostać wywołane na formanty w wyniku zmian kompozycji systemu zainicjowanego przez użytkownika. Zmień motyw powoduje unieważnienie szablon formantu i zawartych w niej drzewa wizualnego, co z kolei powoduje, że cały formant zwolnienie i ponowne załadowanie. W związku z tym <xref:System.Windows.FrameworkElement.Unloaded> nie zakłada się, że występuje tylko w nawigacji strony.  
  
 Należy pamiętać, że <xref:System.Windows.FrameworkElement.Unloaded> zdarzenie nie jest wywoływane po aplikacja rozpoczyna zamykanie. Zamknięcie aplikacji występuje, gdy warunek określony przez <xref:System.Windows.Application.ShutdownMode%2A> właściwość występuje. Jeśli umieścisz oczyszczanie kodu wewnątrz obsługi dla <xref:System.Windows.FrameworkElement.Unloaded> zdarzenia, takie jak w przypadku <xref:System.Windows.Window> lub <xref:System.Windows.Controls.UserControl>, nie może być potrzebny zgodnie z oczekiwaniami.  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.UnloadedEvent>|  
|Strategii routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkElement.Unloaded" /> kierowanego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory kierowanego zdarzenia są tworzone, gdy kierowane zdarzenia są rejestrowane. Te identyfikatory zawiera nazwę identyfikującą, typ właściciela, typ obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia. Aby dodać obsługę klas, można użyć tych identyfikatorów.  
  
 Aby uzyskać więcej informacji na temat rejestrowania kierowane zdarzenia, zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Aby uzyskać więcej informacji o używaniu identyfikatorów kierowanego zdarzenia, aby dodać obsługę klas, zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa pary nazwa obiektu do usunięcia z bieżącego zakresu.</param>
        <summary>Ułatwiają dostęp do <see cref="T:System.Windows.NameScope" /> rejestracji do metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystarczy wyrejestrować nazwy Jeśli chcesz ponownie zarejestrować inny element o takiej samej nazwie.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przywrócenie styl domyślny do bieżącego <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRounding">
      <MemberSignature Language="C#" Value="public bool UseLayoutRounding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseLayoutRounding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberSignature Language="VB.NET" Value="Public Property UseLayoutRounding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseLayoutRounding { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy układ zaokrąglanie powinno być stosowane do tego elementu rozmiar i położenie podczas układu.</summary>
        <value>
          <see langword="true" /> Jeśli zastosowano zaokrąglania układu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> właściwość elementu ma `true`, wszystkie wartości niecałkowity pikseli, które są obliczane podczas <xref:System.Windows.UIElement.Measure%2A> i <xref:System.Windows.UIElement.Arrange%2A> przekazuje są zaokrąglane do całego pikseli.  
  
 Ta właściwość jest dziedziczona przez elementy podrzędne.  
  
> [!NOTE]
>  Należy ustawić <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> do `true` dla elementu głównego. Układ systemu dodaje współrzędne podrzędnych na współrzędne obiektu nadrzędnego; w związku z tym jeśli współrzędne obiektu nadrzędnego nie znajdują się w granicach pikseli, współrzędne podrzędne również nie są na granicy pikseli. Jeśli <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> nie można ustawić w katalogu głównym, ustaw <xref:System.Windows.UIElement.SnapsToDevicePixels%2A> w elemencie podrzędnym efekt, który chcesz uzyskać.  
  
 Rysowanie obiektów na pikseli eliminuje półprzezroczyste krawędzi oferowanych przez wygładzanie, gdy krawędzi znajduje się w środku pikseli urządzenia. Na poniższej ilustracji przedstawiono dane wyjściowe wiersza pojedynczego szerokość piksela, która znajduje się w środku pikseli urządzenia. Wiersz po lewej stronie nie używa zaokrąglania układ i jest wygładzanie. Wiersz po prawej stronie używa układu zaokrąglania.  
  
 ![Anty&#45;alias wiersza w porównaniu do wiersza piksela. ] (~/add/media/pixelsnaplinecompare.PNG "Wygładzanie wiersza w porównaniu do wiersza piksela.")  
  
 Jeśli używasz układu zaokrąglania i <xref:System.Windows.GridUnitType.Star> zmiany rozmiaru, system układu tworzy małe różnice w wartości kolumny lub wiersza, tak aby uniknąć subpixel renderowania. Na przykład, czy siatka ma łączna szerokość 100 z 3 kolumny o rozmiarze <xref:System.Windows.GridUnitType.Star>, zamiast tworzyć trzy kolumny, która ma takie same szerokość 33,3, system układu tworzy 2 kolumny, które mają szerokość 33 i który ma szerokość 34.  
  
> [!NOTE]
>  W wersji 4.6 .NET do układu zaokrąglania w celu ograniczenia wystąpień wycinka w formantach obramowaniami zostały wprowadzone zmiany. Domyślnie ta funkcja jest włączona, jeśli Twoje platformy docelowej .NET Framework 4.6 lub nowszy. Aplikacje, które odnoszą się do wcześniejszych wersji platformy włączyć na nowe zachowanie, dodając następujące ustawienie do pliku app.config: `<runtime><AppContextSwitchOverrides value="Switch.MS.Internal.DoNotApplyLayoutRoundingToMarginsAndBorderThickness=false"/></runtime>` ustawienie tylko działa, gdy aplikacja jest uruchomiona na .NET Framework 4.6.  
  
   
  
## Examples  
 Poniższy przykład ilustruje efekt który <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> właściwość ma wierszu pojedynczego szerokość piksela. Wiersz po lewej stronie nie używa zaokrąglania układ, a wiersza po prawej stronie używa zaokrąglania układu. Jeśli wolno zmiany rozmiaru okna widać różnica taki układ zaokrąglania sprawia, że.  
  
```xaml  
  
<Page x:Class="LayoutRounding.Lines"  
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"  
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"  
    Title="Lines" Name="linesPage"  
    >  
  <StackPanel Width="150"  Margin="7" Orientation="Horizontal">  
    <!-- Single pixel line with layout rounding turned OFF.-->  
    <Rectangle UseLayoutRounding="False"  
       Width="45.5" Margin="10" Height="1" Fill="Red"/>  
    <!-- Single pixel line with layout rounding turned ON.-->  
    <Rectangle UseLayoutRounding="True"  
      Width="45.5" Margin="10" Height="1" Fill="Red"/>  
  </StackPanel>  
  <!-- Background Grid -->  
  <Page.Background>  
    <DrawingBrush  Viewport="0,0,10,10" ViewportUnits="Absolute" TileMode="Tile">  
      <DrawingBrush.Drawing>  
        <DrawingGroup>  
          <GeometryDrawing Brush="White">  
            <GeometryDrawing.Geometry>  
              <RectangleGeometry Rect="0,0,1,1" />  
            </GeometryDrawing.Geometry>  
          </GeometryDrawing>  
          <GeometryDrawing Geometry="M0,0 L1,0 1,0.1, 0,0.1Z " Brush="#CCCCFF" />  
          <GeometryDrawing Geometry="M0,0 L0,1 0.1,1, 0.1,0Z" Brush="#CCCCFF" />  
        </DrawingGroup>  
      </DrawingBrush.Drawing>  
    </DrawingBrush>  
  </Page.Background>  
</Page>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRoundingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty UseLayoutRoundingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty UseLayoutRoundingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UseLayoutRoundingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ UseLayoutRoundingProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.UseLayoutRounding" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.VerticalAlignment VerticalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.VerticalAlignment VerticalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property VerticalAlignment As VerticalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::VerticalAlignment VerticalAlignment { System::Windows::VerticalAlignment get(); void set(System::Windows::VerticalAlignment value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.VerticalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia charakterystyki wyrównania poziomego stosowane do tego elementu, gdy wchodzi on w ramach elementu nadrzędnego, takiego jak panel lub kontrolka elementów.</summary>
        <value>Ustawienie wyrównania w pionie. Wartość domyślna to <see cref="F:System.Windows.VerticalAlignment.Stretch" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.FrameworkElement.Height%2A> i <xref:System.Windows.FrameworkElement.Width%2A> w elemencie są jawnie ustawione właściwości, pomiarów zająć uprzednie układ i anulują zwykłe efekty ustawienia tej właściwości <xref:System.Windows.VerticalAlignment.Stretch>.  
  
 <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> jest [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] metody dostępu właściwości dla co to jest w rzeczywistości właściwości zależności. Ta właściwość zależności określonego dość często ma wartość jawnego "domyślną" ustawione inaczej w klasach element pochodny, szczególnie kontrolki. Zwykle ma to miejsce w jeden z dwóch sposobów: właściwość zależności jest ponownie zarejestrowane do określonej klasy pochodnej, ale z inną metadanych do ustawiania wartości domyślnych; lub istnieje domyślny styl są stosowane, która ustawia wartości tej właściwości zależności inaczej. Na przykład jawnego "domyślną" <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> dla <xref:System.Windows.Controls.ComboBoxItem> formant będzie <xref:System.Windows.VerticalAlignment.Center>, nawet jeśli <xref:System.Windows.Controls.ComboBoxItem> dziedziczy <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> bezpośrednio z <xref:System.Windows.FrameworkElement>. Jest to spowodowane resetowania tej wartości w ramach domyślnego stylu <xref:System.Windows.Controls.ComboBoxItem>, w obrębie stylu kontrolki szablonu.  
  
 <xref:System.Windows.Controls.Canvas> nie używa <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> podczas tworzenia układu, ponieważ <xref:System.Windows.Controls.Canvas> opiera się na bezwzględny.  
  
 Gdy dziedziczone przez <xref:System.Windows.Controls.ComboBoxItem> lub dowolnej klasy, pochodne <xref:System.Windows.Controls.ComboBoxItem> ponownie definiuje wartość domyślna tej właściwości należy <xref:System.Windows.VerticalAlignment.Center>.  
  
<a name="dependencyPropertyInfo_VerticalAlignment"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.VerticalAlignmentProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VerticalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VerticalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VerticalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VerticalAlignmentProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.VerticalAlignment" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów podrzędnych visual w obrębie tego elementu.</summary>
        <value>Liczba elementów podrzędnych visual dla tego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> Implementacja <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> zawsze zwraca wartość zero lub jeden. Klasy, które Obsługa kolekcji podrzędny obiekt visual może być więcej niż jeden musi zastępować właściwość ta i <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  
  
 Ta właściwość zazwyczaj służy do określania górną granicą bieżącej kolekcji podrzędnych na potrzeby zastąpienia układu Implementowanie (<xref:System.Windows.FrameworkElement.MeasureOverride%2A>, <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak niestandardowy moduł definiowania układu kodu używa wartości zadeklarowanych przez <xref:System.Windows.Media.VisualCollection> obsługuje dla wielu podrzędnych visual i raporty te wartości przy użyciu zastąpień z <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> i <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Jeśli klasa obsługuje więcej niż jeden element podrzędny visual w kolekcji elementów podrzędnych, należy zastąpić tę właściwość, aby uzyskać liczbę elementów w tej kolekcji. Należy to zrobić, nawet jeśli sam obiekt kolekcji argument. Logika układu elementu na poziomie framework WPF zakłada zwraca wszystkich elementów prawidłową liczbę za pomocą ich <see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /> właściwości.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public double Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Width" />
      <MemberSignature Language="VB.NET" Value="Public Property Width As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Width { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia szerokość elementu.</summary>
        <value>Szerokość elementu w [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Wartość domyślna to <see cref="F:System.Double.NaN" />. Ta wartość musi być równa lub większa niż 0,0. Górna granica informacji, zobacz uwagi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to jeden z trzech właściwości na <xref:System.Windows.FrameworkElement> określające szerokość informacji.  Są dwa inne <xref:System.Windows.FrameworkElement.MinWidth%2A> i <xref:System.Windows.FrameworkElement.MaxWidth%2A>.  Jeśli występuje konflikt między tymi wartościami, kolejność aplikacji do oznaczania rzeczywista szerokość jest pierwszym <xref:System.Windows.FrameworkElement.MinWidth%2A> musi zostać wdrożona, następnie <xref:System.Windows.FrameworkElement.MaxWidth%2A>, a na końcu w przypadku każdego z tych należą granice, <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 Zwracane wartości tej właściwości jest zawsze taki sam jak każdą wartość, która została ustawiona do niego. Natomiast wartość <xref:System.Windows.FrameworkElement.ActualWidth%2A> może się różnić. Układ mogą odrzucone sugerowany rozmiar jakiegoś powodu. System układu działa także asynchronicznie względem systemu właściwość zbiór <xref:System.Windows.FrameworkElement.Width%2A> i nie mogą być przetwarzane to określonego rozmiaru jeszcze zmiany właściwości.  
  
 Ponadto do akceptowalnego <xref:System.Double> wartości tej właściwości można też <xref:System.Double.NaN?displayProperty=nameWithType>. Jest to, jak określić zachowanie ustalania rozmiaru automatycznie. W [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] zostanie ustawiona wartość ciągu "Auto" (bez uwzględniania wielkości liter) umożliwiające automatycznej zmiany rozmiaru zachowanie. Automatycznej zmiany rozmiaru zachowanie oznacza, że element będzie wypełnić dostępnych. Należy jednak pamiętać, że kontrolek często podać wartości domyślne w ich domyślne style, które spowoduje wyłączenie automatycznego ustalania rozmiaru zachowanie, o ile nie dotyczy w szczególności ponownie włączyć.  
  
 Oprócz sprawdzania poprawności jest niedeterministyczne górna wartość przeznaczony dla <xref:System.Windows.FrameworkElement.Width%2A> który jest wymuszana przez system układu (jest bardzo duża liczba większa niż <xref:System.Single.MaxValue?displayProperty=nameWithType> ale mniejszy niż <xref:System.Double.MaxValue?displayProperty=nameWithType>). Jeśli przekroczysz ten powiązany, nie będzie renderować element, a nie wyjątek. Nie ustawiaj <xref:System.Windows.FrameworkElement.Width%2A> jest znacznie większa niż maksymalny rozmiar dowolnego wyświetlacza możliwe, lub może przekroczyć to niedeterministyczna górna granica wartości.  
  
<a name="xamlAttributeUsage_Width"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object Width="double"/>  
- or –  
<object Width ="qualifiedDouble"/>  
- or -  
<object Width ="Auto"/>  
```  
  
<a name="xamlValues_Width"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *double*  
 <xref:System.Double>  
  
 Reprezentacja ciągu <xref:System.Double> wartość równą lub większą niż 0,0. Górna granica informacji, zobacz uwagi. Ta wartość jest interpretowana jako [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] miary. Ciągi nie musi zawierać jawnie miejsc dziesiętnych. Na przykład wartość `1` jest dopuszczalna.  
  
 *qualifiedDouble*  
 A *podwójne* wartość jak opisano powyżej, a następnie za pomocą jednej z następujących ciągów jednostki w deklaracji: `px`, `in`, `cm`, `pt`.  
  
 `px` (domyślnie) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm` jest cm; 1cm==(96/2.54) pikseli  
  
 `pt` jest punktów. 1pt==(96/72) pikseli  
  
 `Auto`  
 Włącza zachowanie automatyczna zmiana rozmiaru. Zobacz uwagi.  
  
<a name="dependencyPropertyInfo_Width"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.WidthProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.WidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WidthProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.Width" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
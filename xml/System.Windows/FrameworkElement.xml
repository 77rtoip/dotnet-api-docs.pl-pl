<Type Name="FrameworkElement" FullName="System.Windows.FrameworkElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5304e30b2f27bea183d66c7cc450c3053fe362a8" />
    <Meta Name="ms.sourcegitcommit" Value="6f3d3181d9ca22a1ab46a7f61f3ee152f2b844ea" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="10/27/2018" />
    <Meta Name="ms.locfileid" Value="50175549" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkElement : System.Windows.UIElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkElement extends System.Windows.UIElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkElement&#xA;Inherits UIElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkElement : System::Windows::UIElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkElement = class&#xA;    inherit UIElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia poziomie struktury WPF zbiór właściwości, zdarzeń i metod dla elementów Windows Presentation Foundation (WPF). Ta klasa reprezentuje podana implementacji WPF poziomie struktury jest oparta na WPF poziom podstawowych interfejsów API, które są definiowane przez <see cref="T:System.Windows.UIElement" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> jest punkt połączenia między klasami elementu na poziomie framework WPF i zestaw podstawowych poziomie WPF <xref:System.Windows.UIElement> usług prezentacji. Aby uzyskać więcej informacji na temat tych pojęć, zobacz [architektura WPF](~/docs/framework/wpf/advanced/wpf-architecture.md).  
  
 <xref:System.Windows.FrameworkElement> Rozszerza <xref:System.Windows.UIElement> i dodaje następujące możliwości:  
  
-   **Układ systemu definicji**: <xref:System.Windows.FrameworkElement> zapewnia implementacji WPF określonych w poziomie struktury w przypadku niektórych metod, które zostały zdefiniowane jako wirtualnych elementów członkowskich w <xref:System.Windows.UIElement>. W szczególności <xref:System.Windows.FrameworkElement> zapieczętowuje określone zastąpienia układu podstawowego poziomu WPF i przekazuje odpowiednika poziomie struktury WPF klasy pochodne powinny przesłaniać zamiast tego. Na przykład <xref:System.Windows.FrameworkElement> zamknięcia <xref:System.Windows.UIElement.ArrangeCore%2A> , ale zapewnia <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>. Te zmiany odzwierciedlają fakt, że na poziomie struktury WPF jest systemem układ pełny w miejscu, umożliwiający renderowanie dowolne <xref:System.Windows.FrameworkElement> klasy pochodnej. W WPF podstawowe poziomu, niektóre elementy członkowskie, które będą struktury ogólnego [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] układu opartego na rozwiązaniu znajdują się w miejscu, ale nie zdefiniowano rzeczywiste aparatu układu systemu. Aby uzyskać więcej informacji, zobacz [układ](~/docs/framework/wpf/advanced/layout.md).  
  
-   **Drzewo logiczne:** ogólne [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] często wyrażonych jest drzewo elementów modelu programowania. Obsługa wyrażanie drzewa elementów jako drzewo logiczne i towarzyszące pomocy technicznej dla definiowania tego drzewa w znacznikach jest zaimplementowana w <xref:System.Windows.FrameworkElement> poziom. Pamiętaj jednak, że <xref:System.Windows.FrameworkElement> celowo nie definiuje model zawartości i pozostawia tej odpowiedzialności na klasach pochodnych. Aby uzyskać więcej informacji, zobacz [drzewa w WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
-   **Zdarzenia okresu istnienia obiektów:** jest często warto wiedzieć, kiedy element jest inicjowany (Konstruktor jest wywoływany) lub gdy elementu najpierw jest ładowany do drzewa logicznego. <xref:System.Windows.FrameworkElement> definiuje kilka zdarzeń dotyczą okres istnienia obiektów, które zapewniają punkty zaczepienia przydatne w przypadku operacje związane z kodem, które obejmują elementy, takie jak dodanie więcej elementów podrzędnych. Aby uzyskać więcej informacji, zobacz [zdarzenia okresu istnienia obiektu](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
-   **Obsługa powiązań danych i odwołania do zasobów dynamicznej:** właściwości poziomu obsługę powiązanie danych oraz zasobów jest implementowany przez <xref:System.Windows.DependencyProperty> klasy i zawarte w systemie właściwości, ale możliwość usuwania wartość elementu członkowskiego, który jest przechowywane jako <xref:System.Windows.Expression> (programowania konstrukcji źródłową powiązanie danych i zasobów dynamicznej) jest implementowany przez <xref:System.Windows.FrameworkElement>. Aby uzyskać więcej informacji, zobacz [Przegląd wiązanie danych](~/docs/framework/wpf/data/data-binding-overview.md) i [zasoby XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
-   **Style:** <xref:System.Windows.FrameworkElement> definiuje <xref:System.Windows.FrameworkElement.Style%2A> właściwości. Jednak <xref:System.Windows.FrameworkElement> nie została jeszcze zdefiniować obsługę szablonów lub obsługuje dekoratory. Te funkcje są wprowadzone przez klasy formantów, takich jak <xref:System.Windows.Controls.Control> i <xref:System.Windows.Controls.ContentControl>.  
  
-   **Więcej obsługę animacji:** obsługi niektórych animacji została już zdefiniowana na poziomie core WPF, ale <xref:System.Windows.FrameworkElement> rozszerza to zaimplementowanie <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> i powiązanych elementów członkowskich.  
  
 Jak wynika z hierarchii klas wielu [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] klasy pochodzić od <xref:System.Windows.FrameworkElement>, bezpośrednio lub za pośrednictwem pośrednich klas podstawowych takich jak <xref:System.Windows.Controls.Panel> lub <xref:System.Windows.Controls.Control>.  
  
 Jeśli zamierzasz używać <xref:System.Windows.FrameworkElement> jako klasa bazowa, warto najpierw sprawdzić istniejące klasy pochodnej. <xref:System.Windows.FrameworkElement> zapewnia obsługę kilka podstawowych scenariuszy, ale również nie zawiera pewną liczbę funkcji, które są wskazane "elementu" w sensie elementem konstrukcyjnym, który umożliwia tworzenie [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] w [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. Na przykład <xref:System.Windows.FrameworkElement> nie definiuje żadnych true model zawartości; <xref:System.Windows.FrameworkElement> jako klasa bazowa nie definiuje właściwości, które mogą tworzyć [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] elementów podrzędnych. W szczególności należy przyjrzeć się <xref:System.Windows.Controls.Control> i <xref:System.Windows.Controls.ContentControl>.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.FrameworkContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkElement" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeight">
      <MemberSignature Language="C#" Value="public double ActualHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualHeight { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ActualHeight : double" Usage="System.Windows.FrameworkElement.ActualHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wysokość renderowanych tego elementu.</summary>
        <value>Wysokość elementu jako wartość [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Wartością domyślną jest 0 (zero).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest wartością obliczoną na podstawie danych wejściowych innych wysokość i system układu. Wartość jest ustawiana przez system układu, oparte na rzeczywistych renderowania — dostęp próbny i może być w związku z tym opóźniona nieco ustaw wartość właściwości takich jak <xref:System.Windows.FrameworkElement.Height%2A> , które są podstawą wprowadzania zmian.  
  
 Ponieważ <xref:System.Windows.FrameworkElement.ActualHeight%2A> jest obliczoną wartość, należy pamiętać, że może istnieć wiele zgłaszane przyrostowe zmiany lub do niego wyniku różne operacje przez system układu. System układu może obliczania miary wymagane miejsce dla elementów podrzędnych, ograniczenia przez element nadrzędny i tak dalej.  
  
 Mimo że nie można ustawić tę właściwość z [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], można oprzeć <xref:System.Windows.Trigger> po jego wartość w stylu.  
  
<a name="dependencyPropertyInfo_ActualHeight"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ActualHeightProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład wyświetla różne właściwości wysokości.  
  
 [!code-csharp[HeightMinHeightMaxHeight#3](~/samples/snippets/csharp/VS_Snippets_Wpf/HeightMinHeightMaxHeight/CSharp/Window1.xaml.cs#3)]
 [!code-vb[HeightMinHeightMaxHeight#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HeightMinHeightMaxHeight/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActualHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.ActualHeight" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidth">
      <MemberSignature Language="C#" Value="public double ActualWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualWidth { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ActualWidth : double" Usage="System.Windows.FrameworkElement.ActualWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera szerokość renderowanych tego elementu.</summary>
        <value>Szerokość elementu jako wartość [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Wartością domyślną jest 0 (zero).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest wartością obliczoną na podstawie danych wejściowych innych szerokości i system układu. Wartość jest ustawiana przez system układu, oparte na rzeczywistych renderowania — dostęp próbny i może być w związku z tym opóźniona nieco ustaw wartość właściwości takich jak <xref:System.Windows.FrameworkElement.Width%2A> , które są podstawą wprowadzania zmian.  
  
 Ponieważ <xref:System.Windows.FrameworkElement.ActualWidth%2A> jest obliczoną wartość, należy pamiętać, że może istnieć wiele zgłaszane przyrostowe zmiany lub do niego wyniku różne operacje przez system układu. System układu może obliczania miary wymagane miejsce dla elementów podrzędnych, ograniczenia przez element nadrzędny i tak dalej.  
  
 Mimo że nie można ustawić tę właściwość z [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], można oprzeć <xref:System.Windows.Trigger> po jego wartość w stylu.  
  
<a name="dependencyPropertyInfo_ActualWidth"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ActualWidthProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład wyświetla różne właściwości szerokości.  
  
 [!code-csharp[WidthMinWidthMaxWidth#3](~/samples/snippets/csharp/VS_Snippets_Wpf/WidthMinWidthMaxWidth/CSharp/Window1.xaml.cs#3)]
 [!code-vb[WidthMinWidthMaxWidth#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WidthMinWidthMaxWidth/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActualWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.ActualWidth" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Element podrzędny, która ma zostać dodana.</param>
        <summary>Dodaje podany obiekt do drzewa logicznego tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do wykonania w kolekcji obiektów, które reprezentują elementów podrzędnych logicznego elementu. Obsługa kolekcji w kolekcje elementów podrzędnych elementu może odbywać się w metody pobierające właściwości lub metody ustawiające, obsługę zmieniono zdarzenia, konstruktory, lub w ramach typów kolekcji, same klasy.  
  
 Dla autorów kontroli manipulowanie drzewo logiczne na tym poziomie nie jest zalecana praktyka, chyba że żaden z modeli zawartości dla klas dostępne kontrolki podstawowej są odpowiednie dla danego scenariusza kontroli. Należy wziąć pod uwagę podklasy na poziomie <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>, i <xref:System.Windows.Controls.HeaderedItemsControl>. Te klasy oferują model zawartości przy użyciu określonego wymuszania elementów podrzędnych logicznego drzewa za pośrednictwem dedykowanej [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)], a także obsługę innych funkcji, które są zazwyczaj pożądane w [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] kontrolki, np. stylów za pomocą szablonów. Aby uzyskać więcej informacji na temat sposobu użycia <xref:System.Windows.FrameworkElement.LogicalChildren%2A> i <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>, zobacz [drzewa w WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 <xref:System.Windows.FrameworkElement.AddLogicalChild%2A> może zgłosić wyjątek, jeśli wywołano w danym momencie, gdy drzewo logiczne jest on postanowiliśmy przez inny proces.  
  
   
  
## Examples  
 Poniższy przykład implementuje `Child` właściwość niestandardową <xref:System.Windows.FrameworkElement> wykonujący implementacji warstwy visual. Metoda ustawiająca właściwości jest zaprojektowana tak, że jeśli wartość zostanie zmieniona, stara wartość zostanie usunięty z drzewa logicznego, a także kolekcję visual swoiste dla klas. Wartość właściwości jest buforowany, a następnie nową wartość jest dodawany do drzewa logicznego i niestandardowej kolekcji visual.  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyTemplate">
      <MemberSignature Language="C#" Value="public bool ApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyTemplate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ApplyTemplate();" />
      <MemberSignature Language="F#" Value="member this.ApplyTemplate : unit -&gt; bool" Usage="frameworkElement.ApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy drzewo wizualne bieżącego szablonu, jeśli to konieczne i zwraca wartość wskazującą, czy drzewo wizualne został odbudowany przez to wywołanie.</summary>
        <returns>
          <see langword="true" /> Jeśli wizualizacje zostały dodane do drzewa; Zwraca <see langword="false" /> inaczej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacje można wywołać tę metodę, aby zagwarantować, że drzewa wizualnego elementu została zakończona. W tym kroku gwarancji może być konieczne, jeśli kod zostanie sprawdzanie elementy podrzędne w drzewie. Dla typowego elementu logiki w aplikacjach, podczas wywoływania <xref:System.Windows.FrameworkElement.ApplyTemplate%2A> nie jest konieczne, ponieważ szablony zostaną zastosowane do elementów w momencie odpowiednie w ich okresy istnienia automatycznie.  
  
 <xref:System.Windows.FrameworkElement.ApplyTemplate%2A> jest wywoływana w Każda miara jest przekazywany za pomocą system poziomie struktury układu WPF.  
  
 <xref:System.Windows.FrameworkElement> można użyć klas pochodnych <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> klasy programu obsługi, aby otrzymywać powiadomienia o przypadkach, gdy ta metoda została wywołana jawnie lub przez system układu. <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> jest wywoływana, gdy szablon jest całkowicie i dołączony do drzewa logicznego.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ControlTemplate" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeCore">
      <MemberSignature Language="C#" Value="protected override sealed void ArrangeCore (System.Windows.Rect finalRect);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ArrangeCore(valuetype System.Windows.Rect finalRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Sub ArrangeCore (finalRect As Rect)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ArrangeCore(System::Windows::Rect finalRect);" />
      <MemberSignature Language="F#" Value="override this.ArrangeCore : System.Windows.Rect -&gt; unit" Usage="frameworkElement.ArrangeCore finalRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalRect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="finalRect">Końcowe obszar nadrzędnym, która powinna być używana ten element, aby rozmieścić wraz z jego elementów podrzędnych.</param>
        <summary>Implementuje <see cref="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" /> (zdefiniowany jako maszynę wirtualną w <see cref="T:System.Windows.UIElement" />) i zapieczętowuje wdrożenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest zapieczętowany. Aby zastąpić logikę w swojej element niestandardowy dla przebiegu rozmieszczanie układu elementu swoje <xref:System.Windows.FrameworkElement> klasy pochodne muszą przesłaniać <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size ArrangeOverride (System.Windows.Size finalSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size finalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ArrangeOverride (finalSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size ArrangeOverride(System::Windows::Size finalSize);" />
      <MemberSignature Language="F#" Value="abstract member ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.ArrangeOverride finalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="finalSize">Końcowe obszar nadrzędnym, która powinna być używana ten element, aby rozmieścić wraz z jego elementów podrzędnych.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, określa położenie elementów podrzędnych i określa rozmiar dla <see cref="T:System.Windows.FrameworkElement" /> klasy pochodnej.</summary>
        <returns>Jeśli rozmiar rzeczywisty jest używany.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Autorzy kontroli, którzy chcesz dostosować przebiegu rozmieszczanie układu przetwarzania powinny przesłaniać tę metodę. Należy wywołać implementację wzorca <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> na każdym elemencie podrzędnym widoczne i — dostęp próbny końcowe żądanego rozmiaru dla każdego elementu podrzędnego jako <paramref name="finalRect" /> parametru. Elementy nadrzędne należy wywołać <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> na poszczególne elementy podrzędne, w przeciwnym razie elementów podrzędnych nie będzie renderowana.  
  
Wiele klas pochodnych oferują implementacje tej metody. Widocznym te obejmują: <see cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />, <see cref="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" /> i <see cref="M:System.Windows.Controls.Control.ArrangeOverride(System.Windows.Size)" />.</para>
        </block>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkElement.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia proces inicjowania dla tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dostosowując je w sposób, który jeszcze nie ujawniają i nie element nawiązać połączenie z dowolnym drzewo elementów, można wywołać tę metodę w poszczególnych elementów. Na przykład utworzyć nowy <xref:System.Windows.FrameworkElement>, ale nie jeszcze go do dołączono wszelkie drzewo logiczne. Lub drzewo logiczne, do których Twoje element jest elementem podrzędnym znajdujący się w nim może nie być połączony z okna lub strony aplikacji.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zaimplementuj tę metodę, aby zapewnić obsługę specjalne, który ma się zdarzyć, zanim Twoja element jest inicjowany podczas element proces ładowania.  
  
Twoja implementacja powinny wywoływać implementację podstawową, ponieważ implementacja base (ustawienie domyślne) ustawia niektóre wewnętrznego flagi do śledzenia inicjowania. Jedna implementacja możliwe jest do używania tej metody jako zaczepienia do własnych Klasa prywatna procedury inicjowania, które nie są już włączone przez konstruktory.  
  
Podstawowa implementacja spowoduje zgłoszenie wyjątku, jeśli <see cref="M:System.Windows.FrameworkElement.BeginInit" /> jest wywoływana więcej niż jeden raz w tym samym elemencie przed <see cref="M:System.Windows.FrameworkElement.EndInit" /> wywoływana.</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.EndInit" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna się sekwencję akcji zawartych w podanej scenorysu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">Scenorysu, aby rozpocząć.</param>
        <summary>Rozpoczyna się Sekwencja akcji, które znajdują się w podanej scenorysu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najbardziej typowe scenariusze animacji nie należy używać tej metody. Zazwyczaj w celu utworzenia <xref:System.Windows.Media.Animation.Storyboard> lub <xref:System.Windows.Media.Animation.BeginStoryboard> element adiustacji, a następnie umieść je jako <xref:System.Windows.EventTrigger> zawartości elementu. Po wyzwoleniu przez zdarzenie uruchamia następnie animacji. Większości aspektów kontroli <xref:System.Windows.Media.Animation.Storyboard> może zostać zlikwidowane przez właściwości, które są dostępne w znacznikach.  
  
 W przypadku podpisów, które nie korzystają z `isControllable`, parametr, lub gdy określono tego parametru `false`, zegary osi czasu, które są skojarzone z animacji są usuwane, tak szybko, jak animacji osiągnie okres "Fill". W związku z tym animacji nie można uruchomić ponownie po uruchomieniu jeden raz. Kontrolowanie animacji również wymaga scenorysu [x: Name — dyrektywa](~/docs/framework/xaml-services/x-name-directive.md) lub być dostępny za pomocą odwołania w kodzie.  
  
   
  
## Examples  
 Poniższy przykład pobiera <xref:System.Windows.Media.Animation.Storyboard> z zasobów, a następnie uruchamia, <xref:System.Windows.Media.Animation.Storyboard> po klasy obsługiwane przez zdarzenie wewnętrzne.  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">Scenorysu, aby rozpocząć.</param>
        <param name="handoffBehavior">Wartość wyliczenia, opisujący zachowanie do użycia, jeśli właściwość opisanego w serii ujęć już jest animowany.</param>
        <summary>Rozpoczyna się sekwencję akcji zawartych w podanej scenorysu, za pomocą opcji określonych dla co ma się zdarzyć, jeśli właściwość jest już animowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najbardziej typowe scenariusze animacji nie należy używać tej metody. Zazwyczaj w celu utworzenia <xref:System.Windows.Media.Animation.Storyboard> lub <xref:System.Windows.Media.Animation.BeginStoryboard> element adiustacji, a następnie umieść je jako <xref:System.Windows.EventTrigger> zawartości elementu. Po wyzwoleniu przez zdarzenie uruchamia następnie animacji. Większości aspektów kontroli <xref:System.Windows.Media.Animation.Storyboard> może zostać zlikwidowane przez właściwości, które są dostępne w znacznikach.  
  
 W przypadku podpisów, które nie korzystają z `isControllable`, parametr, lub gdy określono tego parametru `false`, zegary osi czasu, które są skojarzone z animacji są usuwane, tak szybko, jak animacji osiągnie okres "Fill". W związku z tym animacji nie można uruchomić ponownie po uruchomieniu jeden raz. Kontrolowanie animacji również wymaga scenorysu [x: Name — dyrektywa](~/docs/framework/xaml-services/x-name-directive.md) lub być dostępny za pomocą odwołania w kodzie.  
  
 Zachowanie dotyczące przekazania można określić jako atrybut <xref:System.Windows.Media.Animation.BeginStoryboard>.  
  
## <a name="using-the-compose-handoffbehavior"></a>Korzystanie z Compose HandoffBehavior  
 Po zastosowaniu <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> do właściwości przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> obiektów była poprzednio skojarzona z tą właściwością, kontynuując zużywanie zasobów systemowych; nie system chronometrażu Automatycznie usuwaj zegary.  
  
 Aby uniknąć problemów z wydajnością, po zastosowaniu dużej liczby zegary przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, tworzenie zegary należy usunąć z animowanych właściwości po ich zakończeniu. Istnieje kilka sposobów, aby usunąć zegar:  
  
-   Aby usunąć wszystkie zegary z właściwością, należy użyć <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metoda obiekt animowany. Określa właściwość, jest animowany podczas pierwszego parametru i `null` jako drugiego. Spowoduje to usunięcie wszystkie zegary animacji z właściwości.  
  
-   Aby usunąć określony <xref:System.Windows.Media.Animation.AnimationClock> z listy zegary, użyj <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość <xref:System.Windows.Media.Animation.AnimationClock> można pobrać <xref:System.Windows.Media.Animation.ClockController>, następnie wywołać <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metody <xref:System.Windows.Media.Animation.ClockController>. Jest to zazwyczaj wykonywane <xref:System.Windows.Media.Animation.Clock.Completed> program obsługi zdarzeń dla zegara. Należy pamiętać, że tylko zegary głównego można kontrolować, <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość zegara podrzędne zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzeń nie jest inicjowane, jeśli efektywnym czasem trwania zegara jest nieskończona.  W takim przypadku użytkownik musi określić, kiedy do wywołania <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Jest to głównie problemu dla animacji na obiekty, które mają długi okres istnienia.  Gdy obiekt jest bezużyteczne, jego zegary również są odłączone i wyrzucania.  
  
 Aby uzyskać więcej informacji o obiektach zegara, zobacz [Animacja i System chronometrażu w — Przegląd](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 Poniższy przykład pobiera <xref:System.Windows.Media.Animation.Storyboard> z zasobów, a następnie uruchamia, <xref:System.Windows.Media.Animation.Storyboard> po klasy obsługiwane przez zdarzenie wewnętrzne.  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">Scenorysu, aby rozpocząć.</param>
        <param name="handoffBehavior">Wartość wyliczenia, opisujący zachowanie do użycia, jeśli właściwość opisanego w serii ujęć już jest animowany.</param>
        <param name="isControllable">Deklaruje, czy animacja jest kontrolowane (może być wstrzymana) po jej ponownym uruchomieniu.</param>
        <summary>Rozpoczyna się sekwencję akcji zawartych w podanej scenorysu, o określonym stanie dla formantu animacji po jej ponownym uruchomieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najbardziej typowe scenariusze animacji nie należy używać tej metody. Zazwyczaj w celu utworzenia <xref:System.Windows.Media.Animation.Storyboard> lub <xref:System.Windows.Media.Animation.BeginStoryboard> element adiustacji, a następnie umieść je jako <xref:System.Windows.EventTrigger> zawartości elementu. Po wyzwoleniu przez zdarzenie uruchamia następnie animacji. Większości aspektów kontroli <xref:System.Windows.Media.Animation.Storyboard> może zostać zlikwidowane przez właściwości, które są dostępne w znacznikach.  
  
 W przypadku podpisów, które nie korzystają z `isControllable`, parametr, lub gdy określono tego parametru `false`, zegary osi czasu, które są skojarzone z animacji są usuwane, tak szybko, jak animacji osiągnie okres "Fill". W związku z tym animacji nie można uruchomić ponownie po uruchomieniu jeden raz. Kontrolowanie animacji również wymaga scenorysu [x: Name — dyrektywa](~/docs/framework/xaml-services/x-name-directive.md) lub być dostępny za pomocą odwołania w kodzie.  
  
 Zachowanie dotyczące przekazania można określić jako atrybut <xref:System.Windows.Media.Animation.BeginStoryboard>.  
  
## <a name="using-the-compose-handoffbehavior"></a>Korzystanie z Compose HandoffBehavior  
 Po zastosowaniu <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> do właściwości przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> obiektów była poprzednio skojarzona z tą właściwością, kontynuując zużywanie zasobów systemowych; nie system chronometrażu Automatycznie usuwaj zegary.  
  
 Aby uniknąć problemów z wydajnością, po zastosowaniu dużej liczby zegary przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, tworzenie zegary należy usunąć z animowanych właściwości po ich zakończeniu. Istnieje kilka sposobów, aby usunąć zegar:  
  
-   Aby usunąć wszystkie zegary z właściwością, należy użyć <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metoda obiekt animowany. Określa właściwość, jest animowany podczas pierwszego parametru i `null` jako drugiego. Spowoduje to usunięcie wszystkie zegary animacji z właściwości.  
  
-   Aby usunąć określony <xref:System.Windows.Media.Animation.AnimationClock> z listy zegary, użyj <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość <xref:System.Windows.Media.Animation.AnimationClock> można pobrać <xref:System.Windows.Media.Animation.ClockController>, następnie wywołać <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metody <xref:System.Windows.Media.Animation.ClockController>. Jest to zazwyczaj wykonywane <xref:System.Windows.Media.Animation.Clock.Completed> program obsługi zdarzeń dla zegara. Należy pamiętać, że tylko zegary głównego można kontrolować, <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość zegara podrzędne zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzeń nie jest inicjowane, jeśli efektywnym czasem trwania zegara jest nieskończona.  W takim przypadku użytkownik musi określić, kiedy do wywołania <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Jest to głównie problemu dla animacji na obiekty, które mają długi okres istnienia.  Gdy obiekt jest bezużyteczne, jego zegary również są odłączone i wyrzucania.  
  
 Aby uzyskać więcej informacji o obiektach zegara, zobacz [Animacja i System chronometrażu w — Przegląd](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Data.BindingGroup" /> używany dla elementu.</summary>
        <value>
          <see cref="T:System.Windows.Data.BindingGroup" /> Używany dla elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Element <xref:System.Windows.Data.BindingGroup> może służyć do sprawdzania poprawności wartości wielu właściwości obiektu. Na przykład załóżmy, że aplikacja monituje użytkownika o podanie adresu, a następnie wypełnia obiekt typu `Address`, który ma właściwości `Street`, `City`, `ZipCode`, i `Country`, przy użyciu wartości, użytkownik podana. Aplikacja ma panel, który zawiera cztery <xref:System.Windows.Controls.TextBox> formantów, z których każdy jest powiązane z jedną z właściwości obiektu. Możesz użyć <xref:System.Windows.Controls.ValidationRule> w <xref:System.Windows.Data.BindingGroup> do sprawdzania poprawności `Address` obiektu. Na przykład <xref:System.Windows.Controls.ValidationRule> można upewnić się, że kod pocztowy jest prawidłowy dla kraju adresu.  
  
 Elementy podrzędne dziedziczą <xref:System.Windows.Data.BindingGroup> z ich elementów nadrzędnych, tak jak w przypadku wszystkich innych właściwości dziedziczonych.  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.BindingGroupProperty>|  
|Ustaw właściwości metadanych **true**|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Poniższe przykłady są częścią aplikacji, która sprawdza, czy użytkownik ma ustawioną właściwości dwóch obiektów na równą wartości. Pierwszy przykład umożliwia utworzenie dwóch <xref:System.Windows.Controls.TextBox> formantów, z których każdy jest powiązany z innym źródłem danych. <xref:System.Windows.Controls.StackPanel> Ma <xref:System.Windows.Data.BindingGroup> zawierający <xref:System.Windows.Controls.ValidationRule> , sprawdza, czy dwa ciągi są równe.  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupComplete](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupcomplete)]  
  
 W poniższym przykładzie przedstawiono <xref:System.Windows.Controls.ValidationRule> używającej w poprzednim przykładzie.  W <xref:System.Windows.Controls.ValidationRule.Validate%2A> zastąpienie metody przykład pobiera każdy obiekt źródłowy z <xref:System.Windows.Data.BindingGroup> i sprawdza, czy właściwości obiektów są takie same.  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 Aby wywołać <xref:System.Windows.Controls.ValidationRule>, wywołaj <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> metody.  Poniższy przykład wywołuje <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> gdy wystąpi zdarzenie kliknięcia przycisku.  
  
 [!code-csharp[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#updatesourcesclick)]
 [!code-vb[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#updatesourcesclick)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.BindingGroup" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BringIntoView">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Próbuje przenieść ten element do wyświetlenia w ramach przewijany regionów, który jest zawarty w.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Próbuje przenieść ten element do wyświetlenia w ramach przewijany regionów, który jest zawarty w.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przez wywołanie tej metody, zostanie podniesiony <xref:System.Windows.FrameworkElement.RequestBringIntoView> zdarzeń, który pochodzi z bieżącego elementu. To zdarzenie jest wywoływane, dzięki czemu może zostać obsłużony przez <xref:System.Windows.Controls.ScrollViewer>, lub klasy pochodnej lub podobne. Oczekiwane zachowanie jest, że zdarzenie jest obsługiwane przez element nadrzędny, oznaczone jako obsługiwane w danych zdarzenia i źródło zdarzenia jest przeznaczone do wyświetlenia za pośrednictwem logiki osadzone w <xref:System.Windows.Controls.ScrollViewer> kontroli. Ani <xref:System.Windows.FrameworkElement.RequestBringIntoView> zdarzeń ani <xref:System.Windows.FrameworkElement.BringIntoView%2A> metoda przekazuje wszystkie informacje o powodzeniu lub niepowodzeniu, innym niż zdarzenie jest zwykle oznaczony obsługiwanego na powodzenie. Przyczyny niepowodzenia może zawierać ustawienia elementu, takie jak <xref:System.Windows.UIElement.Visibility%2A> jest jedna z wartości innych niż <xref:System.Windows.Visibility.Visible>.  
  
 Jeśli używasz podpisu, który nie określa `targetRectangle`, następnie rozmiar całego elementu (jego <xref:System.Windows.UIElement.RenderSize%2A>) będą widoczne.  
  
 Przez wywołanie tej metody, potencjalnie wywołasz <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> na wszelkie przewijany obszar nadrzędny, który zawiera element. Jeśli ten element nie jest zawarta w przewijanym obszarze <xref:System.Windows.FrameworkElement.RequestBringIntoView> zdarzenie jest zgłaszane w dalszym ciągu, ale nie będzie żadnego efektu ponieważ istnieją nie detektorów zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład wykonuje program obsługi zdarzeń nawigacji aplikacji, który odpowiada zawsze, gdy [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] trwa przejście zawiera fragmentu. Fragment jest wymieniony w polu [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] następujące znak kratki (#), i zaimplementowano zachowanie powoduje, że element przewinąć do widoku w ramce. <xref:System.Windows.FrameworkElement.BringIntoView%2A> i <xref:System.Windows.FrameworkElement.RequestBringIntoView> żądania to zachowanie przewijania w przykładzie.  
  
 [!code-csharp[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/csharp/VS_Snippets_Wpf/FragmentNavigationSample/CSharp/MainWindow.xaml.cs#febringintoview)]
 [!code-vb[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FragmentNavigationSample/VisualBasic/MainWindow.xaml.vb#febringintoview)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView (System.Windows.Rect targetRectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView(valuetype System.Windows.Rect targetRectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView (targetRectangle As Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView(System::Windows::Rect targetRectangle);" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : System.Windows.Rect -&gt; unit" Usage="frameworkElement.BringIntoView targetRectangle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetRectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="targetRectangle">Określony rozmiar elementu, który również należy dostosować do widoku.</param>
        <summary>Podejmuje próbę wprowadzenia rozmiar podany region tego elementu w widoku, w ramach przewijany regionów, który jest zawarty w.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przez wywołanie tej metody, zostanie podniesiony <xref:System.Windows.FrameworkElement.RequestBringIntoView> zdarzeń, który pochodzi z bieżącego elementu. To zdarzenie jest wywoływane, dzięki czemu może zostać obsłużony przez <xref:System.Windows.Controls.ScrollViewer>, lub klasy pochodnej lub podobne. Oczekiwane zachowanie jest, że zdarzenie jest obsługiwane przez element nadrzędny, oznaczone jako obsługiwane w danych zdarzenia i źródło zdarzenia jest przeznaczone do wyświetlenia za pośrednictwem logiki osadzone w <xref:System.Windows.Controls.ScrollViewer> kontroli. Ani <xref:System.Windows.FrameworkElement.RequestBringIntoView> zdarzeń ani <xref:System.Windows.FrameworkElement.BringIntoView%2A> metoda przekazuje wszystkie informacje o powodzeniu lub niepowodzeniu, innym niż zdarzenie jest zwykle oznaczony obsługiwanego na powodzenie. Przyczyny niepowodzenia może zawierać ustawienia elementu, takie jak <xref:System.Windows.UIElement.Visibility%2A> jest jedna z wartości innych niż <xref:System.Windows.Visibility.Visible>.  
  
 Jeśli używasz podpisu, który nie określa `targetRectangle`, następnie rozmiar całego elementu (jego <xref:System.Windows.UIElement.RenderSize%2A>) będą widoczne.  
  
 Przez wywołanie tej metody, potencjalnie wywołasz <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> na wszelkie przewijany obszar nadrzędny, który zawiera element. Jeśli ten element nie jest zawarta w przewijanym obszarze <xref:System.Windows.FrameworkElement.RequestBringIntoView> zdarzenie jest zgłaszane w dalszym ciągu, ale nie będzie żadnego efektu ponieważ istnieją nie detektorów zdarzeń.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono dużą grafikę w ograniczonym obszarze przewijana. Przycisk na stronie ma program obsługi, który przewija widok do konkretnego regionu duże grafiki.  
  
 [!code-xaml[BaseElementsSmorgasbord#BringIntoViewRectMarkup](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml#bringintoviewrectmarkup)]  
  
 [!code-csharp[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#bringintoviewrectcode)]
 [!code-vb[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#bringintoviewrectcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.FlowDocumentScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia element menu kontekstowego, który powinien zostać wyświetlony każdorazowo żądania za pomocą menu kontekstowego [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] z w ramach tego elementu.</summary>
        <value>Menu kontekstowe przypisane do tego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ContextMenu> jest <xref:System.Windows.FrameworkElement> klasę pochodną i jest technicznie możliwe, aby <xref:System.Windows.Controls.ContextMenu> sam być <xref:System.Windows.FrameworkElement.ContextMenu%2A> właściwości. Jednak powoduje to utworzenie mylące środowiska menu kontekstowe dla użytkownika i tej praktyką nie jest zalecane.  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ContextMenuProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje zaraz przed zamknięciem dowolnego menu kontekstowego w elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby pominąć zamknięcia menu kontekstowe, programy obsługi zdarzeń należy oznaczyć go jako obsługiwane.  
  
 Aby użyć tego zdarzenia jako <xref:System.Windows.EventTrigger> w stylu, musi odwoływać się usłudze podstawowej definicji zdarzenia:  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (To użycie jest konieczne, ponieważ implementacja zdarzeń w <xref:System.Windows.FrameworkElement> czy uwidacznia bazowe zdarzenie usługi nie jest mapowany <xref:System.Windows.FrameworkElement.ContextMenuClosing> identyfikator taki sposób, aby można było używać go jako wyzwalacz).  
  
 <xref:System.Windows.Controls.ContextMenu> jest <xref:System.Windows.FrameworkElement> klasy, ale <xref:System.Windows.FrameworkElement.ContextMenuClosing> zdarzenia nie zostaną wywołane przez menu kontekstowe bezpośrednio. Zamiast tego zdarzenie jest wywoływane z elementu "właścicielem" z menu kontekstowego jako właściwość, która powstaje tylko, gdy użytkownik próbuje zamknąć menu kontekstowego w interfejsie użytkownika. Jednak jest możliwe <xref:System.Windows.Controls.ContextMenu> sam być <xref:System.Windows.FrameworkElement.ContextMenu%2A> właściwości (menu kontekstowe zagnieżdżone). W tym przypadku <xref:System.Windows.Controls.ContextMenu> naprawdę jest właścicielem zagnieżdżonego <xref:System.Windows.Controls.ContextMenu> i mogą zgłaszać zdarzenia ze źródłem zdarzenia jest menu kontekstowe zagnieżdżonych.  
  
 <xref:System.Windows.Controls.ContextMenu> Sama klasa ma również podobne zdarzenie (<xref:System.Windows.Controls.ContextMenu.Closed>), ale <xref:System.Windows.Controls.ContextMenu.Closed> zdarzeń nie daje możliwość anulowania akcji użytkownika.  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ContextMenuClosingEvent>|  
|Strategii routingu|Propagacja|  
|Delegate|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   Zastąp <xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A> zaimplementować obsługę klasy dla tego zdarzenia w klasach pochodnych.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /> zdarzenia trasowanego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia trasowanego identyfikatory są tworzone, jeśli są rejestrowane zdarzenia trasowane. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metody dodawania właścicieli dla zdarzenia. Aby dodać funkcje obsługi klas, można użyć tych identyfikatorów.  
  
 Aby uzyskać więcej informacji na temat rejestrowania zdarzenia trasowane, zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Aby uzyskać więcej informacji na temat przy użyciu identyfikatorów zdarzenia trasowanego, aby dodać funkcje obsługi klas, zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po otwarciu dowolnego menu kontekstowego w elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby ręcznie otworzyć menu kontekstowe, programy obsługi zdarzeń należy oznaczyć istotnych zdarzeń jako obsługiwane. W przeciwnym razie istniejącej wartości <xref:System.Windows.FrameworkElement.ContextMenu%2A> zostanie użyta właściwość, aby automatycznie otworzyć menu kontekstowe. Oznaczanie zdarzeń obsługiwane skutecznie spowoduje anulowanie domyślnej akcji i może być możliwość resetowania wartości <xref:System.Windows.FrameworkElement.ContextMenu%2A> właściwości, a następnie otwórz nowy <xref:System.Windows.Controls.ContextMenu>. Jednak jest błąd chronometrażu, których należy wiedzieć. W celu całkowitego zastąpienia menu kontekstowego za pośrednictwem <xref:System.Windows.FrameworkElement.ContextMenuOpening> obsługi menu kontekstowe początkowej nie mogą być null / puste. Alternatywnie może być konieczne obsługi zdarzeń, a następnie ręcznie Otwórz nowe menu kontekstowego. Aby uzyskać więcej informacji, zobacz [porady: Obsługa zdarzenia ContextMenuOpening](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).  
  
 Aby użyć tego zdarzenia jako <xref:System.Windows.EventTrigger> w stylu, musi odwoływać się podstawowym dołączone zdarzenie:  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (Tego użycia jest wymagana, ponieważ implementacja zdarzeń w <xref:System.Windows.FrameworkElement> czy uwidacznia bazowe zdarzenie usługi nie jest mapowany <xref:System.Windows.FrameworkElement.ContextMenuOpening> identyfikator taki sposób, aby można było używać go w wyzwalacze).  
  
 <xref:System.Windows.Controls.ContextMenu> jest <xref:System.Windows.FrameworkElement> klasy pochodnej, ale to zdarzenie nie zostaną wywołane z poziomu menu kontekstowego otwierana jako źródło. Zdarzenie jest wywoływane z elementu "właścicielem" z menu kontekstowego jako właściwość, która powstaje tylko, gdy użytkownik próbuje otworzyć menu kontekstowe w interfejsie użytkownika. Możliwe jest <xref:System.Windows.Controls.ContextMenu> sam być <xref:System.Windows.FrameworkElement.ContextMenu%2A> właściwości, ale należy unikać tego scenariusza (Aby uzyskać więcej informacji, zobacz <xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType>).  
  
 <xref:System.Windows.Controls.ContextMenu> Sama klasa ma również podobne zdarzenie (<xref:System.Windows.Controls.ContextMenu.Opened>), ale <xref:System.Windows.Controls.ContextMenu.Opened> nie zapewnia możliwość anulowania akcji użytkownika.  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ContextMenuOpeningEvent>|  
|Strategii routingu|Propagacja|  
|Delegate|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   Zastąp <xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A> zaimplementować obsługę klasy dla tego zdarzenia w klasach pochodnych.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> zdarzenia trasowanego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia trasowanego identyfikatory są tworzone, jeśli są rejestrowane zdarzenia trasowane. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metody dodawania właścicieli dla zdarzenia. Aby dodać funkcje obsługi klas, można użyć tych identyfikatorów.  
  
 Aby uzyskać więcej informacji na temat rejestrowania zdarzenia trasowane, zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Aby uzyskać więcej informacji na temat przy użyciu identyfikatorów zdarzenia trasowanego, aby dodać funkcje obsługi klas, zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.ContextMenu" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kursor wyświetlany, gdy wskaźnik myszy znajduje się nad tym elementem.</summary>
        <value>Kursor do wyświetlenia. Wartość domyślna jest zdefiniowany jako <see langword="null" /> dla tej właściwości zależności. Jednak domyślnie praktyczne w czasie wykonywania będą pochodzić z różnych czynników.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ustawisz tę właściwość [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] procesora zależy od typu konwersji dla <xref:System.Windows.Input.Cursor> klasy można obliczyć wartości ciągu. Podany ciąg powinna być wyliczana jako <xref:System.Windows.Input.CursorType> wartość. Zobacz <xref:System.Windows.Input.Cursor> Aby uzyskać szczegółowe informacje.  
  
 Czy kursor zgodnie z ustaleniami tej właściwości będzie lub nie będą wyświetlane, gdy wskaźnik myszy znajduje się nad tym elementem jest również zależny od wartości <xref:System.Windows.FrameworkElement.ForceCursor%2A> właściwości. Ponadto zdarzenie powiązane zagadnienia, takich jak active przeciągnij, przechwytywanie myszy, tryby w ramach kontrolki i tak dalej, edycji tekstu wpłynie również na kursora o wyższym priorytecie niż wartość, którą określisz w tej właściwości.  
  
 Aby cofnąć ustawienie tej właściwości do ostatecznej domyślne zachowanie, ustaw ją na `null` ponownie.  
  
 `null` Domyślne tak naprawdę oznacza, że określenie wartości praktyczne kursora jest odroczone tutaj mają być uzyskiwane z innego miejsca. Przedstawione bez programowe wartości z dowolnego źródła, domyślnego kursora jest wizualnie ponad [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] aplikacja będzie strzałki. Jednak zmian przejściowych kursora nie ustawiono <xref:System.Windows.FrameworkElement.Cursor%2A> wartości elementów, gdy są przekazywane za pośrednictwem. <xref:System.Windows.FrameworkElement.Cursor%2A> Właściwości będą tylko raportu puste wartości w przypadkach, gdzie była rzeczywiście ustawiona, na przykład za pomocą kodu lub stylu. Każdy przepływ wskaźnik myszy nad [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] aplikacji zgłasza <xref:System.Windows.UIElement.QueryCursor> zdarzeń. Bąbelków zdarzeń, a każdy element wzdłuż trasy ma możliwość obsługi zdarzenia i ustawić wartość kursora za pośrednictwem argumentów tego zdarzenia. Jest to mechanizm, który tworzy wizualnie jawnego kursor znajduje się w większości przypadków. Jeśli <xref:System.Windows.UIElement.QueryCursor> metoda obsługi zwraca wynik kursora, a następnie fakt, że zdarzenie jest obsługiwane i została zmieniona wartość w argumentach mają pierwszeństwo przed wartością <xref:System.Windows.FrameworkElement.Cursor%2A> właściwości na dowolnym poziomie, chyba że <xref:System.Windows.FrameworkElement.ForceCursor%2A> jest ustawiona.  
  
 Jeśli nie są tworzone niestandardowe kursora, zwykle ustawić tę właściwość na wartość właściwości statycznej <xref:System.Windows.Input.Cursors> klasy. Ustawienie <xref:System.Windows.FrameworkElement.Cursor%2A> w kodzie wymaga jednej z następujących czynności:  
  
-   Wywołaj <xref:System.Windows.Input.Cursor> konstruktora, aby uzyskać <xref:System.Windows.Input.Cursor> wystąpienia. Podpisy obu <xref:System.Windows.Input.Cursor> Konstruktor Użyj strumienie lub pliki w oczekiwaniu, który tworzysz <xref:System.Windows.Input.Cursor> obiektu dla niestandardowych kursora.  
  
-   Użyj <xref:System.Windows.Input.CursorConverter> klasy i jego <xref:System.Windows.Input.CursorConverter.ConvertFrom%2A> metodę, aby określić kursora przez <xref:System.Windows.Input.CursorType>, lub ciąg, który może być <xref:System.Windows.Input.CursorType>i rzutowane na powrót do <xref:System.Windows.Input.Cursor>.  
  
 Ustawienie <xref:System.Windows.Input.Cursor> niestandardowej wartości nie jest włączone w częściowej relacji zaufania. Aby uzyskać więcej informacji na temat niestandardowych kursorów, zobacz [przegląd danych wejściowych](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.CursorProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak ustawić celowo grafiki kursora.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.Cursor" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kontekst danych dla elementu, gdy uczestniczy w powiązaniu danych.</summary>
        <value>Obiekt do użycia jako kontekstu danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Kontekst danych* pojęcie, która umożliwia elementom dziedziczenie informacji z ich źródła danych, która jest używana do powiązania, a także innych charakterystyk powiązania, takich jak ścieżka elementów nadrzędnych.  
  
 Kontekst danych można ustawić bezpośrednio do obiektu .NET z powiązaniami oceny właściwości tego obiektu. Alternatywnie, można ustawić kontekstu danych <xref:System.Windows.Data.DataSourceProvider> obiektu.  
  
 Ta właściwość zależności dziedziczy wartości właściwości. Jeśli są elementami podrzędnymi bez innych wartości <xref:System.Windows.FrameworkElement.DataContext%2A> ustanowione przez wartości lokalnych lub style, a następnie system właściwość zostanie ustawiony na wartość <xref:System.Windows.FrameworkElement.DataContext%2A> tę wartość przypisaną wartością najbliższym elemencie nadrzędnym.  
  
 Alternatywnie można użyć jednej z następujących właściwości <xref:System.Windows.Data.Binding> klasy, aby określić źródło wiążące jawnie:
  
    - <xref:System.Windows.Data.Binding.ElementName%2A>.
    - <xref:System.Windows.Data.Binding.Source%2A>.
    - <xref:System.Windows.Data.Binding.RelativeSource%2A>. 
  
  Aby uzyskać więcej informacji, zobacz [porady: Określanie powiązania źródła](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).  
  
 W XAML <xref:System.Windows.FrameworkElement.DataContext%2A> najczęściej jest ustawiony jako <xref:System.Windows.Data.Binding> deklaracji. Można użyć składni elementu właściwości lub Składnia atrybutu. Składnia atrybutu jest wyświetlana w przykładzie pokazanym na tej stronie. Można również użyć kodu można ustawić <xref:System.Windows.FrameworkElement.DataContext%2A>.  
  
 <xref:System.Windows.FrameworkElement.DataContext%2A> jest właściwości możliwej do wiązania, aby ułatwić scenariusze, w którym jednym kontekście może być powiązane do innego. Jednak jeśli powiązana z <xref:System.Windows.FrameworkElement.DataContext%2A>, uważaj nie utworzyć powiązanie cykliczne odwołania (nie tworzy wiązania <xref:System.Windows.FrameworkElement.DataContext%2A> do samego siebie, co można zrobić ze względu na charakter dziedziczenie wartości właściwości z <xref:System.Windows.FrameworkElement.DataContext%2A> właściwości).  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *dataContextObject*  
 Bezpośrednio osadzonego obiektu, który służy jako kontekst danych dla powiązań w elemencie nadrzędnym. Zazwyczaj ten obiekt jest <xref:System.Windows.Data.Binding> lub inne <xref:System.Windows.Data.BindingBase> klasy pochodnej. Alternatywnie nieprzetworzone dane dowolnego typu obiektu przeznaczony dla powiązania mogą być umieszczane w tym miejscu przy użyciu rzeczywistego powiązania zdefiniowane w dalszej części.  
  
 *bindingUsage*  
 Użycie powiązania, który ocenia do kontekstu odpowiednie dane. Aby uzyskać więcej informacji, zobacz [— rozszerzenie znaczników powiązania](~/docs/framework/wpf/advanced/binding-markup-extension.md).  
  
 *resourceExtension*  
 Jedną z następujących: [ `StaticResource` ](~/docs/framework/wpf/advanced/staticresource-markup-extension.md) lub [ `DynamicResource` ](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md). Użycie tych jest używana przy odwoływaniu się do danych pierwotnych definiowana jako obiekt w zasobach. Zobacz [zasoby XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *contextResourceKey*  
 Identyfikator klucza dla obiektu żądanego z poziomu <xref:System.Windows.ResourceDictionary>.  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.DataContextProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Poniższy przykład ilustruje, jak działa kontekstu danych w powiązaniu i zawiera informacje, które definiują konkretne wartości właściwości powiązanej.  
  
 [!code-xaml[MasterDetail#DataContextProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty)]  
[!code-xaml[MasterDetail#DataContextProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty2)]  
[!code-xaml[MasterDetail#DataContextProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie kontekstu danych dla tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Opis kontekstów danych i powiązanie danych można znaleźć [Data Binding Overview](~/docs/framework/wpf/data/data-binding-overview.md).  
  
> [!IMPORTANT]
>  Gdy <xref:System.Windows.FrameworkElement.DataContext%2A> zmian elementu potencjalnie dotyczą wszystkich właściwości powiązanych z danymi w tym elemencie. Dotyczy to żadnych elementów, które są elementy podrzędne bieżącego elementu w drzewie logicznym, które dziedziczą kontekst danych, oraz bieżącego elementu. Takie istniejących powiązań ponownie należy interpretować nowy <xref:System.Windows.FrameworkElement.DataContext%2A> i spowoduje to ponowne ocenienie wyników powiązania. Aparat powiązań danych nie jest jednoznaczny o kolejność tych reevaluations, względem gromadzenia <xref:System.Windows.FrameworkElement.DataContextChanged> zdarzeń. Reevaluations może wystąpić przed wydarzeniem, po wystąpieniu zdarzenia lub w dowolnej mieszanki.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.DataContext" />
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.DataContext" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia klucz do użycia gdy stylów motywu są używane lub zdefiniowane k odkazu stylu dla tego formantu.</summary>
        <value>Klucz stylu. Działała prawidłowo, jako część wyszukiwania style motyw, to jest oczekiwaną wartością <see cref="T:System.Type" /> kontrolki są różne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zazwyczaj nie ustawiono za pomocą dowolnego z jego metod dostępu do właściwości bezpośrednich. Zamiast tego należy zastąpić metadane specyficzne dla typu ta właściwość zależności za każdym razem, gdy użytkownik utworzy nowy <xref:System.Windows.FrameworkElement> klasy pochodnej. Po utworzeniu klasy pochodnej kontrolki, wywołaj <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> metoda względem <xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty> identyfikator w konstruktorze statycznym formantu pochodne klasy (lub odpowiednik klasy inicjowania).  
  
 Formant zazwyczaj domyślnej wartości tej właściwości, aby mieć swój własny typ, ale w niektórych przypadkach można również użyć typu podstawowego, dla której istnieje styl słowników motywu. Jest to tylko praktyczne szablony kontroli kontrolki podstawowej całkowicie zdefiniować wizualnej reprezentacji pochodnej kontrolki, a wszelkie dodatkowe elementy członkowskie udostępnianie typów pochodnych nie wymagają dodatkowych elementów jako części szablonu kontrolki.  
  
 Jeśli chcesz, elementu lub formantu, aby celowo nie używać stylów motywu, należy ustawić <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> właściwość `true`.  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie przesłonięcia metadanych właściwości zależności omówione w uwagi. Ten kod definiuje klasę formantu niestandardowego `NumericUpDown` przeznaczony do użycia z zestawu biblioteki dedykowanej kontroli. Przedstawiono Konstruktor statyczny odwołuje się do niektórych funkcji inicjowania prywatnych, rejestruje obsługi klasy (inny typowy scenariusz podklasy kontrolki; zobacz [oznaczanie zdarzeń trasowanych jako Handled oraz obsługa klasy](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)) i na koniec zastępuje <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> metadane zależności właściwości na `NumericUpDown` klasy. <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> zawsze zwraca swój własny typ jako klucz przeznaczone jest do Konwencja, używanym przez system style motyw do wyszukania stylu dla niektórych dowolnego formantu inaczej niż stylem. Pełny przykład definiuje również styl motyw rzeczywistego formantu, który odwołuje się do tego klucza; zobacz [NumericUpDown kontrolkę niestandardową przy użyciu przykładowych Obsługa automatyzacji interfejsu użytkownika i motyw](http://go.microsoft.com/fwlink/?LinkID=160025).  
  
 [!code-csharp[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/NumericUpDown2.cs)]
 [!code-vb[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/numericupdown2.vb)]  

  Pełnego kodu źródłowego w tym przykładzie jest dostępny w witrynie GitHub dla obu [C#](https://github.com/dotnet/samples/tree/master/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary) i [języka Visual Basic](https://github.com/dotnet/samples/tree/master/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary).

 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
        <related type="ExternalDocumentation" href="http://go.microsoft.com/fwlink/?LinkID=160025">Formant NumericUpDown niestandardowe z motywu i przykładowe Obsługa automatyzacji interfejsu użytkownika</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.DefaultStyleKey" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkElement.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, o ukończeniu procesu inicjowania dla elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.FrameworkElement.BeginInit%2A> był wcześniej nazywany programem, base zgłosi implementacji <xref:System.Windows.FrameworkElement.Initialized> zdarzeń. W przeciwnym razie, jeśli <xref:System.Windows.FrameworkElement.BeginInit%2A> nie została wywołana lub nie można ustalić, czy <xref:System.Windows.FrameworkElement.BeginInit%2A> została wywołana <xref:System.Windows.FrameworkElement.Initialized> nie jest inicjowane i zamiast tego zostanie zgłoszony wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.FrameworkElement.EndInit" /> Wywołano bez <see cref="M:System.Windows.FrameworkElement.BeginInit" /> mające wcześniej nazywane w elemencie.</exception>
        <block subset="none" type="overrides">
          <para>Zaimplementuj tę metodę, aby zapewnić obsługę specjalne, który ma się zdarzyć, gdy Twoje element jest inicjowany podczas element proces ładowania.  
  
Twoja implementacja powinny wywoływać implementację podstawową, ponieważ implementacja base (ustawienie domyślne) ustawia niektóre wewnętrznego flagi do śledzenia inicjowania.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa żądanego elementu.</param>
        <summary>Wyszukuje element, który ma nazwę podany identyfikator.</summary>
        <returns>Żądany element. Może to być <see langword="null" /> Jeśli nie została odnaleziona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli element ma elementy podrzędne, te elementy podrzędne są wszystkie cyklicznie wyszukiwanych dla żądanego o nazwie elementu.  
  
 <xref:System.Windows.FrameworkElement.FindName%2A> działa w namescope bieżącego elementu. Aby uzyskać więcej informacji, zobacz [zakresy WPF XAML nazw](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
        <related type="Article" href="http://msdn.microsoft.com/library/b7e61222-e8cf-48d2-acd0-6df3b7685d48">x: Name — atrybut</related>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Identyfikator klucza dla żądanego zasobu.</param>
        <summary>Wyszukuje zasób z określonym kluczem i zgłasza wyjątek, jeśli nie odnaleziono żądanego zasobu.</summary>
        <returns>Żądany zasób. Jeśli żaden zasób z podany klucz został znaleziony, jest zgłaszany wyjątek. <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> Również może zostać zwrócona wartość w przypadku wyjątku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Jeśli chcesz wywołać tę metodę dla klucza, którego nie można odnaleźć jest zgłaszany wyjątek. Jeśli nie chcesz obsługiwać wyjątki, które wynikają z wywołaniem <xref:System.Windows.FrameworkElement.FindResource%2A>, wywołaj <xref:System.Windows.FrameworkElement.TryFindResource%2A> zamiast tego. <xref:System.Windows.FrameworkElement.TryFindResource%2A> Zwraca `null` kiedy nie można odnaleźć żądanego zasobu i nie zgłasza wyjątku.  
  
 Jeśli zasób nie zostanie znaleziony w elemencie wywołującym, elementu nadrzędnego w drzewie logicznym jest wyszukiwanych dalej, a następnie aplikacji, a następnie motywy, a na końcu zasobów systemowych. Ta metoda wyszukiwania jest identyczna jak drzewa są przeszukiwane, jeśli zasób prosili odwołaniem zasobu dynamicznego w znacznikach. Aby uzyskać więcej informacji na temat wyszukiwania zasobów, zobacz [zasoby XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 Zwykle, możesz od razu rzutowania <xref:System.Windows.FrameworkElement.FindResource%2A> powrót wartość do typu właściwości, ustawienie o wartości zwracanego zasobów.  
  
 Klucze zasobu niekoniecznie ciągów. Na przykład style dla formantów na poziomie motyw celowo określonemu <xref:System.Type> formantu i style aplikacji lub stron dla formantów zazwyczaj używają tego klucza Konwencji. Aby uzyskać więcej informacji, zobacz [Tworzenie szablonów i stylów](~/docs/framework/wpf/controls/styling-and-templating.md) lub [zasoby XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
   
  
## Examples  
 Poniższy przykład pobiera nazwany zasób i rzutuje je na odpowiedni typ w celu wypełnienia właściwości.  
  
 [!code-csharp[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page3.xaml.cs#resourceproceduralget)]
 [!code-vb[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page3.xaml.vb#resourceproceduralget)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">
          <paramref name="resourceKey" /> Nie można odnaleźć i program obsługi zdarzeń nie istnieje dla <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /> zdarzeń.  
  
—lub— 
 <paramref name="resourceKey" /> Nie można odnaleźć i <see cref="P:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled" /> właściwość <see langword="false" /> w <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /> zdarzeń.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceKey" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FlowDirection">
      <MemberSignature Language="C#" Value="public System.Windows.FlowDirection FlowDirection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FlowDirection FlowDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FlowDirection" />
      <MemberSignature Language="VB.NET" Value="Public Property FlowDirection As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FlowDirection FlowDirection { System::Windows::FlowDirection get(); void set(System::Windows::FlowDirection value); };" />
      <MemberSignature Language="F#" Value="member this.FlowDirection : System.Windows.FlowDirection with get, set" Usage="System.Windows.FrameworkElement.FlowDirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia kierunek ten tekst i inne [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] elementy przepływu w ramach dowolnego elementu nadrzędnego, który kontroluje ich układ.</summary>
        <value>Kierunek ten tekst i inne [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] elementy przepływu w ramach jego elementu nadrzędnego jako wartość wyliczenia. Wartość domyślna to <see cref="F:System.Windows.FlowDirection.LeftToRight" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestawy użycia właściwości zależności <xref:System.Windows.FrameworkElement.FlowDirection%2A> w tym elemencie. Ze względu na przejęcie wartości właściwości, ustawienie <xref:System.Windows.FrameworkElement.FlowDirection%2A> potencjalnie można ustawić w elemencie <xref:System.Windows.FrameworkElement.FlowDirection%2A> na wszystkie elementy podrzędne, które nie ustawił <xref:System.Windows.FrameworkElement.FlowDirection%2A> lokalnie lub do innych środków, takich jak style.  
  
 Właściwość ta nie jest automatycznie ustawiona żadnych informacji o kulturze aplikacji w ramach, ponieważ element może zawierać zawartość, która nie ma zawsze z odpowiednimi zasadami kierunek przepływu ogólne, domniemane przez informacji o kulturze. Aby uzyskać więcej informacji na temat zagadnienia dotyczące globalizacji, zobacz [globalizacja dla WPF](~/docs/framework/wpf/advanced/globalization-for-wpf.md).  
  
 Właściwość ta nie ma zdefiniowanych [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] metody dostępu właściwości, aby działała jako właściwość zależności. Jednak jest również zarejestrowany jako dołączone, dzięki czemu może również działać jako dołączona właściwość. Dołączone rejestracji jest głównie pozwoli dziedziczenie wartości właściwości jest obsługiwany, ale właściwość również może służyć jako wartość true, właściwość dołączone. Dołączona właściwość jest tylko istotne, jeśli obiekt chcesz ustawić kierunek przepływu na ma <xref:System.Windows.FrameworkElement> elementu nadrzędnego, który wykonuje układ stronę, sama nie jest <xref:System.Windows.FrameworkElement>i nie ma jeszcze bardziej bezpośrednio zdefiniowanych `FlowDirection` Właściwość. (Niektóre przepływu dokumentu klasy takie jak <xref:System.Windows.Documents.Block> i <xref:System.Windows.Documents.Inline> definiować własne `FlowDirection`, a ta właściwość można ustawić kierunek przepływu. Wartość właściwości jest odczytywany przez ostatecznej host zawartości bez konieczności użycia dołączona właściwość.)  
  
<a name="xamlAttributeUsage_FlowDirection"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
 \<*obiekt* **FlowDirection**= "<xref:System.Windows.FlowDirection>" / >  
  
<a name="xamlTextUsage_FlowDirection"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Można również ustawić tę właściwość w klasach, które nie są <xref:System.Windows.FrameworkElement> pochodnych klas, następujący [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] dołączone użycia właściwości:  
  
 `<` *obiekt* `FrameworkElement.` **FlowDirection**= "<xref:System.Windows.FlowDirection>`"/>`  
  
<a name="dependencyPropertyInfo_FlowDirection"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.FlowDirectionProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 Ta właściwość jest właściwością zależności i dołączoną właściwość; Zobacz uwagi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlowDirectionProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FlowDirectionProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FlowDirectionProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FlowDirectionProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FlowDirectionProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FlowDirectionProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia właściwość, która umożliwia dostosowanie wyglądu, efekty lub innych właściwości stylu, które będą miały zastosowanie do tego elementu po jego przechwyceniu fokus klawiatury.</summary>
        <value>Żądany styl można zastosować fokus. Wartość domyślna, ponieważ nie zadeklarowano właściwości zależności jest pusty statyczne <see cref="T:System.Windows.Style" />. Jednakże, efektywną wartość w czasie wykonywania jest często (ale nie zawsze) styl dostarczony przez dział pomocy technicznej motywie dla kontrolki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość ma wpływ na wygląd, ale nie raportuje <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> w metadanych. Jest to spowodowane zmianami wygląd jest oparte na zdarzeniach i nie mogą mieć zastosowanie przez cały czas i w związku z tym należy zwykle będą zgłaszać żadnych informacji wizualizacji i układów w metadanych.  
  
 Model visual zachowanie fokus do formantu powinny być zgodne z formantami. Najbardziej rozsądne sposób, aby wymusić spójność jest tylko zmienić styl wizualny fokusu, jeśli redagowania całego motywu. Ustawienie tej właściwości na poszczególnych kontrolek, stylów, a nie jako część motywu nie jest zamierzone użycie tej właściwości, ponieważ może dojść do mylące czynności użytkownika dotyczących fokus klawiatury. Sygnalizuje pomyślny przebieg operacji zachowanie specyficznej dla kontroli, które celowo nie jest spójny we motyw, możesz znacznie lepszym rozwiązaniem jest Użyj wyzwalaczy w stylach właściwości poszczególnych stanu danych wejściowych, takich jak <xref:System.Windows.UIElement.IsFocused%2A> lub <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>i aby to zrobić w sposób, który nie zawiera wizualnie kolidować z wszelkie istniejące styl wizualny fokusu. Aby uzyskać więcej informacji na temat projektowania zamiar <xref:System.Windows.FrameworkElement.FocusVisualStyle%2A> i alternatywne skupić się właściwości, zobacz [style dla fokusu w formantach i FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *resourceExtension*  
 Jedną z następujących:, lub. Zobacz [zasoby XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Klucz, który identyfikuje styl żądanej. Klucz, który odwołuje się do istniejącego zasobu w <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Składnia elementu właściwości jest technicznie możliwe, ale niezalecane. Zobacz [style i Szablony wbudowane](~/docs/framework/wpf/advanced/inline-styles-and-templates.md). Odwołanie do wiązania za pomocą lub <xref:System.Windows.Data.Binding> jest również możliwe, ale rzadko.  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.FocusVisualStyleProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.FocusVisualStyle" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy to <see cref="T:System.Windows.FrameworkElement" /> ma wymusić [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] do renderowania kursora w postaci zadeklarowanej przez <see cref="P:System.Windows.FrameworkElement.Cursor" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli prezentacji kursor znajduje się nad tym elementem jest zmuszony do użycia bieżący <see cref="P:System.Windows.FrameworkElement.Cursor" /> ustawienia kursora (w tym na wszystkie elementy podrzędne); w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta właściwość jest ustawiona na `true` spowoduje przesłonięcie preferencje kursora ustanowione przez elementy podrzędne. Spowoduje to więc ogólnie rzecz biorąc aplikacji [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] może być mylące dla użytkowników, szczególnie w przypadku, gdy próbujesz określić kursory elementów podrzędnych. Ustawienie <xref:System.Windows.FrameworkElement.ForceCursor%2A> jest bardziej odpowiednie w scenariuszach podklasy lub składania kontroli.  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ForceCursorProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład powoduje wartość kursora.  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.ForceCursor" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Element docelowy <see cref="T:System.Windows.DependencyProperty" /> można pobrać powiązania z.</param>
        <summary>Zwraca <see cref="T:System.Windows.Data.BindingExpression" /> reprezentujący powiązania dla określonej właściwości.</summary>
        <returns>A <see cref="T:System.Windows.Data.BindingExpression" /> Jeśli właściwość docelowa ma powiązanie aktywny; w przeciwnym razie zwraca <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sprawdzanie wartość zwracana przez `null` to technika, można użyć w celu ustalenia, czy właściwość ma powiązania usługi active.  
  
 Ta metoda jest w rzeczywistości po prostu wygodne otokę <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType> metody. <xref:System.Windows.FrameworkElement.GetBindingExpression%2A> przekazuje bieżącego wystąpienia i `dp` parametr <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Data.BindingOperations" />
      </Docs>
    </Member>
    <Member MemberName="GetFlowDirection">
      <MemberSignature Language="C#" Value="public static System.Windows.FlowDirection GetFlowDirection (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FlowDirection GetFlowDirection(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFlowDirection (element As DependencyObject) As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FlowDirection GetFlowDirection(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFlowDirection : System.Windows.DependencyObject -&gt; System.Windows.FlowDirection" Usage="System.Windows.FrameworkElement.GetFlowDirection element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Elementu do zwrócenia <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> dla.</param>
        <summary>Pobiera wartość <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> dołączonych właściwości dla określonego <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Kierunek żądanego przepływu jako wartość wyliczenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Głównym celem tej metody jest wspieranie składnia dołączoną właściwość <xref:System.Windows.FrameworkElement.FlowDirection%2A> właściwości, w związku z tym co podrzędnych elementów podana <xref:System.Windows.FrameworkElement> do określania kierunku przepływu dla rozmieszczenia w ramach jego elementu nadrzędnego. Aby uzyskać wartość na bieżącej <xref:System.Windows.FrameworkElement>, użyj bezpośrednio [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] dostępu <xref:System.Windows.FrameworkElement.FlowDirection%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="GetLayoutClip">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Geometry GetLayoutClip(valuetype System.Windows.Size layoutSlotSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetLayoutClip (layoutSlotSize As Size) As Geometry" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Geometry ^ GetLayoutClip(System::Windows::Size layoutSlotSize);" />
      <MemberSignature Language="F#" Value="override this.GetLayoutClip : System.Windows.Size -&gt; System.Windows.Media.Geometry" Usage="frameworkElement.GetLayoutClip layoutSlotSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layoutSlotSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="layoutSlotSize">Rozmiar część elementu, który wykonuje wizualnej prezentacji.</param>
        <summary>Zwraca geometrii maski wycinka. Maska ma zastosowanie, gdy system układu próbuje Rozmieść element, który jest większy niż dostępny ekran.</summary>
        <returns>Geometria wycinka.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Marginesy zostanie odjęta od `layoutSlotSize` jako część zachowanie systemu układu.  
  
 Zwracane odwołanie o wartości null wskazuje, że nastąpi nie przycinania. Zwraca zawsze wartość domyślną implementację `null` podczas <xref:System.Windows.UIElement.ClipToBounds%2A> jest `false`. Ta metoda zastępuje <xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=nameWithType>. <xref:System.Windows.FrameworkElement> Implementacja używa <xref:System.Windows.FrameworkElement.MaxHeight%2A> i <xref:System.Windows.FrameworkElement.MaxWidth%2A> w obliczeniach. Kilka podklasy <xref:System.Windows.FrameworkElement> ponownie należy przesłonić tę metodę. <xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=nameWithType>, przesłonięć zawsze zwrócenia `null` ponieważ moduły definiowania układu są często celowo poza granicami zwykłej. <xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=nameWithType> i <xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=nameWithType> zwracają `null` Jeśli <xref:System.Windows.UIElement.ClipToBounds%2A> jest `false`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zwraca zawsze wartość domyślną implementację <see langword="null" /> podczas <see cref="P:System.Windows.UIElement.ClipToBounds" /> jest <see langword="false" />. Zastąpienia zwykle powinny zachowania tej, mimo że istnieją wyjątki, w zależności od tego, czy relacja i celem w klasie pochodnej i jego logikę układu, w przeciwieństwie do klasy bazowej.</para>
        </block>
        <altmember cref="P:System.Windows.UIElement.Clip" />
        <altmember cref="P:System.Windows.UIElement.ClipToBounds" />
      </Docs>
    </Member>
    <Member MemberName="GetTemplateChild">
      <MemberSignature Language="C#" Value="protected internal System.Windows.DependencyObject GetTemplateChild (string childName);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Windows.DependencyObject GetTemplateChild(string childName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetTemplateChild (childName As String) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Windows::DependencyObject ^ GetTemplateChild(System::String ^ childName);" />
      <MemberSignature Language="F#" Value="member this.GetTemplateChild : string -&gt; System.Windows.DependencyObject" Usage="frameworkElement.GetTemplateChild childName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="childName">Nazwa podrzędnej, aby znaleźć.</param>
        <summary>Zwraca element nazwany w drzewie wizualnym skonkretyzowany <see cref="T:System.Windows.Controls.ControlTemplate" />.</summary>
        <returns>Żądany element. Może być <see langword="null" /> Jeśli żądana nazwa nie zawiera żadnego elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Szablony w [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] mają namescope niezależna. Jest to spowodowane szablony są używane ponownie i dowolną nazwę, zdefiniowane w szablonie nie może pozostać unikatowe, jeśli wiele wystąpień kontroli każdego wystąpienia szablonu. Wywołaj <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> metody, aby przywrócić odwołania do obiektów, które pochodzą z tego szablonu, po zostanie uruchomiony. Nie można użyć <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> metodę, aby znaleźć elementy za pomocą szablonów, ponieważ <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> działa w bardziej ogólnej zakresu i nie ma połączenia między <xref:System.Windows.Controls.ControlTemplate> klasy wraz z wystąpień szablonu, po zastosowaniu.  
  
 <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> dostarcza taką samą funkcję jak ta metoda. <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> publiczne, a nie jest chroniona i używa poprawna nazwa zakresu kwestie dotyczące zezwalała na dostęp do szablonu w ramach elementu i Znajdź o nazwie elementów w obrębie tej. Użyj <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> kiedy musisz pobrać element poza kontrolki nadrzędnej.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkTemplate.FindName(System.String,System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca alternatywny nadrzędny logicznych dla tego elementu, jeśli nie określono visual elementu nadrzędnego.</summary>
        <returns>Zwraca coś innego niż <see langword="null" /> zawsze, gdy WPF poziomie struktury implementacja tej metody ma połączenie nadrzędne innym niż wizualny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=nameWithType>. Wartość domyślna <xref:System.Windows.FrameworkElement> implementacja zwraca oczekiwanego pojedynczego visual elementem nadrzędnym. jest to ten sam wynik jako wprowadzenie <xref:System.Windows.FrameworkElement.Parent%2A> wartość. Implementacje Klasa pochodna może zwrócić alternatywny nadrzędny relacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberSignature Language="F#" Value="override this.GetVisualChild : int -&gt; System.Windows.Media.Visual" Usage="frameworkElement.GetVisualChild index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu podrzędnego żądanego elementu w kolekcji.</param>
        <summary>Zastępuje <see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" />i zwraca kolekcję elementów podrzędnych elementu podrzędnego wskazywanego przez określony indeks.</summary>
        <returns>Element podrzędny żądanej. To nie powinna zwracać <see langword="null" />; Jeśli podany indeks jest poza zakres, zgłaszany jest wyjątek.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W <xref:System.Windows.FrameworkElement> implementacji, jedyną prawidłową indeksu jest równa zero. Model zawartości dla <xref:System.Windows.FrameworkElement.GetVisualChild%2A> obsługuje elementy podrzędne zero lub jeden, nie jest kolekcją.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak niestandardowy moduł definiowania układu kodu używa wartości zdeklarowane <xref:System.Windows.Media.VisualCollection> przechowujący wiele podrzędnych visual. Te wartości są raportowane za pośrednictwem zastąpień <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> i <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ta implementacja jest prawidłowy tylko dla elementów, które nie mają żadnej bardziej opisowe kolekcji elementów podrzędnych visual. Elementów, które mają takie kolekcji należy przesłonić tę metodę i mapowania indeks równoważne indeksu w kolekcji elementów podrzędnych, która jest obsługiwana przez ten element. Indeks w zakresie od 0 do <see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /> (minus jeden) powinien zwrócić prawidłowego elementu; inne indeks powinien zgłosić wyjątek spoza zakresu. Przykładem typu elementu, który obsługuje kolekcji podrzędnej i zastępuje <see cref="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" /> do zwrócenia więcej niż jeden element podrzędny możliwe jest <see cref="T:System.Windows.Controls.Panel" />.  
  
Domyślna implementacja w <see cref="T:System.Windows.FrameworkElement" /> zakłada tylko jeden element podrzędny visual. Dowolna wartość przekazana <paramref name="index" /> niż zero powoduje, że wyjątek, który zostanie wygenerowany. Zastąp typowymi elementami, takie jak dekoratory, moduły definiowania układu lub elementów przy użyciu wyspecjalizowanego renderowania <see cref="T:System.Windows.FrameworkElement" /> implementacji (wykonanie pośrednich klas podstawowych). Niektóre implementacje nadal wymuszają jeden element podrzędny visual, natomiast inne umożliwiają kolekcji.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public double Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Height" />
      <MemberSignature Language="VB.NET" Value="Public Property Height As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Height { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Height : double with get, set" Usage="System.Windows.FrameworkElement.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia sugerowany wysokość elementu.</summary>
        <value>Wysokość elementu w [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Wartość domyślna to <see cref="F:System.Double.NaN" />. Ta wartość musi być równa lub większa niż 0,0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Height%2A> jest jednym z trzech właściwości z możliwością zapisu na <xref:System.Windows.FrameworkElement> określające wysokość informacji. Istnieją dwie <xref:System.Windows.FrameworkElement.MinHeight%2A> i <xref:System.Windows.FrameworkElement.MaxHeight%2A>. Jeśli występuje konflikt między te wartości, kolejność aplikacji do określenia wysokości rzeczywisty jest to, że pierwszy <xref:System.Windows.FrameworkElement.MinHeight%2A> musi zostać wdrożona, następnie <xref:System.Windows.FrameworkElement.MaxHeight%2A>, a na koniec, jeśli znajduje się w granicach, <xref:System.Windows.FrameworkElement.Height%2A>.  
  
 Jeśli ten element jest elementem podrzędnym w ramach innego elementu, następnie ustawienie tej właściwości na wartość jest naprawdę sugerowana wartość. System układu, a także logiki określonego układu elementu nadrzędnego będzie używać wartości jako nonbinding dane wejściowe w procesie układu. W praktyce <xref:System.Windows.FrameworkElement> prawie zawsze jest elementem podrzędnym coś innego; nawet wtedy, gdy ustawisz <xref:System.Windows.FrameworkElement.Height%2A> na <xref:System.Windows.Window>. (Aby uzyskać <xref:System.Windows.Window>, czy wartość jest używana, gdy odpowiedni model aplikacji ustanawia założenia podstawowe renderowania, tworzonych Hwnd, które hostuje aplikację.)  
  
 Ponadto do akceptowalnego <xref:System.Double> wartości tej właściwości można też <xref:System.Double.NaN?displayProperty=nameWithType>. Jest to, jak określić automatycznego ustalania rozmiaru zachowanie w kodzie. W [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] wartość na ciąg "Auto" (jest uwzględniana wielkość liter) umożliwia automatyczne ustalanie rozmiaru zachowanie. Automatyczne ustalanie rozmiaru zachowanie oznacza, że elementu wypełni dostępne jej wysokość. Należy jednak pamiętać, że określonych kontrolek często podać wartości domyślnych za pomocą ich style motyw domyślny, które spowoduje wyłączenie automatycznego ustalania rozmiaru zachowanie, chyba że jest to szczególnie w przypadku ponownego włączenia.  
  
 Zwracana wartość tej właściwości jest zawsze taki sam jak każdą wartość, która została ustawiona do niego. Z drugiej strony, wartość <xref:System.Windows.FrameworkElement.ActualHeight%2A> mogą się różnić. Taka sytuacja może wystąpić albo statycznie ponieważ układ odrzucone sugerowany rozmiar jakiegoś powodu lub chwilowo. System układu działa asynchronicznie względem zestawu system właściwości <xref:System.Windows.FrameworkElement.Height%2A> i może nie zostały przetworzone oznacza określonego rozmiaru jeszcze zmiany właściwości.  
  
 Ograniczenia dotyczące wartości na <xref:System.Double> wartości są wymuszane przez <xref:System.Windows.ValidateValueCallback> mechanizm. Jeśli spróbujesz ustawić wartość jest nieprawidłowa, zwracany jest wyjątek czasu wykonywania.  
  
 Oprócz sprawdzania poprawności, to niedeterministyczna wartość górna granica <xref:System.Windows.FrameworkElement.Height%2A> , jest wymuszana przez system układu (jest to bardzo dużą liczbą większe niż <xref:System.Single.MaxValue?displayProperty=nameWithType> ale jest mniejszy niż <xref:System.Double.MaxValue?displayProperty=nameWithType>). Jeśli przekroczysz to powiązany element nie będzie renderowana i jest zgłaszany żaden wyjątek. Nie należy ustawiać <xref:System.Windows.FrameworkElement.Height%2A> na wartość, która jest znacznie większa niż maksymalny rozmiar dowolnego wyświetlacza wizualnego możliwe, lub może być dłuższe niż to niedeterministyczna górną granicę.  
  
<a name="xamlAttributeUsage_Height"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object Height="double"/>  
- or -  
<object Height="qualifiedDouble"/>  
- or -  
<object Height="Auto"/>  
```  
  
<a name="xamlValues_Height"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *double*  
 <xref:System.Double>  
  
 Ciąg reprezentujący <xref:System.Double> wartość równą lub większą niż 0,0. Górna granica informacji, zobacz uwagi. Ta wartość jest interpretowana jako [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] miary. Ciągi nie musi jawnie zawierać separatorów dziesiętnych. Na przykład wartość `1` jest dopuszczalna.  
  
 *qualifiedDouble*  
 A *double* wartość zgodnie z opisem powyżej, a następnie za pomocą jednej z następujących ciągów jednostki w deklaracji: `px`, `in`, `cm`, `pt`.  
  
 `px` (domyślnie) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm` centymetrów; 1cm==(96/2.54) piks.  
  
 `pt` jest punktów. 1pt==(96/72) piks.  
  
 **Auto**  
 Włącza zachowanie automatyczne określanie rozmiaru. Zobacz uwagi.  
  
<a name="dependencyPropertyInfo_Height"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.HeightProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.ActualHeight" />
      </Docs>
    </Member>
    <Member MemberName="HeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.HeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.Height" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.HorizontalAlignment HorizontalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.HorizontalAlignment HorizontalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalAlignment As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::HorizontalAlignment HorizontalAlignment { System::Windows::HorizontalAlignment get(); void set(System::Windows::HorizontalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.HorizontalAlignment : System.Windows.HorizontalAlignment with get, set" Usage="System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia charakterystyki wyrównania poziomego stosowane do tego elementu, gdy wchodzi on w ramach elementu nadrzędnego, takiego jak panel lub kontrolka elementów.</summary>
        <value>Ustawienie wyrównania w poziomie, jako wartość wyliczenia. Wartość domyślna to <see cref="F:System.Windows.HorizontalAlignment.Stretch" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.FrameworkElement.Height%2A> i <xref:System.Windows.FrameworkElement.Width%2A> właściwości są jawnie ustawione na element, pomiarów zająć wyższe anulują podczas układ i spowoduje anulowanie skutki typowe ustawienia <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> do <xref:System.Windows.HorizontalAlignment.Stretch>.  
  
 <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> jest [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] metody dostępu właściwości w celu przedstawienia w rzeczywistości właściwość zależności. Ta właściwość określonej zależności dość często ma wartość jawnego "domyślna" ustawione inaczej w elementy będące podklasami, szczególnie kontrolki. Zwykle dzieje się to jeden z dwóch sposobów: właściwość zależności jest ponownie zarejestrowane, podklasą określonej, ale innych metadanych do ustawiania wartości domyślnych; lub domyślnego stylu stosowane, która ustawia tę wartość właściwości zależności inaczej. Na przykład jawnego "domyślną" <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> dla <xref:System.Windows.Controls.Label> formant będzie <xref:System.Windows.HorizontalAlignment.Left>, nawet jeśli <xref:System.Windows.Controls.Label> dziedziczy <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> bezpośrednio z <xref:System.Windows.FrameworkElement>. To dlatego ta wartość została zresetowana w ramach domyślnego stylu <xref:System.Windows.Controls.Label>, w ramach szablonu kontrolki stylu.  
  
 <xref:System.Windows.Controls.Canvas> nie używa <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> podczas redagowania układu, ponieważ <xref:System.Windows.Controls.Canvas> opiera się na pozycjonowanie absolutne.  
  
 W przypadku dziedziczonych przez <xref:System.Windows.Controls.Label> lub klasy, pochodne <xref:System.Windows.Controls.Label> redefiniuje wartość domyślna tej właściwości zależności za <xref:System.Windows.HorizontalAlignment.Left>.  
  
<a name="dependencyPropertyInfo_HorizontalAlignment"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.HorizontalAlignmentProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HorizontalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HorizontalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HorizontalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HorizontalAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HorizontalAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.HorizontalAlignment" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InheritanceBehavior">
      <MemberSignature Language="C#" Value="protected internal System.Windows.InheritanceBehavior InheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.InheritanceBehavior InheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property InheritanceBehavior As InheritanceBehavior" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::InheritanceBehavior InheritanceBehavior { System::Windows::InheritanceBehavior get(); void set(System::Windows::InheritanceBehavior value); };" />
      <MemberSignature Language="F#" Value="member this.InheritanceBehavior : System.Windows.InheritanceBehavior with get, set" Usage="System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.InheritanceBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ograniczenia zakresu dziedziczenie wartości właściwości, wyszukiwanie klucza zasobu i RelativeSource FindAncestor wyszukiwania.</summary>
        <value>Wartość wyliczenia. Wartość domyślna to <see cref="F:System.Windows.InheritanceBehavior.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określone granice w elemencie drzewa zestaw <xref:System.Windows.FrameworkElement.InheritanceBehavior%2A> celowo ograniczyć zakres zachowanie dziedziczenia, w celu wyszukiwania zasobów Wymuś Sprawdzanie zasobów aplikacji lub uniemożliwić wyszukiwania RelativeSource FindAncestor zapytań bieżącego elementu lub więcej. Wyszukiwanie RelativeSource FindAncestor występuje po powiązaniu używa <xref:System.Windows.Data.RelativeSource> zawierający jego <xref:System.Windows.Data.RelativeSource.Mode%2A> właściwością <xref:System.Windows.Data.RelativeSourceMode.FindAncestor?displayProperty=nameWithType> wartość.  
  
 Jeśli chcesz, aby swojej otrzymanej klasy, aby ustawić tę właściwość, należy to zrobić w konstruktorze statycznym lub w innych procedury inicjowania.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Frame" />
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy to <see cref="T:System.Windows.FrameworkElement" /> został zainicjowany. To zdarzenie pokrywa się to z przypadkami, w którym wartość <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> właściwość zmienia się z <see langword="false" /> (lub undefined) na <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest wywoływane zawsze, gdy <xref:System.Windows.FrameworkElement.EndInit%2A> lub <xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A> metody są wywoływane. Wywołania do jednej z metod może pochodzić od kodu aplikacji lub za pomocą [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] zachowanie procesora podczas [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] przetwarzania strony.  
  
 Czy istnieje możliwość obsługi <xref:System.Windows.FrameworkElement.Loaded> lub <xref:System.Windows.FrameworkElement.Initialized> zależy od wymagań. Nie należy do odczytu właściwości elementu Zamierzasz zresetować właściwości, a nie ma potrzeby żadnych informacji o układzie <xref:System.Windows.FrameworkElement.Initialized> mogą być lepiej zdarzeń wykonywane działania. Jeśli potrzebujesz wszystkich właściwości elementu, który ma być dostępny, i będzie ustawienie właściwości, które mogą zresetować układ, <xref:System.Windows.FrameworkElement.Loaded> mogą być lepiej zdarzeń wykonywane działania. Należy zachować ostrożność z współużytkowania wątkowości, jeśli programu obsługi resetuje wszystkie właściwości, które będą interpretowane przez system układu oznacza, że wymagane jest nowe przekazanie układu. (Może być konieczne Sprawdź <xref:System.Windows.FrameworkPropertyMetadata> przekazania wartości dla właściwości, jeśli wiesz właściwości, które mogą wymagać nowego układu, w przypadku ich zmiany.)  
  
 Aby uzyskać więcej informacji na temat sekwencji zdarzenia obiektu dla <xref:System.Windows.FrameworkElement>, a także dla kilku powiązanych aplikacji i klasy elementów, zobacz [zdarzenia okresu istnienia obiektu](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kontekst dla danych wejściowych używanych przez to <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <value>Zakresu wejściowego, który modyfikuje interpretacji danych wejściowych z alternatywnych metod danych wejściowych. Wartość domyślna to <see langword="null" /> (które powoduje domyślna obsługa poleceń).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zależności dziedziczy wartości właściwości. Jeśli są elementami podrzędnymi bez innych wartości <xref:System.Windows.FrameworkElement.InputScope%2A> ustanowione przez wartości lokalnych lub style, a następnie system właściwość zostanie ustawiony na wartość <xref:System.Windows.FrameworkElement.InputScope%2A> wartość najbliższej element nadrzędny o tej wartości przypisane.  
  
 Mimo że [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] użycie składni znajduje się na liście i składniowo jest dozwolony, ustawienie tej właściwości [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] nie jest powszechne.  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.InputScopeProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.InputScope" />
        <altmember cref="T:System.Windows.IInputElement" />
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.InputScope" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten element został zainicjowany, albo w trakcie przetwarzania przez [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] procesora, albo przez jawne zdefiniowanie jego <see cref="M:System.Windows.FrameworkElement.EndInit" /> metodę o nazwie.</summary>
        <value>
          <see langword="true" /> Jeśli element jest inicjowany na wyżej wymienionych [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] przetwarzania lub metoda wywołania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość może być również `true` Jeśli ten element został przeniesiony w drzewie logicznym taki sposób, że ma nowy element nadrzędny i w związku z tym staje się ponownie ponownie załadowany.  
  
 Ta właściwość jest przydatna, jeśli również używają <xref:System.Windows.FrameworkElement.BeginInit%2A> i <xref:System.Windows.FrameworkElement.EndInit%2A>. Elementy w drzewie logicznym, który jest ładowany przez [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] zapewni procesora do zainicjowania. Elementy w drzewie logicznym nie są inicjowane po <xref:System.Windows.FrameworkElement.EndInit%2A> jest wywoływana. W przypadku braku dowolnego określonego obsługi <xref:System.Windows.FrameworkElement.BeginInit%2A> i <xref:System.Windows.FrameworkElement.EndInit%2A>, dzieje się tak szybko, jak Konstruktor zwraca wynik zainicjowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten element został załadowany do prezentacji.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący element jest dołączony do drzewa elementów; <see langword="false" /> Jeśli element nigdy nie został dołączony do drzewa załadowanych elementów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Z nowo skonstruowany <xref:System.Windows.FrameworkElement>, rozpoczyna się tę właściwość `false`, a pozostaje `true` po jego ustawieniu `true`nawet wtedy, gdy element jest później usunięte z połączonych drzewo logiczne przez kod. `true` stan jest ustawiony przez logikę ogólne prezentacji, gdy elementy są ładowane do aparatu prezentacji.  
  
 Zazwyczaj załadowanych elementów są renderowanych, ale nie wszystkich <xref:System.Windows.FrameworkElement> klasy pochodnej mają prezentacji i inne właściwości, takie jak <xref:System.Windows.UIElement.Visibility%2A> mogą mieć wpływ na prezentacji.  
  
   
  
## Examples  
 Poniższy przykład implementuje dwóch metod obsługi: jeden obsługuje <xref:System.Windows.FrameworkElement.Loaded> zdarzeń elementu głównego, dzięki czemu jest pewne, czy element główny strony są ładowane, ponieważ jest to znaczenie zdarzenia. Program obsługi jest podłączone do kontrolki użytkownika i połączeń <xref:System.Windows.FrameworkElement.IsLoaded%2A> aby mieć pewność, że element główny jest ładowany całkowicie. Oba programy obsługi wywołać tę samą funkcję (niewyświetlany), który zostanie wypełniony elementów podrzędnych za pomocą najnowszych danych.  
  
 [!code-csharp[GroupBoxExample#FEIsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupBoxExample/CSharp/Page1.xaml.cs#feisloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje o języku lokalizacji/globalizacji, który stosuje się do elementu.</summary>
        <value>Informacje o języku dla tego elementu. Wartość domyślna to <see cref="T:System.Windows.Markup.XmlLanguage" /> z jego <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> wartość na ciąg "en US".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Formaty ciągu zgodne ze standardem RFC 3066. Na przykład w Stanach Zjednoczonych Język angielski jest "en US". Aby uzyskać więcej informacji na temat wartości i formatu, zobacz <xref:System.Windows.Markup.XmlLanguage>.  
  
 Ta właściwość zależności dziedziczy wartości właściwości. Jeśli są elementami podrzędnymi bez innych wartości <xref:System.Windows.FrameworkElement.Language%2A> nawiązane, przy użyciu wartości lokalnych lub style, system właściwość ustawi wartość <xref:System.Windows.FrameworkElement.Language%2A> wartość najbliższej element nadrzędny o tej wartości przypisane.  
  
 [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)] Określa ogólne znaczenie `xml:lang` atrybutu. <xref:System.Windows.FrameworkElement.Language%2A> zasadniczo udostępnia znaczenie tego atrybutu jako właściwość zależności. <xref:System.Windows.FrameworkElement.Language%2A> można dostosować programowo i mogą uczestniczyć w dziedziczenie wartości właściwości w systemie w taki sposób, że równoleżnikami sposób, w jaki `xml:lang` atrybut może dziedziczyć do zakresu elementu podrzędnego w [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]. Jeśli ustawisz <xref:System.Windows.FrameworkElement.Language%2A>, staje się wartości `xml:lang` i zastępuje wszystkie wcześniejsze wartości. Aby uzyskać więcej informacji, zobacz [XML: lang — Obsługa w XAML](~/docs/framework/xaml-services/xml-lang-handling-in-xaml.md).  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.LanguageProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.Language" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform LayoutTransform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform LayoutTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LayoutTransform" />
      <MemberSignature Language="VB.NET" Value="Public Property LayoutTransform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Transform ^ LayoutTransform { System::Windows::Media::Transform ^ get(); void set(System::Windows::Media::Transform ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LayoutTransform : System.Windows.Media.Transform with get, set" Usage="System.Windows.FrameworkElement.LayoutTransform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia transformację grafiki, która powinna zostać zastosowana do tego elementu, gdy przeprowadzane jest układu.</summary>
        <value>Skorzystaj z tego elementu przekształcenia. Wartość domyślna to <see cref="P:System.Windows.Media.Transform.Identity" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do <xref:System.Windows.UIElement.RenderTransform%2A>, <xref:System.Windows.FrameworkElement.LayoutTransform%2A> będzie mieć wpływ na wyniki układu.  
  
 Ustawienie przekształcenia zapewnia zaawansowane możliwości skalowania i obracania. Jednak <xref:System.Windows.FrameworkElement.LayoutTransform%2A> ignoruje <xref:System.Windows.Media.TranslateTransform> operacji. Jest to spowodowane zachowanie systemu układu dla elementów podrzędnych <xref:System.Windows.FrameworkElement> automatycznie koryguje kompensacji położenie elementu skalowany lub obrócony do odpowiedniego układu i współrzędnych elementu nadrzędnego.  
  
 <xref:System.Windows.FrameworkElement.LayoutTransform%2A> może prowadzić do niską wydajność aplikacji, jeśli wywołujesz w scenariuszu, który nie wymaga pełnego przebiegu przez system układu. Po zastosowaniu <xref:System.Windows.FrameworkElement.LayoutTransform%2A> do <xref:System.Windows.Controls.Panel.Children%2A> zbiór <xref:System.Windows.Controls.Panel>, wyzwala nowy przebieg przez system układu i wymusza wyświetlanymi na ekranie wszystkie obiekty do pomiaru i nieco inaczej rozmieszczone. Jeśli aktualizujesz kompletna aplikacja [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)], ta funkcja musi być dokładnie potrzebnych składników. Jednakże, jeśli nie potrzebujesz przekazać układ pełny, użyć <xref:System.Windows.UIElement.RenderTransform%2A> właściwość, która nie jest wywoływany system układu i dlatego jest zwykle w tym scenariuszu lepszym rozwiązaniem.  
  
 Przykładowe scenariusze gdzie <xref:System.Windows.FrameworkElement.LayoutTransform%2A> byłoby obejmują: obracanie elementów, takich jak składniki menu z poziomej, pionowej lub na odwrót, skalowania elementów (powiększania) na fokus, zapewniając edycji itp.  
  
<a name="dependencyPropertyInfo_LayoutTransform"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.LayoutTransformProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak zastosować <xref:System.Windows.FrameworkElement.LayoutTransform%2A> do elementu. Przykład tworzy wystąpienie <xref:System.Windows.Controls.Button> i umieszcza w obrębie nadrzędnego <xref:System.Windows.Controls.Grid>. Korzysta również <xref:System.Windows.FrameworkElement.LayoutTransform%2A> właściwości, aby zastosować <xref:System.Windows.Media.RotateTransform> do <xref:System.Windows.Controls.Button>.  
  
 [!code-cpp[LayoutTransform#1](~/samples/snippets/cpp/VS_Snippets_Wpf/LayoutTransform/CPP/LayoutTransform.cpp#1)]
 [!code-csharp[LayoutTransform#1](~/samples/snippets/csharp/VS_Snippets_Wpf/LayoutTransform/CSharp/LayoutTransform.cs#1)]
 [!code-vb[LayoutTransform#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/LayoutTransform/VisualBasic/LayoutTransform.vb#1)]
 [!code-xaml[LayoutTransform#1](~/samples/snippets/xaml/VS_Snippets_Wpf/LayoutTransform/XAML/default.xaml#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="http://go.microsoft.com/fwlink/?LinkID=158252">Przykładowe transformacje 2-D</related>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransformProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LayoutTransformProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LayoutTransformProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LayoutTransformProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LayoutTransformProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LayoutTransformProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.LayoutTransform" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy element jest poukładany, wyrenderowany i gotowy do interakcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Loaded> jest zwykle ostatniego zdarzenia wywoływane w kolejności inicjowania elementu. Zostanie wygenerowany zawsze po <xref:System.Windows.FrameworkElement.Initialized>. Czy istnieje możliwość obsługi <xref:System.Windows.FrameworkElement.Loaded> lub <xref:System.Windows.FrameworkElement.Initialized> zależy od wymagań. Nie należy do odczytu właściwości elementu Zamierzasz zresetować właściwości, a nie ma potrzeby żadnych informacji o układzie <xref:System.Windows.FrameworkElement.Initialized> mogą być lepiej zdarzeń wykonywane działania. Jeśli potrzebujesz wszystkich właściwości elementu, który ma być dostępny, i będzie ustawienie właściwości, które mogą zresetować układ, <xref:System.Windows.FrameworkElement.Loaded> mogą być lepiej zdarzeń wykonywane działania. Należy zachować ostrożność z współużytkowania wątkowości, jeśli programu obsługi resetuje wszystkie właściwości, które będą interpretowane przez system układu oznacza, że wymagane jest nowe przekazanie układu. (Może być konieczne Sprawdź <xref:System.Windows.FrameworkPropertyMetadata> przekazania wartości dla właściwości, jeśli wiesz właściwości, które mogą wymagać nowego układu, w przypadku ich zmiany.)  
  
 Aby uzyskać więcej informacji na temat sekwencji zdarzenia obiektu dla <xref:System.Windows.FrameworkElement>, a także dla kilku powiązanych aplikacji i klasy elementów, zobacz [zdarzenia okresu istnienia obiektu](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
 Zdarzenia trasowane bezpośrednie nie wykonuj trasy, są obsługiwane tylko w obrębie tego samego elementu, na którym są wywoływane. Bezpośrednie zdarzenia trasowane obsługują innych zachowań zdarzenia trasowanego: zbieranie dostępne programy obsługi pomocy technicznej i mogą być używane jako <xref:System.Windows.EventTrigger> w stylu.  
  
 <xref:System.Windows.FrameworkElement.Loaded> i <xref:System.Windows.FrameworkElement.Unloaded> może być zarówno wywołane kontrolek w wyniku zmiany motywu systemu zainicjowanego przez użytkownika. Zmień motyw powoduje unieważnienie szablonu kontrolki i zawartej drzewa wizualnego, co z kolei powoduje, że cały formant, aby zwolnić i załaduj ponownie. W związku z tym <xref:System.Windows.FrameworkElement.Loaded> nie zakłada się, że występują, tylko gdy strona jest ładowany Nawigacja do strony za pomocą.  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.LoadedEvent>|  
|Strategii routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkElement.Loaded" /> zdarzenia trasowanego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia trasowanego identyfikatory są tworzone, jeśli są rejestrowane zdarzenia trasowane. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metody dodawania właścicieli dla zdarzenia. Aby dodać funkcje obsługi klas, można użyć tych identyfikatorów.  
  
 Aby uzyskać więcej informacji na temat rejestrowania zdarzenia trasowane, zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Aby uzyskać więcej informacji na temat przy użyciu identyfikatorów zdarzenia trasowanego, aby dodać funkcje obsługi klas, zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduł wyliczający dla elementów podrzędnych logicznego tego elementu.</summary>
        <value>Moduł wyliczający dla elementów podrzędnych logicznego tego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.LogicalChildren%2A> umożliwia iteracyjne przeglądanie elementów podrzędnych. Jest to przydatne dla elementów, które może nie ma zdefiniowanych, dedykowany kolekcji, ale nadal zawierać więcej niż jeden element podrzędny, szczególnie <xref:System.Windows.FrameworkContentElement> elementów podrzędnych.  
  
 Aby uzyskać więcej informacji na temat sposobu użycia <xref:System.Windows.FrameworkElement.LogicalChildren%2A> i <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>, zobacz [drzewa w WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/c5358e14-d24c-44c7-b5eb-6062a4fd981c">x:Array — Rozszerzenie znaczników</related>
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Margin { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.Margin : System.Windows.Thickness with get, set" Usage="System.Windows.FrameworkElement.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zewnętrzny margines elementu.</summary>
        <value>Udostępnia wartości marginesów dla elementu. Wartość domyślna to <see cref="T:System.Windows.Thickness" /> przy użyciu wszystkich właściwości jest równa 0 (zero).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Margines to obszar między tym elementem i inne elementy, które będą sąsiadować podczas tworzenia przez układ [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]. Udostępniane elementy może być elementów równorzędnych (np. inne elementy w kolekcji wspólne kontrolki nadrzędnej) lub może być również nadrzędny tego elementu.  
  
 <xref:System.Windows.FrameworkElement.Margin%2A> jest ustawiony jako <xref:System.Windows.Thickness> struktury, a nie jako liczba tak, aby margines można ustawić niesymetryczne. <xref:System.Windows.Thickness> Struktura obsługuje konwersję typu ciąg, tak, aby można było określić asymetrycznego <xref:System.Windows.FrameworkElement.Margin%2A> w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] również atrybut składni.  
  
 Margines niezerową stosuje miejsce poza układ elementów <xref:System.Windows.FrameworkElement.ActualWidth%2A> i <xref:System.Windows.FrameworkElement.ActualHeight%2A>.  
  
 Marginesy są addytywne dla elementów równorzędnych w układzie; na przykład dwa sąsiadujące elementy, zarówno z marginesem 30 ustawionych na krawędzi sąsiednimi musi 60 jednostek odstęp między nimi.  
  
 Elementy, które mają Ustaw marginesu nie będzie zazwyczaj ograniczenie rozmiaru określonego <xref:System.Windows.FrameworkElement.Margin%2A> Jeśli miejsca przydzielonego prostokąt nie jest wystarczająco duży, marży oraz obszaru zawartości elementu. Obszar zawartości elementu będzie ograniczone zamiast tego podczas obliczania układu. Tylko wówczas, gdy będzie ograniczone marginesy jest również, jeśli zawartość jest już ograniczona do zera.  
  
<a name="xamlAttributeUsage_Margin"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object Margin="left,top,right,bottom"/>  
- or -  
<object Margin="left,top"/>  
- or -  
<object Margin="thicknessReference"/>  
```  
  
<a name="xamlPropertyElementUsage_Margin"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.Margin>  
    <Thickness Left="left" Top="top" Right="right" Bottom="bottom"/>  
  </object.Margin>  
</object>  
```  
  
<a name="xamlValues_Margin"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *po lewej stronie, góra, dół po prawej stronie*  
 Liczba wartości z zakresu od 0 i <xref:System.Double.PositiveInfinity> określające cztery właściwości wymiaru możliwe <xref:System.Windows.Thickness> struktury.  
  
 Użycie atrybutu akceptuje również skróconej wartości, które są stosowane w kolejności dostarczonej symetrycznie i logicznie. Na przykład `Margin="20"` będzie interpretowany jako oznaczenie <xref:System.Windows.Thickness> przy użyciu wszystkich właściwości wartość 20. `Margin="20,50"` będzie interpretowany jako oznaczenie <xref:System.Windows.Thickness> z <xref:System.Windows.Thickness.Left%2A> i <xref:System.Windows.Thickness.Right%2A> wartość 20, a <xref:System.Windows.Thickness.Top%2A> i <xref:System.Windows.Thickness.Bottom%2A> ustawioną wartość 50.  
  
 Jednostki domyślnej <xref:System.Windows.Thickness> miara jest [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]. Można również określić inne jednostki, dodając parametry typu jednostki `cm`, `in`, lub `pt` do żadnych miar.  
  
 Liczba wartości, podane jako [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] atrybutów nie trzeba określać separatorów dziesiętnych (0 jest dopuszczalna, nie musi być podana jako 0.0). Aby uzyskać więcej informacji na temat [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] użycia, zobacz <xref:System.Windows.Thickness>.  
  
 *thicknessReference*  
 Odwołanie do obiektu do istniejącego <xref:System.Windows.Thickness>. Może to być `}`, lub `}` odwołania. Aby uzyskać więcej informacji na temat [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] użycia, zobacz <xref:System.Windows.Thickness>.  
  
<a name="dependencyPropertyInfo_Margin"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.MarginProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Thickness" />
      </Docs>
    </Member>
    <Member MemberName="MarginProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MarginProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MarginProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MarginProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MarginProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MarginProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MarginProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MarginProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.Margin" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeight">
      <MemberSignature Language="C#" Value="public double MaxHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxHeight : double with get, set" Usage="System.Windows.FrameworkElement.MaxHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ograniczenie maksymalnej wysokości elementu.</summary>
        <value>Maksymalna wysokość elementu w [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Wartość domyślna to <see cref="F:System.Double.PositiveInfinity" />. Ta wartość może być dowolna wartość równa lub większa niż 0,0. <see cref="F:System.Double.PositiveInfinity" /> jest również jest prawidłowy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to jeden z trzech właściwości na <xref:System.Windows.FrameworkElement> określające wysokość informacji. Istnieją dwie <xref:System.Windows.FrameworkElement.MinHeight%2A> i <xref:System.Windows.FrameworkElement.Height%2A>.  Jeśli występuje konflikt między tymi wartościami, kolejność aplikacji do określenia wysokości rzeczywisty jest pierwszy <xref:System.Windows.FrameworkElement.MinHeight%2A> musi zostać wdrożona, następnie <xref:System.Windows.FrameworkElement.MaxHeight%2A>, a na koniec Jeśli każdy z nich znajdują się w granicach, <xref:System.Windows.FrameworkElement.Height%2A>.  
  
 Ograniczenia dotyczące wartości na <xref:System.Double> wartości są wymuszane przez <xref:System.Windows.ValidateValueCallback> mechanizm. Jeśli spróbujesz ustawić nieprawidłową wartość zwracany jest wyjątek czasu wykonywania.  
  
<a name="xamlAttributeUsage_MaxHeight"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object MaxHeight="double"/>  
- or –  
<object MaxHeight ="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MaxHeight"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *double*  
 <xref:System.Double>  
  
 Ciąg reprezentujący <xref:System.Double> wartość równą lub większą niż 0,0. To jest interpretowane jako [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] miary. Ciągi nie musi jawnie zawierać separatorów dziesiętnych. Na przykład wartość `1` jest dopuszczalna.  
  
 Taki sam <xref:System.Double> obowiązują ograniczenia zakresu, zgodnie z opisem w sekcji wartości właściwości, z tą różnicą, że należy użyć [x: Static — rozszerzenie znaczników](~/docs/framework/xaml-services/x-static-markup-extension.md) Musisz jawnie ustawić wartość <xref:System.Double.PositiveInfinity>.  
  
 *qualifiedDouble*  
 A *double* wartość zgodnie z opisem powyżej, a następnie za pomocą jednej z następujących ciągów jednostki w deklaracji: `px`, `in`, `cm`, `pt`.  
  
 `px` (domyślnie) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm` centymetrów; 1cm==(96/2.54) piks.  
  
 `pt` jest punktów. 1pt==(96/72) piks.  
  
<a name="dependencyPropertyInfo_MaxHeight"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.MaxHeightProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.MaxHeight" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidth">
      <MemberSignature Language="C#" Value="public double MaxWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWidth : double with get, set" Usage="System.Windows.FrameworkElement.MaxWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ograniczenie maksymalnej szerokości elementu.</summary>
        <value>Maksymalna szerokość elementu w [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Wartość domyślna to <see cref="F:System.Double.PositiveInfinity" />. Ta wartość może być dowolna wartość równa lub większa niż 0,0. <see cref="F:System.Double.PositiveInfinity" /> jest również jest prawidłowy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to jeden z trzech właściwości na <xref:System.Windows.FrameworkElement> określające szerokość informacji. Istnieją dwie <xref:System.Windows.FrameworkElement.MinWidth%2A> i <xref:System.Windows.FrameworkElement.Width%2A>. Jeśli występuje konflikt między tymi wartościami, kolejność aplikacji do oznaczania rzeczywista szerokość jest pierwszy <xref:System.Windows.FrameworkElement.MinWidth%2A> musi zostać wdrożona, następnie <xref:System.Windows.FrameworkElement.MaxWidth%2A>, a na koniec Jeśli każdy z nich znajdują się w granicach, <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 Ograniczenia dotyczące wartości na <xref:System.Double> wartości są wymuszane przez <xref:System.Windows.ValidateValueCallback> mechanizm. Jeśli spróbujesz ustawić wartość jest nieprawidłowa, zwracany jest wyjątek czasu wykonywania.  
  
<a name="xamlAttributeUsage_MaxWidth"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object MaxWidth="double"/>  
- or -  
<object MaxWidth="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MaxWidth"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *double*  
 <xref:System.Double>  
  
 Ciąg reprezentujący <xref:System.Double> wartość równą lub większą niż 0,0. To jest interpretowane jako [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] miary. Ciągi nie musi jawnie zawierać separatorów dziesiętnych. Na przykład wartość `1` jest dopuszczalna.  
  
 Taki sam <xref:System.Double> obowiązują ograniczenia zakresu, zgodnie z opisem w sekcji wartości właściwości, z tą różnicą, że należy użyć [x: Static — rozszerzenie znaczników](~/docs/framework/xaml-services/x-static-markup-extension.md) można ustawić wartość <xref:System.Double.PositiveInfinity>.  
  
 *qualifiedDouble*  
 A *double* wartość zgodnie z opisem powyżej, a następnie za pomocą jednej z następujących ciągów jednostki w deklaracji: `px`, `in`, `cm`, `pt`.  
  
 `px` (domyślnie) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm` centymetrów; 1cm==(96/2.54) piks.  
  
 `pt` jest punktów. 1pt==(96/72) piks.  
  
<a name="dependencyPropertyInfo_MaxWidth"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.MaxWidthProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.MaxWidth" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureCore">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Size MeasureCore (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureCore(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function MeasureCore (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureCore(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureCore : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.MeasureCore availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Dostępny rozmiar przyznać do elementów podrzędnych elementu nadrzędnego.</param>
        <summary>Implementuje podstawowe miary pass zachowanie systemu układu <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <returns>Wymagany rozmiar tego elementu w układzie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType> do łączenia z poziomu core WPF i implementacje miary poziomie struktury układu WPF. <xref:System.Windows.FrameworkElement> Implementacji zapieczętowuje metody. Aby dostosować zachowanie układu — dostęp próbny miary dowolnego elementu, który opiera się na poziomie struktury WPF, należy zastąpić <xref:System.Windows.FrameworkElement.MeasureOverride%2A> zamiast tego. Dopasuj środek polega na przekazaniu zachowanie układu elementu, który celowo nie twórz na poziomie struktury WPF lub użyj <xref:System.Windows.FrameworkElement>, Zastąp <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="abstract member MeasureOverride : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Dostępny rozmiar tego elementu można przydzielić do elementów podrzędnych. Infinity można określić jako wartość, aby wskazać, że element rozmiar zostanie zmieniony na dowolną zawartość jest dostępna.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, mierzy rozmiaru w układzie wymagane dla elementów podrzędnych i określa rozmiar dla <see cref="T:System.Windows.FrameworkElement" />-klasy pochodnej.</summary>
        <returns>Rozmiar ten element określa ona musi podczas układu, w oparciu o obliczenia rozmiarów elementu podrzędnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastąp <xref:System.Windows.FrameworkElement.MeasureOverride%2A> zaimplementować zachowanie zmiany rozmiaru niestandardowego układu dla danego elementu, ponieważ uczestniczy w [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] system układu. Implementacji należy wykonać następujące czynności:  
  
1.  Iteracyjne usługi element określonej kolekcji elementów podrzędnych, które są częścią układu, wywołanie <xref:System.Windows.UIElement.Measure%2A> dla każdego elementu podrzędnego.  
  
2.  Natychmiast Uzyskaj <xref:System.Windows.UIElement.DesiredSize%2A> w elemencie podrzędnym (jest ono ustawione jako właściwość po <xref:System.Windows.UIElement.Measure%2A> nosi nazwę).  
  
3.  Obliczenia netto żądany rozmiar elementu nadrzędnego, na podstawie pomiarów elementów podrzędnych.  
  
 Wartość zwracana przez <xref:System.Windows.FrameworkElement.MeasureOverride%2A> powinien być rozmiar elementu własne potrzeby staje się wówczas miary, dane wejściowe dla elementu nadrzędnego bieżącego elementu. Te same czynności, nadal za pośrednictwem systemu układów, aż do osiągnięcia element główny strony.  
  
 W trakcie tego procesu może zwrócić elementy podrzędne, większego <xref:System.Windows.UIElement.DesiredSize%2A> rozmiar niż początkowy `availableSize` do wskazania, że element podrzędny chce więcej miejsca. Może to być obsługiwane w Twojej własnej implementacji dzięki zastosowaniu przewijany regionu, zmieniając rozmiar kontrolki nadrzędnej, ustanawiając sposób skumulowany zamówienia lub dowolnej liczby rozwiązań do pomiaru lub rozmieszczanie zawartości.  
  
> [!IMPORTANT]
>  Elementy powinny wywoływać <xref:System.Windows.UIElement.Measure%2A> na poszczególne elementy podrzędne w trakcie tego procesu, w przeciwnym razie elementy podrzędne będą nie poprawnie o rozmiarze lub rozmieszczone.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Poniższy kod — kompilowanie przedstawia ten wzorzec implementacji.  <c>VisualChildren</c> reprezentuje właściwość wyliczalny kolekcję elementów podrzędnych, które należy zdefiniować własne elementu. Właściwość może być nazwany niczego. <c>VisualChildren</c> to nazwa symbolu zastępczego dla celów tego przykładu <c>VisualChildren</c> nie [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] zgodnie z informacjami od [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] lub jej część wzorca nazewnictwa...  
  
[! code-csharp[CorePseudocode #FEMeasureOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#femeasureoverride)] [! kodu vb[CorePseudocode #FEMeasureOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#femeasureoverride)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="MinHeight">
      <MemberSignature Language="C#" Value="public double MinHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MinHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinHeight : double with get, set" Usage="System.Windows.FrameworkElement.MinHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ograniczenie minimalnej wysokości elementu.</summary>
        <value>Minimalna wysokość elementu w [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Wartość domyślna to od 0,0. Ta wartość może być dowolna wartość równa lub większa niż 0,0. Jednak <see cref="F:System.Double.PositiveInfinity" /> nie jest prawidłowy, ani nie jest <see cref="F:System.Double.NaN" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to jeden z trzech właściwości na <xref:System.Windows.FrameworkElement> określające wysokość informacji.  Istnieją dwie <xref:System.Windows.FrameworkElement.Height%2A> i <xref:System.Windows.FrameworkElement.MaxHeight%2A>. Jeśli występuje konflikt między tymi wartościami, kolejność aplikacji do określenia wysokości rzeczywisty jest pierwszy <xref:System.Windows.FrameworkElement.MinHeight%2A> musi zostać wdrożona, następnie <xref:System.Windows.FrameworkElement.MaxHeight%2A>, a na koniec Jeśli każdy z nich znajdują się w granicach, <xref:System.Windows.FrameworkElement.Height%2A>.  
  
 Ograniczenia dotyczące wartości na <xref:System.Double> wartości są wymuszane przez <xref:System.Windows.ValidateValueCallback> mechanizm. Jeśli spróbujesz ustawić wartość jest nieprawidłowa, zwracany jest wyjątek czasu wykonywania.  
  
<a name="xamlAttributeUsage_MinHeight"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object MinHeight="double"/>  
- or -  
<object MinHeight="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MinHeight"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *double*  
 <xref:System.Double>  
  
 Ciąg reprezentujący <xref:System.Double> wartość równą lub większą niż 0,0. To jest interpretowane jako [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] miary. Ciągi nie musi jawnie zawierać separatorów dziesiętnych. Na przykład wartość `1` jest dopuszczalna.  
  
 Taki sam <xref:System.Double> obowiązują ograniczenia zakresu, zgodnie z opisem w sekcji wartości właściwości.  
  
 *qualifiedDouble*  
 A *double* wartość zgodnie z opisem powyżej, a następnie za pomocą jednej z następujących ciągów jednostki w deklaracji: `px`, `in`, `cm`, `pt`.  
  
 `px` (domyślnie) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm` centymetrów; 1cm==(96/2.54) piks.  
  
 `pt` jest punktów. 1pt==(96/72) piks.  
  
<a name="dependencyPropertyInfo_MinHeight"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.MinHeightProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.MinHeight" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidth">
      <MemberSignature Language="C#" Value="public double MinWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinWidth : double with get, set" Usage="System.Windows.FrameworkElement.MinWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ograniczenie minimalnej szerokości elementu.</summary>
        <value>Minimalna szerokość elementu w [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Wartość domyślna to od 0,0. Ta wartość może być dowolna wartość równa lub większa niż 0,0. Jednak <see cref="F:System.Double.PositiveInfinity" /> jest nieprawidłowa, podobnie jak <see cref="F:System.Double.NaN" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to jeden z trzech właściwości na <xref:System.Windows.FrameworkElement> określające szerokość informacji.  Istnieją dwie <xref:System.Windows.FrameworkElement.Width%2A> i <xref:System.Windows.FrameworkElement.MaxWidth%2A>.  Jeśli występuje konflikt między tymi wartościami, kolejność aplikacji do oznaczania rzeczywista szerokość jest pierwszy <xref:System.Windows.FrameworkElement.MinWidth%2A> musi zostać wdrożona, następnie <xref:System.Windows.FrameworkElement.MaxWidth%2A>, a na koniec Jeśli każdy z nich znajdują się w granicach, <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 Ograniczenia dotyczące wartości na <xref:System.Double> wartości są wymuszane przez <xref:System.Windows.ValidateValueCallback> mechanizm. Jeśli spróbujesz ustawić wartość jest nieprawidłowa, zwracany jest wyjątek czasu wykonywania.  
  
<a name="xamlAttributeUsage_MinWidth"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object MinWidth="double"/>  
- or -  
<object MinWidth="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MinWidth"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *double*  
 <xref:System.Double>  
  
 Ciąg reprezentujący <xref:System.Double> wartość równą lub większą niż 0,0. To jest interpretowane jako [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] miary. Ciągi nie musi jawnie zawierać separatorów dziesiętnych. Na przykład wartość `1` jest dopuszczalna.  
  
 Taki sam <xref:System.Double> obowiązują ograniczenia zakresu, zgodnie z opisem w sekcji wartości właściwości.  
  
 *qualifiedDouble*  
 A *double* wartość zgodnie z opisem powyżej, a następnie za pomocą jednej z następujących ciągów jednostki w deklaracji: `px`, `in`, `cm`, `pt`.  
  
 `px` (domyślnie) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm` centymetrów; 1cm==(96/2.54) piks.  
  
 `pt` jest punktów. 1pt==(96/72) piks.  
  
<a name="dependencyPropertyInfo_MinWidth"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.MinWidthProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.MinWidth" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">Kierunku, w którym fokus ma zostać przesunięta, jako wartość wyliczenia.</param>
        <summary>Przenosi fokus klawiatury od tego elementu, a także do innego elementu w kierunku podana przechodzenia.</summary>
        <returns>Zwraca <see langword="true" /> Jeśli fokus zostanie przeniesiony pomyślnie; <see langword="false" /> Jeśli elementem docelowym, w kierunku co określona, nie istnieje, lub może nie być klawiatura fokus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja zastępuje <xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=nameWithType> i zapieczętowuje metody.  
  
   
  
## Examples  
 Poniższy przykład wykonuje program obsługi, który obsługuje kilka dane wejściowe przycisku możliwe. Każdy przycisk reprezentuje możliwe <xref:System.Windows.Input.FocusNavigationDirection>. Program obsługi śledzi element z bieżącym fokusem klawiatury i wywołania <xref:System.Windows.FrameworkElement.MoveFocus%2A> tego elementu, określając odpowiednią <xref:System.Windows.Input.FocusNavigationDirection> jako inicjowanie <xref:System.Windows.Input.TraversalRequest> podany parametr typu.  
  
 [!code-csharp[FocusSample#FocusSampleMoveFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#focussamplemovefocus)]
 [!code-vb[FocusSample#FocusSampleMoveFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#focussamplemovefocus)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.DesignerSerializationOptions</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Windows.Markup.DesignerSerializationOptions(System.Windows.Markup.DesignerSerializationOptions.SerializeAsAttribute)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę identyfikującą elementu. Nazwa zawiera odwołanie, aby po jest tworzony podczas przetwarzania przez związanym z kodem, takie jak kod procedury obsługi zdarzeń, mogą odwoływać się do elementu znaczników [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] procesora.</summary>
        <value>Nazwa elementu. Wartość domyślna to ciąg pusty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najbardziej typowe użycia tej właściwości jest określenie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] nazwy elementu jako atrybut w znacznikach.  
  
 Ta właściwość zapewnia zasadniczo można ustawić właściwości wygody poziomie struktury WPF [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [x: Name — dyrektywa](~/docs/framework/xaml-services/x-name-directive.md).  
  
 Nazwy muszą być unikatowe w obrębie namescope. Aby uzyskać więcej informacji, zobacz [zakresy WPF XAML nazw](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 Wprowadzenie <xref:System.Windows.FrameworkElement.Name%2A> w przypadku tworzenia elementów w kodzie nie jest powszechne. Jeśli już masz odpowiednie odwołania w kodzie, można wywoływać tylko metody i właściwości w elemencie odwołania, a nie ogólnie potrzebę <xref:System.Windows.FrameworkElement.Name%2A>. Wyjątkiem jest Jeśli <xref:System.Windows.FrameworkElement.Name%2A> ciąg zawiera niektóre przeciążona to znaczy, na przykład jeśli jest przydatne wyświetlić tą nazwą w [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]. Ustawienie <xref:System.Windows.FrameworkElement.Name%2A> z kodem Jeśli oryginalny <xref:System.Windows.FrameworkElement.Name%2A> została ustawiona z kodu znaczników nie zaleca się, a zmiana wartości właściwości po załadowaniu [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] nie zmieni się odwołanie do obiektu oryginalnego. Odwołania do obiektów są tworzone tylko wtedy, gdy podstawowy zakresy nazw są jawnie tworzone podczas analizowania. W szczególności należy wywołać <xref:System.Windows.FrameworkElement.RegisterName%2A> zapewnienie skutecznego zmiany <xref:System.Windows.FrameworkElement.Name%2A> właściwość elementu już załadowana.  
  
 Co warto zamierzone, w przypadku, gdy ustawienie <xref:System.Windows.FrameworkElement.Name%2A> z kodu jest ważne jest, gdy rejestracji nazw dla elementów, które scenorysy będą uruchamiane, dzięki czemu może znajdować się w czasie wykonywania. Przed zarejestrowaniem nazwę, może wystąpić konieczność tworzenia instancji i przypisać <xref:System.Windows.NameScope> wystąpienia. Sekcja przykład lub [Przegląd Scenorysy](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
 Ustawienie <xref:System.Windows.FrameworkElement.Name%2A> z kodu ma ograniczoną aplikacje, ale pobieranie elementu <xref:System.Windows.FrameworkElement.Name%2A> częściej. Jednego konkretnego scenariusza jest to, czy aplikacja obsługuje model nawigacji, gdzie stron Załaduj ponownie do aplikacji i kodu w czasie wykonywania niekoniecznie jest kodem zdefiniowane dla tej strony. Metoda narzędzie <xref:System.Windows.FrameworkElement.FindName%2A>, który jest dostępny z dowolnego <xref:System.Windows.FrameworkElement>, można znaleźć dowolnego elementu przez <xref:System.Windows.FrameworkElement.Name%2A> w drzewie logicznym dla tego elementu, wyszukiwanie rekursywnie drzewa zgodnie z potrzebami. Możesz też <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> metoda statyczna <xref:System.Windows.LogicalTreeHelper>, która również korzysta <xref:System.Windows.FrameworkElement.Name%2A> ciągu jako argument.  
  
 Zwykle używanych elementów głównych (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> na przykład) implementować interfejs <xref:System.Windows.Markup.INameScope>. Implementacje tego interfejsu powinny wymuszanie nazwy się jednoznaczna w obrębie swojego zakresu. Elementy główne, które definiują ten interfejs również zdefiniować granice zachowanie namescope wszystkie powiązane [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)].  
  
 <xref:System.Windows.FrameworkElement.Name%2A> Właściwości służy również jako identyfikator dla innych procesów. Na przykład [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] użyje modelu automatyzacji <xref:System.Windows.FrameworkElement.Name%2A> jako AutomationId dla klientów i dostawców.  
  
 Wartości ciągu używanych dla <xref:System.Windows.FrameworkElement.Name%2A> mają pewne ograniczenia, jak nałożonych przez podstawowe [x: Name — dyrektywa](~/docs/framework/xaml-services/x-name-directive.md) definicją [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] specyfikacji. W szczególności <xref:System.Windows.FrameworkElement.Name%2A> musi rozpoczynać się od litery lub znaku podkreślenia (_) i może zawierać tylko litery, cyfry i znaki podkreślenia. Aby uzyskać więcej informacji, zobacz [zakresy WPF XAML nazw](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 <xref:System.Windows.FrameworkElement.Name%2A> jest jednym z nielicznymi właściwości zależności, które nie mogą być animowane (<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> jest `true` w metadanych), ponieważ sama nazwa ma zasadnicze znaczenie dla przeznaczonych dla animacji. Powiązanie danych <xref:System.Windows.FrameworkElement.Name%2A> jest technicznie możliwe, ale jest to bardzo rzadko scenariusz, ponieważ powiązane z danymi <xref:System.Windows.FrameworkElement.Name%2A> nie może obsługiwać głównym przeznaczeniem właściwość: zapewnienie punkt połączenia z identyfikatorem związanym z kodem.  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.NameProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
   
  
## Examples  
 Poniższy przykład ustawia <xref:System.Windows.FrameworkElement.Name%2A> właściwości w kodzie, a następnie rejestruje nazwę do nowo utworzonego <xref:System.Windows.NameScope> przez wywołanie metody <xref:System.Windows.FrameworkElement.RegisterName%2A>. Techniki przedstawione w tym miejscu jest wymagana dla animowanie za pomocą scenorysów, ponieważ scenorysów wymagają określania wartości docelowej przez <xref:System.Windows.FrameworkElement.Name%2A>i nie może być objęta odwołanie do obiektu.  
  
 [!code-csharp[animateHeight_procedural#FEName](~/samples/snippets/csharp/VS_Snippets_Wpf/animateHeight_procedural/CSharp/AnimatedHeightExample.cs#fename)]
 [!code-vb[animateHeight_procedural#FEName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animateHeight_procedural/visualbasic/animatedheightexample.vb#fename)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.Name" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public virtual void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnApplyTemplate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnApplyTemplate();" />
      <MemberSignature Language="F#" Value="abstract member OnApplyTemplate : unit -&gt; unit&#xA;override this.OnApplyTemplate : unit -&gt; unit" Usage="frameworkElement.OnApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, jest wywoływana zawsze wtedy, gdy kod aplikacji realizowania innych procesów wewnętrznych wywołań <see cref="M:System.Windows.FrameworkElement.ApplyTemplate" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma domyślnej implementacji.  
  
 Szablony są części elementu ukończone drzewa wizualnego pochodzi z właściwości szablonu <xref:System.Windows.Style> zastosowany dla elementu. Aby uzyskać więcej informacji, zobacz [Tworzenie szablonów i stylów](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Pochodne klasy <see cref="T:System.Windows.FrameworkElement" /> można użyć tej metody jako powiadomienie dla różnych możliwych scenariuszy: 
— Możesz wywołać Twojej własnej implementacji kodu, który kompiluje w pozostałej części drzewa wizualnego elementu.  
  
— Można uruchomić kod, który opiera się na drzewie wizualnym za pomocą szablonów o została zastosowana, takich jak uzyskanie odwołania do nazwanych elementów pochodzących z szablonu.  
  
— Można wprowadzać tylko ma sensu istnieje po ukończeniu drzewa wizualnego, za pomocą szablonów usługi.  
  
— Można ustawić stanów i właściwości elementów w szablonie, które są zależne od innych czynników. Na przykład wartości właściwości mogą składać się wykrywalny przez element nadrzędny, wiedząc, lub otrzymane określonej klasy korzysta z wspólnego szablonu.  
  
Implementacje zawsze powinna wywołać implementację podstawową przed ich wdrożeniem. <see cref="T:System.Windows.FrameworkElement" /> sam nie ma wartości domyślnej implementacji, ale pośredniczące klasy może być.  
  
 <see cref="T:System.Windows.Controls.Control" /> oferuje podobne override, <see cref="M:System.Windows.Controls.Control.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Udostępnia dane o zdarzeniu.</param>
        <summary>Wywoływana zawsze, gdy jest to nieobsługiwany <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /> zdarzenia trasowanego osiągnie tej klasy w jego trasę. Zaimplementuj tę metodę, aby dodać obsługę klasy dla tego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma domyślnej implementacji. Nadal powinny wywoływać implementację podstawową, w przypadku, gdy klasa pośrednicząca w dziedziczeniu zaimplementowała tej metody.  
  
 Celem tej metody jest nieco podobne do [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] wzorzec zdarzeń na * metody: zapewnia mechanizmy do obsługi zdarzeń zgodnych z klas pochodnych z obsługi klasy, zamiast do obsługi wystąpienia. W tym przypadku pasującego zdarzenia to zdarzenia trasowanego. Wzorzec implementacji metody On * różni się dla zdarzenia trasowane ponieważ zdarzenia trasowanego został zgłoszony przez element podrzędny nie musi to być element, który będzie wywoływać procedury obsługi, więc implementacji należy weź źródło argumenty zdarzenia właściwości pod uwagę (i nie należy próbować ponownie zgłosić zdarzenie, które w większości przypadków). Podklasy <xref:System.Windows.FrameworkElement> może wybrać do wywołania metody obsługi Klasa prywatna, po odebraniu zdarzenia wzdłuż trasy. Jeden scenariusz potencjalnych jest przyjmują argumentów zdarzenia i celowo oznaczanie zdarzenia, jako obsługiwane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.RoutedEventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywoływana zawsze, gdy jest to nieobsługiwany <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> zdarzenia trasowanego osiągnie tej klasy w jego trasę. Zaimplementuj tę metodę, aby dodać obsługę klasy dla tego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma domyślnej implementacji. Nadal powinny wywoływać implementację podstawową, w przypadku, gdy klasa pośrednicząca w dziedziczeniu zaimplementowała tej metody.  
  
 Celem tej metody jest nieco podobne do [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] wzorzec zdarzeń na * metody: zapewnia mechanizmy do obsługi zdarzeń zgodnych z klas pochodnych z obsługi klasy, zamiast do obsługi wystąpienia. W tym przypadku pasującego zdarzenia to zdarzenia trasowanego. Wzorzec implementacji metody On * różni się dla zdarzenia trasowane ponieważ zdarzenia trasowanego został zgłoszony przez element podrzędny nie musi to być element, który będzie wywoływać procedury obsługi, więc implementacji należy weź źródło argumenty zdarzenia właściwości pod uwagę (i nie należy próbować ponownie zgłosić zdarzenie, które w większości przypadków). Podklasy <xref:System.Windows.FrameworkElement> może wybrać do wywołania metody obsługi Klasa prywatna, po odebraniu zdarzenia wzdłuż trasy. Jeden scenariusz potencjalnych jest przyjmują argumentów zdarzenia i celowo oznaczanie zdarzenia, jako obsługiwane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.RoutedEventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywoływana zawsze, gdy jest to nieobsługiwany <see cref="E:System.Windows.UIElement.GotFocus" /> zdarzeń osiągnie tego elementu w jego trasę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od niektórych innych na * metod udostępnianych przez elementy bazy <xref:System.Windows.FrameworkElement.OnGotFocus%2A> mają domyślną implementację. W szczególności ma implementację zastępujący null implementacji na następnym poziomie elementu podstawowego, <xref:System.Windows.UIElement.OnGotFocus%2A>. Po wywołaniu, <xref:System.Windows.FrameworkElement.OnGotFocus%2A> Ustawia fokus odpowiednie zachowanie w tym elemencie w przypadkach, z którego pochodzi z bieżącego elementu z powodu fokus klawiatury. <xref:System.Windows.FrameworkElement.OnGotFocus%2A> Obsługi nie są oznaczane argumenty zdarzenia jako obsłużony, nawet wtedy, gdy fokus jest ustawiony do bieżącego elementu. Jeśli źródło zdarzenia innego elementu w drzewie (nie bieżący element), program obsługi nie działa.  
  
 Mogą przesłaniać tę metodę, aby można było zmienić domyślne zachowanie fokus w elemencie, ale należy pamiętać, że zmiany zachowania fokus w ten sposób można lepiej wykonać przy użyciu nie zezwala na element, który ma być focusable w ogóle (zobacz <xref:System.Windows.UIElement.Focusable%2A>).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Jeśli zamierzasz oznaczyć zdarzeń przetwarzanych w argumentach, należy pamiętać konsekwencji w obsłudze zdarzeń w inne elementy nadrzędne w drzewie elementów. Ponieważ ten program obsługi działa na zdarzenia przy użyciu propagacji routing, ustawienia fokus na bieżącym <paramref name="sender" /> na zdarzenie argumenty mogą nie być odpowiednie. Zespół może być konieczne przejść do elementu podrzędnego złożonego lub do elementu nadrzędnego, w zależności od tego, składania niektórych kontrolek. W związku z tym oznaczanie zdarzenia fokusu jako obsłużony, zaleca się tylko jeśli całego drzewa wizualnego, za pośrednictwem routingiem zdarzenia jest częścią kompozycji formantu, który zostanie utworzony.</para>
        </block>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.RoutedEventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.FrameworkElement.Initialized" /> zdarzeń. Ta metoda jest wywoływana zawsze wtedy, gdy <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> ustawiono <see langword="true" /> wewnętrznie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej konkretnej na * metoda nie jest zaczepienia klasy programu obsługi. Nie jest on dokładnie postępuj zgodnie z ustanowionym [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] na * Konwencji metoda czy pasującego zdarzenia można pominąć przez zastąpienie tej metody i nie wywołuje metody podstawowej implementacji.  
  
 Należy pamiętać, że <xref:System.Windows.FrameworkElement.IsInitialized%2A> właściwość jest tylko do odczytu, więc nie można ustawić <xref:System.Windows.FrameworkElement.IsInitialized%2A> wymusić zachowanie inicjowania. Ustawianie stanu inicjowania ma na celu można wykonać tylko przez [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Domyślna implementacja tej metody wirtualnej zgłasza zdarzenie, zgodnie z powyższym opisem. Zastąpienia powinny wywoływać implementację podstawową, aby zachować to zachowanie. Jeśli nie można wywoływać implementację podstawową, nie tylko możesz nie zgłosi <see cref="E:System.Windows.FrameworkElement.Initialized" /> zdarzenie, ponieważ oczekuje się zazwyczaj z <see cref="T:System.Windows.FrameworkElement" /> klasy pochodnej, ale będzie również tłumić dwie ważne styl i motyw styl inicjowania operacje, które są zaimplementowane przez tę implementację podstawowego.</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.OnApplyTemplate" />
        <altmember cref="E:System.Windows.FrameworkElement.Initialized" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzenia, które opisuje właściwość, która się zmieniła, a także starej i nowej wartości.</param>
        <summary>Wywoływane, gdy wartość dowolnej właściwości zależności, w tym <see cref="T:System.Windows.FrameworkElement" /> został zaktualizowany. Zmieniona właściwość konkretnej zależności jest zgłaszany w parametrze argumentów. Zastępuje <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest przeznaczona do zwykle wykrywać zmiany właściwości lub invalidations. Zamiast tego ma na celu modyfikacji wzorca ogólnego unieważniania Jeśli znane jest niektórych informacji o klasyfikacjach szerokiego właściwości.  
  
 Ta metoda jest potencjalnie wywoływana wiele razy w okresie istnienia obiektu. W związku z tym, można osiągnąć lepszą wydajność, jeśli zastąpić metadane z określonych właściwości, a następnie dołącz <xref:System.Windows.CoerceValueCallback> lub <xref:System.Windows.PropertyChangedCallback> funkcje dla poszczególnych właściwości. Jednak jeśli może użyć tej metody <xref:System.Windows.FrameworkElement> obejmuje szereg istotnych właściwości zależności powiązanych wartości, lub jeśli zawiera logikę, takie jak zachowanie renderowania, który musi zostać uruchomiony ponownie dla kilku powiązanych przypadków invalidations właściwości.  
  
 Należy pamiętać, że o identycznej nazwie `OnPropertyChanged` metody z innym podpisem (typ parametru jest <xref:System.ComponentModel.PropertyChangedEventArgs>), mogą być wyświetlane na liczby klas. Czy `OnPropertyChanged` jest używany dla danych obiektu powiadomień i jest częścią kontraktu dla <xref:System.ComponentModel.INotifyPropertyChanged>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zawsze należy wywołać implementację podstawową jako pierwszą operacją w danej implementacji. Niewykonanie tej czynności to znacznie spowoduje wyłączenie całego [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] właściwości systemu, co powoduje, że nieprawidłowe wartości należy podać. Konkretne <see cref="T:System.Windows.FrameworkElement" /> implementacja jest również odpowiedzialnych za utrzymanie stanu właściwe dla różnych właściwości, które mają wpływ na interfejsie użytkownika widoczne. Obejmują one, powodując unieważnienie drzewa wizualnego, w oparciu o zmiany do nadawania stylu w odpowiednim czasie.</para>
        </block>
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="T:System.Windows.PropertyChangedCallback" />
      </Docs>
    </Member>
    <Member MemberName="OnRenderSizeChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnRenderSizeChanged (System.Windows.SizeChangedInfo sizeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnRenderSizeChanged(class System.Windows.SizeChangedInfo sizeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnRenderSizeChanged (sizeInfo As SizeChangedInfo)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnRenderSizeChanged(System::Windows::SizeChangedInfo ^ sizeInfo);" />
      <MemberSignature Language="F#" Value="override this.OnRenderSizeChanged : System.Windows.SizeChangedInfo -&gt; unit" Usage="frameworkElement.OnRenderSizeChanged sizeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sizeInfo" Type="System.Windows.SizeChangedInfo" />
      </Parameters>
      <Docs>
        <param name="sizeInfo">Szczegółowe informacje związane z zmianę rozmiaru stare i nowe.</param>
        <summary>Wywołuje <see cref="E:System.Windows.FrameworkElement.SizeChanged" /> zdarzenie, przy użyciu określone informacje jako część danych zdarzenia ostateczną.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.Windows.UIElement.OnRenderSizeChanged%2A>. Jeśli chcesz wywołać tę metodę spowoduje zresetowanie <xref:System.Windows.FrameworkElement.ActualWidth%2A> właściwości <xref:System.Windows.FrameworkElement.ActualHeight%2A> , albo obie te właściwości, w zależności od tego, co jest określony jako zmienione w podanych argumentów i będzie zawsze podniesieniu zdarzenia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Nie zastępuje tę metodę w typowy układ scenariuszach. System układu działa w sposób celowo asynchronicznej, aby mieć pewność, że wszystkie możliwe układ Rozmieść i przypadków miary są rozliczane. System układu Przesłaniaj metody <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /> i <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" /> są zwykle wystarczające dla jakiegokolwiek dostosowywania układu wymagane. <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /> jest udostępniany jako wirtualny. Można zastąpić <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /> aby poprawić wyjątkowych przypadków, w których zmiany zachowania czasu wykonywania związane z wprowadzanie zdarzeń w połączeniu z formantem recomposition w odpowiedzi może nadać informacji o układzie niedokładne.  
  
Nadal mogą zastąpić tę metodę w klasach pochodnych (go jest chroniona, ale nie jest zapieczętowany). Zawsze należy wywoływać implementację podstawową, aby zachować zachowanie, o których wspomniano powyżej, chyba że masz bardzo powody, aby wyłączyć domyślne zachowanie renderowania poziomie struktury WPF. Nie można podnieść <see cref="E:System.Windows.FrameworkElement.SizeChanged" /> zdarzeń spowoduje zachowanie układu niestandardowego, jeśli przy użyciu standardowej implementacji systemu poziomie struktury układu WPF.</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">Stary styl.</param>
        <param name="newStyle">Nowy styl.</param>
        <summary>Wywoływane, gdy zmieni się styl używany dla tego elementu, który spowoduje unieważnienie układu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma domyślną implementację, która ustawia flagi wewnętrznej, który służy do odnotowania warunek styl zmienione.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Należy zazwyczaj trzeba zastąpić tę metodę. Dowolny Zmień styl, który obejmuje miary lub Rozmieść zmiany powodowało już inny cykl renderowania, zakładając, że typowa implementacja metody <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />  /  <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />, lub wartości domyślne. Zastępuje z <see cref="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" /> odpowiednie może być Jeśli Twoje <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />  /  <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /> wdrożeń zostały celowo optymalizacji lub obsługa aktualizacje częściowe, ale chciała zastosować zmiany stylów bardziej bezpośrednio. (Aktualizacje częściowe byłoby w celu uniknięcia wielu wywołań przyrostowe <see cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" /> i <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> na wszystkie elementy podrzędne).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Udostępnia dane o zdarzeniu.</param>
        <summary>Wywoływana zawsze, gdy jest to nieobsługiwany <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /> zdarzenia trasowanego osiągnie tej klasy w jego trasę. Zaimplementuj tę metodę, aby dodać obsługę klasy dla tego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma domyślnej implementacji. Nadal powinny wywoływać implementację podstawową, w przypadku, gdy klasa pośrednicząca w dziedziczeniu zaimplementowała tej metody.  
  
 Celem tej metody jest nieco podobne do [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] wzorzec zdarzeń na * metody: zapewnia mechanizmy do obsługi zdarzeń zgodnych z klas pochodnych z obsługi klasy, zamiast do obsługi wystąpienia. W tym przypadku pasującego zdarzenia to zdarzenia trasowanego. Wzorzec implementacji metody On * różni się dla zdarzenia trasowane ponieważ zdarzenia trasowanego został zgłoszony przez element podrzędny nie musi to być element, który będzie wywoływać procedury obsługi, więc implementacji należy weź źródło argumenty zdarzenia właściwości pod uwagę (i nie należy próbować ponownie zgłosić zdarzenie, które w większości przypadków). Podklasy <xref:System.Windows.FrameworkElement> może wybrać do wywołania metody obsługi Klasa prywatna, po odebraniu zdarzenia wzdłuż trasy. Jeden scenariusz potencjalnych jest przyjmują argumentów zdarzenia i celowo oznaczanie zdarzenia, jako obsługiwane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Udostępnia dane o zdarzeniu.</param>
        <summary>Wywoływane, gdy <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /> zdarzenia trasowanego osiągnie tej klasy w jego trasę. Zaimplementuj tę metodę, aby dodać obsługę klasy dla tego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma domyślnej implementacji. Nadal powinny wywoływać implementację podstawową, w przypadku, gdy klasa pośrednicząca w dziedziczeniu zaimplementowała tej metody.  
  
 Celem tej metody jest nieco podobne do [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] wzorzec zdarzeń na * metody: zapewnia mechanizmy do obsługi zdarzeń zgodnych z klas pochodnych z obsługi klasy, zamiast do obsługi wystąpienia. W tym przypadku pasującego zdarzenia to zdarzenia trasowanego. Wzorzec implementacji metody On * różni się dla zdarzenia trasowane ponieważ zdarzenia trasowanego został zgłoszony przez element podrzędny nie musi to być element, który będzie wywoływać procedury obsługi, więc implementacji należy weź źródło argumenty zdarzenia właściwości pod uwagę (i nie należy próbować ponownie zgłosić zdarzenie, które w większości przypadków). Podklasy <xref:System.Windows.FrameworkElement> może wybrać do wywołania metody obsługi Klasa prywatna, po odebraniu zdarzenia wzdłuż trasy. Jeden scenariusz potencjalnych jest przyjmują argumentów zdarzenia i celowo oznaczyć zdarzenia jako obsłużony, skrócenie czasu trasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="frameworkElement.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Starego elementu nadrzędnego. Może być <see langword="null" /> do wskazania, że element nie ma elementu nadrzędnego visual wcześniej.</param>
        <summary>Wywoływane, gdy zostanie zmieniony element nadrzędny tego elementu w drzewie wizualnym. Zastępuje <see cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Drzewo wizualne potencjalnie różni się od drzewo logiczne ponieważ pomija elementy, które nie są renderowane wizualnie, takich jak kolekcje i rozwija niektóre elementy na podstawie ich składania styl i motyw. Aby uzyskać więcej informacji, zobacz [drzewa w WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Domyślna implementacja tej metody wirtualnej wysyła zapytanie o nowym rekordem nadrzędnym, wywołuje różne zdarzenia inicjowania i ustawia flagi wewnętrznej o stanie inicjowania <see cref="T:System.Windows.FrameworkElement" /> odpowiednio. Na koniec wywoływanych przez nią kolejnych podstawowe implementacje zgodnie z oświadczeniem <see cref="T:System.Windows.UIElement" />, którym z kolei wywołuje bazowej <see cref="T:System.Windows.Media.Visual" />. Zawsze wywoływać implementację podstawową, aby zachować to zachowanie, w przeciwnym razie zachowanie drzewa element dla tego elementu, gdy zadeklarowana jako element podrzędny innego elementu nie może być zgodnie z oczekiwaniami.  
  
Kilka istniejących [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] klasy przesłonić tę metodę, na przykład: <see cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />, <see cref="M:System.Windows.Controls.ListBoxItem.OnVisualParentChanged(System.Windows.DependencyObject)" />. Najbardziej typowym scenariuszem jest wymuszenie, że nowy element nadrzędny musi być określonego typu. Może to obejmować, zostanie zgłoszony wyjątek, jeśli nowy element nadrzędny sposób typu testu nie powiodła się. Specjalizowanej wersji w tym scenariuszu istnieje w implementacji dla elementów listy i menu elementów, które nie mają sensu wszelkie poza elementem nadrzędnym wizualne, które należą do odpowiedniej kolekcji, aby przechowywać je w. Należy pamiętać, że te przypadki może nie zgłaszaj wyjątków, ponieważ może to być projektanta scenariusze, które zależą od zmiana elementu nadrzędnego elementy, które są chwilowo bez nadrzędnych "regularne".  
  
Ta metoda również zostanie przesłonięta w niektóre elementy, które są zazwyczaj element główny, takich jak <see cref="T:System.Windows.Window" />. Innym przypadkiem jest elementy będące element główny jawnego znaczników, ale automatyczne generowanie większej infrastruktury w skompilowanych drzewo logiczne (takie jak <see cref="T:System.Windows.Controls.Page" />). <see cref="T:System.Windows.Window" /> i <see cref="T:System.Windows.Controls.Page" /> implementacje celowo Zapieczętuj metody.</para>
        </block>
        <altmember cref="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy ten element uwzględnia właściwości stylu ze stylów motywu.</summary>
        <value>
          <see langword="true" /> Jeśli ten element nie zawiera funkcji ponownego obliczenia właściwości stylu motywu; wszystkie właściwości stylu pochodzące pochodzą style aplikacji lokalnej i ponownego obliczenia właściwości stylu motywu nie mają zastosowania. <see langword="false" /> Jeśli najpierw zastosuj style aplikacji, a następnie Zastosuj style motywów dla właściwości, które nie zostały wyraźnie ustawione w stylach aplikacji. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najbardziej typowe użycia tej właściwości jest pośrednich użycie w ramach metody ustawiającej stylu, który udostępnia styl z motywem.  
  
> [!IMPORTANT]
>  Jeśli ustawisz <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> do `true` w kontrolce, będzie pomijanie domyślnego szablonu kontrolki dostarczonych przez stylów motywu. Ten szablon kontrolki zazwyczaj obejmują prezentera zawartości i inne połączone elementy, które zapewniają podstawowy [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] funkcjonalność i wizualizacji dla formantu. Jeśli chcesz kontrolować w dalszym ciągu obsługuje te same funkcje co style motyw domyślny, należy podać alternatywny styl za pomocą szablonu kontrolki, która replikuje tę samą strukturę. Aby uzyskać więcej informacji, zobacz [omówienie tworzenia kontrolek](~/docs/framework/wpf/controls/control-authoring-overview.md).  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.OverridesDefaultStyleProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera element logiczne nadrzędny tego elementu.</summary>
        <value>Logiczne element nadrzędny tego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Parent%2A> może być `null` w przypadkach, gdy element został uruchomiony, ale nie jest dołączony do drzewa logicznego, po pewnym czasie łączącego się element poziomu głównego strony lub w obiekcie aplikacji.  
  
 Należy pamiętać, że logiczne nadrzędnego elementu nie może zmienić w zależności od funkcji Twojej aplikacji i utrzymania wartość tej właściwości nie zreflektuje tej zmiany. Można zwykle uzyskać wartość natychmiast, zanim zajdzie potrzeba jej.  
  
 Zobacz [drzewa w WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) więcej informacji na temat przechodzenia drzewo logiczne i scenariusze w przypadku, gdy za pomocą <xref:System.Windows.FrameworkElement.Parent%2A> jako technika elementu nadrzędnego jest odpowiednia odnajdywania.  
  
 Aparat właściwość potencjalnie ponownych wartości wszystkich właściwości elementu po jego pokrewnym, ponieważ niektóre właściwości dziedziczą wartości za pomocą drzewo logiczne. <xref:System.Windows.FrameworkElement.DataContext%2A> Która odnosi się do powiązania można również zmienić, gdy elementy są pokrewnym.  
  
 Zmiana elementu nadrzędnego zwykle tylko odbywa się za pośrednictwem manipulowanie kolekcjami, za pomocą dedykowanego metod dodawania i usuwania, lub przez ustawienie właściwości zawartości elementów.  
  
 Najbardziej typowym scenariuszem przy użyciu <xref:System.Windows.FrameworkElement.Parent%2A> właściwość jest do uzyskania odwołania, a następnie różnych <xref:System.Windows.FrameworkElement> wartości właściwości z obiektu nadrzędnego. Dla szablonów <xref:System.Windows.FrameworkElement.Parent%2A> szablonu ostatecznie będzie `null`. Aby usunąć ten punkt i rozszerzanie na drzewo logiczne, w którym szablon jest rzeczywiście stosowane, użyj <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.  
  
 Należy pamiętać, ta właściwość nie raportuje rodziców drzewa wizualnego w przypadkach, gdzie one się nieznacznie różnić od nadrzędnych drzewo logiczne. Drzewo wizualne elementy nadrzędne nie są zwykle ważne w sytuacjach ogólnego zastosowania, ale może być z elementami nadrzędnymi żądaną w niektórych przypadkach, poziomu visual. Zobacz <xref:System.Windows.Media.VisualTreeHelper>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje kod, który sprawdza, czy element nadrzędny, a następnie używa wartości właściwości z obiektu nadrzędnego, aby ustawić element podrzędny do dopasowania właściwości. W tym przypadku są to właściwości, które wpływają na rozmiar renderowania.  
  
 [!code-csharp[GeometryDesigner#FEParentProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometryDesigner/CSharp/Window1.xaml.cs#feparentproperty)]
 [!code-vb[GeometryDesigner#FEParentProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometryDesigner/visualbasic/window1.xaml.vb#feparentproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.TemplatedParent" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="ParentLayoutInvalidated">
      <MemberSignature Language="C#" Value="protected internal virtual void ParentLayoutInvalidated (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void ParentLayoutInvalidated(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub ParentLayoutInvalidated (child As UIElement)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void ParentLayoutInvalidated(System::Windows::UIElement ^ child);" />
      <MemberSignature Language="F#" Value="abstract member ParentLayoutInvalidated : System.Windows.UIElement -&gt; unit&#xA;override this.ParentLayoutInvalidated : System.Windows.UIElement -&gt; unit" Usage="frameworkElement.ParentLayoutInvalidated child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">Element podrzędny raportowania zmiany.</param>
        <summary>Obsługuje układ przyrostowy implementacje metod w podklasach wyspecjalizowane z <see cref="T:System.Windows.FrameworkElement" />. <see cref="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" /> jest wywoływane, gdy nie zawiera elementu podrzędnego unieważnił właściwości, który jest oznaczony w metadanych jako wpływających na miary elementu nadrzędnego lub Rozmieść przebiegi podczas układu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ten element ma element podrzędny, niektóre właściwości zostało unieważnione i, w którym właściwość została oznaczona jako <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> lub <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> w metadanych właściwości podczas rejestracji, ta metoda jest wywoływana. Wywołanie metody powiadamia element nadrzędny, w których element podrzędny określonego musi być ponownie mierzonego, jeśli ten element obsługuje częściową aktualizację (przyrostową) układu.  
  
 Domyślnie <xref:System.Windows.FrameworkElement> nie obsługuje układ przyrostowy, a następnie w <xref:System.Windows.FrameworkElement> klasy to metoda nie ma domyślnej implementacji. Scenariusz, w którym przesłaniania tej metody będą niezbędne jest typowy, ponieważ trzeba zmodyfikować domyślne zachowanie systemu na układ.  
  
 Przykładowy scenariusz implementacji może być, jeśli klasa ma ograniczenia typu dla elementów możliwe podrzędnych, które są znacznie bardziej restrykcyjny niż system poziomie struktury układu WPF. Ze względu na charakter tych elementów niestandardowych zmiany właściwości mogą celowo odraczanie podczas implementowania niektóre zachowania niestandardowe układy. Na przykład miary/Rozmieść zastąpienia metody, które spróbuj zoptymalizować element podrzędny renderować — dostęp próbny, może być odraczane w celu niektóre rodzaje zmian, które zazwyczaj spowoduje przekazanie innego układu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Kierunek, dla której powinna zostać określona zmiana potencjalnych fokus.</param>
        <summary>Określa następnego elementu, który otrzyma fokus względem tego elementu dla kierunku przepływu podana fokus, ale faktycznie nie Przenieś fokus.</summary>
        <returns>Następny element, który skupić się spowoduje przeniesienie do fokus rzeczywiście zostały przesunięta. Może zwracać <see langword="null" /> Jeśli fokus nie można przenieść względem tego elementu, dla podanego kierunku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.MoveFocus%2A> jest powiązane metody, która faktycznie Przenieś fokus.  
  
   
  
## Examples  
 Poniższy przykład wykonuje program obsługi, który obsługuje kilka dane wejściowe przycisku możliwe, każdy przycisk reprezentujący możliwe <xref:System.Windows.Input.FocusNavigationDirection>. Program obsługi śledzi element z bieżącym fokusem klawiatury i wywołania <xref:System.Windows.FrameworkElement.PredictFocus%2A> dla tego elementu i określa odpowiedni <xref:System.Windows.Input.FocusNavigationDirection> jako inicjowanie <xref:System.Windows.Input.TraversalRequest> podany parametr typu. Zamiast przechodzenia do tego elementu jako <xref:System.Windows.FrameworkElement.MoveFocus%2A> jak, program obsługi zmiany wymiary fizyczne przeznaczenia przewidywane fokus do celów wizualizacji.  
  
 [!code-csharp[FocusSample#FEPredictFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#fepredictfocus)]
 [!code-vb[FocusSample#FEPredictFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#fepredictfocus)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Określić jedną z następujących wskazówek w <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />. Te wskazówki są niedozwolone dla <see cref="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (ale prawne dla <see cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</exception>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa do użycia dla określonego mapowania nazwy obiektu.</param>
        <param name="scopedElement">Obiekt do mapowania.</param>
        <summary>Udostępnia metodę dostępu, która upraszcza dostęp do <see cref="T:System.Windows.NameScope" /> metodę rejestracji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest to wygodna metoda do wywołania <xref:System.Windows.NameScope.RegisterName%2A>. Implementacja sprawdzi elementy nadrzędne kolejnych, aż znajdzie odpowiednią <xref:System.Windows.NameScope> wdrażania, który zostanie znaleziony, wyszukując element, który implementuje <xref:System.Windows.Markup.INameScope>. Aby uzyskać więcej informacji na temat zakresy nazw, zobacz [zakresy WPF XAML nazw](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 Wywoływanie <xref:System.Windows.FrameworkElement.RegisterName%2A> jest niezbędne, aby można było poprawnie obsługiwać animacji scenorys dla aplikacji utworzonych w kodzie. Jest to spowodowane scenorysu jednego z kluczowych właściwości <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, używa nazw czasu wykonywania wyszukiwania zamiast będzie mogła wykonać odwołanie do elementu docelowego. Ta zasada obowiązuje, nawet jeśli ten element jest dostępny za pomocą odwołania z kodu. Aby uzyskać więcej informacji na temat Dlaczego trzeba zarejestrować nazwy dla celów scenorysu, zobacz [Przegląd Scenorysy](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
   
  
## Examples  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/ScopeExample.cs#namescopeexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/scopeexample.vb#namescopeexample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.NameScope.RegisterName(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Element do usunięcia.</param>
        <summary>Usuwa podany obiekt z tego elementu drzewo logiczne. <see cref="T:System.Windows.FrameworkElement" /> Aktualizuje wskaźniki nadrzędnego dotyczy drzewo logiczne do synchronizowania podczas usuwania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do wykonania w kolekcji obiektów, które reprezentują logiczne elementy podrzędne elementu. Może to zostać zrobione w metody pobierające właściwości lub metody ustawiające, funkcje obsługi klas z `Changed` zdarzenia, konstruktory, lub w kolekcji typów samodzielnie.  
  
 Dla autorów kontroli manipulowanie drzewo logiczne na tym poziomie nie jest zalecana praktyka, chyba że żaden z podanego formantu podstawowej klasy modele zawartości są odpowiednie. Należy wziąć pod uwagę podklasy na poziomie <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>, i <xref:System.Windows.Controls.HeaderedItemsControl>. Te klasy oferują model zawartości przy użyciu określonego wymuszania elementów podrzędnych logicznego za pośrednictwem dedykowanej [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)], a także obsługę innych funkcji, które są zazwyczaj pożądane w [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] kontrolki, np. stylów za pomocą szablonów.  
  
   
  
## Examples  
 Poniższy przykład implementuje `Child` właściwość niestandardową <xref:System.Windows.FrameworkElement> wykonujący implementacji warstwy visual. Metoda ustawiająca właściwości jest zaprojektowana tak, że jeśli wartość zostanie zmieniona, stara wartość zostanie usunięty z drzewa logicznego, a także kolekcję visual swoiste dla klas. Wartości są buforowane, a następnie nową wartość zostanie dodany do standardowego WPF framework poziomu drzewa logicznego i niestandardowej kolekcji visual.  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoView">
      <MemberSignature Language="C#" Value="public event System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.RequestBringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RequestBringIntoView As RequestBringIntoViewEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RequestBringIntoViewEventHandler ^ RequestBringIntoView;" />
      <MemberSignature Language="F#" Value="member this.RequestBringIntoView : System.Windows.RequestBringIntoViewEventHandler " Usage="member this.RequestBringIntoView : System.Windows.RequestBringIntoViewEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RequestBringIntoViewEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" /> jest wywoływana w tym elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie wskazuje do elementu nadrzędnego <xref:System.Windows.Controls.ScrollViewer> (lub klasy pochodnej) czy element, wywołuje <xref:System.Windows.FrameworkElement.RequestBringIntoView> zdarzeń powinny być widoczne w obrębie regionu przewijany. <xref:System.Windows.Controls.ScrollViewer> Następnie spowoduje oznaczenie <xref:System.Windows.FrameworkElement.RequestBringIntoView> zdarzeń jako obsługiwane za pomocą klasy obsługi zdarzenia. Ogólnie rzecz biorąc <xref:System.Windows.FrameworkElement.RequestBringIntoView> zdarzeń danych nie powinien być oznaczony obsługiwanego przez każdej klasy, które sterują regionu przewijania lub dowolnego wystąpienia programu obsługi, ponieważ w ten sposób zakłócać zamierzony cel elementu, który wywołuje się, <xref:System.Windows.FrameworkElement.BringIntoView%2A>.  
  
<a name="routedEventInfo_RequestBringIntoView"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.RequestBringIntoViewEvent>|  
|Strategii routingu|Propagacja|  
|Delegate|<xref:System.Windows.RequestBringIntoViewEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoViewEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent RequestBringIntoViewEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent RequestBringIntoViewEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly RequestBringIntoViewEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ RequestBringIntoViewEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable RequestBringIntoViewEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /> zdarzenia trasowanego.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkElement.Resources" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia słownik zasobów lokalnie zdefiniowane.</summary>
        <value>Bieżący lokalnie zdefiniowany słownik zasobów, w której każdy zasób jest możliwy przez klucz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Słowniki zasobów, które mogą być definiowane częściowo lub całkowicie w [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] są zazwyczaj tworzone jako prvek Vlastnosti i zwykle znajdują się na element główny dla dowolnej pojedynczej strony lub aplikacji. Wprowadzenie do słownika zasobów na tym poziomie sprawia, że łatwiej odnaleźć z elementów podrzędnych poszczególne strony (lub na dowolnej stronie w przypadku aplikacji). W większości scenariuszy aplikacji, zaleca się, że style można zdefiniować jako obiekt elementów w słowniku zasobów, lub można zdefiniować jako zasobów zewnętrznych, tak aby zasobu stylu całej może być samodzielne (takie podejście pomaga oddzielne projektanta obowiązki z odpowiedzialności dla deweloperów, oddzielając pliki fizyczne, które powinny być edytowane).  
  
 Należy pamiętać, że właściwość ta zwraca tylko słownik zasobów zadeklarowany bezpośrednio w ramach tego elementu. Stanowi to odmianę proces wyszukiwania zasobów rzeczywistych, w którym nie zawiera elementu podrzędnego ma dostęp do zasobów zdefiniowane w każdym elemencie nadrzędnym, wyszukiwanie cyklicznie w górę.  
  
 Zasobów także mogą być przywoływane przez kod z kolekcji, ale należy pamiętać, że zasoby są tworzone w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] zdecydowanie nie będą dostępne do czasu po <xref:System.Windows.FrameworkElement.Loaded> jest wywoływane przez element, który deklaruje słownika. W rzeczywistości zasoby są parsowane asynchronicznie, a nie nawet <xref:System.Windows.FrameworkElement.Loaded> zdarzeń jest zapewnienie, że możesz odwoływać się do [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] zdefiniowany zasób. Z tego powodu należy zwykle tylko dostęp [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] określonych zasobów w ramach kodu w czasie wykonywania, lub za pośrednictwem innych [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] technik, takich jak style lub odwołania do rozszerzenia zasobu dla wartości atrybutów. Gdy uzyskujesz dostęp do zasobów za pomocą kodu jest zasadniczo odpowiednikiem odniesienia z [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 Podstawowe <xref:System.Windows.ResourceDictionary> obsługuje metody wymagane do dodawania, usuwania lub zbadać zasobów w kolekcji za pomocą kodu. <xref:System.Windows.FrameworkElement.Resources%2A> Właściwość jest do ustawienia scenariusza całkowicie zamiany kolekcji zasobów w nowej lub innego elementu <xref:System.Windows.ResourceDictionary>.  
  
 Należy zauważyć, że [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] składni przedstawionej nie zawiera element dla <xref:System.Windows.ResourceDictionary>. Jest to przykład składni niejawnej kolekcji; Znacznik reprezentujący element w kolekcji można pominąć. Elementy, które są dodawane jako elementy do kolekcji są określane w zamian. Aby uzyskać więcej informacji o kolekcjach niejawne i [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], zobacz [składnia XAML w szczegółów](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md). Jeden przypadek gdzie <xref:System.Windows.ResourceDictionary> nadal jawnie określono, ponieważ są wprowadzające scalonych słowników, w którym to przypadku czy zwykle Brak elementów podrzędnych do tego elementu <xref:System.Windows.ResourceDictionary>. Aby uzyskać więcej informacji, zobacz [scalone słowniki zasobów](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *oneOrMoreResourceElements*  
 Jeden lub więcej elementów obiektu, z których każdy definiuje zasób. Każdy element właściwości zasobów w ramach każdej <xref:System.Windows.ResourceDictionary> musi mieć unikatową wartość dla [x: Key — dyrektywa](~/docs/framework/xaml-services/x-key-directive.md), który służy jako unikatowego klucza, gdy są one pobierane <xref:System.Windows.ResourceDictionary>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
        <related type="Article" href="http://msdn.microsoft.com/library/1985cd45-f197-42d5-b75e-886add64b248">x: Key — atrybut</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza powiązania do tego elementu, dla właściwości określonej zależności.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">Identyfikuje właściwość docelowego, gdzie należy ustanowić powiązanie.</param>
        <param name="path">Nazwa właściwości źródłowego lub ścieżka do właściwości użytej dla wiązania.</param>
        <summary>Dołącza powiązania do tego elementu, w oparciu o nazwę właściwości podane źródło jako kwalifikacją ścieżka do źródła danych.</summary>
        <returns>Rejestruje warunki powiązania. Zwrócona wartość może być przydatne w przypadku sprawdzania błędów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest to wygodna metoda do wywoływania <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, która przekazuje bieżącego wystąpienia jako <xref:System.Windows.DependencyObject>i tworzy nowy <xref:System.Windows.Data.Binding> na podstawie udostępnionych `path` parametru. Podpis ten jest bardziej wygodne podczas ustanawiania powiązania prostym, domyślnym. Jeśli jest konieczne określanie żadnych właściwości powiązania do wartości niedomyślnej warunków lub chcesz użyć <xref:System.Windows.Data.MultiBinding> lub <xref:System.Windows.Data.PriorityBinding>, należy użyć <xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> podpisu.  
  
   
  
## Examples  
 W poniższym przykładzie ustawiono powiązania przy użyciu określonej ścieżki.  
  
 [!code-csharp[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#setbindingpath)]
 [!code-vb[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#setbindingpath)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">Określa właściwość, której należy ustanowić powiązanie.</param>
        <param name="binding">Przedstawia szczegółowe informacje na temat wiązania danych.</param>
        <summary>Dołącza powiązania do tego elementu, na podstawie obiektu podane powiązanie.</summary>
        <returns>Rejestruje warunki powiązania. Zwrócona wartość może być przydatne w przypadku sprawdzania błędów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest to wygodna metoda do wywoływania <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, która przekazuje bieżącego wystąpienia jako <xref:System.Windows.DependencyObject>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetFlowDirection">
      <MemberSignature Language="C#" Value="public static void SetFlowDirection (System.Windows.DependencyObject element, System.Windows.FlowDirection value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFlowDirection(class System.Windows.DependencyObject element, valuetype System.Windows.FlowDirection value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFlowDirection (element As DependencyObject, value As FlowDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFlowDirection(System::Windows::DependencyObject ^ element, System::Windows::FlowDirection value);" />
      <MemberSignature Language="F#" Value="static member SetFlowDirection : System.Windows.DependencyObject * System.Windows.FlowDirection -&gt; unit" Usage="System.Windows.FrameworkElement.SetFlowDirection (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FlowDirection" />
      </Parameters>
      <Docs>
        <param name="element">Element, który określa kierunek przepływu.</param>
        <param name="value">Wartość wyliczenia, określając kierunku.</param>
        <summary>Ustawia wartość <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> dołączonych właściwości dla podanego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda obsługuje składnię dołączoną właściwość <xref:System.Windows.FrameworkElement.FlowDirection%2A> właściwości, w związku z tym co podrzędnych elementów podana <xref:System.Windows.FrameworkElement> do określania kierunku przepływu dla rozmieszczenia w ramach jego elementu nadrzędnego. Można ustawić wartości na bieżącym <xref:System.Windows.FrameworkElement>, użyj bezpośrednio [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] akcesor <xref:System.Windows.FrameworkElement.FlowDirection%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Właściwość, do której zasób jest powiązany.</param>
        <param name="name">Nazwa zasobu.</param>
        <summary>Wyszukuje zasób o określonej nazwie i konfiguruje zasobu odwołanie do niej dla określonej właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Odwołanie do zasobu jest podobny do stosowania [dynamicresource — rozszerzenie znaczników](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) w znacznikach. Odwołanie do zasobu tworzy wyrażenie wewnętrzne, które dostarcza wartość określonej właściwości na podstawie odroczonego czasu wykonywania. Będzie można ponownie obliczyć wyrażenia zawsze wtedy, gdy słownik zasobów zmienione wskazuje wartość informującą za pośrednictwem wewnętrznego zdarzenia lub zawsze wtedy, gdy bieżącym elementem pokrewnym (zmiany elementu nadrzędnego zmienić ścieżki wyszukiwania słownik).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca, czy procesy serializacji należy serializować zawartość <see cref="P:System.Windows.FrameworkElement.Resources" /> właściwości.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="P:System.Windows.FrameworkElement.Resources" /> wartość właściwości powinna być Zserializowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spowoduje to zwrócenie `true` tak długo, jak istnieje co najmniej jeden zasób z kluczem w lokalnej <xref:System.Windows.FrameworkElement.Resources%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca, czy procesy serializacji należy serializować zawartość <see cref="P:System.Windows.FrameworkElement.Style" /> właściwości.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="P:System.Windows.FrameworkElement.Style" /> wartość właściwości powinna być Zserializowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spowoduje to zwrócenie `true` Jeśli <xref:System.Windows.Style> lokalnie jest ustawiona.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTriggers">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTriggers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTriggers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeTriggers" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTriggers () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTriggers();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTriggers : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeTriggers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca, czy procesy serializacji należy serializować zawartość <see cref="P:System.Windows.FrameworkElement.Triggers" /> właściwości.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="P:System.Windows.FrameworkElement.Triggers" /> wartość właściwości powinna być Zserializowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca `true` Jeśli <xref:System.Windows.FrameworkElement.Triggers%2A> lokalnie ustawiono właściwość.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.SizeChangedEventHandler SizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SizeChangedEventHandler SizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SizeChanged As SizeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SizeChangedEventHandler ^ SizeChanged;" />
      <MemberSignature Language="F#" Value="member this.SizeChanged : System.Windows.SizeChangedEventHandler " Usage="member this.SizeChanged : System.Windows.SizeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy albo <see cref="P:System.Windows.FrameworkElement.ActualHeight" /> lub <see cref="P:System.Windows.FrameworkElement.ActualWidth" /> właściwości Zmień wartość w tym elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia trasowane bezpośrednie nie wykonuj trasy, są obsługiwane tylko w obrębie tego samego elementu, na którym są wywoływane. Bezpośrednie zdarzenia trasowane obsługują innych zachowań zdarzenia trasowanego: zbieranie dostępne programy obsługi pomocy technicznej i mogą być używane jako <xref:System.Windows.EventTrigger> w stylu.  
  
 System układu odczytuje właściwości w ramach <xref:System.Windows.SizeChangedEventArgs> klasy argumentu tego wydarzenia, aby ustalić, czy zmiany rozmiaru zgłoszonych należy uznać za istotne. Dzięki temu system układu lub implementacjach użytkownika układ specyficznej dla kontroli, aby uniknąć wymuszania zmiany układu z powodu wizualnie imperceptible różnice między wartości szerokości lub wysokości stare i nowe. Różnice imperceptible może wynikać zaokrąglania lub ten sam wynik obliczenia typy danych zmiennopozycyjnych.  
  
<a name="routedEventInfo_SizeChanged"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.SizeChangedEvent>|  
|Strategii routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.SizeChangedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Height" />
        <altmember cref="P:System.Windows.FrameworkElement.Width" />
      </Docs>
    </Member>
    <Member MemberName="SizeChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent SizeChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent SizeChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ SizeChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable SizeChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkElement.SizeChanged" /> zdarzenia trasowanego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia trasowanego identyfikatory są tworzone, jeśli są rejestrowane zdarzenia trasowane. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metody dodawania właścicieli dla zdarzenia. Aby dodać funkcje obsługi klas, można użyć tych identyfikatorów.  
  
 Aby uzyskać więcej informacji na temat rejestrowania zdarzenia trasowane, zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Aby uzyskać więcej informacji na temat przy użyciu identyfikatorów zdarzenia trasowanego, aby dodać funkcje obsługi klas, zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie wartości źródła dla dowolnej właściwości istniejących powiązań, w tym elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie tworzy alias dla <xref:System.Windows.Data.Binding.SourceUpdated> zdarzenia, które jest wywoływane przez żaden <xref:System.Windows.Data.Binding> skojarzone z tym elementem.  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object SourceUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.SourceUpdated" />
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia styl używany przez ten element, gdy jest on renderowany.</summary>
        <value>Zastosowane, styl niestandardowy element, jeśli jest obecny. W przeciwnym razie <see langword="null" />. Wartość domyślna dla zbudowanego domyślnie <see cref="T:System.Windows.FrameworkElement" /> jest <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku kontrolek bieżącego stylu jest często zawartym w stylu domyślnym z motywów sterowania lub przy użyciu stylów ogólnie zastosować do kontrolek tego typu przez zasoby na poziomie strony lub aplikacji (styl niejawny). Ta właściwość jest domyślny nie zostały ustawione lub zwrotu style (motyw), ale Przywraca styl niejawny lub jawne styl, który działa w elemencie. W przypadku jawnego lub niejawnego stylów nie ma znaczenia, czy styl jest określony jako zasób zdefiniowane lokalnie.  
  
 Ustawianie stylów mają pewne ograniczenia. Możesz zresetować całą <xref:System.Windows.FrameworkElement.Style%2A> nową właściwość <xref:System.Windows.Style> w dowolnym momencie, która wymusi recomposition układu. Jednak niezwłocznie po stylu jest umieszczany w użyciu przez element załadować <xref:System.Windows.Style> powinny być traktowane jako zapieczętowany. Podjęto próbę dokonania zmiany do żadnej poszczególne właściwości stylu w użyciu (takie jak niczego w obrębie kolekcji <xref:System.Windows.Style.Setters%2A>) powoduje zgłoszenie wyjątku. Styl, który jest zdefiniowany w znacznikach uznaje się będzie używana zaraz po jego załadowaniu ze słownika zasobów (dla zasobów) lub strony, w której znajduje się w obrębie ładowania (style wbudowane).  
  
 <xref:System.Windows.FrameworkElement.Style%2A> jest to właściwość zależności o priorytecie specjalne. Lokalnie ustawiony styl ogólnie operuje na najwyższy priorytet w systemie właściwości. Jeśli <xref:System.Windows.FrameworkElement.Style%2A> ma wartość null w tym momencie podczas ładowania właściwości system sprawdza, czy style niejawne w zasobach lokalnych lub aplikacji, określających tego typu. Jeśli styl nadal o wartości null po wykonaniu tego kroku, a następnie styl działając w celach prezentacji zwykle pochodzi z styl domyślny (motyw), ale domyślny styl nie jest zwracana w <xref:System.Windows.FrameworkElement.Style%2A> wartości właściwości. Zobacz [następstwo wartości właściwości](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md) lub [Tworzenie szablonów i stylów](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object Style="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_Style"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *resourceExtension*  
 Jedną z następujących:, lub. Zobacz [zasoby XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Klucz, który identyfikuje styl żądanej. Klucz, który odwołuje się do istniejącego zasobu w <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Składnia elementu właściwości jest technicznie możliwe, ale nie jest zalecane w przypadku większości scenariuszy stylu. Zobacz [style i Szablony wbudowane](~/docs/framework/wpf/advanced/inline-styles-and-templates.md). Odwołanie do wiązania za pomocą lub <xref:System.Windows.Data.Binding> jest również możliwe, ale rzadko.  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.StyleProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano stylu w słowniku zasobów.  
  
 [!code-xaml[FEResource#StyleProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty)]  
[!code-xaml[FEResource#StyleProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty2)]  
[!code-xaml[FEResource#StyleProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty3)]  
[!code-xaml[FEResource#StyleProperty4](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.Style" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nazwa żądanej właściwości otoczenia.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> metody.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="propertyName" /> jest dostępna; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.FrameworkElement> wystąpienia jest rzutowany na <xref:System.Windows.Markup.IQueryAmbient> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość dowolnego obiektu, który może służyć do przechowywania informacji niestandardowych o tym elemencie.</summary>
        <value>Wartość zamierzona. Ta właściwość nie ma wartości domyślnej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest odpowiednikiem właściwości tagu w modelach programowania inne firmy Microsoft, takie jak Visual Basic dla aplikacji lub Windows Forms. <xref:System.Windows.FrameworkElement.Tag%2A> mają na celu dostarczenie istniejące właściwości lokalizacji przechowywania podstawowych informacji niestandardowych o dowolnej <xref:System.Windows.FrameworkElement> bez konieczności do podklasy elementu.  
  
 Ponieważ ta właściwość ma obiektu, należy użyć użycie elementu właściwości, aby ustawić <xref:System.Windows.FrameworkElement.Tag%2A> właściwości w XAML coś innego niż obiekt, za pomocą konwertera typu znane i wbudowane, takie jak ciąg. Obiekty używane w ten sposób nie są zwykle w ramach standardowych przestrzeni nazw WPF i w związku z tym może wymagać mapowanie przestrzeni nazw do obszaru nazw zewnętrznych w celu wprowadzone jako elementy XAML. Aby uzyskać więcej informacji, zobacz [przestrzeni nazw XAML i Namespace mapowania dla WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md) i [XAML oraz klas niestandardowe dla WPF](~/docs/framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md).  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.TagProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.Tag" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość docelowa dla żadnego powiązania właściwości, w tym elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie tworzy alias dla <xref:System.Windows.Data.Binding.TargetUpdated> zdarzenia, które jest wywoływane przez żaden <xref:System.Windows.Data.Binding> skojarzone z tym elementem. Zwykle oznacza to, że w danym powiązanie to powiązanie dwustronne i właściwości powiązanej zależności potwierdza, że poprzednią wartość właściwości teraz jest nieprawidłowa przy uwzględnieniu sprawdzania poprawności ani pamięci podręcznej schematu, który obsługuje właściwości lub źródła danych.  
  
 Użyj danych zdarzenia <xref:System.Windows.FrameworkElement.TargetUpdated> zdarzenia w celu określenia konkretnej właściwości, która zgłasza aktualizacja wartości docelowej.  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object TargetUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.TargetUpdated" />
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do szablonu elementu nadrzędnego tego elementu. Ta właściwość nie jest istotne, jeśli element nie został utworzony za pomocą szablonu.</summary>
        <value>Element którego <see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> spowodował ten element ma zostać utworzony. Ta wartość jest często <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.TemplatedParent%2A> często `null` dla obiektów, które są tworzone w zaznaczaniu aplikacji lub kodu. Jest to spowodowane bezpośrednio, utworzyć te obiekty nie za pomocą szablonu. Obiekt odwołania otrzymywane przez zalet drzewo logiczne z katalogu głównego, lub Typowa nazwa odwołania, nie pochodzą z szablonu.  
  
 Przypadków, gdy <xref:System.Windows.FrameworkElement.TemplatedParent%2A> może nie być `null` obejmują operacje takie jak testowanie trafień obsługi zdarzeń dla niektórych niskiego poziomu zdarzenia wejściowe zalet drzewa wizualnego, za pomocą <xref:System.Windows.Media.VisualTreeHelper>, lub Praca z modułami wyliczającymi, które mogą zwracać elementy, które nadeszły za pomocą szablonów. Innym przypadkiem jest, jeśli należy wywołać specjalnie <xref:System.Windows.FrameworkTemplate.FindName%2A> względem istniejącej <xref:System.Windows.FrameworkTemplate> i pracować z zwróconego obiektu.  
  
 Szablony są obiektami faktycznie udostępnionych, w których zawartość szablonu są tworzone tylko raz. W związku z tym Jeśli możesz uzyskać odwołanie do obiektu do elementu, który pochodzi z szablonem, może się okazać, że jawnego drzewo logiczne nie dociera do głównej strony. Aby połączyć takie odwołanie szablonu do drzewa logicznego strony, należy pobrać <xref:System.Windows.FrameworkElement.TemplatedParent%2A> wartości i dalsze przechodzenie tego drzewa elementów zgodnie z potrzebami.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.ToolTip)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt etykietki narzędzia, która jest wyświetlana dla tego elementu w [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</summary>
        <value>Obiekt etykietki narzędzia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość tej właściwości jest typu <xref:System.Windows.Controls.ToolTip>, a następnie ta wartość jest etykietka narzędzia, które będą używane w [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].  Jeśli wartość jest innego typu, a następnie ta wartość będzie służyć jako *zawartości* dla <xref:System.Windows.Controls.ToolTip> udostępniane (wykonane), przez system. Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Controls.ToolTipService>. Klasa service udostępnia dołączone właściwości, których można użyć w celu dalszego dostosowywania <xref:System.Windows.Controls.ToolTip>.  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *toolTipContent*  
 Ciąg, który będzie wyświetlany tekst dla <xref:System.Windows.FrameworkElement.ToolTip%2A>.  
  
 *toolTipObjectContent*  
 Niektórych obiektów w formularzu elementów obiektu, który ma zostać użyty jako zawartość dla <xref:System.Windows.FrameworkElement> . Zazwyczaj powinien to być <xref:System.Windows.FrameworkElement> lub inny element, który tworzy składania układu dla <xref:System.Windows.FrameworkElement.ToolTip%2A>, po pewnym czasie zawierające tekst w obrębie składania. W tym użycie <xref:System.Windows.Controls.ToolTip> zostanie utworzony element niejawnie z przeanalizowany element [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]i *toolTipObjectContent* zawartości jest ustawiony jako jego <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> właściwości.  
  
 <`ToolTip` .../>  
 Zobacz <xref:System.Windows.Controls.ToolTip>.  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ToolTipProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Windows.Controls.ToolTip> w kodzie, a następnie ustawia <xref:System.Windows.FrameworkElement.ToolTip%2A> właściwość <xref:System.Windows.Controls.Primitives.StatusBar> kontroli.  
  
 [!code-csharp[StatusBar#MakeProgressBar](~/samples/snippets/csharp/VS_Snippets_Wpf/StatusBar/CSharp/Window1.xaml.cs#makeprogressbar)]
 [!code-vb[StatusBar#MakeProgressBar](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StatusBar/visualbasic/window1.xaml.vb#makeprogressbar)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje zaraz przed zamknięciem dowolnej etykietki narzędzia w elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oznaczanie <xref:System.Windows.FrameworkElement.ToolTipClosing> zdarzeń jako obsłużony, nie powoduje anulowania zamknięcia etykietki narzędzia. Gdy zostanie wyświetlona etykietka narzędzia, zamyka etykietki narzędzia odbywa się tylko w odpowiedzi na interakcję z użytkownikiem za pomocą interfejsu użytkownika.  
  
 To zdarzenie nie może być <xref:System.Windows.EventTrigger> w stylu. Jest to spowodowane pole identyfikatora tego zdarzenia ponownie używa implementacji usługi, który nie ujawnia metody zdarzeń dodawania/usuwania dla zdarzenia poziomu usług.  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ToolTipClosingEvent>|  
|Strategii routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   Zastąp <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> zaimplementować obsługę klasy dla tego zdarzenia w klasach pochodnych.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /> zdarzenia trasowanego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia trasowanego identyfikatory są tworzone, jeśli są rejestrowane zdarzenia trasowane. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metody dodawania właścicieli dla zdarzenia. Aby dodać funkcje obsługi klas, można użyć tych identyfikatorów.  
  
 Aby uzyskać więcej informacji na temat rejestrowania zdarzenia trasowane, zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Aby uzyskać więcej informacji na temat przy użyciu identyfikatorów zdarzenia trasowanego, aby dodać funkcje obsługi klas, zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po otwarciu dowolnej etykietki narzędzia w elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uniemożliwić etykietki narzędzia w Interfejsie użytkownika programu obsługi dla <xref:System.Windows.FrameworkElement.ToolTipOpening> oznaczyć <xref:System.Windows.Controls.ToolTipEventArgs> danych zdarzeń obsługiwanych. W przeciwnym razie zostanie wyświetlona etykietka narzędzia, za pomocą wartości <xref:System.Windows.FrameworkElement.ToolTip%2A> właściwość jako zawartość etykietki narzędzia. Inny scenariusz możliwe jest, można napisać program obsługi, który zresetuje wartość <xref:System.Windows.FrameworkElement.ToolTip%2A> właściwości dla elementu, który jest źródło zdarzenia, po prostu, zanim zostanie wyświetlona etykietka narzędzia.  
  
 <xref:System.Windows.FrameworkElement.ToolTipOpening> nie zostanie wygenerowany, jeśli wartość <xref:System.Windows.FrameworkElement.ToolTip%2A> jest `null` lub w inny sposób nie ustawiono. Nie należy ustawiać celowo <xref:System.Windows.FrameworkElement.ToolTip%2A> do `null` podczas, gdy kontrolka tooltip jest otwarta, lub otwierając; to nie przyniesie efektu zamknięcia etykietki narzędzia, a zamiast tego utworzy niepożądanych artefakt visual w interfejsie użytkownika.  
  
 <xref:System.Windows.FrameworkElement.ToolTipOpening> Zdarzeń nie może być <xref:System.Windows.EventTrigger> w stylu. Jest to spowodowane pole identyfikatora tego zdarzenia ponownie używa implementacji usługi, który nie ujawnia metody zdarzeń dodawania/usuwania dla zdarzenia poziomu usług.  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ToolTipOpeningEvent>|  
|Strategii routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   Zastąp <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> zaimplementować obsługę klasy dla tego zdarzenia w klasach pochodnych.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /> zdarzenia trasowanego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia trasowanego identyfikatory są tworzone, jeśli są rejestrowane zdarzenia trasowane. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metody dodawania właścicieli dla zdarzenia. Aby dodać funkcje obsługi klas, można użyć tych identyfikatorów.  
  
 Aby uzyskać więcej informacji na temat rejestrowania zdarzenia trasowane, zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Aby uzyskać więcej informacji na temat przy użyciu identyfikatorów zdarzenia trasowanego, aby dodać funkcje obsługi klas, zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.ToolTip" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Triggers">
      <MemberSignature Language="C#" Value="public System.Windows.TriggerCollection Triggers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TriggerCollection Triggers" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Triggers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Triggers As TriggerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TriggerCollection ^ Triggers { System::Windows::TriggerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Triggers : System.Windows.TriggerCollection" Usage="System.Windows.FrameworkElement.Triggers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.TriggerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję wyzwalaczy ustanawiany bezpośrednio w tym elemencie lub przez elementy podrzędne.</summary>
        <value>Kolekcję silnie typizowaną <see cref="T:System.Windows.Trigger" /> obiektów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Tę właściwość można ustawić tylko [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] za pomocą składni kolekcji pokazano lub uzyskiwania dostępu do obiektu kolekcji, a przy użyciu jego różnych metod, takich jak dodawanie. Właściwość do dostępu do samego obiektu kolekcji tylko do odczytu, samotnou kolekci odczytu i zapisu. Właściwość istnieje tylko na elementy główne; próbuje znaleźć go lub ustaw go w innym miejscu spowoduje zgłoszenie wyjątku.  
  
 Ta właściwość nie włącza zbadać wyzwalacze, które istnieją w ramach stylów używany w tym elemencie. Informuje jedynie zbiór wyzwalacze, które dosłownie są dodawane do kolekcji, w znaczników lub innego kodu. Elementy zwykle nie mają takie elementy istniejące domyślnie (za pomocą szablonu na przykład); jest to bardziej powszechne wyzwalaczy, które pochodzą z składania kontroli określone w stylach zamiast tego.  
  
 Pod kątem zachowania (i podjęcie próby ustalenie, który pochodzi z deklarowana przez który element <xref:System.Windows.FrameworkElement.Triggers%2A> kolekcji), zarówno Warunek wyzwalający efekt wyzwalacza mogą znajdować się na ten element i mogą znajdować się na jego elementy podrzędne w drzewie logicznym. Należy pamiętać, że jeśli używasz takich jak zdarzenia okresu istnienia <xref:System.Windows.FrameworkElement.Loaded> można pobrać tej kolekcji, wyzwala element podrzędny mogą jeszcze nie znajdować w pełni załadowany i kolekcji będą mniejsze niż w przypadku naprawdę w czasie wykonywania.  
  
 Należy zauważyć, że kolekcja wyzwalaczy na element obsługuje tylko <xref:System.Windows.EventTrigger>, nie wyzwalacze właściwości (<xref:System.Windows.Trigger>). Jeśli potrzebujesz wyzwalacze właściwości, należy umieścić je w obrębie stylu lub szablonu, a następnie przypisz tego stylu lub szablonu albo do elementu za pomocą <xref:System.Windows.FrameworkElement.Style%2A> właściwości lub pośrednio poprzez odwołanie do stylu niejawnego.  
  
<a name="xamlPropertyElementUsage_Triggers"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.Triggers>  
    oneOrMoreTriggers  
  </object.Triggers>  
</object>  
```  
  
<a name="xamlValues_Triggers"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *oneOrMoreTriggers*  
 Co najmniej jedna definicja <xref:System.Windows.EventTrigger> elementów. Każdy taki wyzwalacz powinien zawierać akcje prawidłowe scenorysu i odwołania. Należy pamiętać, że tej kolekcji można ustalić wyłącznie w elemencie głównym strony. Aby uzyskać więcej informacji, zobacz [Przegląd Scenorysy](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.EventTrigger" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Identyfikator klucza zasobu, który ma zostać odnaleziona.</param>
        <summary>Wyszukuje zasób z określonym kluczem, a następnie zwraca tego zasobu, jeśli znaleziono.</summary>
        <returns>Znaleziono zasobu lub <see langword="null" /> Jeśli żaden z zasobów z dostępnego <paramref name="key" /> zostanie znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zasób nie zostanie znaleziony w elemencie wywołującym, drzewa zasobu nadrzędnego jest przeszukiwany w górę za pośrednictwem drzewa logicznego, w taki sam sposób, który będzie drzewa wyszukiwanych w przypadku zasobów zażądano według klucza w czasie wykonywania. Metoda ta zwraca `null` tylko wtedy, gdy żaden zasób tego klucza, istniał w dowolnym miejscu w drzewie zasobów na istniejące warunki drzewa w czasie, <xref:System.Windows.FrameworkElement.TryFindResource%2A> jest wywoływana.  
  
 Zwykle będzie od razu rzutować wartości zwróconej na typ właściwości, które próbowano ustawić za pomocą wartości zwracane zasobów.  
  
 <xref:System.Windows.FrameworkElement.FindResource%2A> Metoda ma zachowanie podobne, z tą różnicą, że zgłasza wyjątek, jeśli został zwrócony żaden z zasobów przy użyciu podanego klucza.  
  
   
  
## Examples  
 Poniższy przykład jest implementowany jako procedura obsługi przycisku, którym przycisk jest kliknięty ustawia tłem do zdefiniowany zasób pędzla można uzyskać przez wywołanie <xref:System.Windows.FrameworkElement.TryFindResource%2A> na siebie. To przegląda drzewo elementów i umożliwia znalezienie zasobu (samego zasobu jest zdefiniowana w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] i nie jest wyświetlana).  
  
 [!code-csharp[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#fetryfindresource)]
 [!code-vb[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#fetryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy element zostanie usunięty z obrębu drzewa elementów załadowanych elementów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia trasowane bezpośrednie nie wykonuj trasy, są obsługiwane tylko w obrębie tego samego elementu, na którym są wywoływane. Bezpośrednie zdarzenia trasowane obsługują innych zachowań zdarzenia trasowanego: zbieranie dostępne programy obsługi pomocy technicznej i mogą być używane jako <xref:System.Windows.EventTrigger> w stylu.  
  
 <xref:System.Windows.FrameworkElement.Loaded> i <xref:System.Windows.FrameworkElement.Unloaded> może być zarówno wywołane kontrolek w wyniku zmiany motywu systemu zainicjowanego przez użytkownika. Zmień motyw powoduje unieważnienie szablonu kontrolki i zawartej drzewa wizualnego, co z kolei powoduje, że cały formant, aby zwolnić i załaduj ponownie. W związku z tym <xref:System.Windows.FrameworkElement.Unloaded> nie zakłada się, że występuje tylko w okienku nawigacji strony.  
  
 Należy pamiętać, że <xref:System.Windows.FrameworkElement.Unloaded> zdarzeń nie jest inicjowane po aplikacja rozpoczyna zamykanie. Zamknięcia aplikacji występuje, gdy warunek określony przez <xref:System.Windows.Application.ShutdownMode%2A> właściwość występuje. Jeśli umieścisz kod porządkujący w ramach programu obsługi dla <xref:System.Windows.FrameworkElement.Unloaded> zdarzenia, takie jak w przypadku <xref:System.Windows.Window> lub <xref:System.Windows.Controls.UserControl>, nie może być potrzebny zgodnie z oczekiwaniami.  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.UnloadedEvent>|  
|Strategii routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.FrameworkElement.Unloaded" /> zdarzenia trasowanego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia trasowanego identyfikatory są tworzone, jeśli są rejestrowane zdarzenia trasowane. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metody dodawania właścicieli dla zdarzenia. Aby dodać funkcje obsługi klas, można użyć tych identyfikatorów.  
  
 Aby uzyskać więcej informacji na temat rejestrowania zdarzenia trasowane, zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Aby uzyskać więcej informacji na temat przy użyciu identyfikatorów zdarzenia trasowanego, aby dodać funkcje obsługi klas, zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa pary nazwa obiektu do usunięcia z bieżącego zakresu.</param>
        <summary>Upraszcza dostęp do <see cref="T:System.Windows.NameScope" /> cofnięcia rejestracji metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystarczy wyrejestrować nazwy Jeśli zamierzasz ponownie zarejestrować inny element o takiej samej nazwie.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ponowne zastosowanie domyślnego stylu do bieżącego <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRounding">
      <MemberSignature Language="C#" Value="public bool UseLayoutRounding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseLayoutRounding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberSignature Language="VB.NET" Value="Public Property UseLayoutRounding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseLayoutRounding { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseLayoutRounding : bool with get, set" Usage="System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy układ zaokrąglanie powinno być stosowane do rozmiaru i położenia tego elementu podczas układu.</summary>
        <value>
          <see langword="true" /> Jeśli zastosowano zaokrąglania układ; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> właściwość elementu ma `true`, wszystkie wartości całkowite inne niż pikseli, które są obliczane podczas <xref:System.Windows.UIElement.Measure%2A> i <xref:System.Windows.UIElement.Arrange%2A> przebiegi są zaokrąglane do całego pikseli.  
  
 Ta właściwość jest dziedziczona przez elementy podrzędne.  
  
> [!NOTE]
>  Należy ustawić <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> do `true` dla elementu głównego. System układu dodaje współrzędne podrzędnych na współrzędne obiektu nadrzędnego; w związku z tym jeśli współrzędne obiektu nadrzędnego nie znajdują się w granicach pikseli, współrzędne podrzędne również nie są w granicach pikseli. Jeśli <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> nie można ustawić w katalogu głównym, ustaw <xref:System.Windows.UIElement.SnapsToDevicePixels%2A> w elemencie podrzędnym wpływ, jaki chcesz uzyskać.  
  
 Rysowanie obiektów w granicach pikseli eliminuje półprzezroczyste krawędzie, generowane przez wygładzanie, gdy krawędź znajduje się w środku pikseli urządzenia. Poniższa ilustracja przedstawia dane wyjściowe wiersza pojedynczego szerokość piksela, który znajduje się w środku pikseli urządzenia. Wiersz po lewej stronie nie korzysta się z zaokrąglaniem układ i jest wygładzanie. Wiersz po prawej stronie korzysta z zaokrąglaniem układu.  
  
 ![Chroniących&#45;alias wiersza w porównaniu do linii piksela. ] (~/add/media/pixelsnaplinecompare.PNG "Wygładzanie wiersza w porównaniu do linii piksela.")  
  
 Kiedy używać zaokrąglania układ i <xref:System.Windows.GridUnitType.Star> zmiany rozmiaru, system układu tworzy małe różnice w wartości kolumny lub wiersza, tak aby uniknąć subpixel renderowania. Na przykład, jeśli łączna szerokość 100 z 3 kolumny rozmiaru siatki <xref:System.Windows.GridUnitType.Star>, zamiast tworzyć trzy kolumny, która ma szerokość równa 33,3, system układu tworzy 2 kolumny, które mają szerokość 33 i jedną, która ma szerokość 34.  
  
> [!NOTE]
>  W .NET 4.6 zmian do układu zaokrąglania do zmniejszenia wystąpienia wycinka w kontrolkach z obramowaniem. Domyślnie ta funkcja jest włączona, jeśli Twoja platforma docelowa jest .NET Framework 4.6 lub nowszy. Aplikacje, których docelową platformą są wcześniejsze wersje Framework mogą wyrazić zgodę w nowe zachowanie, dodając następujące ustawienie do pliku app.config: `<runtime><AppContextSwitchOverrides value="Switch.MS.Internal.DoNotApplyLayoutRoundingToMarginsAndBorderThickness=false"/></runtime>` ustawienie tylko działa, gdy aplikacja jest uruchomiona na platformie .NET Framework 4.6.  
  
   
  
## Examples  
 Poniższy przykład ilustruje efekt, <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> właściwość ma w wierszu pojedynczego szerokość piksela. Wiersz po lewej stronie nie używają zaokrąglania układ i wiersza po prawej stronie używa zaokrąglania układu. Jeśli powoli zmiany rozmiaru okna można zobaczyć różnicę taki układ zaokrąglania sprawia, że.  
  
```xaml  
  
<Page x:Class="LayoutRounding.Lines"  
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"  
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"  
    Title="Lines" Name="linesPage"  
    >  
  <StackPanel Width="150"  Margin="7" Orientation="Horizontal">  
    <!-- Single pixel line with layout rounding turned OFF.-->  
    <Rectangle UseLayoutRounding="False"  
       Width="45.5" Margin="10" Height="1" Fill="Red"/>  
    <!-- Single pixel line with layout rounding turned ON.-->  
    <Rectangle UseLayoutRounding="True"  
      Width="45.5" Margin="10" Height="1" Fill="Red"/>  
  </StackPanel>  
  <!-- Background Grid -->  
  <Page.Background>  
    <DrawingBrush  Viewport="0,0,10,10" ViewportUnits="Absolute" TileMode="Tile">  
      <DrawingBrush.Drawing>  
        <DrawingGroup>  
          <GeometryDrawing Brush="White">  
            <GeometryDrawing.Geometry>  
              <RectangleGeometry Rect="0,0,1,1" />  
            </GeometryDrawing.Geometry>  
          </GeometryDrawing>  
          <GeometryDrawing Geometry="M0,0 L1,0 1,0.1, 0,0.1Z " Brush="#CCCCFF" />  
          <GeometryDrawing Geometry="M0,0 L0,1 0.1,1, 0.1,0Z" Brush="#CCCCFF" />  
        </DrawingGroup>  
      </DrawingBrush.Drawing>  
    </DrawingBrush>  
  </Page.Background>  
</Page>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRoundingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty UseLayoutRoundingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty UseLayoutRoundingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UseLayoutRoundingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ UseLayoutRoundingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable UseLayoutRoundingProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.UseLayoutRounding" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.VerticalAlignment VerticalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.VerticalAlignment VerticalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property VerticalAlignment As VerticalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::VerticalAlignment VerticalAlignment { System::Windows::VerticalAlignment get(); void set(System::Windows::VerticalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.VerticalAlignment : System.Windows.VerticalAlignment with get, set" Usage="System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.VerticalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia charakterystyki wyrównania poziomego stosowane do tego elementu, gdy wchodzi on w ramach elementu nadrzędnego, takiego jak panel lub kontrolka elementów.</summary>
        <value>Ustawienie wyrównania w pionie. Wartość domyślna to <see cref="F:System.Windows.VerticalAlignment.Stretch" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.FrameworkElement.Height%2A> i <xref:System.Windows.FrameworkElement.Width%2A> właściwości są jawnie ustawione na element, pomiarów zająć anulują układ i zwykłe efekty ustawienia tej właściwości <xref:System.Windows.VerticalAlignment.Stretch>.  
  
 <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> jest [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] metody dostępu właściwości w celu przedstawienia w rzeczywistości właściwość zależności. Ta właściwość zależności określonego dość często wartością jego jawnego "domyślna" ustawione inaczej w element pochodny klas, zwłaszcza kontrolki. Zwykle dzieje się to jeden z dwóch sposobów: właściwość zależności jest ponownie zarejestrowane, do określonej klasy pochodnej, ale z inną metadanych do ustawiania wartości domyślnych; lub domyślnego stylu stosowane, która ustawia tę wartość właściwości zależności inaczej. Na przykład jawnego "domyślną" <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> dla <xref:System.Windows.Controls.ComboBoxItem> formant będzie <xref:System.Windows.VerticalAlignment.Center>, nawet jeśli <xref:System.Windows.Controls.ComboBoxItem> dziedziczy <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> bezpośrednio z <xref:System.Windows.FrameworkElement>. To dlatego ta wartość została zresetowana w ramach domyślnego stylu <xref:System.Windows.Controls.ComboBoxItem>, w ramach szablonu kontrolki stylu.  
  
 <xref:System.Windows.Controls.Canvas> nie używa <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> podczas redagowania układu, ponieważ <xref:System.Windows.Controls.Canvas> opiera się na pozycjonowanie absolutne.  
  
 W przypadku dziedziczonych przez <xref:System.Windows.Controls.ComboBoxItem> lub dowolnej klasy, pochodne <xref:System.Windows.Controls.ComboBoxItem> redefiniuje wartość domyślna tej właściwości to <xref:System.Windows.VerticalAlignment.Center>.  
  
<a name="dependencyPropertyInfo_VerticalAlignment"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.VerticalAlignmentProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VerticalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VerticalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VerticalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VerticalAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VerticalAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.VerticalAlignment" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualChildrenCount : int" Usage="System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów podrzędnych visual w ramach tego elementu.</summary>
        <value>Liczba elementów podrzędnych visual dla tego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> Implementacji <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> zawsze zwraca wartość zero lub jeden. Właściwość ta jest przesłonięcie klasy obsługujące kolekcję visual podrzędny, która może przekraczać jeden i <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  
  
 Ta właściwość jest zazwyczaj używana do określenia górną granicą bieżącej kolekcji podrzędnej do celów realizacji zastąpienia układu (<xref:System.Windows.FrameworkElement.MeasureOverride%2A>, <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak niestandardowy moduł definiowania układu kodu używa wartości zdeklarowane <xref:System.Windows.Media.VisualCollection> obsługuje dla wielu podrzędnych wizualne i raporty te wartości przy użyciu zastąpień z <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> i <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Jeśli klasa obsługuje więcej niż jeden element podrzędny visual w kolekcji elementów podrzędnych, należy zastąpić tę właściwość, aby zwrócić liczbę elementów w tej kolekcji. Należy to zrobić, nawet jeśli sam obiekt kolekcji zwraca liczbę. Logikę układu elementu na poziomie framework WPF zakłada, że wszystkie elementy zwróci prawidłowy za pośrednictwem ich <see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /> właściwości.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public double Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Width" />
      <MemberSignature Language="VB.NET" Value="Public Property Width As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Width { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Width : double with get, set" Usage="System.Windows.FrameworkElement.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia szerokość elementu.</summary>
        <value>Szerokość elementu w [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Wartość domyślna to <see cref="F:System.Double.NaN" />. Ta wartość musi być równa lub większa niż 0,0. Górna granica informacji, zobacz uwagi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to jeden z trzech właściwości na <xref:System.Windows.FrameworkElement> określające szerokość informacji.  Istnieją dwie <xref:System.Windows.FrameworkElement.MinWidth%2A> i <xref:System.Windows.FrameworkElement.MaxWidth%2A>.  Jeśli występuje konflikt między tymi wartościami, kolejność aplikacji do oznaczania rzeczywista szerokość jest pierwszy <xref:System.Windows.FrameworkElement.MinWidth%2A> musi zostać wdrożona, następnie <xref:System.Windows.FrameworkElement.MaxWidth%2A>, a na koniec Jeśli każdy z nich znajdują się w granicach, <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 Zwracana wartość tej właściwości jest zawsze taki sam jak każdą wartość, która została ustawiona do niego. Z drugiej strony, wartość <xref:System.Windows.FrameworkElement.ActualWidth%2A> mogą się różnić. Układ mogą odrzucone sugerowany rozmiar przyczyny. Sam system układu działa również asynchronicznie względem systemu właściwość zbiór <xref:System.Windows.FrameworkElement.Width%2A> i może nie zostały przetworzone oznacza określonego rozmiaru jeszcze zmiany właściwości.  
  
 Ponadto do akceptowalnego <xref:System.Double> wartości tej właściwości można też <xref:System.Double.NaN?displayProperty=nameWithType>. Jest to, jak określić automatycznego ustalania rozmiaru zachowanie. W [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] wartość na ciąg "Auto" (jest uwzględniana wielkość liter) umożliwia automatyczne ustalanie rozmiaru zachowanie. Automatyczne ustalanie rozmiaru zachowanie oznacza, że element wypełni dostępne jej szerokość. Należy jednak pamiętać, że określonych kontrolek często podać wartości domyślne w ich domyślne style, które spowoduje wyłączenie automatycznego ustalania rozmiaru zachowanie, chyba że jest to szczególnie w przypadku ponownego włączenia.  
  
 Oprócz sprawdzania poprawności, to niedeterministyczna wartość górna granica <xref:System.Windows.FrameworkElement.Width%2A> , jest wymuszana przez system układu (jest to bardzo dużą liczbą większe niż <xref:System.Single.MaxValue?displayProperty=nameWithType> ale jest mniejszy niż <xref:System.Double.MaxValue?displayProperty=nameWithType>). Jeśli przekroczysz to powiązany element nie będzie renderowana i jest zgłaszany żaden wyjątek. Nie należy ustawiać <xref:System.Windows.FrameworkElement.Width%2A> na wartość, która jest znacznie większa niż maksymalny rozmiar dowolnego wyświetlacza wizualnego możliwe, lub może być dłuższe niż to niedeterministyczna górną granicę.  
  
<a name="xamlAttributeUsage_Width"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object Width="double"/>  
- or –  
<object Width ="qualifiedDouble"/>  
- or -  
<object Width ="Auto"/>  
```  
  
<a name="xamlValues_Width"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *double*  
 <xref:System.Double>  
  
 Ciąg reprezentujący <xref:System.Double> wartość równą lub większą niż 0,0. Górna granica informacji, zobacz uwagi. Ta wartość jest interpretowana jako [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] miary. Ciągi nie musi jawnie zawierać separatorów dziesiętnych. Na przykład wartość `1` jest dopuszczalna.  
  
 *qualifiedDouble*  
 A *double* wartość zgodnie z opisem powyżej, a następnie za pomocą jednej z następujących ciągów jednostki w deklaracji: `px`, `in`, `cm`, `pt`.  
  
 `px` (domyślnie) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm` centymetrów; 1cm==(96/2.54) piks.  
  
 `pt` jest punktów. 1pt==(96/72) piks.  
  
 `Auto`  
 Włącza zachowanie automatyczne określanie rozmiaru. Zobacz uwagi.  
  
<a name="dependencyPropertyInfo_Width"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.WidthProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.WidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.WidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.FrameworkElement.Width" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
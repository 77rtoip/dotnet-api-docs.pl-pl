<Type Name="FrameworkElement" FullName="System.Windows.FrameworkElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8d279bc47238b0f8b0935402d55064cbd46bbdbf" /><Meta Name="ms.sourcegitcommit" Value="74239f3977d28923e5020663db2c4e91601bea79" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/24/2019" /><Meta Name="ms.locfileid" Value="68439510" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkElement : System.Windows.UIElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkElement extends System.Windows.UIElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkElement&#xA;Inherits UIElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkElement : System::Windows::UIElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkElement = class&#xA;    inherit UIElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zawiera zestaw właściwości, zdarzeń i metod programu WPF Framework dla elementów Windows Presentation Foundation (WPF). Ta klasa reprezentuje daną implementację na poziomie platformy WPF, która została utworzona na podstawie interfejsów API na poziomie rdzenia WPF, <see cref="T:System.Windows.UIElement" />które są zdefiniowane przez program.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement>jest punktem łączącym między klasami elementów poziomu platformy WPF a zestawem <xref:System.Windows.UIElement> usług prezentacji na poziomie WPF Core. Aby uzyskać więcej informacji na temat tych pojęć, zobacz [Architektura WPF](~/docs/framework/wpf/advanced/wpf-architecture.md).  
  
 <xref:System.Windows.FrameworkElement>rozszerza <xref:System.Windows.UIElement> i dodaje następujące możliwości:  
  
-   **Definicja systemu układu**: <xref:System.Windows.FrameworkElement> zawiera określone implementacje na poziomie platformy WPF dla niektórych metod, które zostały zdefiniowane jako wirtualne <xref:System.Windows.UIElement>składowe w. W szczególności, <xref:System.Windows.FrameworkElement> plomby niektórych przesłonięcia układu na poziomie rdzenia WPF, a zamiast tego udostępniają równoważne klasy klas pochodnych, które zamiast nich powinny zostać przesłonięte. Na przykład <xref:System.Windows.FrameworkElement> plomby <xref:System.Windows.UIElement.ArrangeCore%2A> , ale <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>zapewniają. Te zmiany odzwierciedlają fakt, że na poziomie WPF Framework jest dostępny pełny system układu, który może renderować dowolną <xref:System.Windows.FrameworkElement> klasę pochodną. Na poziomie WPF Core należy określić niektóre elementy członkowskie, które będą ze [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] strukturą ogólnego rozwiązania układu, ale nie zdefiniowano rzeczywistego aparatu systemu układu. Aby uzyskać więcej informacji, zobacz [Układ](~/docs/framework/wpf/advanced/layout.md).  
  
-   **Drzewo logiczne:** Ogólny [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] model programowania jest często wyrażony jako drzewo elementów. Obsługa wyznaczania drzewa elementów jako drzewa logicznego i towarzyszącej pomocy technicznej do definiowania drzewa w znacznikach jest zaimplementowana na <xref:System.Windows.FrameworkElement> poziomie. Należy jednak pamiętać <xref:System.Windows.FrameworkElement> , że celowo nie definiuje modelu zawartości i pozostawia odpowiedzialność za klasy pochodne. Aby uzyskać więcej informacji, zobacz [drzewa w WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
-   **Zdarzenia okresu istnienia obiektu:** Często warto wiedzieć, kiedy element jest zainicjowany (Konstruktor jest wywoływany) lub kiedy element jest najpierw ładowany do drzewa logicznego. <xref:System.Windows.FrameworkElement>definiuje kilka zdarzeń związanych z okresem istnienia obiektu, który zapewnia przydatne punkty zaczepienia dla operacji związanych z kodem, które obejmują elementy, takie jak dodawanie większej liczby elementów podrzędnych. Aby uzyskać więcej informacji, zobacz [zdarzenia okresu istnienia obiektu](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
-   **Obsługa powiązań danych i dynamicznego odwoływania się do zasobów:** Obsługa poziomu właściwości i zasobów jest implementowana przez <xref:System.Windows.DependencyProperty> klasę i zastosowana w systemie właściwości, ale możliwość rozpoznania wartości elementu członkowskiego, który jest przechowywany <xref:System.Windows.Expression> jako (konstrukcja programistyczna, która jest zależna od siebie powiązanie danych i zasoby dynamiczne są implementowane przez <xref:System.Windows.FrameworkElement>program. Aby uzyskać więcej informacji, zobacz [Omówienie powiązań danych](~/docs/framework/wpf/data/data-binding-overview.md) i [zasobów XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
-   **Style:** <xref:System.Windows.FrameworkElement> definiuje Właściwość.<xref:System.Windows.FrameworkElement.Style%2A> Jednak program <xref:System.Windows.FrameworkElement> nie definiuje jeszcze obsługi szablonów ani nie obsługuje dekoratory. Te funkcje są wprowadzane przez klasy kontroli, takie <xref:System.Windows.Controls.Control> jak <xref:System.Windows.Controls.ContentControl>i.  
  
-   **Obsługa większej liczby animacji:** Niektóre animacje obsługi zostały już zdefiniowane na poziomie WPF Core, ale <xref:System.Windows.FrameworkElement> rozszerzają to przez implementację <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> i powiązane elementy członkowskie.  
  
 Jak widać w [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] hierarchii klas, wiele klas pochodzi od <xref:System.Windows.FrameworkElement>, bezpośrednio lub za pośrednictwem pośrednich klas podstawowych, takich <xref:System.Windows.Controls.Panel> jak <xref:System.Windows.Controls.Control>lub.  
  
 Jeśli zamierzasz użyć <xref:System.Windows.FrameworkElement> jako klasy bazowej, warto najpierw przejrzeć istniejące klasy pochodne. <xref:System.Windows.FrameworkElement>zapewnia obsługę wielu podstawowych scenariuszy, ale również nie ma szeregu funkcji, które są odpowiednie dla "elementu" w sensie bloku konstrukcyjnego, który jest używany do tworzenia [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] w. [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] Na przykład, a <xref:System.Windows.FrameworkElement> nie definiuje żadnych prawdziwy model zawartości; ponieważ klasa bazowa nie definiuje właściwości, która może tworzyć [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] elementy podrzędne. <xref:System.Windows.FrameworkElement> W szczególności warto zapoznać <xref:System.Windows.Controls.Control> się z tematem i. <xref:System.Windows.Controls.ContentControl>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.FrameworkContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.FrameworkElement" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeight">
      <MemberSignature Language="C#" Value="public double ActualHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualHeight { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ActualHeight : double" Usage="System.Windows.FrameworkElement.ActualHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wyrenderowaną wysokość tego elementu.</summary>
        <value>Wysokość elementu, jako wartość w [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Wartością domyślną jest 0 (zero).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest wartością obliczaną na podstawie innych danych wejściowych wysokości i systemu układu. Wartość jest ustawiana przez system układu w oparciu o rzeczywiste przebieg renderingu i dlatego może być nieco opóźnione w stosunku do ustawionej wartości właściwości, takich <xref:System.Windows.FrameworkElement.Height%2A> jak te, które są podstawą zmiany danych wejściowych.  
  
 Ponieważ <xref:System.Windows.FrameworkElement.ActualHeight%2A> jest wartością obliczaną, należy pamiętać, że może być wiele lub przyrostowo raportowane zmiany w tym wyniku różne operacje wykonywane przez system układu. System układu może obliczać wymaganą przestrzeń miary dla elementów podrzędnych, ograniczeń przez element nadrzędny i tak dalej.  
  
 Chociaż nie można ustawić tej właściwości z [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], można oprzeć na <xref:System.Windows.Trigger> jej wartości w stylu.  
  
<a name="dependencyPropertyInfo_ActualHeight"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ActualHeightProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład wyświetla różne właściwości wysokości.  
  
 [!code-csharp[HeightMinHeightMaxHeight#3](~/samples/snippets/csharp/VS_Snippets_Wpf/HeightMinHeightMaxHeight/CSharp/Window1.xaml.cs#3)]
 [!code-vb[HeightMinHeightMaxHeight#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HeightMinHeightMaxHeight/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActualHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.ActualHeight" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidth">
      <MemberSignature Language="C#" Value="public double ActualWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualWidth { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ActualWidth : double" Usage="System.Windows.FrameworkElement.ActualWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość renderowanej szerokości tego elementu.</summary>
        <value>Szerokość elementu, jako wartość w [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Wartością domyślną jest 0 (zero).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest wartością obliczaną na podstawie innych danych wejściowych szerokości i systemu układu. Wartość jest ustawiana przez system układu w oparciu o rzeczywiste przebieg renderingu i dlatego może być nieco opóźnione w stosunku do ustawionej wartości właściwości, takich <xref:System.Windows.FrameworkElement.Width%2A> jak te, które są podstawą zmiany danych wejściowych.  
  
 Ponieważ <xref:System.Windows.FrameworkElement.ActualWidth%2A> jest wartością obliczaną, należy pamiętać, że może być wiele lub przyrostowo raportowane zmiany w tym wyniku różne operacje wykonywane przez system układu. System układu może obliczać wymaganą przestrzeń miary dla elementów podrzędnych, ograniczeń przez element nadrzędny i tak dalej.  
  
 Chociaż nie można ustawić tej właściwości z [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], można oprzeć na <xref:System.Windows.Trigger> jej wartości w stylu.  
  
<a name="dependencyPropertyInfo_ActualWidth"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ActualWidthProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład wyświetla różne właściwości szerokości.  
  
 [!code-csharp[WidthMinWidthMaxWidth#3](~/samples/snippets/csharp/VS_Snippets_Wpf/WidthMinWidthMaxWidth/CSharp/Window1.xaml.cs#3)]
 [!code-vb[WidthMinWidthMaxWidth#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WidthMinWidthMaxWidth/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActualWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.ActualWidth" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Element podrzędny, który ma zostać dodany.</param>
        <summary>Dodaje podany obiekt do drzewa logicznego tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do wdrażania kolekcji obiektów, które reprezentują logiczne elementy podrzędne elementu. Obsługa kolekcji dla kolekcji elementów podrzędnych może odbywać się w metodach pobierających właściwości lub metodach ustawiających, obsłudze klasy zmienionych zdarzeń, konstruktorów lub w samych typach kolekcji.  
  
 Dla autorów kontroli, manipulowanie drzewem logicznym na tym poziomie nie jest zalecanym rozwiązaniem, chyba że żaden z modeli zawartości dla dostępnych klas kontroli podstawowej nie jest odpowiedni dla scenariusza kontroli. Rozważ podklasy na poziomie <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>i <xref:System.Windows.Controls.HeaderedItemsControl>. Klasy te udostępniają model zawartości z określonym wymuszeniem elementów podrzędnych drzewa logicznego [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]za pomocą dedykowanego, a także do obsługi innych funkcji zwykle [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] pożądanych w kontrolce, takiej jak style za pomocą szablonów. Aby uzyskać więcej informacji na temat korzystania <xref:System.Windows.FrameworkElement.LogicalChildren%2A> z <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>i, zobacz [drzewa w WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>może zgłosić wyjątek, jeśli jest wywoływana w czasie, gdy Drzewo logiczne zostanie powtórzone przez inny proces.  
  
   
  
## Examples  
 Poniższy przykład implementuje `Child` właściwość dla niestandardowego <xref:System.Windows.FrameworkElement> , który wykonuje własną implementację warstwy wizualnej. Metoda ustawiająca właściwość jest zaprojektowana tak, że w przypadku zmiany wartości stara wartość jest usuwana z drzewa logicznego, a także do kolekcji wizualizacji specyficznej dla klasy. Wartość właściwości jest buforowana, a następnie nowa wartość jest dodawana do drzewa logicznego i kolekcji wizualizacji niestandardowej.  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyTemplate">
      <MemberSignature Language="C#" Value="public bool ApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyTemplate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ApplyTemplate();" />
      <MemberSignature Language="F#" Value="member this.ApplyTemplate : unit -&gt; bool" Usage="frameworkElement.ApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W razie potrzeby kompiluje drzewo wizualne bieżącego szablonu i zwraca wartość wskazującą, czy drzewo wizualne zostało odbudowane przez to wywołanie.</summary>
        <returns><see langword="true" />Jeśli wizualizacje zostały dodane do drzewa; zwraca <see langword="false" /> w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacje mogą wywołać tę metodę w celu zagwarantowania, że drzewo wizualne elementu zostało zakończone. Ten krok gwarancji może być konieczny, jeśli kod będzie sprawdzać elementy podrzędne w drzewie. W przypadku typowej logiki elementu w aplikacjach <xref:System.Windows.FrameworkElement.ApplyTemplate%2A> wywoływanie nie jest konieczne, ponieważ szablony zostaną zastosowane do elementów w odpowiednim punkcie ich okresów istnienia.  
  
 <xref:System.Windows.FrameworkElement.ApplyTemplate%2A>jest wywoływana dla każdej miary przekazanej przez system układu platformy WPF.  
  
 <xref:System.Windows.FrameworkElement>klasy pochodne mogą używać <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> procedury obsługi klasy do powiadamiania o przypadkach, w których ta metoda została wywołana jawnie lub przez system układu. <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A>jest wywoływana po całkowitym wygenerowaniu szablonu i dołączeniu go do drzewa logicznego.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ControlTemplate" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeCore">
      <MemberSignature Language="C#" Value="protected override sealed void ArrangeCore (System.Windows.Rect finalRect);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ArrangeCore(valuetype System.Windows.Rect finalRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Sub ArrangeCore (finalRect As Rect)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ArrangeCore(System::Windows::Rect finalRect);" />
      <MemberSignature Language="F#" Value="override this.ArrangeCore : System.Windows.Rect -&gt; unit" Usage="frameworkElement.ArrangeCore finalRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalRect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="finalRect">Ostatni obszar w elemencie nadrzędnym, który powinien być używany przez ten element do rozmieszczenia siebie i jego elementów podrzędnych.</param>
        <summary>Implementuje <see cref="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" /> (zdefiniowane jako <see cref="T:System.Windows.UIElement" />wirtualne) i plombuje implementację.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest zapieczętowana. Aby przesłonić logikę w elemencie niestandardowym specyficznym dla ułożenia przebiegu układu elementu, <xref:System.Windows.FrameworkElement> Klasa pochodna musi <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>zostać przesłonięta.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size ArrangeOverride (System.Windows.Size finalSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size finalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ArrangeOverride (finalSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size ArrangeOverride(System::Windows::Size finalSize);" />
      <MemberSignature Language="F#" Value="abstract member ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.ArrangeOverride finalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="finalSize">Ostatni obszar w elemencie nadrzędnym, który powinien być używany przez ten element do rozmieszczenia siebie i jego elementów podrzędnych.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, ustawia elementy podrzędne i określa rozmiar <see cref="T:System.Windows.FrameworkElement" /> klasy pochodnej.</summary>
        <returns>Używany rozmiar rzeczywisty.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Autorzy kontroli, którzy chcą dostosować przebieg przetwarzania układu, powinny zastąpić tę metodę. Wzorzec implementacji powinien wywołać <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> każdy widoczny element podrzędny i przekazać końcowy żądany rozmiar dla każdego elementu podrzędnego <paramref name="finalRect" /> jako parametr. Elementy nadrzędne powinny <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> być wywoływane dla każdego elementu podrzędnego, w przeciwnym razie elementy podrzędne nie będą renderowane.  
  
Wiele klas pochodnych oferuje implementacje tej metody. Widoczne są następujące pozycje <see cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />: <see cref="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" /> , <see cref="M:System.Windows.Controls.Control.ArrangeOverride(System.Windows.Size)" />i.</para></block>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkElement.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia proces inicjowania dla tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tę metodę można wywołać dla poszczególnych elementów, jeśli są one dostosowywane w sposób, który nie uwidacznia jeszcze lub nie łączy elementu z dowolnym drzewem elementu. Na przykład można utworzyć nowe <xref:System.Windows.FrameworkElement>, ale jeszcze nie dołączone do żadnego drzewa logicznego. Lub Drzewo logiczne, w którym element jest elementem podrzędnym, może nie być połączone z oknem lub stroną aplikacji.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Zaimplementuj tę metodę, aby zapewnić specjalną obsługę, która powinna wystąpić przed zainicjowaniem elementu podczas procesu ładowania elementu.  
  
Implementacja powinna wywołać implementację podstawową, ponieważ implementacja podstawowa (domyślna) ustawia pewne flagi wewnętrzne, aby śledzić inicjalizację. Jedną z możliwych implementacji jest użycie tej metody jako punktu zaczepienia do własnych procedur inicjowania klasy prywatnej, które nie zostały jeszcze włączone przez konstruktory.  
  
Implementacja podstawowa zgłosi wyjątek, jeśli <see cref="M:System.Windows.FrameworkElement.BeginInit" /> jest wywoływana więcej niż jeden raz w tym samym elemencie <see cref="M:System.Windows.FrameworkElement.EndInit" /> przed wywołaniem.</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.EndInit" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna sekwencję akcji zawartych w podanym scenorysie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">Seria ujęć do rozpoczęcia.</param>
        <summary>Rozpoczyna sekwencję akcji, które są zawarte w podanym scenorysie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W większości typowych scenariuszy animacji nie jest używana ta metoda. Zazwyczaj tworzysz element <xref:System.Windows.Media.Animation.BeginStoryboard> <xref:System.Windows.EventTrigger> lub w znacznikach, a następnie umieścisz je jako zawartość elementu. <xref:System.Windows.Media.Animation.Storyboard> Gdy zdarzenie zostanie wyzwolone, animacja zostanie uruchomiona. Większość aspektów <xref:System.Windows.Media.Animation.Storyboard> kontroli można rozmieścić według właściwości, które są widoczne w znacznikach.  
  
 W przypadku podpisów, które nie używają `isControllable`parametru, lub gdy ten parametr jest określony `false`, zegary osi czasu skojarzone z animacją są usuwane zaraz po osiągnięciu przez animację okresu "Fill". W związku z tym nie można uruchomić ponownie animacji po uruchomieniu. Kontrolowanie animacji wymaga również, aby scenorys miał [dyrektywę x:Name](~/docs/framework/xaml-services/x-name-directive.md) lub uzyskać dostęp za pomocą odwołania w kodzie.  
  
   
  
## Examples  
 Poniższy przykład pobiera <xref:System.Windows.Media.Animation.Storyboard> z zasobów, a następnie <xref:System.Windows.Media.Animation.Storyboard> uruchamia, gdy zdarzenie wewnętrzne jest obsługiwane przez klasę.  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">Seria ujęć do rozpoczęcia.</param>
        <param name="handoffBehavior">Wartość wyliczenia opisująca zachowanie, jeśli właściwość opisana w scenorysie jest już animowana.</param>
        <summary>Rozpoczyna sekwencję akcji zawartych w podanym scenorysie, z opcjami określonymi dla tego, co powinno się zdarzyć, jeśli właściwość jest już animowana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W większości typowych scenariuszy animacji nie jest używana ta metoda. Zazwyczaj tworzysz element <xref:System.Windows.Media.Animation.BeginStoryboard> <xref:System.Windows.EventTrigger> lub w znacznikach, a następnie umieścisz je jako zawartość elementu. <xref:System.Windows.Media.Animation.Storyboard> Gdy zdarzenie zostanie wyzwolone, animacja zostanie uruchomiona. Większość aspektów <xref:System.Windows.Media.Animation.Storyboard> kontroli można rozmieścić według właściwości, które są widoczne w znacznikach.  
  
 W przypadku podpisów, które nie używają `isControllable`parametru, lub gdy ten parametr jest określony `false`, zegary osi czasu skojarzone z animacją są usuwane zaraz po osiągnięciu przez animację okresu "Fill". W związku z tym nie można uruchomić ponownie animacji po uruchomieniu. Kontrolowanie animacji wymaga również, aby scenorys miał [dyrektywę x:Name](~/docs/framework/xaml-services/x-name-directive.md) lub uzyskać dostęp za pomocą odwołania w kodzie.  
  
 Zachowanie oddania można określić jako atrybut <xref:System.Windows.Media.Animation.BeginStoryboard>.  
  
## <a name="using-the-compose-handoffbehavior"></a>Korzystanie z Compose HandoffBehavior  
 Po <xref:System.Windows.Media.Animation.Storyboard>zastosowaniu <xref:System.Windows.Media.Animation.Clock> , <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> do właściwości przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, wszystkie obiekty wcześniej skojarzone z tą właściwością nadal zużywają zasoby systemowe; system chronometrażu wykonuje nie usuwaj automatycznie zegarów.  
  
 Aby uniknąć problemów z wydajnością w przypadku stosowania dużej liczby zegarów przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>programu, należy usunąć z właściwości animowane zegary, po ich zakończeniu. Istnieje kilka sposobów usunięcia zegara:  
  
-   Aby usunąć wszystkie zegary z właściwości, użyj <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metody animowanego obiektu. Określ animowaną właściwość jako pierwszy parametr, a `null` w drugim. Spowoduje to usunięcie wszystkich zegarów animacji z właściwości.  
  
-   <xref:System.Windows.Media.Animation.AnimationClock> Aby usunąć określony z listy zegarów, <xref:System.Windows.Media.Animation.Clock.Controller%2A> Użyj właściwości <xref:System.Windows.Media.Animation.AnimationClock> do pobrania <xref:System.Windows.Media.Animation.ClockController>a <xref:System.Windows.Media.Animation.ClockController>, a następnie Wywołaj <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metodę. Jest to zazwyczaj wykonywane w programie <xref:System.Windows.Media.Animation.Clock.Completed> obsługi zdarzeń zegara. Należy zauważyć, że tylko zegary główne mogą być sterowane <xref:System.Windows.Media.Animation.ClockController>przez <xref:System.Windows.Media.Animation.Clock.Controller%2A> ; Właściwość zegara podrzędnego zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzenie nie zostanie zgłoszone, jeśli skuteczny czas trwania zegara jest nieograniczona.  W takim przypadku użytkownik musi określić, kiedy ma być wywoływana <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Jest to szczególnie problem w przypadku animacji na obiektach, które mają długi okres istnienia.  Gdy obiekt jest odzyskiwany, jego zegary również są rozłączone i odzyskiwane.  
  
 Aby uzyskać więcej informacji na temat obiektów zegara, zobacz [animacje i system chronometrażu — przegląd](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 Poniższy przykład pobiera <xref:System.Windows.Media.Animation.Storyboard> z zasobów, a następnie <xref:System.Windows.Media.Animation.Storyboard> uruchamia, gdy zdarzenie wewnętrzne jest obsługiwane przez klasę.  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">Seria ujęć do rozpoczęcia.</param>
        <param name="handoffBehavior">Wartość wyliczenia opisująca zachowanie, jeśli właściwość opisana w scenorysie jest już animowana.</param>
        <param name="isControllable">Deklaruje, czy animacja jest sterowana (może zostać wstrzymana) po jej uruchomieniu.</param>
        <summary>Rozpoczyna sekwencję akcji zawartych w podanym scenorysie z określonym stanem kontroli animacji po jej uruchomieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W większości typowych scenariuszy animacji nie jest używana ta metoda. Zazwyczaj tworzysz element <xref:System.Windows.Media.Animation.BeginStoryboard> <xref:System.Windows.EventTrigger> lub w znacznikach, a następnie umieścisz je jako zawartość elementu. <xref:System.Windows.Media.Animation.Storyboard> Gdy zdarzenie zostanie wyzwolone, animacja zostanie uruchomiona. Większość aspektów <xref:System.Windows.Media.Animation.Storyboard> kontroli można rozmieścić według właściwości, które są widoczne w znacznikach.  
  
 W przypadku podpisów, które nie używają `isControllable`parametru, lub gdy ten parametr jest określony `false`, zegary osi czasu skojarzone z animacją są usuwane zaraz po osiągnięciu przez animację okresu "Fill". W związku z tym nie można uruchomić ponownie animacji po uruchomieniu. Kontrolowanie animacji wymaga również, aby scenorys miał [dyrektywę x:Name](~/docs/framework/xaml-services/x-name-directive.md) lub uzyskać dostęp za pomocą odwołania w kodzie.  
  
 Zachowanie oddania można określić jako atrybut <xref:System.Windows.Media.Animation.BeginStoryboard>.  
  
## <a name="using-the-compose-handoffbehavior"></a>Korzystanie z Compose HandoffBehavior  
 Po <xref:System.Windows.Media.Animation.Storyboard>zastosowaniu <xref:System.Windows.Media.Animation.Clock> , <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> do właściwości przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, wszystkie obiekty wcześniej skojarzone z tą właściwością nadal zużywają zasoby systemowe; system chronometrażu wykonuje nie usuwaj automatycznie zegarów.  
  
 Aby uniknąć problemów z wydajnością w przypadku stosowania dużej liczby zegarów przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>programu, należy usunąć z właściwości animowane zegary, po ich zakończeniu. Istnieje kilka sposobów usunięcia zegara:  
  
-   Aby usunąć wszystkie zegary z właściwości, użyj <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metody animowanego obiektu. Określ animowaną właściwość jako pierwszy parametr, a `null` w drugim. Spowoduje to usunięcie wszystkich zegarów animacji z właściwości.  
  
-   <xref:System.Windows.Media.Animation.AnimationClock> Aby usunąć określony z listy zegarów, <xref:System.Windows.Media.Animation.Clock.Controller%2A> Użyj właściwości <xref:System.Windows.Media.Animation.AnimationClock> do pobrania <xref:System.Windows.Media.Animation.ClockController>a <xref:System.Windows.Media.Animation.ClockController>, a następnie Wywołaj <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metodę. Jest to zazwyczaj wykonywane w programie <xref:System.Windows.Media.Animation.Clock.Completed> obsługi zdarzeń zegara. Należy zauważyć, że tylko zegary główne mogą być sterowane <xref:System.Windows.Media.Animation.ClockController>przez <xref:System.Windows.Media.Animation.Clock.Controller%2A> ; Właściwość zegara podrzędnego zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzenie nie zostanie zgłoszone, jeśli skuteczny czas trwania zegara jest nieograniczona.  W takim przypadku użytkownik musi określić, kiedy ma być wywoływana <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Jest to szczególnie problem w przypadku animacji na obiektach, które mają długi okres istnienia.  Gdy obiekt jest odzyskiwany, jego zegary również są rozłączone i odzyskiwane.  
  
 Aby uzyskać więcej informacji na temat obiektów zegara, zobacz [animacje i system chronometrażu — przegląd](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see cref="T:System.Windows.Data.BindingGroup" /> , która jest używana dla elementu.</summary>
        <value><see cref="T:System.Windows.Data.BindingGroup" /> Jest używany dla elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Data.BindingGroup> Można użyć do walidacji wartości wielu właściwości obiektu. Załóżmy na przykład, że aplikacja poprosi użytkownika o wprowadzenie `Address`adresu, a następnie wypełnia obiekt typu, który zawiera właściwości `Street`, `City`, `ZipCode`i `Country`, z wartościami, które użytkownik określonych. Aplikacja ma panel, który zawiera cztery <xref:System.Windows.Controls.TextBox> kontrolki, z których każdy jest powiązany z jednym z właściwości obiektu. Aby sprawdzić poprawność <xref:System.Windows.Controls.ValidationRule> `Address` obiektu <xref:System.Windows.Data.BindingGroup> , można użyć elementu in a. Na przykład, <xref:System.Windows.Controls.ValidationRule> można upewnić się, że kod pocztowy jest prawidłowy dla kraju/regionu adresu.  
  
 Elementy podrzędne dziedziczą <xref:System.Windows.Data.BindingGroup> elementy z elementów nadrzędnych, podobnie jak w przypadku każdej innej dziedziczonej właściwości.  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.BindingGroupProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Poniższe przykłady są częścią aplikacji, która sprawdza, czy użytkownik ustawił właściwości dwóch obiektów na równe wartości. Pierwszy przykład tworzy dwie <xref:System.Windows.Controls.TextBox> kontrolki, z których każdy jest powiązany z innym źródłem danych. Zawieraelementzawierający,którysprawdza,czydwaciągisąrówne.<xref:System.Windows.Controls.StackPanel> <xref:System.Windows.Data.BindingGroup> <xref:System.Windows.Controls.ValidationRule>  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupComplete](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupcomplete)]  
  
 Poniższy przykład pokazuje <xref:System.Windows.Controls.ValidationRule> , że poprzedni przykład używa.  W przypadku przesłonięcia <xref:System.Windows.Data.BindingGroup> metodyprzykładpobierakażdyobiektźródłowyzisprawdza,czywłaściwości<xref:System.Windows.Controls.ValidationRule.Validate%2A> obiektów są równe.  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 Aby wywołać <xref:System.Windows.Controls.ValidationRule> <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> metody, należy wywołać metodę.  Poniższy przykład wywołuje <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> się, gdy wystąpi zdarzenie kliknięcia przycisku.  
  
 [!code-csharp[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#updatesourcesclick)]
 [!code-vb[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#updatesourcesclick)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.BindingGroup" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BringIntoView">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Podejmuje próbę przełączenia tego elementu do widoku w obrębie dowolnego regionu przewijalnego, w którym jest zawarte.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Podejmuje próbę przełączenia tego elementu do widoku w obrębie dowolnego regionu przewijalnego, w którym jest zawarte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody powoduje podnoszenie <xref:System.Windows.FrameworkElement.RequestBringIntoView> zdarzenia pochodzącego z bieżącego elementu. To zdarzenie jest wywoływane, aby można było je obsłużyć <xref:System.Windows.Controls.ScrollViewer>przez klasę, lub pochodną lub podobną. Oczekiwane zachowanie polega na tym, że zdarzenie jest obsługiwane przez element nadrzędny, oznaczone jako obsługiwane w danych zdarzenia, a Źródło zdarzenia jest uwzględniane w widoku przez logikę osadzoną w <xref:System.Windows.Controls.ScrollViewer> formancie. <xref:System.Windows.FrameworkElement.RequestBringIntoView> Zdarzenie<xref:System.Windows.FrameworkElement.BringIntoView%2A> ani Metoda nie przesyłają żadnych informacji o powodzeniu lub niepowodzeniu, z wyjątkiem tego, że zdarzenie jest zazwyczaj oznaczone jako obsługiwane w przypadku powodzenia. Przyczyny niepowodzenia mogą zawierać ustawienia elementu, takie jak <xref:System.Windows.UIElement.Visibility%2A> wartość inna niż. <xref:System.Windows.Visibility.Visible>  
  
 Jeśli używasz podpisu, który nie określa `targetRectangle`, wówczas cały rozmiar elementu (jego <xref:System.Windows.UIElement.RenderSize%2A>) zostanie widoczny.  
  
 Wywołanie tej metody może spowodować wywołanie <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> na dowolnym nadrzędnym obszarze przewijania zawierającym element. Jeśli ten element nie jest zawarty w przewijanym obszarze, <xref:System.Windows.FrameworkElement.RequestBringIntoView> zdarzenie jest nadal zgłaszane, ale nie będzie żadnego efektu, ponieważ nie ma żadnych detektorów zdarzeń.  
  
   
  
## Examples  
 W poniższym przykładzie zaimplementowano procedurę obsługi dla zdarzenia nawigacji aplikacji, które reaguje [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] , gdy zostanie ona przetworzona, aby zawierała fragment. Fragment jest nazwany w [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] poniższym znaku skrótu (#), a zaimplementowane zachowanie powoduje, że element jest przewijany do widoku w obrębie ramki. <xref:System.Windows.FrameworkElement.BringIntoView%2A>i <xref:System.Windows.FrameworkElement.RequestBringIntoView> Zażądaj zachowania przewijania w przykładzie.  
  
 [!code-csharp[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/csharp/VS_Snippets_Wpf/FragmentNavigationSample/CSharp/MainWindow.xaml.cs#febringintoview)]
 [!code-vb[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FragmentNavigationSample/VisualBasic/MainWindow.xaml.vb#febringintoview)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView (System.Windows.Rect targetRectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView(valuetype System.Windows.Rect targetRectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView (targetRectangle As Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView(System::Windows::Rect targetRectangle);" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : System.Windows.Rect -&gt; unit" Usage="frameworkElement.BringIntoView targetRectangle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetRectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="targetRectangle">Określony rozmiar elementu, który powinien być również przełączony do widoku.</param>
        <summary>Próbuje przenieść podany rozmiar regionu tego elementu do widoku w obrębie regionów, w których jest zawarty.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody powoduje podnoszenie <xref:System.Windows.FrameworkElement.RequestBringIntoView> zdarzenia pochodzącego z bieżącego elementu. To zdarzenie jest wywoływane, aby można było je obsłużyć <xref:System.Windows.Controls.ScrollViewer>przez klasę, lub pochodną lub podobną. Oczekiwane zachowanie polega na tym, że zdarzenie jest obsługiwane przez element nadrzędny, oznaczone jako obsługiwane w danych zdarzenia, a Źródło zdarzenia jest uwzględniane w widoku przez logikę osadzoną w <xref:System.Windows.Controls.ScrollViewer> formancie. <xref:System.Windows.FrameworkElement.RequestBringIntoView> Zdarzenie<xref:System.Windows.FrameworkElement.BringIntoView%2A> ani Metoda nie przesyłają żadnych informacji o powodzeniu lub niepowodzeniu, z wyjątkiem tego, że zdarzenie jest zazwyczaj oznaczone jako obsługiwane w przypadku powodzenia. Przyczyny niepowodzenia mogą zawierać ustawienia elementu, takie jak <xref:System.Windows.UIElement.Visibility%2A> wartość inna niż. <xref:System.Windows.Visibility.Visible>  
  
 Jeśli używasz podpisu, który nie określa `targetRectangle`, wówczas cały rozmiar elementu (jego <xref:System.Windows.UIElement.RenderSize%2A>) zostanie widoczny.  
  
 Wywołanie tej metody może spowodować wywołanie <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> na dowolnym nadrzędnym obszarze przewijania zawierającym element. Jeśli ten element nie jest zawarty w przewijanym obszarze, <xref:System.Windows.FrameworkElement.RequestBringIntoView> zdarzenie jest nadal zgłaszane, ale nie będzie żadnego efektu, ponieważ nie ma żadnych detektorów zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład zawiera dużą grafikę w ograniczonym regionie przewijania. Przycisk na stronie zawiera program obsługi, który przewija widok do określonego regionu dużej grafiki.  
  
 [!code-xaml[BaseElementsSmorgasbord#BringIntoViewRectMarkup](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml#bringintoviewrectmarkup)]  
  
 [!code-csharp[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#bringintoviewrectcode)]
 [!code-vb[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#bringintoviewrectcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.FlowDocumentScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia element menu kontekstowego, który powinien być wyświetlany po zażądaniu [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] menu kontekstowego w ramach tego elementu.</summary>
        <value>Menu kontekstowe przypisane do tego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ContextMenu>sama jest <xref:System.Windows.FrameworkElement> klasą pochodną i jest technicznie możliwa dla <xref:System.Windows.Controls.ContextMenu> samej siebie. <xref:System.Windows.FrameworkElement.ContextMenu%2A> Jednak spowoduje to utworzenie w sposób mylący środowiska menu kontekstowego dla użytkownika i nie jest to zalecane.  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ContextMenuProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje tuż przed zamknięciem dowolnego menu kontekstowego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby pominąć menu kontekstowe zamykania, programy obsługi zdarzenia powinny oznaczyć je jako obsłużone.  
  
 Aby użyć tego zdarzenia jako <xref:System.Windows.EventTrigger> stylu, należy odwołać się do definicji usługi podstawowej zdarzenia:  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (To użycie jest wymagane, ponieważ implementacja zdarzeń w <xref:System.Windows.FrameworkElement> programie, która ujawnia podstawowe zdarzenie usługi, nie <xref:System.Windows.FrameworkElement.ContextMenuClosing> mapuje identyfikatora takiego, że można go użyć jako wyzwalacza).  
  
 <xref:System.Windows.Controls.ContextMenu>sama jest <xref:System.Windows.FrameworkElement> klasą pochodną, <xref:System.Windows.FrameworkElement.ContextMenuClosing> ale zdarzenie nie zostanie bezpośrednio wywołane przez menu kontekstowe. Zamiast tego zdarzenie jest wywoływane z elementu, który "jest właścicielem menu kontekstowego jako właściwości i jest uruchamiany tylko wtedy, gdy użytkownik próbuje zamknąć menu kontekstowe w interfejsie użytkownika. Jednakże możliwe <xref:System.Windows.Controls.ContextMenu> jest <xref:System.Windows.FrameworkElement.ContextMenu%2A> posiadanie właściwości (zagnieżdżone menu kontekstowe). W tym przypadku <xref:System.Windows.Controls.ContextMenu> naprawdę robi się to w sposób <xref:System.Windows.Controls.ContextMenu> zagnieżdżony i może zgłosić zdarzenie, ze źródłem zdarzenia w menu kontekstowym zagnieżdżonym.  
  
 Sama klasa ma również podobne zdarzenie (<xref:System.Windows.Controls.ContextMenu.Closed>), ale <xref:System.Windows.Controls.ContextMenu.Closed> zdarzenie nie zapewnia możliwości anulowania akcji użytkownika. <xref:System.Windows.Controls.ContextMenu>  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ContextMenuClosingEvent>|  
|Strategia routingu|Propagacja|  
|Delegate|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   Przesłoń <xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A> , aby zaimplementować obsługę klasy dla tego zdarzenia w klasach pochodnych.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje zdarzenie <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /> kierowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory zdarzeń kierowanych są tworzone po zarejestrowaniu zdarzeń kierowanych. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu i metodę narzędzia służącą do dodawania właścicieli zdarzenia. Możesz użyć tych identyfikatorów, aby dodać obsługę klas.  
  
 Więcej informacji o rejestrowaniu zdarzeń kierowanych znajduje <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>się w temacie. Aby uzyskać więcej informacji na temat używania identyfikatorów zdarzeń kierowanych do dodawania obsługi klas <xref:System.Windows.EventManager.RegisterClassHandler%2A>, zobacz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po otwarciu dowolnego menu kontekstowego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby ręcznie otworzyć menu kontekstowe, programy obsługi zdarzeń powinny oznaczyć odpowiednie zdarzenie jako obsłużone. W przeciwnym razie istniejąca wartość <xref:System.Windows.FrameworkElement.ContextMenu%2A> właściwości zostanie użyta do automatycznego otwarcia menu kontekstowego. Oznaczenie obsłużonego zdarzenia będzie efektywnie anulować akcję domyślną i może być możliwością zresetowania wartości <xref:System.Windows.FrameworkElement.ContextMenu%2A> właściwości, a następnie otworzenia nowej. <xref:System.Windows.Controls.ContextMenu> Istnieje jednak problem z chronometrażem, którego należy wiedzieć. W celu całkowitego zastąpienia menu kontekstowego za pomocą <xref:System.Windows.FrameworkElement.ContextMenuOpening> programu obsługi, początkowe menu kontekstowe nie może mieć wartości null ani być puste. Alternatywnie może być konieczne obsłużenie zdarzenia, a następnie ręczne otwarcie nowego menu kontekstowego. Aby uzyskać szczegółowe informacje [, zobacz How to: Obsłuż zdarzenie](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)ContextMenuOpening.  
  
 Aby użyć tego zdarzenia jako <xref:System.Windows.EventTrigger> stylu, należy odwołać się do powiązanego dołączonego zdarzenia:  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (To użycie jest wymagane, ponieważ implementacja zdarzeń w <xref:System.Windows.FrameworkElement> programie, która ujawnia podstawowe zdarzenie usługi, nie <xref:System.Windows.FrameworkElement.ContextMenuOpening> mapuje identyfikatora takiego, że można go używać w wyzwalaczach).  
  
 <xref:System.Windows.Controls.ContextMenu>sama jest <xref:System.Windows.FrameworkElement> klasą pochodną, ale to zdarzenie nie zostanie wywołane z menu kontekstowego, które jest otwierane jako źródło. Zdarzenie jest wywoływane z elementu, który "jest właścicielem menu kontekstowego jako właściwości i jest uruchamiany tylko wtedy, gdy użytkownik próbuje otworzyć menu kontekstowe w interfejsie użytkownika. Możliwe <xref:System.Windows.Controls.ContextMenu> jest <xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType>posiadanie właściwości, ale należy unikać tego scenariusza (Aby uzyskać szczegółowe informacje, zobacz). <xref:System.Windows.FrameworkElement.ContextMenu%2A>  
  
 Sama klasa ma również podobne zdarzenie (<xref:System.Windows.Controls.ContextMenu.Opened>), ale <xref:System.Windows.Controls.ContextMenu.Opened> nie zapewnia możliwości anulowania akcji użytkownika. <xref:System.Windows.Controls.ContextMenu>  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ContextMenuOpeningEvent>|  
|Strategia routingu|Propagacja|  
|Delegate|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   Przesłoń <xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A> , aby zaimplementować obsługę klasy dla tego zdarzenia w klasach pochodnych.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje zdarzenie <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> kierowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory zdarzeń kierowanych są tworzone po zarejestrowaniu zdarzeń kierowanych. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu i metodę narzędzia służącą do dodawania właścicieli zdarzenia. Możesz użyć tych identyfikatorów, aby dodać obsługę klas.  
  
 Więcej informacji o rejestrowaniu zdarzeń kierowanych znajduje <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>się w temacie. Aby uzyskać więcej informacji na temat używania identyfikatorów zdarzeń kierowanych do dodawania obsługi klas <xref:System.Windows.EventManager.RegisterClassHandler%2A>, zobacz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.ContextMenu" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kursor wyświetlany, gdy wskaźnik myszy znajduje się nad tym elementem.</summary>
        <value>Kursor, który ma zostać wyświetlony. Wartość domyślna jest definiowana jako <see langword="null" /> dla tej właściwości zależności. Jednak praktyczne wartości domyślne w czasie wykonywania będą pochodzić z różnych czynników.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po ustawieniu tej właściwości w programie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] procesor opiera się <xref:System.Windows.Input.Cursor> na konwersji typu dla klasy w celu obliczenia ciągu. Podany ciąg powinien być obliczany <xref:System.Windows.Input.CursorType> jako wartość. Aby <xref:System.Windows.Input.Cursor> uzyskać szczegółowe informacje, zobacz.  
  
 Określa, czy kursor ustalony przez tę właściwość lub nie będzie wyświetlany, gdy wskaźnik myszy znajduje się nad tym elementem również zależy od wartości <xref:System.Windows.FrameworkElement.ForceCursor%2A> właściwości. Ponadto zagadnienia dotyczące zdarzenia, takie jak aktywne przeciąganie, przechwytywanie myszy, tryby edycji tekstu w kontrolkach i tak dalej, wpłyną również na kursor o wyższym priorytecie niż wartość określona w tej właściwości.  
  
 Aby przywrócić zachowanie ustawienia tej właściwości do ostatecznej wartości domyślnej, ustaw ją `null` ponownie.  
  
 `null` Ustawienie domyślne naprawdę oznacza, że określenie praktycznej wartości kursora jest odroczone i powinno zostać uzyskane z innego miejsca. Jeśli jest prezentowane bez wartości programistycznych z dowolnego źródła, kursor domyślny, który jest wizualnie [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] przeznaczony dla aplikacji, będzie strzałką. Jednak przejściowe zmiany kursora nie są ustawione na <xref:System.Windows.FrameworkElement.Cursor%2A> wartości elementów, gdy są one przenoszone. <xref:System.Windows.FrameworkElement.Cursor%2A> Właściwość będzie raportować wartości inne niż null w przypadkach, w których została ustawiona w rzeczywistości, na przykład za pomocą kodu lub stylu. Każdy ruch myszy nad [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] aplikacją <xref:System.Windows.UIElement.QueryCursor> wywołuje zdarzenie. Bąbelki zdarzeń i każdy element na trasie mają możliwość obsługi zdarzenia i ustawiania wartości kursora przez argumenty tego zdarzenia. Jest to mechanizm, który generuje wizualnie widoczny kursor w większości przypadków. Jeśli program obsługi zwróci wynik kursora, oznacza to, że zdarzenie jest obsługiwane i ma zmienioną wartość w argumentach ma pierwszeństwo przed wartością <xref:System.Windows.FrameworkElement.Cursor%2A> właściwości na dowolnym poziomie, chyba że <xref:System.Windows.FrameworkElement.ForceCursor%2A> jest ustawiona. <xref:System.Windows.UIElement.QueryCursor>  
  
 Jeśli nie, nie tworzysz kursora niestandardowego, zazwyczaj Właściwość ta jest ustawiana na wartość <xref:System.Windows.Input.Cursors> właściwości statycznej klasy. Ustawienie <xref:System.Windows.FrameworkElement.Cursor%2A> w kodzie wymaga jednego z następujących elementów:  
  
-   <xref:System.Windows.Input.Cursor> Wywołaj <xref:System.Windows.Input.Cursor> konstruktora, aby uzyskać wystąpienie. Obie sygnatury <xref:System.Windows.Input.Cursor> konstruktora używają strumieni lub plików, w przypadku gdy <xref:System.Windows.Input.Cursor> tworzysz obiekt dla niestandardowego kursora.  
  
-   <xref:System.Windows.Input.CursorConverter.ConvertFrom%2A> <xref:System.Windows.Input.CursorType> <xref:System.Windows.Input.CursorType>Użyj klasy i jej metody, aby określić kursor według lub ciąg, który może <xref:System.Windows.Input.Cursor>zostać obliczony do, i Cast Return. <xref:System.Windows.Input.CursorConverter>  
  
 <xref:System.Windows.Input.Cursor> Ustawienie wartości niestandardowej nie jest włączone w częściowej relacji zaufania. Aby uzyskać więcej informacji na temat niestandardowych kursorów, zobacz [przegląd danych wejściowych](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.CursorProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak celowo ustawić grafikę kursora.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.Cursor" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kontekst danych dla elementu, gdy uczestniczy w powiązaniu danych.</summary>
        <value>Obiekt, który ma być używany jako kontekst danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Kontekst danych* to koncepcja, która umożliwia elementom dziedziczenie informacji z ich elementów nadrzędnych o źródle danych używanym do tworzenia powiązań, a także innych właściwości powiązania, takich jak ścieżka.  
  
 Kontekst danych można ustawić bezpośrednio dla obiektu .NET, z powiązaniem, które oceniają właściwości tego obiektu. Alternatywnie można ustawić kontekst danych dla <xref:System.Windows.Data.DataSourceProvider> obiektu.  
  
 Ta właściwość zależności dziedziczy wartości właściwości. Jeśli istnieją elementy podrzędne bez innych wartości do <xref:System.Windows.FrameworkElement.DataContext%2A> ustanowienia za pomocą lokalnych wartości lub stylów, system właściwości ustawi wartość <xref:System.Windows.FrameworkElement.DataContext%2A> jako wartość najbliższego nadrzędnego elementu z tą wartością.  
  
 Alternatywnie możesz użyć jednej z następujących właściwości <xref:System.Windows.Data.Binding> klasy, aby jawnie określić źródło powiązania:
  
    - <xref:System.Windows.Data.Binding.ElementName%2A>.
    - <xref:System.Windows.Data.Binding.Source%2A>.
    - <xref:System.Windows.Data.Binding.RelativeSource%2A>. 
  
  Aby uzyskać więcej informacji, zobacz [jak: Określ źródło](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)powiązania.  
  
 W języku XAML <xref:System.Windows.FrameworkElement.DataContext%2A> jest najczęściej ustawiany <xref:System.Windows.Data.Binding> jako deklaracja. Można użyć składni elementu właściwości lub składni atrybutów. Składnia atrybutu jest pokazana w przykładzie na tej stronie. Można również użyć kodu do ustawienia <xref:System.Windows.FrameworkElement.DataContext%2A>.  
  
 <xref:System.Windows.FrameworkElement.DataContext%2A>jest właściwością do powiązania, aby ułatwić scenariusze, w których jeden kontekst może być powiązany z innym. Jeśli jednak powiążesz się <xref:System.Windows.FrameworkElement.DataContext%2A>z, należy zachować ostrożność, aby nie tworzyć cykliczne odwołania do <xref:System.Windows.FrameworkElement.DataContext%2A> powiązań (nie należy powiązać do samego siebie, co jest możliwe z powodu dziedziczenia <xref:System.Windows.FrameworkElement.DataContext%2A> wartości właściwości właściwości).  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```xaml  
<object DataContext="bindingUsage"/>  
```

—lub—

```xaml
<object DataContext="{resourceExtension contextResourceKey}"/>  
```
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *dataContextObject*  
 Obiekt bezpośrednio osadzony, który służy jako kontekst danych dla wszelkich powiązań w elemencie nadrzędnym. Zazwyczaj ten obiekt jest <xref:System.Windows.Data.Binding> lub inną <xref:System.Windows.Data.BindingBase> klasą pochodną. Alternatywnie dane pierwotne dowolnego typu obiektu przeznaczonego do powiązania mogą zostać umieszczone tutaj, z rzeczywistymi powiązaniami zdefiniowanymi w dalszej części.  
  
 *bindingUsage*  
 Użycie powiązania, które jest oceniane do odpowiedniego kontekstu danych. Aby uzyskać szczegółowe informacje, zobacz [Binding Markup Extension](~/docs/framework/wpf/advanced/binding-markup-extension.md).  
  
 *resourceExtension*  
 Jeden z następujących elementów: [`StaticResource`](~/docs/framework/wpf/advanced/staticresource-markup-extension.md) lub [`DynamicResource`](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md). To użycie jest używane w przypadku odwoływania się do danych pierwotnych zdefiniowanych jako obiekt w zasobach. Zobacz [zasoby XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *contextResourceKey*  
 Identyfikator klucza dla obiektu, z <xref:System.Windows.ResourceDictionary>którego zażądano.  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.DataContextProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Poniższy przykład ilustruje, jak kontekst danych działa na powiązanie i zawiera informacje definiujące określone wartości powiązanych właściwości.  
  
 [!code-xaml[MasterDetail#DataContextProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty)]  
[!code-xaml[MasterDetail#DataContextProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty2)]  
[!code-xaml[MasterDetail#DataContextProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zostanie zmieniony kontekst danych dla tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać wyjaśnienie kontekstów danych i powiązania danych, zobacz temat [powiązanie danych — omówienie](~/docs/framework/wpf/data/data-binding-overview.md).  
  
> [!IMPORTANT]
>  Gdy element <xref:System.Windows.FrameworkElement.DataContext%2A> dla elementu ulegnie zmianie, wszystkie właściwości powiązane z danymi w tym elemencie mogą być zagrożone. Dotyczy to wszystkich elementów, które są elementami podrzędnymi bieżącego elementu w drzewie logicznym, które dziedziczą kontekst danych, a także bieżącego elementu. Wszystkie istniejące powiązania muszą rezinterpretować nowe <xref:System.Windows.FrameworkElement.DataContext%2A> i przeocenić wyniki powiązania. Aparat powiązań danych nie jest deterministyczny względem kolejności tych ocen w stosunku do podniesienia <xref:System.Windows.FrameworkElement.DataContextChanged> poziomu zdarzenia. Ponowne oceny mogą wystąpić przed zdarzeniem, po zdarzeniu lub w dowolnej mieszaninie.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.DataContext" />
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.DataContext" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia klucz, który będzie używany do odwoływania się do stylu dla tej kontrolki, gdy są używane lub zdefiniowane style motywu.</summary>
        <value>Klucz stylu. Aby prawidłowo działać jako część wyszukiwania w stylu motywu, ta wartość powinna być <see cref="T:System.Type" /> wartością kontrolki z stylem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwykle nie jest ustawiana za pośrednictwem żadnej z bezpośrednich metod dostępu do właściwości. Zamiast tego przesłonić metadane specyficzne dla typu tej właściwości zależności za każdym razem, gdy tworzysz nową <xref:System.Windows.FrameworkElement> klasę pochodną. Gdy uzyskujesz kontrolę, wywołaj <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> metodę <xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty> względem identyfikatora, w ramach konstruktora statycznego klasy pochodnej formantu (lub równoważnej inicjacji klasy).  
  
 Kontrolka zwykle zastępuje domyślną wartość tej właściwości jako własny typ, ale w niektórych przypadkach może również użyć typu podstawowego, dla którego istnieje styl w słownikach motywów. Jest to możliwe tylko wtedy, gdy szablony kontrolek podstawowych całkowicie definiują wizualną reprezentację tej kontrolki pochodnej, a jeśli jakiekolwiek dodatkowe elementy członkowskie ujawniane przez typy pochodne nie wymagają dodatkowych elementów jako części szablonu kontrolki.  
  
 Jeśli chcesz, aby element lub formant nie używał stylów motywu, ustaw <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> właściwość na. `true`  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie zastąpień metadanych właściwości zależności omówione w uwagi. Ten kod definiuje klasę `NumericUpDown` formantów niestandardowych, która ma zostać użyta z dedykowanego zestawu biblioteki formantów. Zilustrowany Konstruktor statyczny odwołuje się do pewnej prywatnej funkcji inicjującej, rejestruje procedurę obsługi klasy (inny scenariusz podklasy kontrolki wspólnej), zobacz [oznaczanie zdarzeń kierowanych jako obsłużone i obsługa klasy](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)) i na konieczastępuje<xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> metadane właściwości zależności w `NumericUpDown` klasie. <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A>zawsze zwraca swój własny typ jako zamierzony klucz, który jest konwencją używaną przez system stylu motywu do wyszukania stylu dla dowolnego dowolnie innej kontrolki. Kompletny przykład definiuje również styl motywu rzeczywistej kontrolki, do którego odwołuje się ten klucz; Zobacz [kontrolkę niestandardową NumericUpDown z motywem i przykładem obsługi automatyzacji interfejsu użytkownika](https://go.microsoft.com/fwlink/?LinkID=160025).  
  
 [!code-csharp[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/NumericUpDown2.cs)]
 [!code-vb[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/numericupdown2.vb)]  

  Pełny kod źródłowy tego przykładu jest dostępny w witrynie GitHub dla obu [C#](https://github.com/dotnet/samples/tree/master/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary) i [Visual Basic](https://github.com/dotnet/samples/tree/master/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary).

 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160025">NumericUpDown kontrolkę niestandardową z motywem i przykładem obsługi automatyzacji interfejsu użytkownika</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.DefaultStyleKey" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkElement.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, że proces inicjalizacji dla elementu został ukończony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.FrameworkElement.BeginInit%2A> została wcześniej wywołana, podstawowa implementacja spowoduje <xref:System.Windows.FrameworkElement.Initialized> wygenerowanie zdarzenia. W przeciwnym razie <xref:System.Windows.FrameworkElement.BeginInit%2A> , jeśli nie została wywołana lub nie można ustalić, <xref:System.Windows.FrameworkElement.BeginInit%2A> czy został wywołany, nie jest wywoływany, <xref:System.Windows.FrameworkElement.Initialized> a zamiast tego zostanie zgłoszony wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.FrameworkElement.EndInit" />został wywołany <see cref="M:System.Windows.FrameworkElement.BeginInit" /> bez wcześniejszego wywołania elementu.</exception>
        <block subset="none" type="overrides"><para>Zaimplementuj tę metodę, aby zapewnić specjalną obsługę, która powinna wystąpić, gdy element zostanie zainicjowany podczas procesu ładowania elementu.  
  
 Implementacja powinna wywołać implementację podstawową, ponieważ implementacja podstawowa (domyślna) ustawia pewne flagi wewnętrzne, aby śledzić inicjalizację.</para></block>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa żądanego elementu.</param>
        <summary>Znajduje element o podanej nazwie identyfikatora.</summary>
        <returns>Żądany element. Może to być <see langword="null" /> możliwe, jeśli nie znaleziono pasującego elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli element ma elementy podrzędne, te elementy podrzędne są przeszukiwane cyklicznie dla żądanego nazwanego elementu.  
  
 <xref:System.Windows.FrameworkElement.FindName%2A>działa w ramach namescope bieżącego elementu. Aby uzyskać szczegółowe informacje, zobacz [WPF XAML Zakresy nazw WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
        <related type="Article" href="https://msdn.microsoft.com/library/b7e61222-e8cf-48d2-acd0-6df3b7685d48">x:Name — atrybut</related>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Identyfikator klucza dla żądanego zasobu.</param>
        <summary>Wyszukuje zasób z określonym kluczem i zgłasza wyjątek, jeśli nie odnaleziono żądanego zasobu.</summary>
        <returns>Żądany zasób. Jeśli nie znaleziono zasobu z podanym kluczem, zostanie zgłoszony wyjątek. W przypadku wyjątku może być również zwracana wartość.<see cref="F:System.Windows.DependencyProperty.UnsetValue" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  W przypadku wywołania tej metody dla klucza, którego nie można znaleźć, zostanie zgłoszony wyjątek. Jeśli nie chcesz obsługiwać wyjątków wynikających z wywołania <xref:System.Windows.FrameworkElement.FindResource%2A>, zamiast tego wywołaj. <xref:System.Windows.FrameworkElement.TryFindResource%2A> <xref:System.Windows.FrameworkElement.TryFindResource%2A>zwraca `null` , gdy nie można znaleźć żądanego zasobu i nie zgłasza wyjątku.  
  
 Jeśli zasób nie zostanie znaleziony w elemencie wywołującym, element nadrzędny w drzewie logicznym zostanie przeszukany dalej, a następnie aplikacja, motywy i końcowe zasoby systemowe. Ta metodologia wyszukiwania jest taka sama jak w przypadku przeszukiwania drzewa, jeśli zażądano zasobu przez odwołanie do zasobu dynamicznego w znaczniku. Aby uzyskać więcej informacji na temat wyszukiwania zasobów, zobacz [zasoby XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 Zazwyczaj natychmiast rzutuje <xref:System.Windows.FrameworkElement.FindResource%2A> wartość zwracaną na typ właściwości, która jest ustawiana za pomocą zwracanej wartości zasobu.  
  
 Klucze zasobów nie muszą być ciągami. Na przykład style dla kontrolek na poziomie motywu są celowo przystosowane do <xref:System.Type> formantu, a style aplikacji lub strony dla formantów zwykle korzystają z tej samej Konwencji klucza. Aby uzyskać szczegółowe informacje, zobacz [Style i tworzenia szablonów](~/docs/framework/wpf/controls/styling-and-templating.md) lub [XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
   
  
## Examples  
 Poniższy przykład uzyskuje nazwany zasób i rzutuje go na odpowiedni typ w celu wypełnienia właściwości.  
  
 [!code-csharp[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page3.xaml.cs#resourceproceduralget)]
 [!code-vb[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page3.xaml.vb#resourceproceduralget)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException"><paramref name="resourceKey" />nie znaleziono i program obsługi zdarzeń nie istnieje dla <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /> zdarzenia.  
  
—lub— 
 <paramref name="resourceKey" />nie znaleziono i <see cref="P:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled" /> właściwość jest <see langword="false" /> w <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /> zdarzeniu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceKey" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FlowDirection">
      <MemberSignature Language="C#" Value="public System.Windows.FlowDirection FlowDirection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FlowDirection FlowDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FlowDirection" />
      <MemberSignature Language="VB.NET" Value="Public Property FlowDirection As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FlowDirection FlowDirection { System::Windows::FlowDirection get(); void set(System::Windows::FlowDirection value); };" />
      <MemberSignature Language="F#" Value="member this.FlowDirection : System.Windows.FlowDirection with get, set" Usage="System.Windows.FrameworkElement.FlowDirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kierunek, w jakim tekst i [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] inne elementy będą przepływać w obrębie dowolnego elementu nadrzędnego, który kontroluje ich układ.</summary>
        <value>Kierunek, w jakim tekst i [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] inne elementy są przepływem w elemencie nadrzędnym jako wartość wyliczenia. Wartość domyślna to <see cref="F:System.Windows.FlowDirection.LeftToRight" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie właściwości zależności ustawia wartość <xref:System.Windows.FrameworkElement.FlowDirection%2A> dla tego elementu. Ze względu na dziedziczenie wartości <xref:System.Windows.FrameworkElement.FlowDirection%2A> właściwości ustawienie dla elementu może być <xref:System.Windows.FrameworkElement.FlowDirection%2A> potencjalnie ustawione dla wszystkich elementów podrzędnych, które <xref:System.Windows.FrameworkElement.FlowDirection%2A> nie zostały ustawione lokalnie, lub jeśli są inne, takie jak style.  
  
 Ta właściwość nie jest ustawiana automatycznie jako część informacji o kulturze aplikacji, ponieważ element może zawierać zawartość niekonieczną do przestrzegania ogólnego kierunku przepływu implikowanego przez informacje o kulturze. Aby uzyskać więcej informacji na temat zagadnień związanych z globalizacją, zobacz [globalizacja dla WPF](~/docs/framework/wpf/advanced/globalization-for-wpf.md).  
  
 Ta właściwość ma zdefiniowany [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] akcesor dostępu do właściwości, więc działa jako właściwość zależności. Jest to jednak również zarejestrowane jako dołączone, więc może również działać jako dołączona właściwość. Dołączona Rejestracja polega głównie na tym, że dziedziczenie wartości właściwości jest obsługiwane, ale właściwość może być również używana jako właściwość dołączona true. Użycie dołączonej właściwości ma zastosowanie tylko wtedy <xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkElement>, gdy obiekt, dla którego zamierzasz ustawić kierunek przepływu, ma element nadrzędny, który go wykonuje, nie należy do i nie jest jeszcze zdefiniowany `FlowDirection` bezpośrednio wartość. (Niektóre klasy dokumentu przepływu, takie jak <xref:System.Windows.Documents.Block> i <xref:System.Windows.Documents.Inline> definiują własne `FlowDirection`, i tej właściwości można również ustawić kierunek przepływu. Wartość właściwości jest odczytywana przez hosta zawartości ostatecznej bez konieczności użycia dołączonej właściwości.)  
  
<a name="xamlAttributeUsage_FlowDirection"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
 \<*object* **FlowDirection**="<xref:System.Windows.FlowDirection>"/>  
  
<a name="xamlTextUsage_FlowDirection"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Tę właściwość można również ustawić dla klas, które nie <xref:System.Windows.FrameworkElement> są klasami pochodnymi, przez następujące [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] użycie dołączonej właściwości:  
  
 `<` *object* `FrameworkElement.`**FlowDirection**="<xref:System.Windows.FlowDirection>`"/>`  
  
<a name="dependencyPropertyInfo_FlowDirection"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.FlowDirectionProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 Ta właściwość jest właściwością zależności i dołączoną właściwością; Zobacz uwagi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlowDirectionProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FlowDirectionProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FlowDirectionProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FlowDirectionProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FlowDirectionProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FlowDirectionProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia właściwość, która umożliwia dostosowanie wyglądu, efektów lub innych cech stylu, które będą stosowane do tego elementu, gdy przechwytuje fokus klawiatury.</summary>
        <value>Żądany styl, który ma zostać zastosowany do fokusu. Wartość domyślna zadeklarowana we właściwości zależności jest pustą statyczną <see cref="T:System.Windows.Style" />. Jednak efektywna wartość w czasie wykonywania jest często (ale nie zawsze) stylem, zgodnie z obsługą motywu dla kontrolek.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość ma wpływ na wygląd wizualizacji, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> ale nie raportuje w metadanych. Wynika to z faktu, że zmiana wyglądu wizualizacji jest sterowana zdarzeniami i może nie być stosowana przez cały czas i dlatego nie powinna raportować żadnych informacji wizualizacji lub układu w metadanych.  
  
 Koncepcyjnie, wizualne zachowanie fokusu zastosowany do kontrolki powinno być spójne od kontroli do kontroli. Najbardziej rozsądnym sposobem wymuszania spójności jest zmiana stylu wizualizacji fokusu tylko w przypadku redagowania całego motywu. Ustawienie tej właściwości dla poszczególnych stylów kontrolek, a nie jako części motywu, nie jest zamierzonym użyciem tej właściwości, ponieważ może to prowadzić do mylącego środowiska użytkownika dotyczącego fokusu klawiatury. Jeśli zamierzasz zachowywać zachowanie specyficzne dla kontroli, które jest świadomie niespójne w motywie, znacznie lepszym rozwiązaniem jest użycie wyzwalaczy w stylach dla poszczególnych właściwości stanu wejściowego, <xref:System.Windows.UIElement.IsFocused%2A> takich <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>jak lub, i w taki sposób, aby nie wizualnie przeszkadza na dowolnym istniejącym stylu wizualizacji fokusu. Aby uzyskać więcej informacji na temat zamiaru <xref:System.Windows.FrameworkElement.FocusVisualStyle%2A> projektowania i właściwości alternatywnej ostrości, zobacz [Style dla fokusu w kontrolkach i FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *resourceExtension*  
 Jeden z następujących elementów:, lub. Zobacz [zasoby XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Klucz, który identyfikuje żądany styl. Klucz odnosi się do istniejącego zasobu w <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Składnia elementu właściwości jest technicznie możliwa, ale nie jest zalecana. Zobacz [wbudowane style i szablony](~/docs/framework/wpf/advanced/inline-styles-and-templates.md). Odwołanie do powiązania przy użyciu [szablonu TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md) lub <xref:System.Windows.Data.Binding> jest również możliwe, ale nietypowe.  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.FocusVisualStyleProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.FocusVisualStyle" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Windows.FrameworkElement" /> powinien [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] wymusić renderowanie <see cref="P:System.Windows.FrameworkElement.Cursor" /> kursora jako zadeklarowanego przez właściwość.</summary>
        <value><see langword="true" />Jeśli prezentacja kursora nad tym elementem jest wymuszana przy użyciu bieżących <see cref="P:System.Windows.FrameworkElement.Cursor" /> ustawień kursora (łącznie ze wszystkimi elementami podrzędnymi); w przeciwnym <see langword="false" />razie. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie tej właściwości `true` spowoduje przesłonięcie preferencji kursora określonych przez elementy podrzędne. Wykonanie tej operacji w ogólnej [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] aplikacji może być mylące dla użytkownika, szczególnie w przypadku, gdy elementy podrzędne próbują określić kursory. Ustawienie <xref:System.Windows.FrameworkElement.ForceCursor%2A> jest bardziej odpowiednie w scenariuszach podklasy kontroli lub składania.  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ForceCursorProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład wymusza wartość kursora.  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.ForceCursor" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Obiekt docelowy <see cref="T:System.Windows.DependencyProperty" /> , z którego ma zostać pobrane powiązanie.</param>
        <summary><see cref="T:System.Windows.Data.BindingExpression" /> Zwraca wartość reprezentującą powiązanie dla określonej właściwości.</summary>
        <returns>A <see cref="T:System.Windows.Data.BindingExpression" /> Jeśli właściwość target ma aktywne powiązanie; w przeciwnym razie zwraca <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sprawdzenie wartości zwracanej przez `null` to technika, której można użyć do określenia, czy właściwość ma aktywne powiązanie.  
  
 Ta metoda jest naprawdę tylko wygodną otoką wokół <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType> metody. <xref:System.Windows.FrameworkElement.GetBindingExpression%2A>przekazuje bieżące wystąpienie i `dp` parametr do. <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Data.BindingOperations" />
      </Docs>
    </Member>
    <Member MemberName="GetFlowDirection">
      <MemberSignature Language="C#" Value="public static System.Windows.FlowDirection GetFlowDirection (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FlowDirection GetFlowDirection(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFlowDirection (element As DependencyObject) As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FlowDirection GetFlowDirection(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFlowDirection : System.Windows.DependencyObject -&gt; System.Windows.FlowDirection" Usage="System.Windows.FrameworkElement.GetFlowDirection element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Element, dla którego ma <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> zostać zwrócona wartość.</param>
        <summary>Pobiera wartość <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> dołączonej właściwości dla określonego <see cref="T:System.Windows.DependencyObject" />elementu.</summary>
        <returns>Żądany kierunek przepływu, jako wartość wyliczenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Głównym celem tej metody jest obsługa składni właściwości dołączonej dla <xref:System.Windows.FrameworkElement.FlowDirection%2A> właściwości, co pozwala <xref:System.Windows.FrameworkElement> na określenie kierunku przepływu dla danego układu w elemencie nadrzędnym. Aby uzyskać wartość w bieżącym <xref:System.Windows.FrameworkElement>, użyj bezpośredniej [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] metody dostępu <xref:System.Windows.FrameworkElement.FlowDirection%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="GetLayoutClip">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Geometry GetLayoutClip(valuetype System.Windows.Size layoutSlotSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetLayoutClip (layoutSlotSize As Size) As Geometry" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Geometry ^ GetLayoutClip(System::Windows::Size layoutSlotSize);" />
      <MemberSignature Language="F#" Value="override this.GetLayoutClip : System.Windows.Size -&gt; System.Windows.Media.Geometry" Usage="frameworkElement.GetLayoutClip layoutSlotSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layoutSlotSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="layoutSlotSize">Rozmiar części elementu, który robi prezentację wizualną.</param>
        <summary>Zwraca geometrię dla maski przycinającej. Maska ma zastosowanie, gdy system układu próbuje rozmieścić element, który jest większy niż dostępne miejsce do wyświetlenia.</summary>
        <returns>Geometria wycinka.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Marginesy zostaną odjęte od `layoutSlotSize` części jako zachowanie systemu układu.  
  
 Zwrócone odwołanie o wartości null wskazuje, że żadne przycinanie nie zostanie wykonane. Domyślna implementacja zawsze zwraca wartość `null` , <xref:System.Windows.UIElement.ClipToBounds%2A> gdy `false`jest. Ta metoda przesłania <xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=nameWithType>. Implementacja używa <xref:System.Windows.FrameworkElement.MaxHeight%2A> i<xref:System.Windows.FrameworkElement.MaxWidth%2A>wobliczeniach. <xref:System.Windows.FrameworkElement> Kilka podklas <xref:System.Windows.FrameworkElement> przesłonięcia tej metody ponownie. <xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=nameWithType>, zastąpienia, aby zawsze `null` zwracały się, ponieważ moduły definiowania układu często zamierzone poza zwykłymi granicami. <xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=nameWithType>i <xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=nameWithType> Return `null` if is<xref:System.Windows.UIElement.ClipToBounds%2A> . `false`  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Domyślna implementacja zawsze zwraca wartość <see langword="null" /> , <see cref="P:System.Windows.UIElement.ClipToBounds" /> gdy <see langword="false" />jest. Przesłonięcia zwykle oczekuje na zachowanie tego zachowania, chociaż istnieją wyjątki, w zależności od relacji i przeznaczenia klasy pochodnej i jej logiki układu, w przeciwieństwie do klasy podstawowej.</para></block>
        <altmember cref="P:System.Windows.UIElement.Clip" />
        <altmember cref="P:System.Windows.UIElement.ClipToBounds" />
      </Docs>
    </Member>
    <Member MemberName="GetTemplateChild">
      <MemberSignature Language="C#" Value="protected internal System.Windows.DependencyObject GetTemplateChild (string childName);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Windows.DependencyObject GetTemplateChild(string childName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetTemplateChild (childName As String) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Windows::DependencyObject ^ GetTemplateChild(System::String ^ childName);" />
      <MemberSignature Language="F#" Value="member this.GetTemplateChild : string -&gt; System.Windows.DependencyObject" Usage="frameworkElement.GetTemplateChild childName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="childName">Nazwa elementu podrzędnego do znalezienia.</param>
        <summary>Zwraca nazwany element w drzewie wizualnym wystąpienia <see cref="T:System.Windows.Controls.ControlTemplate" />.</summary>
        <returns>Żądany element. Może być <see langword="null" /> , jeśli nie istnieje żaden element żądanej nazwy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Szablony w [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] programie mają własne namescope. Wynika to z faktu, że szablony są ponownie używane, a jakakolwiek nazwa zdefiniowana w szablonie nie może pozostawać unikatowa, gdy wiele wystąpień formantu każdy tworzy jego szablon. Wywołaj <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> metodę, aby zwrócić odwołania do obiektów, które pochodzą z szablonu po jego utworzeniu. Nie można użyć <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> metody do znajdowania elementów z szablonów, <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> ponieważ działa w bardziej ogólnym zakresie i nie istnieje połączenie między <xref:System.Windows.Controls.ControlTemplate> samą klasą i szablonem skonkretyzowanym po jego zastosowaniu.  
  
 <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType>dostarcza tę samą funkcję, co ta metoda. <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType>jest publiczny, a nie chroniony, i używa prawidłowych zagadnień dotyczących określania nazw, które zezwalają na dostęp do szablonu w obrębie elementu i Znajdź nazwane elementy w nim. Użyj <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> , gdy musisz uzyskać element poza jego kontrolką nadrzędną.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkTemplate.FindName(System.String,System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca alternatywny logiczny element nadrzędny dla tego elementu, jeśli nie istnieje obiekt nadrzędny.</summary>
        <returns>Zwraca coś innego niż <see langword="null" /> za każdym razem, gdy implementacja tej metody na poziomie platformy WPF jest niewizualna.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przesłania <xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=nameWithType>. Domyślna <xref:System.Windows.FrameworkElement> implementacja zwraca oczekiwaną pojedynczą wizualizację nadrzędną, która jest taka sama, jak <xref:System.Windows.FrameworkElement.Parent%2A> pobieranie wartości. Implementacje klas pochodnych mogą zwracać alternatywne relacje nadrzędne.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberSignature Language="F#" Value="override this.GetVisualChild : int -&gt; System.Windows.Media.Visual" Usage="frameworkElement.GetVisualChild index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks (liczony od zera) żądanego elementu podrzędnego w kolekcji.</param>
        <summary>Przesłania <see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" />i zwraca element podrzędny o określonym indeksie z kolekcji elementów podrzędnych.</summary>
        <returns>Żądany element podrzędny. Ta wartość nie powinna <see langword="null" />zostać zwrócona; Jeśli podany indeks znajduje się poza zakresem, zgłaszany jest wyjątek.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> W implementacji Jedynym prawidłowym indeksem jest zero. Model zawartości dla programu <xref:System.Windows.FrameworkElement.GetVisualChild%2A> obsługuje zero lub jeden element podrzędny, a nie kolekcję.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak niestandardowy moduł definiowania układu używa wartości zadeklarowanych przez <xref:System.Windows.Media.VisualCollection> , które utrzymuje dla wielu wizualizacji podrzędnych. Te wartości są raportowane za poorednictwem <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> przesłonięć <xref:System.Windows.FrameworkElement.GetVisualChild%2A>i.  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ta implementacja jest prawidłowa tylko dla elementów, które nie obsługują więcej opisowych kolekcji elementów podrzędnych wizualizacji. Każdy element, który ma taką kolekcję, musi przesłonić tę metodę i zmapować indeks na odpowiedni indeks w kolekcji elementów podrzędnych, która jest obsługiwana przez ten element. Indeks zakresu od zero do <see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /> (minus jeden) powinien zwrócić prawidłowy element; każdy inny indeks powinien zgłosić wyjątek poza zakresem. Przykład typu elementu, który obsługuje kolekcję podrzędną i przesłonięcia <see cref="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" /> w celu zwrócenia więcej niż jednego możliwego <see cref="T:System.Windows.Controls.Panel" />elementu podrzędnego.  
  
Domyślna implementacja w <see cref="T:System.Windows.FrameworkElement" /> przypuszczalnie ma tylko jeden element podrzędny. Każda wartość przenoszona <paramref name="index" /> przez inną niż zero powoduje wystąpienie wyjątku. Kilka typowych elementów, takich jak dekoratory, moduły definiowania układu lub elementy z wyspecjalizowanym renderowaniem, <see cref="T:System.Windows.FrameworkElement" /> przesłania implementację (implementacji z pośrednich klas bazowych). Niektóre implementacje nadal wymuszają jeden element wizualny wizualizacji, a inne zezwalają na zbieranie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public double Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Height" />
      <MemberSignature Language="VB.NET" Value="Public Property Height As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Height { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Height : double with get, set" Usage="System.Windows.FrameworkElement.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia sugerowaną wysokość elementu.</summary>
        <value>Wysokość elementu w [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Wartość domyślna to <see cref="F:System.Double.NaN" />. Ta wartość musi być równa lub większa niż 0,0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Height%2A>jest jedną z trzech właściwości do <xref:System.Windows.FrameworkElement> zapisu, która określa informacje o wysokości. Pozostałe dwa są <xref:System.Windows.FrameworkElement.MinHeight%2A> i <xref:System.Windows.FrameworkElement.MaxHeight%2A>. Jeśli występuje konflikt między tymi wartościami, kolejność aplikacji do ustalenia rzeczywistej wysokości jest taka, która najpierw <xref:System.Windows.FrameworkElement.MinHeight%2A> musi zostać uznana za zauważaną, następnie <xref:System.Windows.FrameworkElement.MaxHeight%2A>, i na koniec, jeśli znajduje się <xref:System.Windows.FrameworkElement.Height%2A>w granicach,.  
  
 Jeśli ten element jest elementem podrzędnym w obrębie innego elementu, a następnie ustawienie tej właściwości na wartość jest naprawdę tylko sugerowaną wartością. System układu, a także określona logika układu elementu nadrzędnego będzie używać wartości jako niewiążącego wejścia w procesie układu. W praktyce praktycznie zawsze <xref:System.Windows.FrameworkElement> jest elementem podrzędnym czegoś innego, nawet po <xref:System.Windows.FrameworkElement.Height%2A> ustawieniu na <xref:System.Windows.Window>. (Dla <xref:System.Windows.Window>, ta wartość jest używana, gdy podstawowy model aplikacji ustala podstawowe założenia renderowania, które tworzą Właściwość HWND, która hostuje aplikację).  
  
 Oprócz akceptowalnych <xref:System.Double> wartości ta właściwość może być <xref:System.Double.NaN?displayProperty=nameWithType>również. Jest to sposób określania zachowania autozmiany wielkości w kodzie. W [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] ustawieniu wartość na ciąg "Automatyczne" (bez uwzględniania wielkości liter), aby włączyć zachowanie funkcji autodopasowywania. Zachowanie funkcji autoustalania rozmiarów oznacza, że element będzie wypełniał dostępną wysokość. Należy jednak pamiętać, że poszczególne kontrolki często dostarczają wartości domyślne za pomocą domyślnych stylów motywów, które wyłączają zachowanie autozmiany rozmiarów, chyba że zostanie to włączone w szczególny sposób.  
  
 Wartość zwracana przez tę właściwość jest zawsze taka sama jak dowolna ustawiona wartość. W przeciwieństwie do wartości <xref:System.Windows.FrameworkElement.ActualHeight%2A> może się różnić. Może się to zdarzyć statycznie, ponieważ układ odrzucił sugerowany rozmiar z jakiegoś powodu lub chwilowo. Sam system układu działa asynchronicznie względem zestawu systemu właściwości <xref:System.Windows.FrameworkElement.Height%2A> i może nie przetworzyć jeszcze określonego ustawienia właściwości zmiany rozmiarów.  
  
 Ograniczenia wartości w <xref:System.Double> wartości są wymuszane <xref:System.Windows.ValidateValueCallback> przez mechanizm. Jeśli podjęto próbę ustawienia nieprawidłowej wartości, zostanie zgłoszony wyjątek czasu wykonywania.  
  
 Oprócz sprawdzania poprawności istnieje niedeterministyczna Górna wartość związana <xref:System.Windows.FrameworkElement.Height%2A> z tym, że jest wymuszana przez system układu (jest to bardzo duża liczba, większa niż <xref:System.Single.MaxValue?displayProperty=nameWithType> lub mniejsza niż <xref:System.Double.MaxValue?displayProperty=nameWithType>). W przypadku przekroczenia tego powiązania element nie zostanie renderowany i nie zostanie zgłoszony żaden wyjątek. Nie ustawiaj <xref:System.Windows.FrameworkElement.Height%2A> wartości, która jest znacznie większa niż maksymalny rozmiar wyświetlanej wizualizacji lub można przekroczyć tę niedeterministyczną górną granicę.  
  
<a name="xamlAttributeUsage_Height"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```xaml
<object Height="double"/>  
```

—lub—

```xaml
<object Height="qualifiedDouble"/>  
```

—lub—

```xaml
<object Height="Auto"/>  
```  
  
<a name="xamlValues_Height"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *double*  
 <xref:System.Double>  
  
 Ciąg reprezentujący <xref:System.Double> wartość równą lub większą niż 0,0. Zobacz uwagi dotyczące górnej granicy informacji. Ta wartość jest interpretowana jako [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] pomiar. Ciągi nie muszą jawnie zawierać punktów dziesiętnych. Na przykład akceptowalna `1` jest wartość.  
  
 *qualifiedDouble*  
 Wartość *Podwójna* , jak opisano powyżej, po której następuje jeden z następujących ciągów deklaracji jednostkowej `in`: `cm` `px`, `pt`,,.  
  
 `px`(wartość domyślna) to[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm`jest centymetry; 1cm = = (96/2.54) px  
  
 `pt`to punkty; 1 pkt = = (96/72) px  
  
 **Auto**  
 Włącza zachowanie autozmiany rozmiarów. Zobacz uwagi.  
  
<a name="dependencyPropertyInfo_Height"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.HeightProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.ActualHeight" />
      </Docs>
    </Member>
    <Member MemberName="HeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.HeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.Height" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.HorizontalAlignment HorizontalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.HorizontalAlignment HorizontalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalAlignment As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::HorizontalAlignment HorizontalAlignment { System::Windows::HorizontalAlignment get(); void set(System::Windows::HorizontalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.HorizontalAlignment : System.Windows.HorizontalAlignment with get, set" Usage="System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia charakterystyki wyrównania poziomego stosowane do tego elementu, gdy jest on tworzony w elemencie nadrzędnym, takim jak panel lub kontrolka elementów.</summary>
        <value>Ustawienie wyrównania poziomego jako wartość wyliczenia. Wartość domyślna to <see cref="F:System.Windows.HorizontalAlignment.Stretch" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.FrameworkElement.Height%2A> <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> <xref:System.Windows.HorizontalAlignment.Stretch>i <xref:System.Windows.FrameworkElement.Width%2A> właściwości są jawnie ustawiane dla elementu, pomiary są podejmowane na wyższym poziomie poprzedników podczas układania i anulują typowe efekty ustawienia do.  
  
 <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>to metoda dostępu do właściwościdlawłaściwościzależność.[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] Ta właściwość zależności często ma swoją pozornie ustawioną wartość "default" w różny sposób w elementach podklasy, szczególnie w kontrolkach. Zwykle jest to wykonywane na jeden z dwóch sposobów: właściwość zależności jest ponownie rejestrowana w określonej podklasy, ale z innymi metadanymi do ustawiania ich wartości domyślnych; lub jest stosowany styl domyślny, który ustawia wartość właściwości zależności inaczej. Na przykład pozorna wartość "default" <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> <xref:System.Windows.Controls.Label> dla kontrolki <xref:System.Windows.Controls.Label> będzie równa <xref:System.Windows.HorizontalAlignment.Left>, nawet jeśli dziedziczy <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> bezpośrednio z <xref:System.Windows.FrameworkElement>. Dzieje się tak <xref:System.Windows.Controls.Label>, ponieważ ta wartość została zresetowana w stylu domyślnym w szablonie kontrolki style.  
  
 <xref:System.Windows.Controls.Canvas>nie jest używany <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> podczas redagowania układu, ponieważ <xref:System.Windows.Controls.Canvas> jest oparty na rozłożeniu bezwzględnym.  
  
 Gdy dziedziczone przez <xref:System.Windows.Controls.Label> lub klasy pochodne, <xref:System.Windows.Controls.Label> ponownie definiuje domyślną wartość <xref:System.Windows.HorizontalAlignment.Left>tej właściwości zależności.  
  
<a name="dependencyPropertyInfo_HorizontalAlignment"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.HorizontalAlignmentProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HorizontalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HorizontalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HorizontalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HorizontalAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HorizontalAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.HorizontalAlignment" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InheritanceBehavior">
      <MemberSignature Language="C#" Value="protected internal System.Windows.InheritanceBehavior InheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.InheritanceBehavior InheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property InheritanceBehavior As InheritanceBehavior" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::InheritanceBehavior InheritanceBehavior { System::Windows::InheritanceBehavior get(); void set(System::Windows::InheritanceBehavior value); };" />
      <MemberSignature Language="F#" Value="member this.InheritanceBehavior : System.Windows.InheritanceBehavior with get, set" Usage="System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.InheritanceBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia limity zakresu dla dziedziczenia wartości właściwości, wyszukiwania kluczy zasobów i wyszukiwania RelativeSource FindAncestor.</summary>
        <value>Wartość wyliczenia. Wartość domyślna to <see cref="F:System.Windows.InheritanceBehavior.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre granice w drzewie <xref:System.Windows.FrameworkElement.InheritanceBehavior%2A> elementów, które w sposób celowy ograniczają zakres zachowania dziedziczenia, do wymuszania wyszukiwania zasobów w celu sprawdzenia zasobów aplikacji lub uniemożliwienia przeszukiwania przez RelativeSource FindAncestor z bieżącego elementu lub w jakikolwiek sposób. Wyszukiwanie RelativeSource FindAncestor występuje <xref:System.Windows.Data.RelativeSource> , gdy powiązanie używa <xref:System.Windows.Data.RelativeSource.Mode%2A> właściwości, która ma ustawioną <xref:System.Windows.Data.RelativeSourceMode.FindAncestor?displayProperty=nameWithType> wartość.  
  
 Jeśli chcesz, aby Klasa pochodna ustawił tę właściwość, należy to zrobić w konstruktorze statycznym lub w innych procedurach inicjacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Frame" />
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zainicjowaniu tego <see cref="T:System.Windows.FrameworkElement" /> . To zdarzenie pokrywa się z przypadkami, gdy wartość <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> właściwości zmienia się z <see langword="false" /> (lub niezdefiniowana) na. <see langword="true" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie zostanie wywołane przy każdym <xref:System.Windows.FrameworkElement.EndInit%2A> wywołaniu <xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A> metody lub. Wywołania jednej z metod mogą pochodzić z kodu aplikacji lub przez [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] zachowanie procesora [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] podczas przetwarzania strony.  
  
 Niezależnie od tego, czy <xref:System.Windows.FrameworkElement.Loaded> wybrano obsługę lub <xref:System.Windows.FrameworkElement.Initialized> zależy od wymagań. Jeśli nie ma potrzeby odczytywania właściwości elementów, zamiar resetowania właściwości i niepotrzebne informacje o <xref:System.Windows.FrameworkElement.Initialized> układzie mogą być lepszym zdarzeniem. Jeśli chcesz, aby wszystkie właściwości elementu były dostępne, a ustawienia właściwości, które prawdopodobnie zresetują układ, <xref:System.Windows.FrameworkElement.Loaded> mogą być lepszym zdarzeniem. Należy zachować ostrożność w przypadku, gdy program obsługi zresetuje wszystkie właściwości, które są interpretowane przez system układu, aby oznaczało, że jest wymagany nowy przebieg układu. (Może być konieczne sprawdzenie <xref:System.Windows.FrameworkPropertyMetadata> wartości właściwości, jeśli nie masz pewności, które właściwości mogą wymagać nowego układu przebiegu, jeśli są zmieniane).  
  
 Aby uzyskać więcej informacji na temat sekwencji zdarzeń obiektu dla <xref:System.Windows.FrameworkElement>, a także dla kilku powiązanych klas aplikacji i elementów, zobacz [zdarzenia okresu istnienia obiektu](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kontekst używany przez <see cref="T:System.Windows.FrameworkElement" />dane wejściowe.</summary>
        <value>Zakres wejściowy, który modyfikuje sposób interpretacji danych wejściowych z alternatywnych metod wprowadzania. Wartość domyślna to <see langword="null" /> (w wyniku domyślnego sposobu obsługi poleceń).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zależności dziedziczy wartości właściwości. Jeśli istnieją elementy podrzędne bez innych wartości do <xref:System.Windows.FrameworkElement.InputScope%2A> ustanowienia za pomocą lokalnych wartości lub stylów, system właściwości ustawi wartość <xref:System.Windows.FrameworkElement.InputScope%2A> jako wartość najbliższego elementu nadrzędnego z tą wartością.  
  
 Chociaż użycie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] składni jest wymienione i jest syntaktycznie dozwolone, ustawienie tej właściwości w nie jest wspólne. [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.InputScopeProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.InputScope" />
        <altmember cref="T:System.Windows.IInputElement" />
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.InputScope" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten element został zainicjowany, podczas przetwarzania przez [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] procesor lub przez jawne <see cref="M:System.Windows.FrameworkElement.EndInit" /> wywołanie metody.</summary>
        <value><see langword="true" />Jeśli element jest zainicjowany dla powyższych [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] wywołań przetwarzania lub metod; w przeciwnym razie,. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość może być `true` również, jeśli ten element został przeniesiony w drzewie logicznym tak, że ma nowy element nadrzędny i dlatego zostanie ponownie załadowany.  
  
 Ta właściwość jest przydatna <xref:System.Windows.FrameworkElement.BeginInit%2A> , jeśli używasz również i. <xref:System.Windows.FrameworkElement.EndInit%2A> Elementy w drzewie logicznym, które są ładowane przez [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] procesor, są gwarantowane do zainicjowania. Elementy, które nie znajdują się w drzewie <xref:System.Windows.FrameworkElement.EndInit%2A> logicznym, są inicjowane, gdy jest wywoływana. W przypadku braku żadnej szczególnej obsługi <xref:System.Windows.FrameworkElement.BeginInit%2A> i <xref:System.Windows.FrameworkElement.EndInit%2A>, będzie to miało miejsce zaraz po tym, jak Konstruktor zwróci zainicjowany wynik.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten element został załadowany do prezentacji.</summary>
        <value><see langword="true" />Jeśli bieżący element jest dołączony do drzewa elementu; <see langword="false" /> Jeśli element nigdy nie został dołączony do załadowanego drzewa elementów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Od nowo skonstruowanej <xref:System.Windows.FrameworkElement>, ta właściwość `false`zaczyna się i pozostaje `true` po ustawieniu na `true`, nawet jeśli element zostanie następnie usunięty z połączonego drzewa logicznego przez kod. `true`stan jest ustawiany przez ogólną logikę prezentacji, gdy elementy są ładowane do aparatu prezentacji.  
  
 Zwykle ładowane elementy są renderowane, ale nie wszystkie <xref:System.Windows.FrameworkElement> klasy pochodne mają prezentację, a inne właściwości, takie jak <xref:System.Windows.UIElement.Visibility%2A> mogą mieć wpływ na prezentację.  
  
   
  
## Examples  
 W poniższym przykładzie zaimplementowane są dwa programy obsługi: jeden obsługuje <xref:System.Windows.FrameworkElement.Loaded> zdarzenie elementu głównego, dlatego należy się upewnić, że element główny strony jest załadowany, ponieważ jest to istotność zdarzenia. Druga procedura obsługi jest przełączana do kontrolki użytkownika i wywołuje <xref:System.Windows.FrameworkElement.IsLoaded%2A> , aby upewnić się, że element główny został załadowany całkowicie. Oba programy obsługi wywołują tę samą funkcję (niepokazywaną), która będzie wypełniać elementy podrzędne przy użyciu nowych danych.  
  
 [!code-csharp[GroupBoxExample#FEIsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupBoxExample/CSharp/Page1.xaml.cs#feisloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje o języku lokalizacji/globalizacji, które mają zastosowanie do elementu.</summary>
        <value>Informacje o języku dla tego elementu. Wartość domyślna to <see cref="T:System.Windows.Markup.XmlLanguage" /> a <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> z wartością ustawioną na ciąg "en-us".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Formaty ciągów są zgodne ze standardem RFC 3066. Na przykład w Stanach Zjednoczonych Angielski to "pl-US". Aby uzyskać więcej informacji na temat wartości i formatu, <xref:System.Windows.Markup.XmlLanguage>Zobacz.  
  
 Ta właściwość zależności dziedziczy wartości właściwości. Jeśli istnieją elementy podrzędne bez innych wartości do <xref:System.Windows.FrameworkElement.Language%2A> ustanowienia za pomocą lokalnych wartości lub stylów, system właściwości ustawi wartość <xref:System.Windows.FrameworkElement.Language%2A> jako wartość najbliższego elementu nadrzędnego z tą wartością.  
  
 [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]definiuje ogólne znaczenie `xml:lang` atrybutu. <xref:System.Windows.FrameworkElement.Language%2A>zasadniczo ujawnia znaczenie tego atrybutu jako właściwości zależności. <xref:System.Windows.FrameworkElement.Language%2A>można je dostosować programowo i może uczestniczyć w dziedziczeniu wartości systemu właściwości w taki sposób, aby był równoległy `xml:lang` , jak atrybut może dziedziczyć do zakresu [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]elementu podrzędnego w. Ustawienie <xref:System.Windows.FrameworkElement.Language%2A>tej wartości `xml:lang` spowoduje, że zastępuje wszystkie poprzednie wartości. Aby uzyskać więcej informacji, zobacz [XML: lang Obsługa języka XAML](~/docs/framework/xaml-services/xml-lang-handling-in-xaml.md).  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.LanguageProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.Language" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform LayoutTransform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform LayoutTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LayoutTransform" />
      <MemberSignature Language="VB.NET" Value="Public Property LayoutTransform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Transform ^ LayoutTransform { System::Windows::Media::Transform ^ get(); void set(System::Windows::Media::Transform ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LayoutTransform : System.Windows.Media.Transform with get, set" Usage="System.Windows.FrameworkElement.LayoutTransform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia transformację graficzną, która powinna zostać zastosowana do tego elementu podczas wykonywania układu.</summary>
        <value>Przekształć ten element powinien używać. Wartość domyślna to <see cref="P:System.Windows.Media.Transform.Identity" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie <xref:System.Windows.UIElement.RenderTransform%2A>do <xref:System.Windows.FrameworkElement.LayoutTransform%2A> , wpłynie na wyniki układu.  
  
 Ustawienie przekształcenia zapewnia zaawansowane możliwości skalowania i obracania. Jednak ignoruje <xref:System.Windows.Media.TranslateTransform>operacje. <xref:System.Windows.FrameworkElement.LayoutTransform%2A> Dzieje się tak, ponieważ zachowanie systemu układu dla elementów <xref:System.Windows.FrameworkElement> podrzędnych automatycznie koryguje wszystkie przesunięcia do pozycji skalowanego lub obróconego elementu do układu i systemu współrzędnych elementu nadrzędnego.  
  
 <xref:System.Windows.FrameworkElement.LayoutTransform%2A>może prowadzić do słabej wydajności aplikacji, jeśli jest wywoływany w scenariuszu, który nie wymaga pełnego przekazania przez system układu. Po zastosowaniu <xref:System.Windows.FrameworkElement.LayoutTransform%2A> <xref:System.Windows.Controls.Panel.Children%2A> do kolekcji <xref:System.Windows.Controls.Panel>, wyzwala nowy przebieg przez system układu i wymusza, aby wszystkie obiekty na ekranie były ponownie mierzone i zmieniane. Jeśli aktualizujesz kompletną aplikację [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)], ta funkcja może mieć dokładnie to, czego potrzebujesz. Jednakże jeśli nie jest potrzebny pełny przebieg układu, należy użyć <xref:System.Windows.UIElement.RenderTransform%2A> właściwości, która nie wywołuje systemu układu i dlatego jest zazwyczaj lepszym wyborem w tym scenariuszu.  
  
 Przykładowe scenariusze, <xref:System.Windows.FrameworkElement.LayoutTransform%2A> które byłyby przydatne, obejmują: obracanie elementów, takich jak składniki menu, od poziomego do pionowych lub odwrotnie, Skalowanie elementów (powiększanie) na ostro, zapewnianie zachowania edycji itp.  
  
<a name="dependencyPropertyInfo_LayoutTransform"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.LayoutTransformProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.FrameworkElement.LayoutTransform%2A> jak zastosować do elementu. Przykład tworzy wystąpienie <xref:System.Windows.Controls.Button> i hostuje je w obiekcie nadrzędnym <xref:System.Windows.Controls.Grid>. Używa <xref:System.Windows.FrameworkElement.LayoutTransform%2A> również właściwości, aby <xref:System.Windows.Media.RotateTransform> zastosować do <xref:System.Windows.Controls.Button>.  
  
 [!code-cpp[LayoutTransform#1](~/samples/snippets/cpp/VS_Snippets_Wpf/LayoutTransform/CPP/LayoutTransform.cpp#1)]
 [!code-csharp[LayoutTransform#1](~/samples/snippets/csharp/VS_Snippets_Wpf/LayoutTransform/CSharp/LayoutTransform.cs#1)]
 [!code-vb[LayoutTransform#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/LayoutTransform/VisualBasic/LayoutTransform.vb#1)]
 [!code-xaml[LayoutTransform#1](~/samples/snippets/xaml/VS_Snippets_Wpf/LayoutTransform/XAML/default.xaml#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=158252">Przykład transformacji 2-D</related>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransformProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LayoutTransformProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LayoutTransformProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LayoutTransformProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LayoutTransformProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LayoutTransformProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.LayoutTransform" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy element jest określony, renderowany i gotowy do interakcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Loaded>jest zazwyczaj ostatnim zdarzeniem wywoływanym w sekwencji inicjalizacji elementu. Zostanie on zawsze podniesiony po <xref:System.Windows.FrameworkElement.Initialized>. Niezależnie od tego, czy <xref:System.Windows.FrameworkElement.Loaded> wybrano obsługę lub <xref:System.Windows.FrameworkElement.Initialized> zależy od wymagań. Jeśli nie ma potrzeby odczytywania właściwości elementów, zamiar resetowania właściwości i niepotrzebne informacje o <xref:System.Windows.FrameworkElement.Initialized> układzie mogą być lepszym zdarzeniem. Jeśli chcesz, aby wszystkie właściwości elementu były dostępne, a ustawienia właściwości, które prawdopodobnie zresetują układ, <xref:System.Windows.FrameworkElement.Loaded> mogą być lepszym zdarzeniem. Należy zachować ostrożność w przypadku, gdy program obsługi zresetuje wszystkie właściwości, które są interpretowane przez system układu, aby oznaczało, że jest wymagany nowy przebieg układu. (Może być konieczne sprawdzenie <xref:System.Windows.FrameworkPropertyMetadata> wartości właściwości, jeśli nie masz pewności, które właściwości mogą wymagać nowego układu przebiegu, jeśli są zmieniane).  
  
 Aby uzyskać więcej informacji na temat sekwencji zdarzeń obiektu dla <xref:System.Windows.FrameworkElement>, a także dla kilku powiązanych klas aplikacji i elementów, zobacz [zdarzenia okresu istnienia obiektu](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
 Zdarzenia kierowane bezpośrednio nie obserwują trasy, są obsługiwane tylko w obrębie tego samego elementu, w którym zostały zgłoszone. Zdarzenia kierowane bezpośrednio obsługują inne kierowane zdarzenia dotyczące zdarzeń: obsługują kolekcję programów obsługi i mogą być używane jako <xref:System.Windows.EventTrigger> style.  
  
 <xref:System.Windows.FrameworkElement.Loaded>i <xref:System.Windows.FrameworkElement.Unloaded> mogą być wywoływane w kontrolkach w wyniku zmian motywów systemu inicjowanych przez użytkownika. Zmiana motywu powoduje unieważnienie szablonu kontrolki i zawartego w nim drzewa wizualnego, co z kolei powoduje, że cała kontrolka zostanie zwolniona i załadowana ponownie. W <xref:System.Windows.FrameworkElement.Loaded> związku z tym nie można założyć, że występuje tylko wtedy, gdy strona jest najpierw ładowana przez nawigację do strony.  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.LoadedEvent>|  
|Strategia routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje zdarzenie <see cref="E:System.Windows.FrameworkElement.Loaded" /> kierowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory zdarzeń kierowanych są tworzone po zarejestrowaniu zdarzeń kierowanych. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu i metodę narzędzia służącą do dodawania właścicieli zdarzenia. Możesz użyć tych identyfikatorów, aby dodać obsługę klas.  
  
 Więcej informacji o rejestrowaniu zdarzeń kierowanych znajduje <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>się w temacie. Aby uzyskać więcej informacji na temat używania identyfikatorów zdarzeń kierowanych do dodawania obsługi klas <xref:System.Windows.EventManager.RegisterClassHandler%2A>, zobacz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduł wyliczający dla logicznych elementów podrzędnych tego elementu.</summary>
        <value>Moduł wyliczający dla logicznych elementów podrzędnych tego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.LogicalChildren%2A>pozwala na iterację elementów podrzędnych. Jest to przydatne w przypadku elementów, które mogą nie mieć zdefiniowanej, dedykowanej kolekcji, ale nadal zawiera więcej niż jeden <xref:System.Windows.FrameworkContentElement> element podrzędny, szczególnie elementy podrzędne.  
  
 Aby uzyskać więcej informacji na temat korzystania <xref:System.Windows.FrameworkElement.LogicalChildren%2A> z <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>i, zobacz [drzewa w WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c5358e14-d24c-44c7-b5eb-6062a4fd981c">x:Array — Rozszerzenie znaczników</related>
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Margin { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.Margin : System.Windows.Thickness with get, set" Usage="System.Windows.FrameworkElement.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zewnętrzny margines elementu.</summary>
        <value>Udostępnia wartości marginesów dla elementu. Wartość domyślna to a <see cref="T:System.Windows.Thickness" /> ze wszystkimi właściwościami równymi 0 (zero).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Margines jest odstępem między tym elementem i innymi elementami, które będą przyległe po utworzeniu [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]układu. Współużytkowane elementy mogą być elementami równorzędnymi (takimi jak inne elementy w kolekcji typowej kontrolki nadrzędnej) lub mogą być również elementem nadrzędnym tego elementu.  
  
 <xref:System.Windows.FrameworkElement.Margin%2A>jest ustawiony jako <xref:System.Windows.Thickness> struktura, a nie jako liczba, aby można było ustawić margines asymetryczny. Sama struktura obsługuje konwersję typu String, aby można było także określić [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] asymetryczną <xref:System.Windows.FrameworkElement.Margin%2A> składnię atrybutu. <xref:System.Windows.Thickness>  
  
 Margines różny od zera ma miejsce poza elementami układu <xref:System.Windows.FrameworkElement.ActualWidth%2A> elementów i. <xref:System.Windows.FrameworkElement.ActualHeight%2A>  
  
 Marginesy są addytywne dla elementów równorzędnych w układzie; na przykład dwa sąsiadujące elementy z marginesem 30 ustawionym na sąsiedniej krawędzi będą miały 60 jednostki przestrzeni między nimi.  
  
 Elementy, które mają ustawione marginesy, zazwyczaj nie ograniczają rozmiaru określonego <xref:System.Windows.FrameworkElement.Margin%2A> , jeśli przydzielony obszar prostokąta nie jest wystarczająco duży dla marginesu i obszaru zawartości elementu. W przypadku obliczenia układu obszar zawartości elementu będzie ograniczony. Jedynym przypadkiem, w którym marginesy byłyby ograniczone, jest również to, że zawartość jest już ograniczona do zera.  
  
<a name="xamlAttributeUsage_Margin"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```xaml  
<object Margin="left,top,right,bottom"/>  
```

—lub—

```xaml
<object Margin="left,top"/>  
```

—lub—  

```xaml
<object Margin="thicknessReference"/>  
```

<a name="xamlPropertyElementUsage_Margin"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.Margin>  
    <Thickness Left="left" Top="top" Right="right" Bottom="bottom"/>  
  </object.Margin>  
</object>  
```  
  
<a name="xamlValues_Margin"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *do lewej, do góry, do prawej, do dołu*  
 Liczba wartości z zakresu od <xref:System.Double.PositiveInfinity> 0 do, które określają cztery możliwe właściwości <xref:System.Windows.Thickness> wymiaru struktury.  
  
 Użycie atrybutu spowoduje również zaakceptowanie skróconych wartości, które są stosowane w podanej kolejności, symetrycznie i logicznie. Na przykład, `Margin="20"` zostaną zinterpretowane tak, aby <xref:System.Windows.Thickness> oznaczała wszystkie właściwości ustawione na 20. `Margin="20,50"`zostanie zinterpretowana jako <xref:System.Windows.Thickness> wartość <xref:System.Windows.Thickness.Left%2A> i <xref:System.Windows.Thickness.Right%2A> ustawiona na 20, <xref:System.Windows.Thickness.Top%2A> a i <xref:System.Windows.Thickness.Bottom%2A> ustawiona na 50.  
  
 Jednostką <xref:System.Windows.Thickness> domyślną miary jest [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]. Można również określić inne jednostki przez dołączenie ciągów `cm`typu jednostki, `in`lub `pt` do dowolnej miary.  
  
 Wartości liczbowe podane jako [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] atrybuty nie mogą określać przecinków dziesiętnych (0 jest akceptowalny, nie musi być podane jako 0,0). Aby uzyskać więcej informacji [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] na temat użycia <xref:System.Windows.Thickness>, zobacz.  
  
 *thicknessReference*  
 Odwołanie do obiektu istniejącego <xref:System.Windows.Thickness>. Może to być `}`, a lub `}` odwołanie. Aby uzyskać więcej informacji [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] na temat użycia <xref:System.Windows.Thickness>, zobacz.  
  
<a name="dependencyPropertyInfo_Margin"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.MarginProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Thickness" />
      </Docs>
    </Member>
    <Member MemberName="MarginProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MarginProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MarginProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MarginProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MarginProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MarginProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MarginProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MarginProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.Margin" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeight">
      <MemberSignature Language="C#" Value="public double MaxHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxHeight : double with get, set" Usage="System.Windows.FrameworkElement.MaxHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ograniczenie maksymalnej wysokości elementu.</summary>
        <value>Maksymalna wysokość elementu w [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Wartość domyślna to <see cref="F:System.Double.PositiveInfinity" />. Ta wartość może być dowolną wartością równą lub większą niż 0,0. <see cref="F:System.Double.PositiveInfinity" />jest również prawidłowy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to jedna z trzech właściwości <xref:System.Windows.FrameworkElement> , które określają informacje o wysokości. Pozostałe dwa są <xref:System.Windows.FrameworkElement.MinHeight%2A> i <xref:System.Windows.FrameworkElement.Height%2A>.  Jeśli występuje konflikt między tymi wartościami, kolejność aplikacji do ustalenia rzeczywistej wysokości jest najpierw <xref:System.Windows.FrameworkElement.MinHeight%2A> uznawana za zahonor, a następnie <xref:System.Windows.FrameworkElement.MaxHeight%2A>, a wreszcie, jeśli każda z nich znajduje się w granicach <xref:System.Windows.FrameworkElement.Height%2A>,.  
  
 Ograniczenia wartości w <xref:System.Double> wartości są wymuszane <xref:System.Windows.ValidateValueCallback> przez mechanizm. Jeśli podjęto próbę ustawienia nieprawidłowej wartości, zostanie zgłoszony wyjątek czasu wykonywania.  
  
<a name="xamlAttributeUsage_MaxHeight"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```xaml  
<object MaxHeight="double"/>  
```

—lub—

```xaml
<object MaxHeight ="qualifiedDouble"/>  
```

<a name="xamlValues_MaxHeight"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *double*  
 <xref:System.Double>  
  
 Ciąg reprezentujący <xref:System.Double> wartość równą lub większą niż 0,0. Jest to interpretowane jako [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] pomiar. Ciągi nie muszą jawnie zawierać punktów dziesiętnych. Na przykład akceptowalna `1` jest wartość.  
  
 Te same <xref:System.Double> ograniczenia zakresu, jak wspomniano w sekcji wartość właściwości, mają zastosowanie, z tą różnicą, że należy użyć [rozszerzenia znaczników x:static —](~/docs/framework/xaml-services/x-static-markup-extension.md) , jeśli trzeba jawnie <xref:System.Double.PositiveInfinity>ustawić wartość.  
  
 *qualifiedDouble*  
 Wartość *Podwójna* , jak opisano powyżej, po której następuje jeden z następujących ciągów deklaracji jednostkowej `in`: `cm` `px`, `pt`,,.  
  
 `px`(wartość domyślna) to[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm`jest centymetry; 1cm = = (96/2.54) px  
  
 `pt`to punkty; 1 pkt = = (96/72) px  
  
<a name="dependencyPropertyInfo_MaxHeight"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.MaxHeightProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.MaxHeight" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidth">
      <MemberSignature Language="C#" Value="public double MaxWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWidth : double with get, set" Usage="System.Windows.FrameworkElement.MaxWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ograniczenie maksymalnej szerokości elementu.</summary>
        <value>Maksymalna Szerokość elementu w [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Wartość domyślna to <see cref="F:System.Double.PositiveInfinity" />. Ta wartość może być dowolną wartością równą lub większą niż 0,0. <see cref="F:System.Double.PositiveInfinity" />jest również prawidłowy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to jedna z trzech właściwości <xref:System.Windows.FrameworkElement> , które określają informacje o szerokości. Pozostałe dwa są <xref:System.Windows.FrameworkElement.MinWidth%2A> i <xref:System.Windows.FrameworkElement.Width%2A>. Jeśli występują konflikty między tymi wartościami, kolejność aplikacji dla określania rzeczywistej szerokości <xref:System.Windows.FrameworkElement.MinWidth%2A> musi być wykorzystana, a następnie <xref:System.Windows.FrameworkElement.MaxWidth%2A>, a wreszcie, jeśli każda z nich znajduje się w granicach, <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 Ograniczenia wartości w <xref:System.Double> wartości są wymuszane <xref:System.Windows.ValidateValueCallback> przez mechanizm. Jeśli podjęto próbę ustawienia nieprawidłowej wartości, zostanie zgłoszony wyjątek czasu wykonywania.  
  
<a name="xamlAttributeUsage_MaxWidth"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```xaml 
<object MaxWidth="double"/>  
```

—lub—

```xaml
<object MaxWidth="qualifiedDouble"/>  
```

<a name="xamlValues_MaxWidth"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *double*  
 <xref:System.Double>  
  
 Ciąg reprezentujący <xref:System.Double> wartość równą lub większą niż 0,0. Jest to interpretowane jako [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] pomiar. Ciągi nie muszą jawnie zawierać punktów dziesiętnych. Na przykład akceptowalna `1` jest wartość.  
  
 Te same <xref:System.Double> ograniczenia zakresu, jak wspomniano w sekcji wartość właściwości, mają zastosowanie, z tą różnicą, że należy użyć [rozszerzenia znacznika x:static —](~/docs/framework/xaml-services/x-static-markup-extension.md) do ustawienia wartości <xref:System.Double.PositiveInfinity>.  
  
 *qualifiedDouble*  
 Wartość *Podwójna* , jak opisano powyżej, po której następuje jeden z następujących ciągów deklaracji jednostkowej `in`: `cm` `px`, `pt`,,.  
  
 `px`(wartość domyślna) to[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm`jest centymetry; 1cm = = (96/2.54) px  
  
 `pt`to punkty; 1 pkt = = (96/72) px  
  
<a name="dependencyPropertyInfo_MaxWidth"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.MaxWidthProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.MaxWidth" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureCore">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Size MeasureCore (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureCore(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function MeasureCore (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureCore(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureCore : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.MeasureCore availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Dostępny rozmiar, który element nadrzędny może przekazać do elementów podrzędnych.</param>
        <summary>Implementuje podstawowe zachowanie systemu pomiarów dla programu <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <returns>Wymagany rozmiar tego elementu w układzie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType> implementację implementacji miary na poziomie rdzenia WPF i platformy WPF. <xref:System.Windows.FrameworkElement> Implementacja zamknięć metody. Aby dostosować zachowanie układu przebiegu miary dowolnego elementu, który kompiluje na poziomie platformy WPF, <xref:System.Windows.FrameworkElement.MeasureOverride%2A> zamiast tego. Aby dostosować zachowanie układu przebiegu miary elementu, który celowo nie kompiluje na poziomie platformy WPF lub użyć <xref:System.Windows.FrameworkElement>, override. <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="abstract member MeasureOverride : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Dostępny rozmiar, który ten element może przydzielić do elementów podrzędnych. Nieskończoność można określić jako wartość, aby wskazać, że element będzie miał rozmiar do dowolnej dostępnej zawartości.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, mierzy rozmiar w układzie wymaganym dla elementów podrzędnych i określa rozmiar <see cref="T:System.Windows.FrameworkElement" />klasy pochodnej.</summary>
        <returns>Rozmiar, jaki ten element określa potrzebę podczas układania, na podstawie jego obliczeń rozmiarów elementów podrzędnych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastąp <xref:System.Windows.FrameworkElement.MeasureOverride%2A> , aby zaimplementować niestandardowe zachowanie ustalania wielkości układu dla elementu [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] w miarę uczestniczenia w systemie układu. Implementacja powinna wykonywać następujące czynności:  
  
1.  Wykonaj iterację określonej kolekcji elementów podrzędnych, które są częścią układu, wywołaj <xref:System.Windows.UIElement.Measure%2A> dla każdego elementu podrzędnego.  
  
2.  Natychmiast Uzyskaj <xref:System.Windows.UIElement.DesiredSize%2A> w elemencie podrzędnym (jest to ustawienie jako właściwość po <xref:System.Windows.UIElement.Measure%2A> wywołaniu).  
  
3.  Oblicza żądany rozmiar sieci nadrzędnej na podstawie pomiaru elementów podrzędnych.  
  
 Zwracana wartość <xref:System.Windows.FrameworkElement.MeasureOverride%2A> powinna być własnym wymaganym rozmiarem elementu, który następnie zmienia dane wejściowe miary dla elementu nadrzędnego bieżącego elementu. Ten sam proces jest kontynuowany przez system układu do momentu osiągnięcia elementu głównego strony.  
  
 W trakcie tego procesu elementy podrzędne mogą zwrócić większy <xref:System.Windows.UIElement.DesiredSize%2A> rozmiar niż początkowy `availableSize` , aby wskazać, że element podrzędny potrzebuje większej ilości miejsca. Może to być obsługiwane we własnej implementacji przez wprowadzenie przewijanego regionu, zmieniając rozmiar kontrolki nadrzędnej, przez ustalenie kolejności stosu lub dowolnej liczby rozwiązań do mierzenia lub rozmieszczania zawartości.  
  
> [!IMPORTANT]
>  Elementy powinny być <xref:System.Windows.UIElement.Measure%2A> wywoływane dla każdego elementu podrzędnego w trakcie tego procesu; w przeciwnym razie elementy podrzędne nie będą poprawnie skalowane ani uporządkowane.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Poniższy kod niekompilowania pokazuje ten wzorzec implementacji.  <c>VisualChildren</c> reprezentuje wyliczalną Właściwość kolekcji elementów podrzędnych, które należy zdefiniować dla Twojego elementu. Właściwość może mieć nazwę wszystko. <c>VisualChildren</c> to nazwa symbolu zastępczego dla celów tego przykładu, <c>VisualChildren</c> nie [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] jest to podane [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] przez ani część wzorca nazewnictwa. 
  
[! code-CSharp[CorePseudocode # FEMeasureOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#femeasureoverride)] [! code — VB[CorePseudocode # FEMeasureOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#femeasureoverride)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="MinHeight">
      <MemberSignature Language="C#" Value="public double MinHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MinHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinHeight : double with get, set" Usage="System.Windows.FrameworkElement.MinHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ograniczenie minimalnej wysokości elementu.</summary>
        <value>Minimalna wysokość elementu w [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Wartość domyślna to 0,0. Ta wartość może być dowolną wartością równą lub większą niż 0,0. Jednak jest nieprawidłowy lub nie jest <see cref="F:System.Double.NaN" />. <see cref="F:System.Double.PositiveInfinity" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to jedna z trzech właściwości <xref:System.Windows.FrameworkElement> , które określają informacje o wysokości.  Pozostałe dwa są <xref:System.Windows.FrameworkElement.Height%2A> i <xref:System.Windows.FrameworkElement.MaxHeight%2A>. Jeśli występuje konflikt między tymi wartościami, kolejność aplikacji do ustalenia rzeczywistej wysokości jest najpierw <xref:System.Windows.FrameworkElement.MinHeight%2A> uznawana za zahonor, a następnie <xref:System.Windows.FrameworkElement.MaxHeight%2A>, a wreszcie, jeśli każda z nich znajduje się w granicach <xref:System.Windows.FrameworkElement.Height%2A>,.  
  
 Ograniczenia wartości w <xref:System.Double> wartości są wymuszane <xref:System.Windows.ValidateValueCallback> przez mechanizm. Jeśli podjęto próbę ustawienia nieprawidłowej wartości, zostanie zgłoszony wyjątek czasu wykonywania.  
  
<a name="xamlAttributeUsage_MinHeight"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```xaml
<object MinHeight="double"/>  
```

—lub—

```xaml
<object MinHeight="qualifiedDouble"/>  
```

<a name="xamlValues_MinHeight"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *double*  
 <xref:System.Double>  
  
 Ciąg reprezentujący <xref:System.Double> wartość równą lub większą niż 0,0. Jest to interpretowane jako [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] pomiar. Ciągi nie muszą jawnie zawierać punktów dziesiętnych. Na przykład akceptowalna `1` jest wartość.  
  
 Stosuje się <xref:System.Double> te same ograniczenia zakresu, jak wspomniano w sekcji wartość właściwości.  
  
 *qualifiedDouble*  
 Wartość *Podwójna* , jak opisano powyżej, po której następuje jeden z następujących ciągów deklaracji jednostkowej `in`: `cm` `px`, `pt`,,.  
  
 `px`(wartość domyślna) to[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm`jest centymetry; 1cm = = (96/2.54) px  
  
 `pt`to punkty; 1 pkt = = (96/72) px  
  
<a name="dependencyPropertyInfo_MinHeight"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.MinHeightProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.MinHeight" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidth">
      <MemberSignature Language="C#" Value="public double MinWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinWidth : double with get, set" Usage="System.Windows.FrameworkElement.MinWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ograniczenie minimalnej szerokości elementu.</summary>
        <value>Minimalna szerokość elementu w [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Wartość domyślna to 0,0. Ta wartość może być dowolną wartością równą lub większą niż 0,0. Jednak jest nieprawidłowy lub nie jest <see cref="F:System.Double.NaN" />. <see cref="F:System.Double.PositiveInfinity" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to jedna z trzech właściwości <xref:System.Windows.FrameworkElement> , które określają informacje o szerokości.  Pozostałe dwa są <xref:System.Windows.FrameworkElement.Width%2A> i <xref:System.Windows.FrameworkElement.MaxWidth%2A>.  Jeśli występują konflikty między tymi wartościami, kolejność aplikacji dla określania rzeczywistej szerokości <xref:System.Windows.FrameworkElement.MinWidth%2A> musi być wykorzystana, a następnie <xref:System.Windows.FrameworkElement.MaxWidth%2A>, a wreszcie, jeśli każda z nich znajduje się w granicach, <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 Ograniczenia wartości w <xref:System.Double> wartości są wymuszane <xref:System.Windows.ValidateValueCallback> przez mechanizm. Jeśli podjęto próbę ustawienia nieprawidłowej wartości, zostanie zgłoszony wyjątek czasu wykonywania.  
  
<a name="xamlAttributeUsage_MinWidth"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```xaml 
<object MinWidth="double"/>  
```

—lub—

```xaml
<object MinWidth="qualifiedDouble"/>  
```
  
<a name="xamlValues_MinWidth"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *double*  
 <xref:System.Double>  
  
 Ciąg reprezentujący <xref:System.Double> wartość równą lub większą niż 0,0. Jest to interpretowane jako [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] pomiar. Ciągi nie muszą jawnie zawierać punktów dziesiętnych. Na przykład akceptowalna `1` jest wartość.  
  
 Stosuje się <xref:System.Double> te same ograniczenia zakresu, jak wspomniano w sekcji wartość właściwości.  
  
 *qualifiedDouble*  
 Wartość *Podwójna* , jak opisano powyżej, po której następuje jeden z następujących ciągów deklaracji jednostkowej `in`: `cm` `px`, `pt`,,.  
  
 `px`(wartość domyślna) to[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm`jest centymetry; 1cm = = (96/2.54) px  
  
 `pt`to punkty; 1 pkt = = (96/72) px  
  
<a name="dependencyPropertyInfo_MinWidth"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.MinWidthProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.MinWidth" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">Kierunek, który fokus ma zostać przeniesiony jako wartość wyliczenia.</param>
        <summary>Przesuwa fokus klawiatury od tego elementu i do innego elementu w podanym kierunku przechodzenia.</summary>
        <returns>Zwraca <see langword="true" /> wartość, jeśli fokus jest przenoszony pomyślnie; <see langword="false" /> Jeśli element docelowy w kierunku określonym przez nie istnieje lub nie może być skoncentrowany na klawiaturze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja przesłania <xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=nameWithType> i plombuje metodę.  
  
   
  
## Examples  
 Poniższy przykład implementuje procedurę obsługi, która obsługuje kilka możliwych wejść przycisku. Każdy przycisk reprezentuje możliwe <xref:System.Windows.Input.FocusNavigationDirection>. Procedura obsługi śledzi element z bieżącym fokusem klawiatury i wywołuje <xref:System.Windows.FrameworkElement.MoveFocus%2A> dla tego elementu, określając odpowiednie <xref:System.Windows.Input.FocusNavigationDirection> jako inicjalizacje dla <xref:System.Windows.Input.TraversalRequest> podanego parametru typu.  
  
 [!code-csharp[FocusSample#FocusSampleMoveFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#focussamplemovefocus)]
 [!code-vb[FocusSample#FocusSampleMoveFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#focussamplemovefocus)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.DesignerSerializationOptions(System.Windows.Markup.DesignerSerializationOptions.SerializeAsAttribute)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Windows.Markup.DesignerSerializationOptions</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę identyfikującą elementu. Nazwa zawiera odwołanie, tak aby powiązane z kodem, takie jak kod programu obsługi zdarzeń, można odwoływać się do elementu znaczników po jego skonstruowaniu podczas przetwarzania przez [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] procesor.</summary>
        <value>Nazwa elementu. Wartość domyślna to pusty ciąg.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najbardziej typowym użyciem tej właściwości jest określenie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] nazwy elementu jako atrybutu w znaczniku.  
  
 Ta właściwość zasadniczo zapewnia wygodną właściwość na poziomie platformy WPF do ustawiania [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [dyrektywy x:Name](~/docs/framework/xaml-services/x-name-directive.md).  
  
 Nazwy muszą być unikatowe w obrębie elementu namescope. Aby uzyskać więcej informacji, zobacz [WPF XAML Zakresy nazw WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 Uzyskiwanie <xref:System.Windows.FrameworkElement.Name%2A> , jeśli tworzysz elementy w kodzie nie są wspólne. Jeśli masz już odpowiednie odwołanie w kodzie, możesz wywołać metody i właściwości w odwołaniu do elementu i nie będzie to <xref:System.Windows.FrameworkElement.Name%2A>zwykle potrzebne. Wyjątkiem jest to, czy <xref:System.Windows.FrameworkElement.Name%2A> ciąg ma pewne przeciążone znaczenie, na przykład jeśli jest przydatne do wyświetlania tej nazwy w. [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] Ustawienie na <xref:System.Windows.FrameworkElement.Name%2A> podstawie kodu w przypadku, gdy oryginał <xref:System.Windows.FrameworkElement.Name%2A> został ustawiony z znaczników nie jest również zalecane i zmiana właściwości po załadowaniu [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] nie spowoduje zmiany oryginalnego odwołania do obiektu. Odwołania do obiektów są tworzone tylko wtedy, gdy bazowe Zakresy nazw WPF są tworzone jawnie podczas analizowania. Należy wywołać <xref:System.Windows.FrameworkElement.RegisterName%2A> , aby wprowadzić skuteczną zmianę <xref:System.Windows.FrameworkElement.Name%2A> właściwości już załadowanego elementu.  
  
 W przypadku, gdy ustawienie <xref:System.Windows.FrameworkElement.Name%2A> od kodu jest ważne, rejestruje nazwy dla elementów, dla których będą uruchamiane Scenorysy, dzięki czemu mogą być przywoływane w czasie wykonywania. Przed zarejestrowaniem nazwy może również wystąpić potrzeba wystąpienia i przypisania <xref:System.Windows.NameScope> wystąpienia. Zapoznaj się z sekcją [](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)przykładu lub scenorysami.  
  
 Ustawienie <xref:System.Windows.FrameworkElement.Name%2A> z kodu ma ograniczone aplikacje, ale pobieranie elementu przez <xref:System.Windows.FrameworkElement.Name%2A> jest bardziej popularne. Jednym z określonych scenariuszy jest to, że aplikacja obsługuje model nawigacyjny, w którym strony ładują się ponownie do aplikacji, a kod czasu wykonywania nie musi być kodem zdefiniowanym dla tej strony. Metoda <xref:System.Windows.FrameworkElement.FindName%2A>narzędziowa, która jest dostępna z dowolnego <xref:System.Windows.FrameworkElement>, <xref:System.Windows.FrameworkElement.Name%2A> może znaleźć każdy element w drzewie logicznym dla tego elementu, przeszukiwanie drzewa cyklicznie w razie potrzeby. Można też użyć <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> statycznej <xref:System.Windows.LogicalTreeHelper>metody <xref:System.Windows.FrameworkElement.Name%2A> , która również przyjmuje ciąg jako argument.  
  
 Zazwyczaj używane elementy główne (<xref:System.Windows.Window> <xref:System.Windows.Controls.Page> na przykład) implementują interfejs <xref:System.Windows.Markup.INameScope>. Implementacje tego interfejsu powinny wymusić niejednoznaczność nazw w zakresie. Elementy główne, które definiują ten interfejs, również definiują granice zachowania namescope dla wszystkich [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]powiązanych.  
  
 <xref:System.Windows.FrameworkElement.Name%2A> Właściwość służy również jako identyfikator dla innych procesów. Na przykład [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] model automatyzacji będzie używany <xref:System.Windows.FrameworkElement.Name%2A> jako AutomationId dla klientów i dostawców.  
  
 Wartości ciągu używane dla <xref:System.Windows.FrameworkElement.Name%2A> mają pewne ograniczenia, nałożone przez podstawową [dyrektywę x:Name](~/docs/framework/xaml-services/x-name-directive.md) zdefiniowaną przez [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] specyfikację. W szczególności <xref:System.Windows.FrameworkElement.Name%2A> musi zaczynać się literą lub znakiem podkreślenia (_) i może zawierać tylko litery, cyfry i znaki podkreślenia. Aby uzyskać więcej informacji, zobacz [WPF XAML Zakresy nazw WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 <xref:System.Windows.FrameworkElement.Name%2A>jest jedną z bardzo mało właściwości zależności, które nie mogą być animowane `true` (<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> w metadanych), ponieważ sama sama nazwa jest istotna dla celów animacji. Powiązanie danych a <xref:System.Windows.FrameworkElement.Name%2A> jest technicznie możliwe, ale jest wyjątkowo nietypowym scenariuszem, ponieważ <xref:System.Windows.FrameworkElement.Name%2A> powiązane z danymi nie mogą służyć do głównego zamierzonego celu właściwości: w celu zapewnienia punktu połączenia identyfikatora dla kodu.  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.NameProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
   
  
## Examples  
 Poniższy przykład ustawia <xref:System.Windows.FrameworkElement.Name%2A> właściwość w kodzie, a następnie rejestruje nazwę w nowo utworzonym <xref:System.Windows.NameScope> wywołaniu <xref:System.Windows.FrameworkElement.RegisterName%2A>. Technika zilustrowana w tym miejscu jest wymagana w przypadku animacji z scenorysami, ponieważ Scenorysy wymagają elementów docelowych i <xref:System.Windows.FrameworkElement.Name%2A>nie mogą być wskazywane przez odwołanie do obiektu.  
  
 [!code-csharp[animateHeight_procedural#FEName](~/samples/snippets/csharp/VS_Snippets_Wpf/animateHeight_procedural/CSharp/AnimatedHeightExample.cs#fename)]
 [!code-vb[animateHeight_procedural#FEName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animateHeight_procedural/visualbasic/animatedheightexample.vb#fename)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.Name" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public virtual void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnApplyTemplate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnApplyTemplate();" />
      <MemberSignature Language="F#" Value="abstract member OnApplyTemplate : unit -&gt; unit&#xA;override this.OnApplyTemplate : unit -&gt; unit" Usage="frameworkElement.OnApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, jest wywoływana przy każdym wywołaniu <see cref="M:System.Windows.FrameworkElement.ApplyTemplate" />kodu aplikacji lub procesów wewnętrznych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma domyślnej implementacji.  
  
 Szablony to sekcja ukończonego drzewa wizualnego elementu, która pochodzi z właściwości <xref:System.Windows.Style> szablonu obiektu, który jest stosowany dla elementu. Aby uzyskać więcej informacji, zobacz [Style i tworzenia szablonów](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Klasy <see cref="T:System.Windows.FrameworkElement" /> pochodne mogą używać tej metody jako powiadomienia dla różnych możliwych scenariuszy: 
— Możesz wywołać własną implementację kodu, która kompiluje resztę drzewa wizualnego elementu.  
  
— Można uruchomić kod, który opiera się na drzewie wizualnym z szablonów, które zostały zastosowane, takich jak uzyskiwanie odwołań do nazwanych elementów, które pochodzą z szablonu.  
  
— Możesz wprowadzić usługi, które mają sens tylko wtedy, gdy drzewo wizualne z szablonów zostanie zakończone.  
  
— Można ustawiać Stany i właściwości elementów w ramach szablonu, które są zależne od innych czynników. Na przykład wartości właściwości mogą być wykrywalne tylko przez znajomość elementu nadrzędnego lub w przypadku, gdy określona Klasa pochodna używa wspólnego szablonu.  
  
Implementacje powinny zawsze wywoływać implementację podstawową przed ich wdrożeniem. <see cref="T:System.Windows.FrameworkElement" />sama nie ma żadnej domyślnej implementacji, ale mogą wystąpić klasy.  
  
 <see cref="T:System.Windows.Controls.Control" />oferuje podobne przesłonięcie <see cref="M:System.Windows.Controls.Control.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Zawiera dane dotyczące zdarzenia.</param>
        <summary>Wywoływana za każdym razem, gdy <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /> nieobsłużone zdarzenie osiągnie tę klasę w swojej trasie. Zaimplementuj tę metodę, aby dodać obsługę klasy dla tego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma domyślnej implementacji. Należy nadal wywoływać implementację bazową w przypadku zaimplementowania tej metody przez klasę pośrednią w dziedziczeniu.  
  
 Celem tej metody jest nieco podobna do wzorca zdarzeń [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] w odniesieniu do * metod: udostępnia metodę do obsługi pasującego zdarzenia z klas pochodnych z obsługą klasy zamiast programu obsługi wystąpienia. W takim przypadku zdarzenie dopasowywania jest zdarzeniem kierowanym. Wzorzec implementacji metod on * jest różny dla zdarzeń kierowanych, ponieważ zdarzenie kierowane mogło zostać zgłoszone przez element podrzędny, niekoniecznie jest to element, który wywoła programy obsługi, więc implementacja będzie musiała mieć wartość "Źródło" argumentów zdarzeń właściwości do konta (i nie powinny próbować ponownie podnieść zdarzenia w większości przypadków). Podklasy <xref:System.Windows.FrameworkElement> mogą wybierać wywołania metod obsługi klasy prywatnej, gdy zdarzenie jest odbierane wzdłuż trasy. Jednym z potencjalnych scenariuszy jest przejęcie argumentów zdarzenia i celowe oznaczenie zdarzenia jako obsłużonego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.RoutedEventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywoływana za każdym razem, gdy <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> nieobsłużone zdarzenie osiągnie tę klasę w swojej trasie. Zaimplementuj tę metodę, aby dodać obsługę klasy dla tego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma domyślnej implementacji. Należy nadal wywoływać implementację bazową w przypadku zaimplementowania tej metody przez klasę pośrednią w dziedziczeniu.  
  
 Celem tej metody jest nieco podobna do wzorca zdarzeń [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] w odniesieniu do * metod: udostępnia metodę do obsługi pasującego zdarzenia z klas pochodnych z obsługą klasy zamiast programu obsługi wystąpienia. W takim przypadku zdarzenie dopasowywania jest zdarzeniem kierowanym. Wzorzec implementacji metod on * jest różny dla zdarzeń kierowanych, ponieważ zdarzenie kierowane mogło zostać zgłoszone przez element podrzędny, niekoniecznie jest to element, który wywoła programy obsługi, więc implementacja będzie musiała mieć wartość "Źródło" argumentów zdarzeń właściwości do konta (i nie powinny próbować ponownie podnieść zdarzenia w większości przypadków). Podklasy <xref:System.Windows.FrameworkElement> mogą wybierać wywołania metod obsługi klasy prywatnej, gdy zdarzenie jest odbierane wzdłuż trasy. Jednym z potencjalnych scenariuszy jest przejęcie argumentów zdarzenia i celowe oznaczenie zdarzenia jako obsłużonego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.RoutedEventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywoływana za każdym razem, gdy <see cref="E:System.Windows.UIElement.GotFocus" /> nieobsłużone zdarzenie osiągnie ten element w swojej trasie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do innych metod na * metodach udostępnianych przez <xref:System.Windows.FrameworkElement.OnGotFocus%2A> elementy podstawowe, ma implementację domyślną. W tym celu ma implementację zastępującą implementację null na następnym poziomie elementu <xref:System.Windows.UIElement.OnGotFocus%2A>podstawowego. Po wywołaniu, <xref:System.Windows.FrameworkElement.OnGotFocus%2A> ustawia odpowiednie zachowanie ostrości dla tego elementu w przypadkach, gdy zdarzenie pochodzi z bieżącego elementu z powodu fokusu klawiatury. <xref:System.Windows.FrameworkElement.OnGotFocus%2A> Procedura obsługi nie oznacza argumentów zdarzeń jako obsłużonych, nawet jeśli fokus jest ustawiony na bieżący element. Jeśli źródło zdarzenia było innym elementem drzewa (nie bieżącym), program obsługi niczego nie robi.  
  
 Można zastąpić tę metodę, aby zmienić domyślne zachowanie ostrości dla elementu, ale należy pamiętać, że zmiana zachowania fokusu w ten sposób może być lepszym rozwiązaniem przez niezezwalanie, aby element był skoncentrowany w ogóle (zobacz <xref:System.Windows.UIElement.Focusable%2A>).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Jeśli zamierzasz oznaczyć zdarzenie obsługiwane w argumentach, należy zwrócić uwagę na konsekwencje dotyczące obsługi zdarzeń w innych elementach nadrzędnych w drzewie elementów. Ponieważ ta procedura obsługi działa na zdarzeniu z routingiem propagacji, ustawienie fokusu na bieżące <paramref name="sender" /> według argumentów zdarzenia może być nieodpowiednie. Może być konieczne przechodzenie do złożonego elementu podrzędnego lub do elementu nadrzędnego, w zależności od składu niektórych kontrolek. W związku z tym Oznaczanie zdarzenia fokusu jako obsługiwanego jest zalecane tylko wtedy, gdy całością drzewa wizualnego, za pomocą którego zdarzenie jest Routing, jest część składowej wprowadzonej kontrolki.</para></block>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.RoutedEventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.FrameworkElement.Initialized" /> Podnosi zdarzenie. Ta metoda jest wywoływana za <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> każdym razem, <see langword="true" /> gdy jest ustawiona wewnętrznie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta konkretna metoda nie jest punktem zaczepienia obsługi klasy. Nie jest jednak dokładnie zgodne z Konwencją ustanowioną [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] na *, aby można było pominąć to zdarzenie, zastępując tę metodę i niewywołując implementację podstawową.  
  
 Należy zauważyć, <xref:System.Windows.FrameworkElement.IsInitialized%2A> że właściwość jest tylko do odczytu, więc nie można <xref:System.Windows.FrameworkElement.IsInitialized%2A> ustawić, aby wymusić zachowanie inicjalizacji. Ustawienie stanu inicjalizacji jest przeznaczone do wykonania tylko przez [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] platformę.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Domyślna implementacja tej metody wirtualnej wywołuje zdarzenie zgodnie z powyższym opisem. Zastąpienia powinny wywołać implementację podstawową w celu zachowania tego zachowania. Jeśli nie zostanie wywołana implementacja podstawowa, nie tylko zostanie <see cref="E:System.Windows.FrameworkElement.Initialized" /> zgłoszone zdarzenie, którego zwykle oczekuje <see cref="T:System.Windows.FrameworkElement" /> Klasa pochodna, ale również zostaną pominięte dwa ważne operacje inicjowania stylu i stylu motywu, które są zaimplementowane przez tę implementację podstawową.</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.OnApplyTemplate" />
        <altmember cref="E:System.Windows.FrameworkElement.Initialized" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzenia, które opisują modyfikowaną właściwość, a także stare i nowe wartości.</param>
        <summary>Wywoływana za każdym razem, gdy wartość skuteczna każdej właściwości <see cref="T:System.Windows.FrameworkElement" /> zależności na tej stronie została zaktualizowana. Określona właściwość zależności, która została zmieniona, jest raportowana w parametrze argumenty. Zastąpień <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest przeznaczona do ogólnego wykrywania zmian właściwości lub Unieważnień. Zamiast tego jest przeznaczony do modyfikacji ogólnego wzorca unieważnienia, jeśli pewne informacje są znane o szerokiej klasyfikacji właściwości.  
  
 Ta metoda jest potencjalnie wywoływana wiele razy w okresie istnienia obiektu. W związku z tym można osiągnąć lepszą wydajność w przypadku zastąpienia metadanych określonych właściwości, a następnie dołączenia <xref:System.Windows.CoerceValueCallback> lub <xref:System.Windows.PropertyChangedCallback> funkcji dla poszczególnych właściwości. Należy jednak użyć tej metody, jeśli <xref:System.Windows.FrameworkElement> zawiera znaczną liczbę właściwości zależności z wartościami, lub jeśli zawiera logikę, taką jak zachowanie renderowania, które należy uruchomić ponownie dla kilku powiązanych przypadków Unieważnień właściwości.  
  
 Należy zauważyć, że istnieje taka sama metoda `OnPropertyChanged` o nazwie z inną sygnaturą (typ parametru to <xref:System.ComponentModel.PropertyChangedEventArgs>), która może być wyświetlana w wielu klasach. Jest używany do powiadomień obiektów danych i jest częścią kontraktu dla <xref:System.ComponentModel.INotifyPropertyChanged>. `OnPropertyChanged`  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Zawsze Wywołaj implementację podstawową, jako pierwszą operację w implementacji. Niewykonanie tej czynności spowoduje znacząco wyłączenie całego [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] systemu właściwości, co spowoduje zgłoszenie nieprawidłowych wartości. Konkretna <see cref="T:System.Windows.FrameworkElement" /> implementacja jest również odpowiedzialna za utrzymywanie właściwego stanu dla różnych właściwości, które mają wpływ na widoczny interfejs użytkownika. Obejmują one unieważnienie drzewa wizualnego w zależności od zmian stylów w odpowiednim czasie.</para></block>
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="T:System.Windows.PropertyChangedCallback" />
      </Docs>
    </Member>
    <Member MemberName="OnRenderSizeChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnRenderSizeChanged (System.Windows.SizeChangedInfo sizeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnRenderSizeChanged(class System.Windows.SizeChangedInfo sizeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnRenderSizeChanged (sizeInfo As SizeChangedInfo)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnRenderSizeChanged(System::Windows::SizeChangedInfo ^ sizeInfo);" />
      <MemberSignature Language="F#" Value="override this.OnRenderSizeChanged : System.Windows.SizeChangedInfo -&gt; unit" Usage="frameworkElement.OnRenderSizeChanged sizeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sizeInfo" Type="System.Windows.SizeChangedInfo" />
      </Parameters>
      <Docs>
        <param name="sizeInfo">Szczegóły starego i nowego rozmiaru, który obejmuje zmianę.</param>
        <summary><see cref="E:System.Windows.FrameworkElement.SizeChanged" /> Podnosi zdarzenie przy użyciu określonych informacji w ramach danych zdarzenia ostatecznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przesłania <xref:System.Windows.UIElement.OnRenderSizeChanged%2A>. W przypadku wywołania tej metody zostanie zresetowana <xref:System.Windows.FrameworkElement.ActualWidth%2A> Właściwość <xref:System.Windows.FrameworkElement.ActualHeight%2A> , właściwość lub obie wartości, w zależności od tego, co zostało określone jako zmienione w podanych argumentach i będzie zawsze powodować zdarzenie.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Nie należy przesłaniać tej metody dla typowych scenariuszy układu. System układu działa w sposób celowo asynchroniczny, aby zapewnić, że wszystkie możliwe rozmieszczenie i mierzenie przypadków są uwzględniane. Metody <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /> przesłaniania systemu układu i <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" /> są zwykle wystarczające do dowolnych wymaganych dostosowań układu. <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />jest udostępniana jako wirtualna. Można przesłonić <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /> , aby poprawić w przypadku wyjątkowych przypadków, w których zmiana zachowania w czasie wykonywania związana ze zdarzeniami wejściowymi z rekompozycją kontroli w odpowiedzi może dać niedokładne informacje o układzie.  
  
Tę metodę można nadal zastąpić w klasach pochodnych (jest ona chroniona, ale nie zapieczętowana). Zawsze Wywołaj implementację podstawową, aby zachować zachowanie wymienione powyżej, chyba że masz szczególne przyczyny wyłączenia domyślnego zachowania renderowania na poziomie platformy WPF. Niepowodzenie podniesienia <see cref="E:System.Windows.FrameworkElement.SizeChanged" /> poziomu zdarzenia spowoduje niestandardowe zachowanie układu w przypadku użycia standardowej implementacji systemu układu na poziomie platformy WPF Framework.</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">Stary styl.</param>
        <param name="newStyle">Nowy styl.</param>
        <summary>Wywoływana, gdy styl używany przez ten element zostanie zmieniony, co spowoduje unieważnienie układu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma domyślną implementację, która ustawia wewnętrzną flagę, która ma uwagi na warunek zmiany stylu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Nie należy zwykle przesłonić tej metody. Wszelkie zmiany w stylu, które obejmują miarę lub zmiany ułożenia, spowodują już wyzwolenie innego cyklu renderowania, przy założeniu <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" /> <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />, że typowa implementacja  / lub ustawienia domyślne. Przesłonięcia mogą być odpowiednie <see cref="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" /> , <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />  /  <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /> Jeśli implementacje zostały świadomie zoptymalizowane lub obsługujące częściowe aktualizacje, ale mimo to chcesz zastosować zmiany stylów bezpośrednio. (Aktualizacje częściowe będą próbować uniknąć wielu wywołań przyrostowych do <see cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" /> i <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> na elementach podrzędnych).</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Zawiera dane dotyczące zdarzenia.</param>
        <summary>Wywoływana za każdym razem, gdy <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /> nieobsłużone zdarzenie osiągnie tę klasę w swojej trasie. Zaimplementuj tę metodę, aby dodać obsługę klasy dla tego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma domyślnej implementacji. Należy nadal wywoływać implementację bazową w przypadku zaimplementowania tej metody przez klasę pośrednią w dziedziczeniu.  
  
 Celem tej metody jest nieco podobna do wzorca zdarzeń [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] w odniesieniu do * metod: udostępnia metodę do obsługi pasującego zdarzenia z klas pochodnych z obsługą klasy zamiast programu obsługi wystąpienia. W takim przypadku zdarzenie dopasowywania jest zdarzeniem kierowanym. Wzorzec implementacji metod on * jest różny dla zdarzeń kierowanych, ponieważ zdarzenie kierowane mogło zostać zgłoszone przez element podrzędny, niekoniecznie jest to element, który wywoła programy obsługi, więc implementacja będzie musiała mieć wartość "Źródło" argumentów zdarzeń właściwości do konta (i nie powinny próbować ponownie podnieść zdarzenia w większości przypadków). Podklasy <xref:System.Windows.FrameworkElement> mogą wybierać wywołania metod obsługi klasy prywatnej, gdy zdarzenie jest odbierane wzdłuż trasy. Jednym z potencjalnych scenariuszy jest przejęcie argumentów zdarzenia i celowe oznaczenie zdarzenia jako obsłużonego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Zawiera dane dotyczące zdarzenia.</param>
        <summary>Wywoływana za każdym <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /> razem, gdy zdarzenie kierowane osiągnie tę klasę w swojej trasie. Zaimplementuj tę metodę, aby dodać obsługę klasy dla tego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma domyślnej implementacji. Należy nadal wywoływać implementację bazową w przypadku zaimplementowania tej metody przez klasę pośrednią w dziedziczeniu.  
  
 Celem tej metody jest nieco podobna do wzorca zdarzeń [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] w odniesieniu do * metod: udostępnia metodę do obsługi pasującego zdarzenia z klas pochodnych z obsługą klasy zamiast programu obsługi wystąpienia. W takim przypadku zdarzenie dopasowywania jest zdarzeniem kierowanym. Wzorzec implementacji metod on * jest różny dla zdarzeń kierowanych, ponieważ zdarzenie kierowane mogło zostać zgłoszone przez element podrzędny, niekoniecznie jest to element, który wywoła programy obsługi, więc implementacja będzie musiała mieć wartość "Źródło" argumentów zdarzeń właściwości do konta (i nie powinny próbować ponownie podnieść zdarzenia w większości przypadków). Podklasy <xref:System.Windows.FrameworkElement> mogą wybierać wywołania metod obsługi klasy prywatnej, gdy zdarzenie jest odbierane wzdłuż trasy. Jednym z potencjalnych scenariuszy jest przejęcie argumentów zdarzenia i celowe oznaczenie zdarzenia jako obsłużonego w celu skrócenia trasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="frameworkElement.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Stary element nadrzędny. <see langword="null" /> Może wskazywać, że element nie miał wcześniej elementu nadrzędnego obiektu Visual.</param>
        <summary>Wywoływana, gdy obiekt nadrzędny tego elementu w drzewie wizualnym zostanie zmieniony. Zastąpień <see cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Drzewo wizualne może się różnić od drzewa logicznego, ponieważ pomija elementy, które nie renderują wizualizacji, takich jak kolekcje, i rozszerza niektóre elementy na podstawie ich motywu i składania stylów. Aby uzyskać więcej informacji, zobacz [drzewa w WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Domyślna implementacja tego zapytania metody wirtualnej dla nowego elementu nadrzędnego, wywołuje różne zdarzenia inicjujące i ustawia wewnętrzne flagi dotyczące stanu <see cref="T:System.Windows.FrameworkElement" /> inicjalizacji w zależności od potrzeb. Na koniec wywołuje kolejne implementacje podstawowe jako zadeklarowane przez <see cref="T:System.Windows.UIElement" />, co z kolei wywołuje jego bazę w. <see cref="T:System.Windows.Media.Visual" /> Zawsze Wywołaj implementację podstawową, aby zachować to zachowanie, w przeciwnym razie zachowanie drzewa elementów dla tego elementu, gdy zostanie zadeklarowany jako element podrzędny innego elementu, może nie być zgodne z oczekiwaniami.  
  
Kilka istniejących [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] klas przesłania tę metodę, na przykład: <see cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />, <see cref="M:System.Windows.Controls.ListBoxItem.OnVisualParentChanged(System.Windows.DependencyObject)" />. Najbardziej typowym scenariuszem jest wymuszenie, że nowy element nadrzędny musi być określonym typem. Może to dotyczyć zgłaszania wyjątku, jeśli nowy element nadrzędny nie zakończył się pewnym sposobem testowania typu. Wyspecjalizowana wersja tego scenariusza istnieje w implementacjach elementów list i elementów menu, które nie mają żadnego sensu poza wizualizacją nadrzędną, która jest właścicielem odpowiedniej kolekcji w celu ich przechowywania. Należy zauważyć, że te przypadki nie muszą zgłaszać wyjątków, ponieważ mogą istnieć scenariusze projektanta, które polegają na elementach nadrzędnych, które są bezproblemowo bez ich "zwykłych" elementów nadrzędnych.  
  
Ta metoda jest również zastępowana w niektórych elementach, które są zwykle elementami głównymi <see cref="T:System.Windows.Window" />, takimi jak. Innym przypadkiem jest elementy, które są widocznym elementem głównym w znaczniku, ale które automatycznie generują większą infrastrukturę w skompilowanym <see cref="T:System.Windows.Controls.Page" />drzewie logicznym (na przykład). Implementacje <see cref="T:System.Windows.Controls.Page" /> i celowo zapieczętować metodę. <see cref="T:System.Windows.Window" /></para></block>
        <altmember cref="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy ten element uwzględnia właściwości stylu ze stylów motywu.</summary>
        <value><see langword="true" />Jeśli ten element nie używa właściwości stylu motywu; wszystkie właściwości pochodzące z stylu pochodzą ze stylów aplikacji lokalnych, a właściwości stylu motywu nie są stosowane. <see langword="false" />Jeśli style aplikacji są stosowane w pierwszej kolejności, a następnie style motywu stosują się do właściwości, które nie zostały jawnie ustawione w stylach aplikacji. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najbardziej typowym użyciem tej właściwości jest pośrednie użycie w metodzie ustawiającej stylu, który dostarcza styl z motywem.  
  
> [!IMPORTANT]
>  Jeśli ustawisz <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> `true` na kontrolkę, zostanie pominięty domyślny szablon kontrolki dostarczany przez style motywu. Ten szablon formantu zwykle obejmuje prezentera zawartości i inne elementy złożone, które zapewniają podstawowe [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] funkcje i wizualizację dla kontrolki. Jeśli chcesz, aby formant nadal obsługiwał te same funkcje co domyślne style motywu, musisz podać styl alternatywny z szablonem kontrolki, który replikuje tę samą strukturę. Aby uzyskać więcej informacji, zobacz temat [Tworzenie kontroli — przegląd](~/docs/framework/wpf/controls/control-authoring-overview.md).  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.OverridesDefaultStyleProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera logiczny element nadrzędny tego elementu.</summary>
        <value>Logiczny element nadrzędny tego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Parent%2A>może być `null` w przypadku wystąpienia elementu, ale nie jest on dołączony do żadnego drzewa logicznego, które ostatecznie nawiązuje połączenie z elementem głównym poziomu strony lub obiektem aplikacji.  
  
 Należy zauważyć, że logiczny element nadrzędny elementu może ulec zmianie w zależności od funkcjonalności aplikacji i pozostawienie wartości tej właściwości nie będzie odzwierciedlała tej zmiany. Zwykle należy uzyskać wartość bezpośrednio przed jej użyciem.  
  
 Zobacz [drzewa w WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) , aby uzyskać więcej informacji na temat przechodzenia do drzewa logicznego <xref:System.Windows.FrameworkElement.Parent%2A> i scenariuszy, w których należy użyć jako techniki odnajdywania elementów nadrzędnych.  
  
 Aparat właściwości może ponownie obliczyć wszystkie wartości właściwości elementu, gdy zostanie on oddany, ponieważ niektóre właściwości dziedziczą wartości za pomocą drzewa logicznego. Obiekt <xref:System.Windows.FrameworkElement.DataContext%2A> , który ma zastosowanie do powiązań, również zmienia się w przypadku zmiany elementów nadrzędnych.  
  
 Zmiana elementu nadrzędnego jest zazwyczaj wykonywane tylko przez manipulowanie kolekcjami przy użyciu dedykowanych metod dodawania lub usuwania lub ustawiania właściwości zawartości elementów.  
  
 Najbardziej typowym scenariuszem użycia <xref:System.Windows.FrameworkElement.Parent%2A> właściwości jest uzyskanie odwołania, a następnie uzyskanie różnych <xref:System.Windows.FrameworkElement> wartości właściwości z elementu nadrzędnego. W przypadku szablonów `null`zostanie <xref:System.Windows.FrameworkElement.Parent%2A> ostatecznie zadany szablon. Aby przejść do poprzedniego punktu i przekroczyć Drzewo logiczne, w którym faktycznie zastosowano szablon, <xref:System.Windows.FrameworkElement.TemplatedParent%2A>Użyj.  
  
 Należy pamiętać, że ta właściwość nie raportuje obiektów nadrzędnych drzewa wizualnego w przypadkach, w których różnią się one od obiektów nadrzędnych drzewa logicznego. Elementy nadrzędne drzewa wizualnego nie są zwykle ważne dla ogólnych przypadków aplikacji, ale mogą być żądanymi elementami nadrzędnymi dla pewnych przypadków na poziomie wizualizacji. Zobacz <xref:System.Windows.Media.VisualTreeHelper>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje kod, który sprawdza element nadrzędny elementu, a następnie używa wartości właściwości z elementu nadrzędnego do ustawiania właściwości w elemencie podrzędnym do dopasowania. W tym przypadku są to właściwości, które wpływają na rozmiar renderowania.  
  
 [!code-csharp[GeometryDesigner#FEParentProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometryDesigner/CSharp/Window1.xaml.cs#feparentproperty)]
 [!code-vb[GeometryDesigner#FEParentProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometryDesigner/visualbasic/window1.xaml.vb#feparentproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.TemplatedParent" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="ParentLayoutInvalidated">
      <MemberSignature Language="C#" Value="protected internal virtual void ParentLayoutInvalidated (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void ParentLayoutInvalidated(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub ParentLayoutInvalidated (child As UIElement)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void ParentLayoutInvalidated(System::Windows::UIElement ^ child);" />
      <MemberSignature Language="F#" Value="abstract member ParentLayoutInvalidated : System.Windows.UIElement -&gt; unit&#xA;override this.ParentLayoutInvalidated : System.Windows.UIElement -&gt; unit" Usage="frameworkElement.ParentLayoutInvalidated child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">Element podrzędny zgłasza zmianę.</param>
        <summary>Obsługuje przyrostowe implementacje układów w wyspecjalizowanych podklasach <see cref="T:System.Windows.FrameworkElement" />. <see cref="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" />jest wywoływany, gdy element podrzędny ma unieważnioną właściwość, która jest oznaczona w metadanych, co wpływa na miarę obiektu nadrzędnego lub organizuje przebiegi podczas układania układu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ten element ma element podrzędny, w którym niektóre właściwości zostały unieważnione i właściwość została oznaczona jako <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> lub <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> w metadanych właściwości podczas rejestracji, Metoda ta jest wywoływana. Wywołanie metody powiadamia element nadrzędny, który określony element podrzędny musi być ponownie mierzony, jeśli ten element obsługuje częściową (przyrostową) aktualizację układu.  
  
 Domyślnie program <xref:System.Windows.FrameworkElement> nie obsługuje układu przyrostowego, a <xref:System.Windows.FrameworkElement> w klasie ta metoda nie ma domyślnej implementacji. Scenariusz, w którym Zastępowanie tej metody, będzie nietypowy, ponieważ wymaga modyfikacji domyślnego zachowania systemu układu.  
  
 Przykładowy scenariusz implementacji może być, jeśli klasa ma ograniczenia typu dla możliwych elementów podrzędnych, które są znacznie bardziej restrykcyjne niż system układu platformy WPF. Ze względu na charakter tych elementów niestandardowych, zmiany właściwości mogą zostać celowo odroczone podczas implementowania niestandardowego zachowania układu. Na przykład Zastępowanie metody Measure/Rozmieoć, które próbują zoptymalizować przebieg renderowania elementu podrzędnego, mogą zostać odroczone dla niektórych typów zmian, które zwykle spowodują przejście do innego układu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Kierunek, dla którego należy określić potencjalną zmianę fokusu.</param>
        <summary>Określa następny element, który będzie miał fokus względem tego elementu dla podanego kierunku przenoszenia fokusu, ale nie przesuwa fokusu.</summary>
        <returns>Następny element, który koncentruje się na tym, jeśli fokus został rzeczywiście przesunięty. Może zwracać <see langword="null" /> , jeśli fokus nie może zostać przeniesiony względem tego elementu dla danego kierunku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.MoveFocus%2A>jest pokrewną metodą, która rzeczywiście przenosi fokus.  
  
   
  
## Examples  
 W poniższym przykładzie jest implementowana procedura obsługi, która obsługuje kilka możliwych wejść na przycisk, każdy <xref:System.Windows.Input.FocusNavigationDirection>przycisk reprezentujący możliwe. Procedura obsługi śledzi element z bieżącym fokusem klawiatury i wywołuje <xref:System.Windows.FrameworkElement.PredictFocus%2A> ten element i określa odpowiednie <xref:System.Windows.Input.FocusNavigationDirection> jako inicjalizację dla <xref:System.Windows.Input.TraversalRequest> podanego parametru typu. Zamiast przechodzenie do tego elementu, <xref:System.Windows.FrameworkElement.MoveFocus%2A> jak to zrobisz, program obsługi zmienia wymiary fizyczne przewidywanego miejsca docelowego fokusu na potrzeby wizualizacji.  
  
 [!code-csharp[FocusSample#FEPredictFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#fepredictfocus)]
 [!code-vb[FocusSample#FEPredictFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#fepredictfocus)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Określono <see cref="T:System.Windows.Input.TraversalRequest" />jeden z następujących kierunków w: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />. Te wskazówki nie są prawne dla <see cref="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> programu (ale są prawne dla <see cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</exception>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa do użycia dla określonego mapowania nazwa-obiekt.</param>
        <param name="scopedElement">Obiekt mapowania.</param>
        <summary>Zapewnia metodę dostępu, która upraszcza dostęp do <see cref="T:System.Windows.NameScope" /> metody rejestracji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wygodną metodą wywoływania <xref:System.Windows.NameScope.RegisterName%2A>. Implementacja sprawdzi kolejne elementy nadrzędne do momentu znalezienia odpowiedniej <xref:System.Windows.NameScope> implementacji, która jest znaleziona przez znalezienie elementu, który implementuje. <xref:System.Windows.Markup.INameScope> Aby uzyskać więcej informacji na temat zakresy nazw WPF, zobacz [WPF XAML Zakresy nazw WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 Wywołanie <xref:System.Windows.FrameworkElement.RegisterName%2A> jest niezbędne w celu poprawnego podłączania scenorysów animacji dla aplikacji tworzonych w kodzie. Wynika to z faktu, że jedna z właściwości <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>klucza scenorysu, używa wyszukiwania nazw w czasie wykonywania, zamiast można wykonać odwołanie do elementu docelowego. Jest to prawdziwe, nawet jeśli ten element jest dostępny przez odwołanie z kodu. Aby uzyskać więcej informacji na temat tego, dlaczego należy zarejestrować nazwy dla obiektów docelowych scenorysów, zobacz [Omówienie scenorysów](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
   
  
## Examples  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/ScopeExample.cs#namescopeexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/scopeexample.vb#namescopeexample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.NameScope.RegisterName(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Element do usunięcia.</param>
        <summary>Usuwa podany obiekt z drzewa logicznego tego elementu. <see cref="T:System.Windows.FrameworkElement" />aktualizuje wskaźniki nadrzędnego drzewa logicznego, które mają być zsynchronizowane z tym usunięciem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do wdrażania kolekcji obiektów, które reprezentują logiczne elementy podrzędne elementu. Można to zrobić w metodach pobierających właściwości lub Setters, obsłudze `Changed` klas zdarzeń, konstruktorów lub w samych typach kolekcji.  
  
 Dla autorów kontroli, manipulowanie drzewem logicznym na tym poziomie nie jest zalecanym rozwiązaniem, chyba że żadna z podanych modeli zawartości klasy kontroli podstawowej nie jest odpowiednia. Rozważ podklasy na poziomie <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>i <xref:System.Windows.Controls.HeaderedItemsControl>. Klasy te udostępniają model zawartości z określonym wymuszeniem logicznych elementów potomnych za pomocą dedykowanego [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)], a także do obsługi innych funkcji zwykle pożądanych [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] w kontrolce, takiej jak style za pomocą szablonów.  
  
   
  
## Examples  
 Poniższy przykład implementuje `Child` właściwość dla niestandardowego <xref:System.Windows.FrameworkElement> , który wykonuje własną implementację warstwy wizualnej. Metoda ustawiająca właściwość jest zaprojektowana tak, że w przypadku zmiany wartości stara wartość jest usuwana z drzewa logicznego, a także do kolekcji wizualizacji specyficznej dla klasy. Wartości są buforowane, a następnie nowa wartość jest dodawana do standardowego drzewa logicznego poziomu platformy WPF i niestandardowej kolekcji wizualizacji.  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoView">
      <MemberSignature Language="C#" Value="public event System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.RequestBringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RequestBringIntoView As RequestBringIntoViewEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RequestBringIntoViewEventHandler ^ RequestBringIntoView;" />
      <MemberSignature Language="F#" Value="member this.RequestBringIntoView : System.Windows.RequestBringIntoViewEventHandler " Usage="member this.RequestBringIntoView : System.Windows.RequestBringIntoViewEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RequestBringIntoViewEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, <see cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" /> gdy jest wywoływana dla tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie wskazuje obiekt nadrzędny <xref:System.Windows.Controls.ScrollViewer> (lub klasę pochodną), że element, który <xref:System.Windows.FrameworkElement.RequestBringIntoView> wywołuje zdarzenie, powinien być widoczny w obszarze przewijania. <xref:System.Windows.Controls.ScrollViewer> Spowoduje to<xref:System.Windows.FrameworkElement.RequestBringIntoView> oznaczenie zdarzenia jako obsłużonego, przy użyciu obsługi klasy zdarzenia. W obszarze <xref:System.Windows.FrameworkElement.RequestBringIntoView> ogólne dane zdarzenia nie powinny być oznaczone jako obsługiwane przez żadną klasę, która kontroluje region przewijania lub w ramach obsługi dowolnego wystąpienia, ponieważ takie działanie mogłoby zakłócać docelowy cel elementu, który został wywołany. <xref:System.Windows.FrameworkElement.BringIntoView%2A>  
  
<a name="routedEventInfo_RequestBringIntoView"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.RequestBringIntoViewEvent>|  
|Strategia routingu|Propagacja|  
|Delegate|<xref:System.Windows.RequestBringIntoViewEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoViewEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent RequestBringIntoViewEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent RequestBringIntoViewEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly RequestBringIntoViewEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ RequestBringIntoViewEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable RequestBringIntoViewEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje zdarzenie <see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /> kierowane.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkElement.Resources" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia słownik zasobów zdefiniowany lokalnie.</summary>
        <value>Bieżący, zdefiniowany lokalnie słownik zasobów, do którego można uzyskać dostęp do każdego zasobu za pomocą klucza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Słowniki zasobów, które mogą być zdefiniowane w całości [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] lub częściowo w programie, są zwykle tworzone jako element właściwości i zazwyczaj znajdują się na elemencie głównym dla każdej pojedynczej strony lub aplikacji. Umieszczenie słownika zasobów na tym poziomie ułatwia znalezienie poszczególnych elementów podrzędnych na stronie (lub z dowolnej strony w przypadku aplikacji). W większości scenariuszy aplikacji zaleca się zdefiniowanie stylów jako elementów obiektów w słowniku zasobów lub zdefiniowanie ich jako zasobów zewnętrznych, aby cały zasób stylu mógł być niezależny (to podejście ułatwia oddzielny Projektant obowiązki z obowiązków deweloperów przez oddzielenie plików fizycznych, które należy edytować).  
  
 Należy zauważyć, że ta właściwość zwraca tylko słownik zasobów zadeklarowany bezpośrednio w tym elemencie. Jest to inny niż rzeczywisty proces wyszukiwania zasobów, gdzie element podrzędny może uzyskać dostęp do dowolnego zasobu zdefiniowanego w każdym elemencie nadrzędnym, co umożliwia cykliczne wyszukiwanie w górę.  
  
 Do zasobów można także odwoływać się za pomocą kodu z kolekcji, ale należy pamiętać, że zasoby [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] utworzone w programie nie będą dostępne <xref:System.Windows.FrameworkElement.Loaded> do momentu zgłoszenia przez element, który deklaruje słownik. W rzeczywistości zasoby są analizowane asynchronicznie, a nawet w <xref:System.Windows.FrameworkElement.Loaded> przypadku, gdy jest to gwarancja, że można odwołać się do [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] określonego zasobu. Z tego powodu zazwyczaj należy uzyskać dostęp do [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] określonych zasobów tylko w ramach kodu czasu wykonywania lub za innymi [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] technikami, takimi jak style lub odwołania do rozszerzenia zasobu dla wartości atrybutów. Gdy uzyskujesz dostęp do zasobów za pośrednictwem kodu, jest to [](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) zasadniczo równoważne z DynamicResource — [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]odwołaniem z.  
  
 Podstawowa <xref:System.Windows.ResourceDictionary> obsługa metod wymaganych do dodawania, usuwania lub wykonywania zapytań dotyczących zasobów w kolekcji przy użyciu kodu. Właściwość jest settable, aby obsługiwać scenariusz całkowitego zastąpienia kolekcji Resources elementu, aby była nową lub inną <xref:System.Windows.ResourceDictionary>. <xref:System.Windows.FrameworkElement.Resources%2A>  
  
 Zauważ, że [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] pokazana składnia nie zawiera elementu <xref:System.Windows.ResourceDictionary>dla. Jest to przykład niejawnej składni kolekcji; Tag reprezentujący element kolekcji można pominąć. Zamiast tego można określić elementy, które są dodawane jako elementy do kolekcji. Aby uzyskać więcej informacji na temat kolekcji [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]niejawnych i, zobacz [Szczegóły składni XAML](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md). Jeden przypadek, w <xref:System.Windows.ResourceDictionary> którym jest w dalszym ciągu jawnie określony jako element, jeśli wprowadzasz scalony słownik, w którym to przypadku zazwyczaj nie ma elementów podrzędnych <xref:System.Windows.ResourceDictionary>dla tego elementu. Aby uzyskać szczegółowe informacje, zobacz [scalone słowniki zasobów](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *oneOrMoreResourceElements*  
 Jeden lub więcej elementów obiektów, z których każdy definiuje zasób. Każdy element właściwości zasobu w ramach <xref:System.Windows.ResourceDictionary> każdej z nich musi mieć unikatową wartość dla [dyrektywy x:Key](~/docs/framework/xaml-services/x-key-directive.md), która służy jako unikatowy klucz, gdy wartości <xref:System.Windows.ResourceDictionary>są pobierane z.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
        <related type="Article" href="https://msdn.microsoft.com/library/1985cd45-f197-42d5-b75e-886add64b248">x:Key — atrybut</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza powiązanie do tego elementu dla określonej właściwości zależności.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">Określa właściwość docelową, w której ma zostać utworzone powiązanie.</param>
        <param name="path">Nazwa właściwości źródłowej lub ścieżka do właściwości użytej dla powiązania.</param>
        <summary>Dołącza powiązanie do tego elementu, na podstawie podanej nazwy właściwości źródłowej jako ścieżki kwalifikacji do źródła danych.</summary>
        <returns>Rejestruje warunki powiązania. Ta wartość zwracana może być przydatna do sprawdzania błędów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>Metoda jest wygodną metodą wywołania, która przekazuje bieżące wystąpienie <xref:System.Windows.DependencyObject>jako i tworzy nowy <xref:System.Windows.Data.Binding> na podstawie podanego `path` parametru. Ten podpis jest wygodniejszy, jeśli tworzysz proste domyślne powiązanie. Jeśli musisz określić dowolne właściwości powiązania z warunkami niedomyślnymi lub chcesz użyć <xref:System.Windows.Data.MultiBinding> lub <xref:System.Windows.Data.PriorityBinding> <xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> , należy użyć podpisu.  
  
   
  
## Examples  
 Poniższy przykład ustawia powiązanie przy użyciu określonej ścieżki.  
  
 [!code-csharp[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#setbindingpath)]
 [!code-vb[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#setbindingpath)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">Identyfikuje właściwość, w której ma zostać utworzone powiązanie.</param>
        <param name="binding">Reprezentuje informacje o powiązaniu danych.</param>
        <summary>Dołącza powiązanie do tego elementu na podstawie podanego obiektu powiązania.</summary>
        <returns>Rejestruje warunki powiązania. Ta wartość zwracana może być przydatna do sprawdzania błędów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wygodną metodą wywołania <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, która przekazuje bieżące wystąpienie <xref:System.Windows.DependencyObject>jako.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetFlowDirection">
      <MemberSignature Language="C#" Value="public static void SetFlowDirection (System.Windows.DependencyObject element, System.Windows.FlowDirection value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFlowDirection(class System.Windows.DependencyObject element, valuetype System.Windows.FlowDirection value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFlowDirection (element As DependencyObject, value As FlowDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFlowDirection(System::Windows::DependencyObject ^ element, System::Windows::FlowDirection value);" />
      <MemberSignature Language="F#" Value="static member SetFlowDirection : System.Windows.DependencyObject * System.Windows.FlowDirection -&gt; unit" Usage="System.Windows.FrameworkElement.SetFlowDirection (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FlowDirection" />
      </Parameters>
      <Docs>
        <param name="element">Element określający kierunek przepływu.</param>
        <param name="value">Wartość wyliczenia określająca kierunek.</param>
        <summary>Ustawia wartość <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> dołączonej właściwości dla podanego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda obsługuje składnię właściwości dołączonej <xref:System.Windows.FrameworkElement.FlowDirection%2A> dla właściwości, co pozwala <xref:System.Windows.FrameworkElement> na określenie kierunku przepływu dla danego układu w elemencie nadrzędnym. Aby ustawić wartość w bieżącym <xref:System.Windows.FrameworkElement>, użyj bezpośredniej [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] metody dostępu <xref:System.Windows.FrameworkElement.FlowDirection%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Właściwość, z którą jest powiązany zasób.</param>
        <param name="name">Nazwa zasobu.</param>
        <summary>Wyszukuje zasób o określonej nazwie i konfiguruje odwołanie do zasobu dla określonej właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Odwołanie do zasobu jest podobne do użycia [rozszerzenia znacznika DynamicResource —](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) w znaczniku. Odwołanie do zasobu tworzy wyrażenie wewnętrzne, które dostarcza wartość określonej właściwości w oparciu o odroczony czas wykonywania. Wyrażenie zostanie obliczone ponowne, gdy słownik zasobów wskazuje zmianę wartości za pomocą wewnętrznych zdarzeń, lub gdy bieżący element zostanie odtworzony jako obiekt nadrzędny (zmiana nadrzędna spowodowałaby zmianę ścieżki wyszukiwania słownika).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy procesy serializacji powinny serializować zawartość <see cref="P:System.Windows.FrameworkElement.Resources" /> właściwości.</summary>
        <returns><see langword="true" />Jeśli wartość <see langword="false" />właściwości powinna być serializowana; w przeciwnym razie,. <see cref="P:System.Windows.FrameworkElement.Resources" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spowoduje to zwrócenie `true` , o ile w lokalnym <xref:System.Windows.FrameworkElement.Resources%2A>miejscu istnieje co najmniej jeden zasób z kluczem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy procesy serializacji powinny serializować zawartość <see cref="P:System.Windows.FrameworkElement.Style" /> właściwości.</summary>
        <returns><see langword="true" />Jeśli wartość <see langword="false" />właściwości powinna być serializowana; w przeciwnym razie,. <see cref="P:System.Windows.FrameworkElement.Style" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spowoduje to zwrócenie `true` , <xref:System.Windows.Style> Jeśli zestaw jest ustawiony lokalnie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTriggers">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTriggers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTriggers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeTriggers" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTriggers () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTriggers();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTriggers : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeTriggers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy procesy serializacji powinny serializować zawartość <see cref="P:System.Windows.FrameworkElement.Triggers" /> właściwości.</summary>
        <returns><see langword="true" />Jeśli wartość <see langword="false" />właściwości powinna być serializowana; w przeciwnym razie,. <see cref="P:System.Windows.FrameworkElement.Triggers" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca `true` wartość, <xref:System.Windows.FrameworkElement.Triggers%2A> Jeśli właściwość jest ustawiona lokalnie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.SizeChangedEventHandler SizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SizeChangedEventHandler SizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SizeChanged As SizeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SizeChangedEventHandler ^ SizeChanged;" />
      <MemberSignature Language="F#" Value="member this.SizeChanged : System.Windows.SizeChangedEventHandler " Usage="member this.SizeChanged : System.Windows.SizeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, <see cref="P:System.Windows.FrameworkElement.ActualHeight" /> gdy wartość <see cref="P:System.Windows.FrameworkElement.ActualWidth" /> lub właściwości zmieniają się w tym elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia kierowane bezpośrednio nie obserwują trasy, są obsługiwane tylko w obrębie tego samego elementu, w którym zostały zgłoszone. Zdarzenia kierowane bezpośrednio obsługują inne kierowane zdarzenia dotyczące zdarzeń: obsługują kolekcję programów obsługi i mogą być używane jako <xref:System.Windows.EventTrigger> style.  
  
 System układu odczytuje właściwości w <xref:System.Windows.SizeChangedEventArgs> klasie argumentów tego zdarzenia, aby określić, czy raportowane zmiany rozmiaru powinny być uznawane za znaczące. Dzięki temu system układu lub implementacje układu związane z kontrolką pozwalają uniknąć wymuszenia zmiany układu z powodu wizualnie niezauważalnych różnic między starą i nową wartością wysokości lub szerokości. Różnice niezauważalne mogą być spowodowane zaokrąglaniem lub wynikami obliczeń dla zmiennoprzecinkowych typów danych.  
  
<a name="routedEventInfo_SizeChanged"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.SizeChangedEvent>|  
|Strategia routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.SizeChangedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Height" />
        <altmember cref="P:System.Windows.FrameworkElement.Width" />
      </Docs>
    </Member>
    <Member MemberName="SizeChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent SizeChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent SizeChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ SizeChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable SizeChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje zdarzenie <see cref="E:System.Windows.FrameworkElement.SizeChanged" /> kierowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory zdarzeń kierowanych są tworzone po zarejestrowaniu zdarzeń kierowanych. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu i metodę narzędzia służącą do dodawania właścicieli zdarzenia. Możesz użyć tych identyfikatorów, aby dodać obsługę klas.  
  
 Więcej informacji o rejestrowaniu zdarzeń kierowanych znajduje <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>się w temacie. Aby uzyskać więcej informacji na temat używania identyfikatorów zdarzeń kierowanych do dodawania obsługi klas <xref:System.Windows.EventManager.RegisterClassHandler%2A>, zobacz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość źródłowa zostanie zmieniona dla dowolnego istniejącego powiązania właściwości w tym elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie tworzy alias dla <xref:System.Windows.Data.Binding.SourceUpdated> zdarzenia, które jest wywoływane przez dowolne <xref:System.Windows.Data.Binding> skojarzone z tym elementem.  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object SourceUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.SourceUpdated" />
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia styl używany przez ten element, gdy jest renderowany.</summary>
        <value>Stosowany, niedomyślny styl elementu, jeśli jest obecny. W przeciwnym razie. <see langword="null" /> Wartość domyślna dla konstruowanej <see cref="T:System.Windows.FrameworkElement" /> domyślnie to. <see langword="null" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku kontrolek bieżący styl jest często dostarczany przez domyślny styl z kontroli nad nimi lub od stylów zwykle stosowanych do kontrolek tego typu według zasobów na poziomie strony lub aplikacji (styl niejawny). Ta właściwość nie ustawia ani nie zwraca domyślnych stylów (motywu), ale zwraca styl niejawny lub jawny styl, który działa na elemencie. W przypadku niejawnych lub jawnych stylów nie ma znaczenia, czy styl jest określony jako zasób lub zdefiniowany lokalnie.  
  
 Ustawienie stylów ma pewne ograniczenia. W dowolnym momencie możesz zresetować <xref:System.Windows.FrameworkElement.Style%2A> całą Właściwość <xref:System.Windows.Style> , co spowoduje wymuszenie przetworzenia układu. Jednakże, gdy tylko ten styl jest umieszczany przez załadowany element, <xref:System.Windows.Style> powinien być uważany za zapieczętowany. Podjęto próbę dokonania zmiany we właściwościach w stylu w użyciu (takich jak wszystkie elementy w kolekcji <xref:System.Windows.Style.Setters%2A>), co powoduje zgłoszenie wyjątku. Styl zdefiniowany w znacznikach jest traktowany jako używany zaraz po załadowaniu go ze słownika zasobów (dla zasobów) lub strony, w której jest zawarty w programie, jest ładowany (dla stylów wbudowanych).  
  
 <xref:System.Windows.FrameworkElement.Style%2A>jest właściwością zależności z specjalnym pierwszeństwem. Lokalnie ustawiony styl zazwyczaj działa przy najwyższym priorytecie w systemie właściwości. Jeśli w tym momencie mawartośćnull,podczasładowaniasystemuwłaściwościsprawdzaniejawnestylewzasobachlokalnychlubaplikacji,któreokreślajątentyp.<xref:System.Windows.FrameworkElement.Style%2A> Jeśli styl nadal ma wartość null po wykonaniu tego kroku, to w celu przedstawienia tego stylu dla celów prezentacji zwykle pochodzi z domyślnego stylu (motywu), ale domyślny styl nie jest <xref:System.Windows.FrameworkElement.Style%2A> zwracany w wartości właściwości. Zapoznaj się z pierwszeństwem lub stylem [wartości właściwości zależności](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md) [oraz tworzenia szablonów](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object Style="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_Style"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *resourceExtension*  
 Jeden z następujących elementów:, lub. Zobacz [zasoby XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Klucz, który identyfikuje żądany styl. Klucz odnosi się do istniejącego zasobu w <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Składnia elementu właściwości jest technicznie możliwa, ale nie jest zalecana w przypadku większości scenariuszy stylów. Zobacz [wbudowane style i szablony](~/docs/framework/wpf/advanced/inline-styles-and-templates.md). Odwołanie do powiązania przy użyciu [szablonu TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md) lub <xref:System.Windows.Data.Binding> jest również możliwe, ale nietypowe.  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.StyleProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano styl w słowniku zasobów.  
  
 [!code-xaml[FEResource#StyleProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty)]  
[!code-xaml[FEResource#StyleProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty2)]  
[!code-xaml[FEResource#StyleProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty3)]  
[!code-xaml[FEResource#StyleProperty4](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.Style" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nazwa żądanej właściwości otoczenia.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> metodę.</summary>
        <returns><see langword="true" />Jeśli <paramref name="propertyName" /> jest dostępna; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.FrameworkElement> gdy wystąpienie jest rzutowane <xref:System.Windows.Markup.IQueryAmbient> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia dowolną wartość obiektu, która może być używana do przechowywania informacji niestandardowych o tym elemencie.</summary>
        <value>Zamierzona wartość. Ta właściwość nie ma wartości domyślnej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest analogiczna do właściwości tagów w innych modelach programowania firmy Microsoft, takich jak Visual Basic for Applications lub Windows Forms. <xref:System.Windows.FrameworkElement.Tag%2A>ma na celu zapewnienie istniejącej lokalizacji właściwości, w której można przechowywać podstawowe informacje niestandardowe o dowolnym <xref:System.Windows.FrameworkElement> , bez konieczności podklasy elementu.  
  
 Ponieważ ta właściwość przyjmuje obiekt, należy użyć opcji użycie elementu właściwości w celu ustawienia <xref:System.Windows.FrameworkElement.Tag%2A> właściwości w języku XAML na coś innego niż obiekt z znanym i wbudowanym konwerterem typów, takim jak ciąg. Obiekty używane w ten sposób zwykle nie znajdują się w standardowych przestrzeniach nazw WPF i w związku z tym mogą wymagać mapowania przestrzeni nazw do zewnętrznej przestrzeni nazw, aby można było je wprowadzić jako elementy XAML. Aby uzyskać szczegółowe informacje, zobacz [przestrzenie nazw XAML i mapowanie przestrzeni nazw dla WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md) i [XAML oraz klas niestandardowych dla WPF](~/docs/framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md).  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.TagProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.Tag" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość docelowa zostanie zmieniona dla dowolnego powiązania właściwości w tym elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie tworzy alias dla <xref:System.Windows.Data.Binding.TargetUpdated> zdarzenia, które jest wywoływane przez dowolne <xref:System.Windows.Data.Binding> skojarzone z tym elementem. Zazwyczaj oznacza to, że powiązanie w powiązaniu jest powiązaniem dwukierunkowym i że właściwość zależności powiązanej potwierdza, że Poprzednia wartość właściwości jest teraz nieprawidłowa zgodnie z dowolnym schematem walidacji lub buforowaniem, który jest obsługiwany przez właściwość lub źródło danych.  
  
 Użyj danych <xref:System.Windows.FrameworkElement.TargetUpdated> zdarzenia zdarzenia, aby określić konkretną właściwość, która zgłasza aktualizację wartości docelowej.  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object TargetUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.TargetUpdated" />
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do elementu nadrzędnego szablonu tego elementu. Ta właściwość nie jest istotna, jeśli element nie został utworzony za pomocą szablonu.</summary>
        <value><see cref="T:System.Windows.FrameworkTemplate" /> Element<see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> , który spowodował utworzenie tego elementu. Ta wartość jest często <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.TemplatedParent%2A>jest często `null` w przypadku obiektów tworzonych w znacznikach lub kodzie aplikacji. Jest to spowodowane tym, że te obiekty są tworzone bezpośrednio, a nie za pośrednictwem szablonu. Odwołania do obiektów uzyskane przez przeprowadzenie przechodzenia drzewa logicznego z katalogu głównego lub według typowych odwołań do nazw nie pochodzą z szablonu.  
  
 Przypadki, <xref:System.Windows.FrameworkElement.TemplatedParent%2A> w których mogą `null` nie być uwzględniane operacje, takie jak testowanie trafień, obsługa zdarzeń dla pewnych zdarzeń wejściowych niskiego poziomu, przechodzenie <xref:System.Windows.Media.VisualTreeHelper>drzewa wizualnego z lub praca z modułami wyliczającymi, które mogą zwracać elementy, które zostały dostarczone z szablonów. Innym przypadkiem jest to, że <xref:System.Windows.FrameworkTemplate.FindName%2A> w przypadku wywołania <xref:System.Windows.FrameworkTemplate> istniejącej i są one wykonywane z zwróconym obiektem.  
  
 Szablony są faktycznie udostępnionymi obiektami, gdzie zawartość szablonu jest tworzona tylko raz. W związku z tym, Jeśli uzyskujesz odwołanie do obiektu, który pochodzi z szablonu, może się okazać, że jawne Drzewo logiczne nie dociera do głównego elementu strony. Aby można było połączyć takie odwołanie szablonu z drzewem logicznym strony, należy uzyskać <xref:System.Windows.FrameworkElement.TemplatedParent%2A> wartość i kontynuować nawigowanie w drzewie elementów zgodnie z potrzebami.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.ToolTip)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt etykietki narzędzia, który jest wyświetlany dla tego elementu w [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</summary>
        <value>Obiekt ToolTip.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość tej właściwości jest typu <xref:System.Windows.Controls.ToolTip>, ta wartość jest etykietki narzędzia, która będzie używana [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]w.  Jeśli wartość jest dowolnego innego typu, ta wartość będzie używana jako *zawartość* dla <xref:System.Windows.Controls.ToolTip> dostarczonego (konstruowanego) przez system. Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Controls.ToolTipService>. Klasa usługi zawiera dołączone właściwości, których można użyć do dalszej dostosowywania <xref:System.Windows.Controls.ToolTip>.  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```xaml 
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>
```

—lub—

```xaml
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *toolTipContent*  
 Ciąg, który zmienia się w tekście <xref:System.Windows.FrameworkElement.ToolTip%2A>wyświetlanym.  
  
 *toolTipObjectContent*  
 Niektóre obiekty, podane w formularzu elementu obiektu, które powinny być używane jako zawartość <xref:System.Windows.FrameworkElement> . Zwykle jest <xref:System.Windows.FrameworkElement> to lub inny element, który tworzy składanie układu <xref:System.Windows.FrameworkElement.ToolTip%2A>dla, ostatecznie zawierający zawartość tekstową w ramach składania. <xref:System.Windows.Controls.ToolTip> W tym użyciu element jest tworzony niejawnie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]z przeanalizowanej, a zawartość *toolTipObjectContent* jest ustawiana jako jej <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> właściwość.  
  
 <`ToolTip` .../>  
 Zobacz <xref:System.Windows.Controls.ToolTip>.  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ToolTipProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Windows.Controls.ToolTip> kod w kodzie, a następnie <xref:System.Windows.FrameworkElement.ToolTip%2A> ustawia właściwość <xref:System.Windows.Controls.Primitives.StatusBar> w kontrolce.  
  
 [!code-csharp[StatusBar#MakeProgressBar](~/samples/snippets/csharp/VS_Snippets_Wpf/StatusBar/CSharp/Window1.xaml.cs#makeprogressbar)]
 [!code-vb[StatusBar#MakeProgressBar](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StatusBar/visualbasic/window1.xaml.vb#makeprogressbar)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje tuż przed zamknięciem dowolnej etykietki narzędzia w elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oznaczanie <xref:System.Windows.FrameworkElement.ToolTipClosing> zdarzenia jako obsługiwanego nie powoduje anulowania zamknięcia etykietki narzędzia. Gdy etykietka narzędzia zostanie wyświetlona, zamknięcie etykietki narzędzia jest wykonywane tylko w odpowiedzi na interakcję z INTERFEJSem użytkownika.  
  
 To zdarzenie nie może być <xref:System.Windows.EventTrigger> w stylu. Jest to spowodowane tym, że pole Identyfikator tego zdarzenia ponownie używa implementacji z usługi, która nie uwidacznia metod dodawania/usuwania zdarzeń na poziomie usługi.  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ToolTipClosingEvent>|  
|Strategia routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   Przesłoń <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> , aby zaimplementować obsługę klasy dla tego zdarzenia w klasach pochodnych.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje zdarzenie <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /> kierowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory zdarzeń kierowanych są tworzone po zarejestrowaniu zdarzeń kierowanych. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu i metodę narzędzia służącą do dodawania właścicieli zdarzenia. Możesz użyć tych identyfikatorów, aby dodać obsługę klas.  
  
 Więcej informacji o rejestrowaniu zdarzeń kierowanych znajduje <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>się w temacie. Aby uzyskać więcej informacji na temat używania identyfikatorów zdarzeń kierowanych do dodawania obsługi klas <xref:System.Windows.EventManager.RegisterClassHandler%2A>, zobacz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po otwarciu dowolnej etykietki narzędzia w elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zapobiec wyświetlaniu etykietki narzędzia w interfejsie użytkownika, program <xref:System.Windows.FrameworkElement.ToolTipOpening> obsługi może <xref:System.Windows.Controls.ToolTipEventArgs> oznaczyć dane zdarzenia jako obsługiwane. W przeciwnym razie etykietka narzędzia zostanie wyświetlona przy użyciu <xref:System.Windows.FrameworkElement.ToolTip%2A> wartości właściwości jako zawartości etykietki narzędzia. Innym możliwym scenariuszem jest to, że można napisać procedurę obsługi, która resetuje <xref:System.Windows.FrameworkElement.ToolTip%2A> wartość właściwości dla elementu, który jest źródłem zdarzenia, tuż przed wyświetleniem etykietki narzędzia.  
  
 <xref:System.Windows.FrameworkElement.ToolTipOpening>nie zostanie zgłoszony, jeśli wartość <xref:System.Windows.FrameworkElement.ToolTip%2A> jest lub w inny sposób nie jest `null` ustawiony. Nie ustawiaj <xref:System.Windows.FrameworkElement.ToolTip%2A> celowo na `null` , gdy etykietka narzędzia jest otwarta lub otwiera; nie spowoduje to zamknięcia etykietki narzędzia i zamiast tego utworzy niepożądany artefakt wizualny w interfejsie użytkownika.  
  
 Zdarzenie nie może <xref:System.Windows.EventTrigger> być w stylu. <xref:System.Windows.FrameworkElement.ToolTipOpening> Jest to spowodowane tym, że pole Identyfikator tego zdarzenia ponownie używa implementacji z usługi, która nie uwidacznia metod dodawania/usuwania zdarzeń na poziomie usługi.  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.ToolTipOpeningEvent>|  
|Strategia routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   Przesłoń <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> , aby zaimplementować obsługę klasy dla tego zdarzenia w klasach pochodnych.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje zdarzenie <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /> kierowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory zdarzeń kierowanych są tworzone po zarejestrowaniu zdarzeń kierowanych. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu i metodę narzędzia służącą do dodawania właścicieli zdarzenia. Możesz użyć tych identyfikatorów, aby dodać obsługę klas.  
  
 Więcej informacji o rejestrowaniu zdarzeń kierowanych znajduje <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>się w temacie. Aby uzyskać więcej informacji na temat używania identyfikatorów zdarzeń kierowanych do dodawania obsługi klas <xref:System.Windows.EventManager.RegisterClassHandler%2A>, zobacz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.ToolTip" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Triggers">
      <MemberSignature Language="C#" Value="public System.Windows.TriggerCollection Triggers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TriggerCollection Triggers" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Triggers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Triggers As TriggerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TriggerCollection ^ Triggers { System::Windows::TriggerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Triggers : System.Windows.TriggerCollection" Usage="System.Windows.FrameworkElement.Triggers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.TriggerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję wyzwalaczy ustanowionych bezpośrednio w tym elemencie lub w elementach podrzędnych.</summary>
        <value>Kolekcja <see cref="T:System.Windows.Trigger" /> obiektów o jednoznacznie określonym typie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Tę właściwość można ustawić [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] tylko za pośrednictwem podanej składni kolekcji lub przez uzyskanie dostępu do obiektu kolekcja i użycie jego różnych metod, takich jak Add. Właściwość uzyskiwania dostępu do obiektu kolekcji jest tylko do odczytu, a sama kolekcja to Read-Write. Właściwość istnieje tylko w elementach głównych. próba znalezienia lub ustawienia go w innym miejscu spowoduje zgłoszenie wyjątku.  
  
 Ta właściwość nie pozwala na badanie wyzwalaczy, które istnieją jako część stylów używanych dla tego elementu. Tylko raportuje kolekcja wyzwalaczy, które są dosłownie dodawane do kolekcji, w znacznikach lub kodzie. Elementy zazwyczaj nie mają takich elementów, które są domyślnie istniejące (za pomocą szablonu dla wystąpienia); jest to bardziej powszechne w przypadku wyzwalaczy, które pochodzą z składania, które mają zostać utworzone w stylach.  
  
 W warunkach zachowania (i próba ustalenia, który efekt pochodzi z kolekcji zadeklarowanej <xref:System.Windows.FrameworkElement.Triggers%2A> elementu), zarówno warunek wyzwalania, jak i efekt wyzwalacza mogą znajdować się w tym elemencie lub mogą znajdować się w jego elementach podrzędnych drzewa logicznego. Należy pamiętać, że jeśli używasz zdarzeń okresu istnienia, takich jak <xref:System.Windows.FrameworkElement.Loaded> Aby uzyskać tę kolekcję, wyzwalacze elementu podrzędnego mogą jeszcze nie być w pełni załadowane, a kolekcja będzie mniejsza niż w czasie wykonywania.  
  
 Należy zauważyć, że kolekcja wyzwalaczy ustanowionych w elemencie obsługuje <xref:System.Windows.EventTrigger>tylko, a nie wyzwalaczy właściwości (<xref:System.Windows.Trigger>). Jeśli wymagane są wyzwalacze właściwości, należy umieścić je w obrębie stylu lub szablonu, a następnie przypisać ten styl lub szablon do elementu bezpośrednio przez <xref:System.Windows.FrameworkElement.Style%2A> właściwość lub pośrednio za pomocą jawnego odwołania do stylu.  
  
<a name="xamlPropertyElementUsage_Triggers"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.Triggers>  
    oneOrMoreTriggers  
  </object.Triggers>  
</object>  
```  
  
<a name="xamlValues_Triggers"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *oneOrMoreTriggers*  
 Co najmniej jeden element <xref:System.Windows.EventTrigger> zdefiniowany. Każdy taki wyzwalacz powinien zawierać prawidłowe akcje i odwołania scenorysu. Należy zauważyć, że ta kolekcja może zostać ustanowiona tylko w elemencie głównym strony. Aby uzyskać więcej informacji, zobacz [Omówienie scenorysów](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.EventTrigger" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Identyfikator klucza zasobu, który ma zostać znaleziony.</param>
        <summary>Wyszukuje zasób z określonym kluczem i zwraca ten zasób, jeśli został znaleziony.</summary>
        <returns>Znaleziono zasób lub <see langword="null" /> Jeśli nie zostanie znaleziony żaden zasób z podanym <paramref name="key" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zasób nie zostanie znaleziony w elemencie wywołującym, drzewo zasobów nadrzędnych zostanie przeszukane w górę drzewa logicznego w taki sam sposób, w jaki drzewo będzie przeszukiwane, jeśli zasób zażądał klucza w czasie wykonywania. Metoda zwraca `null` tylko wtedy, gdy żaden zasób tego klucza nie istniał w dowolnym miejscu w drzewie zasobów, na istniejące warunki drzewa w czasie, który <xref:System.Windows.FrameworkElement.TryFindResource%2A> jest wywoływany.  
  
 Zazwyczaj można natychmiast rzutować wartość zwracaną na typ właściwości, którą próbowano ustawić przy użyciu zwróconej wartości zasobu.  
  
 <xref:System.Windows.FrameworkElement.FindResource%2A> Metoda ma podobne zachowanie, z tą różnicą, że zgłasza wyjątek, jeśli nie został zwrócony żaden zasób z podanym kluczem.  
  
   
  
## Examples  
 Poniższy przykład jest zaimplementowany jako procedura obsługi przycisku, gdzie kliknięty przycisk ustawia jego tło na pędzel zdefiniowany przez metodę, który jest wywoływany przez <xref:System.Windows.FrameworkElement.TryFindResource%2A> wywołanie. Spowoduje to przeprowadzenie drzewa elementów i znalezienie zasobu (sam zasób jest zdefiniowany w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] i nie jest wyświetlany).  
  
 [!code-csharp[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#fetryfindresource)]
 [!code-vb[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#fetryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy element zostanie usunięty z drzewa elementów załadowanych elementów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia kierowane bezpośrednio nie obserwują trasy, są obsługiwane tylko w obrębie tego samego elementu, w którym zostały zgłoszone. Zdarzenia kierowane bezpośrednio obsługują inne kierowane zdarzenia dotyczące zdarzeń: obsługują kolekcję programów obsługi i mogą być używane jako <xref:System.Windows.EventTrigger> style.  
  
 <xref:System.Windows.FrameworkElement.Loaded>i <xref:System.Windows.FrameworkElement.Unloaded> mogą być wywoływane w kontrolkach w wyniku zmian motywów systemu inicjowanych przez użytkownika. Zmiana motywu powoduje unieważnienie szablonu kontrolki i zawartego w nim drzewa wizualnego, co z kolei powoduje, że cała kontrolka zostanie zwolniona i załadowana ponownie. W <xref:System.Windows.FrameworkElement.Unloaded> związku z tym nie można założyć, że występuje tylko po nawigacji poza stroną.  
  
 Należy zauważyć, <xref:System.Windows.FrameworkElement.Unloaded> że zdarzenie nie zostało zgłoszone po rozpoczęciu zamykania aplikacji. Wyłączenie aplikacji następuje, gdy występuje warunek zdefiniowany przez <xref:System.Windows.Application.ShutdownMode%2A> właściwość. Jeśli umieścisz kod czyszczący w ramach procedury obsługi <xref:System.Windows.FrameworkElement.Unloaded> zdarzenia, na przykład <xref:System.Windows.Window> dla lub a <xref:System.Windows.Controls.UserControl>, może to nie być wywoływana zgodnie z oczekiwaniami.  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.UnloadedEvent>|  
|Strategia routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje zdarzenie <see cref="E:System.Windows.FrameworkElement.Unloaded" /> kierowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory zdarzeń kierowanych są tworzone po zarejestrowaniu zdarzeń kierowanych. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu i metodę narzędzia służącą do dodawania właścicieli zdarzenia. Możesz użyć tych identyfikatorów, aby dodać obsługę klas.  
  
 Więcej informacji o rejestrowaniu zdarzeń kierowanych znajduje <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>się w temacie. Aby uzyskać więcej informacji na temat używania identyfikatorów zdarzeń kierowanych do dodawania obsługi klas <xref:System.Windows.EventManager.RegisterClassHandler%2A>, zobacz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa pary nazwa-obiekt do usunięcia z bieżącego zakresu.</param>
        <summary>Upraszcza dostęp do <see cref="T:System.Windows.NameScope" /> metody Wycofaj rejestrację.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Musisz wyrejestrować nazwy tylko wtedy, gdy zamierzasz ponownie zarejestrować inny element o tej samej nazwie.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stosuje domyślny styl do bieżącego <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRounding">
      <MemberSignature Language="C#" Value="public bool UseLayoutRounding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseLayoutRounding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberSignature Language="VB.NET" Value="Public Property UseLayoutRounding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseLayoutRounding { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseLayoutRounding : bool with get, set" Usage="System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy zaokrąglanie układu ma być stosowane do rozmiaru i pozycji tego elementu w trakcie układu.</summary>
        <value><see langword="true" />Jeśli zastosowano zaokrąglenie układu; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy właściwość elementu jest równa `true`, wszystkie wartości niebędące w pikselach, <xref:System.Windows.UIElement.Measure%2A> które są obliczane podczas <xref:System.Windows.UIElement.Arrange%2A> i są zaokrąglane do pełnych wartości pikseli. <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A>  
  
 Ta właściwość jest dziedziczona przez elementy podrzędne.  
  
> [!NOTE]
>  Należy ustawić `true` na <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> wartość dla elementu głównego. System układu dodaje współrzędne podrzędne do współrzędnych nadrzędnych; w związku z tym, jeśli współrzędne nadrzędne nie znajdują się na granicy pikseli, współrzędnych elementów podrzędnych również nie ma na granicy pikseli. Jeśli <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> nie można ustawić w katalogu głównym, ustaw <xref:System.Windows.UIElement.SnapsToDevicePixels%2A> w elemencie podrzędnym, aby uzyskać odpowiedni efekt.  
  
 Rysowanie obiektów na granicach pikseli eliminuje przezroczyste krawędzie, które są tworzone przez wygładzanie, gdy brzeg znajduje się w środku piksela urządzenia. Na poniższej ilustracji przedstawiono dane wyjściowe pojedynczego wiersza o szerokości pikseli, który znajduje się w środku piksela urządzenia. Wiersz po lewej stronie nie używa zaokrąglania układu i ma wygładzanie. Wiersz po prawej stronie używa zaokrąglania układu.  
  
 Wygładzone ![linie w porównaniu z linią pojedynczego piksela.&#45;] Wygładzone (~/add/media/pixelsnaplinecompare.PNG "linie w porównaniu z linią pojedynczego piksela.")  
  
 W przypadku korzystania z zaokrąglania i <xref:System.Windows.GridUnitType.Star> ustalania układu system układu tworzy małe wariacje w pomiarach kolumn lub wierszy, aby uniknąć renderowania w pikselach. Jeśli na przykład siatka ma całkowitą szerokość 100 z 3 kolumnami o rozmiarze <xref:System.Windows.GridUnitType.Star>, zamiast tworzenia trzech kolumn o równej szerokości 33,3, system układu tworzy 2 kolumny o szerokości 33 i jeden, który ma szerokość 34.  
  
> [!NOTE]
>  W programie .NET 4,6 wprowadzono zmiany w zaokrąglaniu układu, aby zmniejszyć liczbę wystąpień wycinków w kontrolkach z obramowaniem. Domyślnie ta funkcja jest włączona, jeśli platforma docelowa ma wartość .NET Framework 4,6 lub wyższą. Aplikacje przeznaczone dla wcześniejszych wersji platformy mogą zadecydować o nowym zachowaniu, dodając następujące ustawienie do pliku App. config: `<runtime><AppContextSwitchOverrides value="Switch.MS.Internal.DoNotApplyLayoutRoundingToMarginsAndBorderThickness=false"/></runtime>`Ustawienie zacznie obowiązywać tylko wtedy, gdy aplikacja działa w .NET Framework 4,6.  
  
   
  
## Examples  
 Poniższy przykład demonstruje efekt, że <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> właściwość ma pojedynczy piksel o szerokości. Wiersz po lewej stronie nie używa zaokrąglania układu, a wiersz po prawej stronie używa zaokrąglania układu. W przypadku spowolnienia zmiany rozmiaru okna można zobaczyć różnicę, która wprowadza zaokrąglenie układu.  
  
```xaml  
  
<Page x:Class="LayoutRounding.Lines"  
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"  
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"  
    Title="Lines" Name="linesPage"  
    >  
  <StackPanel Width="150"  Margin="7" Orientation="Horizontal">  
    <!-- Single pixel line with layout rounding turned OFF.-->  
    <Rectangle UseLayoutRounding="False"  
       Width="45.5" Margin="10" Height="1" Fill="Red"/>  
    <!-- Single pixel line with layout rounding turned ON.-->  
    <Rectangle UseLayoutRounding="True"  
      Width="45.5" Margin="10" Height="1" Fill="Red"/>  
  </StackPanel>  
  <!-- Background Grid -->  
  <Page.Background>  
    <DrawingBrush  Viewport="0,0,10,10" ViewportUnits="Absolute" TileMode="Tile">  
      <DrawingBrush.Drawing>  
        <DrawingGroup>  
          <GeometryDrawing Brush="White">  
            <GeometryDrawing.Geometry>  
              <RectangleGeometry Rect="0,0,1,1" />  
            </GeometryDrawing.Geometry>  
          </GeometryDrawing>  
          <GeometryDrawing Geometry="M0,0 L1,0 1,0.1, 0,0.1Z " Brush="#CCCCFF" />  
          <GeometryDrawing Geometry="M0,0 L0,1 0.1,1, 0.1,0Z" Brush="#CCCCFF" />  
        </DrawingGroup>  
      </DrawingBrush.Drawing>  
    </DrawingBrush>  
  </Page.Background>  
</Page>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRoundingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty UseLayoutRoundingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty UseLayoutRoundingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UseLayoutRoundingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ UseLayoutRoundingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable UseLayoutRoundingProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.UseLayoutRounding" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.VerticalAlignment VerticalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.VerticalAlignment VerticalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property VerticalAlignment As VerticalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::VerticalAlignment VerticalAlignment { System::Windows::VerticalAlignment get(); void set(System::Windows::VerticalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.VerticalAlignment : System.Windows.VerticalAlignment with get, set" Usage="System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.VerticalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia charakterystyki wyrównania w pionie stosowane do tego elementu, gdy jest on tworzony w elemencie nadrzędnym, takim jak panel lub kontrolka elementów.</summary>
        <value>Ustawienie wyrównania w pionie. Wartość domyślna to <see cref="F:System.Windows.VerticalAlignment.Stretch" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.FrameworkElement.Height%2A> <xref:System.Windows.VerticalAlignment.Stretch>i <xref:System.Windows.FrameworkElement.Width%2A> właściwości są jawnie ustawiane dla elementu, te pomiary przyjmują poprzednią pozycję układu i anulują regularne skutki ustawienia tej właściwości na.  
  
 <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>to metoda dostępu do właściwościdlawłaściwościzależność.[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] Ta właściwość zależności często ma swoją pozornie ustawioną wartość "default" jako inaczej w klasach elementów pochodnych, szczególnie w kontrolkach. Zwykle jest to wykonywane na jeden z dwóch sposobów: właściwość zależności jest ponownie rejestrowana w określonej klasie pochodnej, ale z innymi metadanymi do ustawiania ich wartości domyślnych; lub jest stosowany styl domyślny, który ustawia wartość właściwości zależności inaczej. Na przykład pozorna wartość "default" <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> <xref:System.Windows.Controls.ComboBoxItem> dla kontrolki <xref:System.Windows.Controls.ComboBoxItem> będzie równa <xref:System.Windows.VerticalAlignment.Center>, nawet jeśli dziedziczy <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> bezpośrednio z <xref:System.Windows.FrameworkElement>. Dzieje się tak <xref:System.Windows.Controls.ComboBoxItem>, ponieważ ta wartość została zresetowana w stylu domyślnym w szablonie kontrolki style.  
  
 <xref:System.Windows.Controls.Canvas>nie jest używany <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> podczas redagowania układu, ponieważ <xref:System.Windows.Controls.Canvas> jest oparty na rozłożeniu bezwzględnym.  
  
 W przypadku dziedziczenia przez <xref:System.Windows.Controls.ComboBoxItem> lub dowolnych klas pochodnych, program <xref:System.Windows.Controls.ComboBoxItem> ponownie <xref:System.Windows.VerticalAlignment.Center>definiuje domyślną wartość tej właściwości.  
  
<a name="dependencyPropertyInfo_VerticalAlignment"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.VerticalAlignmentProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VerticalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VerticalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VerticalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VerticalAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VerticalAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.VerticalAlignment" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualChildrenCount : int" Usage="System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów podrzędnych wizualizacji w tym elemencie.</summary>
        <value>Liczba elementów podrzędnych wizualnych dla tego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> Implementacjazawszezwraca<xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> wartość zero lub jeden. Klasy, które utrzymują kolekcję Visual potomne, która może przekroczyć jeden, muszą przesłaniać tę właściwość i <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  
  
 Ta właściwość jest zazwyczaj używana do określania górnych granic bieżącej kolekcji podrzędnej do celów implementacji zastąpień układu (<xref:System.Windows.FrameworkElement.MeasureOverride%2A>, <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, w jaki sposób niestandardowy moduł definiowania układu używa wartości zadeklarowanych przez <xref:System.Windows.Media.VisualCollection> , które utrzymuje dla wielu elementów podrzędnych wizualizacji i raportuje te wartości za pomocą <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> przesłonięć i <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Jeśli klasa obsługuje więcej niż jeden element podrzędny wizualizacji w kolekcji elementów podrzędnych, Przesłoń tę właściwość, aby zwrócić liczbę elementów w tej kolekcji. Należy to zrobić nawet wtedy, gdy sam obiekt kolekcji zwraca liczbę. Logika układu elementu na poziomie platformy WPF Framework zakłada, że wszystkie elementy zwróci prawidłową liczbę za pomocą ich <see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /> właściwości.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public double Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Width" />
      <MemberSignature Language="VB.NET" Value="Public Property Width As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Width { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Width : double with get, set" Usage="System.Windows.FrameworkElement.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia szerokość elementu.</summary>
        <value>Szerokość elementu w [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Wartość domyślna to <see cref="F:System.Double.NaN" />. Ta wartość musi być równa lub większa niż 0,0. Zobacz uwagi dotyczące górnej granicy informacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to jedna z trzech właściwości <xref:System.Windows.FrameworkElement> , które określają informacje o szerokości.  Pozostałe dwa są <xref:System.Windows.FrameworkElement.MinWidth%2A> i <xref:System.Windows.FrameworkElement.MaxWidth%2A>.  Jeśli występują konflikty między tymi wartościami, kolejność aplikacji dla określania rzeczywistej szerokości <xref:System.Windows.FrameworkElement.MinWidth%2A> musi być wykorzystana, a następnie <xref:System.Windows.FrameworkElement.MaxWidth%2A>, a wreszcie, jeśli każda z nich znajduje się w granicach, <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 Wartość zwracana przez tę właściwość jest zawsze taka sama jak dowolna ustawiona wartość. W przeciwieństwie do wartości <xref:System.Windows.FrameworkElement.ActualWidth%2A> może się różnić. Układ mógł odrzucić sugerowany rozmiar z jakiegoś powodu. Ponadto sam system układu działa asynchronicznie względem zestawu <xref:System.Windows.FrameworkElement.Width%2A> systemowego właściwości i może nie przetworzyć tej właściwości, która nie została jeszcze przetworzona.  
  
 Oprócz akceptowalnych <xref:System.Double> wartości ta właściwość może być <xref:System.Double.NaN?displayProperty=nameWithType>również. Jest to sposób określania zachowania autozmiany wielkości. W [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] ustawieniu wartość na ciąg "Automatyczne" (bez uwzględniania wielkości liter), aby włączyć zachowanie funkcji autodopasowywania. Zachowanie autozmiany wielkości oznacza, że element będzie wypełniał dostępną szerokość. Należy jednak pamiętać, że poszczególne kontrolki często dostarczają wartości domyślne w stylach domyślnych, które wyłączają zachowanie autozmiany rozmiarów, chyba że zostanie to jeszcze włączone.  
  
 Oprócz sprawdzania poprawności istnieje niedeterministyczna Górna wartość związana <xref:System.Windows.FrameworkElement.Width%2A> z tym, że jest wymuszana przez system układu (jest to bardzo duża liczba, większa niż <xref:System.Single.MaxValue?displayProperty=nameWithType> lub mniejsza niż <xref:System.Double.MaxValue?displayProperty=nameWithType>). W przypadku przekroczenia tego powiązania element nie zostanie renderowany i nie zostanie zgłoszony żaden wyjątek. Nie ustawiaj <xref:System.Windows.FrameworkElement.Width%2A> wartości, która jest znacznie większa niż maksymalny rozmiar wyświetlanej wizualizacji lub można przekroczyć tę niedeterministyczną górną granicę.  
  
<a name="xamlAttributeUsage_Width"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```xaml 
<object Width="double"/>  
```

—lub—

```xaml
<object Width ="qualifiedDouble"/>  
```

—lub—

```xaml
<object Width ="Auto"/>  
```  

<a name="xamlValues_Width"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *double*  
 <xref:System.Double>  
  
 Ciąg reprezentujący <xref:System.Double> wartość równą lub większą niż 0,0. Zobacz uwagi dotyczące górnej granicy informacji. Ta wartość jest interpretowana jako [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] pomiar. Ciągi nie muszą jawnie zawierać punktów dziesiętnych. Na przykład akceptowalna `1` jest wartość.  
  
 *qualifiedDouble*  
 Wartość *Podwójna* , jak opisano powyżej, po której następuje jeden z następujących ciągów deklaracji jednostkowej `in`: `cm` `px`, `pt`,,.  
  
 `px`(wartość domyślna) to[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm`jest centymetry; 1cm = = (96/2.54) px  
  
 `pt`to punkty; 1 pkt = = (96/72) px  
  
 `Auto`  
 Włącza zachowanie autozmiany rozmiarów. Zobacz uwagi.  
  
<a name="dependencyPropertyInfo_Width"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.FrameworkElement.WidthProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.WidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.WidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.FrameworkElement.Width" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="FreezableCollection&lt;T&gt;" FullName="System.Windows.FreezableCollection&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2e048a4b30d5bdeda6c34018bbb5231b91a0d8ec" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69444598" /></Metadata><TypeSignature Language="C#" Value="public class FreezableCollection&lt;T&gt; : System.Windows.Media.Animation.Animatable, System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.IList, System.Collections.Specialized.INotifyCollectionChanged, System.ComponentModel.INotifyPropertyChanged where T : DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FreezableCollection`1&lt;(class System.Windows.DependencyObject) T&gt; extends System.Windows.Media.Animation.Animatable implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.Specialized.INotifyCollectionChanged, class System.ComponentModel.INotifyPropertyChanged" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FreezableCollection`1" />
  <TypeSignature Language="VB.NET" Value="Public Class FreezableCollection(Of T)&#xA;Inherits Animatable&#xA;Implements ICollection(Of T), IEnumerable(Of T), IList, IList(Of T), INotifyCollectionChanged, INotifyPropertyChanged" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA; where T : DependencyObjectpublic ref class FreezableCollection : System::Windows::Media::Animation::Animatable, System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IList&lt;T&gt;, System::Collections::IList, System::Collections::Specialized::INotifyCollectionChanged, System::ComponentModel::INotifyPropertyChanged" />
  <TypeSignature Language="F#" Value="type FreezableCollection&lt;'T (requires 'T :&gt; DependencyObject)&gt; = class&#xA;    inherit Animatable&#xA;    interface IList&#xA;    interface ICollection&#xA;    interface IEnumerable&#xA;    interface IList&lt;'T (requires 'T :&gt; DependencyObject)&gt;&#xA;    interface ICollection&lt;'T (requires 'T :&gt; DependencyObject)&gt;&#xA;    interface seq&lt;'T (requires 'T :&gt; DependencyObject)&gt;&#xA;    interface INotifyCollectionChanged&#xA;    interface INotifyPropertyChanged" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T">
      <Constraints>
        <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Windows.Media.Animation.Animatable</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Specialized.INotifyCollectionChanged</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.INotifyPropertyChanged</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="T">Typ kolekcji. Ten typ musi być <see cref="T:System.Windows.DependencyObject" /> klasą lub klasy pochodnej.</typeparam>
    <summary>Reprezentuje kolekcję <see cref="T:System.Windows.DependencyObject" />obiektów, <see cref="T:System.Windows.Freezable" />lub <see cref="T:System.Windows.Media.Animation.Animatable" /> . <see cref="T:System.Windows.FreezableCollection`1" />jest własnym <see cref="T:System.Windows.Media.Animation.Animatable" /> typem.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa jest dostarczana, aby umożliwić tworzenie niestandardowych typów kolekcji, które w pełni obsługują powiązanie danych, powiadomienia o zmianach, unieważnienie właściwości i animację jego zawartości.  
  
### <a name="xaml-usage-for-freezablecollection"></a>Użycie XAML dla FreezableCollection  
 <xref:System.Windows.FreezableCollection%601>obsługuje ograniczoną [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] składnię.  
  
-   Jako element obiektu w katalogu głównym, można teoretycznie określić nieograniczonego <xref:System.Windows.FreezableCollection%601> elementu obiektu, który musi również określać [dyrektywę x:TypeArguments —](~/docs/framework/xaml-services/x-typearguments-directive.md) , aby zadeklarować ograniczenie. Nie jest to jednak typowy scenariusz, dlatego <xref:System.Windows.FreezableCollection%601> musi być elementem głównym elementu. To ograniczenie istnieje, [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] ponieważ implementacja procesora w programie [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] może obsługiwać tylko [dyrektywę x:TypeArguments —](~/docs/framework/xaml-services/x-typearguments-directive.md) , gdy element, w którym jest ustawiana, jest elementem głównym, a użytkownik musi użyć dowolnego typu Open ograniczenia ogólnego, jeśli chcesz Tworzenie wystąpienia typu ogólnego w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Jest mało prawdopodobne, że element ma <xref:System.Windows.FreezableCollection%601> być elementem głównym, nawet jako luźny [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
-   Jeśli użytkownik dziedziczy z <xref:System.Windows.FreezableCollection%601> i zastosuje ograniczenie typu w kolekcji pochodnej, kolekcja pochodna może obsługiwać różne użycia. Jest to możliwe, ponieważ ograniczenie w wyprowadzenia wyprowadzania eliminuje konieczność przekazania.  
  
    -   Typowym [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] użyciem tej kolekcji pochodnej jest niejawna składnia kolekcji. Kolekcje obsługujące określone interfejsy nie muszą określać samej kolekcji jako elementu obiektu. Aby uzyskać szczegółowe informacje na temat [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]składni kolekcji w, zobacz [Szczegóły składni języka XAML](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md). Na przykład *obiekt* z właściwością, ** w której *Właściwość* jest typu <xref:System.Windows.FreezableCollection%601> ograniczonego przez <xref:System.Windows.DependencyObject> może obsługiwać następującą składnię:  
  
        ```  
        <object>  
          <object.property>  
            oneOrMoreDependencyObjectElements  
          </object.property>  
        </object>  
        ```  
  
    -   Dopóki nie ukryjesz konstruktora bez parametrów, kolekcja pochodna może również obsługiwać składnię elementu obiektu (gdzie element obiektu jest jawny, w przeciwieństwie do niejawnego użycia pokazanego powyżej). Nie musi to być element główny. Lub można również użyć kolekcji pochodnej jako elementu głównego, bez konieczności określania, Chociaż użycie kolekcji jako elementu głównego jest nietypowe.  
  
-   Wszystkie elementy podrzędne kolekcji w każdym z powyższych scenariuszy muszą być typu ograniczenia implementowanego lub określone przez.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.FreezableCollection`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FreezableCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FreezableCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.FreezableCollection`1" /> , które jest puste i ma domyślną pojemność początkową.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FreezableCollection (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FreezableCollection(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Windows.FreezableCollection&lt;'T (requires 'T :&gt; System.Windows.DependencyObject)&gt; : seq&lt;'T (requires 'T :&gt; System.Windows.DependencyObject)&gt; -&gt; System.Windows.FreezableCollection&lt;'T (requires 'T :&gt; System.Windows.DependencyObject)&gt;" Usage="new System.Windows.FreezableCollection&lt;'T (requires 'T :&gt; System.Windows.DependencyObject)&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Kolekcja, której elementy należy dodać do nowego <see cref="T:System.Windows.FreezableCollection`1" />.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.FreezableCollection`1" /> klasy, która zawiera te same elementy co określona kolekcja.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja wykonuje kopię skróconą w określonej kolekcji; tylko odwołania do elementów kolekcji są kopiowane, same elementy nie są klonowane. Modyfikowanie elementu nowego <xref:System.Windows.FreezableCollection%601> powoduje także modyfikację tego `collection`elementu.  
  
 Elementy są umieszczane w nowym <xref:System.Windows.FreezableCollection%601> w takiej samej kolejności, w jakiej są odczytywane przez moduł wyliczający określonej kolekcji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="collection" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FreezableCollection (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FreezableCollection(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Windows.FreezableCollection&lt;'T (requires 'T :&gt; System.Windows.DependencyObject)&gt; : int -&gt; System.Windows.FreezableCollection&lt;'T (requires 'T :&gt; System.Windows.DependencyObject)&gt;" Usage="new System.Windows.FreezableCollection&lt;'T (requires 'T :&gt; System.Windows.DependencyObject)&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Wartość, która jest większa lub równa 0, która określa liczbę elementów, które mogą być początkowo przechowywane w nowej kolekcji.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.FreezableCollection`1" /> , które jest puste i ma określoną pojemność początkową.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />jest mniejsza niż 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(T value);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; unit&#xA;override this.Add : 'T -&gt; unit" Usage="freezableCollection.Add value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt, który ma zostać dodany na końcu <see cref="T:System.Windows.FreezableCollection`1" />. Ta wartość nie może <see langword="null" />być.</param>
        <summary>Dodaje określony obiekt na końcu <see cref="T:System.Windows.FreezableCollection`1" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Jest zamrożony ( <see cref="P:System.Windows.Freezable.IsFrozen" /> jej właściwość <see langword="true" />to). <see cref="T:System.Windows.FreezableCollection`1" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="freezableCollection.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie elementy z kolekcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.FreezableCollection&lt;T&gt; Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.FreezableCollection`1&lt;!T&gt; Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As FreezableCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::FreezableCollection&lt;T&gt; ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.Windows.FreezableCollection&lt;'T (requires 'T :&gt; System.Windows.DependencyObject)&gt;" Usage="freezableCollection.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FreezableCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy modyfikowalny klon tej <see cref="T:System.Windows.FreezableCollection`1" /> i jej zawartości, tworząc kopie głębokie. Jeśli ta kolekcja (lub jej zawartość) ma animowane właściwości zależności, wartość podstawowa właściwości jest kopiowana, a nie jej bieżąca wartość animowana.</summary>
        <returns>Modyfikowalna kopia tej kolekcji i jej zawartość. <see cref="P:System.Windows.Freezable.IsFrozen" /> Wartość kopii jest <see langword="false" />równa.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przesłania metodę dziedziczonej <xref:System.Windows.Media.Animation.Animatable.Clone%2A?displayProperty=nameWithType> silnie wpisaną implementacją dla wygody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected override void CloneCore (System.Windows.Freezable source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCore(class System.Windows.Freezable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCore (source As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCore(System::Windows::Freezable ^ source);" />
      <MemberSignature Language="F#" Value="override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezableCollection.CloneCore source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="source"><see cref="T:System.Windows.FreezableCollection`1" /> Do kopiowania.</param>
        <summary>Sprawia, że to wystąpienie jest klonem (głębokiej kopii <see cref="T:System.Windows.FreezableCollection`1" /> ) dla określonych wartości właściwości Base (Nieanimowane).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez <xref:System.Windows.FreezableCollection%601.Clone%2A> metodę i nie powinna być wywoływana bezpośrednio z kodu, chyba że podczas wywoływania implementacji podstawowej podczas zastępowania tej metody. Aby utworzyć modyfikowalną kopię bieżącego obiektu, wywołaj <xref:System.Windows.FreezableCollection%601.Clone%2A> zamiast wywołania tej metody bezpośrednio.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Zobacz stronę <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> , aby uzyskać informacje o tym, kiedy należy zastąpić tę metodę.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.FreezableCollection&lt;T&gt; CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.FreezableCollection`1&lt;!T&gt; CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As FreezableCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::FreezableCollection&lt;T&gt; ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="override this.CloneCurrentValue : unit -&gt; System.Windows.FreezableCollection&lt;'T (requires 'T :&gt; System.Windows.DependencyObject)&gt;" Usage="freezableCollection.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FreezableCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy modyfikowalną kopię tej <see cref="T:System.Windows.FreezableCollection`1" /> zawartości i jej zawartość, tworząc głębokie kopie bieżących wartości tego obiektu. Jeśli ten obiekt (lub zawarte w nim obiekty) zawiera animowane właściwości zależności, zostaną skopiowane ich bieżące wartości.</summary>
        <returns>Modyfikowalny klon kolekcji i jej zawartości. <see cref="P:System.Windows.Freezable.IsFrozen" /> Właściwość sklonowanego obiektu <see langword="false" /> będzie <see cref="P:System.Windows.Freezable.IsFrozen" /> nawet wtedy, gdy właściwość źródła była<see langword="true." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przesłania metodę dziedziczonej <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=nameWithType> silnie wpisaną implementacją dla wygody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Animatable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected override void CloneCurrentValueCore (System.Windows.Freezable source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCurrentValueCore(class System.Windows.Freezable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCurrentValueCore (source As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCurrentValueCore(System::Windows::Freezable ^ source);" />
      <MemberSignature Language="F#" Value="override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezableCollection.CloneCurrentValueCore source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="source"><see cref="T:System.Windows.FreezableCollection`1" /> Do klonowania.</param>
        <summary>Sprawia, że to wystąpienie jest modyfikowalnym klonem (głębokiej <see cref="T:System.Windows.FreezableCollection`1" /> kopii) określonej przy użyciu bieżących wartości właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez <xref:System.Windows.FreezableCollection%601.CloneCurrentValue%2A> metodę i nie powinna być wywoływana bezpośrednio z kodu, chyba że podczas wywoływania implementacji podstawowej podczas zastępowania tej metody. Aby utworzyć modyfikowalną kopię bieżącego obiektu, wywołaj <xref:System.Windows.FreezableCollection%601.CloneCurrentValue%2A> zamiast wywołania tej metody bezpośrednio.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Zobacz stronę <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> , aby uzyskać informacje o tym, kiedy należy zastąpić tę metodę.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T value);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool&#xA;override this.Contains : 'T -&gt; bool" Usage="freezableCollection.Contains value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt, który ma zostać zlokalizowany w tej kolekcji. Ten obiekt może być <see langword="null" />.</param>
        <summary>Określa, czy <see cref="T:System.Windows.FreezableCollection`1" /> zawiera określoną wartość.</summary>
        <returns><see langword="true" />Jeśli wartość zostanie znaleziona w <see cref="T:System.Windows.FreezableCollection`1" />; w <see langword="false" />przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'T[] * int -&gt; unit&#xA;override this.CopyTo : 'T[] * int -&gt; unit" Usage="freezableCollection.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa tablica, która jest miejscem docelowym elementów skopiowanych z <see cref="T:System.Windows.FreezableCollection`1" />.</param>
        <param name="index">Indeks (liczony od zera) <paramref name="array" /> , w którym rozpoczyna się kopiowanie.</param>
        <summary>Kopiuje cały <see cref="T:System.Windows.FreezableCollection`1" /> do zgodnej jednowymiarowej tablicy, rozpoczynając od określonego indeksu tablicy docelowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy zauważyć, że ta operacja wykonuje kopię skróconą. Elementy są kopiowane do tablicy docelowej w tej samej kolejności, w której moduł wyliczający wykonuje iterację <xref:System.Windows.FreezableCollection%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż 0.</exception>
        <exception cref="T:System.ArgumentException">Liczba elementów w źródle <see cref="T:System.Windows.FreezableCollection`1" /> jest większa niż dostępne miejsce od indeksu do końca miejsca docelowego. <paramref name="array" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FreezableCollection`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Windows.FreezableCollection&lt;'T (requires 'T :&gt; System.Windows.DependencyObject)&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów zawartych w tym <see cref="T:System.Windows.FreezableCollection`1" />elemencie.</summary>
        <value>Liczba elementów zawartych w tym <see cref="T:System.Windows.FreezableCollection`1" />elemencie.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezableCollection.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nowe wystąpienie <see cref="T:System.Windows.FreezableCollection`1" />.</summary>
        <returns>Nowe wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie wywołuj tej metody bezpośrednio (z wyjątkiem sytuacji, w której jest wywoływana baza w implementacji). Ta metoda jest wywoływana wewnętrznie przez <xref:System.Windows.Freezable.CreateInstance%2A>, za każdym razem, gdy tworzone <xref:System.Windows.Freezable> jest nowe wystąpienie.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono typową implementację <xref:System.Windows.Freezable.CreateInstanceCore%2A>programu.  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Każda <see cref="T:System.Windows.Freezable" /> podklasa musi implementować tę metodę. Typową implementacją jest po prostu wywołanie konstruktora bez parametrów klasy i zwrócenie wyniku.</para></block>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected override bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="override this.FreezeCore : bool -&gt; bool" Usage="freezableCollection.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking"><see langword="true" />Jeśli należy <see cref="T:System.Windows.FreezableCollection`1" /> po prostu zwrócić, czy można go zablokować. <see langword="false" />Jeśli wystąpienie <see cref="T:System.Windows.FreezableCollection`1" /> powinno być rzeczywiście zawieszać się, gdy ta metoda jest wywoływana.</param>
        <summary>Sprawia, <see cref="T:System.Windows.FreezableCollection`1" /> że ten obiekt jest niemodyfikowalny lub określa, czy można go nie modyfikować.</summary>
        <returns>Jeśli <paramref name="isChecking" /> <see langword="true" /> jest <see langword="true" />, Tametoda<see langword="false" /> zwraca wartość, jeśli niemożnajejmodyfikowaćlubniemożnajejzmodyfikować.<see cref="T:System.Windows.FreezableCollection`1" />  
  
Jeśli <paramref name="isChecking" /> <see langword="true" /> jest <see langword="false" />, ta metoda zwraca wartość, jeśli określony <see cref="T:System.Windows.FreezableCollection`1" /> element jest teraz niemodyfikowalny, <see langword="false" /> lub jeśli nie można dokonać jego edycji, z efektem ubocznym rozpoczętego zmiany stanu zamrożonego tego obiektu .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie wywołuj tej metody bezpośrednio (z wyjątkiem sytuacji, w której jest wywoływana baza w implementacji). Ta metoda jest wywoływana wewnętrznie przez <xref:System.Windows.Freezable.CanFreeze%2A> (z `isChecking` równą `true`) i <xref:System.Windows.Freezable.Freeze%2A> (z `isChecking` równą `false`).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Informacje o tym, kiedy przesłonić tę metodę <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />, można znaleźć w temacie.</para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetAsFrozenCore (System.Windows.Freezable source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetAsFrozenCore(class System.Windows.Freezable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetAsFrozenCore (source As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetAsFrozenCore(System::Windows::Freezable ^ source);" />
      <MemberSignature Language="F#" Value="override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezableCollection.GetAsFrozenCore source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="source"><see cref="T:System.Windows.FreezableCollection`1" /> Do kopiowania.</param>
        <summary>Sprawia, że to wystąpienie jest zablokowanym klonem określonego <see cref="T:System.Windows.FreezableCollection`1" /> przy użyciu wartości właściwości Base (Nieanimowane).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez <xref:System.Windows.Freezable.GetAsFrozen%2A> polecenie i nie powinna być wywoływana bezpośrednio z kodu, chyba że podczas wywoływania implementacji podstawowej podczas zastępowania tej metody. Aby utworzyć zamrożoną kopię bieżącego obiektu, wywołaj <xref:System.Windows.Freezable.GetAsFrozen%2A> zamiast wywołania tej metody bezpośrednio.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Informacje o tym, kiedy przesłonić tę metodę <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />, można znaleźć w temacie.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetCurrentValueAsFrozenCore (source As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ source);" />
      <MemberSignature Language="F#" Value="override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezableCollection.GetCurrentValueAsFrozenCore source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="source"><see cref="T:System.Windows.FreezableCollection`1" /> Do kopiowania.</param>
        <summary>Sprawia, że to wystąpienie jest zablokowanym klonem określonego <see cref="T:System.Windows.Freezable" />. Jeśli ten obiekt ma animowane właściwości zależności, są kopiowane bieżące wartości animacyjne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> polecenie i nie powinna być wywoływana bezpośrednio z kodu, chyba że podczas wywoływania implementacji podstawowej podczas zastępowania tej metody. Aby utworzyć zamrożoną kopię bieżącego obiektu, wywołaj <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> zamiast wywołania tej metody bezpośrednio.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Informacje o tym, kiedy przesłonić tę metodę <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />, można znaleźć w temacie.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Windows.FreezableCollection&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.FreezableCollection`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As FreezableCollection(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::FreezableCollection&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Windows.FreezableCollection&lt;'T (requires 'T :&gt; System.Windows.DependencyObject)&gt;.Enumerator" Usage="freezableCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FreezableCollection&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający dla całego <see cref="T:System.Windows.FreezableCollection`1" />elementu.</summary>
        <returns>Moduł wyliczający dla całego <see cref="T:System.Windows.FreezableCollection`1" />elementu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.IndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(T value);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : 'T -&gt; int&#xA;override this.IndexOf : 'T -&gt; int" Usage="freezableCollection.IndexOf value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt, który ma zostać zlokalizowany w <see cref="T:System.Windows.FreezableCollection`1" />.</param>
        <summary>Wyszukuje określony obiekt i zwraca indeks (liczony od zera) pierwszego wystąpienia w całości <see cref="T:System.Windows.FreezableCollection`1" />.</summary>
        <returns>Indeks (liczony od zera) pierwszego wystąpienia <paramref name="value" /> w całości <see cref="T:System.Windows.FreezableCollection`1" />, jeśli został znaleziony; w przeciwnym razie-1.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, !T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.Insert(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (index As Integer, value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, T value);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * 'T -&gt; unit&#xA;override this.Insert : int * 'T -&gt; unit" Usage="freezableCollection.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">Indeks (liczony od zera), <paramref name="value" /> który powinien zostać wstawiony.</param>
        <param name="value">Obiekt do wstawienia.</param>
        <summary>Wstawia określony obiekt do <see cref="T:System.Windows.FreezableCollection`1" /> obiektu o określonym indeksie.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="index" />jest większa niż <see cref="P:System.Windows.FreezableCollection`1.Count" />.</exception>
        <exception cref="T:System.InvalidOperationException">Jest zamrożony ( <see cref="P:System.Windows.Freezable.IsFrozen" /> jej właściwość <see langword="true" />to). <see cref="T:System.Windows.FreezableCollection`1" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FreezableCollection`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T default[int] { T get(int index); void set(int index, T value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : 'T with get, set" Usage="System.Windows.FreezableCollection&lt;'T (requires 'T :&gt; System.Windows.DependencyObject)&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu, który ma zostać pobrany lub skonfigurowany.</param>
        <summary>Pobieranie lub konfigurowanie elementów pod określonym indeksem.</summary>
        <value>Element pod określonym indeksem.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="index" />jest równa lub większa niż <see cref="P:System.Windows.FreezableCollection`1.Count" />.</exception>
        <exception cref="T:System.ArgumentException">Określony element ma wartość <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę ustawienia elementu w kolekcji, gdy kolekcja jest zamrożona ( <see cref="P:System.Windows.Freezable.IsFrozen" /> jej właściwość <see langword="true" />to).</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T value);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; bool&#xA;override this.Remove : 'T -&gt; bool" Usage="freezableCollection.Remove value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do usunięcia.</param>
        <summary>Usuwa pierwsze wystąpienie określonego obiektu z <see cref="T:System.Windows.FreezableCollection`1" />.</summary>
        <returns><see langword="true" />Jeśli wystąpienie <paramref name="value" /> zostało znalezione w kolekcji i usunięte; <see langword="false" /> Jeśli<paramref name="value" /> nie można odnaleźć w kolekcji.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Jest zamrożony ( <see cref="P:System.Windows.Freezable.IsFrozen" /> jej właściwość <see langword="true" />to). <see cref="T:System.Windows.FreezableCollection`1" /></exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="freezableCollection.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks (liczony od zera) obiektu do usunięcia.</param>
        <summary>Usuwa obiekt w określonym indeksie <see cref="T:System.Windows.FreezableCollection`1" />liczonym od zera.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="index" />jest większa niż <see cref="P:System.Windows.FreezableCollection`1.Count" />.</exception>
        <exception cref="T:System.InvalidOperationException">Jest zamrożony ( <see cref="P:System.Windows.Freezable.IsFrozen" /> jej właściwość <see langword="true" />to). <see cref="T:System.Windows.FreezableCollection`1" /></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FreezableCollection`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;T&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Collections.Generic.ICollection`1.IsReadOnly" />Zobacz.</summary>
        <value><see langword="true" />Jeśli jest <see cref="T:System.Windows.FreezableCollection`1" /> tylko do odczytu; <see langword="false" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.FreezableCollection%601> gdy wystąpienie jest rzutowane <xref:System.Collections.Generic.ICollection%601> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" />Zobacz.</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerator`1" /> Obiekt, którego można użyć do iteracji w kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.FreezableCollection%601> gdy wystąpienie jest rzutowane <xref:System.Collections.Generic.IEnumerable%601> do interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FreezableCollection`1.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Wartość zerowa <see cref="T:System.Array" /> , która odbiera skopiowane elementy <see cref="T:System.Windows.FreezableCollection`1" />z.</param>
        <param name="index">Pierwsza pozycja w określonym <see cref="T:System.Array" /> do odebrania skopiowanej zawartości.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />Zobacz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.FreezableCollection%601> gdy wystąpienie jest rzutowane <xref:System.Collections.ICollection> do interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FreezableCollection`1.CopyTo(`0[],System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FreezableCollection`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Collections.ICollection.IsSynchronized" />Zobacz.</summary>
        <value><see langword="true" />Jeśli dostęp do programu <see cref="T:System.Windows.FreezableCollection`1" /> jest synchronizowany (wątek bezpieczny); <see langword="false" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.FreezableCollection%601> gdy wystąpienie jest rzutowane <xref:System.Collections.ICollection> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FreezableCollection`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Collections.ICollection.SyncRoot" />Zobacz.</summary>
        <value>Obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Windows.FreezableCollection`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.FreezableCollection%601> gdy wystąpienie jest rzutowane <xref:System.Collections.ICollection> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.Collections.IEnumerable.GetEnumerator" />Zobacz.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> Obiekt, którego można użyć do iteracji w kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.FreezableCollection%601> gdy wystąpienie jest rzutowane <xref:System.Collections.IEnumerable> do interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FreezableCollection`1.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">, <see cref="T:System.Object" /> Aby dodać <see cref="T:System.Windows.FreezableCollection`1" />do.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.Collections.IList.Add(System.Object)" />Zobacz.</summary>
        <returns>Położenie, do którego wstawiono nowy element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.FreezableCollection%601> gdy wystąpienie jest rzutowane <xref:System.Collections.IList> do interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FreezableCollection`1.Add(`0)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Object" /> Aby zlokalizować <see cref="T:System.Windows.FreezableCollection`1" />w.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.Collections.IList.Contains(System.Object)" />Zobacz.</summary>
        <returns><see langword="true" />Jeśli znajduje się <see cref="T:System.Windows.FreezableCollection`1" />w; w przeciwnym razie, <see langword="false" />. <see cref="T:System.Object" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.FreezableCollection%601> gdy wystąpienie jest rzutowane <xref:System.Collections.IList> do interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FreezableCollection`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Object" /> Aby zlokalizować <see cref="T:System.Windows.FreezableCollection`1" />w.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.Collections.IList.IndexOf(System.Object)" />Zobacz.</summary>
        <returns>Indeks elementu <paramref name="value" /> if znajduje się na liście; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.FreezableCollection%601> gdy wystąpienie jest rzutowane <xref:System.Collections.IList> do interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FreezableCollection`1.IndexOf(`0)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Indeks (liczony od zera), w którym ma <see cref="T:System.Object" />zostać wstawiony.</param>
        <param name="value">, <see cref="T:System.Object" /> Aby wstawić <see cref="T:System.Windows.FreezableCollection`1" />do.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.Collections.IList.Insert(System.Int32,System.Object)" />Zobacz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.FreezableCollection%601> gdy wystąpienie jest rzutowane <xref:System.Collections.IList> do interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FreezableCollection`1.Insert(System.Int32,`0)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FreezableCollection`1.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Collections.IList.IsFixedSize" />Zobacz.</summary>
        <value><see langword="true" />Jeśli ma stały rozmiar; <see langword="false" />w przeciwnym razie. <see cref="T:System.Windows.FreezableCollection`1" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.FreezableCollection%601> gdy wystąpienie jest rzutowane <xref:System.Collections.IList> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FreezableCollection`1.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Collections.IList.IsReadOnly" />Zobacz.</summary>
        <value><see langword="true" />Jeśli jest <see cref="T:System.Windows.FreezableCollection`1" /> tylko do odczytu; <see langword="false" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.FreezableCollection%601> gdy wystąpienie jest rzutowane <xref:System.Collections.IList> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FreezableCollection`1.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu, który ma zostać pobrany lub skonfigurowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Collections.IList.Item(System.Int32)" />Zobacz.</summary>
        <value>Element pod określonym indeksem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.FreezableCollection%601> gdy wystąpienie jest rzutowane <xref:System.Collections.IList> do interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FreezableCollection`1.Item(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FreezableCollection`1.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Object" /> Do usunięcia <see cref="T:System.Windows.FreezableCollection`1" />z.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.Collections.IList.Remove(System.Object)" />Zobacz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.FreezableCollection%601> gdy wystąpienie jest rzutowane <xref:System.Collections.IList> do interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FreezableCollection`1.Remove(`0)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged">
      <MemberSignature Language="C#" Value="event System.Collections.Specialized.NotifyCollectionChangedEventHandler System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Collections.Specialized.NotifyCollectionChangedEventHandler System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FreezableCollection`1.System#Collections#Specialized#INotifyCollectionChanged#CollectionChanged" />
      <MemberSignature Language="VB.NET" Value="Custom Event CollectionChanged As NotifyCollectionChangedEventHandler Implements System.Collections.Specialized.INotifyCollectionChanged" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NotifyCollectionChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Opis tych elementów członkowskich można znaleźć w temacie <see cref="E:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.FreezableCollection%601> gdy wystąpienie jest rzutowane <xref:System.Collections.Specialized.INotifyCollectionChanged> do interfejsu.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.INotifyPropertyChanged.PropertyChanged">
      <MemberSignature Language="C#" Value="event System.ComponentModel.PropertyChangedEventHandler System.ComponentModel.INotifyPropertyChanged.PropertyChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.PropertyChangedEventHandler System.ComponentModel.INotifyPropertyChanged.PropertyChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FreezableCollection`1.System#ComponentModel#INotifyPropertyChanged#PropertyChanged" />
      <MemberSignature Language="VB.NET" Value="Custom Event PropertyChanged As PropertyChangedEventHandler Implements System.ComponentModel.INotifyPropertyChanged" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Opis tych elementów członkowskich można znaleźć w temacie <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.FreezableCollection%601> gdy wystąpienie jest rzutowane <xref:System.ComponentModel.INotifyPropertyChanged> do interfejsu.

]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="DependencyPropertyKey" FullName="System.Windows.DependencyPropertyKey">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f9fcfb20206ac7f24d91f609ccb02c05f54be47c" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37549959" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DependencyPropertyKey" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyPropertyKey extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyPropertyKey" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyPropertyKey" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyPropertyKey sealed" />
  <TypeSignature Language="F#" Value="type DependencyPropertyKey = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="8ecb4-101">Zawiera identyfikator właściwości zależności ograniczone do zapisu właściwości zależności tylko do odczytu.</span>
      <span class="sxs-lookup">
        <span data-stu-id="8ecb4-101">Provides a dependency property identifier for limited write access to a read-only dependency property.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ecb4-102"><xref:System.Windows.DependencyPropertyKey> wystąpienia są uzyskiwane jako wartość zwracaną przez wywołanie rejestracji właściwość zależności za pomocą metod <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> lub <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.</span><span class="sxs-lookup"><span data-stu-id="8ecb4-102"><xref:System.Windows.DependencyPropertyKey> instances are obtained as the return value of a dependency property registration call using the methods <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> or <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.</span></span>  
  
 <span data-ttu-id="8ecb4-103">Typy, które Zarejestruj właściwości zależności można użyć <xref:System.Windows.DependencyPropertyKey> w wywołaniach <xref:System.Windows.DependencyObject.SetValue%2A> i <xref:System.Windows.DependencyObject.ClearValue%2A> , Dostosuj wartość właściwości jako część logiki klasy.</span><span class="sxs-lookup"><span data-stu-id="8ecb4-103">The types that register a dependency property can use the <xref:System.Windows.DependencyPropertyKey> in calls to <xref:System.Windows.DependencyObject.SetValue%2A> and <xref:System.Windows.DependencyObject.ClearValue%2A> that adjust the property's value as part of class logic.</span></span> <span data-ttu-id="8ecb4-104">Jeśli dozwolone przez poziom dostępu do klucza, powiązanymi klasami też używać klucza i właściwości zależności.</span><span class="sxs-lookup"><span data-stu-id="8ecb4-104">If permitted by the access level of the key, related classes can use the key and the dependency property also.</span></span> <span data-ttu-id="8ecb4-105">Na przykład można zadeklarować klucza jako wewnętrzne, a inne typy w obrębie tego samego zestawu można również ustawić tę właściwość zależności.</span><span class="sxs-lookup"><span data-stu-id="8ecb4-105">For instance, you can declare the key as internal, and other types within the same assembly can also set that dependency property.</span></span>  
  
 <span data-ttu-id="8ecb4-106"><xref:System.Windows.DependencyPropertyKey> Zwrócony przez zależności tylko do odczytu właściwości rejestracji nie należy publiczne, ponieważ udostępnianie klucz sprawia, że właściwość można ustawić, udaremniając tym samym punktem rejestrując go jako właściwości zależności tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="8ecb4-106">The <xref:System.Windows.DependencyPropertyKey> returned by read-only dependency property registration should not be made public, because exposing the key makes the property settable, thus defeating the point of registering it as a read-only dependency property.</span></span> <span data-ttu-id="8ecb4-107">Ponadto ujawnienie klucza powoduje, że niezgodność między zależności dostępne właściwości zachowania i jego [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] właściwość otoki implementacji, czyli zła projektowania.</span><span class="sxs-lookup"><span data-stu-id="8ecb4-107">Also, exposing the key causes a mismatch between the available dependency property behaviors and its [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] property wrapper implementations, which is bad class design.</span></span>  
  
 <span data-ttu-id="8ecb4-108">Zamiast uwidaczniania sam klucz, zamiast tego powinny ujawniać <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> wartość <xref:System.Windows.DependencyPropertyKey> jako `public static readonly` <xref:System.Windows.DependencyProperty> na klasie.</span><span class="sxs-lookup"><span data-stu-id="8ecb4-108">Instead of exposing the key itself, you should instead expose the <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> value of the <xref:System.Windows.DependencyPropertyKey> as a `public static readonly`<xref:System.Windows.DependencyProperty> on your class.</span></span> <span data-ttu-id="8ecb4-109">Dzięki temu właściwości do zwrócenia identyfikatora właściwości zależności prawidłowe w przypadku niektórych operacji systemu właściwości, takich jak wyliczanie lokalnie Ustawianie wartości.</span><span class="sxs-lookup"><span data-stu-id="8ecb4-109">This enables the property to return a valid dependency property identifier for certain property system operations such as enumerating locally set values.</span></span> <span data-ttu-id="8ecb4-110">Jednak identyfikator uzyskane w związku z tym nie ma w pełni możliwości <xref:System.Windows.DependencyProperty> wielu operacjach system właściwości.</span><span class="sxs-lookup"><span data-stu-id="8ecb4-110">However, the identifier thus obtained does not have the full capabilities of a <xref:System.Windows.DependencyProperty> for many property system operations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ecb4-111">Poniższy przykład rejestruje właściwości zależności tylko do odczytu, a także korzysta z klucza do dwóch celów w innych składowych klasy: Implementowanie get "otoki" i jako identyfikatory operacji chronionych określenie, która ustawia wartość na podstawie obliczeń inne wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="8ecb4-111">The following example registers a read-only dependency property, and also uses the key for two purposes in other class members: implementing the get "wrapper", and as the identifier for a protected determination operation that sets the value based on calculations of other property values.</span></span>  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName="DependencyProperty">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty DependencyProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyProperty DependencyProperty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyPropertyKey.DependencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyProperty As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyProperty ^ DependencyProperty { System::Windows::DependencyProperty ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependencyProperty : System.Windows.DependencyProperty" Usage="System.Windows.DependencyPropertyKey.DependencyProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8ecb4-112">Pobiera identyfikator właściwości zależności, które są skojarzone z identyfikatorem właściwości specjalne zależności tylko do odczytu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb4-112">Gets the dependency property identifier associated with this specialized read-only dependency property identifier.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8ecb4-113">Identyfikator właściwości odpowiednich zależności.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb4-113">The relevant dependency property identifier.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ecb4-114"><xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> Wartość włącza identyfikator właściwości tylko do odczytu do wzięcia udziału w typowych operacji systemu właściwości przy użyciu niektóre z tych samych interfejsów jako używane dla właściwości zależności odczytu i zapisu.</span><span class="sxs-lookup"><span data-stu-id="8ecb4-114">The <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> value enables a read-only property's identifier to participate in common property system operations using some of the same interfaces as used for read-write dependency properties.</span></span>  
  
 <span data-ttu-id="8ecb4-115">Aby można było implementować metody dostępu właściwości get dla właściwości zależności tylko do odczytu, należy utworzyć i uwidocznić <xref:System.Windows.DependencyProperty> identyfikator swojej klasy.</span><span class="sxs-lookup"><span data-stu-id="8ecb4-115">In order to implement the get property accessor for a read-only dependency property, you should create and expose a <xref:System.Windows.DependencyProperty> identifier on your class.</span></span> <span data-ttu-id="8ecb4-116">Służy do dwóch celów:</span><span class="sxs-lookup"><span data-stu-id="8ecb4-116">This serves two purposes:</span></span>  
  
-   <span data-ttu-id="8ecb4-117">Twoje potrzeby klasy <xref:System.Windows.DependencyProperty> identyfikator, aby można było implementować metody dostępu get dla otoki właściwości.</span><span class="sxs-lookup"><span data-stu-id="8ecb4-117">Your own class needs the <xref:System.Windows.DependencyProperty> identifier in order to implement the get accessor for the property wrapper.</span></span> <span data-ttu-id="8ecb4-118">Możesz użyć <xref:System.Windows.DependencyProperty> jako parametru dla <xref:System.Windows.DependencyObject.GetValue%2A> wywołań, który implementuje metody dostępu get.</span><span class="sxs-lookup"><span data-stu-id="8ecb4-118">You use the <xref:System.Windows.DependencyProperty> as a parameter for the <xref:System.Windows.DependencyObject.GetValue%2A> call that implements the get accessor.</span></span>  
  
-   <span data-ttu-id="8ecb4-119"><xref:System.Windows.DependencyProperty> identyfikatory uwidocznić swoje właściwości zależności systemu właściwość taki sposób, że inne metody, które zależą od metadanych do niego dostęp w postaci standardowych.</span><span class="sxs-lookup"><span data-stu-id="8ecb4-119"><xref:System.Windows.DependencyProperty> identifiers expose your dependency property to the property system such that other methods that rely on metadata can access it in a standard form.</span></span> <span data-ttu-id="8ecb4-120">Na przykład jeśli wywołujesz <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> niektórych <xref:System.Windows.DependencyObject> i uzyskać identyfikator wyliczenia właściwości ustawione lokalnie (wartości i identyfikatory) zwrócona dla właściwości zależności tylko do odczytu będzie swoje <xref:System.Windows.DependencyProperty> wartości zamiast klucza.</span><span class="sxs-lookup"><span data-stu-id="8ecb4-120">For instance, if you called <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> on some <xref:System.Windows.DependencyObject> and obtained an enumeration of locally set properties (values and identifiers) the identifier returned for a read-only dependency property would be your <xref:System.Windows.DependencyProperty> value rather than the key.</span></span> <span data-ttu-id="8ecb4-121">Udostępnianie nie <xref:System.Windows.DependencyProperty> identyfikator nie zwiększa zabezpieczenia właściwości zależności tylko do odczytu w jakikolwiek sposób, to po prostu sprawia, że operacje obejmujące Twoja własność bardziej niewygodna kolejnych klas pochodnych i wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="8ecb4-121">Not exposing a <xref:System.Windows.DependencyProperty> identifier does not increase the security of your read-only dependency property in any way, it just makes operations that involve your property more awkward both for subsequent derived classes and class instances.</span></span>  
  
 <span data-ttu-id="8ecb4-122">Aby udostępnić <xref:System.Windows.DependencyProperty> identyfikator w swojej klasie, należy wywołać <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> bezpośrednio na klucz.</span><span class="sxs-lookup"><span data-stu-id="8ecb4-122">To expose the  <xref:System.Windows.DependencyProperty> identifier on your class, you call <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> directly on your key.</span></span> <span data-ttu-id="8ecb4-123">Ta wartość służy do tworzenia `public static readonly` <xref:System.Windows.DependencyProperty> identyfikator klasy, która równoleżnikami <xref:System.Windows.DependencyPropertyKey>.</span><span class="sxs-lookup"><span data-stu-id="8ecb4-123">Use this value to create a `public static readonly`<xref:System.Windows.DependencyProperty> identifier on the class, which parallels the <xref:System.Windows.DependencyPropertyKey>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ecb4-124">Poniższy przykład wywołuje <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> do udostępnienia <xref:System.Windows.DependencyProperty> identyfikator (`AquariumGraphicProperty`) dla `AquariumGraphic` właściwości zależności tylko do odczytu w klasie.</span><span class="sxs-lookup"><span data-stu-id="8ecb4-124">The following example calls <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> to expose the <xref:System.Windows.DependencyProperty> identifier (`AquariumGraphicProperty`) for the `AquariumGraphic` read-only dependency property on a class.</span></span> <span data-ttu-id="8ecb4-125">W przykładzie pokazano również <xref:System.Windows.DependencyPropertyKey> tworzenie (jako wewnętrzny element członkowski) i metody dostępu get dla `AquariumGraphic`.</span><span class="sxs-lookup"><span data-stu-id="8ecb4-125">The example also shows the <xref:System.Windows.DependencyPropertyKey> creation (as an internal member) and the get accessor for `AquariumGraphic`.</span></span>  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyPropertyKey.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">
          <span data-ttu-id="8ecb4-126">Typ, ta właściwość zależności istnieje i, w którym powinna zostać zastąpiona w metadanych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb4-126">The type on which this dependency property exists and metadata should be overridden.</span>
          </span>
        </param>
        <param name="typeMetadata">
          <span data-ttu-id="8ecb4-127">Metadane podane dla tego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb4-127">Metadata supplied for this type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ecb4-128">Zastępuje metadanych właściwości zależności tylko do odczytu, który jest reprezentowany przez ten identyfikator właściwości zależności.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb4-128">Overrides the metadata of a read-only dependency property that is represented by this dependency property identifier.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ecb4-129">Zastępowanie metadanych właściwości zależności tylko do odczytu jest wykonywane ze względów podobnie jak zastępowanie metadanych właściwości zależności odczytu / zapisu i jest ograniczony do dostępu na poziomie klucza, ponieważ określony w metadanych zachowania można zmienić zachowanie zestawu ( Wartość domyślna, na przykład).</span><span class="sxs-lookup"><span data-stu-id="8ecb4-129">Overriding metadata on a read-only dependency property is done for similar reasons as overriding metadata on a read-write dependency property, and is restricted to access at the key level because behaviors specified in the metadata can change the set behavior (the default value, for instance).</span></span>  
  
 <span data-ttu-id="8ecb4-130">Jak przy użyciu właściwości zależności odczytu i zapisu, zastępowanie metadanych właściwości zależności tylko do odczytu należy to robić tylko przed tej właściwości zostanie umieszczona w użyciu przez system właściwości (to jest równa czas tego określone wystąpienia obiektów, które rejestrują właściwości są tworzone).</span><span class="sxs-lookup"><span data-stu-id="8ecb4-130">As with read-write dependency properties, overriding metadata on a read-only dependency property should only be done prior to that property being placed in use by the property system (this equates to the time that specific instances of objects that register the property are instantiated).</span></span> <span data-ttu-id="8ecb4-131">Wywołania <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> powinny zostać wykonane tylko w konstruktorach statycznych typu, który zapewnia siebie jako `forType` parametru tej metody, lub równoważne inicjowanie tej klasy.</span><span class="sxs-lookup"><span data-stu-id="8ecb4-131">Calls to <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> should only be performed within the static constructors of the type that provides itself as the `forType` parameter of this method, or equivalent initialization for that class.</span></span>  
  
 <span data-ttu-id="8ecb4-132">Ta metoda skutecznie przekazuje do <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> jest metoda <xref:System.Windows.DependencyPropertyKey> wystąpienia jako parametr klucza.</span><span class="sxs-lookup"><span data-stu-id="8ecb4-132">This method effectively forwards to the <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method, passing the <xref:System.Windows.DependencyPropertyKey> instance as the key parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ecb4-133">Poniższy przykład zastępuje metadanych właściwości zależności tylko do odczytu, która dziedziczy z klasy.</span><span class="sxs-lookup"><span data-stu-id="8ecb4-133">The following example overrides metadata for an existing read-only dependency property that a class inherits.</span></span> <span data-ttu-id="8ecb4-134">W tym przypadku celem scenariuszu było dodać coerce wartość wywołanie zwrotne nie miał metadane właściwości podstawowej.</span><span class="sxs-lookup"><span data-stu-id="8ecb4-134">In this case, the scenario goal was to add a coerce value callback that the base property metadata did not have.</span></span> <span data-ttu-id="8ecb4-135">Można także zastąpić metadane dla odpowiednich z innych powodów, które Zastępowanie metadanych jest zwykle (zmiana wartości domyślnej, dodając <xref:System.Windows.FrameworkPropertyMetadataOptions> wartości itp.)</span><span class="sxs-lookup"><span data-stu-id="8ecb4-135">You could also override metadata for any of the other reasons that overriding metadata is typically appropriate (changing default value, adding <xref:System.Windows.FrameworkPropertyMetadataOptions> values, etc.)</span></span>  
  
 [!code-csharp[WPFAquariumSln#RODPOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodpoverride)]
 [!code-vb[WPFAquariumSln#RODPOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodpoverride)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8ecb4-136">Metadane próba zastąpienia dla właściwości zależności odczytu i zapisu (nie można wykonać przy użyciu tej sygnatury).</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb4-136">Attempted metadata override on a read-write dependency property (cannot be done using this signature).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8ecb4-137">Metadane już została włączona dla właściwości, zgodnie z jego lokalizacją dla podanego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb4-137">Metadata was already established for the property as it exists on the provided type.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.DependencyProperty" />
        <altmember cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="DependencyPropertyKey" FullName="System.Windows.DependencyPropertyKey">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9a12e407bc5345e416145c390f8fcd6f8262c445" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30714629" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DependencyPropertyKey" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyPropertyKey extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyPropertyKey" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyPropertyKey" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyPropertyKey sealed" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zapewnia ograniczony dostęp zapisu do właściwości tylko do odczytu zależności identyfikatora właściwości zależności.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyPropertyKey> wystąpienia są uzyskiwane jako wartość zwracaną przez wywołanie rejestracji właściwości zależności przy użyciu metody <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> lub <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.  
  
 Typy, które Zarejestruj właściwości zależności można użyć <xref:System.Windows.DependencyPropertyKey> w wywołaniach <xref:System.Windows.DependencyObject.SetValue%2A> i <xref:System.Windows.DependencyObject.ClearValue%2A> który dostosowanie wartości właściwości jako część logiki klasy. Jeśli dozwolone przez poziom dostępu do klucza, powiązanymi klasami również użyć klucza i właściwości zależności. Na przykład można zadeklarować klucz jako wewnętrzne i innych typów w ramach tego samego zestawu można również ustawić tej właściwości zależności.  
  
 <xref:System.Windows.DependencyPropertyKey> Zwrócony przez zależność tylko do odczytu właściwości rejestracji nie należy publiczne, ponieważ klucz udostępnianie sprawia, że właściwość można ustawić, w związku z tym defeating punktu rejestrując go jako właściwość tylko do odczytu zależności. Również udostępnianie klucz powoduje niezgodność między dostępne zależności zachowania właściwości i jego [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] implementacji otoki właściwości, które jest zła projektowania.  
  
 Zamiast udostępnianie samego klucza, zamiast tego powinny ujawniać <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> wartość <xref:System.Windows.DependencyPropertyKey> jako `public static readonly` <xref:System.Windows.DependencyProperty> w klasie. Dzięki temu właściwości do zwrócenia zależności nieprawidłowy identyfikator właściwości dla niektórych właściwości systemu operacji, takich jak lokalnie wyliczania zestaw wartości. Jednak identyfikator uzyskanych w związku z tym nie ma w pełni możliwości <xref:System.Windows.DependencyProperty> na wiele właściwości systemu operacji.  
  
   
  
## Examples  
 Poniższy przykład rejestruje właściwości zależności tylko do odczytu, a także korzysta z klucza do dwóch celów w innych elementach członkowskich klasy: implementacja get "otoki" i jako identyfikator dla operacji chronionego oznaczania, która ustawia wartości na podstawie obliczeń wartości innych właściwości.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName="DependencyProperty">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty DependencyProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyProperty DependencyProperty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyPropertyKey.DependencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyProperty As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyProperty ^ DependencyProperty { System::Windows::DependencyProperty ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator właściwości zależności, które są skojarzone z identyfikatorem właściwość specjalne zależności tylko do odczytu.</summary>
        <value>Identyfikator właściwości odpowiednich zależności.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> Wartość powoduje włączenie identyfikatora właściwości tylko do odczytu do udziału wspólnych właściwości operacje systemu za pomocą niektóre z tych samych interfejsów jako używane dla właściwości zależności odczytu i zapisu.  
  
 Aby mogła implementować metody dostępu właściwości get dla właściwości tylko do odczytu zależności, należy utworzyć i uwidocznić <xref:System.Windows.DependencyProperty> identyfikatora klasy. Dzięki temu dwóch celów:  
  
-   Potrzeb klasy <xref:System.Windows.DependencyProperty> identyfikator, aby mogła implementować metody dostępu get dla właściwości otoki. Możesz użyć <xref:System.Windows.DependencyProperty> jako parametru dla <xref:System.Windows.DependencyObject.GetValue%2A> wywołania, który implementuje metody dostępu get.  
  
-   <xref:System.Windows.DependencyProperty> identyfikatory narazić Twoje właściwości zależności w systemie właściwości tak, aby innych metod, które opierają się na metadanych do niego dostęp w formie standardowej. Na przykład jeśli wywołujesz <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> na niektórych <xref:System.Windows.DependencyObject> i pobierane wyliczenie lokalnie zestawu właściwości (wartości i identyfikatorów), identyfikator zwrócona dla właściwości tylko do odczytu zależności będą Twojej <xref:System.Windows.DependencyProperty> wartość zamiast klucza. Udostępnianie nie <xref:System.Windows.DependencyProperty> identyfikator nie zwiększenie bezpieczeństwa sieci właściwości tylko do odczytu zależności w dowolny sposób, ale tylko operacji związanych z właściwości więcej nieodpowiednich zarówno dla kolejnych klas pochodnych i wystąpień klas.  
  
 Aby udostępnić <xref:System.Windows.DependencyProperty> identyfikatora klasy, należy wywołać <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> bezpośrednio na klucz. Użyj tej wartości, aby utworzyć `public static readonly` <xref:System.Windows.DependencyProperty> identyfikatora klasy, która równoleżnikami <xref:System.Windows.DependencyPropertyKey>.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> do udostępnienia <xref:System.Windows.DependencyProperty> identyfikator (`AquariumGraphicProperty`) dla `AquariumGraphic` właściwość dependency tylko do odczytu w klasie. Ponadto w przykładzie <xref:System.Windows.DependencyPropertyKey> tworzenie (jako element członkowski wewnętrznego) i metody dostępu get dla `AquariumGraphic`.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">Typ, na którym ta właściwość zależności istnieje i powinna zostać zastąpiona w metadanych.</param>
        <param name="typeMetadata">Metadane podane dla tego typu.</param>
        <summary>Zastępuje metadane właściwości tylko do odczytu zależności reprezentowanego przez ten identyfikator właściwości zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastępowanie metadanych dla właściwości tylko do odczytu zależności odbywa się podobnych przyczyn jako Zastępowanie metadanych dla właściwości zależności odczytu i zapisu i jest ograniczony do dostęp na poziomie klucza, ponieważ zachowanie zestawu (można zmienić zachowania określony w metadanych Wartość domyślna, na przykład).  
  
 Ponieważ z właściwości zależności odczytu i zapisu, zastępowanie metadanych dla właściwości tylko do odczytu zależności powinno być wykonane przed tą właściwością zostanie umieszczona w użycia przez system właściwości (to jest równa czas tego określone wystąpienia obiektów, które rejestrują właściwości są wystąpienia). Wywołuje się <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> powinno być wykonywane jedynie konstruktorów statycznych typu, który udostępnia siebie jako `forType` parametru tej metody, lub równoważne inicjowania dla tej klasy.  
  
 Ta metoda skutecznie przekazuje do <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> jest metoda <xref:System.Windows.DependencyPropertyKey> wystąpienia jako parametr klucza.  
  
   
  
## Examples  
 Poniższy przykład zastępuje metadane dla właściwości tylko do odczytu zależności, który dziedziczy z klasy. W takim przypadku celem scenariuszu było dodać wywołanie zwrotne wartość coerce, które nie ma metadanych właściwości podstawowej. Można także zastępować metadanych dla jednego z powodów, które Zastępowanie metadanych jest zazwyczaj odpowiednie (zmiana wartości domyślnej, dodawanie <xref:System.Windows.FrameworkPropertyMetadataOptions> wartości itp.)  
  
 [!code-csharp[WPFAquariumSln#RODPOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodpoverride)]
 [!code-vb[WPFAquariumSln#RODPOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodpoverride)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Próba metadane zastępcze dla właściwości zależności odczytu i zapisu (nie można wykonać za pomocą tego podpisu).</exception>
        <exception cref="T:System.ArgumentException">Metadane już zostało ustanowione dla właściwości, ponieważ znajduje się na udostępnionego typu.</exception>
        <altmember cref="T:System.Windows.DependencyProperty" />
        <altmember cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      </Docs>
    </Member>
  </Members>
</Type>
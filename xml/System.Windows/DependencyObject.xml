<Type Name="DependencyObject" FullName="System.Windows.DependencyObject">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cdad856ca1190b53eeb702e6825901cbd349d2ed" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55320242" /></Metadata><TypeSignature Language="C#" Value="public class DependencyObject : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DependencyObject extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DependencyObject&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyObject : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type DependencyObject = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.ComponentModel.DependencyObjectProvider))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.NameScopeProperty("NameScope", typeof(System.Windows.NameScope))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje obiekt, który uczestniczy w systemie właściwości zależności.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyObject> Klasy umożliwia [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] właściwości usług systemowych na wiele klas pochodnych.  
  
 System właściwości podstawową funkcją jest do obliczenia wartości właściwości oraz w celu zapewnienia systemu powiadomień dotyczące wartości, które uległy zmianie. Jest innej klasy klucza, który uczestniczy w systemie właściwości <xref:System.Windows.DependencyProperty>. <xref:System.Windows.DependencyProperty> Umożliwia rejestrację właściwości zależności w systemie właściwości i zawiera identyfikator i informacje o każdej właściwości zależności, natomiast <xref:System.Windows.DependencyObject> jako klasę bazową umożliwia obiekty używane właściwości zależności.  
  
 <xref:System.Windows.DependencyObject> usługi i właściwości są następujące:  
  
-   Obsługa hostingu właściwość zależności. Zarejestruj właściwości zależności, wywołując <xref:System.Windows.DependencyProperty.Register%2A> metoda i przechowywania wartości zwracanej metody jako publiczne pole statyczne w klasie.  
  
-   Dołączona właściwość Obsługa hostingu. Zarejestruj dołączoną właściwość wywołując <xref:System.Windows.DependencyProperty.RegisterAttached%2A> metoda i przechowywania wartości zwracanej metody jako publiczne statyczne pole tylko do odczytu w klasie. (Dostępne są także wymagania dotyczące dodatkowych składowych; należy pamiętać, że jest to [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] konkretnej implementacji w przypadku dołączonych właściwości. Aby uzyskać więcej informacji, zobacz [Przegląd właściwości dołączonych](~/docs/framework/wpf/advanced/attached-properties-overview.md).) Usługi dołączonej właściwości można następnie ustawić na dowolną klasę pochodzącą od <xref:System.Windows.DependencyObject>.  
  
-   Pobierania ustawiania, a następnie wyczyść metody narzędziowe do wartości wszystkich właściwości zależności, które istnieją na <xref:System.Windows.DependencyObject>.  
  
-   Metadane, wymuszone obsługę wartości, powiadomienie o zmianie właściwości i wywołań zwrotnych zastąpienie właściwości zależności lub dołączone właściwości. Ponadto <xref:System.Windows.DependencyObject> klasy ułatwia metadane właściwości dla właściciela dla właściwości zależności.  
  
-   Wspólna klasa bazowa dla klas pochodną <xref:System.Windows.ContentElement>, <xref:System.Windows.Freezable>, lub <xref:System.Windows.Media.Visual>. (<xref:System.Windows.UIElement>, innej klasy elementu podstawowego, ma hierarchii klas, która obejmuje <xref:System.Windows.Media.Visual>.)  
  
   
  
## Examples  
 Poniższy przykład pochodzi z <xref:System.Windows.DependencyObject> do utworzenia nowej klasy abstrakcyjnej. Klasa następnie rejestruje dołączoną właściwość i obejmuje członków pomocy technicznej dla tej właściwości dołączone.  
  
 [!code-csharp[WPFAquariumSln#DOMain](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#domain)]
 [!code-vb[WPFAquariumSln#DOMain](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#domain)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependencyObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DependencyObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.DependencyObject" /> klasy.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ClearValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Czyści lokalna wartość właściwości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.ClearValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Właściwości zależności, aby zostać wyczyszczone, identyfikowane przez <see cref="T:System.Windows.DependencyProperty" /> odwołanie do obiektu.</param>
        <summary>Czyści lokalna wartość właściwości. Właściwość do wyczyszczenia jest określona przez <see cref="T:System.Windows.DependencyProperty" /> identyfikatora.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyczyszczenie wartości właściwości, wywołując <xref:System.Windows.DependencyObject.ClearValue%2A> niekoniecznie daje właściwości zależności wartość domyślną, która jest określona w metadanych właściwości zależności. Czyszczenie właściwości tylko wyraźnie czyści, niezależnie od wartości lokalnej zostały zastosowane. Aby uzyskać więcej informacji, zobacz [następstwo wartości właściwości](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
   
  
## Examples  
 Poniższy przykład wykonuje iterację wszystkich właściwości, które mają wartości lokalnych ustawiona na obiekt, następnie wywołuje <xref:System.Windows.DependencyObject.ClearValue%2A> aby wyczyścić wartości w każdej z tych właściwości.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba wywołania <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> w zapieczętowanym <see cref="T:System.Windows.DependencyObject" />.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="P:System.Windows.DependencyObject.IsSealed" />
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyObject.ClearValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz dla właściwości zależności, aby zostać wyczyszczone.</param>
        <summary>Czyści lokalna wartość właściwości tylko do odczytu. Właściwość do wyczyszczenia jest określona przez <see cref="T:System.Windows.DependencyPropertyKey" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.DependencyPropertyKey> identyfikuje właściwości zależności tylko do odczytu dla operacji systemu właściwości. Klasy, które definiują właściwości zależności tylko do odczytu nie powinny ujawniać tego klucza publicznego. Udostępnione publicznie klucza przekazanie ścieżki kodu publicznego, który ujemna znak tylko do odczytu właściwości, jeśli metody takie jak <xref:System.Windows.DependencyObject.ClearValue%2A> lub <xref:System.Windows.DependencyObject.SetValue%2A> może być wywoływana poza klasy lub zestawu, odwołuje się do klucza.  
  
 Wyczyszczenie wartości właściwości, wywołując <xref:System.Windows.DependencyObject.ClearValue%2A> niekoniecznie daje właściwości zależności wartość domyślną, która jest określona w metadanych właściwości zależności. Wyczyszczenie wartości tylko wyraźnie czyści, niezależnie od wartości lokalnej zostały zastosowane. Aby uzyskać więcej informacji, zobacz [następstwo wartości właściwości](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba wywołania <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> w zapieczętowanym <see cref="T:System.Windows.DependencyObject" />.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="T:System.Windows.DependencyPropertyKey" />
      </Docs>
    </Member>
    <Member MemberName="CoerceValue">
      <MemberSignature Language="C#" Value="public void CoerceValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CoerceValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CoerceValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CoerceValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.CoerceValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.CoerceValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Identyfikator właściwości zależności, aby wymusić.</param>
        <summary>Przekształca wynik dane wartości właściwości określonej zależności. Jest to realizowane za pomocą dowolnego <see cref="T:System.Windows.CoerceValueCallback" /> określony w metadanych właściwości modelu dla właściwości zależności, ponieważ znajduje się na wywołania funkcji <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oprócz jawnie wywoływana za pośrednictwem wywołania <xref:System.Windows.DependencyObject.CoerceValue%2A>, <xref:System.Windows.CoerceValueCallback> zależność właściwość jest również wywoływany wewnętrznie zawsze wtedy, gdy wartość właściwości zależności jest ponownie oceniane przez [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] właściwości systemu.  
  
 Gdy wywołujesz <xref:System.Windows.DependencyObject.CoerceValue%2A> metody ostatecznie wywoływane coerce wartość wywołania zwrotnego dla właściwości, które określisz. Zwykle będzie wywoływać <xref:System.Windows.DependencyObject.CoerceValue%2A> tylko, jeśli wiesz, że wywołanie zwrotne wartość coerce istnieje i jeśli znasz kryteria wywołania zwrotnego dla wymuszenia.  
  
 Najbardziej typowym scenariuszem do wywoływania <xref:System.Windows.DependencyObject.CoerceValue%2A> mieści się klasy obsługi lub właściwość zmiany wywołania zwrotne z powiązanych właściwości, które wpływają na siebie nawzajem wartości w taki sposób, zależnych. Aby uzyskać więcej informacji, zobacz [zależność wartości wywołania zwrotnego i walidacji](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Windows.DependencyObject.CoerceValue%2A> w ramach <xref:System.Windows.PropertyChangedCallback> implementację, która jest używana jako <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> dla właściwości zależności różne, w tej samej klasy. Jest to wspólny wzorzec wprowadzania wartość true zależności między właściwościami zależności.  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Określony <paramref name="dp" /> lub jego wartość była nieprawidłowa lub nie istnieją.</exception>
        <altmember cref="T:System.Windows.CoerceValueCallback" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DependencyObjectType">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObjectType DependencyObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObjectType DependencyObjectType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.DependencyObjectType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyObjectType As DependencyObjectType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObjectType ^ DependencyObjectType { System::Windows::DependencyObjectType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependencyObjectType : System.Windows.DependencyObjectType" Usage="System.Windows.DependencyObject.DependencyObjectType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObjectType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.DependencyObjectType" /> to opakowuje [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] typu tego wystąpienia.</summary>
        <value>A <see cref="T:System.Windows.DependencyObjectType" /> to opakowuje [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] typu tego wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest przydatna, jeśli obiekt, który jest zwracany z metody ma typ wartości zwracanej <xref:System.Windows.DependencyObject> i chcesz przeprowadzić właściwości określonych operacji w systemie go w zależności od jego typu. Na przykład jest bardziej wydajne, aby wywołać <xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29> przy użyciu <xref:System.Windows.DependencyObjectType> zamiast [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] typu. <xref:System.Windows.DependencyObjectType> ułatwia szybsze wyszukiwania.  
  
   
  
## Examples  
 W poniższym przykładzie pseudokodzie `MySubClass` oszacowano, że dodatkowe klasy pochodne mogą ulec zmianie wartość domyślną `MyCustom` właściwość zależności. Klasa implementuje domyślnego konstruktora, można określić rzeczywisty klasy pochodnej, wykorzystując polimorfizm <xref:System.Windows.DependencyObjectType> wartości w każdym przypadku, gdy ten konstruktor jest używany jako instantiator klasy pochodnej.  
  
 `public DOClass() : base()`  
  
 `{`  
  
 `__customPropertyCache = (CustomDP)`  
  
 `CustomDPProperty.GetMetadata(DependencyObjectType).DefaultValue;`  
  
 `}`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
        <altmember cref="T:System.Windows.DependencyObjectType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override sealed bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="dependencyObject.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><see cref="T:System.Windows.DependencyObject" /> Do porównania z bieżącym wystąpieniem.</param>
        <summary>Określa, czy podana <see cref="T:System.Windows.DependencyObject" /> jest odpowiednikiem bieżącego <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns><see langword="true" /> Jeśli dwa wystąpienia są takie same; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja jest tylko równości odwołań i nie podejmuje próby oceny równość wartości właściwości zawartych.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.DependencyObject" /> zastępuje, a następnie zapieczętowuje dwa podstawowe <see cref="T:System.Object" /> metody: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> i <see cref="M:System.Windows.DependencyObject.GetHashCode" />. Wywołania przesłonięć <see cref="T:System.Object" /> implementacji, co spowoduje zachowanie równość obiektu. Te zastąpienia zamierzonego ma na celu zapobiec próby Definiowanie równości wartości dla klas pochodnych <see cref="T:System.Windows.DependencyObject" />. Wartość equalities dla <see cref="T:System.Windows.DependencyObject" /> nigdy nie będą właściwe, ze względu na właściwość zapewniające zmieniając wartość możliwości <see cref="T:System.Windows.DependencyObject" /> i jego właściwości zależności. Obejmuje to podstawowe [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] funkcje, takie jak powiązanie danych oraz [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] właściwości systemu.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override sealed int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyObject.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość skrótu dla tego <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Całkowita 32-bitowa wartość skrótu.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.DependencyObject" /> zastępuje, a następnie zapieczętowuje dwa <see cref="T:System.Object" /> metody: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> i <see cref="M:System.Windows.DependencyObject.GetHashCode" />. Wywołania przesłonięć <see cref="T:System.Object" /> implementacji, co spowoduje zachowanie równość obiektu. Te zastąpienia zamierzonego ma na celu zapobiec próby Definiowanie równości wartości dla klas pochodnych <see cref="T:System.Windows.DependencyObject" />. Wartość equalities dla <see cref="T:System.Windows.DependencyObject" /> nigdy nie będą właściwe, ze względu na właściwość zapewniające zmieniając wartość możliwości <see cref="T:System.Windows.DependencyObject" /> i jego właściwości zależności. Obejmuje to podstawowe [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] funkcje, takie jak powiązanie danych oraz [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] właściwości systemu.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetLocalValueEnumerator">
      <MemberSignature Language="C#" Value="public System.Windows.LocalValueEnumerator GetLocalValueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.LocalValueEnumerator GetLocalValueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLocalValueEnumerator () As LocalValueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::LocalValueEnumerator GetLocalValueEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetLocalValueEnumerator : unit -&gt; System.Windows.LocalValueEnumerator" Usage="dependencyObject.GetLocalValueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LocalValueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy specjalne modułu wyliczającego do określania, które właściwości zależności lokalnie ustawiono wartości w tym <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Moduł wyliczający wyspecjalizowane wartości lokalnej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A *lokalna wartość* oznacza dowolną wartość właściwości zależności, która została ustawiona przez <xref:System.Windows.DependencyObject.SetValue%2A>, w przeciwieństwie do innych aspektów dla właściwości.  
  
 <xref:System.Windows.LocalValueEnumerator> Można uzyskać przez wywołanie <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> może służyć do wyliczenia właściwości, które mają lokalnie ustawiony wartość <xref:System.Windows.DependencyObject> wystąpienia. Każdej z tych właściwości jest reprezentowana w moduł wyliczający przez <xref:System.Windows.LocalValueEntry> obiektu, który ma właściwości, które odwołują się konkretny <xref:System.Windows.DependencyProperty> i jego wartości. Ta technika wyliczać za pośrednictwem lokalnie ustawiony wartości może służyć do optymalizacji lub innych obsługi wartości lokalnych, takich jak do określenia wartości właściwości z <xref:System.Windows.DependencyObject> zmienią się, jeśli zostały one wyczyszczone.  
  
> [!IMPORTANT]
>  Zwrócony <xref:System.Windows.LocalValueEnumerator> może zawierać <xref:System.Windows.LocalValueEntry> rekordów dla właściwości zależności, które są przeznaczone tylko do odczytu lub właściwości zależności, których wartości są obliczane przez system właściwości. Na przykład element wizualny framework, który ma szerokość ustanowionym przy użyciu układu informację o wartości lokalnej dla <xref:System.Windows.FrameworkElement.ActualWidth%2A>. Jeśli otrzymujesz wartości lokalne, aby można było je zresetować, sprawdź <xref:System.Windows.DependencyProperty.ReadOnly%2A> wartości na identyfikator właściwości każdego <xref:System.Windows.LocalValueEntry> do sprawdzenia, czy <xref:System.Windows.DependencyProperty> danego nie jest tylko do odczytu.  
  
   
  
## Examples  
 Poniższy przykład wykonuje iterację wszystkich właściwości, które mają wartości lokalnych ustawiona na obiekt, następnie wywołuje <xref:System.Windows.DependencyObject.ClearValue%2A> aby wyczyścić wartości w każdej z tych właściwości.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LocalValueEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.GetValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp"><see cref="T:System.Windows.DependencyProperty" /> Identyfikator właściwości, które można pobrać wartość.</param>
        <summary>Zwraca bieżącą wartość skutecznych właściwości zależności w tym wystąpieniu programu <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Zwraca bieżącą wartość skuteczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Skuteczność* jest wartością właściwości, które są zwracane przez system właściwości do dowolny obiekt wywołujący, który żąda wartość. Wartość efektywna jest wynikiem system właściwości o ocenie wszystkich możliwych danych wejściowych, które uczestniczą w pierwszeństwo wartość właściwości systemu. Obejmuje to wymuszenia i animacji. Aby uzyskać więcej informacji, zobacz [następstwo wartości właściwości](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Ta metoda zwróci nigdy nie <xref:System.Windows.DependencyProperty.UnsetValue>. <xref:System.Windows.DependencyProperty.UnsetValue> Jest wartością wartownik systemu właściwości, który jest używany w różnych pojemnościach wewnętrznie i czasami również dostępna za pośrednictwem wywołania zwrotne wymuszenia.  
  
 Jeśli nie masz pewności, jakie powinny być typu właściwości, można tworzyć zapytania identyfikatora właściwości zależności żądanego, aby ustalić, czy jest określony więcej <xref:System.Windows.DependencyProperty.PropertyType%2A> który zwracana wartość może zostać przekonwertowany na.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Określony <paramref name="dp" /> albo jego wartość jest nieprawidłowa lub określone <paramref name="dp" /> nie istnieje.</exception>
        <altmember cref="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateProperty">
      <MemberSignature Language="C#" Value="public void InvalidateProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateProperty (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.InvalidateProperty : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.InvalidateProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp"><see cref="T:System.Windows.DependencyProperty" /> Identyfikator właściwości do unieważnienia.</param>
        <summary>Ponownie oblicza efektywną wartość dla właściwości określonej zależności</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wywołujesz <xref:System.Windows.DependencyObject.InvalidateProperty%2A>, wszelkie skojarzone i jest stosowane <xref:System.Windows.CoerceValueCallback> lub <xref:System.Windows.PropertyChangedCallback> funkcje zarejestrowany dla tej właściwości zależności mogą być wywoływane.  
  
 Wywoływanie <xref:System.Windows.DependencyObject.InvalidateProperty%2A> dla właściwości, która ma ustawioną wartością lokalnego odniesie żadnego skutku, ponieważ lokalna wartość mają pierwszeństwo przed pozostałych danych wejściowych do systemu z właściwości, z wyjątkiem animacji. Jednak można wywoływać <xref:System.Windows.DependencyObject.ClearValue%2A>, następnie wywołać <xref:System.Windows.DependencyObject.InvalidateProperty%2A>. Aby uzyskać więcej informacji, zobacz [następstwo wartości właściwości](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Wywoływanie <xref:System.Windows.DependencyObject.InvalidateProperty%2A> nie dotyczy zawsze umożliwia obsługę wielu scenariuszy właściwość zależności. Jeśli właściwość zależności staje się unieważnione z powodu zmiany wartości we wszystkich składników, system właściwości unieważnia i ponownie automatycznie sprawdza właściwości zależności. Jednak nadal istnieją sytuacje, w odpowiednich gdzie <xref:System.Windows.DependencyObject.InvalidateProperty%2A> przydaje się. W szczególności można użyć <xref:System.Windows.DependencyObject.InvalidateProperty%2A> wewnątrz wartości coerce lub właściwości zmienione wywołania zwrotnego dla właściwości zależności różne. Można również użyć <xref:System.Windows.DependencyObject.InvalidateProperty%2A> Aby wymusić ponowną ocenę powiązania w odniesieniu do źródła danych, który nie jest w stanie implementacji zalecanej <xref:System.ComponentModel.INotifyPropertyChanged> mechanizm powiadomień (prawdopodobnie w przypadku używania klas danych nie mogą pochodzić z lub gdy dane są statycznego element członkowski).  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Windows.DependencyObject.InvalidateProperty%2A> we właściwości niestandardowej, zawsze, gdy właściwości, które są zaangażowane w obliczeniach unieważniany właściwość zmieniają się. Jest alternatywna metoda do wywołania <xref:System.Windows.DependencyObject.CoerceValue%2A> metody, ponieważ unieważnienia właściwości również wywoła wszelkie zarejestrowane <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/SDKSampleLibrary/class1.cs#invalidateproperty)]
 [!code-vb[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/sdksamplelibrary/class1.vb#invalidateproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.DependencyProperty.UnsetValue" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.DependencyObject.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to wystąpienie jest obecnie zapieczętowany (tylko do odczytu).</summary>
        <value><see langword="true" /> Jeśli to wystąpienie jest zapieczętowany; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość jest ustawiana wewnętrznie.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkElementFactory" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="dependencyObject.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzenia, który będzie zawierać identyfikator właściwości zależności, zainteresowań, metadane właściwości dla typu i starej i nowej wartości.</param>
        <summary>Wywoływane, gdy wartość dowolnej właściwości zależności, w tym <see cref="T:System.Windows.DependencyObject" /> został zaktualizowany. Zmieniona właściwość konkretnej zależności jest zgłaszany w danych zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest przeznaczona do ogólnie wykrywać zmiany poszczególne właściwości lub wykonywania invalidations właściwości na poszczególnych przypadków. <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> Zamiast tego jest przeznaczony do modyfikacji wzorca unieważniania ogólne, jeśli znane jest niektórych informacji o klasyfikacjach szerokiego właściwości. Na przykład zmiany w <xref:System.Windows.Freezable> może być zmian w typach wartości <xref:System.Windows.Freezable>, lub może nie zawierać właściwości podrzędne, której zmiany są w innych <xref:System.Windows.Freezable> odwołania. <xref:System.Windows.Freezable> Przesłoń implementację <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> używa wewnętrznych informacji do określenia, czy właściwości mają właściwości podrzędnych i udostępnia logikę odpowiednią klasę bazową dla obu przypadków.  
  
 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> potencjalnie jest wywoływana wiele razy w okresie istnienia obiektu. W związku z tym, można osiągnąć lepszą wydajność w przypadku systemu ogólne właściwości, jeśli zastąpić metadane z określonych właściwości, a następnie dołącz <xref:System.Windows.CoerceValueCallback> lub <xref:System.Windows.PropertyChangedCallback> funkcje dla poszczególnych właściwości. Jednak jeśli może użyć tej metody <xref:System.Windows.DependencyObject> obejmuje szereg istotnych właściwości zależności powiązanych wartości, lub jeśli zawiera logikę, takie jak zachowanie renderowania, który musi zostać uruchomiony ponownie dla kilku powiązanych przypadków invalidations właściwości.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Zawsze należy wywoływać implementację podstawową. Niewykonanie tej czynności to znacznie spowoduje wyłączenie całego [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] właściwości systemu, powodując niepoprawne wartości, należy podać.</para></block>
        <altmember cref="T:System.Windows.FrameworkElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadLocalValue">
      <MemberSignature Language="C#" Value="public object ReadLocalValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ReadLocalValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLocalValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ReadLocalValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ReadLocalValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.ReadLocalValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp"><see cref="T:System.Windows.DependencyProperty" /> Identyfikator właściwości, które można pobrać wartość.</param>
        <summary>Zwraca lokalną wartość właściwości zależności, jeśli taki istnieje.</summary>
        <returns>Zwraca wartość lokalnego lub zwraca wartość wartownik <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> Jeśli nie ma ustawionej wartości lokalnej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy używać <xref:System.Windows.DependencyObject.GetValue%2A> najbardziej typowych operacji "Pobierz" dla właściwości zależności. <xref:System.Windows.DependencyObject.ReadLocalValue%2A> nie zwraca efektywną wartość dla szerokiego zakresu okoliczności gdzie nie lokalnie ustawiono wartości.  
  
 Wartości, które są ustawiane przez style, kompozycje i szablony, wartość domyślna z metadanych lub przejęcie wartości właściwości nie są uwzględniane jako wartości lokalnych. Jednakże powiązania i inne wyrażenia są uznawane za wartości lokalnych po zostały ocenione.  
  
 Gdy jest ustawiona żadna wartość lokalnych, Metoda ta zwraca <xref:System.Windows.DependencyProperty.UnsetValue>.  
  
 Jeśli zwracana wartość jest inny niż <xref:System.Windows.DependencyProperty.UnsetValue>, możesz zbadać metadane właściwości żądanego zależności, aby ustalić, czy jest bardziej określonego typu, który zwracana wartość może zostać przekonwertowany na.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentValue">
      <MemberSignature Language="C#" Value="public void SetCurrentValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCurrentValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCurrentValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCurrentValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetCurrentValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetCurrentValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Identyfikator właściwości zależności, aby ustawić.</param>
        <param name="value">Nowa wartość lokalnego.</param>
        <summary>Ustawia wartość właściwości zależności bez wprowadzania zmian w jej wartość źródła.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana przez składnik, programowo określająca wartość jednego z własną właściwości bez konieczności wyłączania aplikacji użyj zadeklarowane właściwości. <xref:System.Windows.DependencyObject.SetCurrentValue%2A> Metoda zmienia wartość powiązania danych właściwości, ale istniejące wyzwalacze i style będą nadal działać.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę modyfikacji właściwości zależności tylko do odczytu lub właściwość w zapieczętowanym <see cref="T:System.Windows.DependencyObject" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> nie był niepoprawny typ zarejestrowany dla <paramref name="dp" /> właściwości.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia wartość lokalnych właściwości zależności.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Identyfikator właściwości zależności, aby ustawić.</param>
        <param name="value">Nowa wartość lokalnego.</param>
        <summary>Ustawia wartość lokalnych właściwości zależności, określony przez jego identyfikator właściwości zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli podany typ nie jest zgodny z typem, która jest zadeklarowana dla właściwości zależności, ponieważ pierwotnie został zarejestrowany, jest zgłaszany wyjątek. `value` Zawsze można dostarczać parametru jako odpowiedniego typu.  
  
 Potencjalnie wpływało warunków wyjątków <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> wywołania zwrotnego, która istnieje na identyfikator właściwości zależności z właściwością zależności. W przeciwnym razie wartość podana zakończonych niepowodzeniem ogólne warunki sprawdzania typów (na przykład, przekazując ciąg, gdy typ natywny jest podwójnej precyzji).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę modyfikacji właściwości zależności tylko do odczytu lub właściwość w zapieczętowanym <see cref="T:System.Windows.DependencyObject" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> nie był niepoprawny typ zarejestrowany dla <paramref name="dp" /> właściwości.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyPropertyKey key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyPropertyKey key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (key As DependencyPropertyKey, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyPropertyKey ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyPropertyKey * obj -&gt; unit" Usage="dependencyObject.SetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key"><see cref="T:System.Windows.DependencyPropertyKey" /> Identyfikator właściwości do ustawienia.</param>
        <param name="value">Nowa wartość lokalnego.</param>
        <summary>Ustawia lokalna wartość właściwości zależności tylko do odczytu, określony przez <see cref="T:System.Windows.DependencyPropertyKey" /> identyfikatora właściwości zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podpis ten jest zazwyczaj używana podczas ustawiania wartości dla właściwości zależności tylko do odczytu, które są definiowane przez użytkownika niestandardowych klas. Ogólnie rzecz biorąc <xref:System.Windows.DependencyObject.SetValue%2A> jest wywoływana tylko z typu, który zarejestrował tej właściwości zależności, która implementuje logika wewnętrzna, która zawiera określone wartości dla właściwości zależności. Aby uzyskać więcej informacji, zobacz [właściwości zależności tylko do odczytu](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
 Jeśli podany typ nie jest zgodny z typem, która jest zadeklarowana dla właściwości zależności, ponieważ pierwotnie został zarejestrowany, jest zgłaszany wyjątek. `value` Zawsze można dostarczać parametru jako odpowiedniego typu. Potencjalnie wpływało warunków wyjątków <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> wywołania zwrotnego, która istnieje na identyfikator właściwości zależności z właściwością zależności.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano właściwości zależności tylko do odczytu, wraz z `public static readonly` <xref:System.Windows.DependencyProperty> zapewniający niezbędne narażenia tylko do odczytu dla konsumentów właściwości i metody dostępu get dla [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] otoki.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeProperty">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeProperty (dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool&#xA;override this.ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool" Usage="dependencyObject.ShouldSerializeProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Identyfikator właściwości zależności, który powinien zostać Zserializowany.</param>
        <summary>Zwraca wartość wskazującą, czy procesy serializacji należy serializować wartość właściwości podana zależności.</summary>
        <returns><see langword="true" /> Jeśli właściwość zależności, która jest dostarczana należy serializować wartość; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca `true` we wszystkich przypadkach, w których właściwość zależności miał wartości lokalnej na <xref:System.Windows.DependencyObject>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Zastąpienia dla tej metody może obsługiwać właściwości zależności określone inaczej.</para></block>
      </Docs>
    </Member>
  </Members>
</Type>
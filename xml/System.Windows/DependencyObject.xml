<Type Name="DependencyObject" FullName="System.Windows.DependencyObject">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="93e067f8bf97d79f7e4525a57db08a4a8d5109c2" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30715631" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DependencyObject : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DependencyObject extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DependencyObject&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyObject : System::Windows::Threading::DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.ComponentModel.DependencyObjectProvider))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.NameScopeProperty("NameScope", typeof(System.Windows.NameScope))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje obiekt, który uczestniczy w systemie właściwości zależności.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyObject> Klasy umożliwia [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] właściwości usług systemowych na jej wielu klas pochodnych.  
  
 Podstawową funkcją systemu właściwość jest do obliczenia wartości właściwości oraz zapewnienie systemu powiadomień o wartości, które zostały zmienione. Jest inna klasa klucza, który uczestniczy w systemie właściwości <xref:System.Windows.DependencyProperty>. <xref:System.Windows.DependencyProperty> Umożliwia rejestrację właściwości zależności w systemie właściwości i zawiera identyfikator i informacje o każdej właściwości zależności, podczas gdy <xref:System.Windows.DependencyObject> jako klasa podstawowa umożliwia obiektów do użycia właściwości zależności.  
  
 <xref:System.Windows.DependencyObject> usługi i właściwości są następujące:  
  
-   Hosting obsługa właściwości zależności. Zarejestruj właściwości zależności przez wywołanie metody <xref:System.Windows.DependencyProperty.Register%2A> — metoda i przechowywanie wartości zwracanej przez metodę jako publiczne pola statycznego w klasie.  
  
-   Dołączona właściwość hosting pomocy technicznej. Zarejestruj dołączona właściwość przez wywołanie metody <xref:System.Windows.DependencyProperty.RegisterAttached%2A> — metoda i przechowywanie wartości zwracanej przez metodę jako publiczne statyczne pole tylko do odczytu w klasie. (Istnieją również wymagania dodatkowy element członkowski; należy pamiętać, że jest to [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] konkretnej implementacji w przypadku dołączonych właściwości. Aby uzyskać więcej informacji, zobacz [dołączony Przegląd właściwości](~/docs/framework/wpf/advanced/attached-properties-overview.md).) Twoje dołączonej właściwości można następnie ustawić na dowolnej klasy, która jest pochodną <xref:System.Windows.DependencyObject>.  
  
-   Get ustaw i wyczyść metody narzędziowe do wartości wszystkich właściwości zależności, które istnieją na <xref:System.Windows.DependencyObject>.  
  
-   Metadane, wymuszone wartość obsługi powiadomień zmiany właściwości i wywołania zwrotne zastąpienia dla właściwości zależności lub dołączone właściwości. Ponadto <xref:System.Windows.DependencyObject> klasy ułatwia na właściciela metadanych właściwości dla właściwości zależności.  
  
-   Wspólna klasa podstawowa dla klas pochodnych <xref:System.Windows.ContentElement>, <xref:System.Windows.Freezable>, lub <xref:System.Windows.Media.Visual>. (<xref:System.Windows.UIElement>, inny base element klasa, ma hierarchii klasy, która obejmuje <xref:System.Windows.Media.Visual>.)  
  
   
  
## Examples  
 Poniższy przykład pochodzi z <xref:System.Windows.DependencyObject> do utworzenia nowej klasy abstrakcyjnej. Klasa następnie rejestruje dołączona właściwość i zawiera elementy pomocy technicznej dla tej właściwości dołączone.  
  
 [!code-csharp[WPFAquariumSln#DOMain](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#domain)]
 [!code-vb[WPFAquariumSln#DOMain](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#domain)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependencyObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DependencyObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.DependencyObject" /> klasy.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ClearValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Czyści lokalnego wartości właściwości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Właściwości zależności, aby wyczyścić, identyfikowane przez <see cref="T:System.Windows.DependencyProperty" /> obiektu odwołania.</param>
        <summary>Czyści lokalnego wartości właściwości. Właściwość do wyczyszczenia jest określona przez <see cref="T:System.Windows.DependencyProperty" /> identyfikator.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyczyszczenie wartości właściwości przez wywołanie metody <xref:System.Windows.DependencyObject.ClearValue%2A> niekoniecznie daje właściwości zależności domyślną wartość, która została określona w metadanych właściwości zależności. Czyszczenie właściwości tylko wyraźnie czyści niezależnie od wartości lokalnej zostały zastosowane. Aby uzyskać więcej informacji, zobacz [pierwszeństwo wartość właściwości zależności](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
   
  
## Examples  
 Poniższy przykład wykonuje iterację wszystkich właściwości, które mają wartości ustawionej w obiekcie, następnie wywołuje <xref:System.Windows.DependencyObject.ClearValue%2A> można wyczyścić wartości każdej z tych właściwości.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba wywołania <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> w zapieczętowanym <see cref="T:System.Windows.DependencyObject" />.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="P:System.Windows.DependencyObject.IsSealed" />
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyPropertyKey ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz dla właściwości zależności do wyczyszczenia.</param>
        <summary>Usuwa lokalną wartość właściwości tylko do odczytu. Właściwość do wyczyszczenia jest określona przez <see cref="T:System.Windows.DependencyPropertyKey" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.DependencyPropertyKey> identyfikuje właściwość tylko do odczytu zależności dla operacji systemu właściwości. Klasy, które definiują właściwości tylko do odczytu zależności nie powinny ujawniać tego klucza publicznego. Klucz publicznie ujawnionych zapewni ścieżki kodu publicznego, który zanegowane znak tylko do odczytu właściwości, jeśli metod, takich jak <xref:System.Windows.DependencyObject.ClearValue%2A> lub <xref:System.Windows.DependencyObject.SetValue%2A> może zostać wywołana poza klasę lub odwołanie do klucza zestawu.  
  
 Wyczyszczenie wartości właściwości przez wywołanie metody <xref:System.Windows.DependencyObject.ClearValue%2A> niekoniecznie daje właściwości zależności domyślną wartość, która została określona w metadanych właściwości zależności. Wyczyszczenie wartości tylko w szczególności czyści niezależnie od wartości lokalnej zostały zastosowane. Aby uzyskać więcej informacji, zobacz [pierwszeństwo wartość właściwości zależności](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba wywołania <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> w zapieczętowanym <see cref="T:System.Windows.DependencyObject" />.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="T:System.Windows.DependencyPropertyKey" />
      </Docs>
    </Member>
    <Member MemberName="CoerceValue">
      <MemberSignature Language="C#" Value="public void CoerceValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CoerceValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CoerceValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CoerceValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Identyfikator właściwości zależności, aby wymusić.</param>
        <summary>Przekształca wynik dane wartości właściwości określonej zależności. Jest to osiągane przez wywoływanie żadnego <see cref="T:System.Windows.CoerceValueCallback" /> funkcja określony w metadanych właściwości dla właściwości zależności, ponieważ znajduje się na wywołujący <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oprócz jawnie wywoływany za pośrednictwem wywołania <xref:System.Windows.DependencyObject.CoerceValue%2A>, <xref:System.Windows.CoerceValueCallback> zależność właściwości jest również wywoływana wewnętrznie zawsze, gdy wartość właściwości zależności jest ponownie oceniane przez [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] właściwości systemu.  
  
 Gdy wywołanie <xref:System.Windows.DependencyObject.CoerceValue%2A> metody, możesz są ostatecznie wywoływania wywołania zwrotnego wartość coerce dla określonej właściwości. Zwykle wywoła <xref:System.Windows.DependencyObject.CoerceValue%2A> tylko, jeśli wiadomo, czy istnieje wartość coerce wywołania zwrotnego i znane kryteria koercja metodę wywołania zwrotnego.  
  
 Najbardziej typowym scenariuszem dla wywołania <xref:System.Windows.DependencyObject.CoerceValue%2A> jest w obrębie klasy obsługi lub właściwość zmiany wywołania zwrotne powiązanych właściwości, które wpływają na wartości w sposób zależnych. Aby uzyskać więcej informacji, zobacz [wywołania zwrotne właściwości zależności i sprawdzania poprawności](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Windows.DependencyObject.CoerceValue%2A> w <xref:System.Windows.PropertyChangedCallback> implementacji, które jest używane jako <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> dla właściwości zależności inny, na tej samej klasy. Jest to wspólnego wzorca wprowadzenia wartości true zależności między właściwości zależności.  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Określony <paramref name="dp" /> lub jego wartość były nieprawidłowe lub nie istnieją.</exception>
        <altmember cref="T:System.Windows.CoerceValueCallback" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DependencyObjectType">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObjectType DependencyObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObjectType DependencyObjectType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.DependencyObjectType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyObjectType As DependencyObjectType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObjectType ^ DependencyObjectType { System::Windows::DependencyObjectType ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObjectType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.DependencyObjectType" /> który opakowuje [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] typu tego wystąpienia.</summary>
        <value>A <see cref="T:System.Windows.DependencyObjectType" /> który opakowuje [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] typu tego wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest przydatna, jeśli obiekt jest zwracany z metody ma typ wartości zwracanej <xref:System.Windows.DependencyObject> i chcesz przeprowadzić właściwości określonych operacji w systemie go w zależności od jego typu. Na przykład jest bardziej wydajne, aby wywołać <xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29> przy użyciu <xref:System.Windows.DependencyObjectType> zamiast [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] typu. <xref:System.Windows.DependencyObjectType> Umożliwia szybsze wyszukiwanie.  
  
   
  
## Examples  
 W poniższym przykładzie pseudocode `MySubClass` oszacowano, że dodatkowe klasy pochodne mogą zmienić wartość domyślną `MyCustom` właściwości zależności. Klasa implementuje konstruktora domyślnego, które można określić rzeczywistego klasy pochodnej dzięki wykorzystaniu polimorfizm <xref:System.Windows.DependencyObjectType> wartość zawsze, gdy ten konstruktor jest używany jako instantiator klasy pochodnej.  
  
 `public DOClass() : base()`  
  
 `{`  
  
 `__customPropertyCache = (CustomDP)`  
  
 `CustomDPProperty.GetMetadata(DependencyObjectType).DefaultValue;`  
  
 `}`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
        <altmember cref="T:System.Windows.DependencyObjectType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override sealed bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <see cref="T:System.Windows.DependencyObject" /> Do porównania z bieżącym wystąpieniem.</param>
        <summary>Określa, czy podany <see cref="T:System.Windows.DependencyObject" /> jest odpowiednikiem bieżącego <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>
          <see langword="true" /> Jeśli dwa wystąpienia są takie same; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja jest tylko równości odwołań, a nie próbuje ocenić równości wartości zawartych w niej właściwości.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.DependencyObject" /> zastąpienia, a następnie uszczelnienia dwóch basic <see cref="T:System.Object" /> metody: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> i <see cref="M:System.Windows.DependencyObject.GetHashCode" />. Wywołanie zastąpienia <see cref="T:System.Object" /> implementacji, co powoduje zachowanie równość obiektu. Te zastąpienia zamierzonego ma na celu zapobieganie próby Definiowanie równości wartości dla klas pochodnych <see cref="T:System.Windows.DependencyObject" />. Wartość equalities dla <see cref="T:System.Windows.DependencyObject" /> nigdy nie będą dokładne z powodu możliwości zmiany wartości właściwości zapewniające z <see cref="T:System.Windows.DependencyObject" /> i jego właściwości zależności. Dotyczy to również podstawowe [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] funkcje, takie jak powiązania danych i [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] właściwości systemu.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override sealed int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość skrótu dla tego <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Całkowita 32-bitowa wartość skrótu.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.DependencyObject" /> zastąpienia, a następnie uszczelnienia dwa <see cref="T:System.Object" /> metody: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> i <see cref="M:System.Windows.DependencyObject.GetHashCode" />. Wywołanie zastąpienia <see cref="T:System.Object" /> implementacji, co powoduje zachowanie równość obiektu. Te zastąpienia zamierzonego ma na celu zapobieganie próby Definiowanie równości wartości dla klas pochodnych <see cref="T:System.Windows.DependencyObject" />. Wartość equalities dla <see cref="T:System.Windows.DependencyObject" /> nigdy nie będą dokładne z powodu możliwości zmiany wartości właściwości zapewniające z <see cref="T:System.Windows.DependencyObject" /> i jego właściwości zależności. Dotyczy to również podstawowe [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] funkcje, takie jak powiązania danych i [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] właściwości systemu.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetLocalValueEnumerator">
      <MemberSignature Language="C#" Value="public System.Windows.LocalValueEnumerator GetLocalValueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.LocalValueEnumerator GetLocalValueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLocalValueEnumerator () As LocalValueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::LocalValueEnumerator GetLocalValueEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LocalValueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy specjalne modułu wyliczającego określania właściwości zależności, które ustawiono lokalnie wartości na tym <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Moduł wyliczający specjalne wartości lokalnej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A *wartości lokalnej* jest dowolną wartością właściwości zależności, która została ustawiona przez <xref:System.Windows.DependencyObject.SetValue%2A>, w przeciwieństwie do innych aspektów dla właściwości.  
  
 <xref:System.Windows.LocalValueEnumerator> Można uzyskać przez wywołanie <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> może służyć do wyliczenia właściwości, które mają lokalnie ustaw wartość na <xref:System.Windows.DependencyObject> wystąpienia. Każdej z tych właściwości jest reprezentowany przez moduł wyliczający <xref:System.Windows.LocalValueEntry> obiektu, który ma właściwości, które odwołują się do konkretnych <xref:System.Windows.DependencyProperty> i jej wartości. Ta technika wyliczania za pośrednictwem lokalnie ustawiony wartości może służyć do optymalizacji lub innych obsługi wartości lokalnej, takich jak do określenia wartości właściwości z <xref:System.Windows.DependencyObject> zmieniłby, jeśli zostały one wyczyszczone.  
  
> [!IMPORTANT]
>  Zwrócona <xref:System.Windows.LocalValueEnumerator> może zawierać <xref:System.Windows.LocalValueEntry> rekordów dla właściwości zależności, które są tylko do odczytu lub właściwości zależności, których wartości są obliczane przez system właściwości. Na przykład element visual framework, który ma ustaloną szerokość za pośrednictwem układu będzie zgłaszać wartości lokalnej dla <xref:System.Windows.FrameworkElement.ActualWidth%2A>. Aby zresetować je w przypadku uzyskiwania wartości lokalnej, sprawdź <xref:System.Windows.DependencyProperty.ReadOnly%2A> wartości na podstawie identyfikatora właściwości każdego <xref:System.Windows.LocalValueEntry> do sprawdzenia, czy <xref:System.Windows.DependencyProperty> zagrożona nie jest tylko do odczytu.  
  
   
  
## Examples  
 Poniższy przykład wykonuje iterację wszystkich właściwości, które mają wartości ustawionej w obiekcie, następnie wywołuje <xref:System.Windows.DependencyObject.ClearValue%2A> można wyczyścić wartości każdej z tych właściwości.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LocalValueEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">
          <see cref="T:System.Windows.DependencyProperty" /> Identyfikator można pobrać wartości właściwości.</param>
        <summary>Zwraca bieżącą wartość skuteczne właściwości zależności dla tego wystąpienia obiektu <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Zwraca bieżącą wartość skuteczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Wartość efektywna* jest wartością zwracaną przez system właściwości do każdego obiektu wywołującego, który żąda wartość właściwości. Wartość efektywna jest wynikiem systemu właściwość o ocenie wszystkich możliwych danych wejściowych uczestniczących w pierwszeństwo wartość właściwości systemu. Obejmuje to koercja i animacji. Aby uzyskać więcej informacji, zobacz [pierwszeństwo wartość właściwości zależności](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Ta metoda zwróci dane nigdy nie <xref:System.Windows.DependencyProperty.UnsetValue>. <xref:System.Windows.DependencyProperty.UnsetValue> Jest wartością wartownik systemu właściwości, który jest używany w różnych formach wewnętrznie i czasami również dostępne za pośrednictwem wywołania zwrotne wymuszenia.  
  
 Jeśli nie masz pewności, co powinna być typu właściwości, można zbadać identyfikatora właściwości zależności żądanych, aby ustalić, czy jest określony więcej <xref:System.Windows.DependencyProperty.PropertyType%2A> której można przekonwertować wartości zwracanej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Określony <paramref name="dp" /> lub jego wartość jest nieprawidłowy lub określony <paramref name="dp" /> nie istnieje.</exception>
        <altmember cref="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateProperty">
      <MemberSignature Language="C#" Value="public void InvalidateProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateProperty (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">
          <see cref="T:System.Windows.DependencyProperty" /> Identyfikator właściwości unieważnić.</param>
        <summary>Ponownie oblicza wartość efektywna dla właściwości zależności określony</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas wywoływania <xref:System.Windows.DependencyObject.InvalidateProperty%2A>, wszystkie skojarzone i stosowane <xref:System.Windows.CoerceValueCallback> lub <xref:System.Windows.PropertyChangedCallback> funkcje zarejestrowany dla tej właściwości zależności mogą wywołać.  
  
 Wywoływanie <xref:System.Windows.DependencyObject.InvalidateProperty%2A> dla właściwości, która ma lokalnego wartością ustawioną nie odniesie żadnego skutku, ponieważ wartość lokalnego mają pierwszeństwo przed innych danych wejściowych do systemu z właściwości, z wyjątkiem animacji. Jednak można wywołać <xref:System.Windows.DependencyObject.ClearValue%2A>, następnie wywołaj <xref:System.Windows.DependencyObject.InvalidateProperty%2A>. Aby uzyskać więcej informacji, zobacz [pierwszeństwo wartość właściwości zależności](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Wywoływanie <xref:System.Windows.DependencyObject.InvalidateProperty%2A> nie mieć zastosowania w różnych scenariuszach właściwości zależności. Jeśli właściwość zależności staje się unieważnionych z powodu zmiany wartości w jednym ze składników, system właściwości unieważnia i ponownie automatycznie sprawdza właściwości zależności. Jednak nadal istnieją odpowiednie sytuacje, gdy <xref:System.Windows.DependencyObject.InvalidateProperty%2A> przydaje się. W szczególności można użyć <xref:System.Windows.DependencyObject.InvalidateProperty%2A> wewnątrz wartości coerce lub właściwości zmienić wywołania zwrotnego dla właściwości zależności inny. Można również użyć <xref:System.Windows.DependencyObject.InvalidateProperty%2A> Aby wymusić ponowną ocenę powiązanie względem źródła danych, który nie jest w stanie do zaimplementowania zalecanej <xref:System.ComponentModel.INotifyPropertyChanged> mechanizm powiadomień (możliwe, że jeśli korzystanie z klas danych, która nie może dziedziczyć po lub gdy dane są statycznego element członkowski).  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Windows.DependencyObject.InvalidateProperty%2A> we właściwości niestandardowej, gdy właściwości, które są zaangażowane w obliczeniach nieważne właściwości zmienić. Jest alternatywna metoda do wywołania <xref:System.Windows.DependencyObject.CoerceValue%2A> metody, ponieważ unieważnia właściwość również wywoła żadnych zarejestrowany <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/SDKSampleLibrary/class1.cs#invalidateproperty)]
 [!code-vb[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/sdksamplelibrary/class1.vb#invalidateproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.DependencyProperty.UnsetValue" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to wystąpienie jest obecnie zapieczętowany (tylko do odczytu).</summary>
        <value>
          <see langword="true" /> Jeśli to wystąpienie jest zapieczętowany; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość jest ustawiana wewnętrznie.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkElementFactory" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzenia, który będzie zawierać identyfikator właściwości zależności zainteresowań, metadane właściwości dla typu i starej i nowej wartości.</param>
        <summary>Wywoływane, gdy wartość efektywna dowolnej właściwości zależności na tym <see cref="T:System.Windows.DependencyObject" /> została zaktualizowana. Właściwości określonych zależności, które zmienić jest zgłaszana w danych zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma zazwyczaj wykrycia zmiany indywidualne właściwości lub wykonać invalidations właściwości na poszczególnych przypadków. <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> Zamiast tego jest przeznaczony dla modyfikacje wzorca unieważniania ogólne, jeśli znane jest niektórych informacji o klasyfikacjach szeroki właściwości. Na przykład zmiany w <xref:System.Windows.Freezable> może być zmiany w typach wartości <xref:System.Windows.Freezable>, lub może nie zawierać właściwości, której zmiany są w innych <xref:System.Windows.Freezable> odwołania. <xref:System.Windows.Freezable> Zastąpienia implementacja <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> używa wewnętrznego informacji do ustalenia, czy właściwości mają właściwości i udostępnia logikę odpowiedniej klasy podstawowej dla obu przypadkach.  
  
 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> potencjalnie jest wywołana wiele razy w okresie istnienia obiektu. W związku z tym można osiągnąć lepszą wydajność systemu ogólne właściwości, jeśli Zastępowanie metadanych określonych właściwości, a następnie dołącz <xref:System.Windows.CoerceValueCallback> lub <xref:System.Windows.PropertyChangedCallback> funkcje dla poszczególnych właściwości. Jednak czy użyć tej metody, jeśli <xref:System.Windows.DependencyObject> obejmuje znaczących właściwości zależności powiązanych wartości, lub jeśli zawiera logikę, takich jak zachowanie renderowania, który musi zostać uruchomiony ponownie dla kilku powiązanych przypadków invalidations właściwości.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zawsze wywoływać implementację podstawową. Błąd w tym celu znacznie spowoduje wyłączenie całą [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] właściwości systemu, powoduje należy podać niepoprawne wartości.</para>
        </block>
        <altmember cref="T:System.Windows.FrameworkElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadLocalValue">
      <MemberSignature Language="C#" Value="public object ReadLocalValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ReadLocalValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLocalValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ReadLocalValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">
          <see cref="T:System.Windows.DependencyProperty" /> Identyfikator można pobrać wartości właściwości.</param>
        <summary>Zwraca wartość lokalnego właściwości zależności, jeśli istnieje.</summary>
        <returns>Zwraca wartość lokalnego lub zwraca wartość wartownik <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> przypadku nie wartości lokalnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy używać <xref:System.Windows.DependencyObject.GetValue%2A> najbardziej typowych operacji "get" dla właściwości zależności. <xref:System.Windows.DependencyObject.ReadLocalValue%2A> Zwraca wartość efektywna dla różnych okolicznościach w której wartość nie lokalnie ustawiono.  
  
 Wartości, które są ustawiane przez style, kompozycje i szablony, wartością domyślną z metadanych lub dziedziczenie wartość właściwości nie są uważane można wartości lokalnej. Jednak powiązania i inne wyrażenia są uważane wartości lokalnego po zostały ocenione.  
  
 Jeśli ustawiono nie wartości lokalnej, ta metoda zwraca <xref:System.Windows.DependencyProperty.UnsetValue>.  
  
 Jeśli zwrócona wartość jest inny niż <xref:System.Windows.DependencyProperty.UnsetValue>, możesz zbadać metadane właściwości żądanego zależności, aby ustalić, czy jest więcej określonego typu, który można przekonwertować na wartość zwracaną.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentValue">
      <MemberSignature Language="C#" Value="public void SetCurrentValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCurrentValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCurrentValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCurrentValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Identyfikator właściwości zależności do ustawienia.</param>
        <param name="value">Nowa wartość lokalnego.</param>
        <summary>Ustawia wartości właściwości zależności nie zmieniając wartość źródła.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana przez składnik programowo ustawia wartości jednego z jego własnej właściwości bez konieczności wyłączania aplikacji użyj zadeklarowane właściwości. <xref:System.Windows.DependencyObject.SetCurrentValue%2A> Metoda zmienia wartość powiązania danych właściwości, ale istniejące wyzwalacze i style będą nadal działać.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę modyfikacji właściwości zależności tylko do odczytu lub właściwość w zapieczętowanym <see cref="T:System.Windows.DependencyObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> nie ma poprawnego typu jest zarejestrowany dla <paramref name="dp" /> właściwości.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia wartość lokalnego właściwości zależności.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Identyfikator właściwości zależności do ustawienia.</param>
        <param name="value">Nowa wartość lokalnego.</param>
        <summary>Ustawia wartość lokalnego właściwości zależności, określony przez jego identyfikatora właściwości zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli podany typ niezgodny z typem, który jest zadeklarowana dla właściwości zależności, ponieważ pierwotnie został zarejestrowany, jest zwracany wyjątek. `value` Zawsze należy podawać parametru jako odpowiedniego typu.  
  
 Potencjalnie wpływało warunków wyjątków <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> wywołania zwrotnego, która istnieje na podstawie identyfikatora właściwości zależności ustawiania właściwości zależności. W przeciwnym razie wartość podana może awarii ogólnych warunków Sprawdzanie typu (np. przekazywanie ciąg, gdy typ macierzysty jest o podwójnej precyzji).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę modyfikacji właściwości zależności tylko do odczytu lub właściwość w zapieczętowanym <see cref="T:System.Windows.DependencyObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> nie ma poprawnego typu jest zarejestrowany dla <paramref name="dp" /> właściwości.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyPropertyKey key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyPropertyKey key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (key As DependencyPropertyKey, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyPropertyKey ^ key, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">
          <see cref="T:System.Windows.DependencyPropertyKey" /> Identyfikator właściwości do ustawienia.</param>
        <param name="value">Nowa wartość lokalnego.</param>
        <summary>Ustawia wartość lokalnego właściwości zależności tylko do odczytu, określona przez <see cref="T:System.Windows.DependencyPropertyKey" /> identyfikatora właściwości zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta sygnatura jest zazwyczaj używana w przypadku ustawienia wartości dla właściwości tylko do odczytu zależności, które są zdefiniowane przez użytkownika klas niestandardowych. Ogólnie rzecz biorąc <xref:System.Windows.DependencyObject.SetValue%2A> jest wywoływane tylko z typ zarejestrowanych tej właściwości zależności, która implementuje wewnętrzny logiki, która zawiera wartości określone dla właściwości zależności. Aby uzyskać więcej informacji, zobacz [tylko do odczytu właściwości zależności](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
 Jeśli podany typ niezgodny z typem, który jest zadeklarowana dla właściwości zależności, ponieważ pierwotnie został zarejestrowany, jest zwracany wyjątek. `value` Zawsze należy podawać parametru jako odpowiedniego typu. Potencjalnie wpływało warunków wyjątków <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> wywołania zwrotnego, która istnieje na podstawie identyfikatora właściwości zależności ustawiania właściwości zależności.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano właściwość tylko do odczytu zależności, wraz z `public static readonly` <xref:System.Windows.DependencyProperty> zapewnia niezbędne uwidocznienia tylko do odczytu dla konsumentów właściwości i metody dostępu get dla [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] otoki.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeProperty">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeProperty (dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Identyfikator właściwości zależności, które powinny być serializowane.</param>
        <summary>Zwraca wartość wskazującą, czy procesy serializacji powinny serializacji wartości dla właściwości zależności podana.</summary>
        <returns>
          <see langword="true" /> Jeśli właściwość zależności, która jest dostarczana powinny być serializowane wartości; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca `true` we wszystkich przypadkach, w których właściwość zależności miał wartość lokalnego w <xref:System.Windows.DependencyObject>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zastąpienia dla tej metody może obsługiwać właściwości zależności określone inaczej.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>
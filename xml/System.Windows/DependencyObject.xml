<Type Name="DependencyObject" FullName="System.Windows.DependencyObject">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0900b79b76b6508ed950a519c524288ac0c6b191" /><Meta Name="ms.sourcegitcommit" Value="e7974886b08aa83a8fb461e8550f31a7d4331ee3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/23/2019" /><Meta Name="ms.locfileid" Value="68392294" /></Metadata><TypeSignature Language="C#" Value="public class DependencyObject : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DependencyObject extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DependencyObject&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyObject : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type DependencyObject = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.ComponentModel.DependencyObjectProvider))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.NameScopeProperty("NameScope", typeof(System.Windows.NameScope))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje obiekt, który uczestniczy w systemie właściwości zależności.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa umożliwia korzystanie [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] z usług systemu właściwości na wielu klasach pochodnych. <xref:System.Windows.DependencyObject>  
  
 Podstawową funkcją systemu właściwości jest obliczanie wartości właściwości i zapewnienie powiadomienia systemu o wartościach, które uległy zmianie. Inna Klasa klucza, która uczestniczy w systemie właściwości, <xref:System.Windows.DependencyProperty>to. <xref:System.Windows.DependencyProperty>Włącza rejestrację właściwości zależności w systemie właściwości i zawiera identyfikację i informacje o każdej właściwości zależności, natomiast <xref:System.Windows.DependencyObject> jako klasa bazowa umożliwia obiektom Używanie właściwości zależności.  
  
 <xref:System.Windows.DependencyObject>dostępne są następujące usługi i cechy:  
  
-   Obsługa hostingu właściwości zależności. Należy zarejestrować właściwość zależności przez wywołanie <xref:System.Windows.DependencyProperty.Register%2A> metody i przechowywanie wartości zwracanej metody jako publicznego pola statycznego w klasie.  
  
-   Obsługa hostingu właściwości dołączonej. Zarejestrowano dołączoną Właściwość przez wywołanie <xref:System.Windows.DependencyProperty.RegisterAttached%2A> metody i przechowywanie wartości zwracanej metody jako publicznego statycznego pola tylko do odczytu w klasie. (Istnieją także dodatkowe wymagania dotyczące elementu członkowskiego; należy zauważyć, [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] że reprezentuje to konkretną implementację załączonych właściwości. Aby uzyskać szczegółowe informacje, zobacz [Omówienie załączonych właściwości](~/docs/framework/wpf/advanced/attached-properties-overview.md).) Dołączoną Właściwość można następnie ustawić dla każdej klasy, która pochodzi od <xref:System.Windows.DependencyObject>.  
  
-   Pobieranie, ustawianie i czyszczenie metod narzędzi dla wartości właściwości zależności, które istnieją w <xref:System.Windows.DependencyObject>.  
  
-   Metadane, przekształcenie obsługi wartości, powiadomienie o zmianie właściwości i przesłonięcie wywołania zwrotnego dla właściwości zależności lub załączonych właściwości. <xref:System.Windows.DependencyObject> Ponadto Klasa umożliwia obsługę metadanych właściwości dla właściciela dla właściwości zależności.  
  
-   Wspólna Klasa bazowa dla klas pochodnych <xref:System.Windows.ContentElement>, <xref:System.Windows.Freezable>, lub <xref:System.Windows.Media.Visual>. (<xref:System.Windows.UIElement>, inna Klasa elementu podstawowego ma hierarchię klas, która zawiera <xref:System.Windows.Media.Visual>).  
  
   
  
## Examples  
 Poniższy przykład pochodzi od <xref:System.Windows.DependencyObject> do utworzenia nowej klasy abstrakcyjnej. Klasa następnie rejestruje załączoną Właściwość i zawiera członków pomocy technicznej dla tej dołączonej właściwości.  
  
 [!code-csharp[WPFAquariumSln#DOMain](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#domain)]
 [!code-vb[WPFAquariumSln#DOMain](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#domain)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependencyObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DependencyObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.DependencyObject" /> klasy.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ClearValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Czyści wartość lokalną właściwości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.ClearValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Właściwość zależności, która ma zostać wyczyszczona, <see cref="T:System.Windows.DependencyProperty" /> identyfikowana przez odwołanie do obiektu.</param>
        <summary>Czyści wartość lokalną właściwości. Właściwość, która ma zostać wyczyszczona, <see cref="T:System.Windows.DependencyProperty" /> jest określana przez identyfikator.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyczyszczenie wartości właściwości przez wywołanie <xref:System.Windows.DependencyObject.ClearValue%2A> nie musi dawać właściwości zależności wartością domyślną określoną w metadanych właściwości zależności. Czyszczenie właściwości tylko wyraźnie czyści, niezależnie od tego, która wartość lokalna mogła zostać zastosowana. Aby uzyskać więcej informacji, zobacz [pierwszeństwo wartości właściwości zależności](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
   
  
## Examples  
 Poniższy przykład wykonuje iterację wszystkich właściwości, które mają wartości lokalne ustawione dla obiektu, a następnie <xref:System.Windows.DependencyObject.ClearValue%2A> wywołuje w celu wyczyszczenia wartości każdej takiej właściwości.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> wywołania zapieczętowanego <see cref="T:System.Windows.DependencyObject" />elementu.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="P:System.Windows.DependencyObject.IsSealed" />
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyObject.ClearValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz dla właściwości zależności, która ma zostać wyczyszczona.</param>
        <summary>Czyści wartość lokalną właściwości tylko do odczytu. Właściwość, która ma zostać wyczyszczona, <see cref="T:System.Windows.DependencyPropertyKey" />jest określana przez.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyPropertyKey> Identyfikuje właściwość zależności tylko do odczytu dla operacji systemu właściwości. Klasy definiujące właściwości zależności tylko do odczytu nie powinny ujawniać tego klucza z dostępem publicznym. Publicznie uwidoczniony klucz zapewnia publiczne ścieżki kodu, które negacją znaku tylko do odczytu właściwości, jeśli metody takie jak <xref:System.Windows.DependencyObject.ClearValue%2A> lub <xref:System.Windows.DependencyObject.SetValue%2A> mogą być wywoływane poza klasą lub zestawem, odwołujące się do klucza.  
  
 Wyczyszczenie wartości właściwości przez wywołanie <xref:System.Windows.DependencyObject.ClearValue%2A> nie musi dawać właściwości zależności wartością domyślną określoną w metadanych właściwości zależności. Czyszczenie wartości tylko wyraźnie czyści, niezależnie od tego, która wartość lokalna mogła zostać zastosowana. Aby uzyskać więcej informacji, zobacz [pierwszeństwo wartości właściwości zależności](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> wywołania zapieczętowanego <see cref="T:System.Windows.DependencyObject" />elementu.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="T:System.Windows.DependencyPropertyKey" />
      </Docs>
    </Member>
    <Member MemberName="CoerceValue">
      <MemberSignature Language="C#" Value="public void CoerceValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CoerceValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CoerceValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CoerceValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.CoerceValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.CoerceValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Identyfikator właściwości zależności, która ma zostać przekształcona.</param>
        <summary>Przekształca wartość określonej właściwości zależności. Jest to realizowane przez wywołanie dowolnej <see cref="T:System.Windows.CoerceValueCallback" /> funkcji określonej w metadanych właściwości dla właściwości zależności, która istnieje w wywołaniu. <see cref="T:System.Windows.DependencyObject" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oprócz jawnego wywołania metody <xref:System.Windows.DependencyObject.CoerceValue%2A> <xref:System.Windows.CoerceValueCallback> dla właściwości zależności jest również wywoływana wewnętrznie za każdym razem, gdy wartość właściwości zależności jest przeliczana przez [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] system właściwości.  
  
 Gdy wywołasz <xref:System.Windows.DependencyObject.CoerceValue%2A> metodę, ostatecznie wywołujesz wywołanie zwrotne wartości wymuszonej dla właściwości, którą określisz. Zwykle zostanie to wywołane <xref:System.Windows.DependencyObject.CoerceValue%2A> tylko wtedy, gdy wiesz, że istnieje wywołanie zwrotne wartości wymuszonej i jeśli znasz kryteria wywołania zwrotnego dla przekształcenia.  
  
 Najbardziej typowym scenariuszem wywoływania <xref:System.Windows.DependencyObject.CoerceValue%2A> jest w ramach obsługi klasy lub zmiany wartości wywołania zwrotnego powiązanych właściwości, które mają wpływ na wszystkie inne elementy w zależności od siebie. Aby uzyskać więcej informacji, zobacz [wywołania zwrotne właściwości zależności i walidacja](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Windows.DependencyObject.CoerceValue%2A> <xref:System.Windows.PropertyChangedCallback> w ramach implementacji <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> , która jest używana jako dla różnych właściwości zależności w tej samej klasie. Jest to typowy wzorzec służący do wprowadzania wartości rzeczywistych zależności między właściwościami zależności.  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Określony <paramref name="dp" /> lub jego wartość jest nieprawidłowa lub nie istnieje.</exception>
        <altmember cref="T:System.Windows.CoerceValueCallback" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DependencyObjectType">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObjectType DependencyObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObjectType DependencyObjectType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.DependencyObjectType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyObjectType As DependencyObjectType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObjectType ^ DependencyObjectType { System::Windows::DependencyObjectType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependencyObjectType : System.Windows.DependencyObjectType" Usage="System.Windows.DependencyObject.DependencyObjectType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObjectType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera, który zawija [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] typ tego wystąpienia. <see cref="T:System.Windows.DependencyObjectType" /></summary>
        <value>Obiekt <see cref="T:System.Windows.DependencyObjectType" /> , który zawija [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] typ tego wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest przydatna <xref:System.Windows.DependencyObject> , jeśli obiekt, który jest zwracany z metody, ma typ wartości zwracanej i chcesz wykonać na nim operacje specyficzne dla systemu właściwości, w zależności od jego typu. Na przykład bardziej wydajne jest wywoływanie <xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29> <xref:System.Windows.DependencyObjectType> przy użyciu elementu zamiast [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] typu. <xref:System.Windows.DependencyObjectType>ułatwia szybsze wyszukiwanie.  
  
   
  
## Examples  
 W poniższym przykładzie `MySubClass` pseudokodzie przewiduje, że dodatkowe klasy pochodne mogą zmienić wartość `MyCustom` domyślną właściwości zależności. Klasa implementuje Konstruktor bez parametrów, który może ustalić rzeczywistą klasę pochodną, wykorzystując w tym celu zalety polimorfizmu na <xref:System.Windows.DependencyObjectType> wartości za każdym razem, gdy Konstruktor jest używany jako Klasa pochodna.  
  
 `public DOClass() : base()`  
  
 `{`  
  
 `__customPropertyCache = (CustomDP)`  
  
 `CustomDPProperty.GetMetadata(DependencyObjectType).DefaultValue;`  
  
 `}`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
        <altmember cref="T:System.Windows.DependencyObjectType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override sealed bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="dependencyObject.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><see cref="T:System.Windows.DependencyObject" /> Do porównania z bieżącym wystąpieniem.</param>
        <summary>Określa, czy podana <see cref="T:System.Windows.DependencyObject" /> jest równoważna z bieżącym <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns><see langword="true" />Jeśli dwa wystąpienia są takie same; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja dotyczy tylko równości odwołań i nie próbuje oszacować równości wartości zawartych właściwości.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.DependencyObject" />zastępuje, a następnie wypisuje <see cref="T:System.Object" /> dwie podstawowe <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> metody <see cref="M:System.Windows.DependencyObject.GetHashCode" />: i. Przesłonięcia wywołują <see cref="T:System.Object" /> implementacje, co skutkuje zachowaniem równości obiektów. Celem tych zamierzonych zastąpień jest uniemożliwienie klasom pochodnym próby zdefiniowania równości wartości <see cref="T:System.Windows.DependencyObject" />dla. Wartości równe dla <see cref="T:System.Windows.DependencyObject" /> nigdy nie będą dokładne, ponieważ wartości właściwości innate zmieniają możliwości <see cref="T:System.Windows.DependencyObject" /> i właściwości zależności. Obejmuje to podstawowe [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] funkcje, takie jak powiązanie danych [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] i system właściwości.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override sealed int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyObject.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kod skrótu dla tego <see cref="T:System.Windows.DependencyObject" />elementu.</summary>
        <returns>Podpisany 32-bitowy kod skrótu liczby całkowitej.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.DependencyObject" />przesłania, a następnie plombuje dwie <see cref="T:System.Object" /> metody <see cref="M:System.Windows.DependencyObject.GetHashCode" />: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> i. Przesłonięcia wywołują <see cref="T:System.Object" /> implementacje, co skutkuje zachowaniem równości obiektów. Celem tych zamierzonych zastąpień jest uniemożliwienie klasom pochodnym próby zdefiniowania równości wartości <see cref="T:System.Windows.DependencyObject" />dla. Wartości równe dla <see cref="T:System.Windows.DependencyObject" /> nigdy nie będą dokładne, ponieważ wartości właściwości innate zmieniają możliwości <see cref="T:System.Windows.DependencyObject" /> i właściwości zależności. Obejmuje to podstawowe [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] funkcje, takie jak powiązanie danych [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] i system właściwości.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetLocalValueEnumerator">
      <MemberSignature Language="C#" Value="public System.Windows.LocalValueEnumerator GetLocalValueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.LocalValueEnumerator GetLocalValueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLocalValueEnumerator () As LocalValueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::LocalValueEnumerator GetLocalValueEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetLocalValueEnumerator : unit -&gt; System.Windows.LocalValueEnumerator" Usage="dependencyObject.GetLocalValueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LocalValueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy wyspecjalizowany moduł wyliczający służący do określania, które właściwości zależności mają <see cref="T:System.Windows.DependencyObject" />lokalnie ustawione wartości.</summary>
        <returns>Wyspecjalizowany moduł wyliczający wartość lokalną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Wartość lokalna* to jakakolwiek wartość właściwości zależności, która została ustawiona przez <xref:System.Windows.DependencyObject.SetValue%2A>, w przeciwieństwie do innych aspektów systemu właściwości.  
  
 Metodę uzyskana przez <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> wywołanie mogą służyć do wyliczania właściwości, które mają <xref:System.Windows.DependencyObject> lokalnie ustawioną wartość w wystąpieniu. <xref:System.Windows.LocalValueEnumerator> Każda taka właściwość jest reprezentowana w module wyliczającym <xref:System.Windows.LocalValueEntry> przez obiekt, który ma właściwości odwołujące <xref:System.Windows.DependencyProperty> się do określonych i jego wartości. Ta technika wyliczania za pośrednictwem wartości zestawu lokalnego może być używana do optymalizacji lub do innej obsługi wartości lokalnych, na przykład w celu określenia, które wartości <xref:System.Windows.DependencyObject> właściwości mogą ulec zmianie, jeśli zostały wyczyszczone.  
  
> [!IMPORTANT]
>  Zwrócone <xref:System.Windows.LocalValueEnumerator> mogą zawierać <xref:System.Windows.LocalValueEntry> rekordy właściwości zależności, które są tylko do odczytu lub właściwości zależności, gdzie wartości są obliczane przez system właściwości. Na przykład element Visual Framework, który ma ustaloną szerokość przez układ, będzie zgłaszać wartość lokalną dla <xref:System.Windows.FrameworkElement.ActualWidth%2A>. Jeśli otrzymujesz wartości lokalne, aby je zresetować, sprawdź <xref:System.Windows.DependencyProperty.ReadOnly%2A> wartość w każdym <xref:System.Windows.LocalValueEntry> identyfikatorze właściwości, aby sprawdzić, czy <xref:System.Windows.DependencyProperty> pytanie nie jest tylko do odczytu.  
  
   
  
## Examples  
 Poniższy przykład wykonuje iterację wszystkich właściwości, które mają wartości lokalne ustawione dla obiektu, a następnie <xref:System.Windows.DependencyObject.ClearValue%2A> wywołuje w celu wyczyszczenia wartości każdej takiej właściwości.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LocalValueEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.GetValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp"><see cref="T:System.Windows.DependencyProperty" /> Identyfikator właściwości, dla której ma zostać pobrana wartość.</param>
        <summary>Zwraca bieżącą obowiązującą wartość właściwości zależności w tym wystąpieniu <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Zwraca bieżącą wartość efektywną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Wartość efektywna* to wartość właściwości, która jest zwracana przez system właściwości do dowolnego obiektu wywołującego żądającego wartości. Wartość efektywna to wynik systemu właściwości, który ocenia wszystkie możliwe dane wejściowe, które uczestniczą w pierwszeństwie wartości systemu właściwości. Obejmuje to przekształcenia i animację. Aby uzyskać więcej informacji, zobacz [pierwszeństwo wartości właściwości zależności](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Ta metoda nigdy nie zwróci <xref:System.Windows.DependencyProperty.UnsetValue>. <xref:System.Windows.DependencyProperty.UnsetValue> Jest to wartość wskaźnikowa dla systemu właściwości, który jest używany w różnych możliwościach wewnętrznie, a jednocześnie narażony na wywołania zwrotne.  
  
 Jeśli nie masz pewności, jaka jest wartość typu właściwości, możesz wykonać zapytanie o identyfikator żądanej właściwości zależności, aby określić, czy jest bardziej szczegółowy <xref:System.Windows.DependencyProperty.PropertyType%2A> , aby można było przekonwertować wartość zwracaną na.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Określona <paramref name="dp" /> lub jej wartość jest nieprawidłowa lub określona <paramref name="dp" /> nie istnieje.</exception>
        <altmember cref="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateProperty">
      <MemberSignature Language="C#" Value="public void InvalidateProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateProperty (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.InvalidateProperty : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.InvalidateProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp"><see cref="T:System.Windows.DependencyProperty" /> Identyfikator właściwości do unieważnienia.</param>
        <summary>Ponowna ocenuje wartość efektywną dla określonej właściwości zależności</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku wywołania <xref:System.Windows.DependencyObject.InvalidateProperty%2A>, wszystkie skojarzone i mające <xref:System.Windows.PropertyChangedCallback> zastosowanie <xref:System.Windows.CoerceValueCallback> funkcje lub funkcję zarejestrowane dla danej właściwości zależności mogą być wywoływane.  
  
 Wywołanie <xref:System.Windows.DependencyObject.InvalidateProperty%2A> na właściwości, która ma jej lokalny zestaw wartości, nie będzie miało wpływu, ponieważ wartość lokalna ma pierwszeństwo przed innymi danymi wejściowymi systemu właściwości, z wyjątkiem animacji. Można jednak wywołać metodę <xref:System.Windows.DependencyObject.ClearValue%2A>, a następnie wywołać <xref:System.Windows.DependencyObject.InvalidateProperty%2A>polecenie. Aby uzyskać więcej informacji, zobacz [pierwszeństwo wartości właściwości zależności](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Wywołanie <xref:System.Windows.DependencyObject.InvalidateProperty%2A> nie musi być stosowane dla wielu scenariuszy właściwości zależności. Jeśli właściwość zależności zostanie unieważniona ze względu na zmiany wartości w którymkolwiek z elementów, system właściwości unieważnia i ponownie oblicza właściwość zależności automatycznie. Jednak nadal istnieją pewne odpowiednie scenariusze, w których <xref:System.Windows.DependencyObject.InvalidateProperty%2A> są użyteczne. W szczególności można użyć <xref:System.Windows.DependencyObject.InvalidateProperty%2A> wewnątrz wartości wymuszania lub zmiany właściwości wywołania zwrotnego dla innej właściwości zależności. Można również użyć <xref:System.Windows.DependencyObject.InvalidateProperty%2A> , aby wymusić ponowną ocenę powiązania ze źródłem danych, które nie jest w stanie zaimplementować zalecanego <xref:System.ComponentModel.INotifyPropertyChanged> mechanizmu powiadamiania (na przykład w przypadku używania klas danych, które nie mogą pochodzić z lub gdzie dane są statyczne członek).  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Windows.DependencyObject.InvalidateProperty%2A> właściwość niestandardową, zawsze, gdy właściwości, które są związane z niezweryfikowaną zmianą właściwości. Jest to alternatywna technika wywołująca <xref:System.Windows.DependencyObject.CoerceValue%2A> metodę, ponieważ unieważnienie właściwości spowoduje również wywołanie wszelkich zarejestrowanych. <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>  
  
 [!code-csharp[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/SDKSampleLibrary/class1.cs#invalidateproperty)]
 [!code-vb[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/sdksamplelibrary/class1.vb#invalidateproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.DependencyProperty.UnsetValue" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.DependencyObject.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to wystąpienie jest aktualnie zapieczętowane (tylko do odczytu).</summary>
        <value><see langword="true" />Jeśli to wystąpienie jest zapieczętowane; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość jest ustawiana wewnętrznie.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkElementFactory" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="dependencyObject.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzenia, które będą zawierać identyfikator właściwości zależności, metadane właściwości dla typu i stare i nowe wartości.</param>
        <summary>Wywoływana za każdym razem, gdy wartość skuteczna każdej właściwości <see cref="T:System.Windows.DependencyObject" /> zależności na tej stronie została zaktualizowana. Określona właściwość zależności, która została zmieniona, jest raportowana w danych zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest przeznaczona do ogólnego wykrywania poszczególnych zmian właściwości lub wykonywania nieprawidłowych właściwości dla poszczególnych przypadków. <xref:System.Windows.DependencyObject.OnPropertyChanged%2A>Zamiast tego jest przeznaczony do modyfikacji ogólnego wzorca unieważnienia, jeśli pewne informacje są znane o szerokich klasyfikacjach właściwości. Na przykład zmiany w programie <xref:System.Windows.Freezable> mogą być zmieniane w typach <xref:System.Windows.Freezable>wartości lub mogą być podwłaściwościami, gdzie zmiany znajdują się w innych <xref:System.Windows.Freezable> odwołaniach. Implementacja przesłonięcia <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> programu używa wewnętrznych informacji, aby określić, czy właściwości są podwłaściwościami, i zapewnia odpowiednią logikę klasy bazowej w obu przypadkach. <xref:System.Windows.Freezable>  
  
 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A>jest potencjalnie wywoływany wiele razy w okresie istnienia obiektu. W związku z tym można osiągnąć lepszą wydajność dla ogólnego systemu właściwości w przypadku zastąpienia metadanych określonych właściwości, a następnie <xref:System.Windows.CoerceValueCallback> dołączenia <xref:System.Windows.PropertyChangedCallback> lub funkcji dla poszczególnych właściwości. Należy jednak użyć tej metody, jeśli <xref:System.Windows.DependencyObject> zawiera znaczną liczbę właściwości zależności z wartościami, lub jeśli zawiera logikę, taką jak zachowanie renderowania, które należy uruchomić ponownie dla kilku powiązanych przypadków Unieważnień właściwości.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Zawsze Wywołaj implementację podstawową. Niewykonanie tej czynności spowoduje znacząco wyłączenie całego [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] systemu właściwości, co spowoduje zgłoszenie niepoprawnych wartości.</para></block>
        <altmember cref="T:System.Windows.FrameworkElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadLocalValue">
      <MemberSignature Language="C#" Value="public object ReadLocalValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ReadLocalValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLocalValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ReadLocalValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ReadLocalValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.ReadLocalValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp"><see cref="T:System.Windows.DependencyProperty" /> Identyfikator właściwości, dla której ma zostać pobrana wartość.</param>
        <summary>Zwraca wartość lokalną właściwości zależności, jeśli istnieje.</summary>
        <returns>Zwraca wartość lokalną lub zwraca wartość <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> wskaźnikową, jeśli nie ustawiono żadnej wartości lokalnej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy używać <xref:System.Windows.DependencyObject.GetValue%2A> dla większości typowych operacji "Get" dla właściwości zależności. <xref:System.Windows.DependencyObject.ReadLocalValue%2A>nie zwraca wartości efektywnej dla różnych przypadków, w których wartość nie została ustawiona lokalnie.  
  
 Wartości, które są ustawiane przez style, motywy, szablony, wartość domyślną z metadanych lub dziedziczenia wartości właściwości, nie są uznawane za wartości lokalne. Jednakże powiązania i inne wyrażenia są uznawane za wartości lokalne po ich ocenie.  
  
 Gdy wartość lokalna nie jest ustawiona, ta metoda zwraca <xref:System.Windows.DependencyProperty.UnsetValue>.  
  
 Jeśli zwracana wartość jest inna niż <xref:System.Windows.DependencyProperty.UnsetValue>, można wysłać zapytanie do metadanych żądanej właściwości zależności, aby określić, czy istnieje bardziej konkretny typ, do którego można przekonwertować wartość zwracaną.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentValue">
      <MemberSignature Language="C#" Value="public void SetCurrentValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCurrentValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCurrentValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCurrentValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetCurrentValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetCurrentValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="dp">Identyfikator właściwości zależności do ustawienia.</param>
        <param name="value">Nowa wartość lokalna.</param>
        <summary>Ustawia wartość właściwości zależności bez zmiany jego źródła wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana przez składnik, który programowo ustawia wartość jednej z własnych właściwości bez wyłączania użycia właściwości. <xref:System.Windows.DependencyObject.SetCurrentValue%2A> Metoda zmienia obowiązującą wartość właściwości, ale istniejące wyzwalacze, powiązania danych i style będą nadal działały.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę zmodyfikowania właściwości zależności tylko do odczytu lub właściwości zapieczętowanej <see cref="T:System.Windows.DependencyObject" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" />nie jest prawidłowym typem zarejestrowanym dla <paramref name="dp" /> właściwości.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia wartość lokalną właściwości zależności.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Identyfikator właściwości zależności do ustawienia.</param>
        <param name="value">Nowa wartość lokalna.</param>
        <summary>Ustawia wartość lokalną właściwości zależności, określoną za pomocą identyfikatora właściwości zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dostarczony typ nie jest zgodny z typem zadeklarowanym dla właściwości zależności, która została pierwotnie zarejestrowana, zgłaszany jest wyjątek. `value` Parametr powinien zawsze być określony jako odpowiedni typ.  
  
 Warunki wyjątku mogą mieć wpływ <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> na wywołanie zwrotne istniejące w identyfikatorze właściwości zależności ustawionej właściwości zależności. W przeciwnym razie podana wartość może kończyć się niepowodzeniem ogólnymi warunkami sprawdzania typu (na przykład przekazywaniem ciągu, gdy typ natywny jest podwójny).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę zmodyfikowania właściwości zależności tylko do odczytu lub właściwości zapieczętowanej <see cref="T:System.Windows.DependencyObject" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" />nie jest prawidłowym typem zarejestrowanym dla <paramref name="dp" /> właściwości.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyPropertyKey key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyPropertyKey key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (key As DependencyPropertyKey, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyPropertyKey ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyPropertyKey * obj -&gt; unit" Usage="dependencyObject.SetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key"><see cref="T:System.Windows.DependencyPropertyKey" /> Identyfikator właściwości do ustawienia.</param>
        <param name="value">Nowa wartość lokalna.</param>
        <summary>Ustawia wartość lokalną właściwości zależności tylko do odczytu, określoną przez <see cref="T:System.Windows.DependencyPropertyKey" /> identyfikator właściwości zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten podpis jest zazwyczaj używany podczas ustawiania wartości dla właściwości zależności tylko do odczytu, które są zdefiniowane przez klasy niestandardowe. Ogólnie rzecz biorąc jest wywoływana tylko z typu, który zarejestrował tę właściwość zależności, która implementuje wewnętrzną logikę, która dostarcza określoną wartość właściwości zależności. <xref:System.Windows.DependencyObject.SetValue%2A> Aby uzyskać więcej informacji, zobacz [właściwości zależności tylko do odczytu](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
 Jeśli dostarczony typ nie jest zgodny z typem zadeklarowanym dla właściwości zależności, która została pierwotnie zarejestrowana, zgłaszany jest wyjątek. `value` Parametr powinien zawsze być określony jako odpowiedni typ. Warunki wyjątku mogą mieć wpływ <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> na wywołanie zwrotne istniejące w identyfikatorze właściwości zależności ustawionej właściwości zależności.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano właściwość zależności tylko do odczytu wraz z `public static readonly` <xref:System.Windows.DependencyProperty> , która zapewnia niezbędny dostęp tylko do odczytu do odbiorców właściwości, i metodę dostępu dla [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] otoki.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeProperty">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeProperty (dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool&#xA;override this.ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool" Usage="dependencyObject.ShouldSerializeProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Identyfikator właściwości zależności, która powinna być serializowana.</param>
        <summary>Zwraca wartość wskazującą, czy procesy serializacji powinny serializować wartość dla podanej właściwości zależności.</summary>
        <returns><see langword="true" />Jeśli podana właściwość zależności powinna mieć wartość Serializacja wartości. w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca `true` wszystkie przypadki, w których właściwość dependency ma wartość <xref:System.Windows.DependencyObject>lokalną dla elementu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Zastąpienia tej metody mogą w różny sposób obsługiwać określone właściwości zależności.</para></block>
      </Docs>
    </Member>
  </Members>
</Type>
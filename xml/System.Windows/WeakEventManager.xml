<Type Name="WeakEventManager" FullName="System.Windows.WeakEventManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e7a44b791800ff544c7087f3aa44377d7008c985" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36455804" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WeakEventManager : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract WeakEventManager extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.WeakEventManager" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WeakEventManager&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class WeakEventManager abstract : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type WeakEventManager = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Udostępnia klasę podstawową dla menedżera zdarzeń, który jest używany w * słabe zdarzeń wzorca *. Menedżer dodaje i usuwa odbiorników zdarzeń (lub wywołań zwrotnych) korzystających ze wzorca.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wzorzec słabe zdarzeń jest zazwyczaj używana, gdy źródło zdarzenia ma okres istnienia obiektów, która jest niezależna od odbiorników zdarzeń. Za pomocą tego zdarzenia centralnej wysyłki możliwości <xref:System.Windows.WeakEventManager> umożliwia obsługi obiektu nasłuchującego być bezużytecznych nawet, jeśli obiekt źródłowy będzie się powtarzał. Z kolei podłączenie regularne zdarzeń przy użyciu `+=` operatora powoduje potencjalnie odłączonego źródła do przechowywania odwołanie do odbiorników. To zapobiega odbiornika bezużytecznych w odpowiednim czasie.  
  
 Jeden sytuacja wspólnej gdzie należy używać okresu istnienia relacji między źródłami i odbiorników wzorca słabe zdarzeń jest obsługi zdarzeń aktualizacji z powiązania danych.  
  
 Wzorzec słabe zdarzenia można również dla wywołań zwrotnych oraz zdarzeniami standardowymi.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Na przykład niestandardowy <see cref="T:System.Windows.WeakEventManager" />, zobacz [słabe Patterns](~/docs/framework/wpf/advanced/weak-event-patterns.md) zdarzeń.</para>
    </block>
    <altmember cref="T:System.Windows.IWeakEventListener" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WeakEventManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WeakEventManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje podstawowa Klasa wartości, gdy jest używany jako inicjator przez konstruktora klasy pochodnej.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeliverEvent">
      <MemberSignature Language="C#" Value="protected void DeliverEvent (object sender, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEvent(object sender, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEvent (sender As Object, args As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEvent(System::Object ^ sender, EventArgs ^ args);" />
      <MemberSignature Language="F#" Value="member this.DeliverEvent : obj * EventArgs -&gt; unit" Usage="weakEventManager.DeliverEvent (sender, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">Obiekt, w którym zdarzenie jest obsługiwane.</param>
        <param name="args">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzeń dla zdarzenia w celu dostarczenia.</param>
        <summary>Dostarcza zdarzenia zarządzany każdego odbiornika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Windows.WeakEventManager.DeliverEvent%2A> metodę z obsługi zdarzeń, które zostały dodane lub usunięte przez <xref:System.Windows.WeakEventManager.StartListening%2A> i <xref:System.Windows.WeakEventManager.StopListening%2A> implementacje podklasy.  
  
 Wywołanie <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> metody w Twojej `AddListener` implementacji klasy listy odbiorników odbierającego zdarzenie jest przechowywany w kolekcji źródłowej. (`AddListener` nie jest częścią kontrakt interfejsu lub klasy. `AddListener` sugerowana nazwa dla metody klasy Menedżera wywołująca jest <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> i dodaje detektory wzorzec słabe zdarzeń dla zdarzenia.)  
  
 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> dodaje do jednej listy. Jeśli wdrożenie Menedżera ma więcej niż jedną listę odbiorników na zdarzenie, nie używaj <xref:System.Windows.WeakEventManager.DeliverEvent%2A> lub <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>. Zamiast tego implementacji należy utworzyć własny <xref:System.Windows.WeakEventManager.ListenerList> wystąpień, `AddListener` należy dodać odbiorników na odpowiedniej liście i zdarzenia powinna zostać dostarczona do listy odpowiednie odbiornika przez wywołanie metody <xref:System.Windows.WeakEventManager.DeliverEventToList%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
      </Docs>
    </Member>
    <Member MemberName="DeliverEventToList">
      <MemberSignature Language="C#" Value="protected void DeliverEventToList (object sender, EventArgs args, System.Windows.WeakEventManager.ListenerList list);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEventToList(object sender, class System.EventArgs args, class System.Windows.WeakEventManager/ListenerList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEventToList (sender As Object, args As EventArgs, list As WeakEventManager.ListenerList)" />
      <MemberSignature Language="F#" Value="member this.DeliverEventToList : obj * EventArgs * System.Windows.WeakEventManager.ListenerList -&gt; unit" Usage="weakEventManager.DeliverEventToList (sender, args, list)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
        <Parameter Name="list" Type="System.Windows.WeakEventManager+ListenerList" />
      </Parameters>
      <Docs>
        <param name="sender">Obiekt, w którym zdarzenie jest obsługiwane.</param>
        <param name="args">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <param name="list">Podana <see cref="T:System.Windows.WeakEventManager.ListenerList" />.</param>
        <summary>Dostarcza zdarzenia zarządzany każdego odbiornika w podanej listy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest niezbędne, jeśli implementacji Menedżera zachowuje odbiorników osobnych list na podstawie informacji przechwyconych w danych zdarzenia. Możesz użyć tej metody zaawansowane, musisz utworzyć i obsługa osobnych list w ramach implementacji manager, a należy podać sposób dodawania odbiorników do określonej listy. Implementację programu obsługi nasłuchujący zdarzenia pierwotnych musi obsługiwanie warunek obsługi do odróżnienia list, a dostarczyć zdarzenie tylko do odpowiedniej liście lub list.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentManager">
      <MemberSignature Language="C#" Value="protected static System.Windows.WeakEventManager GetCurrentManager (Type managerType);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Windows.WeakEventManager GetCurrentManager(class System.Type managerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetCurrentManager (managerType As Type) As WeakEventManager" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Windows::WeakEventManager ^ GetCurrentManager(Type ^ managerType);" />
      <MemberSignature Language="F#" Value="static member GetCurrentManager : Type -&gt; System.Windows.WeakEventManager" Usage="System.Windows.WeakEventManager.GetCurrentManager managerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="managerType">Typ do uzyskania <see cref="T:System.Windows.WeakEventManager" /> dla.</param>
        <summary>Zwraca <see cref="T:System.Windows.WeakEventManager" /> implementację, która jest używana dla podanego typu.</summary>
        <returns>Dopasowanie <see cref="T:System.Windows.WeakEventManager" /> implementacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.IWeakEventListener.ReceiveWeakEvent%2A> implementacje wywołać tę metodę, przy użyciu ich przekazany `managerType`. Zwrócona <xref:System.Windows.WeakEventManager> służy jako różnicą, określająca otrzymano zdarzenie (event) i które obsługi Klasa prywatna do wywołania.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="protected object this[object source] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Protected Property Item(source As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ source); void set(System::Object ^ source, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Windows.WeakEventManager.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Liczony od zera indeks żądanego źródła.</param>
        <summary>Pobiera lub ustawia przechowywanych dla określonego źródła danych.</summary>
        <value>Przechowywanych przez menedżera dla tego źródła danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne mogą wybrać, jakie dane i typ do przechowywania w tym indeksatora. Zazwyczaj jest to implementowane jako <xref:System.Windows.WeakEventManager.ListenerList>, który znajduje się lista odwołania słabe do odbiorników. Czy wystarczy tylko zmienić tego typu, jeśli <xref:System.Windows.WeakEventManager.ListenerList> typu nie może zawierać wymaganych informacji. Jeśli tak, należy zastąpić <xref:System.Windows.WeakEventManager.Purge%2A> metody, aby wszystkie oczyszczania podstawowy typ odbywa się poprawnie.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="NewListenerList">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.WeakEventManager.ListenerList NewListenerList ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.WeakEventManager/ListenerList NewListenerList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.NewListenerList" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewListenerList () As WeakEventManager.ListenerList" />
      <MemberSignature Language="F#" Value="abstract member NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList&#xA;override this.NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList" Usage="weakEventManager.NewListenerList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager+ListenerList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca nowy obiekt, który zawiera odbiorników ze zdarzeniem.</summary>
        <returns>Nowy obiekt zawierający odbiorników ze zdarzeniem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedAddHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedAddHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Obiekt źródłowy, która ją subskrybuje delegata obsługi.</param>
        <param name="handler">Delegat, który obsługuje zdarzenia, które jest wywoływane przez <c>źródła</c>.</param>
        <summary>Dodaje określonego delegata jako program obsługi zdarzeń z określonego źródła.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddListener">
      <MemberSignature Language="C#" Value="protected void ProtectedAddListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedAddListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">Źródło do odbiorników do dołączenia.</param>
        <param name="listener">Klasa nasłuchiwania (który musi zaimplementować interfejs <see cref="T:System.Windows.IWeakEventListener" />).</param>
        <summary>Dodaje podany odbiornika do udostępnionego źródła zdarzeń zarządzany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody w klasie Menedżera `AddListener` metody <xref:System.Windows.WeakEventManager> implementacji. `AddListener` sugerowana nazwa jest dla metody statycznej zdefiniowanie w klasie manager, aby włączyć innych klas dodać odbiornika dla deseniu słabe zdarzeń. `AddListener` powinien mieć dwa parametry: `source` w przypadku, gdy odbiornika jest dołączony, a `listener` wystąpienia. Dla Twojego `AddListener` implementacji, wywołaj <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> metody na bieżący Menedżer i przebiegu tego samego dwa parametry.  
  
 Jeśli lista odbiorników było wcześniej puste, <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> wywołania <xref:System.Windows.WeakEventManager.StartListening%2A> — metoda, która wywoła konkretnej <xref:System.Windows.WeakEventManager.StartListening%2A> zastąpienia za pośrednictwem polimorfizm.  
  
 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> dodaje do pojedynczego wewnętrznego <xref:System.Windows.WeakEventManager.ListenerList> na `source`. Jeśli wdrożenie Menedżera ma więcej niż jedną listę odbiorników dla każdej kombinacji źródło zdarzenia, nie używaj <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>. Zamiast tego implementacji należy utworzyć własny <xref:System.Windows.WeakEventManager.ListenerList> wystąpień, `AddListener` należy dodać odbiorników na odpowiedniej liście i zdarzenia powinna zostać dostarczona do listy odpowiednie odbiornika wywołując <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> zdarzeń zamiast <xref:System.Windows.WeakEventManager.DeliverEvent%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedRemoveHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Źródło do usunięcia programu obsługi.</param>
        <param name="handler">Delegat do usunięcia z <c>źródła</c>.</param>
        <summary>Usuwa uprzednio dodanych obsługi pochodzących z określonego źródła.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveListener">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedRemoveListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">Aby usunąć odbiorników z źródło.</param>
        <param name="listener">Klasa nasłuchiwania (który musi zaimplementować interfejs <see cref="T:System.Windows.IWeakEventListener" />).</param>
        <summary>Usuwa odbiornik uprzednio dodanych z podanego źródła.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody w klasie Menedżera `RemoveListener` metody <xref:System.Windows.WeakEventManager> implementacji. `RemoveListener` sugerowana nazwa jest dla metody statycznej zdefiniowanie w klasie manager, aby włączyć innych klas usunąć odbiornik dla deseniu słabe zdarzeń. `RemoveListener` powinien mieć dwa parametry: `source` Jeśli odbiornik zostanie usunięty i `listener` klasy. Dla Twojego `RemoveListener` implementacji, wywołaj <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> metody na bieżący Menedżer i przebiegu tego samego dwa parametry.  
  
 Jeśli wywołanie <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> usuwa odbiornik ostatniego na liście <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> wywołania <xref:System.Windows.WeakEventManager.StopListening%2A> — metoda wewnętrznie, która wywoła konkretnej <xref:System.Windows.WeakEventManager.StopListening%2A> zastąpienia za pośrednictwem polimorfizm.  
  
 <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> Usuwa odbiorników jeden wewnętrzny <xref:System.Windows.WeakEventManager.ListenerList> na `source`. Jeśli wdrożenie Menedżera ma więcej niż jedną listę odbiorników dla każdej kombinacji źródło zdarzenia, nie używaj <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>. Zamiast tego implementacji należy utworzyć własny <xref:System.Windows.WeakEventManager.ListenerList> wystąpień, `RemoveListener` należy usunąć odbiorników z listy odpowiednią i zdarzenia powinna zostać dostarczona do listy odpowiednie odbiornika wywołując <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> zamiast metody <xref:System.Windows.WeakEventManager.DeliverEvent%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="protected virtual bool Purge (object source, object data, bool purgeAll);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool Purge(object source, object data, bool purgeAll) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Purge (source As Object, data As Object, purgeAll As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool Purge(System::Object ^ source, System::Object ^ data, bool purgeAll);" />
      <MemberSignature Language="F#" Value="abstract member Purge : obj * obj * bool -&gt; bool&#xA;override this.Purge : obj * obj * bool -&gt; bool" Usage="weakEventManager.Purge (source, data, purgeAll)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="purgeAll" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">Źródło zdarzenia prowadzi nasłuch do.</param>
        <param name="data">Dane do sprawdzenia. Ten obiekt powinien być <see cref="T:System.Windows.WeakEventManager.ListenerList" /> implementacji.</param>
        <param name="purgeAll">
          <see langword="true" /> Aby zatrzymać nasłuchiwanie <c>źródła</c>i całkowicie usunąć wszystkie wpisy z <c>danych</c>.</param>
        <summary>Usuwa nieaktywne odbiornika wpisy z listy danych dla podanego źródła. Zwraca <see langword="true" /> Jeśli niektóre wpisy rzeczywiście zostały usunięte z listy.</summary>
        <returns>
          <see langword="true" /> Jeśli niektóre wpisy rzeczywiście zostały usunięte; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.WeakEventManager.Purge%2A> Metoda ma domyślną implementację, która spowoduje usunięcie wszystkich wpisów, gdy dane są <xref:System.Windows.WeakEventManager.ListenerList>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Jeśli typ bazowy dla <see cref="P:System.Windows.WeakEventManager.Item(System.Object)" /> coś jest inny niż <see cref="T:System.Windows.WeakEventManager.ListenerList" />, lub zawiera dane poza <see cref="T:System.Windows.WeakEventManager.ListenerList" />, konieczne jest przesłonięcie <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> metody. Zastąpienie powinien zapewnić zachowanie przeczyszczania do listy elementów typu alternatywny. Ogólnie rzecz biorąc zastąpienie powinien zapewnić zachowanie bez wywoływania implementacji podstawowej. Jeśli określony <see cref="T:System.Windows.WeakEventManager.ListenerList" /> nadal wymaga czyszczenia, wywołania <see cref="M:System.Windows.WeakEventManager.ListenerList.Purge" />.</para>
        </block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="ReadLock">
      <MemberSignature Language="C#" Value="protected IDisposable ReadLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable ReadLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.ReadLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ReadLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ ReadLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadLock : IDisposable" Usage="System.Windows.WeakEventManager.ReadLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ustanawia blokady odczytu w tabeli podstawowej danych i zwraca <see cref="T:System.IDisposable" />.</summary>
        <value>Obiekt, który może służyć do ustanowienia blokady w elementach członkowskich tabeli danych, a następnie odpowiednio usunięta z <see langword="using" /> utworzenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W klasach pochodnych, wysyła zapytanie do tabeli zawartych w <xref:System.Windows.WeakEventManager.Item%2A> powinny być zawsze wykonywane w ramach `using (ReadLock) { ... }` klauzuli, z wyjątkiem zapytań, które znajdują się już na blokadę zapisu. Te zapytania może być konieczne, jeśli klasa obsługuje bardziej złożone `AddListener` implementację, która wymaga większej ilości danych poza `source` i `listener`i używa <xref:System.Windows.WeakEventManager.Item%2A> kolekcji do przechowywania dodatkowych informacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.WriteLock" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="protected void Remove (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Remove(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub Remove (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Remove(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="member this.Remove : obj -&gt; unit" Usage="weakEventManager.Remove source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Aby usunąć odbiornik informacje dotyczące źródło.</param>
        <summary>Usuwa wszystkie odbiorników dla określonego źródła.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ScheduleCleanup">
      <MemberSignature Language="C#" Value="protected void ScheduleCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ScheduleCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ScheduleCleanup" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ScheduleCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ScheduleCleanup();" />
      <MemberSignature Language="F#" Value="member this.ScheduleCleanup : unit -&gt; unit" Usage="weakEventManager.ScheduleCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wykonanie usuwanie nieużywanych wpisów na liście podstawowej odbiornika na niższy priorytet wątku żądania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Windows.WeakEventManager.ScheduleCleanup%2A> metoda jest podobna do wywoływania <xref:System.Windows.WeakEventManager.Purge%2A> metody na liście bieżący Menedżer, niższym priorytetem wątku, z `purgeAll` ustawiono parametr `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentManager">
      <MemberSignature Language="C#" Value="protected static void SetCurrentManager (Type managerType, System.Windows.WeakEventManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig void SetCurrentManager(class System.Type managerType, class System.Windows.WeakEventManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Sub SetCurrentManager (managerType As Type, manager As WeakEventManager)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static void SetCurrentManager(Type ^ managerType, System::Windows::WeakEventManager ^ manager);" />
      <MemberSignature Language="F#" Value="static member SetCurrentManager : Type * System.Windows.WeakEventManager -&gt; unit" Usage="System.Windows.WeakEventManager.SetCurrentManager (managerType, manager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
        <Parameter Name="manager" Type="System.Windows.WeakEventManager" />
      </Parameters>
      <Docs>
        <param name="managerType">Typ do nowego menedżera zdarzeń.</param>
        <param name="manager">Nowy Menedżer zdarzeń.</param>
        <summary>Ustawia bieżący Menedżer Menedżera określonego typu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Windows.WeakEventManager.SetCurrentManager%2A> metody można zainicjować menedżera, jeśli jest wymagany przez wywołanie do Twojej `CurrentManager` właściwość <xref:System.Windows.WeakEventManager> implementacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StartListening">
      <MemberSignature Language="C#" Value="protected abstract void StartListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StartListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StartListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StartListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StartListening : obj -&gt; unit" Usage="weakEventManager.StartListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Źródło, aby rozpocząć nasłuchiwania na.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna nasłuchiwanie zdarzeń zarządzany. Po <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> najpierw wywoływana jest metoda, Menedżer powinien być w stanie wywołania metody <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> lub <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" /> zawsze, gdy odpowiednie zdarzenie z podanego źródła jest obsługiwane.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> zastąpienia należy dodać program obsługi do dostarczonego <paramref name="source" />. Program obsługi jest zadeklarowany przez Menedżera samej siebie. Obsługa klasy nie powinny być publiczne i powinna być wywoływana tylko w odpowiedzi na zdarzenie zarządzany. Obsługa klasy powinny wywoływać <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> metody lub <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" /> — metoda odpowiednio.</para>
        </block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StopListening">
      <MemberSignature Language="C#" Value="protected abstract void StopListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StopListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StopListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StopListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StopListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StopListening : obj -&gt; unit" Usage="weakEventManager.StopListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Źródło do zatrzymania nasłuchiwania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zatrzymuje nasłuchiwanie dla podanego źródła zdarzeń zarządzany.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.Windows.WeakEventManager.StopListening(System.Object)" /> implementacje należy usunąć program obsługi klasy dodawany przez <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> metody. Usuwanie odbiornik nie należy wyczyścić listy odbiornika. Zamiast tego należy tylko Odłącz obsługi klasy (być może tymczasowo). Inne metody są dostępne, takich jak czyszczenie całą listę <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> metody z <paramref name="purgeAll" /> ustawiono parametr <see langword="true" />.</para>
        </block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLock">
      <MemberSignature Language="C#" Value="protected IDisposable WriteLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable WriteLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.WriteLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property WriteLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ WriteLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteLock : IDisposable" Usage="System.Windows.WeakEventManager.WriteLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ustanawia blokady zapisu w tabeli podstawowej danych i zwraca <see cref="T:System.IDisposable" />.</summary>
        <value>Obiekt, który może służyć do ustanowienia blokady w elementach członkowskich tabeli danych, a następnie odpowiednio usunięta z <see langword="using" /> utworzenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W klasach pochodnych, wszystkie zmiany do tabeli podstawowej danych powinna wystąpić w ramach `using (WriteLock) { ... }` klauzuli. Poniższe zmiany, może być konieczne, jeśli klasa obsługuje bardziej złożone `AddListener` implementację, która wymaga większej ilości danych poza `source` i `listener`i używa <xref:System.Windows.WeakEventManager.Item%2A> kolekcji do przechowywania dodatkowych informacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.ReadLock" />
      </Docs>
    </Member>
  </Members>
</Type>
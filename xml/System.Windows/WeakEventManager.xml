<Type Name="WeakEventManager" FullName="System.Windows.WeakEventManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8241e2ff47b51e906cfa1cf3ca25aac03e6ca974" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/24/2018" />
    <Meta Name="ms.locfileid" Value="37489333" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WeakEventManager : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract WeakEventManager extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.WeakEventManager" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WeakEventManager&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class WeakEventManager abstract : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type WeakEventManager = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Udostępnia klasę bazową dla menedżera zdarzeń, który jest używany w *słaby wzorzec zdarzeń*. Menedżer dodaje i usuwa odbiorników zdarzeń (lub wywołania zwrotne), które również użyć wzorca.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Słaby wzorzec zdarzeń jest zazwyczaj używana, gdy źródło zdarzenia ma okres istnienia obiektu, który jest niezależny od detektorów zdarzeń. Za pomocą centralnej zdarzenia, które wysyła możliwości <xref:System.Windows.WeakEventManager> umożliwia obsługi odbiornika jako bezużyteczne, nawet jeśli obiekt źródłowy będzie się powtarzać. Z drugiej strony Obsługa zdarzeń regularnego przy użyciu `+=` operator powoduje, że potencjalnie odłączonego źródła do przechowywania odwołań do odbiorników. Zapobiega to odbiornika jako elementu bezużytecznego zebranych w odpowiednim czasie.  
  
 Jednej wspólnej sytuacja gdzie należy używać okresu istnienia relacje między źródłami a odbiorników słaby wzorzec zdarzeń jest obsługi zdarzeń aktualizacji pochodzące z powiązań danych.  
  
 Słaby wzorzec zdarzeń może również służyć do wywołania zwrotne oraz zdarzeniami standardowymi.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Na przykład niestandardowy <see cref="T:System.Windows.WeakEventManager" />, zobacz [słabe wzorce zdarzeń](~/docs/framework/wpf/advanced/weak-event-patterns.md).</para>
    </block>
    <altmember cref="T:System.Windows.IWeakEventListener" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WeakEventManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WeakEventManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje podstawowej klasy wartości, gdy jest używany jako inicjator przez konstruktora klasy pochodnej.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeliverEvent">
      <MemberSignature Language="C#" Value="protected void DeliverEvent (object sender, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEvent(object sender, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEvent (sender As Object, args As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEvent(System::Object ^ sender, EventArgs ^ args);" />
      <MemberSignature Language="F#" Value="member this.DeliverEvent : obj * EventArgs -&gt; unit" Usage="weakEventManager.DeliverEvent (sender, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">Obiekt, w którym zdarzenie jest obsługiwane.</param>
        <param name="args">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzeń dla zdarzenia w celu dostarczenia.</param>
        <summary>Zapewnia zdarzenia zarządzane w przypadku każdego odbiornika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Windows.WeakEventManager.DeliverEvent%2A> metodę z procedury obsługi zdarzeń, które są dodawane lub usuwane przez <xref:System.Windows.WeakEventManager.StartListening%2A> i <xref:System.Windows.WeakEventManager.StopListening%2A> implementacje podklasy.  
  
 Jeśli wywołasz <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> method in Class metoda swoje `AddListener` implementacji klasy listy obiektów nasłuchujących odbierającego zdarzenie jest przechowywany w kolekcji źródłowej. (`AddListener` nie jest częścią kontrakt interfejsu lub klasy. `AddListener` sugerowana nazwa metody klasy Menedżera wywołująca jest <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> i dodaje zdarzeń słabych wzorzec detektory zdarzenia.)  
  
 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> dodaje do jednej liście. Jeśli Twoja implementacja manager przechowuje więcej niż jednej listy obiektów nasłuchujących na zdarzenie, nie używaj <xref:System.Windows.WeakEventManager.DeliverEvent%2A> lub <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>. Zamiast tego wdrożenia należy utworzyć swój własny <xref:System.Windows.WeakEventManager.ListenerList> przypadkach `AddListener` należy dodawać odbiorników do odpowiedniej listy, a zdarzenia powinna zostać dostarczona do listy odpowiedniego odbiornika przez wywołanie metody <xref:System.Windows.WeakEventManager.DeliverEventToList%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
      </Docs>
    </Member>
    <Member MemberName="DeliverEventToList">
      <MemberSignature Language="C#" Value="protected void DeliverEventToList (object sender, EventArgs args, System.Windows.WeakEventManager.ListenerList list);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEventToList(object sender, class System.EventArgs args, class System.Windows.WeakEventManager/ListenerList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEventToList (sender As Object, args As EventArgs, list As WeakEventManager.ListenerList)" />
      <MemberSignature Language="F#" Value="member this.DeliverEventToList : obj * EventArgs * System.Windows.WeakEventManager.ListenerList -&gt; unit" Usage="weakEventManager.DeliverEventToList (sender, args, list)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEventToList(System::Object ^ sender, EventArgs ^ args, System::Windows::WeakEventManager::ListenerList ^ list);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
        <Parameter Name="list" Type="System.Windows.WeakEventManager+ListenerList" />
      </Parameters>
      <Docs>
        <param name="sender">Obiekt, w którym zdarzenie jest obsługiwane.</param>
        <param name="args">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <param name="list">Podany <see cref="T:System.Windows.WeakEventManager.ListenerList" />.</param>
        <summary>Zapewnia zdarzenia zarządzane w przypadku każdego odbiornika na podanej liście.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest niezbędna, jeśli Twoja implementacja menedżera zachowuje odbiorników osobnych list na podstawie informacji o są przechwytywane dane zdarzeń. Jeśli używasz tej zaawansowane techniki, należy utworzyć i utrzymywać osobnych list jako część Twojego wdrożenia menedżera i należy podać sposób, aby dodać odbiorników do określonej listy. Implementację programu obsługi, która nasłuchuje nieprzetworzone zdarzenia dorywczych pod warunkiem służy do rozróżnienia na listach i dostarczanie zdarzeń tylko do odpowiedniej listy lub list.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentManager">
      <MemberSignature Language="C#" Value="protected static System.Windows.WeakEventManager GetCurrentManager (Type managerType);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Windows.WeakEventManager GetCurrentManager(class System.Type managerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetCurrentManager (managerType As Type) As WeakEventManager" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Windows::WeakEventManager ^ GetCurrentManager(Type ^ managerType);" />
      <MemberSignature Language="F#" Value="static member GetCurrentManager : Type -&gt; System.Windows.WeakEventManager" Usage="System.Windows.WeakEventManager.GetCurrentManager managerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="managerType">Typ do uzyskania <see cref="T:System.Windows.WeakEventManager" /> dla.</param>
        <summary>Zwraca <see cref="T:System.Windows.WeakEventManager" /> implementację, która jest używana dla podanego typu.</summary>
        <returns>Dopasowanie <see cref="T:System.Windows.WeakEventManager" /> implementacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.IWeakEventListener.ReceiveWeakEvent%2A> implementacje wywołać tę metodę, przy użyciu ich przekazany `managerType`. Zwrócony <xref:System.Windows.WeakEventManager> służy jako informatyczne, określająca zdarzenia został odebrany i które obsługi klasy prywatny do wywołania.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="protected object this[object source] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Protected Property Item(source As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ source); void set(System::Object ^ source, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Windows.WeakEventManager.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Liczony od zera indeks żądanego źródła.</param>
        <summary>Pobiera lub ustawia przechowywanych dla określonego źródła danych.</summary>
        <value>Dane są przechowywane przez menedżera dla tego źródła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne mogą wybrać, jakie dane i typ do przechowywania w tym indeksatora. Zazwyczaj ten sposób jest implementowany jako <xref:System.Windows.WeakEventManager.ListenerList>, który znajduje się lista słabe odwołania do odbiorników. Tylko trzeba zmienić tego typu, jeśli <xref:System.Windows.WeakEventManager.ListenerList> typ nie może zawierać Twoje wymaganych informacji. Jeśli tak, trzeba będzie zastąpić <xref:System.Windows.WeakEventManager.Purge%2A> metody, aby wszystkie oczyszczania typu podstawowego jest wykonywane poprawnie.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="NewListenerList">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.WeakEventManager.ListenerList NewListenerList ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.WeakEventManager/ListenerList NewListenerList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.NewListenerList" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewListenerList () As WeakEventManager.ListenerList" />
      <MemberSignature Language="F#" Value="abstract member NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList&#xA;override this.NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList" Usage="weakEventManager.NewListenerList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager+ListenerList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca nowy obiekt, który zawiera detektory zdarzenia.</summary>
        <returns>Nowy obiekt ma zawierać detektory zdarzenia.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedAddHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedAddHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Obiekt źródłowy, która ją subskrybuje delegata obsługi.</param>
        <param name="handler">Delegat, który obsługuje zdarzenia, który jest wywoływany przez <c>źródła</c>.</param>
        <summary>Dodaje określonego delegata jako program obsługi zdarzeń z określonego źródła.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddListener">
      <MemberSignature Language="C#" Value="protected void ProtectedAddListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedAddListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">Źródło do odbiorników do dołączenia.</param>
        <param name="listener">Klasa nasłuchiwania (który musi zaimplementować interfejs <see cref="T:System.Windows.IWeakEventListener" />).</param>
        <summary>Dodaje podany odbiornika podane źródło zdarzenia zarządzany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody w klasie Menedżera `AddListener` metod <xref:System.Windows.WeakEventManager> implementacji. `AddListener` sugerowana nazwa metody statyczne, należy zdefiniować w swojej klasy manager, aby włączyć innych klas do dodania odbiornika dla Twojego słaby wzorzec zdarzeń. `AddListener` należy przyjmują dwa parametry: `source` w przypadku, gdy jest dołączony odbiornik i `listener` wystąpienia. Dla Twojej `AddListener` implementacji, wywołanie <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> metody w bieżącej manager i przekaż ten sam dwa parametry.  
  
 Jeśli wcześniej pustą listę detektorów <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> wywołania <xref:System.Windows.WeakEventManager.StartListening%2A> — metoda wewnętrznie, która będzie wywoływać konkretne <xref:System.Windows.WeakEventManager.StartListening%2A> zastąpić za pomocą polimorfizmu.  
  
 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> dodaje do pojedynczego wewnętrznego <xref:System.Windows.WeakEventManager.ListenerList> na `source`. Jeśli Twoja implementacja manager przechowuje więcej niż jednej listy obiektów nasłuchujących dla każdej kombinacji źródła zdarzeń, nie używaj <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>. Zamiast tego wdrożenia należy utworzyć swój własny <xref:System.Windows.WeakEventManager.ListenerList> przypadkach `AddListener` należy dodawać odbiorników do odpowiedniej listy, a zdarzenia powinna zostać dostarczona do listy odpowiedniego odbiornika przez wywołanie metody <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> zdarzeniu zamiast <xref:System.Windows.WeakEventManager.DeliverEvent%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedRemoveHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Aby usunąć programu obsługi z źródło.</param>
        <param name="handler">Delegat do usunięcia z <c>źródła</c>.</param>
        <summary>Usuwa uprzednio dodanych obsługi pochodzących z określonego źródła.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveListener">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedRemoveListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">Aby usunąć odbiorniki z źródło.</param>
        <param name="listener">Klasa nasłuchiwania (który musi zaimplementować interfejs <see cref="T:System.Windows.IWeakEventListener" />).</param>
        <summary>Usuwa odbiornik uprzednio dodanych z podane źródło.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody w klasie Menedżera `RemoveListener` metod <xref:System.Windows.WeakEventManager> implementacji. `RemoveListener` sugerowana nazwa metody statyczne, należy zdefiniować w swojej klasy manager, aby włączyć innych klas usunąć odbiornik dla Twojego słaby wzorzec zdarzeń. `RemoveListener` należy przyjmują dwa parametry: `source` Jeśli odbiornik zostanie usunięty, a `listener` klasy. Dla Twojej `RemoveListener` implementacji, wywołanie <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> metody w bieżącej manager i przekaż ten sam dwa parametry.  
  
 Jeśli wywołanie <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> usuwa ostatni odbiornik na liście <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> wywołania <xref:System.Windows.WeakEventManager.StopListening%2A> metoda wewnętrznie, która będzie wywoływać konkretne <xref:System.Windows.WeakEventManager.StopListening%2A> zastąpić za pomocą polimorfizmu.  
  
 <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> Usuwa odbiorniki z pojedynczej wewnętrznej <xref:System.Windows.WeakEventManager.ListenerList> na `source`. Jeśli Twoja implementacja manager przechowuje więcej niż jednej listy obiektów nasłuchujących dla każdej kombinacji źródła zdarzeń, nie używaj <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>. Zamiast tego wdrożenia należy utworzyć swój własny <xref:System.Windows.WeakEventManager.ListenerList> przypadkach `RemoveListener` należy usunąć odbiorniki z odpowiednią listę, a zdarzenia powinna zostać dostarczona do listy odpowiedniego odbiornika przez wywołanie metody <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> zamiast metody <xref:System.Windows.WeakEventManager.DeliverEvent%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="protected virtual bool Purge (object source, object data, bool purgeAll);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool Purge(object source, object data, bool purgeAll) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Purge (source As Object, data As Object, purgeAll As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool Purge(System::Object ^ source, System::Object ^ data, bool purgeAll);" />
      <MemberSignature Language="F#" Value="abstract member Purge : obj * obj * bool -&gt; bool&#xA;override this.Purge : obj * obj * bool -&gt; bool" Usage="weakEventManager.Purge (source, data, purgeAll)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="purgeAll" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">Źródło zdarzenia jest wysłuchaliśmy.</param>
        <param name="data">Dane do sprawdzenia. Ten obiekt powinien być <see cref="T:System.Windows.WeakEventManager.ListenerList" /> implementacji.</param>
        <param name="purgeAll">
          <see langword="true" /> Aby zatrzymać nasłuchiwanie <c>źródła</c>i całkowicie usunąć wszystkie wpisy z <c>danych</c>.</param>
        <summary>Usuwa wpisy nieaktywne odbiornika z listy podane źródło danych. Zwraca <see langword="true" /> Jeśli niektóre wpisy rzeczywiście zostały usunięte z listy.</summary>
        <returns>
          <see langword="true" /> Jeśli niektóre wpisy rzeczywiście zostały usunięte; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.WeakEventManager.Purge%2A> Metoda ma domyślną implementację, która spowoduje usunięcie wszystkich wpisów, gdy dane znajdują się <xref:System.Windows.WeakEventManager.ListenerList>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Jeśli podstawowy typ dla <see cref="P:System.Windows.WeakEventManager.Item(System.Object)" /> jest coś innego niż <see cref="T:System.Windows.WeakEventManager.ListenerList" />, lub zawiera dane poza <see cref="T:System.Windows.WeakEventManager.ListenerList" />, konieczne jest przesłonięcie <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> metody. Zastąpienie powinny zapewnić zachowanie przeczyszczania alternatywny typ listy elementów. Ogólnie rzecz biorąc zastąpienie, powinien zapewnić zachowanie bez wywoływania implementację podstawową. Jeśli określony <see cref="T:System.Windows.WeakEventManager.ListenerList" /> nadal wymaga czyszczenia, wywołanie <see cref="M:System.Windows.WeakEventManager.ListenerList.Purge" />.</para>
        </block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="ReadLock">
      <MemberSignature Language="C#" Value="protected IDisposable ReadLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable ReadLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.ReadLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ReadLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ ReadLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadLock : IDisposable" Usage="System.Windows.WeakEventManager.ReadLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ustanawia blokadę odczytu na podstawowej tabeli danych, a następnie zwraca <see cref="T:System.IDisposable" />.</summary>
        <value>Obiekt, który może służyć do ustanowienia blokadę elementy członkowskie danych tabeli i następnie odpowiednio usunięte z <see langword="using" /> konstruowania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W klasach pochodnych, odpytuje do tabeli zawartej w <xref:System.Windows.WeakEventManager.Item%2A> powinny być zawsze wykonywane w ramach `using (ReadLock) { ... }` klauzuli, z wyjątkiem zapytania, które znajdują się już na blokadę zapisu. Te zapytania może być konieczne, jeśli klasa obsługuje bardziej zaawansowane `AddListener` implementację, która wymaga większej ilości danych poza `source` i `listener`i wykorzystuje <xref:System.Windows.WeakEventManager.Item%2A> kolekcji do przechowywania dodatkowych informacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.WriteLock" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="protected void Remove (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Remove(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub Remove (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Remove(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="member this.Remove : obj -&gt; unit" Usage="weakEventManager.Remove source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Aby usunąć odbiornik informacje dotyczące źródło.</param>
        <summary>Usuwa wszystkie odbiorników dla określonego źródła.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ScheduleCleanup">
      <MemberSignature Language="C#" Value="protected void ScheduleCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ScheduleCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ScheduleCleanup" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ScheduleCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ScheduleCleanup();" />
      <MemberSignature Language="F#" Value="member this.ScheduleCleanup : unit -&gt; unit" Usage="weakEventManager.ScheduleCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Żądania, czyszczenie nieużywanych wpisów na liście odbiornika podstawowej można wykonać na niższy priorytet wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Windows.WeakEventManager.ScheduleCleanup%2A> metoda jest podobna do wywoływania <xref:System.Windows.WeakEventManager.Purge%2A> metody na liście bieżącego Menedżera o niższym priorytecie wątku, przy użyciu `purgeAll` parametr `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentManager">
      <MemberSignature Language="C#" Value="protected static void SetCurrentManager (Type managerType, System.Windows.WeakEventManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig void SetCurrentManager(class System.Type managerType, class System.Windows.WeakEventManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Sub SetCurrentManager (managerType As Type, manager As WeakEventManager)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static void SetCurrentManager(Type ^ managerType, System::Windows::WeakEventManager ^ manager);" />
      <MemberSignature Language="F#" Value="static member SetCurrentManager : Type * System.Windows.WeakEventManager -&gt; unit" Usage="System.Windows.WeakEventManager.SetCurrentManager (managerType, manager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
        <Parameter Name="manager" Type="System.Windows.WeakEventManager" />
      </Parameters>
      <Docs>
        <param name="managerType">Typ, który można ustawić nowy Menedżer zdarzeń.</param>
        <param name="manager">Nowy Menedżer zdarzeń.</param>
        <summary>Ustawia bieżący menedżera dla typu określonego menedżera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Windows.WeakEventManager.SetCurrentManager%2A> metodę, aby zainicjować menedżera, czy jest wymagany przez wywołanie usługi `CurrentManager` właściwość <xref:System.Windows.WeakEventManager> implementacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StartListening">
      <MemberSignature Language="C#" Value="protected abstract void StartListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StartListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StartListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StartListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StartListening : obj -&gt; unit" Usage="weakEventManager.StartListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Źródło, aby rozpocząć nasłuchiwania na.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się zdarzenie zarządzane. Po <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> najpierw jest wywoływana metoda, Menedżer powinno być w stanie wywoływania <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> lub <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" /> zawsze, gdy odpowiednie zdarzenie z podanego źródła jest obsługiwane.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> zastąpienia należy dodać program obsługi podanego <paramref name="source" />. Program obsługi jest zadeklarowana przez menedżera SAM. Obsługa klasy nie powinny być publiczne, a powinna być wywoływana tylko w odpowiedzi na zdarzenie, które są zarządzane. Obsługa klasy powinny wywoływać <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> metody lub <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" /> metoda odpowiednio.</para>
        </block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StopListening">
      <MemberSignature Language="C#" Value="protected abstract void StopListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StopListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StopListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StopListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StopListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StopListening : obj -&gt; unit" Usage="weakEventManager.StopListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Źródło można zatrzymać nasłuchiwania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zatrzymuje nasłuchiwanie na podane źródło zdarzeń zarządzany.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.Windows.WeakEventManager.StopListening(System.Object)" /> implementacje należy usunąć program obsługi klasy, dodawany przez <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> metody. Usuwanie odbiornik nie należy wyczyścić listę odbiornika. Zamiast tego należy tylko Odłącz klasy programu obsługi (być może tymczasowo). Inne metody są dostępne dla takich jak czyszczenie całą listę <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> metody z <paramref name="purgeAll" /> parametr <see langword="true" />.</para>
        </block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLock">
      <MemberSignature Language="C#" Value="protected IDisposable WriteLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable WriteLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.WriteLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property WriteLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ WriteLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteLock : IDisposable" Usage="System.Windows.WeakEventManager.WriteLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ustanawia blokadę zapisu na podstawowej tabeli danych, a następnie zwraca <see cref="T:System.IDisposable" />.</summary>
        <value>Obiekt, który może służyć do ustanowienia blokadę elementy członkowskie danych tabeli i następnie odpowiednio usunięte z <see langword="using" /> konstruowania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W klasach pochodnych, wszystkie zmiany do podstawowej tabeli danych mogło nastąpić w ramach `using (WriteLock) { ... }` klauzuli. Te zmiany mogą być wymagane, jeśli klasa obsługuje bardziej zaawansowane `AddListener` implementację, która wymaga większej ilości danych poza `source` i `listener`i wykorzystuje <xref:System.Windows.WeakEventManager.Item%2A> kolekcji do przechowywania dodatkowych informacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.ReadLock" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="WeakEventManager" FullName="System.Windows.WeakEventManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e7a44b791800ff544c7087f3aa44377d7008c985" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36455804" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WeakEventManager : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract WeakEventManager extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.WeakEventManager" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WeakEventManager&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class WeakEventManager abstract : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type WeakEventManager = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="21bcf-101">Udostępnia klasę podstawową dla menedżera zdarzeń, który jest używany w * słabe zdarzeń wzorca *.</span>
      <span class="sxs-lookup">
        <span data-stu-id="21bcf-101">Provides a base class for the event manager that is used in the *weak event pattern*.</span>
      </span>
      <span data-ttu-id="21bcf-102">Menedżer dodaje i usuwa odbiorników zdarzeń (lub wywołań zwrotnych) korzystających ze wzorca.</span>
      <span class="sxs-lookup">
        <span data-stu-id="21bcf-102">The manager adds and removes listeners for events (or callbacks) that also use the pattern.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21bcf-103">Wzorzec słabe zdarzeń jest zazwyczaj używana, gdy źródło zdarzenia ma okres istnienia obiektów, która jest niezależna od odbiorników zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="21bcf-103">You typically use the weak event pattern when the event source has an object lifetime that is independent of the event listeners.</span></span> <span data-ttu-id="21bcf-104">Za pomocą tego zdarzenia centralnej wysyłki możliwości <xref:System.Windows.WeakEventManager> umożliwia obsługi obiektu nasłuchującego być bezużytecznych nawet, jeśli obiekt źródłowy będzie się powtarzał.</span><span class="sxs-lookup"><span data-stu-id="21bcf-104">Using the central event dispatching capability of a <xref:System.Windows.WeakEventManager> allows the listener's handlers to be garbage collected even if the source object persists.</span></span> <span data-ttu-id="21bcf-105">Z kolei podłączenie regularne zdarzeń przy użyciu `+=` operatora powoduje potencjalnie odłączonego źródła do przechowywania odwołanie do odbiorników.</span><span class="sxs-lookup"><span data-stu-id="21bcf-105">By contrast, a regular event hookup using the `+=` operator causes the potentially disconnected source to hold a reference to the listeners.</span></span> <span data-ttu-id="21bcf-106">To zapobiega odbiornika bezużytecznych w odpowiednim czasie.</span><span class="sxs-lookup"><span data-stu-id="21bcf-106">This prevents the receiver from being garbage collected in a timely fashion.</span></span>  
  
 <span data-ttu-id="21bcf-107">Jeden sytuacja wspólnej gdzie należy używać okresu istnienia relacji między źródłami i odbiorników wzorca słabe zdarzeń jest obsługi zdarzeń aktualizacji z powiązania danych.</span><span class="sxs-lookup"><span data-stu-id="21bcf-107">One common situation where the lifetime relationships between sources and listeners should use of the weak event pattern is the handling of update events coming from data bindings.</span></span>  
  
 <span data-ttu-id="21bcf-108">Wzorzec słabe zdarzenia można również dla wywołań zwrotnych oraz zdarzeniami standardowymi.</span><span class="sxs-lookup"><span data-stu-id="21bcf-108">The weak event pattern can also be used for callbacks and regular events.</span></span>  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <span data-ttu-id="21bcf-109">
        <para>Na przykład niestandardowy <see cref="T:System.Windows.WeakEventManager" />, zobacz [słabe Patterns](~/docs/framework/wpf/advanced/weak-event-patterns.md) zdarzeń.</para>
      </span>
      <span class="sxs-lookup">
        <span data-stu-id="21bcf-109">
          <para>For an example of a custom <see cref="T:System.Windows.WeakEventManager" />, see [Weak Event Patterns](~/docs/framework/wpf/advanced/weak-event-patterns.md).</para>
        </span>
      </span>
    </block>
    <altmember cref="T:System.Windows.IWeakEventListener" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WeakEventManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WeakEventManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="21bcf-110">Inicjuje podstawowa Klasa wartości, gdy jest używany jako inicjator przez konstruktora klasy pochodnej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-110">Initializes base class values when it is used as the initializer by the constructor of a derived class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeliverEvent">
      <MemberSignature Language="C#" Value="protected void DeliverEvent (object sender, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEvent(object sender, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEvent (sender As Object, args As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEvent(System::Object ^ sender, EventArgs ^ args);" />
      <MemberSignature Language="F#" Value="member this.DeliverEvent : obj * EventArgs -&gt; unit" Usage="weakEventManager.DeliverEvent (sender, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">
          <span data-ttu-id="21bcf-111">Obiekt, w którym zdarzenie jest obsługiwane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-111">The object on which the event is being handled.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="21bcf-112">
            <see cref="T:System.EventArgs" /> Zawierający dane zdarzeń dla zdarzenia w celu dostarczenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-112">An <see cref="T:System.EventArgs" /> that contains the event data for the event to deliver.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="21bcf-113">Dostarcza zdarzenia zarządzany każdego odbiornika.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-113">Delivers the event being managed to each listener.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21bcf-114">Wywołanie <xref:System.Windows.WeakEventManager.DeliverEvent%2A> metodę z obsługi zdarzeń, które zostały dodane lub usunięte przez <xref:System.Windows.WeakEventManager.StartListening%2A> i <xref:System.Windows.WeakEventManager.StopListening%2A> implementacje podklasy.</span><span class="sxs-lookup"><span data-stu-id="21bcf-114">Call the <xref:System.Windows.WeakEventManager.DeliverEvent%2A> method from within the event handlers that are added or removed by the <xref:System.Windows.WeakEventManager.StartListening%2A> and <xref:System.Windows.WeakEventManager.StopListening%2A> implementations of subclasses.</span></span>  
  
 <span data-ttu-id="21bcf-115">Wywołanie <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> metody w Twojej `AddListener` implementacji klasy listy odbiorników odbierającego zdarzenie jest przechowywany w kolekcji źródłowej.</span><span class="sxs-lookup"><span data-stu-id="21bcf-115">If you call the <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> method in your `AddListener` implementation of your class, the list of listeners receiving the event is kept in an underlying collection.</span></span> <span data-ttu-id="21bcf-116">(`AddListener` nie jest częścią kontrakt interfejsu lub klasy.</span><span class="sxs-lookup"><span data-stu-id="21bcf-116">(`AddListener` is not part of an interface or class contract.</span></span> <span data-ttu-id="21bcf-117">`AddListener` sugerowana nazwa dla metody klasy Menedżera wywołująca jest <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> i dodaje detektory wzorzec słabe zdarzeń dla zdarzenia.)</span><span class="sxs-lookup"><span data-stu-id="21bcf-117">`AddListener` is the suggested name for the method of your manager class that calls <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> and adds weak event pattern listeners for the event.)</span></span>  
  
 <span data-ttu-id="21bcf-118"><xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> dodaje do jednej listy.</span><span class="sxs-lookup"><span data-stu-id="21bcf-118"><xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> adds listeners to a single list.</span></span> <span data-ttu-id="21bcf-119">Jeśli wdrożenie Menedżera ma więcej niż jedną listę odbiorników na zdarzenie, nie używaj <xref:System.Windows.WeakEventManager.DeliverEvent%2A> lub <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>.</span><span class="sxs-lookup"><span data-stu-id="21bcf-119">If your manager implementation maintains more than one list of listeners per event, do not use <xref:System.Windows.WeakEventManager.DeliverEvent%2A> or <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>.</span></span> <span data-ttu-id="21bcf-120">Zamiast tego implementacji należy utworzyć własny <xref:System.Windows.WeakEventManager.ListenerList> wystąpień, `AddListener` należy dodać odbiorników na odpowiedniej liście i zdarzenia powinna zostać dostarczona do listy odpowiednie odbiornika przez wywołanie metody <xref:System.Windows.WeakEventManager.DeliverEventToList%2A>.</span><span class="sxs-lookup"><span data-stu-id="21bcf-120">Instead, your implementation should create its own <xref:System.Windows.WeakEventManager.ListenerList> instances, `AddListener` should add listeners to the appropriate list, and events should be delivered to the appropriate listener list by calling <xref:System.Windows.WeakEventManager.DeliverEventToList%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
      </Docs>
    </Member>
    <Member MemberName="DeliverEventToList">
      <MemberSignature Language="C#" Value="protected void DeliverEventToList (object sender, EventArgs args, System.Windows.WeakEventManager.ListenerList list);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEventToList(object sender, class System.EventArgs args, class System.Windows.WeakEventManager/ListenerList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEventToList (sender As Object, args As EventArgs, list As WeakEventManager.ListenerList)" />
      <MemberSignature Language="F#" Value="member this.DeliverEventToList : obj * EventArgs * System.Windows.WeakEventManager.ListenerList -&gt; unit" Usage="weakEventManager.DeliverEventToList (sender, args, list)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
        <Parameter Name="list" Type="System.Windows.WeakEventManager+ListenerList" />
      </Parameters>
      <Docs>
        <param name="sender">
          <span data-ttu-id="21bcf-121">Obiekt, w którym zdarzenie jest obsługiwane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-121">The object on which the event is being handled.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="21bcf-122">
            <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-122">An <see cref="T:System.EventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <param name="list">
          <span data-ttu-id="21bcf-123">Podana <see cref="T:System.Windows.WeakEventManager.ListenerList" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-123">The provided <see cref="T:System.Windows.WeakEventManager.ListenerList" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="21bcf-124">Dostarcza zdarzenia zarządzany każdego odbiornika w podanej listy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-124">Delivers the event being managed to each listener in the provided list.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21bcf-125">Ta metoda jest niezbędne, jeśli implementacji Menedżera zachowuje odbiorników osobnych list na podstawie informacji przechwyconych w danych zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="21bcf-125">This method is necessary if your manager implementation maintains separate listeners lists based on information that is captured in the event data.</span></span> <span data-ttu-id="21bcf-126">Możesz użyć tej metody zaawansowane, musisz utworzyć i obsługa osobnych list w ramach implementacji manager, a należy podać sposób dodawania odbiorników do określonej listy.</span><span class="sxs-lookup"><span data-stu-id="21bcf-126">If you use this advanced technique, you must create and maintain the separate lists as part of your manager implementation, and you must provide a way to add listeners to a specific list.</span></span> <span data-ttu-id="21bcf-127">Implementację programu obsługi nasłuchujący zdarzenia pierwotnych musi obsługiwanie warunek obsługi do odróżnienia list, a dostarczyć zdarzenie tylko do odpowiedniej liście lub list.</span><span class="sxs-lookup"><span data-stu-id="21bcf-127">Your handler implementation that listens to the raw event must act upon the condition that you use to differentiate the lists, and deliver the event only to the appropriate list or lists.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentManager">
      <MemberSignature Language="C#" Value="protected static System.Windows.WeakEventManager GetCurrentManager (Type managerType);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Windows.WeakEventManager GetCurrentManager(class System.Type managerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetCurrentManager (managerType As Type) As WeakEventManager" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Windows::WeakEventManager ^ GetCurrentManager(Type ^ managerType);" />
      <MemberSignature Language="F#" Value="static member GetCurrentManager : Type -&gt; System.Windows.WeakEventManager" Usage="System.Windows.WeakEventManager.GetCurrentManager managerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="managerType">
          <span data-ttu-id="21bcf-128">Typ do uzyskania <see cref="T:System.Windows.WeakEventManager" /> dla.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-128">The type to obtain the <see cref="T:System.Windows.WeakEventManager" /> for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="21bcf-129">Zwraca <see cref="T:System.Windows.WeakEventManager" /> implementację, która jest używana dla podanego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-129">Returns the <see cref="T:System.Windows.WeakEventManager" /> implementation that is used for the provided type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="21bcf-130">Dopasowanie <see cref="T:System.Windows.WeakEventManager" /> implementacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-130">The matching <see cref="T:System.Windows.WeakEventManager" /> implementation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21bcf-131"><xref:System.Windows.IWeakEventListener.ReceiveWeakEvent%2A> implementacje wywołać tę metodę, przy użyciu ich przekazany `managerType`.</span><span class="sxs-lookup"><span data-stu-id="21bcf-131"><xref:System.Windows.IWeakEventListener.ReceiveWeakEvent%2A> implementations call this method using their passed `managerType`.</span></span> <span data-ttu-id="21bcf-132">Zwrócona <xref:System.Windows.WeakEventManager> służy jako różnicą, określająca otrzymano zdarzenie (event) i które obsługi Klasa prywatna do wywołania.</span><span class="sxs-lookup"><span data-stu-id="21bcf-132">The returned <xref:System.Windows.WeakEventManager> is then used as the differentiator that determines which event was received, and which private class handler to invoke.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="protected object this[object source] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Protected Property Item(source As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ source); void set(System::Object ^ source, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Windows.WeakEventManager.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="21bcf-133">Liczony od zera indeks żądanego źródła.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-133">The zero-based index of the requested source.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="21bcf-134">Pobiera lub ustawia przechowywanych dla określonego źródła danych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-134">Gets or sets the data being stored for the specified source.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="21bcf-135">Przechowywanych przez menedżera dla tego źródła danych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-135">Data being stored by the manager for this source.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21bcf-136">Klasy pochodne mogą wybrać, jakie dane i typ do przechowywania w tym indeksatora.</span><span class="sxs-lookup"><span data-stu-id="21bcf-136">Derived classes can choose what data and type to store in this indexer.</span></span> <span data-ttu-id="21bcf-137">Zazwyczaj jest to implementowane jako <xref:System.Windows.WeakEventManager.ListenerList>, który znajduje się lista odwołania słabe do odbiorników.</span><span class="sxs-lookup"><span data-stu-id="21bcf-137">Typically this is implemented as a <xref:System.Windows.WeakEventManager.ListenerList>, which is a list of weak references to listeners.</span></span> <span data-ttu-id="21bcf-138">Czy wystarczy tylko zmienić tego typu, jeśli <xref:System.Windows.WeakEventManager.ListenerList> typu nie może zawierać wymaganych informacji.</span><span class="sxs-lookup"><span data-stu-id="21bcf-138">You would only have to change this type if the <xref:System.Windows.WeakEventManager.ListenerList> type cannot contain your required information.</span></span> <span data-ttu-id="21bcf-139">Jeśli tak, należy zastąpić <xref:System.Windows.WeakEventManager.Purge%2A> metody, aby wszystkie oczyszczania podstawowy typ odbywa się poprawnie.</span><span class="sxs-lookup"><span data-stu-id="21bcf-139">If so, you will have to override the <xref:System.Windows.WeakEventManager.Purge%2A> method so that all cleanup of the underlying type is performed correctly.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="NewListenerList">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.WeakEventManager.ListenerList NewListenerList ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.WeakEventManager/ListenerList NewListenerList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.NewListenerList" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewListenerList () As WeakEventManager.ListenerList" />
      <MemberSignature Language="F#" Value="abstract member NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList&#xA;override this.NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList" Usage="weakEventManager.NewListenerList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager+ListenerList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="21bcf-140">Zwraca nowy obiekt, który zawiera odbiorników ze zdarzeniem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-140">Returns a new object to contain listeners to an event.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="21bcf-141">Nowy obiekt zawierający odbiorników ze zdarzeniem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-141">A new object to contain listeners to an event.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedAddHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedAddHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="21bcf-142">Obiekt źródłowy, która ją subskrybuje delegata obsługi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-142">The source object that the handler delegate subscribes to.</span>
          </span>
        </param>
        <param name="handler">
          <span data-ttu-id="21bcf-143">Delegat, który obsługuje zdarzenia, które jest wywoływane przez <c>źródła</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-143">The delegate that handles the event that is raised by <c>source</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="21bcf-144">Dodaje określonego delegata jako program obsługi zdarzeń z określonego źródła.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-144">Adds the specified delegate as an event handler of the specified source.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddListener">
      <MemberSignature Language="C#" Value="protected void ProtectedAddListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedAddListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="21bcf-145">Źródło do odbiorników do dołączenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-145">The source to attach listeners to.</span>
          </span>
        </param>
        <param name="listener">
          <span data-ttu-id="21bcf-146">Klasa nasłuchiwania (który musi zaimplementować interfejs <see cref="T:System.Windows.IWeakEventListener" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-146">The listening class (which must implement <see cref="T:System.Windows.IWeakEventListener" />).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="21bcf-147">Dodaje podany odbiornika do udostępnionego źródła zdarzeń zarządzany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-147">Adds the provided listener to the provided source for the event being managed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21bcf-148">Wywołanie tej metody w klasie Menedżera `AddListener` metody <xref:System.Windows.WeakEventManager> implementacji.</span><span class="sxs-lookup"><span data-stu-id="21bcf-148">Call this method within your manager class `AddListener` methods on <xref:System.Windows.WeakEventManager> implementations.</span></span> <span data-ttu-id="21bcf-149">`AddListener` sugerowana nazwa jest dla metody statycznej zdefiniowanie w klasie manager, aby włączyć innych klas dodać odbiornika dla deseniu słabe zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="21bcf-149">`AddListener` is the suggested name for the static method you define on your manager class to enable other classes to add a listener for your weak event pattern.</span></span> <span data-ttu-id="21bcf-150">`AddListener` powinien mieć dwa parametry: `source` w przypadku, gdy odbiornika jest dołączony, a `listener` wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="21bcf-150">`AddListener` should take two parameters: the `source` where the listener is attached, and the `listener` instance.</span></span> <span data-ttu-id="21bcf-151">Dla Twojego `AddListener` implementacji, wywołaj <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> metody na bieżący Menedżer i przebiegu tego samego dwa parametry.</span><span class="sxs-lookup"><span data-stu-id="21bcf-151">For your `AddListener` implementation, call the <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> method on the current manager and pass the same two parameters.</span></span>  
  
 <span data-ttu-id="21bcf-152">Jeśli lista odbiorników było wcześniej puste, <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> wywołania <xref:System.Windows.WeakEventManager.StartListening%2A> — metoda, która wywoła konkretnej <xref:System.Windows.WeakEventManager.StartListening%2A> zastąpienia za pośrednictwem polimorfizm.</span><span class="sxs-lookup"><span data-stu-id="21bcf-152">If the list of listeners was previously empty, <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> calls the <xref:System.Windows.WeakEventManager.StartListening%2A> method internally, which will call your specific <xref:System.Windows.WeakEventManager.StartListening%2A> override through polymorphism.</span></span>  
  
 <span data-ttu-id="21bcf-153"><xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> dodaje do pojedynczego wewnętrznego <xref:System.Windows.WeakEventManager.ListenerList> na `source`.</span><span class="sxs-lookup"><span data-stu-id="21bcf-153"><xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> adds listeners to a single internal <xref:System.Windows.WeakEventManager.ListenerList> per `source`.</span></span> <span data-ttu-id="21bcf-154">Jeśli wdrożenie Menedżera ma więcej niż jedną listę odbiorników dla każdej kombinacji źródło zdarzenia, nie używaj <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>.</span><span class="sxs-lookup"><span data-stu-id="21bcf-154">If your manager implementation maintains more than one list of listeners for each event-source combination, do not use <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>.</span></span> <span data-ttu-id="21bcf-155">Zamiast tego implementacji należy utworzyć własny <xref:System.Windows.WeakEventManager.ListenerList> wystąpień, `AddListener` należy dodać odbiorników na odpowiedniej liście i zdarzenia powinna zostać dostarczona do listy odpowiednie odbiornika wywołując <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> zdarzeń zamiast <xref:System.Windows.WeakEventManager.DeliverEvent%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="21bcf-155">Instead, your implementation should create its own <xref:System.Windows.WeakEventManager.ListenerList> instances, `AddListener` should add listeners to the appropriate list, and events should be delivered to the appropriate listener list by calling the <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> event instead of the <xref:System.Windows.WeakEventManager.DeliverEvent%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedRemoveHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="21bcf-156">Źródło do usunięcia programu obsługi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-156">The source to remove the handler from.</span>
          </span>
        </param>
        <param name="handler">
          <span data-ttu-id="21bcf-157">Delegat do usunięcia z <c>źródła</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-157">The delegate to remove from <c>source</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="21bcf-158">Usuwa uprzednio dodanych obsługi pochodzących z określonego źródła.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-158">Removes the previously added handler from the specified source.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveListener">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedRemoveListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="21bcf-159">Aby usunąć odbiorników z źródło.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-159">The source to remove listeners from.</span>
          </span>
        </param>
        <param name="listener">
          <span data-ttu-id="21bcf-160">Klasa nasłuchiwania (który musi zaimplementować interfejs <see cref="T:System.Windows.IWeakEventListener" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-160">The listening class (which must implement <see cref="T:System.Windows.IWeakEventListener" />).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="21bcf-161">Usuwa odbiornik uprzednio dodanych z podanego źródła.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-161">Removes a previously added listener from the provided source.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21bcf-162">Wywołanie tej metody w klasie Menedżera `RemoveListener` metody <xref:System.Windows.WeakEventManager> implementacji.</span><span class="sxs-lookup"><span data-stu-id="21bcf-162">Call this method within your manager class `RemoveListener` methods on <xref:System.Windows.WeakEventManager> implementations.</span></span> <span data-ttu-id="21bcf-163">`RemoveListener` sugerowana nazwa jest dla metody statycznej zdefiniowanie w klasie manager, aby włączyć innych klas usunąć odbiornik dla deseniu słabe zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="21bcf-163">`RemoveListener` is the suggested name for the static method you define on your manager class to enable other classes to remove a listener for your weak event pattern.</span></span> <span data-ttu-id="21bcf-164">`RemoveListener` powinien mieć dwa parametry: `source` Jeśli odbiornik zostanie usunięty i `listener` klasy.</span><span class="sxs-lookup"><span data-stu-id="21bcf-164">`RemoveListener` should take two parameters: the `source` where the listener is removed, and the `listener` class.</span></span> <span data-ttu-id="21bcf-165">Dla Twojego `RemoveListener` implementacji, wywołaj <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> metody na bieżący Menedżer i przebiegu tego samego dwa parametry.</span><span class="sxs-lookup"><span data-stu-id="21bcf-165">For your `RemoveListener` implementation, call the <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> method on the current manager and pass the same two parameters.</span></span>  
  
 <span data-ttu-id="21bcf-166">Jeśli wywołanie <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> usuwa odbiornik ostatniego na liście <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> wywołania <xref:System.Windows.WeakEventManager.StopListening%2A> — metoda wewnętrznie, która wywoła konkretnej <xref:System.Windows.WeakEventManager.StopListening%2A> zastąpienia za pośrednictwem polimorfizm.</span><span class="sxs-lookup"><span data-stu-id="21bcf-166">If a call to <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> removes the last listener in the list, <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> calls the <xref:System.Windows.WeakEventManager.StopListening%2A> method internally, which will call your specific <xref:System.Windows.WeakEventManager.StopListening%2A> override through polymorphism.</span></span>  
  
 <span data-ttu-id="21bcf-167"><xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> Usuwa odbiorników jeden wewnętrzny <xref:System.Windows.WeakEventManager.ListenerList> na `source`.</span><span class="sxs-lookup"><span data-stu-id="21bcf-167"><xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> removes listeners from a single internal <xref:System.Windows.WeakEventManager.ListenerList> per `source`.</span></span> <span data-ttu-id="21bcf-168">Jeśli wdrożenie Menedżera ma więcej niż jedną listę odbiorników dla każdej kombinacji źródło zdarzenia, nie używaj <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>.</span><span class="sxs-lookup"><span data-stu-id="21bcf-168">If your manager implementation maintains more than one list of listeners for each event-source combination, do not use <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>.</span></span> <span data-ttu-id="21bcf-169">Zamiast tego implementacji należy utworzyć własny <xref:System.Windows.WeakEventManager.ListenerList> wystąpień, `RemoveListener` należy usunąć odbiorników z listy odpowiednią i zdarzenia powinna zostać dostarczona do listy odpowiednie odbiornika wywołując <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> zamiast metody <xref:System.Windows.WeakEventManager.DeliverEvent%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="21bcf-169">Instead, your implementation should create its own <xref:System.Windows.WeakEventManager.ListenerList> instances, `RemoveListener` should remove listeners from the appropriate list, and events should be delivered to the appropriate listener list by calling the <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> method instead of the <xref:System.Windows.WeakEventManager.DeliverEvent%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="protected virtual bool Purge (object source, object data, bool purgeAll);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool Purge(object source, object data, bool purgeAll) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Purge (source As Object, data As Object, purgeAll As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool Purge(System::Object ^ source, System::Object ^ data, bool purgeAll);" />
      <MemberSignature Language="F#" Value="abstract member Purge : obj * obj * bool -&gt; bool&#xA;override this.Purge : obj * obj * bool -&gt; bool" Usage="weakEventManager.Purge (source, data, purgeAll)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="purgeAll" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="21bcf-170">Źródło zdarzenia prowadzi nasłuch do.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-170">The source for events being listened to.</span>
          </span>
        </param>
        <param name="data">
          <span data-ttu-id="21bcf-171">Dane do sprawdzenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-171">The data to check.</span>
          </span>
          <span data-ttu-id="21bcf-172">Ten obiekt powinien być <see cref="T:System.Windows.WeakEventManager.ListenerList" /> implementacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-172">This object is expected to be a <see cref="T:System.Windows.WeakEventManager.ListenerList" /> implementation.</span>
          </span>
        </param>
        <param name="purgeAll">
          <span data-ttu-id="21bcf-173">
            <see langword="true" /> Aby zatrzymać nasłuchiwanie <c>źródła</c>i całkowicie usunąć wszystkie wpisy z <c>danych</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-173">
              <see langword="true" /> to stop listening to <c>source</c>, and completely remove all entries from <c>data</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="21bcf-174">Usuwa nieaktywne odbiornika wpisy z listy danych dla podanego źródła.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-174">Removes inactive listener entries from the data list for the provided source.</span>
          </span>
          <span data-ttu-id="21bcf-175">Zwraca <see langword="true" /> Jeśli niektóre wpisy rzeczywiście zostały usunięte z listy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-175">Returns <see langword="true" /> if some entries were actually removed from the list.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="21bcf-176">
            <see langword="true" /> Jeśli niektóre wpisy rzeczywiście zostały usunięte; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-176">
              <see langword="true" /> if some entries were actually removed; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21bcf-177"><xref:System.Windows.WeakEventManager.Purge%2A> Metoda ma domyślną implementację, która spowoduje usunięcie wszystkich wpisów, gdy dane są <xref:System.Windows.WeakEventManager.ListenerList>.</span><span class="sxs-lookup"><span data-stu-id="21bcf-177">The <xref:System.Windows.WeakEventManager.Purge%2A> method has a default implementation that will remove all entries when data is a <xref:System.Windows.WeakEventManager.ListenerList>.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="21bcf-178">
            <para>Jeśli typ bazowy dla <see cref="P:System.Windows.WeakEventManager.Item(System.Object)" /> coś jest inny niż <see cref="T:System.Windows.WeakEventManager.ListenerList" />, lub zawiera dane poza <see cref="T:System.Windows.WeakEventManager.ListenerList" />, konieczne jest przesłonięcie <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> metody. Zastąpienie powinien zapewnić zachowanie przeczyszczania do listy elementów typu alternatywny. Ogólnie rzecz biorąc zastąpienie powinien zapewnić zachowanie bez wywoływania implementacji podstawowej. Jeśli określony <see cref="T:System.Windows.WeakEventManager.ListenerList" /> nadal wymaga czyszczenia, wywołania <see cref="M:System.Windows.WeakEventManager.ListenerList.Purge" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-178">
              <para>If the underlying type for the <see cref="P:System.Windows.WeakEventManager.Item(System.Object)" /> is something other than <see cref="T:System.Windows.WeakEventManager.ListenerList" />, or contains data beyond a <see cref="T:System.Windows.WeakEventManager.ListenerList" />, you must override the <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> method. The override should provide purge behavior for the alternate type items list. Generally, the override should provide behavior without calling the base implementation. If a specific <see cref="T:System.Windows.WeakEventManager.ListenerList" /> still needs clearing, call <see cref="M:System.Windows.WeakEventManager.ListenerList.Purge" />.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="ReadLock">
      <MemberSignature Language="C#" Value="protected IDisposable ReadLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable ReadLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.ReadLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ReadLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ ReadLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadLock : IDisposable" Usage="System.Windows.WeakEventManager.ReadLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="21bcf-179">Ustanawia blokady odczytu w tabeli podstawowej danych i zwraca <see cref="T:System.IDisposable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-179">Establishes a read-lock on the underlying data table, and returns an <see cref="T:System.IDisposable" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="21bcf-180">Obiekt, który może służyć do ustanowienia blokady w elementach członkowskich tabeli danych, a następnie odpowiednio usunięta z <see langword="using" /> utworzenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-180">An object that can be used to establish a lock on the data table members and then be appropriately disposed with a <see langword="using" /> construct.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21bcf-181">W klasach pochodnych, wysyła zapytanie do tabeli zawartych w <xref:System.Windows.WeakEventManager.Item%2A> powinny być zawsze wykonywane w ramach `using (ReadLock) { ... }` klauzuli, z wyjątkiem zapytań, które znajdują się już na blokadę zapisu.</span><span class="sxs-lookup"><span data-stu-id="21bcf-181">In derived classes, queries to the table contained in <xref:System.Windows.WeakEventManager.Item%2A> should always occur within a `using (ReadLock) { ... }` clause, except for queries that are already within a write lock.</span></span> <span data-ttu-id="21bcf-182">Te zapytania może być konieczne, jeśli klasa obsługuje bardziej złożone `AddListener` implementację, która wymaga większej ilości danych poza `source` i `listener`i używa <xref:System.Windows.WeakEventManager.Item%2A> kolekcji do przechowywania dodatkowych informacji.</span><span class="sxs-lookup"><span data-stu-id="21bcf-182">These queries may be necessary if your class supports a more sophisticated `AddListener` implementation that requires more data beyond the `source` and the `listener`, and uses the <xref:System.Windows.WeakEventManager.Item%2A> collection to store the extra information.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.WriteLock" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="protected void Remove (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Remove(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub Remove (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Remove(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="member this.Remove : obj -&gt; unit" Usage="weakEventManager.Remove source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="21bcf-183">Aby usunąć odbiornik informacje dotyczące źródło.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-183">The source to remove listener information for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="21bcf-184">Usuwa wszystkie odbiorników dla określonego źródła.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-184">Removes all listeners for the specified source.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ScheduleCleanup">
      <MemberSignature Language="C#" Value="protected void ScheduleCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ScheduleCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ScheduleCleanup" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ScheduleCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ScheduleCleanup();" />
      <MemberSignature Language="F#" Value="member this.ScheduleCleanup : unit -&gt; unit" Usage="weakEventManager.ScheduleCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="21bcf-185">Wykonanie usuwanie nieużywanych wpisów na liście podstawowej odbiornika na niższy priorytet wątku żądania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-185">Requests that a purge of unused entries in the underlying listener list be performed on a lower priority thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21bcf-186">Wywoływanie <xref:System.Windows.WeakEventManager.ScheduleCleanup%2A> metoda jest podobna do wywoływania <xref:System.Windows.WeakEventManager.Purge%2A> metody na liście bieżący Menedżer, niższym priorytetem wątku, z `purgeAll` ustawiono parametr `false`.</span><span class="sxs-lookup"><span data-stu-id="21bcf-186">Calling the <xref:System.Windows.WeakEventManager.ScheduleCleanup%2A> method is similar to calling the <xref:System.Windows.WeakEventManager.Purge%2A> method on the current manager's list, at lower thread priority, with the `purgeAll` parameter set to `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentManager">
      <MemberSignature Language="C#" Value="protected static void SetCurrentManager (Type managerType, System.Windows.WeakEventManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig void SetCurrentManager(class System.Type managerType, class System.Windows.WeakEventManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Sub SetCurrentManager (managerType As Type, manager As WeakEventManager)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static void SetCurrentManager(Type ^ managerType, System::Windows::WeakEventManager ^ manager);" />
      <MemberSignature Language="F#" Value="static member SetCurrentManager : Type * System.Windows.WeakEventManager -&gt; unit" Usage="System.Windows.WeakEventManager.SetCurrentManager (managerType, manager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
        <Parameter Name="manager" Type="System.Windows.WeakEventManager" />
      </Parameters>
      <Docs>
        <param name="managerType">
          <span data-ttu-id="21bcf-187">Typ do nowego menedżera zdarzeń.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-187">The type to set the new event manager.</span>
          </span>
        </param>
        <param name="manager">
          <span data-ttu-id="21bcf-188">Nowy Menedżer zdarzeń.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-188">The new event manager.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="21bcf-189">Ustawia bieżący Menedżer Menedżera określonego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-189">Sets the current manager for the specified manager type.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21bcf-190">Wywołanie <xref:System.Windows.WeakEventManager.SetCurrentManager%2A> metody można zainicjować menedżera, jeśli jest wymagany przez wywołanie do Twojej `CurrentManager` właściwość <xref:System.Windows.WeakEventManager> implementacji.</span><span class="sxs-lookup"><span data-stu-id="21bcf-190">Call the <xref:System.Windows.WeakEventManager.SetCurrentManager%2A> method to initialize a manager, if that is required by a call to your `CurrentManager` property on a <xref:System.Windows.WeakEventManager> implementation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StartListening">
      <MemberSignature Language="C#" Value="protected abstract void StartListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StartListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StartListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StartListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StartListening : obj -&gt; unit" Usage="weakEventManager.StartListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="21bcf-191">Źródło, aby rozpocząć nasłuchiwania na.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-191">The source to begin listening on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="21bcf-192">W przypadku przesłonięcia w klasie pochodnej, rozpoczyna nasłuchiwanie zdarzeń zarządzany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-192">When overridden in a derived class, starts listening for the event being managed.</span>
          </span>
          <span data-ttu-id="21bcf-193">Po <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> najpierw wywoływana jest metoda, Menedżer powinien być w stanie wywołania metody <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> lub <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" /> zawsze, gdy odpowiednie zdarzenie z podanego źródła jest obsługiwane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-193">After the <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> method is first called, the manager should be in the state of calling <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> or <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" /> whenever the relevant event from the provided source is handled.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="21bcf-194">
            <para>
              <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> zastąpienia należy dodać program obsługi do dostarczonego <paramref name="source" />. Program obsługi jest zadeklarowany przez Menedżera samej siebie. Obsługa klasy nie powinny być publiczne i powinna być wywoływana tylko w odpowiedzi na zdarzenie zarządzany. Obsługa klasy powinny wywoływać <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> metody lub <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" /> — metoda odpowiednio.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-194">
              <para>
                <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> overrides should add a handler to the provided <paramref name="source" />. The handler is declared by the manager itself. The class handler should not be public, and it should only be called in response to the event being managed. The class handler should call the <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> method or the <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" /> method appropriately.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StopListening">
      <MemberSignature Language="C#" Value="protected abstract void StopListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StopListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StopListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StopListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StopListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StopListening : obj -&gt; unit" Usage="weakEventManager.StopListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="21bcf-195">Źródło do zatrzymania nasłuchiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-195">The source to stop listening on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="21bcf-196">W przypadku przesłonięcia w klasie pochodnej, zatrzymuje nasłuchiwanie dla podanego źródła zdarzeń zarządzany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-196">When overridden in a derived class, stops listening on the provided source for the event being managed.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="21bcf-197">
            <para>
              <see cref="M:System.Windows.WeakEventManager.StopListening(System.Object)" /> implementacje należy usunąć program obsługi klasy dodawany przez <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> metody. Usuwanie odbiornik nie należy wyczyścić listy odbiornika. Zamiast tego należy tylko Odłącz obsługi klasy (być może tymczasowo). Inne metody są dostępne, takich jak czyszczenie całą listę <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> metody z <paramref name="purgeAll" /> ustawiono parametr <see langword="true" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-197">
              <para>
                <see cref="M:System.Windows.WeakEventManager.StopListening(System.Object)" /> implementations should remove the class handler as added by the <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> method. Removing a listener should not clear the listener list. Instead, it should only disconnect the class handler (perhaps temporarily). Other methods are available for clearing the entire list, such as the <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> method with the <paramref name="purgeAll" /> parameter set to <see langword="true" />.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLock">
      <MemberSignature Language="C#" Value="protected IDisposable WriteLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable WriteLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.WriteLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property WriteLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ WriteLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteLock : IDisposable" Usage="System.Windows.WeakEventManager.WriteLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="21bcf-198">Ustanawia blokady zapisu w tabeli podstawowej danych i zwraca <see cref="T:System.IDisposable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-198">Establishes a write-lock on the underlying data table, and returns an <see cref="T:System.IDisposable" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="21bcf-199">Obiekt, który może służyć do ustanowienia blokady w elementach członkowskich tabeli danych, a następnie odpowiednio usunięta z <see langword="using" /> utworzenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="21bcf-199">An object that can be used to establish a lock on the data table members and then be appropriately disposed with a <see langword="using" /> construct.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="21bcf-200">W klasach pochodnych, wszystkie zmiany do tabeli podstawowej danych powinna wystąpić w ramach `using (WriteLock) { ... }` klauzuli.</span><span class="sxs-lookup"><span data-stu-id="21bcf-200">In derived classes, all modifications to the underlying data table should occur within a `using (WriteLock) { ... }` clause.</span></span> <span data-ttu-id="21bcf-201">Poniższe zmiany, może być konieczne, jeśli klasa obsługuje bardziej złożone `AddListener` implementację, która wymaga większej ilości danych poza `source` i `listener`i używa <xref:System.Windows.WeakEventManager.Item%2A> kolekcji do przechowywania dodatkowych informacji.</span><span class="sxs-lookup"><span data-stu-id="21bcf-201">These modifications may be necessary if your class supports a more sophisticated `AddListener` implementation that requires more data beyond the `source` and the `listener`, and uses the <xref:System.Windows.WeakEventManager.Item%2A> collection to store the extra information.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.ReadLock" />
      </Docs>
    </Member>
  </Members>
</Type>
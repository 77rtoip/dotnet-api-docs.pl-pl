<Type Name="WeakEventManager" FullName="System.Windows.WeakEventManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="080b5265a21bc5938d549e2c320e525fe044eb65" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69443642" /></Metadata><TypeSignature Language="C#" Value="public abstract class WeakEventManager : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract WeakEventManager extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.WeakEventManager" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WeakEventManager&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class WeakEventManager abstract : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type WeakEventManager = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Dostarcza klasę bazową dla Menedżera zdarzeń, która jest używana w niesłabym *wzorcu zdarzenia*. Menedżer dodaje i usuwa detektory zdarzeń (lub wywołania zwrotne), które również używają wzorca.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wzorzec zdarzeń słabych jest zazwyczaj używany, gdy źródło zdarzenia ma okres istnienia obiektu, który jest niezależny od detektorów zdarzeń. Użycie centralnej funkcji <xref:System.Windows.WeakEventManager> wysyłania zdarzeń przez program umożliwia obsługę elementów bezużytecznych odbiornika, nawet jeśli obiekt źródłowy utrzymuje się. W przeciwieństwie do regularnego podłączenie zdarzeń przy `+=` użyciu operatora powoduje, że potencjalnie odłączona źródło może przechowywać odwołanie do odbiorników. Zapobiega to odbieraniu przez odbiornik elementów bezużytecznych w odpowiednim czasie.  
  
 Jedną z typowych sytuacji, w której relacje okresu istnienia między źródłami i odbiornikami powinny używać słabego wzorca zdarzeń, obsługują zdarzenia aktualizacji pochodzące z powiązań danych.  
  
 Słaby wzorzec zdarzeń może również służyć do wywoływania zwrotnego i zwykłych zdarzeń.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Przykład niestandardowego <see cref="T:System.Windows.WeakEventManager" />, zobacz [słabych wzorców zdarzeń](~/docs/framework/wpf/advanced/weak-event-patterns.md).</para></block>
    <altmember cref="T:System.Windows.IWeakEventListener" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WeakEventManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WeakEventManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje wartości klasy bazowej, gdy jest używany jako inicjator przez konstruktora klasy pochodnej.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeliverEvent">
      <MemberSignature Language="C#" Value="protected void DeliverEvent (object sender, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEvent(object sender, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEvent (sender As Object, args As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEvent(System::Object ^ sender, EventArgs ^ args);" />
      <MemberSignature Language="F#" Value="member this.DeliverEvent : obj * EventArgs -&gt; unit" Usage="weakEventManager.DeliverEvent (sender, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">Obiekt, na którym zdarzenie jest obsługiwane.</param>
        <param name="args"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia do dostarczenia.</param>
        <summary>Dostarcza zdarzenie zarządzane dla każdego odbiornika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Windows.WeakEventManager.StartListening%2A> <xref:System.Windows.WeakEventManager.StopListening%2A> metodę z obsługi zdarzeń, które są dodawane lub usuwane przez implementacje podklas i. <xref:System.Windows.WeakEventManager.DeliverEvent%2A>  
  
 Jeśli wywołasz <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> metodę `AddListener` w implementacji klasy, lista odbiorników otrzymujących zdarzenie jest zachowywana w źródłowej kolekcji. (`AddListener` nie jest częścią kontraktu interfejsu lub klasy. `AddListener`jest sugerowaną nazwą metody klasy Menedżera, która wywołuje <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> i dodaje słabe detektory wzorców zdarzeń dla zdarzenia.  
  
 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>dodaje detektory do pojedynczej listy. Jeśli wdrożenie Menedżera zawiera więcej niż jedną listę odbiorników na zdarzenie, nie używaj <xref:System.Windows.WeakEventManager.DeliverEvent%2A> ani. <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> Zamiast tego implementacja powinna tworzyć własne <xref:System.Windows.WeakEventManager.ListenerList> wystąpienia, `AddListener` należy dodać detektory do odpowiedniej listy, a zdarzenia powinny zostać dostarczone do odpowiedniej listy odbiorników przez wywołanie <xref:System.Windows.WeakEventManager.DeliverEventToList%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
      </Docs>
    </Member>
    <Member MemberName="DeliverEventToList">
      <MemberSignature Language="C#" Value="protected void DeliverEventToList (object sender, EventArgs args, System.Windows.WeakEventManager.ListenerList list);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEventToList(object sender, class System.EventArgs args, class System.Windows.WeakEventManager/ListenerList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEventToList (sender As Object, args As EventArgs, list As WeakEventManager.ListenerList)" />
      <MemberSignature Language="F#" Value="member this.DeliverEventToList : obj * EventArgs * System.Windows.WeakEventManager.ListenerList -&gt; unit" Usage="weakEventManager.DeliverEventToList (sender, args, list)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEventToList(System::Object ^ sender, EventArgs ^ args, System::Windows::WeakEventManager::ListenerList ^ list);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
        <Parameter Name="list" Type="System.Windows.WeakEventManager+ListenerList" />
      </Parameters>
      <Docs>
        <param name="sender">Obiekt, na którym zdarzenie jest obsługiwane.</param>
        <param name="args"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <param name="list">Dostarczone <see cref="T:System.Windows.WeakEventManager.ListenerList" />.</param>
        <summary>Dostarcza zdarzenie zarządzane dla każdego odbiornika na podanej liście.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest niezbędna, jeśli implementacja Menedżera przechowuje oddzielne listy odbiorników na podstawie informacji przechwytywanych w danych zdarzenia. W przypadku korzystania z tej zaawansowanej metody, należy utworzyć i obsłużyć osobne listy w ramach implementacji Menedżera i należy udostępnić sposób dodawania odbiorników do konkretnej listy. Implementacja programu obsługi, która nasłuchuje w zdarzeniu nieprzetworzonym, musi działać w oparciu o warunek, którego można użyć do odróżnienia list i dostarczenia zdarzenia tylko do odpowiedniej listy lub list.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentManager">
      <MemberSignature Language="C#" Value="protected static System.Windows.WeakEventManager GetCurrentManager (Type managerType);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Windows.WeakEventManager GetCurrentManager(class System.Type managerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetCurrentManager (managerType As Type) As WeakEventManager" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Windows::WeakEventManager ^ GetCurrentManager(Type ^ managerType);" />
      <MemberSignature Language="F#" Value="static member GetCurrentManager : Type -&gt; System.Windows.WeakEventManager" Usage="System.Windows.WeakEventManager.GetCurrentManager managerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="managerType">Typ, dla którego ma <see cref="T:System.Windows.WeakEventManager" /> zostać uzyskana wartość.</param>
        <summary><see cref="T:System.Windows.WeakEventManager" /> Zwraca implementację używaną dla podanego typu.</summary>
        <returns>Zgodna <see cref="T:System.Windows.WeakEventManager" /> implementacja.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.IWeakEventListener.ReceiveWeakEvent%2A>implementacje wywołują tę metodę przy `managerType`użyciu ich zakończono. Zwracany <xref:System.Windows.WeakEventManager> jest następnie używany jako odróżniający, który określa, które zdarzenie zostało odebrane i która procedura obsługi klasy prywatnej ma zostać wywołana.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="protected object this[object source] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Protected Property Item(source As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ source); void set(System::Object ^ source, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Windows.WeakEventManager.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Indeks (liczony od zera) żądanego źródła.</param>
        <summary>Pobiera lub ustawia dane przechowywane dla określonego źródła.</summary>
        <value>Dane przechowywane przez Menedżera dla tego źródła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne mogą wybierać dane i typy do przechowywania w tym indeksatorze. Zwykle jest to implementowane jako <xref:System.Windows.WeakEventManager.ListenerList>, która jest listą słabych odwołań do odbiorników. Ten typ należy zmienić tylko wtedy, <xref:System.Windows.WeakEventManager.ListenerList> gdy typ nie może zawierać wymaganych informacji. Jeśli tak, należy przesłonić <xref:System.Windows.WeakEventManager.Purge%2A> metodę, aby wszystkie oczyszczanie typu podstawowego były wykonywane poprawnie.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="NewListenerList">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.WeakEventManager.ListenerList NewListenerList ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.WeakEventManager/ListenerList NewListenerList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.NewListenerList" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewListenerList () As WeakEventManager.ListenerList" />
      <MemberSignature Language="F#" Value="abstract member NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList&#xA;override this.NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList" Usage="weakEventManager.NewListenerList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager+ListenerList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca nowy obiekt, który zawiera detektory do zdarzenia.</summary>
        <returns>Nowy obiekt, który będzie zawierać detektory dla zdarzenia.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedAddHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedAddHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="handler" Type="System.Delegate" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="source">Obiekt źródłowy, do którego subskrybuje program obsługi.</param>
        <param name="handler">Delegat, który obsługuje zdarzenie, które jest zgłaszane przez <paramref name="source" />.</param>
        <summary>Dodaje określonego delegata jako procedurę obsługi zdarzeń określonego źródła.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddListener">
      <MemberSignature Language="C#" Value="protected void ProtectedAddListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedAddListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">Źródło, do którego mają zostać dołączone odbiorniki.</param>
        <param name="listener">Klasa nasłuchu (która musi implementować <see cref="T:System.Windows.IWeakEventListener" />).</param>
        <summary>Dodaje podany odbiornik do podanego źródła dla zarządzanego zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę w ramach metod `AddListener` klasy Menedżera <xref:System.Windows.WeakEventManager> w przypadku implementacji. `AddListener`jest sugerowaną nazwą dla statycznej metody zdefiniowanej w klasie Menedżera, aby umożliwić innym klasom dodanie odbiornika dla słabych wzorców zdarzeń. `AddListener`powinna przyjmować dwa parametry: `source` gdzie jest dołączony odbiornik `listener` i wystąpienie. Dla Twojej `AddListener` implementacji <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> Wywołaj metodę w bieżącym Menedżerze i przekaż te same dwa parametry.  
  
 Jeśli lista odbiorników była wcześniej pusta, <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> <xref:System.Windows.WeakEventManager.StartListening%2A> wywołuje metodę wewnętrznie, która wywoła określone <xref:System.Windows.WeakEventManager.StartListening%2A> przesłonięcie za pomocą polimorfizmu.  
  
 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>dodaje detektory do pojedynczej <xref:System.Windows.WeakEventManager.ListenerList> wewnętrznej `source`wartości. Jeśli wdrożenie Menedżera utrzymuje więcej niż jedną listę odbiorników dla każdej kombinacji źródła zdarzeń, nie należy używać <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>. Zamiast tego implementacja powinna tworzyć własne <xref:System.Windows.WeakEventManager.ListenerList> wystąpienia, `AddListener` należy dodać detektory do odpowiedniej listy, a zdarzenia powinny zostać dostarczone do odpowiedniej listy <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> odbiorników przez wywołanie zdarzenia zamiast <xref:System.Windows.WeakEventManager.DeliverEvent%2A> Metoda.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedRemoveHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="handler" Type="System.Delegate" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="source">Źródło, z którego ma zostać usunięty program obsługi.</param>
        <param name="handler">Delegat do usunięcia <paramref name="source" />.</param>
        <summary>Usuwa wcześniej dodaną procedurę obsługi z określonego źródła.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveListener">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedRemoveListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">Źródło, z którego mają zostać usunięte odbiorniki.</param>
        <param name="listener">Klasa nasłuchu (która musi implementować <see cref="T:System.Windows.IWeakEventListener" />).</param>
        <summary>Usuwa wcześniej dodany odbiornik z podanego źródła.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę w ramach metod `RemoveListener` klasy Menedżera <xref:System.Windows.WeakEventManager> w przypadku implementacji. `RemoveListener`jest sugerowaną nazwą dla statycznej metody zdefiniowanej w klasie Menedżera, aby umożliwić innym klasom usuwanie odbiornika dla słabych wzorców zdarzeń. `RemoveListener`powinien przyjmować dwa parametry: `source` miejsce, w którym został usunięty odbiornik, `listener` i Klasa. Dla Twojej `RemoveListener` implementacji <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> Wywołaj metodę w bieżącym Menedżerze i przekaż te same dwa parametry.  
  
 Jeśli wywołanie <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> usuwa ostatni odbiornik na liście, <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> wywołuje <xref:System.Windows.WeakEventManager.StopListening%2A> metodę wewnętrznie, która wywoła określone <xref:System.Windows.WeakEventManager.StopListening%2A> przesłonięcie za pomocą polimorfizmu.  
  
 <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>usuwa odbiorniki z pojedynczej <xref:System.Windows.WeakEventManager.ListenerList> wewnętrznej `source`na. Jeśli wdrożenie Menedżera utrzymuje więcej niż jedną listę odbiorników dla każdej kombinacji źródła zdarzeń, nie należy używać <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>. Zamiast tego implementacja powinna tworzyć własne <xref:System.Windows.WeakEventManager.ListenerList> wystąpienia, `RemoveListener` należy usunąć detektory z odpowiedniej listy, a zdarzenia powinny zostać dostarczone do odpowiedniej listy <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> odbiorników przez wywołanie metody zamiast <xref:System.Windows.WeakEventManager.DeliverEvent%2A> Metoda.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="protected virtual bool Purge (object source, object data, bool purgeAll);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool Purge(object source, object data, bool purgeAll) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Purge (source As Object, data As Object, purgeAll As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool Purge(System::Object ^ source, System::Object ^ data, bool purgeAll);" />
      <MemberSignature Language="F#" Value="abstract member Purge : obj * obj * bool -&gt; bool&#xA;override this.Purge : obj * obj * bool -&gt; bool" Usage="weakEventManager.Purge (source, data, purgeAll)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="purgeAll" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">Źródło zdarzeń, do których nasłuchuje.</param>
        <param name="data">Dane do sprawdzenia. Oczekiwanym obiektem jest <see cref="T:System.Windows.WeakEventManager.ListenerList" /> implementacja.</param>
        <param name="purgeAll"><see langword="true" />Aby przerwać nasłuchiwanie <paramref name="source" />i całkowicie usunąć wszystkie wpisy z <paramref name="data" />programu.</param>
        <summary>Usuwa nieaktywne wpisy odbiornika z listy danych dla podanego źródła. Zwraca <see langword="true" /> czy niektóre wpisy zostały faktycznie usunięte z listy.</summary>
        <returns><see langword="true" />Jeśli niektóre wpisy zostały faktycznie usunięte; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ma domyślną implementację, która spowoduje usunięcie wszystkich wpisów, gdy dane <xref:System.Windows.WeakEventManager.ListenerList>są. <xref:System.Windows.WeakEventManager.Purge%2A>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Jeśli <see cref="P:System.Windows.WeakEventManager.Item(System.Object)" /> typ podstawowy dla elementu to coś innego niż <see cref="T:System.Windows.WeakEventManager.ListenerList" />lub zawiera dane poza obiektem <see cref="T:System.Windows.WeakEventManager.ListenerList" />, należy zastąpić <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> metodę. Zastąpienie powinno zapewnić zachowanie podczas przeczyszczania dla listy elementów typu alternatywnego. Ogólnie rzecz biorąc, zastąpienie powinno zapewnić zachowanie bez wywoływania podstawowej implementacji. Jeśli określone <see cref="T:System.Windows.WeakEventManager.ListenerList" /> nadal wymagają czyszczenia, wywołaj <see cref="M:System.Windows.WeakEventManager.ListenerList.Purge" />.</para></block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="ReadLock">
      <MemberSignature Language="C#" Value="protected IDisposable ReadLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable ReadLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.ReadLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ReadLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ ReadLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadLock : IDisposable" Usage="System.Windows.WeakEventManager.ReadLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ustanawia odblokowanie do odczytu w źródłowej tabeli danych i zwraca <see cref="T:System.IDisposable" />.</summary>
        <value>Obiekt, który może służyć do ustanowienia blokady elementów członkowskich tabeli danych, a następnie być odpowiednio usunięty z <see langword="using" /> konstrukcja.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W klasach pochodnych zapytania do tabeli zawartej w <xref:System.Windows.WeakEventManager.Item%2A> `using (ReadLock) { ... }` elemencie powinny zawsze występować w klauzuli, z wyjątkiem zapytań, które znajdują się już w ramach blokady zapisu. Te zapytania mogą być niezbędne, jeśli klasa obsługuje bardziej zaawansowaną `AddListener` implementację, która wymaga większej ilości danych `listener` `source` poza i i używa <xref:System.Windows.WeakEventManager.Item%2A> kolekcji do przechowywania dodatkowych informacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.WriteLock" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="protected void Remove (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Remove(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub Remove (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Remove(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="member this.Remove : obj -&gt; unit" Usage="weakEventManager.Remove source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Źródło, dla którego mają zostać usunięte informacje o odbiorniku.</param>
        <summary>Usuwa wszystkie detektory dla określonego źródła.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ScheduleCleanup">
      <MemberSignature Language="C#" Value="protected void ScheduleCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ScheduleCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ScheduleCleanup" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ScheduleCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ScheduleCleanup();" />
      <MemberSignature Language="F#" Value="member this.ScheduleCleanup : unit -&gt; unit" Usage="weakEventManager.ScheduleCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Żąda, aby przeczyszczanie nieużywanych wpisów na liście bazowych odbiorników odbywało się w wątku o niższym priorytecie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie metody jest podobne do <xref:System.Windows.WeakEventManager.Purge%2A> wywołania metody na liście bieżącego Menedżera, przy niższym priorytecie `purgeAll` wątku, z parametrem ustawionym na `false`. <xref:System.Windows.WeakEventManager.ScheduleCleanup%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentManager">
      <MemberSignature Language="C#" Value="protected static void SetCurrentManager (Type managerType, System.Windows.WeakEventManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig void SetCurrentManager(class System.Type managerType, class System.Windows.WeakEventManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Sub SetCurrentManager (managerType As Type, manager As WeakEventManager)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static void SetCurrentManager(Type ^ managerType, System::Windows::WeakEventManager ^ manager);" />
      <MemberSignature Language="F#" Value="static member SetCurrentManager : Type * System.Windows.WeakEventManager -&gt; unit" Usage="System.Windows.WeakEventManager.SetCurrentManager (managerType, manager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
        <Parameter Name="manager" Type="System.Windows.WeakEventManager" />
      </Parameters>
      <Docs>
        <param name="managerType">Typ, dla którego ma zostać ustawiony nowy Menedżer zdarzeń.</param>
        <param name="manager">Nowy Menedżer zdarzeń.</param>
        <summary>Ustawia bieżącego Menedżera dla określonego typu Menedżera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj `CurrentManager` <xref:System.Windows.WeakEventManager> metodę, aby zainicjować Menedżera, jeśli jest to wymagane przez wywołanie właściwości w implementacji. <xref:System.Windows.WeakEventManager.SetCurrentManager%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StartListening">
      <MemberSignature Language="C#" Value="protected abstract void StartListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StartListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StartListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StartListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StartListening : obj -&gt; unit" Usage="weakEventManager.StartListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Źródło, na którym rozpocznie się nasłuchiwanie.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, zaczyna nasłuchiwać zarządzanego zdarzenia. Po pierwszym wywołaniu <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" /> metody Menedżer powinien być w stanie wywoływania lub zawsze, gdy odpowiednie zdarzenie z podanego źródła jest obsługiwane. <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /></summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />zastąpień należy dodać procedurę obsługi do <paramref name="source" />podanego elementu. Program obsługi jest zadeklarowany przez Menedżera. Procedura obsługi klas nie powinna być publiczna i powinna być wywoływana tylko w odpowiedzi na zarządzane zdarzenie. Procedura obsługi klasy powinna wywołać <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> metodę <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" /> lub metodę odpowiednio.</para></block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StopListening">
      <MemberSignature Language="C#" Value="protected abstract void StopListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StopListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StopListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StopListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StopListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StopListening : obj -&gt; unit" Usage="weakEventManager.StopListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Źródło, na którym ma zostać zatrzymane nasłuchiwanie.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, przestaje nasłuchiwać podanego źródła dla zarządzanego zdarzenia.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.Windows.WeakEventManager.StopListening(System.Object)" />implementacje powinny usuwać procedurę obsługi klas dodaną przez <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> metodę. Usuwanie odbiornika nie powinno czyścić listy odbiorników. Zamiast tego należy rozłączyć tylko procedurę obsługi klasy (prawdopodobnie tymczasowo). Inne metody są dostępne do wyczyszczenia całej listy, <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> na przykład metody <paramref name="purgeAll" /> z parametrem ustawionym na <see langword="true" />.</para></block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLock">
      <MemberSignature Language="C#" Value="protected IDisposable WriteLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable WriteLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.WriteLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property WriteLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ WriteLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteLock : IDisposable" Usage="System.Windows.WeakEventManager.WriteLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ustanawia blokadę zapisu w źródłowej tabeli danych i zwraca <see cref="T:System.IDisposable" />.</summary>
        <value>Obiekt, który może służyć do ustanowienia blokady elementów członkowskich tabeli danych, a następnie być odpowiednio usunięty z <see langword="using" /> konstrukcja.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W klasach pochodnych wszystkie modyfikacje źródłowej tabeli danych powinny występować w `using (WriteLock) { ... }` klauzuli. Te `AddListener` modyfikacje mogą być konieczne, jeśli klasa obsługuje bardziej zaawansowaną implementację, która wymaga większej ilości danych `source` poza i `listener`i <xref:System.Windows.WeakEventManager.Item%2A> używa kolekcji do przechowywania dodatkowych informacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.ReadLock" />
      </Docs>
    </Member>
  </Members>
</Type>

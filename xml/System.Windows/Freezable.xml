<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c125d54ad21fa44be59bb03c1e4d67d257a48fed" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30715652" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Definiuje obiekt, który ma można modyfikować stanu i stanie (zamrożonym) tylko do odczytu. Klasy, które pochodzą z <see cref="T:System.Windows.Freezable" /> Podaj powiadomienia o zmianie szczegółowe, można wprowadzić niezmienne i może klonować samodzielnie.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable> Klasa udostępnia funkcje specjalne, które mogą pomóc zwiększyć wydajność aplikacji, korzystając z obiektów, które są kosztowne zmodyfikować lub skopiować. Przykłady <xref:System.Windows.Freezable> obiekty są następujące:  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a>Wyprowadzanie z obiektu Freezable  
 Klasa, która pochodzi z <xref:System.Windows.Freezable> uzyska następujące funkcje:  
  
-   Stany specjalnych: (zablokowane) stanie tylko do odczytu i zapisu stanu.  
  
-   Bezpieczeństwo wątków: zablokowane <xref:System.Windows.Freezable> obiektu może być współużytkowana przez wątki.  
  
-   Szczegółowe powiadomienia o zmianie: w odróżnieniu od innych <xref:System.Windows.DependencyObject> obiektów, <xref:System.Windows.Freezable> obiekt zapewnia powiadomienia o zmianie po zmianie wartości właściwości podrzędnych.  
  
-   Klonowanie łatwe: klasa obiektu Freezable został już zaimplementowany kilka metod, które wywołują klony głębokie.  
  
 Informacji o użyciu i tworzenia własnego <xref:System.Windows.Freezable> obiekty, zobacz [obiektu Freezable Przegląd obiektów](~/docs/framework/wpf/advanced/freezable-objects-overview.md).  
  
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie publiczne <see langword="static" /> elementy członkowskie tego typu są bezpieczne dla wątków. Wystąpienia elementów członkowskich nie dają gwarancji bezpieczeństwa wątków.  
  
 Gdy <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość jest <see langword="false" />, <see cref="T:System.Windows.Freezable" /> obiektu jest możliwy tylko z wątku, w którym został utworzony. Próba dostępu do niego z innego wątku zgłasza <see cref="T:System.InvalidOperationException" />. <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> i <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> metody zapewniają obsługę dla kierowania zorganizuj poprawny wątek.  
  
 Po ich <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość jest <see langword="true" />, <see cref="T:System.Windows.Freezable" /> są obiekty bezwątkowe.  Aby uzyskać więcej informacji, zobacz [obiektu Freezable Przegląd obiektów](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Freezable" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to Konstruktor chroniony dostępności klasy abstrakcyjnej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy obiekt mogą być tworzone unmodifiable.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący obiekt jest możliwe unmodifiable lub jest już unmodifiable; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Używa tej implementacji metody <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metody z <paramref name="isChecking" /> ustawioną <see langword="true" /> ustalenie, czy <see cref="T:System.Windows.Freezable" /> może się unmodifiable. Aby zmodyfikować sposób zachowania tej właściwości w klasie pochodnej, Zastąp <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metody.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="T:System.Windows.Freezable" /> lub obiektu zawiera jest modyfikowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli spróbujesz Dodaj lub usuń programy obsługi zdarzeń, jeśli bieżący obiekt nie jest modyfikowane przez (po <xref:System.Windows.Freezable.IsFrozen%2A> właściwość jest `true`), jest zgłaszany wyjątek.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy modyfikowalną Sklonowanie <see cref="T:System.Windows.Freezable" />, tworzenie bezpośrednich kopii wartości obiektu. Podczas kopiowania obiektu właściwości zależności, ta metoda umożliwia skopiowanie wyrażenia (których nie może rozpoznać), ale nie animacje lub ich bieżącymi wartościami.</summary>
        <returns>Można modyfikować klonowania bieżącego obiektu. Sklonowany obiekt <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość jest <see langword="false" /> nawet wtedy, gdy źródło <see cref="P:System.Windows.Freezable.IsFrozen" /> jest właściwość <see langword="true." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable.Clone%2A> i <xref:System.Windows.Freezable.CloneCurrentValue%2A> metody tworzy modyfikowalną klonów zablokowane <xref:System.Windows.Freezable> obiektów (metody również sklonować <xref:System.Windows.Freezable> obiektów, które nie są zablokowane). Klon jest głęboką kopię bieżącego obiektu.  
  
 W poniższej tabeli przedstawiono różnice między <xref:System.Windows.Freezable.Clone%2A> i <xref:System.Windows.Freezable.CloneCurrentValue%2A> metody.  
  
|Akcja|Klonowanie zachowanie — metoda|CloneCurrentValue zachowanie — metoda|  
|------------|---------------------------|---------------------------------------|  
|Kopiowanie właściwości zależności, który znajduje się wyrażenie|Wyrażenie jest kopiowana, ale nie może zostać rozwiązana. Aby uzyskać więcej informacji, zobacz [obiektu Freezable Przegląd obiektów](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|Bieżąca wartość wyrażenia jest kopiowana, ale nie wyrażenie.|  
|Kopiowanie właściwości animowany zależności|Wartość właściwości podstawowej (z systemem innym niż animowane) jest kopiowany. Animacji nie są kopiowane.|Bieżąca wartość animowanej właściwości jest kopiowana. Animacji nie są kopiowane.|  
  
 Należy pamiętać, że nie ustawiono właściwości nie są kopiowane. Jeśli nie ustawiono właściwość ma wartość domyślną, która jest zablokowane <xref:System.Windows.Freezable>, że wartość właściwości jest zablokowany w klonowania w przeciwnym razie można modyfikować.  
  
## <a name="move-a-freezable-between-threads"></a>Przenieś obiektu Freezable między wątkami  
 Ta metoda może być przydatna do przenoszenia <xref:System.Windows.Freezable> między wątkami. Po pierwsze należy <xref:System.Windows.Freezable> unmodifiable przez wywołanie jego <xref:System.Windows.Freezable.Freeze%2A> metody. Teraz można uzyskać dostępu do innego wątku <xref:System.Windows.Freezable> i lokalnym <xref:System.Windows.Freezable.Clone%2A> których może uzyskać dostęp.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ta metoda używa <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> do tworzenia klonu. Aby zmodyfikować zachowanie tej metody w klasie pochodnej, Przesłoń <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> metody.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Obiekt do klonowania.</param>
        <summary>Sprawia, że wystąpienie klonowania (bezpośrednich kopii) z określonym <see cref="T:System.Windows.Freezable" /> przy użyciu wartości podstawowej właściwości (z systemem innym niż animowane).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez <xref:System.Windows.Freezable.Clone%2A> metody i nie należy wywoływać bezpośrednio w kodzie, z wyjątkiem podczas wywoływania metody implementacji podstawowej podczas przesłaniania tej metody. Aby utworzyć modyfikowalną kopię bieżącego obiektu, należy wywołać <xref:System.Windows.Freezable.Clone%2A> zamiast bezpośrednio wywołaniem tej metody.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Jeśli pochodzi od <see cref="T:System.Windows.Freezable" />, konieczne może być przesłonić tę metodę. Aby zastąpić przyczyny poniżej:  
  
-   Klasy pochodne ma dane, które nie jest dostępna za pośrednictwem właściwości zależności.  
  
-   Klasy pochodne należy wykonać dodatkową inicjację pracy, którego nie można osiągnąć przez zastąpienie po prostu <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Na przykład, to ma zastosowanie, gdy implementuje klasy pochodnej <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
 Nie trzeba zastąpienie klas, które są przechowywane w właściwości zależności wszystkich danych i że nie trzeba wykonywać dodatkowe inicjalizację <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.  
  
 Istotne jest, że wszystkie implementacje wywoływać implementację podstawową tej metody. Implementacje należy wykonywać tylko pracy, który nie jest wykonywane przez domyślną implementację. Domyślna implementacja tworzy głębokie kopie wszystkich właściwości zapisywalny, ustaw lokalnie, w tym wewnętrznych wyrażeń.  
  
 Jeśli obiekt ma właściwości zależności powiązane z danymi, wyrażenia są kopiowane, ale nie może zostać rozwiązana. Aby uzyskać więcej informacji na temat klonowania obiektów powiązanych z danymi, zobacz [obiektu Freezable Przegląd obiektów](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Jeśli obiekt ma właściwości zależności animowany, jest kopiowana podstawowej (z systemem innym niż animowane) wartości tych właściwości. Animacji nie są kopiowane.  
  
 Należy pamiętać, że nie ustawiono właściwości nie są kopiowane ani nie są właściwościami tylko do odczytu. Jeśli taka właściwość ma wartość domyślną, która jest zablokowane <see cref="T:System.Windows.Freezable" />, że wartość właściwości jest zablokowany w klonowania w przeciwnym razie można modyfikować.  
  
 Poniższa lista zawiera podsumowanie nieoczekiwane zachowanie w przypadku tej metody:  
  
-   Kopia wyprodukowanych zawiera kopie wszystkich <see cref="T:System.Windows.Freezable" /> obiektów podrzędnych.  
  
-   Nie ustawiono i tylko do odczytu właściwości nie są kopiowane.  
  
-   Wyrażenia są kopiowane.  
  
-   Żadna z tych obiektów podrzędnych są zablokowane podczas ich tworzenia.  
  
-   Kopią samodzielnie nie jest zablokowany.  
  
-   Animacji nie są kopiowane.  
  
-   Tylko wartości podstawowej właściwości są kopiowane, nie są aktualnie animowany wartości.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy modyfikowalną klonu (bezpośrednich kopii) <see cref="T:System.Windows.Freezable" /> przy użyciu jego bieżące wartości.</summary>
        <returns>Można modyfikować klonowania bieżącego obiektu. Sklonowany obiekt <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość jest <see langword="false" /> nawet wtedy, gdy źródło <see cref="P:System.Windows.Freezable.IsFrozen" /> jest właściwość <see langword="true." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable.Clone%2A> i <xref:System.Windows.Freezable.CloneCurrentValue%2A> metody tworzy modyfikowalną klonów zablokowane <xref:System.Windows.Freezable> obiektów (metody również sklonować <xref:System.Windows.Freezable> obiektów, które nie są zablokowane). Klon jest głęboką kopię bieżącego obiektu.  
  
 W poniższej tabeli przedstawiono różnice między <xref:System.Windows.Freezable.Clone%2A> i <xref:System.Windows.Freezable.CloneCurrentValue%2A> metody.  
  
|Akcja|Klonowanie zachowanie — metoda|CloneCurrentValue zachowanie — metoda|  
|------------|---------------------------|---------------------------------------|  
|Kopiowanie właściwości zależności, który znajduje się wyrażenie|Wyrażenie jest kopiowana, ale nie może zostać rozwiązana. Aby uzyskać więcej informacji, zobacz [obiektu Freezable Przegląd obiektów](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|Bieżąca wartość wyrażenia jest kopiowana, ale nie wyrażenie.|  
|Kopiowanie właściwości animowany zależności|Wartość właściwości podstawowej (z systemem innym niż animowane) jest kopiowany. Animacji nie są kopiowane.|Bieżąca wartość animowanej właściwości jest kopiowana. Animacji nie są kopiowane.|  
  
 Należy pamiętać, że nie ustawiono właściwości nie są kopiowane. Jeśli nie ustawiono właściwość ma wartość domyślną, która jest zablokowane <xref:System.Windows.Freezable>, że wartość właściwości jest zablokowany w klonowania w przeciwnym razie można modyfikować.  
  
## <a name="move-a-freezable-between-threads"></a>Przenieś obiektu Freezable między wątkami  
 Ta metoda może być przydatna do przenoszenia <xref:System.Windows.Freezable> między wątkami. Po pierwsze należy <xref:System.Windows.Freezable> unmodifiable przy użyciu jego <xref:System.Windows.Freezable.Freeze%2A> metody. Teraz można uzyskać dostępu do innego wątku <xref:System.Windows.Freezable> i lokalne klonowania, których może uzyskać dostęp.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ta metoda używa <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> metody do tworzenia klonu; <see cref="T:System.Windows.Freezable" /> implementacje, które zastępują <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> musi zapewnić, że kopia nie jest zablokowana na tworzenie.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <see cref="T:System.Windows.Freezable" /> Klonowania.</param>
        <summary>Sprawia, że wystąpienie można modyfikować klonowania (bezpośrednich kopii) z określonym <see cref="T:System.Windows.Freezable" /> przy użyciu bieżącej wartości właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez <xref:System.Windows.Freezable.CloneCurrentValue%2A> metody i nie należy wywoływać bezpośrednio w kodzie, z wyjątkiem podczas wywoływania metody implementacji podstawowej podczas przesłaniania tej metody. Aby utworzyć modyfikowalną kopię bieżącego obiektu, należy wywołać <xref:System.Windows.Freezable.CloneCurrentValue%2A> zamiast bezpośrednio wywołaniem tej metody.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Jeśli pochodzi od <see cref="T:System.Windows.Freezable" />, konieczne może być przesłonić tę metodę. Aby zastąpić przyczyny poniżej:  
  
-   Klasy pochodne ma dane, które nie jest dostępna za pośrednictwem właściwości zależności.  
  
-   Klasy pochodne należy wykonać dodatkową inicjację pracy, którego nie można osiągnąć przez zastąpienie po prostu <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Na przykład, to ma zastosowanie, gdy implementuje klasy pochodnej <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
 Nie trzeba zastąpienie klas, które są przechowywane w właściwości zależności wszystkich danych i że nie trzeba wykonywać dodatkowe inicjalizację <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />.  
  
 Istotne jest, że wszystkie implementacje wywoływać implementację podstawową tej metody. Implementacje należy wykonywać tylko pracy, który nie jest wykonywane przez domyślną implementację. Domyślna implementacja tworzy głębokie kopie wszystkich właściwości zapisywalny, ustaw lokalnie. Jeśli obiekt zawiera właściwości zależności za pomocą wyrażeń (na przykład powiązanie danych), bieżącą wartość wyrażenia jest kopiowana, ale nie wyrażenie.  
  
 Jeśli obiekt ma animowany właściwości zależności, animowany bieżącą wartość właściwości jest kopiowana, ale animacji nie są.  
  
 Należy pamiętać, że nie ustawiono właściwości nie są kopiowane ani nie są właściwościami tylko do odczytu. Jeśli taka właściwość ma wartość domyślną, która jest zablokowane <see cref="T:System.Windows.Freezable" />, że wartość właściwości jest zablokowany w klonowania w przeciwnym razie można modyfikować.  
  
 Poniższa lista zawiera podsumowanie nieoczekiwane zachowanie w przypadku tej metody.  
  
-   Kopia wyprodukowanych zawiera kopie wszystkich <see cref="T:System.Windows.Freezable" /> obiektów podrzędnych.  
  
-   Nie ustawiono i tylko do odczytu właściwości nie są kopiowane.  
  
-   Jeśli właściwość jest animowany, jego bieżąca wartość jest kopiowana, ale sam animacji nie jest.  
  
-   Żadna z tych obiektów podrzędnych są zablokowane podczas ich tworzenia.  
  
-   Kopią samodzielnie nie jest zablokowany.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Freezable" /> klasy.</summary>
        <returns>Nowe wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to metoda chroniona, a rzeczywista implementacje specyficzne dla obiekt zachowania są zależne od implementacji zastąpienie <xref:System.Windows.Freezable.CreateInstanceCore%2A> metodę, która ta metoda wywołuje wewnętrznie.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po zaimplementowaniu w klasie pochodnej tworzy nowe wystąpienie klasy <see cref="T:System.Windows.Freezable" /> klasy.</summary>
        <returns>Nowe wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie wywołuj tej metody bezpośrednio (za wyjątkiem podczas wywoływania base w implementacji). Ta metoda jest wywoływana wewnętrznie przez <xref:System.Windows.Freezable.CreateInstance%2A> zawsze, gdy jest nowe wystąpienie klasy <xref:System.Windows.Freezable> jest tworzony.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono Typowa implementacja <xref:System.Windows.Freezable.CreateInstanceCore%2A>.  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Każdy <see cref="T:System.Windows.Freezable" /> klas pochodnych należy zaimplementować tę metodę. Typowa implementacja jest po prostu wywołania konstruktora domyślnego i zwracają wynik.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sprawia, że <see cref="T:System.Windows.Freezable" /> obiekt unmodifiable i ustawia jej <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwości <see langword="true" />, lub testów czy <see cref="T:System.Windows.Freezable" /> obiektu można wprowadzić unmodifiable.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że bieżący obiekt unmodifiable i ustawia jej <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwości <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uniknąć możliwości <xref:System.InvalidOperationException> podczas wywoływania tej metody, sprawdź <xref:System.Windows.Freezable.CanFreeze%2A> umożliwia określenie, czy <xref:System.Windows.Freezable> można wprowadzić unmodifiable przed wywołaniem tej metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Windows.Freezable" /> Nie mogą dopuszczać unmodifiable.</exception>
        <block subset="none" type="overrides">
          <para>Ta metoda używa <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metody, aby <see cref="T:System.Windows.Freezable" /> unmodifiable. Aby zmodyfikować zachowanie zamrożenia, Zastąp <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metody.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">Obiekt do wyboru lub Utwórz unmodifiable. Jeśli <c>isChecking</c> jest <see langword="true" />, obiekt jest sprawdzany w celu określenia, czy można go było unmodifiable. Jeśli <c>isChecking</c> jest <see langword="false" />, obiekt ma zostać unmodifiable, jeśli to możliwe.</param>
        <param name="isChecking">
          <see langword="true" /> Aby przywrócić wskazaniem, czy obiekt może być zablokowana (bez faktycznie zamrażanie go); <see langword="false" /> aby faktycznie zablokować obiektu.</param>
        <summary>Jeśli <paramref name="isChecking" /> parametr jest <see langword="true" />, ta metoda wskazuje czy określony <see cref="T:System.Windows.Freezable" /> można wprowadzić unmodifiable. Jeśli <paramref name="isChecking" /> parametr jest <see langword="false" />, ta metoda próbuje utworzyć określonego <see cref="T:System.Windows.Freezable" /> unmodifiable oraz wskazuje, czy operacja zakończyła się pomyślnie.</summary>
        <returns>Jeśli <paramref name="isChecking" /> jest <see langword="true" />, ta metoda zwraca <see langword="true" /> Jeśli określonego <see cref="T:System.Windows.Freezable" /> może się unmodifiable, lub <see langword="false" /> , jeśli nie można dokonać unmodifiable. Jeśli <paramref name="isChecking" /> jest <see langword="false" />, ta metoda zwraca <see langword="true" /> Jeśli określonego <see cref="T:System.Windows.Freezable" /> jest teraz unmodifiable, lub <see langword="false" /> , jeśli nie można dokonać unmodifiable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie wywołuj tej metody, chyba że są wynikających z <xref:System.Windows.Freezable> i zastępowanie <xref:System.Windows.Freezable.FreezeCore%2A> metody.  Ta metoda może być używany w <xref:System.Windows.Freezable.FreezeCore%2A> metodę, aby zablokować danych elementów członkowskich klasy, które same <xref:System.Windows.Freezable> obiektów.  
  
 Problem jest aby wywołać tę metodę ponownie na <xref:System.Windows.Freezable> obiekt, który jest już zablokowany (unmodifiable).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Gdy <paramref name="isChecking" /> jest <see langword="false" />, próba wykonania <paramref name="freezable" /> unmodifiable nie powiodła się; obiektu jest teraz w nieznanym stanie (go może być częściowo zablokowana).</exception>
        <block subset="none" type="overrides">
          <para>Ta metoda używa <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metody, aby <see cref="T:System.Windows.Freezable" /> unmodifiable. Aby zmodyfikować zachowanie zamrożenia, Zastąp <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metody.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">
          <see langword="true" /> Aby przywrócić wskazaniem, czy obiekt może być zablokowana (bez faktycznie zamrażanie go); <see langword="false" /> aby faktycznie zablokować obiektu.</param>
        <summary>Sprawia, że <see cref="T:System.Windows.Freezable" /> obiektu unmodifiable lub sprawdzenie, czy można go było unmodifiable.</summary>
        <returns>Jeśli <paramref name="isChecking" /> jest <see langword="true" />, ta metoda zwraca <see langword="true" /> Jeśli <see cref="T:System.Windows.Freezable" /> może się unmodifiable, lub <see langword="false" /> , jeśli nie można dokonać unmodifiable. Jeśli <paramref name="isChecking" /> jest <see langword="false" />, ta metoda zwraca <see langword="true" /> Jeśli obszar, jeśli określony <see cref="T:System.Windows.Freezable" /> jest teraz unmodifiable, lub <see langword="false" /> , jeśli nie można dokonać unmodifiable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie wywołuj tej metody bezpośrednio (za wyjątkiem podczas wywoływania base w implementacji). Ta metoda jest wywoływana wewnętrznie przez <xref:System.Windows.Freezable.CanFreeze%2A> właściwości (z `isChecking` równa `true`) i <xref:System.Windows.Freezable.Freeze%2A> — metoda (z `isChecking` równa `false`).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.Freezable" /> implementacje muszą przesłaniać tę metodę, jeśli klasa zawiera dane, które nie są przechowywane przy użyciu właściwości zależności.  
  
 Typowa implementacja może wywołać podstawową, a następnie wywołaj statycznych <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> metody na wszystkich <see cref="T:System.Windows.Freezable" /> uwzględniających typy właściwości, które zawiera klasy, zwracając <see langword="true" /> tylko wtedy, gdy wszystkie właściwości zostały zablokowane (lub może być zablokowane, w przypadku określenia <see langword="true" /> dla <paramref name="isChecking" />).</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy kopię zablokowane <see cref="T:System.Windows.Freezable" />, przy użyciu wartości podstawowej właściwości (z systemem innym niż animowane). Ponieważ kopiowania jest zablokowana, wszystkie zablokowane obiekty podrzędne są kopiowane przez odwołanie.</summary>
        <returns>Zablokowane kopię <see cref="T:System.Windows.Freezable" />. Kopiuj <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość jest ustawiona na <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy sprawdzić <xref:System.Windows.Freezable.CanFreeze%2A> właściwość przed wywołaniem tej metody do sprawdzenia, czy <xref:System.Windows.Freezable> może być zablokowana. Za pomocą tej metody jest podobny do tworzenia kopii przy użyciu <xref:System.Windows.Freezable.Clone%2A> , a następnie go przy użyciu zamrażanie <xref:System.Windows.Freezable.Freeze%2A> metody.  
  
 <xref:System.Windows.Freezable.GetAsFrozen%2A> i <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> metody może poprawić wydajność kopiowania, ponieważ one nie Klonuj <xref:System.Windows.Freezable> podrzędnych obiektów które są już zablokowane; tylko kopiowania ich przez odwołanie.  
  
 W poniższej tabeli przedstawiono różnice między <xref:System.Windows.Freezable.GetAsFrozen%2A> i <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> metody.  
  
|Akcja|GetAsFrozen zachowanie — metoda|GetCurrentValueAsFrozen zachowanie — metoda|  
|------------|---------------------------------|---------------------------------------------|  
|Kopiowanie właściwości zależności, który znajduje się wyrażenie|Metoda zgłasza <xref:System.InvalidOperationException> , ponieważ nie jest <xref:System.Windows.Freezable.Freeze%2A> właściwości.|Bieżąca wartość wyrażenia jest kopiowana, ale nie wyrażenie.|  
|Kopiowanie właściwości animowany zależności|Wartość właściwości podstawowej (z systemem innym niż animowane) jest kopiowany. Animacji nie są kopiowane.|Bieżąca wartość animowanej właściwości jest kopiowana. Animacji nie są kopiowane.|  
  
 Należy pamiętać, że nie ustawiono właściwości nie są kopiowane ani nie są właściwościami tylko do odczytu.  
  
 Aby utworzyć kopię <xref:System.Windows.Freezable> oznacza to nie jest zablokowane, użyj <xref:System.Windows.Freezable.Clone%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Windows.Freezable" /> Nie może być zablokowany, ponieważ zawiera ona właściwości animowany lub wyrażenia.</exception>
        <block subset="none" type="overrides">
          <para>Ta metoda używa wirtualnego <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> metody w celu utworzenia klonu.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Wystąpienie do skopiowania.</param>
        <summary>Sprawia, że wystąpienie zablokowane klonowania określonego <see cref="T:System.Windows.Freezable" /> przy użyciu wartości podstawowej właściwości (z systemem innym niż animowane).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez <xref:System.Windows.Freezable.GetAsFrozen%2A> metody i nie należy wywoływać bezpośrednio w kodzie, z wyjątkiem podczas wywoływania metody implementacji podstawowej podczas przesłaniania tej metody. Aby utworzyć kopię zablokowane bieżący obiekt, należy wywołać <xref:System.Windows.Freezable.GetAsFrozen%2A> zamiast bezpośrednio wywołaniem tej metody.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Jeśli pochodzi od <see cref="T:System.Windows.Freezable" /> należy przesłonić tę metodę. Aby zastąpić przyczyny poniżej:  
  
-   Klasy pochodne ma dane, które nie jest dostępna za pośrednictwem właściwości zależności.  
  
-   Klasy pochodne należy wykonać dodatkową inicjację pracy, którego nie można osiągnąć przez zastąpienie po prostu <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Na przykład, to ma zastosowanie, gdy implementuje klasy pochodnej <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
 Nie trzeba zastąpienie klas, które są przechowywane w właściwości zależności wszystkich danych i że nie trzeba wykonywać dodatkowe inicjalizację <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />.  
  
 Istotne jest, że wszystkie implementacje wywoływać implementację podstawową tej metody. Implementacje należy wykonywać tylko pracy, który nie jest wykonywane przez domyślną implementację. Domyślna implementacja tworzy kopie głębokie żadnych obiektów freezable odblokowanej i skrócona kopie wszystkich pozostałych zapisywalny, lokalnie Ustawianie właściwości, które zawiera. Jeśli obiekt ma właściwości zależności powiązane z danymi, wyrażenia są kopiowane, ale nie może rozpoznać; Aby uzyskać więcej informacji na temat klonowania obiektów powiązanych z danymi, zobacz [obiektu Freezable Przegląd obiektów](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Jeśli obiekt ma właściwości zależności animowany, są kopiowane podstawowej (z systemem innym niż animowane) wartości tych właściwości. Animacji nie są kopiowane.  
  
 Należy pamiętać, że nie ustawiono właściwości nie są kopiowane ani nie są właściwościami tylko do odczytu.  
  
 Jeśli przesłonić tę metodę, musi wywoływać implementację podstawową.  
  
 Nie trzeba <see cref="M:System.Windows.Freezable.Freeze" /> wartości, ponieważ są one kopiowane.  Wynik jest zablokowana przez <see cref="M:System.Windows.Freezable.GetAsFrozen" /> przed zwróceniem.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy kopię zablokowane <see cref="T:System.Windows.Freezable" /> przy użyciu bieżącej wartości właściwości. Ponieważ kopiowania jest zablokowana, wszystkie zablokowane obiekty podrzędne są kopiowane przez odwołanie.</summary>
        <returns>Zablokowane kopię <see cref="T:System.Windows.Freezable" />. Kopiuj <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość jest ustawiona na <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą tej metody jest podobny do tworzenia kopii przy użyciu <xref:System.Windows.Freezable.CloneCurrentValue%2A> , a następnie go przy użyciu zamrażanie <xref:System.Windows.Freezable.Freeze%2A> metody.  
  
 <xref:System.Windows.Freezable.GetAsFrozen%2A> i <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> metody może poprawić wydajność kopiowania, ponieważ one nie Klonuj <xref:System.Windows.Freezable> podrzędnych obiektów które są już zablokowane; tylko kopiowania ich przez odwołanie.  
  
 W poniższej tabeli przedstawiono różnice między <xref:System.Windows.Freezable.GetAsFrozen%2A> i <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> metody.  
  
|Akcja|GetAsFrozen zachowanie — metoda|GetCurrentValueAsFrozen zachowanie — metoda|  
|------------|---------------------------------|---------------------------------------------|  
|Kopiowanie właściwości zależności, który znajduje się wyrażenie|Metoda zgłasza <xref:System.InvalidOperationException> , ponieważ nie jest <xref:System.Windows.Freezable.Freeze%2A> właściwości.|Bieżąca wartość wyrażenia jest kopiowana, ale nie wyrażenie.|  
|Kopiowanie właściwości animowany zależności|Wartość właściwości podstawowej (z systemem innym niż animowane) jest kopiowany. Animacji nie są kopiowane.|Bieżąca wartość animowanej właściwości jest kopiowana. Animacji nie są kopiowane.|  
  
 Należy pamiętać, że nie ustawiono właściwości nie są kopiowane ani nie są właściwościami tylko do odczytu.  
  
 Aby utworzyć kopię <xref:System.Windows.Freezable> oznacza to nie jest zablokowane, użyj <xref:System.Windows.Freezable.CloneCurrentValue%2A> metody.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ta metoda używa wirtualnego <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> metody w celu utworzenia klonu.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <see cref="T:System.Windows.Freezable" /> Do skopiowania i zablokować.</param>
        <summary>Sprawia, że bieżące wystąpienie zablokowane klonowania określonego <see cref="T:System.Windows.Freezable" />. Jeśli obiekt ma właściwości zależności animowany, ich bieżącymi wartościami animowany są kopiowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> metody i nie należy wywoływać bezpośrednio w kodzie, z wyjątkiem podczas wywoływania metody implementacji podstawowej podczas przesłaniania tej metody. Aby utworzyć kopię zablokowane bieżący obiekt, należy wywołać <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> zamiast bezpośrednio wywołaniem tej metody.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Jeśli pochodzi od <see cref="T:System.Windows.Freezable" />, konieczne może być przesłonić tę metodę. Aby zastąpić przyczyny poniżej:  
  
-   Klasy pochodne ma dane, które nie jest dostępna za pośrednictwem właściwości zależności.  
  
-   Klasy pochodne należy wykonać dodatkową inicjację pracy, którego nie można osiągnąć przez zastąpienie po prostu <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Na przykład, to ma zastosowanie, gdy implementuje klasy pochodnej <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
 Nie trzeba zastąpienie klas, które są przechowywane w właściwości zależności wszystkich danych i że nie trzeba wykonywać dodatkowe inicjalizację <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />.  
  
 Istotne jest, że wszystkie implementacje wywoływać implementację podstawową tej metody. Implementacje należy wykonywać tylko pracy, który nie jest wykonywane przez domyślną implementację. Domyślna implementacja tworzy nową <see cref="T:System.Windows.Freezable" /> przy użyciu <see cref="M:System.Windows.Freezable.CreateInstance" /> lokalnie ustawione właściwości zawiera metody i sprawia, że kopie głębokie odblokowanej obiektów freezable i skrócona kopie wszystkich pozostałych zapisywalny. Jeśli obiekt ma właściwości zależności powiązane z danymi, powiązania danych są kopiowane, ale nie może rozpoznać; Aby uzyskać więcej informacji na temat klonowania obiektów powiązanych z danymi, zobacz [obiektu Freezable Przegląd obiektów](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Jeśli obiekt ma animowany właściwości zależności, animowany bieżącą wartość właściwości jest kopiowana, ale animacji nie są.  
  
 Właściwości tylko do odczytu zależności w ramach <see cref="T:System.Windows.Freezable" /> nie są kopiowane przez tę implementację domyślnej.  
  
 Jeśli przesłonić tę metodę, musi wywoływać implementację podstawową.  
  
 Nie trzeba <see cref="M:System.Windows.Freezable.Freeze" /> wartości, ponieważ są one kopiowane.  Wynik jest zablokowana przez <see cref="M:System.Windows.Freezable.GetAsFrozen" /> przed zwróceniem.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy obiekt jest obecnie można modyfikować.</summary>
        <value>
          <see langword="true" /> Jeśli obiekt jest zablokowany i nie można zmodyfikować; <see langword="false" /> Jeśli obiekt może być modyfikowany.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Próba zmodyfikowania obiektu po jego <xref:System.Windows.Freezable.IsFrozen%2A> właściwość jest `true` zgłasza <xref:System.InvalidOperationException>.  
  
 Ta właściwość jest tylko do odczytu z punktu widzenia modelu obiektu. Niektóre dokumentację dotyczącą <xref:System.Windows.Freezable> mogą zawierać zachowania "ustawia <xref:System.Windows.Freezable.IsFrozen%2A> do `true`" lub podobne języka Omawiając zachowanie innych metod <xref:System.Windows.Freezable>, ale to zachowanie jest wykonywane wewnętrznie w wystąpień klas gdy metody wystąpienia manipulować zmiennych prywatnych, które istnieje w klasie abstrakcyjnej. Aby ustawić wartość tej właściwości, należy wywołać <xref:System.Windows.Freezable.Freeze%2A>. Jest to jednorazowa operacja zmiany <xref:System.Windows.Freezable.IsFrozen%2A> właściwości, początkową domyślnej `false` stan `true` stanu. Brak ma możliwości można ustawić wartości do `false`. Zamiast tego można zmienić żadnych bezpośrednich kopii oryginalnej (zobacz <xref:System.Windows.Freezable.Clone%2A> metody). Jest to zgodne z założeniami, sposób dowolnej klasy pochodnej zachowania w przypadku gdy jest stosowany do przypadków gdzie <xref:System.Windows.Freezable> wzorzec jest użyteczne.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywoływane, gdy bieżący <see cref="T:System.Windows.Freezable" /> obiektu jest modyfikowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przy każdym <xref:System.Windows.Freezable.Changed> zdarzenie.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Podczas implementacji klasy, która jest pochodną <see cref="T:System.Windows.Freezable" />, mogą zastąpić tę metodę w celu wykonywania zadań.</para>
        </block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapewnia ustanowienie wskaźniki odpowiedniego kontekstu dla elementu członkowskiego danych typu <see cref="T:System.Windows.DependencyObject" /> które właśnie zostały zmodyfikowane.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">Poprzedniej wartości elementu członkowskiego danych.</param>
        <param name="newValue">Bieżąca wartość elementu członkowskiego danych.</param>
        <summary>Zapewnia, że wskaźniki odpowiedniego kontekstu są uruchamiane <see cref="T:System.Windows.DependencyObjectType" /> element członkowski danych, który został ustawiony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna być wywoływana <xref:System.Windows.Freezable> dziedziczenia zawsze <xref:System.Windows.DependencyObject> element członkowski danych, które nie są przechowywane jako <xref:System.Windows.DependencyProperty> jest ustawiona.  
  
 Ta metoda nie musi być wywołany dla elementu <xref:System.Windows.DependencyObject> elementy członkowskie danych, które są przechowywane przy użyciu <xref:System.Windows.DependencyProperty>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">Poprzedniej wartości elementu członkowskiego danych.</param>
        <param name="newValue">Bieżąca wartość elementu członkowskiego danych.</param>
        <param name="property">Właściwość zmienione.</param>
        <summary>Ten element członkowski obsługuje [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastrukturę i nie jest przeznaczona do użycia bezpośrednio w kodzie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzenia, który zawiera informacje o tym, które zmienić właściwości, a jego starej i nowej wartości.</param>
        <summary>Zastępuje <see cref="T:System.Windows.DependencyObject" /> implementacja <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> także wywołać żadnego <see cref="E:System.Windows.Freezable.Changed" /> programy obsługi zdarzeń w odpowiedzi na zmiany właściwości zależności typu <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane zdarzenia zawierają informacje o tylko <xref:System.Windows.Freezable> samej siebie. Uzyskiwaną żadnych informacji o właściwościach podrzędnych <xref:System.Windows.Freezable.Changed> programów obsługi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia, że <see cref="T:System.Windows.Freezable" /> jest uzyskiwany z prawidłową wątku. Dziedziczenia z <see cref="T:System.Windows.Freezable" /> musi wywołać tę metodę na początku dowolnego [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] które odczytuje elementy członkowskie danych, które nie są właściwości zależności.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Klasy, które pochodzą z <see cref="T:System.Windows.Freezable" /> powinny wywoływać <see cref="M:System.Windows.Freezable.ReadPreamble" /> metody, zanim będzie mogła uzyskać dostępu do żadnych elementów członkowskich, które nie są właściwościami zależności. <see cref="M:System.Windows.Freezable.WritePreamble" /> Metoda powinna być wywoływana przed takie elementy członkowskie są zapisywane.  
  
 Ta metoda skutecznie nie robi nic więcej niż wywołania <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zgłasza <see cref="E:System.Windows.Freezable.Changed" /> zdarzenia dla <see cref="T:System.Windows.Freezable" /> i wywołuje jego <see cref="M:System.Windows.Freezable.OnChanged" /> metody. Klasy, które pochodzą z <see cref="T:System.Windows.Freezable" /> powinny wywoływać tej metody na końcu jakiegokolwiek interfejsu API, który modyfikuje elementów członkowskich klasy, które nie są przechowywane jako właściwości zależności.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Klasy, które pochodzą z <see cref="T:System.Windows.Freezable" /> powinny wywoływać tej metody na końcu jakiegokolwiek interfejsu API, który modyfikuje element członkowski klasy, która nie jest przechowywana jako <see cref="T:System.Windows.DependencyProperty" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sprawdza, czy <see cref="T:System.Windows.Freezable" /> nie jest zablokowana i że jest uzyskiwany z prawidłowego kontekstu wątków. <see cref="T:System.Windows.Freezable" /> dziedziczenia powinny wywoływać tej metody na początku dowolnego [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] zapisuje elementy członkowskie danych, które nie są właściwości zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> można zweryfikować kontekście wątku jest dostępny i zgłasza wyjątek, jeśli <xref:System.Windows.Freezable> wystąpienie jest już zablokowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Windows.Freezable" /> Wystąpienie jest zablokowane i nie może mieć jej elementów członkowskich zapisane.</exception>
        <block subset="none" type="overrides">
          <para>Klasy, które pochodzą z <see cref="T:System.Windows.Freezable" /> powinny wywoływać <see cref="M:System.Windows.Freezable.WritePreamble" /> przed ponowieniem próby zapisu do żadnych elementów członkowskich, które nie są właściwości zależności. Jeśli należy wywołać <see cref="M:System.Windows.Freezable.WritePreamble" /> w [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)], można pominąć wywołanie <see cref="M:System.Windows.Freezable.ReadPreamble" />.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>
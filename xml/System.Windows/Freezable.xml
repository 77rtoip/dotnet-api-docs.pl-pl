<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="12a1be02c542dfe0d4b2b31c8c4e0fbee60ca7d5" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37549384" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Freezable = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Definiuje obiekt, który ma stan, można modyfikować i stanie (zablokowane) tylko do odczytu. Klasy, które wynikają z <see cref="T:System.Windows.Freezable" /> zapewniają szczegółowe powiadomienia, można wprowadzić niezmienne i można sklonować samodzielnie.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable> Klasa oferuje funkcje specjalne, które mogą pomóc zwiększyć wydajność aplikacji, korzystając z obiektów, które są kosztowne modyfikowanie lub kopiowanie. Przykłady <xref:System.Windows.Freezable> obiektów obejmują następujące elementy:  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a>Wyprowadzanie z Freezable  
 Klasa, która pochodzi od klasy <xref:System.Windows.Freezable> uzyskuje się następujące funkcje:  
  
-   Stany specjalne: (zablokowane) stanie tylko do odczytu i zapisu stanu.  
  
-   Bezpieczeństwo wątków: zamrożone <xref:System.Windows.Freezable> obiektów mogą być współużytkowane przez wątków.  
  
-   Szczegółowe powiadomienia o zmianie: w odróżnieniu od innych <xref:System.Windows.DependencyObject> obiektów <xref:System.Windows.Freezable> obiekt zawiera powiadomienia o zmianie po zmianie wartości właściwości podrzędnych.  
  
-   Klonowanie proste: Freezable klasy zaimplementował już kilka metod, które tworzą klony głębokiego.  
  
 Aby uzyskać informacje na temat używania i tworzenia własnego <xref:System.Windows.Freezable> obiekty, zobacz [Przegląd obiektów Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).  
  
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie publiczne <see langword="static" /> elementy członkowskie tego typu są bezpieczne dla wątków. Wystąpienia elementów członkowskich nie dają gwarancji bezpieczeństwa wątków.  Gdy <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość <see langword="false" />, <see cref="T:System.Windows.Freezable" /> obiektu są dostępne tylko z wątku, na którym została utworzona. Podjęto próbę do niego dostęp z innego wątku zgłasza <see cref="T:System.InvalidOperationException" />. <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> i <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> metody zapewnienia obsługi kierowania poprawny wątek.  Po ich <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość <see langword="true" />, <see cref="T:System.Windows.Freezable" /> obiekty są bezwątkowy.  Aby uzyskać więcej informacji zobacz [Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md) obiektów Freezable.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Freezable" /> klasy pochodnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to Konstruktor chroniony dostępność klasy abstrakcyjnej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFreeze : bool" Usage="System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy obiekt jest możliwe niemodyfikowalnych.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący obiekt jest możliwe niemodyfikowalnych lub jest już niemodyfikowalnych; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Używa tej implementacji metody <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metody z <paramref name="isChecking" /> równa <see langword="true" /> ustalenie, czy <see cref="T:System.Windows.Freezable" /> możliwe niemodyfikowalnych. Aby zmodyfikować sposób tej właściwości, który zachowuje się w klasie pochodnej, należy zastąpić <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metody.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="T:System.Windows.Freezable" /> lub zawiera obiekt zostanie zmodyfikowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli użytkownik podejmie próbę Dodaj lub usuń programy obsługi zdarzeń, gdy bieżący obiekt nie jest modyfikowane przez (gdy <xref:System.Windows.Freezable.IsFrozen%2A> właściwość jest `true`), zgłaszany jest wyjątek.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Freezable" Usage="freezable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy klon można modyfikować <see cref="T:System.Windows.Freezable" />, wykonywania kopii głębokiego wartości obiektu. Podczas kopiowania obiektu właściwości zależności, ta metoda kopiuje wyrażeń, (które nie są już może rozwiązać), ale nie animacji lub ich bieżącymi wartościami.</summary>
        <returns>Można modyfikować klonowania bieżącego obiektu. Sklonowany obiekt <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość <see langword="false" /> nawet wtedy, gdy źródło <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość <see langword="true." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable.Clone%2A> i <xref:System.Windows.Freezable.CloneCurrentValue%2A> metod dać modyfikowalne klony zamrożone <xref:System.Windows.Freezable> obiektów (metody również sklonować <xref:System.Windows.Freezable> obiektów, które nie są zablokowane). Klon jest faktycznie głęboką kopię bieżącego obiektu.  
  
 Poniższa tabela zawiera podsumowanie różnic między <xref:System.Windows.Freezable.Clone%2A> i <xref:System.Windows.Freezable.CloneCurrentValue%2A> metody.  
  
|Akcja|Zachowanie metody klonowania|Zachowanie metody CloneCurrentValue|  
|------------|---------------------------|---------------------------------------|  
|Kopiowanie właściwości zależności, który zawiera wyrażenie|Wyrażenia są kopiowane, ale nie może rozwiązać. Aby uzyskać więcej informacji, zobacz [Przegląd obiektów Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|Bieżąca wartość wyrażenia są kopiowane, ale nie wyrażenie.|  
|Kopiowanie właściwości zależności animowane|Wartość właściwości podstawowej (bez animowane) są kopiowane. Animacje nie są kopiowane.|Bieżąca wartość animowany właściwości są kopiowane. Animacje nie są kopiowane.|  
  
 Należy pamiętać, że nie ustawiono właściwości nie są kopiowane. Jeśli przez nieustawioną właściwość ma wartość domyślną, która jest zablokowane <xref:System.Windows.Freezable>, że wartość właściwości jest zablokowany w inny sposób modyfikować klonowania.  
  
## <a name="move-a-freezable-between-threads"></a>Freezable być przenoszone między wątkami  
 Ta metoda może być przydatna do przenoszenia <xref:System.Windows.Freezable> między wątkami. Po pierwsze należy <xref:System.Windows.Freezable> niemodyfikowalnych przez wywołanie jego <xref:System.Windows.Freezable.Freeze%2A> metody. Teraz mogą uzyskiwać dostęp do innego wątku <xref:System.Windows.Freezable> i lokalnym <xref:System.Windows.Freezable.Clone%2A> których może uzyskać dostęp.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ta metoda używa <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> do tworzenia klonu. Aby zmodyfikować zachowanie tej metody w klasie pochodnej, Zastąp <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> metody.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Obiekt do klonowania.</param>
        <summary>Sprawia, że wystąpienie klonowania (głęboka kopia) określonego <see cref="T:System.Windows.Freezable" /> przy użyciu wartości podstawowej (bez animowane) właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana <xref:System.Windows.Freezable.Clone%2A> metody i nie należy wywoływać bezpośrednio w kodzie, z wyjątkiem podczas wywoływania implementację podstawową podczas przesłaniania tej metody. Aby utworzyć modyfikowalną kopię bieżącego obiektu, wywołaj <xref:System.Windows.Freezable.Clone%2A> zamiast bezpośrednio wywoływać tej metody.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku klasy wyprowadzonej z <see cref="T:System.Windows.Freezable" />, może być konieczne należy przesłonić tę metodę. Powody, aby zastąpić obejmują następujące elementy:-klasy pochodnej ma dane, które nie jest uwidaczniany za pomocą właściwości zależności.  -Klasy pochodnej, należy wykonać dodatkową inicjację pracy nie da się osiągnąć przez zastąpienie po prostu <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Na przykład, to ma zastosowanie, gdy swojej otrzymanej klasy implementuje <see cref="T:System.ComponentModel.ISupportInitialize" />.  Nie trzeba zastąpić klas, które przechowują wszystkie dane w właściwości zależności i że nie trzeba wykonywać dodatkowe inicjowanie <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.  Istotne jest, że wszystkich implementacjach wywoływać implementację podstawową tej metody. Implementacje tylko należy wykonywać pracę, która nie jest wykonywane przez domyślną implementację. Domyślna implementacja sprawia, że głębokiego kopie wszystkich właściwości zapisywalny, lokalnie ustawiony, w tym wewnętrznego wyrażeń.  Jeśli obiekt ma właściwości zależności powiązane z danymi, wyrażenia są kopiowane, ale nie może rozwiązać. Aby uzyskać więcej informacji na temat klonowania obiektów powiązanych z danymi Zobacz [Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md) obiektów Freezable. Jeśli obiekt ma właściwości animowany zależności, jest kopiowany (inne niż animowane) wartości bazowej tych właściwości. Animacje nie są kopiowane.  Należy pamiętać, że nie ustawiono właściwości nie są kopiowane ani nie są właściwości tylko do odczytu. Jeśli takiej właściwości ma wartość domyślną, która jest zamrożone <see cref="T:System.Windows.Freezable" />, że wartość właściwości jest zablokowany w inny sposób modyfikować klonowania.  Na poniższej liście podsumowano oczekiwane zachowanie tej metody:-kopiowania generowany zawiera kopię wszystkich <see cref="T:System.Windows.Freezable" /> obiektów podrzędnych.  — Właściwości nie ustawiono i tylko do odczytu nie są kopiowane.  -Wyrażenia są kopiowane.  -Brak tych obiektów podrzędnych są zablokowane podczas ich tworzenia.  -Kopii sam nie jest zamrożona.  -Animacji nie są kopiowane.  — Tylko wartości podstawowej właściwości są skopiowane, nie bieżącej wartości animowany.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Freezable" Usage="freezable.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Można modyfikować klonu (głęboka kopia) tworzy <see cref="T:System.Windows.Freezable" /> przy użyciu jego bieżących wartości.</summary>
        <returns>Można modyfikować klonowania bieżącego obiektu. Sklonowany obiekt <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość <see langword="false" /> nawet wtedy, gdy źródło <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość <see langword="true." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable.Clone%2A> i <xref:System.Windows.Freezable.CloneCurrentValue%2A> metod dać modyfikowalne klony zamrożone <xref:System.Windows.Freezable> obiektów (metody również sklonować <xref:System.Windows.Freezable> obiektów, które nie są zablokowane). Klon jest faktycznie głęboką kopię bieżącego obiektu.  
  
 Poniższa tabela zawiera podsumowanie różnic między <xref:System.Windows.Freezable.Clone%2A> i <xref:System.Windows.Freezable.CloneCurrentValue%2A> metody.  
  
|Akcja|Zachowanie metody klonowania|Zachowanie metody CloneCurrentValue|  
|------------|---------------------------|---------------------------------------|  
|Kopiowanie właściwości zależności, który zawiera wyrażenie|Wyrażenia są kopiowane, ale nie może rozwiązać. Aby uzyskać więcej informacji, zobacz [Przegląd obiektów Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|Bieżąca wartość wyrażenia są kopiowane, ale nie wyrażenie.|  
|Kopiowanie właściwości zależności animowane|Wartość właściwości podstawowej (bez animowane) są kopiowane. Animacje nie są kopiowane.|Bieżąca wartość animowany właściwości są kopiowane. Animacje nie są kopiowane.|  
  
 Należy pamiętać, że nie ustawiono właściwości nie są kopiowane. Jeśli przez nieustawioną właściwość ma wartość domyślną, która jest zablokowane <xref:System.Windows.Freezable>, że wartość właściwości jest zablokowany w inny sposób modyfikować klonowania.  
  
## <a name="move-a-freezable-between-threads"></a>Freezable być przenoszone między wątkami  
 Ta metoda może być przydatna do przenoszenia <xref:System.Windows.Freezable> między wątkami. Po pierwsze należy <xref:System.Windows.Freezable> niemodyfikowalnych przy użyciu jego <xref:System.Windows.Freezable.Freeze%2A> metody. Teraz mogą uzyskiwać dostęp do innego wątku <xref:System.Windows.Freezable> i lokalnego klona, których może uzyskać dostęp.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ta metoda używa <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> metody do tworzenia klonu; <see cref="T:System.Windows.Freezable" /> implementacje, które zastępują <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> należy upewnić się, że kopia nie jest zamrożony przy tworzeniu.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <see cref="T:System.Windows.Freezable" /> Można sklonować.</param>
        <summary>Sprawia, że wystąpienie można modyfikować klonowania (głęboka kopia) określonego <see cref="T:System.Windows.Freezable" /> przy użyciu bieżącej wartości właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana <xref:System.Windows.Freezable.CloneCurrentValue%2A> metody i nie należy wywoływać bezpośrednio w kodzie, z wyjątkiem podczas wywoływania implementację podstawową podczas przesłaniania tej metody. Aby utworzyć modyfikowalną kopię bieżącego obiektu, wywołaj <xref:System.Windows.Freezable.CloneCurrentValue%2A> zamiast bezpośrednio wywoływać tej metody.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku klasy wyprowadzonej z <see cref="T:System.Windows.Freezable" />, może być konieczne należy przesłonić tę metodę. Powody, aby zastąpić obejmują następujące elementy:-klasy pochodnej ma dane, które nie jest uwidaczniany za pomocą właściwości zależności.  -Klasy pochodnej, należy wykonać dodatkową inicjację pracy nie da się osiągnąć przez zastąpienie po prostu <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Na przykład, to ma zastosowanie, gdy swojej otrzymanej klasy implementuje <see cref="T:System.ComponentModel.ISupportInitialize" />.  Nie trzeba zastąpić klas, które przechowują wszystkie dane w właściwości zależności i że nie trzeba wykonywać dodatkowe inicjowanie <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />.  Istotne jest, że wszystkich implementacjach wywoływać implementację podstawową tej metody. Implementacje tylko należy wykonywać pracę, która nie jest wykonywane przez domyślną implementację. Domyślna implementacja tworzy głębokiego kopie wszystkich właściwości zapisywalny, lokalnie ustawiony. Jeśli obiekt zawiera właściwości zależności za pomocą wyrażeń (np. powiązania danych), bieżąca wartość wyrażenia jest kopiowana, ale nie wyrażenie.  Jeśli obiekt ma być animowany właściwości zależności, bieżąca wartość animowany te właściwości są kopiowane, ale animacji nie są.  Należy pamiętać, że nie ustawiono właściwości nie są kopiowane ani nie są właściwości tylko do odczytu. Jeśli takiej właściwości ma wartość domyślną, która jest zamrożone <see cref="T:System.Windows.Freezable" />, że wartość właściwości jest zablokowany w inny sposób modyfikować klonowania.  Na poniższej liście podsumowano oczekiwane zachowanie tej metody.  -Kopii generowany zawiera kopię wszystkich <see cref="T:System.Windows.Freezable" /> obiektów podrzędnych.  — Właściwości nie ustawiono i tylko do odczytu nie są kopiowane.  — Jeśli właściwość jest animowany, jego bieżąca wartość są kopiowane, ale animacji, sama nie jest.  -Brak tych obiektów podrzędnych są zablokowane podczas ich tworzenia.  -Kopii sam nie jest zamrożona.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Freezable" /> klasy.</summary>
        <returns>Nowe wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to metoda chroniona, a rzeczywiste implementacji określonego obiektu zachowania są zależne od implementacji zastąpienie <xref:System.Windows.Freezable.CreateInstanceCore%2A> metody, która wywołuje wewnętrznie ta metoda.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po zaimplementowaniu w klasie pochodnej tworzy nowe wystąpienie klasy <see cref="T:System.Windows.Freezable" /> klasy pochodnej.</summary>
        <returns>Nowe wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie wywołuj tej metody bezpośrednio (z wyjątkiem podczas wywoływania base w implementacji). Ta metoda jest wywoływana wewnętrznie przez <xref:System.Windows.Freezable.CreateInstance%2A> zawsze, gdy jest nowe wystąpienie klasy <xref:System.Windows.Freezable> zostanie utworzony.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano Typowa implementacja metody <xref:System.Windows.Freezable.CreateInstanceCore%2A>.  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Każdy <see cref="T:System.Windows.Freezable" /> klasy pochodnej musi implementować tej metody. Typowa implementacja jest po prostu wywołać konstruktora domyślnego i zwraca wynik.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sprawia, że <see cref="T:System.Windows.Freezable" /> niemodyfikowalnych i ustawia jego <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwości <see langword="true" />, lub testów czy <see cref="T:System.Windows.Freezable" /> obiektu jest możliwe niemodyfikowalnych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberSignature Language="F#" Value="member this.Freeze : unit -&gt; unit" Usage="freezable.Freeze " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sprawia, że bieżący obiekt jest niemodyfikowalnych i ustawia jego <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uniknąć możliwości <xref:System.InvalidOperationException> w wywołaniu tej metody, sprawdź <xref:System.Windows.Freezable.CanFreeze%2A> właściwości, aby określić, czy <xref:System.Windows.Freezable> można wprowadzić niemodyfikowalnych przed wywołaniem tej metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Windows.Freezable" /> Nie może zostać wykonana niemodyfikowalnych.</exception>
        <block subset="none" type="overrides">
          <para>Ta metoda używa <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metody <see cref="T:System.Windows.Freezable" /> niemodyfikowalnych. Aby zmodyfikować zachowanie zamrożenia, Zastąp <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metody.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberSignature Language="F#" Value="static member Freeze : System.Windows.Freezable * bool -&gt; bool" Usage="System.Windows.Freezable.Freeze (freezable, isChecking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">Obiekt do sprawdzania lub wprowadzania niemodyfikowalnych. Jeśli <c>isChecking</c> jest <see langword="true" />, obiekt jest sprawdzany w celu określenia, czy może on niemodyfikowalnych. Jeśli <c>isChecking</c> jest <see langword="false" />, obiekt ma zostać niemodyfikowalnych, jeśli jest to możliwe.</param>
        <param name="isChecking">
          <see langword="true" /> Aby zwrócić wskazanie, czy obiekt może być zablokowana (bez faktycznego zawiesza go); <see langword="false" /> można faktycznie zablokować obiektu.</param>
        <summary>Jeśli <paramref name="isChecking" /> parametr jest <see langword="true" />, metoda wskazuje czy określony <see cref="T:System.Windows.Freezable" /> możliwe niemodyfikowalnych. Jeśli <paramref name="isChecking" /> parametr jest <see langword="false" />, ta metoda próbuje wprowadzić określony <see cref="T:System.Windows.Freezable" /> niemodyfikowalnych i wskazuje, czy operacja zakończyła się pomyślnie.</summary>
        <returns>Jeśli <paramref name="isChecking" /> jest <see langword="true" />, Metoda ta zwraca <see langword="true" /> Jeśli określony <see cref="T:System.Windows.Freezable" /> możliwe niemodyfikowalnych, lub <see langword="false" /> Jeśli nie można dokonać niemodyfikowalnych. Jeśli <paramref name="isChecking" /> jest <see langword="false" />, Metoda ta zwraca <see langword="true" /> Jeśli określony <see cref="T:System.Windows.Freezable" /> jest teraz niemodyfikowalnych, lub <see langword="false" /> Jeśli nie można dokonać niemodyfikowalnych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie wywołuj tej metody, chyba że są pochodząca od <xref:System.Windows.Freezable> i zastępowanie <xref:System.Windows.Freezable.FreezeCore%2A> metody.  Ta metoda może być używany w <xref:System.Windows.Freezable.FreezeCore%2A> metodę, aby zablokować składowych danych klas, które znajdują się <xref:System.Windows.Freezable> obiektów.  
  
 Jest tak jest ponownie wywołać tę metodę w <xref:System.Windows.Freezable> obiekt, który jest już zablokowany (niemodyfikowalnych).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Gdy <paramref name="isChecking" /> jest <see langword="false" />, próba wykonania <paramref name="freezable" /> niemodyfikowalnych nie powiodła się; obiekt jest teraz w nieznanym stanie (go może być częściowo zamrożona).</exception>
        <block subset="none" type="overrides">
          <para>Ta metoda używa <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metody <see cref="T:System.Windows.Freezable" /> niemodyfikowalnych. Aby zmodyfikować zachowanie zamrożenia, Zastąp <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metody.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="freezable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">
          <see langword="true" /> Aby zwrócić wskazanie, czy obiekt może być zablokowana (bez faktycznego zawiesza go); <see langword="false" /> można faktycznie zablokować obiektu.</param>
        <summary>Sprawia, że <see cref="T:System.Windows.Freezable" /> obiektu niemodyfikowalnych lub sprawdza, czy może on niemodyfikowalnych.</summary>
        <returns>Jeśli <paramref name="isChecking" /> jest <see langword="true" />, Metoda ta zwraca <see langword="true" /> Jeśli <see cref="T:System.Windows.Freezable" /> możliwe niemodyfikowalnych, lub <see langword="false" /> Jeśli nie można dokonać niemodyfikowalnych. Jeśli <paramref name="isChecking" /> jest <see langword="false" />, Metoda ta zwraca <see langword="true" /> Jeśli czy określonego <see cref="T:System.Windows.Freezable" /> jest teraz niemodyfikowalnych, lub <see langword="false" /> Jeśli nie można dokonać niemodyfikowalnych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie wywołuj tej metody bezpośrednio (z wyjątkiem podczas wywoływania base w implementacji). Ta metoda jest wywoływana wewnętrznie przez <xref:System.Windows.Freezable.CanFreeze%2A> właściwości (przy użyciu `isChecking` równa `true`) i <xref:System.Windows.Freezable.Freeze%2A> — metoda (przy użyciu `isChecking` równa `false`).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.Freezable" /> implementujące obiekty muszą przesłaniać tę metodę, gdy klasa zawiera dane, które nie są przechowywane przy użyciu właściwości zależności.  Typowa implementacja może wywołać podstawowej, a następnie wywołaj statyczną <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> metody na wszystkich <see cref="T:System.Windows.Freezable" /> uwzględniających typy właściwości, które zawiera klasy, zwracając <see langword="true" /> tylko wtedy, gdy wszystkie właściwości zostały zamrożone (lub może zostały zamrożone, w przypadku określenia <see langword="true" /> dla <paramref name="isChecking" />).</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy kopię zamrożone <see cref="T:System.Windows.Freezable" />, przy użyciu wartości podstawowej (bez animowane) właściwości. Ponieważ kopia zostanie zamrożona, wszelkie zamrożone obiekty podrzędne są kopiowane przez odwołanie.</summary>
        <returns>Zamrożone kopię <see cref="T:System.Windows.Freezable" />. Kopiuj <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość jest ustawiona na <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy sprawdzić <xref:System.Windows.Freezable.CanFreeze%2A> właściwości przed wywołaniem tej metody, aby sprawdzić, czy <xref:System.Windows.Freezable> może być zablokowany. Przy użyciu tej metody jest podobny do procesu tworzenia, kopiowania za pomocą <xref:System.Windows.Freezable.Clone%2A> i następnie zawiesza się ją za pomocą <xref:System.Windows.Freezable.Freeze%2A> metody.  
  
 <xref:System.Windows.Freezable.GetAsFrozen%2A> i <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> metody może poprawić wydajność kopiowania, ponieważ ich nie Klonuj <xref:System.Windows.Freezable> obiekty podrzędne już jest zablokowany; w ich kopiować tylko je przez odwołanie.  
  
 Poniższa tabela zawiera podsumowanie różnic między <xref:System.Windows.Freezable.GetAsFrozen%2A> i <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> metody.  
  
|Akcja|Zachowanie metody GetAsFrozen|Zachowanie metody GetCurrentValueAsFrozen|  
|------------|---------------------------------|---------------------------------------------|  
|Kopiowanie właściwości zależności, który zawiera wyrażenie|Metoda zgłasza <xref:System.InvalidOperationException> , ponieważ nie jest <xref:System.Windows.Freezable.Freeze%2A> właściwości.|Bieżąca wartość wyrażenia są kopiowane, ale nie wyrażenie.|  
|Kopiowanie właściwości zależności animowane|Wartość właściwości podstawowej (bez animowane) są kopiowane. Animacje nie są kopiowane.|Bieżąca wartość animowany właściwości są kopiowane. Animacje nie są kopiowane.|  
  
 Należy pamiętać, że nie ustawiono właściwości nie są kopiowane ani nie są właściwości tylko do odczytu.  
  
 Aby utworzyć kopię <xref:System.Windows.Freezable> to znaczy nie zamrożone, użyj <xref:System.Windows.Freezable.Clone%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Windows.Freezable" /> Nie można zablokować, ponieważ zawiera wyrażenia lub właściwości animowany.</exception>
        <block subset="none" type="overrides">
          <para>Ta metoda używa wirtualnego <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> metody do tworzenia klonu.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Wystąpienie do skopiowania.</param>
        <summary>Sprawia, że wystąpienie zamrożone klonowania określonego <see cref="T:System.Windows.Freezable" /> przy użyciu wartości podstawowej (bez animowane) właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana <xref:System.Windows.Freezable.GetAsFrozen%2A> metody i nie należy wywoływać bezpośrednio w kodzie, z wyjątkiem podczas wywoływania implementację podstawową podczas przesłaniania tej metody. Aby utworzyć zamrożone kopię bieżącego obiektu, wywołaj <xref:System.Windows.Freezable.GetAsFrozen%2A> zamiast bezpośrednio wywoływać tej metody.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku klasy wyprowadzonej z <see cref="T:System.Windows.Freezable" /> może być konieczne należy przesłonić tę metodę. Powody, aby zastąpić obejmują następujące elementy:-klasy pochodnej ma dane, które nie jest uwidaczniany za pomocą właściwości zależności.  -Klasy pochodnej, należy wykonać dodatkową inicjację pracy nie da się osiągnąć przez zastąpienie po prostu <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Na przykład, to ma zastosowanie, gdy swojej otrzymanej klasy implementuje <see cref="T:System.ComponentModel.ISupportInitialize" />.  Nie trzeba zastąpić klas, które przechowują wszystkie dane w właściwości zależności i że nie trzeba wykonywać dodatkowe inicjowanie <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />.  Istotne jest, że wszystkich implementacjach wywoływać implementację podstawową tej metody. Implementacje tylko należy wykonywać pracę, która nie jest wykonywane przez domyślną implementację. Domyślna implementacja tworzy głębokiego kopie wszelkich odblokowanej obiektów freezable i płytką kopię wszystkie inne zapisywalne, lokalnie zestaw właściwości zawartych w nim. Jeśli obiekt ma właściwości zależności powiązane z danymi, wyrażenia są kopiowane, ale nie może rozwiązać; Aby uzyskać więcej informacji na temat klonowania obiektów powiązanych z danymi Zobacz [Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md) obiektów Freezable. Jeśli obiekt ma właściwości animowany zależności, podstawowej (inne niż animowane) wartości tych właściwości są kopiowane. Animacje nie są kopiowane.  Należy pamiętać, że nie ustawiono właściwości nie są kopiowane ani nie są właściwości tylko do odczytu.  Jeśli zastąpisz tę metodę należy wywoływać implementację podstawową.  Nie trzeba <see cref="M:System.Windows.Freezable.Freeze" /> wartości, jak są one kopiowane.  Wynik jest zamrożony przez <see cref="M:System.Windows.Freezable.GetAsFrozen" /> przed zwróceniem.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentValueAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetCurrentValueAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy kopię zamrożone <see cref="T:System.Windows.Freezable" /> przy użyciu bieżącej wartości właściwości. Ponieważ kopia zostanie zamrożona, wszelkie zamrożone obiekty podrzędne są kopiowane przez odwołanie.</summary>
        <returns>Zamrożone kopię <see cref="T:System.Windows.Freezable" />. Kopiuj <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość jest ustawiona na <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przy użyciu tej metody jest podobny do procesu tworzenia, kopiowania za pomocą <xref:System.Windows.Freezable.CloneCurrentValue%2A> i następnie zawiesza się ją za pomocą <xref:System.Windows.Freezable.Freeze%2A> metody.  
  
 <xref:System.Windows.Freezable.GetAsFrozen%2A> i <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> metody może poprawić wydajność kopiowania, ponieważ ich nie Klonuj <xref:System.Windows.Freezable> obiekty podrzędne już jest zablokowany; w ich kopiować tylko je przez odwołanie.  
  
 Poniższa tabela zawiera podsumowanie różnic między <xref:System.Windows.Freezable.GetAsFrozen%2A> i <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> metody.  
  
|Akcja|Zachowanie metody GetAsFrozen|Zachowanie metody GetCurrentValueAsFrozen|  
|------------|---------------------------------|---------------------------------------------|  
|Kopiowanie właściwości zależności, który zawiera wyrażenie|Metoda zgłasza <xref:System.InvalidOperationException> , ponieważ nie jest <xref:System.Windows.Freezable.Freeze%2A> właściwości.|Bieżąca wartość wyrażenia są kopiowane, ale nie wyrażenie.|  
|Kopiowanie właściwości zależności animowane|Wartość właściwości podstawowej (bez animowane) są kopiowane. Animacje nie są kopiowane.|Bieżąca wartość animowany właściwości są kopiowane. Animacje nie są kopiowane.|  
  
 Należy pamiętać, że nie ustawiono właściwości nie są kopiowane ani nie są właściwości tylko do odczytu.  
  
 Aby utworzyć kopię <xref:System.Windows.Freezable> to znaczy nie zamrożone, użyj <xref:System.Windows.Freezable.CloneCurrentValue%2A> metody.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ta metoda używa wirtualnego <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> metody do tworzenia klonu.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <see cref="T:System.Windows.Freezable" /> Do skopiowania i blokowanie.</param>
        <summary>Sprawia, że bieżące wystąpienie zamrożone klonowania określonego <see cref="T:System.Windows.Freezable" />. Jeśli obiekt ma właściwości animowany zależności, są kopiowane ich bieżącymi wartościami animowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> metody i nie należy wywoływać bezpośrednio w kodzie, z wyjątkiem podczas wywoływania implementację podstawową podczas przesłaniania tej metody. Aby utworzyć zamrożone kopię bieżącego obiektu, wywołaj <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> zamiast bezpośrednio wywoływać tej metody.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku klasy wyprowadzonej z <see cref="T:System.Windows.Freezable" />, może być konieczne należy przesłonić tę metodę. Powody, aby zastąpić obejmują następujące elementy:-klasy pochodnej ma dane, które nie jest uwidaczniany za pomocą właściwości zależności.  -Klasy pochodnej, należy wykonać dodatkową inicjację pracy nie da się osiągnąć przez zastąpienie po prostu <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Na przykład, to ma zastosowanie, gdy swojej otrzymanej klasy implementuje <see cref="T:System.ComponentModel.ISupportInitialize" />.  Nie trzeba zastąpić klas, które przechowują wszystkie dane w właściwości zależności i że nie trzeba wykonywać dodatkowe inicjowanie <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />.  Istotne jest, że wszystkich implementacjach wywoływać implementację podstawową tej metody. Implementacje tylko należy wykonywać pracę, która nie jest wykonywane przez domyślną implementację. Domyślna implementacja tworzy nową <see cref="T:System.Windows.Freezable" /> przy użyciu <see cref="M:System.Windows.Freezable.CreateInstance" /> metody i sprawia, że kopie głębokiego odblokowanej obiektów freezable i płytką kopię wszystkie inne zapisywalne lokalnie Ustaw właściwości, które zawiera. Jeśli obiekt ma właściwości zależności powiązane z danymi, powiązań danych są kopiowane, ale nie może rozwiązać; Aby uzyskać więcej informacji na temat klonowania obiektów powiązanych z danymi Zobacz [Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md) obiektów Freezable. Jeśli obiekt ma być animowany właściwości zależności, bieżąca wartość animowany te właściwości są kopiowane, ale animacji nie są.  Właściwości zależności tylko do odczytu w ramach <see cref="T:System.Windows.Freezable" /> nie są kopiowane przez tę implementację domyślne.  Jeśli zastąpisz tę metodę należy wywoływać implementację podstawową.  Nie trzeba <see cref="M:System.Windows.Freezable.Freeze" /> wartości, jak są one kopiowane.  Wynik jest zamrożony przez <see cref="M:System.Windows.Freezable.GetAsFrozen" /> przed zwróceniem.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrozen : bool" Usage="System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy obiekt jest obecnie można modyfikować.</summary>
        <value>
          <see langword="true" /> Jeśli obiekt jest zablokowane i nie można zmodyfikować; <see langword="false" /> Jeśli obiekt może być modyfikowane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podjęto próbę modyfikacji obiektu podczas jego <xref:System.Windows.Freezable.IsFrozen%2A> właściwość `true` zgłasza <xref:System.InvalidOperationException>.  
  
 Ta właściwość jest tylko do odczytu z punktu widzenia modelu obiektu. Część dokumentacji dotyczącej <xref:System.Windows.Freezable> zachowania mogą zawierać "ustawia <xref:System.Windows.Freezable.IsFrozen%2A> do `true`" lub podobne języka podczas omawiania zachowanie inne metody <xref:System.Windows.Freezable>, ale to zachowanie jest wykonywane wewnętrznie w wystąpienia klasy gdy metody wystąpienia manipulować prywatnej zmiennych, które istnieją w ramach klasy abstrakcyjnej. Aby ustawić wartość tej właściwości, należy wywołać <xref:System.Windows.Freezable.Freeze%2A>. Jest to jednorazowa operacja, aby zmienić <xref:System.Windows.Freezable.IsFrozen%2A> właściwość początkowej domyślnej `false` do stanu `true` stanu. Brak nie dostępnych środków, można ustawić wartości do `false`. Zamiast tego można zmienić wszelkie głęboka kopia wprowadzone od oryginału (zobacz <xref:System.Windows.Freezable.Clone%2A> metody). Jest to celowe a jak dowolnej klasy pochodnej powinny zachowywać się po zastosowaniu do przypadków, gdy <xref:System.Windows.Freezable> wzorzec jest przydatny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : unit -&gt; unit&#xA;override this.OnChanged : unit -&gt; unit" Usage="freezable.OnChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywoływane, gdy bieżący <see cref="T:System.Windows.Freezable" /> obiekt zostanie zmodyfikowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana zawsze wtedy, gdy <xref:System.Windows.Freezable.Changed> wystąpi zdarzenie.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Podczas implementacji klasy, która pochodzi od klasy <see cref="T:System.Windows.Freezable" />, możesz zastąpić tę metodę w celu wykonywania zadań.</para>
        </block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapewnia, że wskaźniki odpowiedniego kontekstu są ustanowione dla składowej danych typu <see cref="T:System.Windows.DependencyObject" /> , właśnie zostały zmodyfikowane.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">Poprzednią wartość elementu danych.</param>
        <param name="newValue">Bieżąca wartość elementu danych.</param>
        <summary>Zapewnia, że odpowiedniego kontekstu wskaźniki są ustanowione dla <see cref="T:System.Windows.DependencyObjectType" /> składowej danych, która została ustawiona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna być wywoływana przez <xref:System.Windows.Freezable> obiektów dziedziczących każdorazowo <xref:System.Windows.DependencyObject> składowej danych, która nie jest przechowywany jako <xref:System.Windows.DependencyProperty> jest ustawiona.  
  
 Ta metoda nie musi być wywoływana dla <xref:System.Windows.DependencyObject> składowych danych, które są przechowywane przy użyciu <xref:System.Windows.DependencyProperty>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">Poprzednią wartość elementu danych.</param>
        <param name="newValue">Bieżąca wartość elementu danych.</param>
        <param name="property">Zmieniona właściwość.</param>
        <summary>Ten element członkowski obsługuje [! Infrastruktura include[TLA#tla_winclient](~/includes/tlasharptla-winclient-MD.MD)] i nie jest przeznaczona do użycia bezpośrednio w kodzie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="freezable.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzenia, który zawiera informacje o tym, które zmienić właściwości, a jego starej i nowej wartości.</param>
        <summary>Zastępuje <see cref="T:System.Windows.DependencyObject" /> implementacji <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> również wywołać żadnego <see cref="E:System.Windows.Freezable.Changed" /> obsługi w odpowiedzi na zmiany właściwości zależności typu <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane zdarzenia zawierają informacje dotyczące tylko <xref:System.Windows.Freezable> sam. Wszystkie informacje z właściwości podrzędnych należy uzyskać za pośrednictwem <xref:System.Windows.Freezable.Changed> programów obsługi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberSignature Language="F#" Value="member this.ReadPreamble : unit -&gt; unit" Usage="freezable.ReadPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia, że <see cref="T:System.Windows.Freezable" /> jest uzyskiwany z prawidłową wątku. Obiektów dziedziczących z <see cref="T:System.Windows.Freezable" /> musi wywołać tę metodę na początku dowolnego [! INCLUDE[TLA#tla_api](~/includes/tlasharptla-API-MD.MD)], odczytuje składowych danych, które nie są właściwościami zależności.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Klasy, które wynikają z <see cref="T:System.Windows.Freezable" /> powinny wywoływać <see cref="M:System.Windows.Freezable.ReadPreamble" /> metodę, zanim spróbuje uzyskać dostęp wszystkie elementy członkowskie, które nie są właściwościami zależności. <see cref="M:System.Windows.Freezable.WritePreamble" /> Metoda powinna być wywoływana przed takich elementów członkowskich są zapisywane.  Ta metoda skutecznie nic nie robi więcej niż wywołania <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberSignature Language="F#" Value="member this.WritePostscript : unit -&gt; unit" Usage="freezable.WritePostscript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywołuje <see cref="E:System.Windows.Freezable.Changed" /> zdarzenie <see cref="T:System.Windows.Freezable" /> i wywołuje jego <see cref="M:System.Windows.Freezable.OnChanged" /> metody. Klasy, które wynikają z <see cref="T:System.Windows.Freezable" /> powinna wywołać tę metodę na końcu dowolnego interfejsu API, który modyfikuje składowych klasy, które nie są przechowywane jako właściwości zależności.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Klasy, które wynikają z <see cref="T:System.Windows.Freezable" /> powinna wywołać tę metodę na końcu dowolnego interfejsu API, który modyfikuje element członkowski klasy, które nie są przechowywane jako <see cref="T:System.Windows.DependencyProperty" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberSignature Language="F#" Value="member this.WritePreamble : unit -&gt; unit" Usage="freezable.WritePreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sprawdza, czy <see cref="T:System.Windows.Freezable" /> nie jest zablokowane i że jest on dostępny z prawidłowego kontekstu wątków. <see cref="T:System.Windows.Freezable" /> obiektów dziedziczących powinna wywołać tę metodę na początku dowolnego [! INCLUDE[TLA#tla_api](~/includes/tlasharptla-API-MD.MD)], która zapisuje do składowych danych, które nie są właściwościami zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> Aby sprawdzić wątkowości kontekstu jest dostępny, i zgłasza wyjątek, jeśli <xref:System.Windows.Freezable> wystąpienia jest już zablokowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Windows.Freezable" /> Wystąpienia jest zablokowane i nie ma składowych zapisać.</exception>
        <block subset="none" type="overrides">
          <para>Klasy, które wynikają z <see cref="T:System.Windows.Freezable" /> powinny wywoływać <see cref="M:System.Windows.Freezable.WritePreamble" /> przed podjęciem próby zapisywać żadnych elementów członkowskich, które nie są właściwościami zależności. Jeśli wywołasz <see cref="M:System.Windows.Freezable.WritePreamble" /> w [! INCLUDE[TLA#tla_api](~/includes/tlasharptla-API-MD.MD)], można pominąć wywołanie <see cref="M:System.Windows.Freezable.ReadPreamble" />.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>
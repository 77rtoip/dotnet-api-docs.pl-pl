<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="12a1be02c542dfe0d4b2b31c8c4e0fbee60ca7d5" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37549384" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Freezable = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="1385c-101">Definiuje obiekt, który ma stan, można modyfikować i stanie (zablokowane) tylko do odczytu.</span>
      <span class="sxs-lookup">
        <span data-stu-id="1385c-101">Defines an object that has a modifiable state and a read-only (frozen) state.</span>
      </span>
      <span data-ttu-id="1385c-102">Klasy, które wynikają z <see cref="T:System.Windows.Freezable" /> zapewniają szczegółowe powiadomienia, można wprowadzić niezmienne i można sklonować samodzielnie.</span>
      <span class="sxs-lookup">
        <span data-stu-id="1385c-102">Classes that derive from <see cref="T:System.Windows.Freezable" /> provide detailed change notification, can be made immutable, and can clone themselves.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1385c-103"><xref:System.Windows.Freezable> Klasa oferuje funkcje specjalne, które mogą pomóc zwiększyć wydajność aplikacji, korzystając z obiektów, które są kosztowne modyfikowanie lub kopiowanie.</span><span class="sxs-lookup"><span data-stu-id="1385c-103">The <xref:System.Windows.Freezable> class provides special features that can help improve application performance when using objects that are expensive to modify or copy.</span></span> <span data-ttu-id="1385c-104">Przykłady <xref:System.Windows.Freezable> obiektów obejmują następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="1385c-104">Examples of <xref:System.Windows.Freezable> objects include the following:</span></span>  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a><span data-ttu-id="1385c-105">Wyprowadzanie z Freezable</span><span class="sxs-lookup"><span data-stu-id="1385c-105">Deriving From Freezable</span></span>  
 <span data-ttu-id="1385c-106">Klasa, która pochodzi od klasy <xref:System.Windows.Freezable> uzyskuje się następujące funkcje:</span><span class="sxs-lookup"><span data-stu-id="1385c-106">A class that derives from <xref:System.Windows.Freezable> gains the following features:</span></span>  
  
-   <span data-ttu-id="1385c-107">Stany specjalne: (zablokowane) stanie tylko do odczytu i zapisu stanu.</span><span class="sxs-lookup"><span data-stu-id="1385c-107">Special states: a read-only (frozen) state and a writable state.</span></span>  
  
-   <span data-ttu-id="1385c-108">Bezpieczeństwo wątków: zamrożone <xref:System.Windows.Freezable> obiektów mogą być współużytkowane przez wątków.</span><span class="sxs-lookup"><span data-stu-id="1385c-108">Thread safety: a frozen <xref:System.Windows.Freezable> object can be shared across threads.</span></span>  
  
-   <span data-ttu-id="1385c-109">Szczegółowe powiadomienia o zmianie: w odróżnieniu od innych <xref:System.Windows.DependencyObject> obiektów <xref:System.Windows.Freezable> obiekt zawiera powiadomienia o zmianie po zmianie wartości właściwości podrzędnych.</span><span class="sxs-lookup"><span data-stu-id="1385c-109">Detailed change notification: Unlike other <xref:System.Windows.DependencyObject> objects, a <xref:System.Windows.Freezable> object provides change notifications when sub-property values change.</span></span>  
  
-   <span data-ttu-id="1385c-110">Klonowanie proste: Freezable klasy zaimplementował już kilka metod, które tworzą klony głębokiego.</span><span class="sxs-lookup"><span data-stu-id="1385c-110">Easy cloning: the Freezable class has already implemented several methods that produce deep clones.</span></span>  
  
 <span data-ttu-id="1385c-111">Aby uzyskać informacje na temat używania i tworzenia własnego <xref:System.Windows.Freezable> obiekty, zobacz [Przegląd obiektów Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span><span class="sxs-lookup"><span data-stu-id="1385c-111">For information on using and creating your own <xref:System.Windows.Freezable> objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="1385c-112">Wszystkie publiczne <see langword="static" /> elementy członkowskie tego typu są bezpieczne dla wątków.</span>
      <span class="sxs-lookup">
        <span data-stu-id="1385c-112">Any public <see langword="static" /> members of this type are thread safe.</span>
      </span>
      <span data-ttu-id="1385c-113">Wystąpienia elementów członkowskich nie dają gwarancji bezpieczeństwa wątków.</span>
      <span class="sxs-lookup">
        <span data-stu-id="1385c-113">Any instance members are not guaranteed to be thread safe.</span>
      </span>
      <span data-ttu-id="1385c-114">Gdy <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość <see langword="false" />, <see cref="T:System.Windows.Freezable" /> obiektu są dostępne tylko z wątku, na którym została utworzona.</span>
      <span class="sxs-lookup">
        <span data-stu-id="1385c-114">When the <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" />, a <see cref="T:System.Windows.Freezable" /> object can be accessed only from the thread on which it was created.</span>
      </span>
      <span data-ttu-id="1385c-115">Podjęto próbę do niego dostęp z innego wątku zgłasza <see cref="T:System.InvalidOperationException" />.</span>
      <span class="sxs-lookup">
        <span data-stu-id="1385c-115">Attempting to access it from another thread throws an <see cref="T:System.InvalidOperationException" />.</span>
      </span>
      <span data-ttu-id="1385c-116">
        <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> i <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> metody zapewnienia obsługi kierowania poprawny wątek.</span>
      <span class="sxs-lookup">
        <span data-stu-id="1385c-116">The <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> and <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> methods provide support for marshalling to the correct thread.</span>
      </span>
      <span data-ttu-id="1385c-117">Po ich <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość <see langword="true" />, <see cref="T:System.Windows.Freezable" /> obiekty są bezwątkowy.</span>
      <span class="sxs-lookup">
        <span data-stu-id="1385c-117">When their <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true" />, <see cref="T:System.Windows.Freezable" /> objects are free-threaded.</span>
      </span>
      <span data-ttu-id="1385c-118">Aby uzyskać więcej informacji zobacz [Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md) obiektów Freezable.</span>
      <span class="sxs-lookup">
        <span data-stu-id="1385c-118">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1385c-119">Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Freezable" /> klasy pochodnej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-119">Initializes a new instance of a <see cref="T:System.Windows.Freezable" /> derived class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1385c-120">Jest to Konstruktor chroniony dostępność klasy abstrakcyjnej.</span><span class="sxs-lookup"><span data-stu-id="1385c-120">This is the protected-accessibility constructor of an abstract class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFreeze : bool" Usage="System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="1385c-121">Pobiera wartość wskazującą, czy obiekt jest możliwe niemodyfikowalnych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-121">Gets a value that indicates whether the object can be made unmodifiable.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="1385c-122">
            <see langword="true" /> Jeśli bieżący obiekt jest możliwe niemodyfikowalnych lub jest już niemodyfikowalnych; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-122">
              <see langword="true" /> if the current object can be made unmodifiable or is already unmodifiable; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="1385c-123">
            <para>Używa tej implementacji metody <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metody z <paramref name="isChecking" /> równa <see langword="true" /> ustalenie, czy <see cref="T:System.Windows.Freezable" /> możliwe niemodyfikowalnych. Aby zmodyfikować sposób tej właściwości, który zachowuje się w klasie pochodnej, należy zastąpić <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metody.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-123">
              <para>This method implementation uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method with <paramref name="isChecking" /> set to <see langword="true" /> to determine whether a <see cref="T:System.Windows.Freezable" /> can be made unmodifiable. To modify the way this property behaves in a derived class, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="1385c-124">Występuje, gdy <see cref="T:System.Windows.Freezable" /> lub zawiera obiekt zostanie zmodyfikowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-124">Occurs when the <see cref="T:System.Windows.Freezable" /> or an object it contains is modified.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1385c-125">Jeśli użytkownik podejmie próbę Dodaj lub usuń programy obsługi zdarzeń, gdy bieżący obiekt nie jest modyfikowane przez (gdy <xref:System.Windows.Freezable.IsFrozen%2A> właściwość jest `true`), zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="1385c-125">If you attempt to add or remove event handlers when the current object is not modifiable (when the <xref:System.Windows.Freezable.IsFrozen%2A> property is `true`), an exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Freezable" Usage="freezable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1385c-126">Tworzy klon można modyfikować <see cref="T:System.Windows.Freezable" />, wykonywania kopii głębokiego wartości obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-126">Creates a modifiable clone of the <see cref="T:System.Windows.Freezable" />, making deep copies of the object's values.</span>
          </span>
          <span data-ttu-id="1385c-127">Podczas kopiowania obiektu właściwości zależności, ta metoda kopiuje wyrażeń, (które nie są już może rozwiązać), ale nie animacji lub ich bieżącymi wartościami.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-127">When copying the object's dependency properties, this method copies expressions (which might no longer resolve) but not animations or their current values.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1385c-128">Można modyfikować klonowania bieżącego obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-128">A modifiable clone of the current object.</span>
          </span>
          <span data-ttu-id="1385c-129">Sklonowany obiekt <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość <see langword="false" /> nawet wtedy, gdy źródło <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość <see langword="true." /></span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-129">The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true." /></span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1385c-130"><xref:System.Windows.Freezable.Clone%2A> i <xref:System.Windows.Freezable.CloneCurrentValue%2A> metod dać modyfikowalne klony zamrożone <xref:System.Windows.Freezable> obiektów (metody również sklonować <xref:System.Windows.Freezable> obiektów, które nie są zablokowane).</span><span class="sxs-lookup"><span data-stu-id="1385c-130">The <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods produce modifiable clones of frozen <xref:System.Windows.Freezable> objects (the methods also clone <xref:System.Windows.Freezable> objects that are not frozen).</span></span> <span data-ttu-id="1385c-131">Klon jest faktycznie głęboką kopię bieżącego obiektu.</span><span class="sxs-lookup"><span data-stu-id="1385c-131">The clone is effectively a deep copy of the current object.</span></span>  
  
 <span data-ttu-id="1385c-132">Poniższa tabela zawiera podsumowanie różnic między <xref:System.Windows.Freezable.Clone%2A> i <xref:System.Windows.Freezable.CloneCurrentValue%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1385c-132">The following table summarizes the differences between the <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods.</span></span>  
  
|<span data-ttu-id="1385c-133">Akcja</span><span class="sxs-lookup"><span data-stu-id="1385c-133">Action</span></span>|<span data-ttu-id="1385c-134">Zachowanie metody klonowania</span><span class="sxs-lookup"><span data-stu-id="1385c-134">Clone method behavior</span></span>|<span data-ttu-id="1385c-135">Zachowanie metody CloneCurrentValue</span><span class="sxs-lookup"><span data-stu-id="1385c-135">CloneCurrentValue method behavior</span></span>|  
|------------|---------------------------|---------------------------------------|  
|<span data-ttu-id="1385c-136">Kopiowanie właściwości zależności, który zawiera wyrażenie</span><span class="sxs-lookup"><span data-stu-id="1385c-136">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="1385c-137">Wyrażenia są kopiowane, ale nie może rozwiązać.</span><span class="sxs-lookup"><span data-stu-id="1385c-137">The expression is copied, but might no longer resolve.</span></span> <span data-ttu-id="1385c-138">Aby uzyskać więcej informacji, zobacz [Przegląd obiektów Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span><span class="sxs-lookup"><span data-stu-id="1385c-138">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>|<span data-ttu-id="1385c-139">Bieżąca wartość wyrażenia są kopiowane, ale nie wyrażenie.</span><span class="sxs-lookup"><span data-stu-id="1385c-139">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="1385c-140">Kopiowanie właściwości zależności animowane</span><span class="sxs-lookup"><span data-stu-id="1385c-140">Copying an animated dependency property</span></span>|<span data-ttu-id="1385c-141">Wartość właściwości podstawowej (bez animowane) są kopiowane.</span><span class="sxs-lookup"><span data-stu-id="1385c-141">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="1385c-142">Animacje nie są kopiowane.</span><span class="sxs-lookup"><span data-stu-id="1385c-142">Animations are not copied.</span></span>|<span data-ttu-id="1385c-143">Bieżąca wartość animowany właściwości są kopiowane.</span><span class="sxs-lookup"><span data-stu-id="1385c-143">The property's current animated value is copied.</span></span> <span data-ttu-id="1385c-144">Animacje nie są kopiowane.</span><span class="sxs-lookup"><span data-stu-id="1385c-144">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="1385c-145">Należy pamiętać, że nie ustawiono właściwości nie są kopiowane.</span><span class="sxs-lookup"><span data-stu-id="1385c-145">Note that unset properties are not copied.</span></span> <span data-ttu-id="1385c-146">Jeśli przez nieustawioną właściwość ma wartość domyślną, która jest zablokowane <xref:System.Windows.Freezable>, że wartość właściwości jest zablokowany w inny sposób modyfikować klonowania.</span><span class="sxs-lookup"><span data-stu-id="1385c-146">If an unset property has a default value that is a frozen <xref:System.Windows.Freezable>, that property value remains frozen in the otherwise modifiable clone.</span></span>  
  
## <a name="move-a-freezable-between-threads"></a><span data-ttu-id="1385c-147">Freezable być przenoszone między wątkami</span><span class="sxs-lookup"><span data-stu-id="1385c-147">Move a Freezable Between Threads</span></span>  
 <span data-ttu-id="1385c-148">Ta metoda może być przydatna do przenoszenia <xref:System.Windows.Freezable> między wątkami.</span><span class="sxs-lookup"><span data-stu-id="1385c-148">This method can be useful for moving a <xref:System.Windows.Freezable> between threads.</span></span> <span data-ttu-id="1385c-149">Po pierwsze należy <xref:System.Windows.Freezable> niemodyfikowalnych przez wywołanie jego <xref:System.Windows.Freezable.Freeze%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1385c-149">First, make the <xref:System.Windows.Freezable> unmodifiable by calling its <xref:System.Windows.Freezable.Freeze%2A> method.</span></span> <span data-ttu-id="1385c-150">Teraz mogą uzyskiwać dostęp do innego wątku <xref:System.Windows.Freezable> i lokalnym <xref:System.Windows.Freezable.Clone%2A> których może uzyskać dostęp.</span><span class="sxs-lookup"><span data-stu-id="1385c-150">Now another thread can access the <xref:System.Windows.Freezable> and make a local <xref:System.Windows.Freezable.Clone%2A> that it can access.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="1385c-151">
            <para>Ta metoda używa <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> do tworzenia klonu. Aby zmodyfikować zachowanie tej metody w klasie pochodnej, Zastąp <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> metody.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-151">
              <para>This method uses <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> to produce the clone. To modify the behavior of this method in a derived class, override the <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> method.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="1385c-152">Obiekt do klonowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-152">The object to clone.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1385c-153">Sprawia, że wystąpienie klonowania (głęboka kopia) określonego <see cref="T:System.Windows.Freezable" /> przy użyciu wartości podstawowej (bez animowane) właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-153">Makes the instance a clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1385c-154">Ta metoda jest wywoływana <xref:System.Windows.Freezable.Clone%2A> metody i nie należy wywoływać bezpośrednio w kodzie, z wyjątkiem podczas wywoływania implementację podstawową podczas przesłaniania tej metody.</span><span class="sxs-lookup"><span data-stu-id="1385c-154">This method is called by the <xref:System.Windows.Freezable.Clone%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="1385c-155">Aby utworzyć modyfikowalną kopię bieżącego obiektu, wywołaj <xref:System.Windows.Freezable.Clone%2A> zamiast bezpośrednio wywoływać tej metody.</span><span class="sxs-lookup"><span data-stu-id="1385c-155">To create a modifiable copy of the current object, call <xref:System.Windows.Freezable.Clone%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="1385c-156">
            <para>W przypadku klasy wyprowadzonej z <see cref="T:System.Windows.Freezable" />, może być konieczne należy przesłonić tę metodę. Powody, aby zastąpić obejmują następujące elementy:-klasy pochodnej ma dane, które nie jest uwidaczniany za pomocą właściwości zależności.  -Klasy pochodnej, należy wykonać dodatkową inicjację pracy nie da się osiągnąć przez zastąpienie po prostu <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Na przykład, to ma zastosowanie, gdy swojej otrzymanej klasy implementuje <see cref="T:System.ComponentModel.ISupportInitialize" />.  Nie trzeba zastąpić klas, które przechowują wszystkie dane w właściwości zależności i że nie trzeba wykonywać dodatkowe inicjowanie <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.  Istotne jest, że wszystkich implementacjach wywoływać implementację podstawową tej metody. Implementacje tylko należy wykonywać pracę, która nie jest wykonywane przez domyślną implementację. Domyślna implementacja sprawia, że głębokiego kopie wszystkich właściwości zapisywalny, lokalnie ustawiony, w tym wewnętrznego wyrażeń.  Jeśli obiekt ma właściwości zależności powiązane z danymi, wyrażenia są kopiowane, ale nie może rozwiązać. Aby uzyskać więcej informacji na temat klonowania obiektów powiązanych z danymi Zobacz [Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md) obiektów Freezable. Jeśli obiekt ma właściwości animowany zależności, jest kopiowany (inne niż animowane) wartości bazowej tych właściwości. Animacje nie są kopiowane.  Należy pamiętać, że nie ustawiono właściwości nie są kopiowane ani nie są właściwości tylko do odczytu. Jeśli takiej właściwości ma wartość domyślną, która jest zamrożone <see cref="T:System.Windows.Freezable" />, że wartość właściwości jest zablokowany w inny sposób modyfikować klonowania.  Na poniższej liście podsumowano oczekiwane zachowanie tej metody:-kopiowania generowany zawiera kopię wszystkich <see cref="T:System.Windows.Freezable" /> obiektów podrzędnych.  — Właściwości nie ustawiono i tylko do odczytu nie są kopiowane.  -Wyrażenia są kopiowane.  -Brak tych obiektów podrzędnych są zablokowane podczas ich tworzenia.  -Kopii sam nie jest zamrożona.  -Animacji nie są kopiowane.  — Tylko wartości podstawowej właściwości są skopiowane, nie bieżącej wartości animowany.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-156">
              <para>If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method. Reasons to override include the following:  -   Your derived class has data that is not exposed via dependency properties.  -   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.  Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.  It is essential that all implementations call the base implementation of this method. Implementations should only perform work that is not performed by the default implementation. The default implementation makes deep copies of all writable, locally set properties, including internal expressions.  If the object has data-bound dependency properties, the expressions are copied but might no longer resolve. For more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). If the object has animated dependency properties, the base (non-animated) value of those properties is copied. Animations are not copied.  Note that unset properties are not copied, nor are read-only properties. If such a property has a default value that is a frozen <see cref="T:System.Windows.Freezable" />, that property value remains frozen in the otherwise modifiable clone.  The following list summarizes the expected behavior for this method:  -   The copy produced contains copies of all <see cref="T:System.Windows.Freezable" /> sub-objects.  -   Unset and read-only properties are not copied.  -   Expressions are copied.  -   None of these sub-objects are frozen on creation.  -   The copy itself is not frozen.  -   Animations are not copied.  -   Only property base values are copied, not current animated values.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Freezable" Usage="freezable.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1385c-157">Można modyfikować klonu (głęboka kopia) tworzy <see cref="T:System.Windows.Freezable" /> przy użyciu jego bieżących wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-157">Creates a modifiable clone (deep copy) of the <see cref="T:System.Windows.Freezable" /> using its current values.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1385c-158">Można modyfikować klonowania bieżącego obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-158">A modifiable clone of the current object.</span>
          </span>
          <span data-ttu-id="1385c-159">Sklonowany obiekt <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość <see langword="false" /> nawet wtedy, gdy źródło <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość <see langword="true." /></span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-159">The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true." /></span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1385c-160"><xref:System.Windows.Freezable.Clone%2A> i <xref:System.Windows.Freezable.CloneCurrentValue%2A> metod dać modyfikowalne klony zamrożone <xref:System.Windows.Freezable> obiektów (metody również sklonować <xref:System.Windows.Freezable> obiektów, które nie są zablokowane).</span><span class="sxs-lookup"><span data-stu-id="1385c-160">The <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods produce modifiable clones of frozen <xref:System.Windows.Freezable> objects (the methods also clone <xref:System.Windows.Freezable> objects that are not frozen).</span></span> <span data-ttu-id="1385c-161">Klon jest faktycznie głęboką kopię bieżącego obiektu.</span><span class="sxs-lookup"><span data-stu-id="1385c-161">The clone is effectively a deep copy of the current object.</span></span>  
  
 <span data-ttu-id="1385c-162">Poniższa tabela zawiera podsumowanie różnic między <xref:System.Windows.Freezable.Clone%2A> i <xref:System.Windows.Freezable.CloneCurrentValue%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1385c-162">The following table summarizes the differences between the <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods.</span></span>  
  
|<span data-ttu-id="1385c-163">Akcja</span><span class="sxs-lookup"><span data-stu-id="1385c-163">Action</span></span>|<span data-ttu-id="1385c-164">Zachowanie metody klonowania</span><span class="sxs-lookup"><span data-stu-id="1385c-164">Clone method behavior</span></span>|<span data-ttu-id="1385c-165">Zachowanie metody CloneCurrentValue</span><span class="sxs-lookup"><span data-stu-id="1385c-165">CloneCurrentValue method behavior</span></span>|  
|------------|---------------------------|---------------------------------------|  
|<span data-ttu-id="1385c-166">Kopiowanie właściwości zależności, który zawiera wyrażenie</span><span class="sxs-lookup"><span data-stu-id="1385c-166">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="1385c-167">Wyrażenia są kopiowane, ale nie może rozwiązać.</span><span class="sxs-lookup"><span data-stu-id="1385c-167">The expression is copied, but might no longer resolve.</span></span> <span data-ttu-id="1385c-168">Aby uzyskać więcej informacji, zobacz [Przegląd obiektów Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span><span class="sxs-lookup"><span data-stu-id="1385c-168">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>|<span data-ttu-id="1385c-169">Bieżąca wartość wyrażenia są kopiowane, ale nie wyrażenie.</span><span class="sxs-lookup"><span data-stu-id="1385c-169">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="1385c-170">Kopiowanie właściwości zależności animowane</span><span class="sxs-lookup"><span data-stu-id="1385c-170">Copying an animated dependency property</span></span>|<span data-ttu-id="1385c-171">Wartość właściwości podstawowej (bez animowane) są kopiowane.</span><span class="sxs-lookup"><span data-stu-id="1385c-171">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="1385c-172">Animacje nie są kopiowane.</span><span class="sxs-lookup"><span data-stu-id="1385c-172">Animations are not copied.</span></span>|<span data-ttu-id="1385c-173">Bieżąca wartość animowany właściwości są kopiowane.</span><span class="sxs-lookup"><span data-stu-id="1385c-173">The property's current animated value is copied.</span></span> <span data-ttu-id="1385c-174">Animacje nie są kopiowane.</span><span class="sxs-lookup"><span data-stu-id="1385c-174">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="1385c-175">Należy pamiętać, że nie ustawiono właściwości nie są kopiowane.</span><span class="sxs-lookup"><span data-stu-id="1385c-175">Note that unset properties are not copied.</span></span> <span data-ttu-id="1385c-176">Jeśli przez nieustawioną właściwość ma wartość domyślną, która jest zablokowane <xref:System.Windows.Freezable>, że wartość właściwości jest zablokowany w inny sposób modyfikować klonowania.</span><span class="sxs-lookup"><span data-stu-id="1385c-176">If an unset property has a default value that is a frozen <xref:System.Windows.Freezable>, that property value remains frozen in the otherwise modifiable clone.</span></span>  
  
## <a name="move-a-freezable-between-threads"></a><span data-ttu-id="1385c-177">Freezable być przenoszone między wątkami</span><span class="sxs-lookup"><span data-stu-id="1385c-177">Move a Freezable Between Threads</span></span>  
 <span data-ttu-id="1385c-178">Ta metoda może być przydatna do przenoszenia <xref:System.Windows.Freezable> między wątkami.</span><span class="sxs-lookup"><span data-stu-id="1385c-178">This method can be useful for moving a <xref:System.Windows.Freezable> between threads.</span></span> <span data-ttu-id="1385c-179">Po pierwsze należy <xref:System.Windows.Freezable> niemodyfikowalnych przy użyciu jego <xref:System.Windows.Freezable.Freeze%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1385c-179">First, make the <xref:System.Windows.Freezable> unmodifiable by using its <xref:System.Windows.Freezable.Freeze%2A> method.</span></span> <span data-ttu-id="1385c-180">Teraz mogą uzyskiwać dostęp do innego wątku <xref:System.Windows.Freezable> i lokalnego klona, których może uzyskać dostęp.</span><span class="sxs-lookup"><span data-stu-id="1385c-180">Now another thread can access the <xref:System.Windows.Freezable> and make a local clone that it can access.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="1385c-181">
            <para>Ta metoda używa <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> metody do tworzenia klonu; <see cref="T:System.Windows.Freezable" /> implementacje, które zastępują <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> należy upewnić się, że kopia nie jest zamrożony przy tworzeniu.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-181">
              <para>This method uses the <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> method to produce the clone; <see cref="T:System.Windows.Freezable" /> implementers who override <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> must ensure that the copy is not frozen on creation.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="1385c-182">
            <see cref="T:System.Windows.Freezable" /> Można sklonować.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-182">The <see cref="T:System.Windows.Freezable" /> to be cloned.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1385c-183">Sprawia, że wystąpienie można modyfikować klonowania (głęboka kopia) określonego <see cref="T:System.Windows.Freezable" /> przy użyciu bieżącej wartości właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-183">Makes the instance a modifiable clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using current property values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1385c-184">Ta metoda jest wywoływana <xref:System.Windows.Freezable.CloneCurrentValue%2A> metody i nie należy wywoływać bezpośrednio w kodzie, z wyjątkiem podczas wywoływania implementację podstawową podczas przesłaniania tej metody.</span><span class="sxs-lookup"><span data-stu-id="1385c-184">This method is called by the <xref:System.Windows.Freezable.CloneCurrentValue%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="1385c-185">Aby utworzyć modyfikowalną kopię bieżącego obiektu, wywołaj <xref:System.Windows.Freezable.CloneCurrentValue%2A> zamiast bezpośrednio wywoływać tej metody.</span><span class="sxs-lookup"><span data-stu-id="1385c-185">To create a modifiable copy of the current object, call <xref:System.Windows.Freezable.CloneCurrentValue%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="1385c-186">
            <para>W przypadku klasy wyprowadzonej z <see cref="T:System.Windows.Freezable" />, może być konieczne należy przesłonić tę metodę. Powody, aby zastąpić obejmują następujące elementy:-klasy pochodnej ma dane, które nie jest uwidaczniany za pomocą właściwości zależności.  -Klasy pochodnej, należy wykonać dodatkową inicjację pracy nie da się osiągnąć przez zastąpienie po prostu <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Na przykład, to ma zastosowanie, gdy swojej otrzymanej klasy implementuje <see cref="T:System.ComponentModel.ISupportInitialize" />.  Nie trzeba zastąpić klas, które przechowują wszystkie dane w właściwości zależności i że nie trzeba wykonywać dodatkowe inicjowanie <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />.  Istotne jest, że wszystkich implementacjach wywoływać implementację podstawową tej metody. Implementacje tylko należy wykonywać pracę, która nie jest wykonywane przez domyślną implementację. Domyślna implementacja tworzy głębokiego kopie wszystkich właściwości zapisywalny, lokalnie ustawiony. Jeśli obiekt zawiera właściwości zależności za pomocą wyrażeń (np. powiązania danych), bieżąca wartość wyrażenia jest kopiowana, ale nie wyrażenie.  Jeśli obiekt ma być animowany właściwości zależności, bieżąca wartość animowany te właściwości są kopiowane, ale animacji nie są.  Należy pamiętać, że nie ustawiono właściwości nie są kopiowane ani nie są właściwości tylko do odczytu. Jeśli takiej właściwości ma wartość domyślną, która jest zamrożone <see cref="T:System.Windows.Freezable" />, że wartość właściwości jest zablokowany w inny sposób modyfikować klonowania.  Na poniższej liście podsumowano oczekiwane zachowanie tej metody.  -Kopii generowany zawiera kopię wszystkich <see cref="T:System.Windows.Freezable" /> obiektów podrzędnych.  — Właściwości nie ustawiono i tylko do odczytu nie są kopiowane.  — Jeśli właściwość jest animowany, jego bieżąca wartość są kopiowane, ale animacji, sama nie jest.  -Brak tych obiektów podrzędnych są zablokowane podczas ich tworzenia.  -Kopii sam nie jest zamrożona.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-186">
              <para>If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method. Reasons to override include the following:  -   Your derived class has data that is not exposed via dependency properties.  -   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.  Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />.  It is essential that all implementations call the base implementation of this method. Implementations should only perform work that is not performed by the default implementation. The default implementation makes deep copies of all writable, locally set properties. If the object contains dependency properties with expressions (such as a data binding), the current value of the expression is copied but not the expression itself.  If the object has animated dependency properties, the current animated value of those properties is copied, but the animations are not.  Note that unset properties are not copied, nor are read-only properties. If such a property has a default value that is a frozen <see cref="T:System.Windows.Freezable" />, that property value remains frozen in the otherwise modifiable clone.  The following list summarizes the expected behavior for this method.  -   The copy produced contains copies of all <see cref="T:System.Windows.Freezable" /> sub-objects.  -   Unset and read-only properties are not copied.  -   If a property is animated, its current value is copied, but the animation itself is not.  -   None of these sub-objects are frozen on creation.  -   The copy itself is not frozen.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1385c-187">Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Freezable" /> klasy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-187">Initializes a new instance of the <see cref="T:System.Windows.Freezable" /> class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1385c-188">Nowe wystąpienie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-188">The new instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1385c-189">Jest to metoda chroniona, a rzeczywiste implementacji określonego obiektu zachowania są zależne od implementacji zastąpienie <xref:System.Windows.Freezable.CreateInstanceCore%2A> metody, która wywołuje wewnętrznie ta metoda.</span><span class="sxs-lookup"><span data-stu-id="1385c-189">This is a protected method, and the actual object-specific implementations for the behavior are dependent on the override implementation of the <xref:System.Windows.Freezable.CreateInstanceCore%2A> method, which this method calls internally.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1385c-190">Po zaimplementowaniu w klasie pochodnej tworzy nowe wystąpienie klasy <see cref="T:System.Windows.Freezable" /> klasy pochodnej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-190">When implemented in a derived class, creates a new instance of the <see cref="T:System.Windows.Freezable" /> derived class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1385c-191">Nowe wystąpienie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-191">The new instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1385c-192">Nie wywołuj tej metody bezpośrednio (z wyjątkiem podczas wywoływania base w implementacji).</span><span class="sxs-lookup"><span data-stu-id="1385c-192">Do not call this method directly (except when calling base in an implementation).</span></span> <span data-ttu-id="1385c-193">Ta metoda jest wywoływana wewnętrznie przez <xref:System.Windows.Freezable.CreateInstance%2A> zawsze, gdy jest nowe wystąpienie klasy <xref:System.Windows.Freezable> zostanie utworzony.</span><span class="sxs-lookup"><span data-stu-id="1385c-193">This method is called internally by the <xref:System.Windows.Freezable.CreateInstance%2A> method whenever a new instance of the <xref:System.Windows.Freezable> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1385c-194">W poniższym przykładzie pokazano Typowa implementacja metody <xref:System.Windows.Freezable.CreateInstanceCore%2A>.</span><span class="sxs-lookup"><span data-stu-id="1385c-194">The following example shows a typical implementation of <xref:System.Windows.Freezable.CreateInstanceCore%2A>.</span></span>  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="1385c-195">
            <para>Każdy <see cref="T:System.Windows.Freezable" /> klasy pochodnej musi implementować tej metody. Typowa implementacja jest po prostu wywołać konstruktora domyślnego i zwraca wynik.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-195">
              <para>Every <see cref="T:System.Windows.Freezable" /> derived class must implement this method. A typical implementation is to simply call the default constructor and return the result.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1385c-196">Sprawia, że <see cref="T:System.Windows.Freezable" /> niemodyfikowalnych i ustawia jego <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwości <see langword="true" />, lub testów czy <see cref="T:System.Windows.Freezable" /> obiektu jest możliwe niemodyfikowalnych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-196">Makes a <see cref="T:System.Windows.Freezable" /> object unmodifiable and sets its <see cref="P:System.Windows.Freezable.IsFrozen" /> property to <see langword="true" />, or tests whether a <see cref="T:System.Windows.Freezable" /> object can be made unmodifiable.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberSignature Language="F#" Value="member this.Freeze : unit -&gt; unit" Usage="freezable.Freeze " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1385c-197">Sprawia, że bieżący obiekt jest niemodyfikowalnych i ustawia jego <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-197">Makes the current object unmodifiable and sets its <see cref="P:System.Windows.Freezable.IsFrozen" /> property to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1385c-198">Aby uniknąć możliwości <xref:System.InvalidOperationException> w wywołaniu tej metody, sprawdź <xref:System.Windows.Freezable.CanFreeze%2A> właściwości, aby określić, czy <xref:System.Windows.Freezable> można wprowadzić niemodyfikowalnych przed wywołaniem tej metody.</span><span class="sxs-lookup"><span data-stu-id="1385c-198">To avoid the possibility of an <xref:System.InvalidOperationException> when calling this method, check the <xref:System.Windows.Freezable.CanFreeze%2A> property to determine whether the <xref:System.Windows.Freezable> can be made unmodifiable before calling this method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="1385c-199">
            <see cref="T:System.Windows.Freezable" /> Nie może zostać wykonana niemodyfikowalnych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-199">The <see cref="T:System.Windows.Freezable" /> cannot be made unmodifiable.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="1385c-200">
            <para>Ta metoda używa <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metody <see cref="T:System.Windows.Freezable" /> niemodyfikowalnych. Aby zmodyfikować zachowanie zamrożenia, Zastąp <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metody.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-200">
              <para>This method uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method to make the <see cref="T:System.Windows.Freezable" /> unmodifiable. To modify freezing behavior, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberSignature Language="F#" Value="static member Freeze : System.Windows.Freezable * bool -&gt; bool" Usage="System.Windows.Freezable.Freeze (freezable, isChecking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">
          <span data-ttu-id="1385c-201">Obiekt do sprawdzania lub wprowadzania niemodyfikowalnych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-201">The object to check or make unmodifiable.</span>
          </span>
          <span data-ttu-id="1385c-202">Jeśli <c>isChecking</c> jest <see langword="true" />, obiekt jest sprawdzany w celu określenia, czy może on niemodyfikowalnych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-202">If <c>isChecking</c> is <see langword="true" />, the object is checked to determine whether it can be made unmodifiable.</span>
          </span>
          <span data-ttu-id="1385c-203">Jeśli <c>isChecking</c> jest <see langword="false" />, obiekt ma zostać niemodyfikowalnych, jeśli jest to możliwe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-203">If <c>isChecking</c> is <see langword="false" />, the object is made unmodifiable, if possible.</span>
          </span>
        </param>
        <param name="isChecking">
          <span data-ttu-id="1385c-204">
            <see langword="true" /> Aby zwrócić wskazanie, czy obiekt może być zablokowana (bez faktycznego zawiesza go); <see langword="false" /> można faktycznie zablokować obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-204">
              <see langword="true" /> to return an indication of whether the object can be frozen (without actually freezing it); <see langword="false" /> to actually freeze the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1385c-205">Jeśli <paramref name="isChecking" /> parametr jest <see langword="true" />, metoda wskazuje czy określony <see cref="T:System.Windows.Freezable" /> możliwe niemodyfikowalnych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-205">If the <paramref name="isChecking" /> parameter is <see langword="true" />, this method indicates whether the specified <see cref="T:System.Windows.Freezable" /> can be made unmodifiable.</span>
          </span>
          <span data-ttu-id="1385c-206">Jeśli <paramref name="isChecking" /> parametr jest <see langword="false" />, ta metoda próbuje wprowadzić określony <see cref="T:System.Windows.Freezable" /> niemodyfikowalnych i wskazuje, czy operacja zakończyła się pomyślnie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-206">If the <paramref name="isChecking" /> parameter is <see langword="false" />, this method attempts to make the specified <see cref="T:System.Windows.Freezable" /> unmodifiable and indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1385c-207">Jeśli <paramref name="isChecking" /> jest <see langword="true" />, Metoda ta zwraca <see langword="true" /> Jeśli określony <see cref="T:System.Windows.Freezable" /> możliwe niemodyfikowalnych, lub <see langword="false" /> Jeśli nie można dokonać niemodyfikowalnych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-207">If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if the specified <see cref="T:System.Windows.Freezable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
          <span data-ttu-id="1385c-208">Jeśli <paramref name="isChecking" /> jest <see langword="false" />, Metoda ta zwraca <see langword="true" /> Jeśli określony <see cref="T:System.Windows.Freezable" /> jest teraz niemodyfikowalnych, lub <see langword="false" /> Jeśli nie można dokonać niemodyfikowalnych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-208">If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the specified <see cref="T:System.Windows.Freezable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1385c-209">Nie wywołuj tej metody, chyba że są pochodząca od <xref:System.Windows.Freezable> i zastępowanie <xref:System.Windows.Freezable.FreezeCore%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1385c-209">Do not call this method unless you are deriving from <xref:System.Windows.Freezable> and overriding the <xref:System.Windows.Freezable.FreezeCore%2A> method.</span></span>  <span data-ttu-id="1385c-210">Ta metoda może być używany w <xref:System.Windows.Freezable.FreezeCore%2A> metodę, aby zablokować składowych danych klas, które znajdują się <xref:System.Windows.Freezable> obiektów.</span><span class="sxs-lookup"><span data-stu-id="1385c-210">This method may be used in the <xref:System.Windows.Freezable.FreezeCore%2A> method to freeze class data members that are themselves <xref:System.Windows.Freezable> objects.</span></span>  
  
 <span data-ttu-id="1385c-211">Jest tak jest ponownie wywołać tę metodę w <xref:System.Windows.Freezable> obiekt, który jest już zablokowany (niemodyfikowalnych).</span><span class="sxs-lookup"><span data-stu-id="1385c-211">It is alright to call this method again on a <xref:System.Windows.Freezable> object that is already frozen (unmodifiable).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="1385c-212">Gdy <paramref name="isChecking" /> jest <see langword="false" />, próba wykonania <paramref name="freezable" /> niemodyfikowalnych nie powiodła się; obiekt jest teraz w nieznanym stanie (go może być częściowo zamrożona).</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-212">When <paramref name="isChecking" /> is <see langword="false" />, the attempt to make <paramref name="freezable" /> unmodifiable was unsuccessful; the object is now in an unknown state (it might be partially frozen).</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="1385c-213">
            <para>Ta metoda używa <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metody <see cref="T:System.Windows.Freezable" /> niemodyfikowalnych. Aby zmodyfikować zachowanie zamrożenia, Zastąp <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metody.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-213">
              <para>This method uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method to make the <see cref="T:System.Windows.Freezable" /> unmodifiable. To modify freezing behavior, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="freezable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">
          <span data-ttu-id="1385c-214">
            <see langword="true" /> Aby zwrócić wskazanie, czy obiekt może być zablokowana (bez faktycznego zawiesza go); <see langword="false" /> można faktycznie zablokować obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-214">
              <see langword="true" /> to return an indication of whether the object can be frozen (without actually freezing it); <see langword="false" /> to actually freeze the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1385c-215">Sprawia, że <see cref="T:System.Windows.Freezable" /> obiektu niemodyfikowalnych lub sprawdza, czy może on niemodyfikowalnych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-215">Makes the <see cref="T:System.Windows.Freezable" /> object unmodifiable or tests whether it can be made unmodifiable.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1385c-216">Jeśli <paramref name="isChecking" /> jest <see langword="true" />, Metoda ta zwraca <see langword="true" /> Jeśli <see cref="T:System.Windows.Freezable" /> możliwe niemodyfikowalnych, lub <see langword="false" /> Jeśli nie można dokonać niemodyfikowalnych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-216">If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if the <see cref="T:System.Windows.Freezable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
          <span data-ttu-id="1385c-217">Jeśli <paramref name="isChecking" /> jest <see langword="false" />, Metoda ta zwraca <see langword="true" /> Jeśli czy określonego <see cref="T:System.Windows.Freezable" /> jest teraz niemodyfikowalnych, lub <see langword="false" /> Jeśli nie można dokonać niemodyfikowalnych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-217">If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the if the specified <see cref="T:System.Windows.Freezable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1385c-218">Nie wywołuj tej metody bezpośrednio (z wyjątkiem podczas wywoływania base w implementacji).</span><span class="sxs-lookup"><span data-stu-id="1385c-218">Do not call this method directly (except when calling base in an implementation).</span></span> <span data-ttu-id="1385c-219">Ta metoda jest wywoływana wewnętrznie przez <xref:System.Windows.Freezable.CanFreeze%2A> właściwości (przy użyciu `isChecking` równa `true`) i <xref:System.Windows.Freezable.Freeze%2A> — metoda (przy użyciu `isChecking` równa `false`).</span><span class="sxs-lookup"><span data-stu-id="1385c-219">This method is called internally by the <xref:System.Windows.Freezable.CanFreeze%2A> property (with `isChecking` equal to `true`) and the <xref:System.Windows.Freezable.Freeze%2A> method (with `isChecking` equal to `false`).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="1385c-220">
            <para>
              <see cref="T:System.Windows.Freezable" /> implementujące obiekty muszą przesłaniać tę metodę, gdy klasa zawiera dane, które nie są przechowywane przy użyciu właściwości zależności.  Typowa implementacja może wywołać podstawowej, a następnie wywołaj statyczną <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> metody na wszystkich <see cref="T:System.Windows.Freezable" /> uwzględniających typy właściwości, które zawiera klasy, zwracając <see langword="true" /> tylko wtedy, gdy wszystkie właściwości zostały zamrożone (lub może zostały zamrożone, w przypadku określenia <see langword="true" /> dla <paramref name="isChecking" />).</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-220">
              <para>
                <see cref="T:System.Windows.Freezable" /> implementers must override this method when the class contains data that is not stored using dependency properties.  A typical implementation would call base, then call the static <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> method on all <see cref="T:System.Windows.Freezable" /> typed properties that the class contains, returning <see langword="true" /> only if all properties were frozen (or could have been frozen, in the case of specifying <see langword="true" /> for <paramref name="isChecking" />).</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1385c-221">Tworzy kopię zamrożone <see cref="T:System.Windows.Freezable" />, przy użyciu wartości podstawowej (bez animowane) właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-221">Creates a frozen copy of the <see cref="T:System.Windows.Freezable" />, using base (non-animated) property values.</span>
          </span>
          <span data-ttu-id="1385c-222">Ponieważ kopia zostanie zamrożona, wszelkie zamrożone obiekty podrzędne są kopiowane przez odwołanie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-222">Because the copy is frozen, any frozen sub-objects are copied by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1385c-223">Zamrożone kopię <see cref="T:System.Windows.Freezable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-223">A frozen copy of the <see cref="T:System.Windows.Freezable" />.</span>
          </span>
          <span data-ttu-id="1385c-224">Kopiuj <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość jest ustawiona na <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-224">The copy's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is set to <see langword="true" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1385c-225">Należy sprawdzić <xref:System.Windows.Freezable.CanFreeze%2A> właściwości przed wywołaniem tej metody, aby sprawdzić, czy <xref:System.Windows.Freezable> może być zablokowany.</span><span class="sxs-lookup"><span data-stu-id="1385c-225">You should check the <xref:System.Windows.Freezable.CanFreeze%2A> property before calling this method to verify that the <xref:System.Windows.Freezable> can be frozen.</span></span> <span data-ttu-id="1385c-226">Przy użyciu tej metody jest podobny do procesu tworzenia, kopiowania za pomocą <xref:System.Windows.Freezable.Clone%2A> i następnie zawiesza się ją za pomocą <xref:System.Windows.Freezable.Freeze%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1385c-226">Using this method is similar to creating a copy using the <xref:System.Windows.Freezable.Clone%2A> and then freezing it with the <xref:System.Windows.Freezable.Freeze%2A> method.</span></span>  
  
 <span data-ttu-id="1385c-227"><xref:System.Windows.Freezable.GetAsFrozen%2A> i <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> metody może poprawić wydajność kopiowania, ponieważ ich nie Klonuj <xref:System.Windows.Freezable> obiekty podrzędne już jest zablokowany; w ich kopiować tylko je przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="1385c-227">The <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods can improve copying performance because they do not clone <xref:System.Windows.Freezable> sub-objects that are already frozen; they only copy them by reference.</span></span>  
  
 <span data-ttu-id="1385c-228">Poniższa tabela zawiera podsumowanie różnic między <xref:System.Windows.Freezable.GetAsFrozen%2A> i <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1385c-228">The following table summarizes the differences between the <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods.</span></span>  
  
|<span data-ttu-id="1385c-229">Akcja</span><span class="sxs-lookup"><span data-stu-id="1385c-229">Action</span></span>|<span data-ttu-id="1385c-230">Zachowanie metody GetAsFrozen</span><span class="sxs-lookup"><span data-stu-id="1385c-230">GetAsFrozen method behavior</span></span>|<span data-ttu-id="1385c-231">Zachowanie metody GetCurrentValueAsFrozen</span><span class="sxs-lookup"><span data-stu-id="1385c-231">GetCurrentValueAsFrozen method behavior</span></span>|  
|------------|---------------------------------|---------------------------------------------|  
|<span data-ttu-id="1385c-232">Kopiowanie właściwości zależności, który zawiera wyrażenie</span><span class="sxs-lookup"><span data-stu-id="1385c-232">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="1385c-233">Metoda zgłasza <xref:System.InvalidOperationException> , ponieważ nie jest <xref:System.Windows.Freezable.Freeze%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="1385c-233">The method throws an <xref:System.InvalidOperationException> because it cannot <xref:System.Windows.Freezable.Freeze%2A> the property.</span></span>|<span data-ttu-id="1385c-234">Bieżąca wartość wyrażenia są kopiowane, ale nie wyrażenie.</span><span class="sxs-lookup"><span data-stu-id="1385c-234">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="1385c-235">Kopiowanie właściwości zależności animowane</span><span class="sxs-lookup"><span data-stu-id="1385c-235">Copying an animated dependency property</span></span>|<span data-ttu-id="1385c-236">Wartość właściwości podstawowej (bez animowane) są kopiowane.</span><span class="sxs-lookup"><span data-stu-id="1385c-236">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="1385c-237">Animacje nie są kopiowane.</span><span class="sxs-lookup"><span data-stu-id="1385c-237">Animations are not copied.</span></span>|<span data-ttu-id="1385c-238">Bieżąca wartość animowany właściwości są kopiowane.</span><span class="sxs-lookup"><span data-stu-id="1385c-238">The property's current animated value is copied.</span></span> <span data-ttu-id="1385c-239">Animacje nie są kopiowane.</span><span class="sxs-lookup"><span data-stu-id="1385c-239">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="1385c-240">Należy pamiętać, że nie ustawiono właściwości nie są kopiowane ani nie są właściwości tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="1385c-240">Note that unset properties are not copied, nor are read-only properties.</span></span>  
  
 <span data-ttu-id="1385c-241">Aby utworzyć kopię <xref:System.Windows.Freezable> to znaczy nie zamrożone, użyj <xref:System.Windows.Freezable.Clone%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1385c-241">To create a copy of the <xref:System.Windows.Freezable> that is not frozen, use the <xref:System.Windows.Freezable.Clone%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="1385c-242">
            <see cref="T:System.Windows.Freezable" /> Nie można zablokować, ponieważ zawiera wyrażenia lub właściwości animowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-242">The <see cref="T:System.Windows.Freezable" /> cannot be frozen because it contains expressions or animated properties.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="1385c-243">
            <para>Ta metoda używa wirtualnego <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> metody do tworzenia klonu.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-243">
              <para>This method uses the virtual <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> method to produce the clone.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="1385c-244">Wystąpienie do skopiowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-244">The instance to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1385c-245">Sprawia, że wystąpienie zamrożone klonowania określonego <see cref="T:System.Windows.Freezable" /> przy użyciu wartości podstawowej (bez animowane) właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-245">Makes the instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1385c-246">Ta metoda jest wywoływana <xref:System.Windows.Freezable.GetAsFrozen%2A> metody i nie należy wywoływać bezpośrednio w kodzie, z wyjątkiem podczas wywoływania implementację podstawową podczas przesłaniania tej metody.</span><span class="sxs-lookup"><span data-stu-id="1385c-246">This method is called by the <xref:System.Windows.Freezable.GetAsFrozen%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="1385c-247">Aby utworzyć zamrożone kopię bieżącego obiektu, wywołaj <xref:System.Windows.Freezable.GetAsFrozen%2A> zamiast bezpośrednio wywoływać tej metody.</span><span class="sxs-lookup"><span data-stu-id="1385c-247">To create a frozen copy of the current object, call <xref:System.Windows.Freezable.GetAsFrozen%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="1385c-248">
            <para>W przypadku klasy wyprowadzonej z <see cref="T:System.Windows.Freezable" /> może być konieczne należy przesłonić tę metodę. Powody, aby zastąpić obejmują następujące elementy:-klasy pochodnej ma dane, które nie jest uwidaczniany za pomocą właściwości zależności.  -Klasy pochodnej, należy wykonać dodatkową inicjację pracy nie da się osiągnąć przez zastąpienie po prostu <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Na przykład, to ma zastosowanie, gdy swojej otrzymanej klasy implementuje <see cref="T:System.ComponentModel.ISupportInitialize" />.  Nie trzeba zastąpić klas, które przechowują wszystkie dane w właściwości zależności i że nie trzeba wykonywać dodatkowe inicjowanie <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />.  Istotne jest, że wszystkich implementacjach wywoływać implementację podstawową tej metody. Implementacje tylko należy wykonywać pracę, która nie jest wykonywane przez domyślną implementację. Domyślna implementacja tworzy głębokiego kopie wszelkich odblokowanej obiektów freezable i płytką kopię wszystkie inne zapisywalne, lokalnie zestaw właściwości zawartych w nim. Jeśli obiekt ma właściwości zależności powiązane z danymi, wyrażenia są kopiowane, ale nie może rozwiązać; Aby uzyskać więcej informacji na temat klonowania obiektów powiązanych z danymi Zobacz [Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md) obiektów Freezable. Jeśli obiekt ma właściwości animowany zależności, podstawowej (inne niż animowane) wartości tych właściwości są kopiowane. Animacje nie są kopiowane.  Należy pamiętać, że nie ustawiono właściwości nie są kopiowane ani nie są właściwości tylko do odczytu.  Jeśli zastąpisz tę metodę należy wywoływać implementację podstawową.  Nie trzeba <see cref="M:System.Windows.Freezable.Freeze" /> wartości, jak są one kopiowane.  Wynik jest zamrożony przez <see cref="M:System.Windows.Freezable.GetAsFrozen" /> przed zwróceniem.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-248">
              <para>If you derive from <see cref="T:System.Windows.Freezable" /> you may need to override this method. Reasons to override include the following:  -   Your derived class has data that is not exposed via dependency properties.  -   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.  Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />.  It is essential that all implementations call the base implementation of this method. Implementations should only perform work that is not performed by the default implementation. The default implementation makes deep copies of any unfrozen freezables and shallow copies of all other writable, locally set properties it contains. If the object has data-bound dependency properties, the expressions are copied but might no longer resolve; for more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). If the object has animated dependency properties, the base (non-animated) values of those properties are copied. Animations are not copied.  Note that unset properties are not copied, nor are read-only properties.  If you do override this method, you must call the base implementation.  You do not need to <see cref="M:System.Windows.Freezable.Freeze" /> values as they are copied.  The result is frozen by <see cref="M:System.Windows.Freezable.GetAsFrozen" /> before being returned.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentValueAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetCurrentValueAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1385c-249">Tworzy kopię zamrożone <see cref="T:System.Windows.Freezable" /> przy użyciu bieżącej wartości właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-249">Creates a frozen copy of the <see cref="T:System.Windows.Freezable" /> using current property values.</span>
          </span>
          <span data-ttu-id="1385c-250">Ponieważ kopia zostanie zamrożona, wszelkie zamrożone obiekty podrzędne są kopiowane przez odwołanie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-250">Because the copy is frozen, any frozen sub-objects are copied by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1385c-251">Zamrożone kopię <see cref="T:System.Windows.Freezable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-251">A frozen copy of the <see cref="T:System.Windows.Freezable" />.</span>
          </span>
          <span data-ttu-id="1385c-252">Kopiuj <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość jest ustawiona na <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-252">The copy's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is set to <see langword="true" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1385c-253">Przy użyciu tej metody jest podobny do procesu tworzenia, kopiowania za pomocą <xref:System.Windows.Freezable.CloneCurrentValue%2A> i następnie zawiesza się ją za pomocą <xref:System.Windows.Freezable.Freeze%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1385c-253">Using this method is similar to creating a copy using the <xref:System.Windows.Freezable.CloneCurrentValue%2A> and then freezing it with the <xref:System.Windows.Freezable.Freeze%2A> method.</span></span>  
  
 <span data-ttu-id="1385c-254"><xref:System.Windows.Freezable.GetAsFrozen%2A> i <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> metody może poprawić wydajność kopiowania, ponieważ ich nie Klonuj <xref:System.Windows.Freezable> obiekty podrzędne już jest zablokowany; w ich kopiować tylko je przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="1385c-254">The <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods can improve copying performance because they do not clone <xref:System.Windows.Freezable> sub-objects that are already frozen; they only copy them by reference.</span></span>  
  
 <span data-ttu-id="1385c-255">Poniższa tabela zawiera podsumowanie różnic między <xref:System.Windows.Freezable.GetAsFrozen%2A> i <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1385c-255">The following table summarizes the differences between the <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods.</span></span>  
  
|<span data-ttu-id="1385c-256">Akcja</span><span class="sxs-lookup"><span data-stu-id="1385c-256">Action</span></span>|<span data-ttu-id="1385c-257">Zachowanie metody GetAsFrozen</span><span class="sxs-lookup"><span data-stu-id="1385c-257">GetAsFrozen method behavior</span></span>|<span data-ttu-id="1385c-258">Zachowanie metody GetCurrentValueAsFrozen</span><span class="sxs-lookup"><span data-stu-id="1385c-258">GetCurrentValueAsFrozen method behavior</span></span>|  
|------------|---------------------------------|---------------------------------------------|  
|<span data-ttu-id="1385c-259">Kopiowanie właściwości zależności, który zawiera wyrażenie</span><span class="sxs-lookup"><span data-stu-id="1385c-259">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="1385c-260">Metoda zgłasza <xref:System.InvalidOperationException> , ponieważ nie jest <xref:System.Windows.Freezable.Freeze%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="1385c-260">The method throws an <xref:System.InvalidOperationException> because it cannot <xref:System.Windows.Freezable.Freeze%2A> the property.</span></span>|<span data-ttu-id="1385c-261">Bieżąca wartość wyrażenia są kopiowane, ale nie wyrażenie.</span><span class="sxs-lookup"><span data-stu-id="1385c-261">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="1385c-262">Kopiowanie właściwości zależności animowane</span><span class="sxs-lookup"><span data-stu-id="1385c-262">Copying an animated dependency property</span></span>|<span data-ttu-id="1385c-263">Wartość właściwości podstawowej (bez animowane) są kopiowane.</span><span class="sxs-lookup"><span data-stu-id="1385c-263">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="1385c-264">Animacje nie są kopiowane.</span><span class="sxs-lookup"><span data-stu-id="1385c-264">Animations are not copied.</span></span>|<span data-ttu-id="1385c-265">Bieżąca wartość animowany właściwości są kopiowane.</span><span class="sxs-lookup"><span data-stu-id="1385c-265">The property's current animated value is copied.</span></span> <span data-ttu-id="1385c-266">Animacje nie są kopiowane.</span><span class="sxs-lookup"><span data-stu-id="1385c-266">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="1385c-267">Należy pamiętać, że nie ustawiono właściwości nie są kopiowane ani nie są właściwości tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="1385c-267">Note that unset properties are not copied, nor are read-only properties.</span></span>  
  
 <span data-ttu-id="1385c-268">Aby utworzyć kopię <xref:System.Windows.Freezable> to znaczy nie zamrożone, użyj <xref:System.Windows.Freezable.CloneCurrentValue%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1385c-268">To create a copy of the <xref:System.Windows.Freezable> that is not frozen, use the <xref:System.Windows.Freezable.CloneCurrentValue%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="1385c-269">
            <para>Ta metoda używa wirtualnego <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> metody do tworzenia klonu.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-269">
              <para>This method uses the virtual <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> method to produce the clone.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="1385c-270">
            <see cref="T:System.Windows.Freezable" /> Do skopiowania i blokowanie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-270">The <see cref="T:System.Windows.Freezable" /> to copy and freeze.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1385c-271">Sprawia, że bieżące wystąpienie zamrożone klonowania określonego <see cref="T:System.Windows.Freezable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-271">Makes the current instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" />.</span>
          </span>
          <span data-ttu-id="1385c-272">Jeśli obiekt ma właściwości animowany zależności, są kopiowane ich bieżącymi wartościami animowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-272">If the object has animated dependency properties, their current animated values are copied.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1385c-273">Ta metoda jest wywoływana <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> metody i nie należy wywoływać bezpośrednio w kodzie, z wyjątkiem podczas wywoływania implementację podstawową podczas przesłaniania tej metody.</span><span class="sxs-lookup"><span data-stu-id="1385c-273">This method is called by the <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="1385c-274">Aby utworzyć zamrożone kopię bieżącego obiektu, wywołaj <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> zamiast bezpośrednio wywoływać tej metody.</span><span class="sxs-lookup"><span data-stu-id="1385c-274">To create a frozen copy of the current object, call <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="1385c-275">
            <para>W przypadku klasy wyprowadzonej z <see cref="T:System.Windows.Freezable" />, może być konieczne należy przesłonić tę metodę. Powody, aby zastąpić obejmują następujące elementy:-klasy pochodnej ma dane, które nie jest uwidaczniany za pomocą właściwości zależności.  -Klasy pochodnej, należy wykonać dodatkową inicjację pracy nie da się osiągnąć przez zastąpienie po prostu <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Na przykład, to ma zastosowanie, gdy swojej otrzymanej klasy implementuje <see cref="T:System.ComponentModel.ISupportInitialize" />.  Nie trzeba zastąpić klas, które przechowują wszystkie dane w właściwości zależności i że nie trzeba wykonywać dodatkowe inicjowanie <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />.  Istotne jest, że wszystkich implementacjach wywoływać implementację podstawową tej metody. Implementacje tylko należy wykonywać pracę, która nie jest wykonywane przez domyślną implementację. Domyślna implementacja tworzy nową <see cref="T:System.Windows.Freezable" /> przy użyciu <see cref="M:System.Windows.Freezable.CreateInstance" /> metody i sprawia, że kopie głębokiego odblokowanej obiektów freezable i płytką kopię wszystkie inne zapisywalne lokalnie Ustaw właściwości, które zawiera. Jeśli obiekt ma właściwości zależności powiązane z danymi, powiązań danych są kopiowane, ale nie może rozwiązać; Aby uzyskać więcej informacji na temat klonowania obiektów powiązanych z danymi Zobacz [Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md) obiektów Freezable. Jeśli obiekt ma być animowany właściwości zależności, bieżąca wartość animowany te właściwości są kopiowane, ale animacji nie są.  Właściwości zależności tylko do odczytu w ramach <see cref="T:System.Windows.Freezable" /> nie są kopiowane przez tę implementację domyślne.  Jeśli zastąpisz tę metodę należy wywoływać implementację podstawową.  Nie trzeba <see cref="M:System.Windows.Freezable.Freeze" /> wartości, jak są one kopiowane.  Wynik jest zamrożony przez <see cref="M:System.Windows.Freezable.GetAsFrozen" /> przed zwróceniem.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-275">
              <para>If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method. Reasons to override include the following:  -   Your derived class has data that is not exposed via dependency properties.  -   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.  Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />.  It is essential that all implementations call the base implementation of this method. Implementations should only perform work that is not performed by the default implementation. The default implementation creates a new <see cref="T:System.Windows.Freezable" /> using the <see cref="M:System.Windows.Freezable.CreateInstance" /> method and makes deep copies of unfrozen freezables and shallow copies of all other writable, locally set properties it contains. If the object has data-bound dependency properties, the data bindings are copied but might no longer resolve; for more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). If the object has animated dependency properties, the current animated value of those properties is copied, but the animations are not.  Read-only dependency properties within a <see cref="T:System.Windows.Freezable" /> are not copied by this default implementation.  If you do override this method, you must call the base implementation.  You do not need to <see cref="M:System.Windows.Freezable.Freeze" /> values as they are copied.  The result is frozen by <see cref="M:System.Windows.Freezable.GetAsFrozen" /> before being returned.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrozen : bool" Usage="System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="1385c-276">Pobiera wartość wskazującą, czy obiekt jest obecnie można modyfikować.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-276">Gets a value that indicates whether the object is currently modifiable.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="1385c-277">
            <see langword="true" /> Jeśli obiekt jest zablokowane i nie można zmodyfikować; <see langword="false" /> Jeśli obiekt może być modyfikowane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-277">
              <see langword="true" /> if the object is frozen and cannot be modified; <see langword="false" /> if the object can be modified.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1385c-278">Podjęto próbę modyfikacji obiektu podczas jego <xref:System.Windows.Freezable.IsFrozen%2A> właściwość `true` zgłasza <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="1385c-278">Attempting to modify an object when its <xref:System.Windows.Freezable.IsFrozen%2A> property is `true` throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="1385c-279">Ta właściwość jest tylko do odczytu z punktu widzenia modelu obiektu.</span><span class="sxs-lookup"><span data-stu-id="1385c-279">This property is read-only from the object model perspective.</span></span> <span data-ttu-id="1385c-280">Część dokumentacji dotyczącej <xref:System.Windows.Freezable> zachowania mogą zawierać "ustawia <xref:System.Windows.Freezable.IsFrozen%2A> do `true`" lub podobne języka podczas omawiania zachowanie inne metody <xref:System.Windows.Freezable>, ale to zachowanie jest wykonywane wewnętrznie w wystąpienia klasy gdy metody wystąpienia manipulować prywatnej zmiennych, które istnieją w ramach klasy abstrakcyjnej.</span><span class="sxs-lookup"><span data-stu-id="1385c-280">Some of the documentation about <xref:System.Windows.Freezable> behaviors may mention "sets <xref:System.Windows.Freezable.IsFrozen%2A> to `true`" or similar language when discussing the behavior of other methods of <xref:System.Windows.Freezable>, but this behavior is happening internally in the class instances, when methods of the instance manipulate the private variables that exist within the abstract class.</span></span> <span data-ttu-id="1385c-281">Aby ustawić wartość tej właściwości, należy wywołać <xref:System.Windows.Freezable.Freeze%2A>.</span><span class="sxs-lookup"><span data-stu-id="1385c-281">To set the value of this property, you should call <xref:System.Windows.Freezable.Freeze%2A>.</span></span> <span data-ttu-id="1385c-282">Jest to jednorazowa operacja, aby zmienić <xref:System.Windows.Freezable.IsFrozen%2A> właściwość początkowej domyślnej `false` do stanu `true` stanu.</span><span class="sxs-lookup"><span data-stu-id="1385c-282">This effectively is a one-time operation to change the <xref:System.Windows.Freezable.IsFrozen%2A> property from the initial default `false` state to the `true` state.</span></span> <span data-ttu-id="1385c-283">Brak nie dostępnych środków, można ustawić wartości do `false`.</span><span class="sxs-lookup"><span data-stu-id="1385c-283">There is no available means to set the value back to `false`.</span></span> <span data-ttu-id="1385c-284">Zamiast tego można zmienić wszelkie głęboka kopia wprowadzone od oryginału (zobacz <xref:System.Windows.Freezable.Clone%2A> metody).</span><span class="sxs-lookup"><span data-stu-id="1385c-284">Instead, you could change any deep copy made from the original (see the <xref:System.Windows.Freezable.Clone%2A> method).</span></span> <span data-ttu-id="1385c-285">Jest to celowe a jak dowolnej klasy pochodnej powinny zachowywać się po zastosowaniu do przypadków, gdy <xref:System.Windows.Freezable> wzorzec jest przydatny.</span><span class="sxs-lookup"><span data-stu-id="1385c-285">This is by design and is how any derived class should behave when applied to the cases where the <xref:System.Windows.Freezable> pattern is useful.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : unit -&gt; unit&#xA;override this.OnChanged : unit -&gt; unit" Usage="freezable.OnChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1385c-286">Wywoływane, gdy bieżący <see cref="T:System.Windows.Freezable" /> obiekt zostanie zmodyfikowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-286">Called when the current <see cref="T:System.Windows.Freezable" /> object is modified.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1385c-287">Ta metoda jest wywoływana zawsze wtedy, gdy <xref:System.Windows.Freezable.Changed> wystąpi zdarzenie.</span><span class="sxs-lookup"><span data-stu-id="1385c-287">This method is called whenever the <xref:System.Windows.Freezable.Changed> event occurs.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="1385c-288">
            <para>Podczas implementacji klasy, która pochodzi od klasy <see cref="T:System.Windows.Freezable" />, możesz zastąpić tę metodę w celu wykonywania zadań.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-288">
              <para>When you implement a class that derives from <see cref="T:System.Windows.Freezable" />, you may override this method to perform tasks.</para>
            </span>
          </span>
        </block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1385c-289">Zapewnia, że wskaźniki odpowiedniego kontekstu są ustanowione dla składowej danych typu <see cref="T:System.Windows.DependencyObject" /> , właśnie zostały zmodyfikowane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-289">Ensures that appropriate context pointers are established for a data member of type <see cref="T:System.Windows.DependencyObject" /> that has just been modified.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">
          <span data-ttu-id="1385c-290">Poprzednią wartość elementu danych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-290">The previous value of the data member.</span>
          </span>
        </param>
        <param name="newValue">
          <span data-ttu-id="1385c-291">Bieżąca wartość elementu danych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-291">The current value of the data member.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1385c-292">Zapewnia, że odpowiedniego kontekstu wskaźniki są ustanowione dla <see cref="T:System.Windows.DependencyObjectType" /> składowej danych, która została ustawiona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-292">Ensures that appropriate context pointers are established for a <see cref="T:System.Windows.DependencyObjectType" /> data member that has just been set.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1385c-293">Ta metoda powinna być wywoływana przez <xref:System.Windows.Freezable> obiektów dziedziczących każdorazowo <xref:System.Windows.DependencyObject> składowej danych, która nie jest przechowywany jako <xref:System.Windows.DependencyProperty> jest ustawiona.</span><span class="sxs-lookup"><span data-stu-id="1385c-293">This method should be called by <xref:System.Windows.Freezable> inheritors each time a <xref:System.Windows.DependencyObject> data member that is not stored as a <xref:System.Windows.DependencyProperty> is set.</span></span>  
  
 <span data-ttu-id="1385c-294">Ta metoda nie musi być wywoływana dla <xref:System.Windows.DependencyObject> składowych danych, które są przechowywane przy użyciu <xref:System.Windows.DependencyProperty>.</span><span class="sxs-lookup"><span data-stu-id="1385c-294">This method does not need to be called for <xref:System.Windows.DependencyObject> data members that are stored using a <xref:System.Windows.DependencyProperty>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">
          <span data-ttu-id="1385c-295">Poprzednią wartość elementu danych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-295">The previous value of the data member.</span>
          </span>
        </param>
        <param name="newValue">
          <span data-ttu-id="1385c-296">Bieżąca wartość elementu danych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-296">The current value of the data member.</span>
          </span>
        </param>
        <param name="property">
          <span data-ttu-id="1385c-297">Zmieniona właściwość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-297">The property that changed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1385c-298">Ten element członkowski obsługuje [! Infrastruktura include[TLA#tla_winclient](~/includes/tlasharptla-winclient-MD.MD)] i nie jest przeznaczona do użycia bezpośrednio w kodzie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-298">This member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="freezable.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="1385c-299">Dane zdarzenia, który zawiera informacje o tym, które zmienić właściwości, a jego starej i nowej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-299">Event data that contains information about which property changed, and its old and new values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1385c-300">Zastępuje <see cref="T:System.Windows.DependencyObject" /> implementacji <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> również wywołać żadnego <see cref="E:System.Windows.Freezable.Changed" /> obsługi w odpowiedzi na zmiany właściwości zależności typu <see cref="T:System.Windows.Freezable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-300">Overrides the <see cref="T:System.Windows.DependencyObject" /> implementation of <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> to also invoke any <see cref="E:System.Windows.Freezable.Changed" /> handlers in response to a changing dependency property of type <see cref="T:System.Windows.Freezable" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1385c-301">Dane zdarzenia zawierają informacje dotyczące tylko <xref:System.Windows.Freezable> sam.</span><span class="sxs-lookup"><span data-stu-id="1385c-301">The event data contains information about only the <xref:System.Windows.Freezable> itself.</span></span> <span data-ttu-id="1385c-302">Wszystkie informacje z właściwości podrzędnych należy uzyskać za pośrednictwem <xref:System.Windows.Freezable.Changed> programów obsługi.</span><span class="sxs-lookup"><span data-stu-id="1385c-302">Any sub-property information must be obtained through the <xref:System.Windows.Freezable.Changed> handlers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberSignature Language="F#" Value="member this.ReadPreamble : unit -&gt; unit" Usage="freezable.ReadPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1385c-303">Zapewnia, że <see cref="T:System.Windows.Freezable" /> jest uzyskiwany z prawidłową wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-303">Ensures that the <see cref="T:System.Windows.Freezable" /> is being accessed from a valid thread.</span>
          </span>
          <span data-ttu-id="1385c-304">Obiektów dziedziczących z <see cref="T:System.Windows.Freezable" /> musi wywołać tę metodę na początku dowolnego [! INCLUDE[TLA#tla_api](~/includes/tlasharptla-API-MD.MD)], odczytuje składowych danych, które nie są właściwościami zależności.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-304">Inheritors of <see cref="T:System.Windows.Freezable" /> must call this method at the beginning of any [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] that reads data members that are not dependency properties.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="1385c-305">
            <para>Klasy, które wynikają z <see cref="T:System.Windows.Freezable" /> powinny wywoływać <see cref="M:System.Windows.Freezable.ReadPreamble" /> metodę, zanim spróbuje uzyskać dostęp wszystkie elementy członkowskie, które nie są właściwościami zależności. <see cref="M:System.Windows.Freezable.WritePreamble" /> Metoda powinna być wywoływana przed takich elementów członkowskich są zapisywane.  Ta metoda skutecznie nic nie robi więcej niż wywołania <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-305">
              <para>Classes that derive from <see cref="T:System.Windows.Freezable" /> should call the <see cref="M:System.Windows.Freezable.ReadPreamble" /> method before they attempt to access any members that are not dependency properties. The <see cref="M:System.Windows.Freezable.WritePreamble" /> method should be called before any such members are written to.  This method effectively does nothing more than call <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberSignature Language="F#" Value="member this.WritePostscript : unit -&gt; unit" Usage="freezable.WritePostscript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1385c-306">Wywołuje <see cref="E:System.Windows.Freezable.Changed" /> zdarzenie <see cref="T:System.Windows.Freezable" /> i wywołuje jego <see cref="M:System.Windows.Freezable.OnChanged" /> metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-306">Raises the <see cref="E:System.Windows.Freezable.Changed" /> event for the <see cref="T:System.Windows.Freezable" /> and invokes its <see cref="M:System.Windows.Freezable.OnChanged" /> method.</span>
          </span>
          <span data-ttu-id="1385c-307">Klasy, które wynikają z <see cref="T:System.Windows.Freezable" /> powinna wywołać tę metodę na końcu dowolnego interfejsu API, który modyfikuje składowych klasy, które nie są przechowywane jako właściwości zależności.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-307">Classes that derive from <see cref="T:System.Windows.Freezable" /> should call this method at the end of any API that modifies class members that are not stored as dependency properties.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="1385c-308">
            <para>Klasy, które wynikają z <see cref="T:System.Windows.Freezable" /> powinna wywołać tę metodę na końcu dowolnego interfejsu API, który modyfikuje element członkowski klasy, które nie są przechowywane jako <see cref="T:System.Windows.DependencyProperty" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-308">
              <para>Classes that derive from <see cref="T:System.Windows.Freezable" /> should call this method at the end of any API that modifies a class member that is not stored as a <see cref="T:System.Windows.DependencyProperty" />.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberSignature Language="F#" Value="member this.WritePreamble : unit -&gt; unit" Usage="freezable.WritePreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1385c-309">Sprawdza, czy <see cref="T:System.Windows.Freezable" /> nie jest zablokowane i że jest on dostępny z prawidłowego kontekstu wątków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-309">Verifies that the <see cref="T:System.Windows.Freezable" /> is not frozen and that it is being accessed from a valid threading context.</span>
          </span>
          <span data-ttu-id="1385c-310">
            <see cref="T:System.Windows.Freezable" /> obiektów dziedziczących powinna wywołać tę metodę na początku dowolnego [! INCLUDE[TLA#tla_api](~/includes/tlasharptla-API-MD.MD)], która zapisuje do składowych danych, które nie są właściwościami zależności.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-310">
              <see cref="T:System.Windows.Freezable" /> inheritors should call this method at the beginning of any [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] that writes to data members that are not dependency properties.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1385c-311">Ta metoda wywołuje <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> Aby sprawdzić wątkowości kontekstu jest dostępny, i zgłasza wyjątek, jeśli <xref:System.Windows.Freezable> wystąpienia jest już zablokowany.</span><span class="sxs-lookup"><span data-stu-id="1385c-311">This method calls <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> to verify the threading context is accessible, and it throws an exception if the <xref:System.Windows.Freezable> instance is already frozen.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="1385c-312">
            <see cref="T:System.Windows.Freezable" /> Wystąpienia jest zablokowane i nie ma składowych zapisać.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-312">The <see cref="T:System.Windows.Freezable" /> instance is frozen and cannot have its members written to.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="1385c-313">
            <para>Klasy, które wynikają z <see cref="T:System.Windows.Freezable" /> powinny wywoływać <see cref="M:System.Windows.Freezable.WritePreamble" /> przed podjęciem próby zapisywać żadnych elementów członkowskich, które nie są właściwościami zależności. Jeśli wywołasz <see cref="M:System.Windows.Freezable.WritePreamble" /> w [! INCLUDE[TLA#tla_api](~/includes/tlasharptla-API-MD.MD)], można pominąć wywołanie <see cref="M:System.Windows.Freezable.ReadPreamble" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="1385c-313">
              <para>Classes that derive from <see cref="T:System.Windows.Freezable" /> should call <see cref="M:System.Windows.Freezable.WritePreamble" /> before attempting to write to any members that are not dependency properties. If you call <see cref="M:System.Windows.Freezable.WritePreamble" /> in an [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)], you can omit a call to <see cref="M:System.Windows.Freezable.ReadPreamble" />.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>
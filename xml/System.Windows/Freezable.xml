<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7d6d9b19e88e2ca2062fad2e21ae548d626378e8" /><Meta Name="ms.sourcegitcommit" Value="e7974886b08aa83a8fb461e8550f31a7d4331ee3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/23/2019" /><Meta Name="ms.locfileid" Value="68399442" /></Metadata><TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Freezable = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Definiuje obiekt, który ma stan modyfikowalny i stan tylko do odczytu (zamrożony). Klasy, które pochodzą <see cref="T:System.Windows.Freezable" /> od dostarczania szczegółowego powiadomienia o zmianach, mogą być niezmienne i mogą klonować siebie.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable> Klasa zawiera specjalne funkcje, które mogą pomóc zwiększyć wydajność aplikacji podczas korzystania z obiektów, które są kosztowne do modyfikacji lub kopiowania. <xref:System.Windows.Freezable> Przykłady obiektów są następujące:  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a>Wyprowadzanie z Freezable  
 Klasa, która powodzi <xref:System.Windows.Freezable> się od, uzyskuje następujące funkcje:  
  
-   Specjalne Stany: stan tylko do odczytu (zablokowany) i stan zapisywalny.  
  
-   Bezpieczeństwo wątków: zablokowany <xref:System.Windows.Freezable> obiekt może być współużytkowany przez wątki.  
  
-   Szczegółowe powiadomienie o zmianie: W przeciwieństwie <xref:System.Windows.DependencyObject> do innych obiektów <xref:System.Windows.Freezable> , obiekt zapewnia powiadomienia o zmianach w przypadku zmiany wartości właściwości podrzędnych.  
  
-   Łatwe Klonowanie: Klasa Freezable już wdrożyła kilka metod, które tworzą głębokie klony.  
  
 Aby uzyskać informacje na temat używania i tworzenia <xref:System.Windows.Freezable> własnych obiektów, zobacz [Freezable obiektów — Omówienie](~/docs/framework/wpf/advanced/freezable-objects-overview.md).  
  
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie publiczne <see langword="static" /> elementy członkowskie tego typu są bezpieczne wątkowo. Wystąpienia elementów członkowskich nie dają gwarancji bezpieczeństwa wątków.  
  
Gdy właściwość ma <see langword="false" />wartość, <see cref="T:System.Windows.Freezable" /> do obiektu można uzyskać dostęp tylko z wątku, w którym został utworzony. <see cref="P:System.Windows.Freezable.IsFrozen" /> Próba uzyskania dostępu do niego z innego wątku zgłasza <see cref="T:System.InvalidOperationException" />. Metody <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> i<see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> zapewniają obsługę kierowania do prawidłowego wątku.  
  
Gdy ich <see cref="P:System.Windows.Freezable.IsFrozen" /> Właściwość to <see langword="true" />, <see cref="T:System.Windows.Freezable" /> obiekty są wolne od wątku.  Aby uzyskać więcej informacji, zobacz [Freezable obiektów — Omówienie](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.Freezable" /> klasy pochodnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to Konstruktor Protected-Accessibility klasy abstrakcyjnej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFreeze : bool" Usage="System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy obiekt może być niemodyfikowalny.</summary>
        <value><see langword="true" />Jeśli bieżący obiekt może być niemodyfikowalny lub jest już niemodyfikowalny; w przeciwnym razie. <see langword="false" /></value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Ta <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> implementacja metody używa metody z <paramref name="isChecking" /> ustawionym <see langword="true" /> na, aby określić, <see cref="T:System.Windows.Freezable" /> czy można nie modyfikować. Aby zmodyfikować sposób zachowania tej właściwości w klasie pochodnej, Zastąp <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metodę.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="T:System.Windows.Freezable" /> lub obiekt, który zawiera, jest modyfikowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli podjęto próbę dodania lub usunięcia programów obsługi zdarzeń, gdy bieżący obiekt nie jest modyfikowany ( <xref:System.Windows.Freezable.IsFrozen%2A> gdy właściwość `true`jest), zostanie zgłoszony wyjątek.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Freezable" Usage="freezable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy modyfikowalny klon <see cref="T:System.Windows.Freezable" />, tworząc głębokie kopie wartości obiektu. Podczas kopiowania właściwości zależności obiektu ta metoda kopiuje wyrażenia (które mogą nie być już rozpoznawane), ale nie animacji ani ich bieżących wartości.</summary>
        <returns>Modyfikowalny klon bieżącego obiektu. <see cref="P:System.Windows.Freezable.IsFrozen" /> Właściwość sklonowanego obiektu jest <see langword="false" /> <see cref="P:System.Windows.Freezable.IsFrozen" /> nawet wtedy, gdy właściwość source ma wartość<see langword="true." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable> <xref:System.Windows.Freezable> Metody i <xref:System.Windows.Freezable.CloneCurrentValue%2A>generują modyfikowalne klony zablokowanych obiektów (metody również klonować obiekty, które nie są zamrożone). <xref:System.Windows.Freezable.Clone%2A> Klon jest wydajnie głęboką kopią bieżącego obiektu.  
  
 Poniższa tabela zawiera podsumowanie różnic między <xref:System.Windows.Freezable.Clone%2A> metodami i. <xref:System.Windows.Freezable.CloneCurrentValue%2A>  
  
|Akcja|Zachowanie metody klonowania|Zachowanie metody CloneCurrentValue|  
|------------|---------------------------|---------------------------------------|  
|Kopiowanie właściwości zależności, która ma wyrażenie|Wyrażenie jest kopiowane, ale może nie być już rozpoznawane. Aby uzyskać więcej informacji, zobacz [Freezable obiektów — Omówienie](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|Bieżąca wartość wyrażenia jest kopiowana, ale nie sama wyrażenie.|  
|Kopiowanie właściwości zależności animowanej|Wartość podstawowa (nieanimowana) właściwości jest kopiowana. Animacje nie są kopiowane.|Bieżąca animowana wartość właściwości jest kopiowana. Animacje nie są kopiowane.|  
  
 Należy zauważyć, że właściwości nie są kopiowane. Jeśli właściwość undefaultd ma wartość domyślną zamrożoną <xref:System.Windows.Freezable>, wartość tej właściwości pozostaje zamrożona w niemodyfikowalnym klonie.  
  
## <a name="move-a-freezable-between-threads"></a>Przenoszenie Freezable między wątkami  
 Ta metoda może być przydatna do poruszania <xref:System.Windows.Freezable> się między wątkami. Najpierw ustaw <xref:System.Windows.Freezable> , aby nie modyfikować przez <xref:System.Windows.Freezable.Freeze%2A> wywołanie metody. Teraz inny wątek może uzyskać dostęp <xref:System.Windows.Freezable> do programu i udostępnić <xref:System.Windows.Freezable.Clone%2A> go lokalnemu dostępowi.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ta metoda używa <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> do tworzenia klona. Aby zmodyfikować zachowanie tej metody w klasie pochodnej, Zastąp <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> metodę.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Obiekt, który ma zostać sklonowany.</param>
        <summary>Sprawia, że wystąpienie jest klonem (głębokiej kopii) <see cref="T:System.Windows.Freezable" /> określonej przy użyciu wartości właściwości Base (Nieanimowane).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez <xref:System.Windows.Freezable.Clone%2A> metodę i nie powinna być wywoływana bezpośrednio z kodu, chyba że podczas wywoływania implementacji podstawowej podczas zastępowania tej metody. Aby utworzyć modyfikowalną kopię bieżącego obiektu, wywołaj <xref:System.Windows.Freezable.Clone%2A> zamiast wywołania tej metody bezpośrednio.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Jeśli pochodzą z <see cref="T:System.Windows.Freezable" />, może być konieczne zastąpienie tej metody. Przyczyny zastąpienia obejmują następujące elementy: 
-Klasa pochodna ma dane, które nie są udostępniane za pośrednictwem właściwości zależności.  
  
-Klasa pochodna musi wykonać dodatkową operację inicjalizacji, której nie można osiągnąć przez po <see cref="M:System.Windows.Freezable.CreateInstanceCore" />prostu zastąpienie. Na przykład ma to zastosowanie w przypadku implementowania <see cref="T:System.ComponentModel.ISupportInitialize" />klasy pochodnej.  
  
Klasy, w których są przechowywane wszystkie dane we właściwościach zależności, które nie muszą wykonywać dodatkowej pracy inicjującej, nie muszą <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />zostać przesłonięte.  
  
Należy koniecznie, aby wszystkie implementacje wywoływały podstawową implementację tej metody. Implementacje powinny wykonywać wyłącznie zadania, które nie są wykonywane przez implementację domyślną. Domyślna implementacja powoduje głębokie kopie wszystkich zapisywalnych, lokalnie ustawionych właściwości, łącznie z wyrażeniami wewnętrznymi.  
  
Jeśli obiekt ma właściwości zależności powiązane z danymi, wyrażenia są kopiowane, ale mogą nie być już rozpoznawane. Aby uzyskać więcej informacji na temat klonowania obiektów powiązanych z danymi, zobacz [Freezable obiektów — Omówienie](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Jeśli obiekt ma animowane właściwości zależności, kopiowana jest wartość podstawowa (nieanimowana) tych właściwości. Animacje nie są kopiowane.  
  
Należy zauważyć, że właściwości nie są kopiowane, ani nie są właściwościami tylko do odczytu. Jeśli taka właściwość ma wartość domyślną zamrożoną <see cref="T:System.Windows.Freezable" />, wartość tej właściwości pozostaje zamrożona w niemodyfikowalnym klonie.  
  
Poniższa lista zawiera podsumowanie oczekiwanego zachowania tej metody: 
-Utworzona kopia zawiera kopie wszystkich <see cref="T:System.Windows.Freezable" /> obiektów podrzędnych.  
  
Nie są kopiowane właściwości-unonly i tylko do odczytu.  
  
-Wyrażenia są kopiowane.  
  
-Żadne z tych obiektów podrzędnych nie są zamrożone podczas tworzenia.  
  
-Sama kopia nie jest zamrożona.  
  
-Animacje nie są kopiowane.  
  
Są kopiowane tylko wartości podstawowe właściwości, a nie bieżące wartości animowane.</para></block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Freezable" Usage="freezable.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia utworzenie sklonowanego klonu (głębokiej kopii <see cref="T:System.Windows.Freezable" /> ) przy użyciu bieżących wartości.</summary>
        <returns>Modyfikowalny klon bieżącego obiektu. <see cref="P:System.Windows.Freezable.IsFrozen" /> Właściwość sklonowanego obiektu jest <see langword="false" /> <see cref="P:System.Windows.Freezable.IsFrozen" /> nawet wtedy, gdy właściwość source ma wartość<see langword="true." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable> <xref:System.Windows.Freezable> Metody i <xref:System.Windows.Freezable.CloneCurrentValue%2A>generują modyfikowalne klony zablokowanych obiektów (metody również klonować obiekty, które nie są zamrożone). <xref:System.Windows.Freezable.Clone%2A> Klon jest wydajnie głęboką kopią bieżącego obiektu.  
  
 Poniższa tabela zawiera podsumowanie różnic między <xref:System.Windows.Freezable.Clone%2A> metodami i. <xref:System.Windows.Freezable.CloneCurrentValue%2A>  
  
|Akcja|Zachowanie metody klonowania|Zachowanie metody CloneCurrentValue|  
|------------|---------------------------|---------------------------------------|  
|Kopiowanie właściwości zależności, która ma wyrażenie|Wyrażenie jest kopiowane, ale może nie być już rozpoznawane. Aby uzyskać więcej informacji, zobacz [Freezable obiektów — Omówienie](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|Bieżąca wartość wyrażenia jest kopiowana, ale nie sama wyrażenie.|  
|Kopiowanie właściwości zależności animowanej|Wartość podstawowa (nieanimowana) właściwości jest kopiowana. Animacje nie są kopiowane.|Bieżąca animowana wartość właściwości jest kopiowana. Animacje nie są kopiowane.|  
  
 Należy zauważyć, że właściwości nie są kopiowane. Jeśli właściwość undefaultd ma wartość domyślną zamrożoną <xref:System.Windows.Freezable>, wartość tej właściwości pozostaje zamrożona w niemodyfikowalnym klonie.  
  
## <a name="move-a-freezable-between-threads"></a>Przenoszenie Freezable między wątkami  
 Ta metoda może być przydatna do poruszania <xref:System.Windows.Freezable> się między wątkami. Najpierw ustaw <xref:System.Windows.Freezable> , aby nie modyfikować za <xref:System.Windows.Freezable.Freeze%2A> pomocą metody. Teraz inny wątek może uzyskać dostęp <xref:System.Windows.Freezable> do i uczynić lokalnym klonem, do którego może uzyskać dostęp.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ta metoda używa <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> metody do tworzenia klonu; Realizatorzy, którzy <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> zastępują, muszą upewnić się, że kopia nie została zamrożona podczas tworzenia. <see cref="T:System.Windows.Freezable" /></para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable"><see cref="T:System.Windows.Freezable" /> Do klonowania.</param>
        <summary>Sprawia, że wystąpienie jest modyfikowalne klonowania (głębokiej kopii <see cref="T:System.Windows.Freezable" /> ) określonej przy użyciu bieżących wartości właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez <xref:System.Windows.Freezable.CloneCurrentValue%2A> metodę i nie powinna być wywoływana bezpośrednio z kodu, chyba że podczas wywoływania implementacji podstawowej podczas zastępowania tej metody. Aby utworzyć modyfikowalną kopię bieżącego obiektu, wywołaj <xref:System.Windows.Freezable.CloneCurrentValue%2A> zamiast wywołania tej metody bezpośrednio.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Jeśli pochodzą z <see cref="T:System.Windows.Freezable" />, może być konieczne zastąpienie tej metody. Przyczyny zastąpienia obejmują następujące elementy: 
-Klasa pochodna ma dane, które nie są udostępniane za pośrednictwem właściwości zależności.  
  
-Klasa pochodna musi wykonać dodatkową operację inicjalizacji, której nie można osiągnąć przez po <see cref="M:System.Windows.Freezable.CreateInstanceCore" />prostu zastąpienie. Na przykład ma to zastosowanie w przypadku implementowania <see cref="T:System.ComponentModel.ISupportInitialize" />klasy pochodnej.  
  
Klasy, w których są przechowywane wszystkie dane we właściwościach zależności, które nie muszą wykonywać dodatkowej pracy inicjującej, nie muszą <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />zostać przesłonięte.  
  
Należy koniecznie, aby wszystkie implementacje wywoływały podstawową implementację tej metody. Implementacje powinny wykonywać wyłącznie zadania, które nie są wykonywane przez implementację domyślną. Implementacja domyślna tworzy głębokie kopie wszystkich zapisywalnych, lokalnie ustawionych właściwości. Jeśli obiekt zawiera właściwości zależności z wyrażeniami (takimi jak powiązanie danych), bieżąca wartość wyrażenia jest kopiowana, ale nie sama wyrażenie.  
  
Jeśli obiekt ma animowane właściwości zależności, bieżąca animowana wartość tych właściwości jest kopiowana, ale animacje nie są.  
  
Należy zauważyć, że właściwości nie są kopiowane, ani nie są właściwościami tylko do odczytu. Jeśli taka właściwość ma wartość domyślną zamrożoną <see cref="T:System.Windows.Freezable" />, wartość tej właściwości pozostaje zamrożona w niemodyfikowalnym klonie.  
  
Poniższa lista zawiera podsumowanie oczekiwanego zachowania tej metody.  
  
-Utworzona kopia zawiera kopie wszystkich <see cref="T:System.Windows.Freezable" /> obiektów podrzędnych.  
  
Nie są kopiowane właściwości-unonly i tylko do odczytu.  
  
— Jeśli właściwość jest animowana, jej bieżąca wartość jest kopiowana, ale sama animacja nie jest.  
  
-Żadne z tych obiektów podrzędnych nie są zamrożone podczas tworzenia.  
  
-Sama kopia nie jest zamrożona.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Freezable" /> klasy.</summary>
        <returns>Nowe wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to metoda chroniona, a rzeczywiste implementacje specyficzne dla obiektów dla zachowania są zależne od implementacji <xref:System.Windows.Freezable.CreateInstanceCore%2A> metody, która ta metoda wywołuje wewnętrznie.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po zaimplementowaniu w klasie pochodnej tworzy nowe wystąpienie <see cref="T:System.Windows.Freezable" /> klasy pochodnej.</summary>
        <returns>Nowe wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie wywołuj tej metody bezpośrednio (z wyjątkiem sytuacji, w której jest wywoływana baza w implementacji). Ta metoda jest wywoływana wewnętrznie przez <xref:System.Windows.Freezable.CreateInstance%2A> metodę za każdym razem, gdy tworzone <xref:System.Windows.Freezable> jest nowe wystąpienie.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono typową implementację <xref:System.Windows.Freezable.CreateInstanceCore%2A>programu.  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Każda <see cref="T:System.Windows.Freezable" /> Klasa pochodna musi implementować tę metodę. Typową implementacją jest po prostu wywołanie konstruktora bez parametrów i zwrócenie wyniku.</para></block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sprawia, że <see cref="P:System.Windows.Freezable.IsFrozen" /> <see langword="true" /> <see cref="T:System.Windows.Freezable" /> obiekt jest niemodyfikowalny i ustawia jego właściwość na lub testuje, czy nie można zmodyfikować obiektu. <see cref="T:System.Windows.Freezable" /></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberSignature Language="F#" Value="member this.Freeze : unit -&gt; unit" Usage="freezable.Freeze " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sprawia, że bieżący obiekt jest niemodyfikowalny <see cref="P:System.Windows.Freezable.IsFrozen" /> i ustawia <see langword="true" />jego właściwość na.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uniknąć <xref:System.InvalidOperationException> <xref:System.Windows.Freezable> możliwego wywołania tej metody przez wywołanie funkcji, należy <xref:System.Windows.Freezable.CanFreeze%2A> sprawdzić właściwość, aby określić, czy można nie modyfikować przed wywołaniem tej metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Windows.Freezable" /> Nie można dokonać edycji.</exception>
        <block subset="none" type="overrides"><para>Ta metoda używa <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metody, aby nie można <see cref="T:System.Windows.Freezable" /> było modyfikować. Aby zmodyfikować zachowanie zamarzania, <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> Zastąp metodę.</para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberSignature Language="F#" Value="static member Freeze : System.Windows.Freezable * bool -&gt; bool" Usage="System.Windows.Freezable.Freeze (freezable, isChecking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">Obiekt do sprawdzenia lub nie można go zmodyfikować. Jeśli <paramref name="isChecking" /> jest<see langword="true" />, obiekt jest sprawdzany w celu określenia, czy można go nie modyfikować. Jeśli <paramref name="isChecking" /> jest <see langword="false" />, obiekt jest niemodyfikowalny, jeśli jest to możliwe.</param>
        <param name="isChecking"><see langword="true" />Aby zwrócić wskazanie, czy obiekt może być zablokowany (bez jego rzeczywistego zamrażania); <see langword="false" /> aby faktycznie zablokować obiekt.</param>
        <summary>Jeśli parametr ma <see langword="true" />wartość, ta metoda wskazuje, czy nie można dokonać edycji określonego. <see cref="T:System.Windows.Freezable" /> <paramref name="isChecking" /> Jeśli parametr ma <see langword="false" />wartość, ta metoda próbuje wprowadzić określone <see cref="T:System.Windows.Freezable" /> niemodyfikowalne i wskazuje, czy operacja zakończyła się pomyślnie. <paramref name="isChecking" /></summary>
        <returns>Jeśli <paramref name="isChecking" /> <see langword="true" /> jest <see langword="true" />, ta metoda zwraca wartość, jeśli <see cref="T:System.Windows.Freezable" /> określony może być niemodyfikowalny lub <see langword="false" /> Jeśli nie można dokonać jego edycji. Jeśli <paramref name="isChecking" /> <see langword="true" /> jest <see langword="false" />, ta metoda zwraca wartość, jeśli <see cref="T:System.Windows.Freezable" /> określony element jest teraz niemodyfikowalny, lub <see langword="false" /> Jeśli nie można dokonać jego edycji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie wywołuj tej metody, chyba że pochodzą z <xref:System.Windows.Freezable> i <xref:System.Windows.Freezable.FreezeCore%2A> zastępują metodę.  Ta metoda może być używana w <xref:System.Windows.Freezable.FreezeCore%2A> metodzie do zablokowania składowych danych klasy, które <xref:System.Windows.Freezable> są obiektami.  
  
 Jest to porządku, aby ponownie wywołać tę metodę dla <xref:System.Windows.Freezable> obiektu, który jest już zablokowany (niemodyfikowalny).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Gdy <paramref name="isChecking" /> tak <see langword="false" />jest, próba dokonania <paramref name="freezable" /> niemodyfikowalnych operacji nie powiodła się; obiekt jest teraz w nieznanym stanie (może być częściowo zamrożony).</exception>
        <block subset="none" type="overrides"><para>Ta metoda używa <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metody, aby nie można <see cref="T:System.Windows.Freezable" /> było modyfikować. Aby zmodyfikować zachowanie zamarzania, <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> Zastąp metodę.</para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="freezable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking"><see langword="true" />Aby zwrócić wskazanie, czy obiekt może być zablokowany (bez jego rzeczywistego zamrażania); <see langword="false" /> aby faktycznie zablokować obiekt.</param>
        <summary>Sprawia, <see cref="T:System.Windows.Freezable" /> że obiekt jest niemodyfikowalny lub testuje, czy można go nie modyfikować.</summary>
        <returns>Jeśli <paramref name="isChecking" /> <see langword="true" /> jest <see langword="true" />, Tametoda<see langword="false" /> zwraca wartość, jeśli niemożnadokonaćedycjilubniemożnajejzmodyfikować.<see cref="T:System.Windows.Freezable" /> Jeśli <paramref name="isChecking" /> <see langword="true" /> jest <see langword="false" />, ta metoda zwraca wartość, jeśli określony <see cref="T:System.Windows.Freezable" /> nie jest teraz niemodyfikowalny, <see langword="false" /> lub jeśli nie można dokonać jego edycji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie wywołuj tej metody bezpośrednio (z wyjątkiem sytuacji, w której jest wywoływana baza w implementacji). Ta metoda jest wywoływana <xref:System.Windows.Freezable.CanFreeze%2A> wewnętrznie przez właściwość (z `isChecking` <xref:System.Windows.Freezable.Freeze%2A> równą `true` `false`) i metodę (z `isChecking` równą).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.Freezable" />implementacje muszą przesłaniać tę metodę, gdy Klasa zawiera dane, które nie są przechowywane przy użyciu właściwości zależności.  
  
Typowa implementacja wywoła podstawę, a następnie Wywołaj <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> metodę statyczną <see cref="T:System.Windows.Freezable" /> we wszystkich typach właściwości, które zawiera Klasa <see langword="true" /> , zwracając tylko wtedy, gdy wszystkie właściwości zostały zamrożone (lub mogły zostać zamrożone w przypadku określenia dla programu<paramref name="isChecking" />). <see langword="true" /></para></block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy zamrożoną kopię <see cref="T:System.Windows.Freezable" />, używając wartości właściwości Base (Nieanimowane). Ponieważ kopia jest zamrożona, wszelkie zamrożone obiekty podrzędne są kopiowane przez odwołanie.</summary>
        <returns>Zamrożona kopia <see cref="T:System.Windows.Freezable" />. <see cref="P:System.Windows.Freezable.IsFrozen" /> Właściwość Copy ma <see langword="true" />ustawioną wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed wywołaniem tej <xref:System.Windows.Freezable.CanFreeze%2A> metody należy sprawdzić Właściwość <xref:System.Windows.Freezable> , aby upewnić się, że można ją zablokować. Użycie tej metody jest podobne do tworzenia kopii przy użyciu <xref:System.Windows.Freezable.Clone%2A> , a następnie zamrażania <xref:System.Windows.Freezable.Freeze%2A> za pomocą metody.  
  
 Metody <xref:System.Windows.Freezable.GetAsFrozen%2A> <xref:System.Windows.Freezable> i <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> mogą zwiększyć wydajność kopiowania, ponieważ nie powielają obiektów podrzędnych, które są już zamrożone; są one kopiowane tylko przez odwołanie.  
  
 Poniższa tabela zawiera podsumowanie różnic między <xref:System.Windows.Freezable.GetAsFrozen%2A> metodami i. <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>  
  
|Akcja|Zachowanie metody GetAsFrozen|Zachowanie metody GetCurrentValueAsFrozen|  
|------------|---------------------------------|---------------------------------------------|  
|Kopiowanie właściwości zależności, która ma wyrażenie|Metoda zgłasza <xref:System.InvalidOperationException> , ponieważ nie może <xref:System.Windows.Freezable.Freeze%2A> właściwości.|Bieżąca wartość wyrażenia jest kopiowana, ale nie sama wyrażenie.|  
|Kopiowanie właściwości zależności animowanej|Wartość podstawowa (nieanimowana) właściwości jest kopiowana. Animacje nie są kopiowane.|Bieżąca animowana wartość właściwości jest kopiowana. Animacje nie są kopiowane.|  
  
 Należy zauważyć, że właściwości nie są kopiowane, ani nie są właściwościami tylko do odczytu.  
  
 Aby utworzyć kopię <xref:System.Windows.Freezable> , która nie jest zamrożona, <xref:System.Windows.Freezable.Clone%2A> Użyj metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie <see cref="T:System.Windows.Freezable" /> można zablokować, ponieważ zawiera wyrażenia lub właściwości animowane.</exception>
        <block subset="none" type="overrides"><para>Ta metoda używa wirtualnej <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> metody do tworzenia klonu.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Wystąpienie, które ma zostać skopiowane.</param>
        <summary>Sprawia, że wystąpienie jest zablokowanym klonem <see cref="T:System.Windows.Freezable" /> określonego przy użyciu wartości właściwości Base (Nieanimowane).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez <xref:System.Windows.Freezable.GetAsFrozen%2A> metodę i nie powinna być wywoływana bezpośrednio z kodu, chyba że podczas wywoływania implementacji podstawowej podczas zastępowania tej metody. Aby utworzyć zamrożoną kopię bieżącego obiektu, wywołaj <xref:System.Windows.Freezable.GetAsFrozen%2A> zamiast wywołania tej metody bezpośrednio.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Jeśli pochodzi od <see cref="T:System.Windows.Freezable" /> użytkownika, może być konieczne przesłonięcie tej metody. Przyczyny zastąpienia obejmują następujące elementy: 
-Klasa pochodna ma dane, które nie są udostępniane za pośrednictwem właściwości zależności.  
  
-Klasa pochodna musi wykonać dodatkową operację inicjalizacji, której nie można osiągnąć przez po <see cref="M:System.Windows.Freezable.CreateInstanceCore" />prostu zastąpienie. Na przykład ma to zastosowanie w przypadku implementowania <see cref="T:System.ComponentModel.ISupportInitialize" />klasy pochodnej.  
  
Klasy, w których są przechowywane wszystkie dane we właściwościach zależności, które nie muszą wykonywać dodatkowej pracy inicjującej, nie muszą <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />zostać przesłonięte.  
  
Należy koniecznie, aby wszystkie implementacje wywoływały podstawową implementację tej metody. Implementacje powinny wykonywać wyłącznie zadania, które nie są wykonywane przez implementację domyślną. Domyślna implementacja powoduje głębokie kopie wszelkich niezablokowanych obiektów Freezable platformie i kopii wszystkich innych zapisywalnych, lokalnie ustawionych właściwości, które zawiera. Jeśli obiekt ma właściwości zależności powiązane z danymi, wyrażenia są kopiowane, ale mogą nie być już rozpoznawane; Aby uzyskać więcej informacji na temat klonowania obiektów powiązanych z danymi, zobacz [Freezable obiektów — Omówienie](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Jeśli obiekt ma animowane właściwości zależności, kopiowane są wartości podstawowe (Nieanimowane) tych właściwości. Animacje nie są kopiowane.  
  
Należy zauważyć, że właściwości nie są kopiowane, ani nie są właściwościami tylko do odczytu.  
  
W przypadku zastąpienia tej metody należy wywołać implementację podstawową.  
  
Nie musisz mieć <see cref="M:System.Windows.Freezable.Freeze" /> wartości podczas kopiowania.  Wynik jest zamrożony <see cref="M:System.Windows.Freezable.GetAsFrozen" /> przez przed zwróceniem.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentValueAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetCurrentValueAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy zamrożoną kopię <see cref="T:System.Windows.Freezable" /> z użyciem bieżących wartości właściwości. Ponieważ kopia jest zamrożona, wszelkie zamrożone obiekty podrzędne są kopiowane przez odwołanie.</summary>
        <returns>Zamrożona kopia <see cref="T:System.Windows.Freezable" />. <see cref="P:System.Windows.Freezable.IsFrozen" /> Właściwość Copy ma <see langword="true" />ustawioną wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie tej metody jest podobne do tworzenia kopii przy użyciu <xref:System.Windows.Freezable.CloneCurrentValue%2A> , a następnie zamrażania <xref:System.Windows.Freezable.Freeze%2A> za pomocą metody.  
  
 Metody <xref:System.Windows.Freezable.GetAsFrozen%2A> <xref:System.Windows.Freezable> i <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> mogą zwiększyć wydajność kopiowania, ponieważ nie powielają obiektów podrzędnych, które są już zamrożone; są one kopiowane tylko przez odwołanie.  
  
 Poniższa tabela zawiera podsumowanie różnic między <xref:System.Windows.Freezable.GetAsFrozen%2A> metodami i. <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>  
  
|Akcja|Zachowanie metody GetAsFrozen|Zachowanie metody GetCurrentValueAsFrozen|  
|------------|---------------------------------|---------------------------------------------|  
|Kopiowanie właściwości zależności, która ma wyrażenie|Metoda zgłasza <xref:System.InvalidOperationException> , ponieważ nie może <xref:System.Windows.Freezable.Freeze%2A> właściwości.|Bieżąca wartość wyrażenia jest kopiowana, ale nie sama wyrażenie.|  
|Kopiowanie właściwości zależności animowanej|Wartość podstawowa (nieanimowana) właściwości jest kopiowana. Animacje nie są kopiowane.|Bieżąca animowana wartość właściwości jest kopiowana. Animacje nie są kopiowane.|  
  
 Należy zauważyć, że właściwości nie są kopiowane, ani nie są właściwościami tylko do odczytu.  
  
 Aby utworzyć kopię <xref:System.Windows.Freezable> , która nie jest zamrożona, <xref:System.Windows.Freezable.CloneCurrentValue%2A> Użyj metody.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ta metoda używa wirtualnej <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> metody do tworzenia klonu.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable"><see cref="T:System.Windows.Freezable" /> Do kopiowania i zablokowania.</param>
        <summary>Sprawia, że bieżące wystąpienie jest zablokowanym klonem <see cref="T:System.Windows.Freezable" />określonego. Jeśli obiekt ma animowane właściwości zależności, ich bieżące wartości animowane są kopiowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> metodę i nie powinna być wywoływana bezpośrednio z kodu, chyba że podczas wywoływania implementacji podstawowej podczas zastępowania tej metody. Aby utworzyć zamrożoną kopię bieżącego obiektu, wywołaj <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> zamiast wywołania tej metody bezpośrednio.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Jeśli pochodzą z <see cref="T:System.Windows.Freezable" />, może być konieczne zastąpienie tej metody. Przyczyny zastąpienia obejmują następujące elementy: 
-Klasa pochodna ma dane, które nie są udostępniane za pośrednictwem właściwości zależności.  
  
-Klasa pochodna musi wykonać dodatkową operację inicjalizacji, której nie można osiągnąć przez po <see cref="M:System.Windows.Freezable.CreateInstanceCore" />prostu zastąpienie. Na przykład ma to zastosowanie w przypadku implementowania <see cref="T:System.ComponentModel.ISupportInitialize" />klasy pochodnej.  
  
Klasy, w których są przechowywane wszystkie dane we właściwościach zależności, które nie muszą wykonywać dodatkowej pracy inicjującej, nie muszą <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />zostać przesłonięte.  
  
Należy koniecznie, aby wszystkie implementacje wywoływały podstawową implementację tej metody. Implementacje powinny wykonywać wyłącznie zadania, które nie są wykonywane przez implementację domyślną. Domyślna implementacja tworzy nowy <see cref="T:System.Windows.Freezable" /> <see cref="M:System.Windows.Freezable.CreateInstance" /> przy użyciu metody i tworzy głębokie kopie niezamrożonych obiektów Freezable platformie i kopii wszystkich innych zapisywalnych, lokalnie ustawionych właściwości. Jeśli obiekt ma właściwości zależności powiązane z danymi, powiązania danych są kopiowane, ale mogą nie być już rozpoznawane; Aby uzyskać więcej informacji na temat klonowania obiektów powiązanych z danymi, zobacz [Freezable obiektów — Omówienie](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Jeśli obiekt ma animowane właściwości zależności, bieżąca animowana wartość tych właściwości jest kopiowana, ale animacje nie są.  
  
Właściwości zależności tylko do odczytu w ramach <see cref="T:System.Windows.Freezable" /> nie są kopiowane przez tę domyślną implementację.  
  
W przypadku zastąpienia tej metody należy wywołać implementację podstawową.  
  
Nie musisz mieć <see cref="M:System.Windows.Freezable.Freeze" /> wartości podczas kopiowania.  Wynik jest zamrożony <see cref="M:System.Windows.Freezable.GetAsFrozen" /> przez przed zwróceniem.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrozen : bool" Usage="System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy obiekt jest obecnie modyfikowalny.</summary>
        <value><see langword="true" />Jeśli obiekt jest zablokowany i nie można go modyfikować; <see langword="false" /> Jeśli obiekt może być modyfikowany.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podjęto próbę zmodyfikowania obiektu, <xref:System.Windows.Freezable.IsFrozen%2A> <xref:System.InvalidOperationException>gdy jego `true` Właściwość zgłosi.  
  
 Ta właściwość jest tylko do odczytu z perspektywy modelu obiektów. Niektóre z dokumentacji dotyczącej <xref:System.Windows.Freezable> zachowań mogą zawierać "zestawy <xref:System.Windows.Freezable.IsFrozen%2A> do `true`" lub podobne Języki podczas <xref:System.Windows.Freezable>omawiania zachowania innych metod, ale takie zachowanie jest wykonywane wewnętrznie w wystąpieniach klasy, gdy metody wystąpienia manipulują zmiennymi prywatnymi, które istnieją w klasie abstrakcyjnej. Aby ustawić wartość tej właściwości, należy wywołać metodę <xref:System.Windows.Freezable.Freeze%2A>. Efektywnie jest to jednorazowa operacja zmiany <xref:System.Windows.Freezable.IsFrozen%2A> właściwości z początkowego stanu domyślnego `false` na `true` stan. Nie ma dostępnego sposobu ustawienia wartości z powrotem `false`. Zamiast tego można zmienić wszystkie głębokie kopie wykonane z oryginału (patrz <xref:System.Windows.Freezable.Clone%2A> Metoda). Jest to zaprojektowane i ma wpływ na to, jak każda klasa pochodna powinna zachowywać się w <xref:System.Windows.Freezable> przypadku zastosowania do przypadków, w których wzorzec jest przydatny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : unit -&gt; unit&#xA;override this.OnChanged : unit -&gt; unit" Usage="freezable.OnChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywoływana, gdy bieżący <see cref="T:System.Windows.Freezable" /> obiekt jest modyfikowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana za każdym <xref:System.Windows.Freezable.Changed> razem, gdy wystąpi zdarzenie.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas implementowania klasy, która pochodzi od <see cref="T:System.Windows.Freezable" />, można zastąpić tę metodę w celu wykonania zadań.</para></block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapewnia, że dla składowej danych typu <see cref="T:System.Windows.DependencyObject" /> , który został właśnie zmodyfikowany, są ustanowione odpowiednie wskaźniki kontekstu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">Poprzednia wartość elementu członkowskiego danych.</param>
        <param name="newValue">Bieżąca wartość elementu członkowskiego danych.</param>
        <summary>Zapewnia, że dla <see cref="T:System.Windows.DependencyObjectType" /> elementu członkowskiego danych, który został właśnie ustawiony, są ustanowione odpowiednie wskaźniki kontekstu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna być wywoływana przez <xref:System.Windows.Freezable> dziedziczenie za każdym <xref:System.Windows.DependencyObject> razem, gdy element członkowski danych, który nie <xref:System.Windows.DependencyProperty> jest przechowywany jako jest ustawiony.  
  
 Ta metoda nie musi być wywoływana dla <xref:System.Windows.DependencyObject> składowych danych, które są przechowywane <xref:System.Windows.DependencyProperty>przy użyciu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">Poprzednia wartość elementu członkowskiego danych.</param>
        <param name="newValue">Bieżąca wartość elementu członkowskiego danych.</param>
        <param name="property">Właściwość, która zmieniła się.</param>
        <summary>Ten element członkowski obsługuje [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastrukturę i nie jest przeznaczony do użycia bezpośrednio w kodzie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="freezable.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzenia, które zawierają informacje o tym, która właściwość została zmieniona, oraz jego stare i nowe wartości.</param>
        <summary>Zastępuje implementację programu <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> , aby wywołać wszystkie <see cref="E:System.Windows.Freezable.Changed" /> procedury obsługi w odpowiedzi na zmianę właściwości zależności typu <see cref="T:System.Windows.Freezable" />. <see cref="T:System.Windows.DependencyObject" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane zdarzenia zawierają informacje dotyczące <xref:System.Windows.Freezable> samego siebie. Wszelkie informacje o właściwościach podrzędnych muszą być uzyskiwane <xref:System.Windows.Freezable.Changed> za pomocą programów obsługi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberSignature Language="F#" Value="member this.ReadPreamble : unit -&gt; unit" Usage="freezable.ReadPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia, że <see cref="T:System.Windows.Freezable" /> dostęp jest uzyskiwany z prawidłowego wątku. Dziedziczenia [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] muszą wywołać tę metodę na początku każdego, który odczytuje składowe danych, które nie są właściwościami zależności. <see cref="T:System.Windows.Freezable" /></summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Klasy, które pochodzą <see cref="T:System.Windows.Freezable" /> od powinny <see cref="M:System.Windows.Freezable.ReadPreamble" /> wywołać metodę przed próbą uzyskania dostępu do wszystkich elementów członkowskich, które nie są właściwościami zależności. <see cref="M:System.Windows.Freezable.WritePreamble" /> Metoda powinna być wywoływana przed zapisaniem jakichkolwiek takich członków.  
  
Ta metoda efektywnie wykonuje nic więcej niż wywoływanie <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />.</para></block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberSignature Language="F#" Value="member this.WritePostscript : unit -&gt; unit" Usage="freezable.WritePostscript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Podnosi zdarzenie dla i wywołuje jego <see cref="M:System.Windows.Freezable.OnChanged" /> metodę. <see cref="T:System.Windows.Freezable" /> <see cref="E:System.Windows.Freezable.Changed" /> Klasy, które pochodzą <see cref="T:System.Windows.Freezable" /> od powinny wywołać tę metodę na końcu każdego interfejsu API, który modyfikuje składowe klasy, które nie są przechowywane jako właściwości zależności.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Klasy, które pochodzą <see cref="T:System.Windows.Freezable" /> od powinny wywołać tę metodę na końcu każdego interfejsu API, który modyfikuje element członkowski klasy, który nie jest <see cref="T:System.Windows.DependencyProperty" />przechowywany jako.</para></block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberSignature Language="F#" Value="member this.WritePreamble : unit -&gt; unit" Usage="freezable.WritePreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sprawdza, czy <see cref="T:System.Windows.Freezable" /> nie jest zablokowany i czy jest dostępny z prawidłowego kontekstu wątku. <see cref="T:System.Windows.Freezable" />dziedziczenia powinny wywołać tę metodę na początku wszelkich [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] zapisów w elementach członkowskich danych, które nie są właściwościami zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> , aby sprawdzić, czy kontekst wątku jest dostępny i zgłasza wyjątek, <xref:System.Windows.Freezable> Jeśli wystąpienie jest już zablokowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Windows.Freezable" /> Wystąpienie jest zamrożone i nie może mieć elementów członkowskich, do których się odnosi.</exception>
        <block subset="none" type="overrides"><para>Klasy, które pochodzą <see cref="T:System.Windows.Freezable" /> od powinny <see cref="M:System.Windows.Freezable.WritePreamble" /> wywołać przed próbą zapisu do wszystkich elementów członkowskich, które nie są właściwościami zależności. Jeśli wywołasz <see cref="M:System.Windows.Freezable.WritePreamble" /> [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]w, możesz pominąć wywołanie <see cref="M:System.Windows.Freezable.ReadPreamble" />elementu.</para></block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>
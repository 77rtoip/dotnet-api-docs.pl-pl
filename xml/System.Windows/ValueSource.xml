<Type Name="ValueSource" FullName="System.Windows.ValueSource">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5805f4ddbc46f2fe95a7cd95d5adac5ac93260ed" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/25/2018" /><Meta Name="ms.locfileid" Value="39968545" /></Metadata><TypeSignature Language="C#" Value="public struct ValueSource" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit ValueSource extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Windows.ValueSource" />
  <TypeSignature Language="VB.NET" Value="Public Structure ValueSource" />
  <TypeSignature Language="C++ CLI" Value="public value class ValueSource" />
  <TypeSignature Language="F#" Value="type ValueSource = struct" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Raporty informacje zwrócone ze <see cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Większość informacji, które <xref:System.Windows.ValueSource> przesyła znajduje się w <xref:System.Windows.ValueSource.BaseValueSource%2A> właściwości. Ta właściwość zawiera wartość wyliczenia, który określa dokładnie jeden z aspektów ogólnej [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] system właściwości, który jest odpowiedzialny za efektywną wartość właściwości zależności.  
  
 Oprócz wartość bazową inne informacje, które mogą być interesujące o wartości właściwości zależności to czy jest animowany wartość i tego, czy wartość zawiera wyrażenie (np. powiązania, lub odwołanie do zasobu dynamicznego). Te informacje są zgłaszane przez <xref:System.Windows.ValueSource.IsAnimated%2A> i <xref:System.Windows.ValueSource.IsExpression%2A> odpowiednio. Ponadto jeśli wymuszenia działa na podstawie wartości właściwości, właściwość zachowuje żądaną wartość i wartość właściwości spróbuje się tego żądaną wartość, jeśli ograniczenia określonych wymuszenia zostaną zmienione lub zniesione. Coerced właściwość, która nie znajduje się w jego żądaną wartość zgłosi, że <xref:System.Windows.ValueSource.IsCoerced%2A> jest `true`.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
    <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
  </Docs>
  <Members>
    <Member MemberName="BaseValueSource">
      <MemberSignature Language="C#" Value="public System.Windows.BaseValueSource BaseValueSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.BaseValueSource BaseValueSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ValueSource.BaseValueSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseValueSource As BaseValueSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::BaseValueSource BaseValueSource { System::Windows::BaseValueSource get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseValueSource : System.Windows.BaseValueSource" Usage="System.Windows.ValueSource.BaseValueSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.BaseValueSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość <see cref="T:System.Windows.BaseValueSource" /> wyliczenia, które raporty źródła, które podano system właściwości zależności z wartością.</summary>
        <value>Wartość wyliczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartości bazowej nie jest wartością efektywną, jeśli przekształcenie lub animacji działa we właściwości. Sprawdź <xref:System.Windows.ValueSource.IsAnimated%2A> i <xref:System.Windows.ValueSource.IsCoerced%2A> Jeśli chcesz ustalić, czy podstawowy wartość jest wartością efektywną.  
  
 Możesz również chcieć sprawdzić <xref:System.Windows.ValueSource.IsExpression%2A> aby zobaczyć, jeśli wartości bazowej został oceniony jako poza wyrażeniem.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ValueSource.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="valueSource.Equals o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Obiekt do porównania z tym <see cref="T:System.Windows.ValueSource" />.</param>
        <summary>Zwraca wartość wskazującą czy to <see cref="T:System.Windows.ValueSource" /> jest taki sam jak określony segment.</summary>
        <returns><see langword="true" /> Jeśli podany obiekt jest odpowiednikiem bieżącego <see cref="T:System.Windows.ValueSource" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja obsługuje równość wartości, oparte na każdym z wartości właściwości każdego <xref:System.Windows.ValueSource> struktury.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ValueSource.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="valueSource.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla tego <see cref="T:System.Windows.ValueSource" />.</summary>
        <returns>Kod skrótu 32-bitowej nieoznaczonej liczby całkowitej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten kod skrótu opiera się na <xref:System.Windows.ValueSource.BaseValueSource%2A> wartość.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="IsAnimated">
      <MemberSignature Language="C#" Value="public bool IsAnimated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnimated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ValueSource.IsAnimated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnimated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnimated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnimated : bool" Usage="System.Windows.ValueSource.IsAnimated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która deklaruje, czy właściwość jest animowany.</summary>
        <value><see langword="true" /> Jeśli właściwość jest animowany; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla dowolnej właściwości, która jest obecnie animowany źródła zgłoszone przez <xref:System.Windows.ValueSource.BaseValueSource%2A> nie jest od razu istotne, ponieważ animacji operuje na wyższy priorytet właściwość zależności od wartości bazowej. Aby uzyskać więcej informacji o nadrzędności i animacji, zobacz [następstwo wartości właściwości](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.ValueSource.BaseValueSource" />
      </Docs>
    </Member>
    <Member MemberName="IsCoerced">
      <MemberSignature Language="C#" Value="public bool IsCoerced { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCoerced" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ValueSource.IsCoerced" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCoerced As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCoerced { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCoerced : bool" Usage="System.Windows.ValueSource.IsCoerced" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która deklaruje, czy ta wartość jest wynikiem <see cref="T:System.Windows.CoerceValueCallback" /> implementacji stosowany do właściwości zależności.</summary>
        <value><see langword="true" /> Jeśli wartość jest wynikiem <see cref="T:System.Windows.CoerceValueCallback" /> implementacji stosowany do właściwości zależności; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wymuszenia działa na podstawie wartości właściwości, właściwość zachowuje żądaną wartość i wartość właściwości spróbuje się tego żądaną wartość, jeśli ograniczenia określonych wymuszenia zostaną zmienione lub zniesione. Coerced właściwość, która nie znajduje się w jego żądaną wartość zgłosi, że <xref:System.Windows.ValueSource.IsCoerced%2A> jest `true`.  
  
 Wymuszanie działa na wyższy priorytet niż wartości bazowej i nie jest ściśle rzecz ujmując uczestnika, który w konfiguracji podstawowej wartości. W związku z tym wykorzystaną stan jest zgłaszany przez tę właściwość, a nie przez wartość <xref:System.Windows.BaseValueSource> wyliczenia. Aby uzyskać więcej informacji na temat wymuszenia, wartości podstawowe i pierwszeństwo zobacz [następstwo wartości właściwości](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.ValueSource.BaseValueSource" />
      </Docs>
    </Member>
    <Member MemberName="IsCurrent">
      <MemberSignature Language="C#" Value="public bool IsCurrent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCurrent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ValueSource.IsCurrent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCurrent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCurrent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCurrent : bool" Usage="System.Windows.ValueSource.IsCurrent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informację, czy wartość została ustawiona <see cref="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" /> metody.</summary>
        <value><see langword="true" /> Jeśli wartość została ustawiona <see cref="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" /> metoda; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExpression">
      <MemberSignature Language="C#" Value="public bool IsExpression { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExpression" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ValueSource.IsExpression" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExpression As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExpression { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExpression : bool" Usage="System.Windows.ValueSource.IsExpression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która deklaruje, czy ta wartość jest wynikiem obliczane wyrażenie. Może to być <see cref="T:System.Windows.Data.BindingExpression" /> obsługi powiązanie lub wyrażenie wewnętrzne, takie jak te, które obsługują [dynamicresource — rozszerzenie znaczników](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md).</summary>
        <value><see langword="true" /> Jeśli wartość pochodzi z wyrażenia ocenianego; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obliczane wyrażenie będzie również zgłosić określonej wartości bazowej ustawienie warunku, w którym wyrażenie została zastosowana, jako wartość <xref:System.Windows.ValueSource.BaseValueSource%2A>. <xref:System.Windows.ValueSource.BaseValueSource%2A> Nadal jest bardzo istotne dla dowolnej właściwości, których <xref:System.Windows.ValueSource.IsExpression%2A> jest `true`. Wiedząc, czy wartość pochodzi przy użyciu wyrażenia może być szczególnie przydatne, jeśli wartość została ustawiona pośrednio, takie jak za pomocą szablonu lub wartość właściwość dziedziczona.  
  
 Jeśli wyrażenie, które kończy się niepowodzeniem (powiązanie nie powiodło się; został znaleziony żaden zasób o takiej nazwie), a następnie wartość będą pochodzić z innych uczestnikiem systemu właściwość najbardziej prawdopodobną wartość domyślną. Następnie zgłaszania tego źródła w <xref:System.Windows.ValueSource.BaseValueSource%2A>. Obliczanie nie powiodło się wyrażenie zwróci `false` dla <xref:System.Windows.ValueSource.IsExpression%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.ValueSource.BaseValueSource" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.ValueSource vs1, System.Windows.ValueSource vs2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Windows.ValueSource vs1, valuetype System.Windows.ValueSource vs2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ValueSource.op_Equality(System.Windows.ValueSource,System.Windows.ValueSource)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (vs1 As ValueSource, vs2 As ValueSource) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::ValueSource vs1, System::Windows::ValueSource vs2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.ValueSource * System.Windows.ValueSource -&gt; bool" Usage="vs1 = vs2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="vs1" Type="System.Windows.ValueSource" />
        <Parameter Name="vs2" Type="System.Windows.ValueSource" />
      </Parameters>
      <Docs>
        <param name="vs1">Pierwszy <see cref="T:System.Windows.ValueSource" /> do porównania.</param>
        <param name="vs2">Drugi <see cref="T:System.Windows.ValueSource" /> do porównania.</param>
        <summary>Określa, czy dwa <see cref="T:System.Windows.ValueSource" /> wystąpienia mają taką samą wartość.</summary>
        <returns><see langword="true" /> Jeśli dwa <see cref="T:System.Windows.ValueSource" /> wystąpienia są równoważne; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja wywołuje <xref:System.Windows.ValueSource.Equals%2A>, i obsługuje wartości równości, w oparciu o wszystkie właściwości <xref:System.Windows.ValueSource>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.ValueSource vs1, System.Windows.ValueSource vs2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Windows.ValueSource vs1, valuetype System.Windows.ValueSource vs2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ValueSource.op_Inequality(System.Windows.ValueSource,System.Windows.ValueSource)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (vs1 As ValueSource, vs2 As ValueSource) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::ValueSource vs1, System::Windows::ValueSource vs2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.ValueSource * System.Windows.ValueSource -&gt; bool" Usage="System.Windows.ValueSource.op_Inequality (vs1, vs2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="vs1" Type="System.Windows.ValueSource" />
        <Parameter Name="vs2" Type="System.Windows.ValueSource" />
      </Parameters>
      <Docs>
        <param name="vs1">Pierwszy <see cref="T:System.Windows.ValueSource" /> do porównania.</param>
        <param name="vs2">Drugi <see cref="T:System.Windows.ValueSource" /> do porównania.</param>
        <summary>Określa, czy dwa <see cref="T:System.Windows.ValueSource" /> wystąpień nie mają taką samą wartość.</summary>
        <returns><see langword="true" /> Jeśli dwa <see cref="T:System.Windows.ValueSource" /> wystąpienia nie są równoważne; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja wywołuje <xref:System.Windows.ValueSource.Equals%2A>, zwracając negacji i obsługuje równość wartości na podstawie wszystkich właściwości <xref:System.Windows.ValueSource>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
  </Members>
</Type>
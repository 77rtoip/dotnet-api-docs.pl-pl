<Type Name="ValueSource" FullName="System.Windows.ValueSource">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a9b2f2c569798c43932db9b71677e6a6716103c9" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69443752" /></Metadata><TypeSignature Language="C#" Value="public struct ValueSource" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit ValueSource extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Windows.ValueSource" />
  <TypeSignature Language="VB.NET" Value="Public Structure ValueSource" />
  <TypeSignature Language="C++ CLI" Value="public value class ValueSource" />
  <TypeSignature Language="F#" Value="type ValueSource = struct" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Raportuje informacje zwracane z <see cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Większość informacji <xref:System.Windows.ValueSource> przesyłanych przez transmisję jest zawartych <xref:System.Windows.ValueSource.BaseValueSource%2A> we właściwości. Ta właściwość zawiera wartość wyliczenia, która określa dokładnie jeden aspekt ogólnego [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] systemu właściwości, który jest odpowiedzialny za wartość efektywną właściwości zależności.  
  
 Oprócz wartości bazowej inne informacje, które mogą być interesujące dla wartości właściwości zależności, to czy wartość jest animowana i czy wartość obejmuje wyrażenie (takie jak powiązanie lub odwołanie do zasobu dynamicznego). Te informacje są raportowane <xref:System.Windows.ValueSource.IsAnimated%2A> <xref:System.Windows.ValueSource.IsExpression%2A> odpowiednio przez program. Ponadto, jeśli przymus działa na wartości właściwości, właściwość zachowuje żądaną wartość, a wartość właściwości podejmie próbę uzyskania dostępu do żądanej wartości, jeśli ograniczenia określonego przekształcenia zostaną zmienione lub zniesione. Właściwość przymusowa, która nie znajduje się na żądanej wartości, spowoduje zgłoszenie <xref:System.Windows.ValueSource.IsCoerced%2A> , `true`że jest to.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
    <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
  </Docs>
  <Members>
    <Member MemberName="BaseValueSource">
      <MemberSignature Language="C#" Value="public System.Windows.BaseValueSource BaseValueSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.BaseValueSource BaseValueSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ValueSource.BaseValueSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseValueSource As BaseValueSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::BaseValueSource BaseValueSource { System::Windows::BaseValueSource get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseValueSource : System.Windows.BaseValueSource" Usage="System.Windows.ValueSource.BaseValueSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.BaseValueSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość <see cref="T:System.Windows.BaseValueSource" /> wyliczenia, która raportuje źródło, które dostarczyło system właściwości zależności z wartością.</summary>
        <value>Wartość wyliczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość podstawowa nie jest wartością efektywną, jeśli dla właściwości działa wymuszone lub animacje. Sprawdź <xref:System.Windows.ValueSource.IsAnimated%2A> ,<xref:System.Windows.ValueSource.IsCoerced%2A> czy chcesz określić, czy wartość podstawowa jest wartością efektywną.  
  
 Warto również sprawdzić <xref:System.Windows.ValueSource.IsExpression%2A> , czy wartość podstawowa została oceniona z wyrażenia.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ValueSource.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="valueSource.Equals o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Obiekt, który ma zostać porównany z tym <see cref="T:System.Windows.ValueSource" />elementem.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Windows.ValueSource" /> jest równa określonego obiektu.</summary>
        <returns><see langword="true" />Jeśli podany obiekt jest równoważny z bieżącym <see cref="T:System.Windows.ValueSource" />; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja obsługuje równość wartości na podstawie każdej wartości właściwości każdej <xref:System.Windows.ValueSource> struktury.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ValueSource.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="valueSource.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla tego <see cref="T:System.Windows.ValueSource" />elementu.</summary>
        <returns>32-bitowy kod skrótu unsigned Integer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten kod skrótu jest określany na <xref:System.Windows.ValueSource.BaseValueSource%2A> podstawie wartości.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="IsAnimated">
      <MemberSignature Language="C#" Value="public bool IsAnimated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnimated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ValueSource.IsAnimated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnimated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnimated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnimated : bool" Usage="System.Windows.ValueSource.IsAnimated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która deklaruje, czy właściwość jest animowana.</summary>
        <value><see langword="true" />Jeśli właściwość jest animowana; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla każdej właściwości, która jest aktualnie animowana, Źródło zgłoszone <xref:System.Windows.ValueSource.BaseValueSource%2A> przez nie jest natychmiast istotne, ponieważ animacja działa przy wyższym priorytecie właściwości zależności niż wartość podstawowa. Aby uzyskać więcej informacji na temat pierwszeństwa i animacji, zobacz [pierwszeństwo wartości właściwości zależności](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.ValueSource.BaseValueSource" />
      </Docs>
    </Member>
    <Member MemberName="IsCoerced">
      <MemberSignature Language="C#" Value="public bool IsCoerced { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCoerced" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ValueSource.IsCoerced" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCoerced As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCoerced { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCoerced : bool" Usage="System.Windows.ValueSource.IsCoerced" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która deklaruje, czy ta wartość wynika z <see cref="T:System.Windows.CoerceValueCallback" /> implementacji zastosowanej do właściwości zależności.</summary>
        <value><see langword="true" />Jeśli wartość wynika z <see cref="T:System.Windows.CoerceValueCallback" /> implementacji zastosowanej do właściwości zależności; <see langword="false" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli przymus działa na wartości właściwości, właściwość zachowuje żądaną wartość, a wartość właściwości podejmie próbę uzyskania dostępu do żądanej wartości, jeśli ograniczenia określonego przekształcenia zostaną zmienione lub zniesione. Właściwość przymusowa, która nie znajduje się na żądanej wartości, spowoduje zgłoszenie <xref:System.Windows.ValueSource.IsCoerced%2A> , `true`że jest to.  
  
 Przymus działa przy wyższym priorytecie niż wartość podstawowa i nie jest ściśle mówiący o tym, jak jest ustawiona wartość podstawowa. W związku z tym stan przymusu jest raportowany przez tę właściwość, a nie przez wartość <xref:System.Windows.BaseValueSource> wyliczenia. Aby uzyskać więcej informacji na temat przymusu, wartości podstawowych i pierwszeństwa, zobacz [pierwszeństwo wartości właściwości zależności](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.ValueSource.BaseValueSource" />
      </Docs>
    </Member>
    <Member MemberName="IsCurrent">
      <MemberSignature Language="C#" Value="public bool IsCurrent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCurrent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ValueSource.IsCurrent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCurrent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCurrent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCurrent : bool" Usage="System.Windows.ValueSource.IsCurrent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy wartość została ustawiona przez <see cref="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" /> metodę.</summary>
        <value><see langword="true" />Jeśli wartość została ustawiona przez <see cref="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" /> metodę; <see langword="false" />w przeciwnym razie.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExpression">
      <MemberSignature Language="C#" Value="public bool IsExpression { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExpression" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ValueSource.IsExpression" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExpression As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExpression { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExpression : bool" Usage="System.Windows.ValueSource.IsExpression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która deklaruje, czy ta wartość wynika z obliczanego wyrażenia. Może to być <see cref="T:System.Windows.Data.BindingExpression" /> obsługiwane powiązanie lub wewnętrzne wyrażenie, takie jak te, które obsługują [rozszerzenie znacznika DynamicResource —](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md).</summary>
        <value><see langword="true" />Jeśli wartość pochodzi z wyrażenia obliczanego; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obliczane wyrażenie również raportuje określony warunek ustawienia wartości podstawowej, gdzie wyrażenie zostało zastosowane, jako wartość w <xref:System.Windows.ValueSource.BaseValueSource%2A>. Jest nadal bardzo istotny dla każdej właściwości, <xref:System.Windows.ValueSource.IsExpression%2A> gdzie `true`is. <xref:System.Windows.ValueSource.BaseValueSource%2A> Wiadomo, czy wartość dołączona przez wyrażenie może być szczególnie przydatna, jeśli wartość została ustawiona pośrednio, na przykład za pomocą szablonu lub dziedziczonej wartości właściwości.  
  
 Jeśli wyrażenie nie zostanie oszacowane (powiązanie nie powiodło się; nie znaleziono zasobu o tej nazwie), wartość będzie pochodzić z innego uczestnika w systemie właściwości, najprawdopodobniej z wartością domyślną. To źródło zostanie następnie zgłoszone <xref:System.Windows.ValueSource.BaseValueSource%2A>w programie. Obliczenia wyrażeń zakończonych niepowodzeniem `false` zostaną <xref:System.Windows.ValueSource.IsExpression%2A>zwrócone.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.ValueSource.BaseValueSource" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.ValueSource vs1, System.Windows.ValueSource vs2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Windows.ValueSource vs1, valuetype System.Windows.ValueSource vs2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ValueSource.op_Equality(System.Windows.ValueSource,System.Windows.ValueSource)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (vs1 As ValueSource, vs2 As ValueSource) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::ValueSource vs1, System::Windows::ValueSource vs2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.ValueSource * System.Windows.ValueSource -&gt; bool" Usage="vs1 = vs2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="vs1" Type="System.Windows.ValueSource" />
        <Parameter Name="vs2" Type="System.Windows.ValueSource" />
      </Parameters>
      <Docs>
        <param name="vs1">Pierwszy <see cref="T:System.Windows.ValueSource" /> do porównania.</param>
        <param name="vs2">Sekunda <see cref="T:System.Windows.ValueSource" /> do porównania.</param>
        <summary>Określa, czy <see cref="T:System.Windows.ValueSource" /> dwa wystąpienia mają tę samą wartość.</summary>
        <returns><see langword="true" />Jeśli dwa <see cref="T:System.Windows.ValueSource" /> wystąpienia są równoważne; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja wywołuje <xref:System.Windows.ValueSource.Equals%2A>i obsługuje równość wartości na podstawie wszystkich <xref:System.Windows.ValueSource>właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.ValueSource vs1, System.Windows.ValueSource vs2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Windows.ValueSource vs1, valuetype System.Windows.ValueSource vs2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ValueSource.op_Inequality(System.Windows.ValueSource,System.Windows.ValueSource)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (vs1 As ValueSource, vs2 As ValueSource) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::ValueSource vs1, System::Windows::ValueSource vs2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.ValueSource * System.Windows.ValueSource -&gt; bool" Usage="System.Windows.ValueSource.op_Inequality (vs1, vs2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="vs1" Type="System.Windows.ValueSource" />
        <Parameter Name="vs2" Type="System.Windows.ValueSource" />
      </Parameters>
      <Docs>
        <param name="vs1">Pierwszy <see cref="T:System.Windows.ValueSource" /> do porównania.</param>
        <param name="vs2">Sekunda <see cref="T:System.Windows.ValueSource" /> do porównania.</param>
        <summary>Określa, czy <see cref="T:System.Windows.ValueSource" /> dwa wystąpienia nie mają tej samej wartości.</summary>
        <returns><see langword="true" />Jeśli dwa <see cref="T:System.Windows.ValueSource" /> wystąpienia nie są równoważne; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja wywołuje <xref:System.Windows.ValueSource.Equals%2A>, zwracając swoją negację i obsługuje równość wartości na podstawie wszystkich <xref:System.Windows.ValueSource>właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
  </Members>
</Type>

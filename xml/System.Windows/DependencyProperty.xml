<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata><Meta Name="ms.openlocfilehash" Value="48e189814c9d38e818a9d416a18db9a92e096f66" /><Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="10/04/2018" /><Meta Name="ms.locfileid" Value="48623040" /></Metadata><TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <TypeSignature Language="F#" Value="type DependencyProperty = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje właściwość, którą można ustawić za pomocą metody takie jak, stylów, powiązań danych, animacji i dziedziczenia.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.DependencyProperty> obsługuje następujące funkcje w [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]:  
  
-   Właściwość można ustawić w stylu. Aby uzyskać więcej informacji, zobacz [Tworzenie szablonów i stylów](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
-   Właściwość można ustawić za pomocą powiązania danych. Aby uzyskać więcej informacji na temat właściwości zależności powiązania danych, zobacz [porady: powiązywanie właściwości dwóch formantów](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md).  
  
-   Można ustawić właściwości z odwołaniem do zasobu dynamicznego. Aby uzyskać więcej informacji, zobacz [zasoby XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
-   Właściwości mogą dziedziczyć wartość automatycznie elementu nadrzędnego w drzewie elementów. Aby uzyskać więcej informacji, zobacz [dziedziczenie wartości właściwości](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
-   Właściwości mogą być animowane. Aby uzyskać więcej informacji, zobacz [Przegląd animacja](~/docs/framework/wpf/graphics-multimedia/animation-overview.md).  
  
-   Właściwość może zgłaszać, gdy poprzednią wartość właściwości została zmieniona i wartość właściwości może być przekształcone. Aby uzyskać więcej informacji, zobacz [zależność wartości wywołania zwrotnego i walidacji](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
-   Właściwość raporty informacji [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], takie jak czy zmiana wartości właściwości powinny wymagać system układu, aby przeskładać wizualizacji dla elementu.  
  
-   Właściwość odbiera pomocy technicznej w [!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)].  Na przykład, właściwości mogą być edytowane w **właściwości** okna.  
  
 Aby dowiedzieć się więcej na temat właściwości zależności, zobacz [Przegląd właściwości zależności](~/docs/framework/wpf/advanced/dependency-properties-overview.md). Jeśli chcesz właściwości w niestandardowych typów do obsługi funkcji na powyższej liście, należy utworzyć właściwość zależności.  Aby dowiedzieć się, jak utworzyć niestandardowe właściwości zależności, zobacz [niestandardowe właściwości zależności](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
 Dołączona właściwość jest właściwością, która umożliwia dowolnego obiektu, do informacji w raporcie na typ, który definiuje dołączona właściwość. W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], dowolny typ, który dziedziczy z <xref:System.Windows.DependencyObject> służy dołączoną właściwość niezależnie od tego, czy typ dziedziczy z typu, który definiuje właściwość. Dołączona właściwość jest funkcją [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] języka.  Aby ustawić dołączoną właściwość [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], użyj *ownerType*.* propertyName* składni. Na przykład dołączoną właściwość <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> właściwości. Jeśli chcesz utworzyć właściwości, które mogą być używane na wszystkich <xref:System.Windows.DependencyObject> typów, a następnie należy utworzyć dołączona właściwość. Aby dowiedzieć się więcej na temat dołączonych właściwości, takie jak, utworzyć zobacz [Przegląd właściwości dołączonych](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="dependencyPropertyName"/>  
- or -  
<object property="ownerType.dependencyPropertyName"/>  
- or -  
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 `dependencyPropertyName`  
 Ciąg, który określa <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType> właściwości żądaną zależności. To może być poprzedzona przez prefiks przestrzeni nazw XML, jeśli właściwość nie jest domyślny obszar nazw XML (Aby uzyskać więcej informacji, zobacz [przestrzeni nazw XAML i Namespace mapowania dla WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).)  
  
 `ownerType`.`dependencyPropertyName`  
 Ciąg określający typ właściciela właściwości zależności, kropka (.), a następnie <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>. `ownerType` może być poprzedzone prefiks przestrzeni nazw XML. Na z późnym wiązaniem — style i szablony, w którym należy określić właściciela właściwości zależności do analizowania kontekstu, ponieważ jest to użycie `TargetType` nie jest jeszcze znany. Aby uzyskać więcej informacji, zobacz [Tworzenie szablonów i stylów](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
 `attachedPropertyOwnerType` *.* `attachedPropertyName`  
 Ciąg, który określa właściciela dołączoną właściwość, kropki (.), a następnie nazwę dołączonych właściwości. `attachedPropertyOwnerType` może być poprzedzone prefiks przestrzeni nazw XML.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje inny typ jako właściciele właściwości zależności, który został już zarejestrowany do typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner ownerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">Typ do dodania jako właściciela tej właściwości zależności.</param>
        <summary>Dodaje inny typ jako właściciele właściwości zależności, który został już zarejestrowany.</summary>
        <returns>Odwołanie do oryginalnego <see cref="T:System.Windows.DependencyProperty" /> identyfikator, który identyfikuje właściwość zależności. Ten identyfikator powinny zostać ujawnione przez dodanie klasę jako <see langword="public static readonly" /> pola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia systemowi właściwości do rozpoznania właściwości zależności typu, który nie zarejestrował początkowo tej właściwości określonej zależności.  
  
 Zazwyczaj <xref:System.Windows.DependencyProperty.AddOwner%2A> służy do dodawania właściwości zależności do klas, które nie udostępniają już tę właściwość zależności za pomocą dziedziczenia klas zarządzanych (dziedziczenia klas spowodowałoby właściwości otoki, aby być dziedziczone przez klasy pochodnej, dlatego czy zapewniają ogólne tabeli składowych dostęp do właściwości zależności już). <xref:System.Windows.DependencyProperty.AddOwner%2A> Umożliwia systemowi właściwości do rozpoznania właściwości zależności typu, który nie zarejestrował początkowo tę właściwość zależności.  
  
 Ta sygnatura nie zezwala na określanie metadanych.  Gdy ta metoda metadanych jest generowany automatycznie dla nowego <xref:System.Windows.DependencyProperty> i jego typ właściciela. Wygenerowany automatycznie metadanych jest wynikiem metadanych scalony ze wszystkich typów podstawowych, które mają ta właściwość jest zdefiniowana. Jeśli brak scalonych metadanych nie jest dostępny, metadane domyślną dla właściwości jest używany. Jeśli właściwość jest zarejestrowana za pomocą <xref:System.Windows.DependencyProperty.RegisterAttached%2A> metody, a następnie metadanych domyślny jest taka sama jak metadane, który jest tworzony podczas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> została wywołana. W przeciwnym razie <xref:System.Windows.PropertyMetadata> obiekt zostanie utworzony przy użyciu <xref:System.Windows.PropertyMetadata.DefaultValue%2A> właściwość ustawioną na domyślny typ właściwości i wszystkie inne właściwości <xref:System.Windows.PropertyMetadata> ustawiono `null`. Użyj <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> podpisu, jeśli chcesz do udostępnienia metadanych dla wersji właściwości zależności w miarę dodawania do podanego typu.  
  
 Wartość zwracana przez tę metodę zwykle jest używana do deklarowania i udostępnić właściwości zależności przez przechowywanie identyfikatora właściwości zależności. Identyfikator zapewnia dostęp do właściwości zależności, aby wywołać system właściwości [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] dla właściwości zależności, szczególnie jako istnieje na dodawanie klasy właściciela. Dla tej samej nazwy właściwości pierwotnego właściciela i dodano właściciela powinny służyć do wskazania podobne funkcje. Należy używać <xref:System.Windows.DependencyProperty> zwraca wartość <xref:System.Windows.DependencyProperty.AddOwner%2A> metoda definiują identyfikatora właściwości zależności, a także do deklarowania [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] otoki właściwości, dla właściwości zależności, które są dodawane do typów przy użyciu <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 <xref:System.Windows.DependencyProperty.AddOwner%2A> Metodologii, zaleca się powyżej jest używany podczas tworzenia właściwości zależności, które są zadeklarowane w obrębie [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Na przykład zarówno <xref:System.Windows.Controls.Border> i <xref:System.Windows.Controls.Control> zdefiniować `BorderBrush` właściwości zależności, które mają podobne funkcje. <xref:System.Windows.Controls.Control> Definiuje jego `BorderBrush` właściwość system właściwości przez wywołanie metody <xref:System.Windows.DependencyProperty.AddOwner%2A> oparte na pierwotny właściciel <xref:System.Windows.Controls.Border> i jego zarejestrowany <xref:System.Windows.Controls.Border.BorderBrushProperty> identyfikator właściwości zależności. <xref:System.Windows.DependencyProperty.AddOwner%2A> Zwracają wartość jest następnie używany do ustanawiania nowego statycznego <xref:System.Windows.DependencyProperty> pola (<xref:System.Windows.Controls.Control.BorderBrushProperty>) dla tej właściwości na dodano właściciela i `BorderBrush` zadeklarowano również właściwość otoki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner (ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">Typ do dodania jako właściciela tej właściwości zależności.</param>
        <param name="typeMetadata">Metadane, które kwalifikują się właściwość zależności, ponieważ znajduje się na podany typ.</param>
        <summary>Dodaje inny typ jako właściciele właściwości zależności, który został już zarejestrowany, zapewniając metadane zależności właściwości dla właściwości zależności, będą znajdować się na typ właściciela podana.</summary>
        <returns>Odwołanie do oryginalnego <see cref="T:System.Windows.DependencyProperty" /> identyfikator, który identyfikuje właściwość zależności. Ten identyfikator powinny zostać ujawnione przez dodanie klasę jako <see langword="public static readonly" /> pola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia systemowi właściwości do rozpoznania właściwości zależności typu, który nie zarejestrował początkowo tej właściwości określonej zależności.  
  
 Wartość zwracana przez tę metodę służy do deklarowania i udostępnić właściwości zależności szczególnie w przypadku, ponieważ znajduje się na dodawanie klasy właściciela. Ogólnie rzecz biorąc dla tej samej nazwy właściwości pierwotnego właściciela i dodano właściciela powinny służyć do wskazania podobne funkcje. Jest dobrą praktyką, aby udostępnić identyfikatorów, jak również jako nowe [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] otoki właściwości, dla właściwości zależności, które są dodawane do typów przy użyciu <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 <xref:System.Windows.DependencyProperty.AddOwner%2A> Metodologii, zaleca się powyżej jest używany podczas tworzenia [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] zadeklarowane wewnątrz [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Na przykład zarówno <xref:System.Windows.Controls.Border> i <xref:System.Windows.Controls.Control> zdefiniować `BorderBrush` właściwości zależności, które mają podobne funkcje. <xref:System.Windows.Controls.Control> Definiuje jego `BorderBrush` właściwość system właściwości przez wywołanie metody <xref:System.Windows.DependencyProperty.AddOwner%2A> na pierwotny właściciel <xref:System.Windows.Controls.Border> i jego zarejestrowany <xref:System.Windows.Controls.Border.BorderBrushProperty> identyfikator właściwości zależności. <xref:System.Windows.DependencyProperty.AddOwner%2A> Zwracają wartość jest następnie używany do ustanawiania statycznego <xref:System.Windows.DependencyProperty> pola (<xref:System.Windows.Controls.Control.BorderBrushProperty>) dla tej właściwości na dodano właściciela i `BorderBrush` zadeklarowano również właściwość otoki.  
  
 Identyfikator właściwości zależności dodano właściciela powinna być używana do operacji takich jak <xref:System.Windows.DependencyObject.GetValue%2A>. Jednak operacje specyficznych dla typu obejmujących typy i wystąpienia klasy, która została dodana jako właściciela z innych metadanych, będzie nadal zwracają oczekiwane wyniki nawet wtedy, gdy oryginalne (nie dodano właściciela) w określono identyfikator właściwości zależności wywołania do metod, takich jak <xref:System.Windows.DependencyObject.GetValue%2A> lub <xref:System.Windows.DependencyProperty.GetMetadata%2A>. Metadane dla właściciela dodano jest perpetuated przez <xref:System.Windows.DependencyProperty.AddOwner%2A> wywoływać samego siebie, niekoniecznie odwołuje się wyłącznie Dodawanie pola Identyfikator klasy, który jest właścicielem. Niemniej jednak jest dobrą praktyką, aby udostępnić identyfikator, a także jako nowe [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] otoki właściwości, dla właściwości zależności, które są dodawane do typów przy użyciu <xref:System.Windows.DependencyProperty.AddOwner%2A>, ponieważ w przeciwnym razie jest tworzony różnic między [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] i [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] reprezentacji właściwości.  
  
 Podany metadanych jest scalany z metadanych właściwości dla właściwości zależności, zgodnie z jego lokalizacją podstawowego właściciela. Wszystkie właściwości, które zostały określone w odpowiednich oryginalnych metadanych podstawowa zostanie utrzymany. Tylko te cechy, które konkretnie zostały zmienione w nowymi metadanymi spowoduje zastąpienie właściwości podstawowej metadanych. Niektóre cechy, takie jak <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, są zastępowane, jeśli są one określone w nowymi metadanymi. Inne, takie jak <xref:System.Windows.PropertyChangedCallback>, są połączone. Ostatecznie zachowania scalania jest zależna od typ metadanych właściwości, które są używane do zastąpienia, więc opisane tu zachowanie występuje dla istniejących klas metadanych właściwości używane przez [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] właściwości zależności. Aby uzyskać więcej informacji, zobacz [metadane zależności właściwości](~/docs/framework/wpf/advanced/dependency-property-metadata.md) i [metadane właściwości szablonu](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMetadata : System.Windows.PropertyMetadata" Usage="System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera metadane domyślne właściwości zależności.</summary>
        <value>Metadane domyślne właściwości zależności.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metadane domyślne są metadane właściwości, która jest dostępna dla danego obiektu lub obiektu typu pochodnego gdzie metadanych alternatywne, nie został dostarczony przez jawną <xref:System.Windows.DependencyProperty.Register%2A> lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> wywołania.  
  
 Jeśli pierwotnego właściciela zastosowane metadanych do pierwszego <xref:System.Windows.DependencyProperty.Register%2A> wywołanie ustanowione właściwości zależności, a następnie tych metadanych są zwracane jako <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
 Jeśli metadanych nie została zastosowana w oryginalnym <xref:System.Windows.DependencyProperty.Register%2A> wywołaniu, domyślne metadanych jest generowany na podstawie poziomu <xref:System.Windows.DependencyProperty.Register%2A> wywołania i ta wartość jest zwracana jako <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
 Głównym celem o domyślnej metadane skojarzone z <xref:System.Windows.DependencyProperty> jest dostarczanie wartości domyślnej dla tej właściwości na dowolnym <xref:System.Windows.DependencyObject> albo typu pochodnego.  
  
 Nie dołączony właściwości nie można rzutować typu metadanych, zwracane przez tę właściwość, dla typów pochodnych <xref:System.Windows.PropertyMetadata> typ, nawet wtedy, gdy właściwość pierwotnie został zarejestrowany za pomocą typu pochodnego metadanych. Jeśli pierwotnie zarejestrowanego metadane, takie jak jego typ oryginalny prawdopodobnie pochodnej metadanych, należy wywołać <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29> przekazywania, oryginalnym rejestrowanie zamiast tego wpisz jako parametr.  
  
 W przypadku dołączonych właściwości typ metadanych zwróconych przez tę właściwość będą zgodne typu podanego w oryginalnym <xref:System.Windows.DependencyProperty.RegisterAttached%2A> metodę rejestracji.  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyProperty.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla tego <see cref="T:System.Windows.DependencyProperty" />.</summary>
        <returns>Wartość skrótu dla tego <see cref="T:System.Windows.DependencyProperty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 System właściwości używa swojego unikatowego identyfikatora <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, a wartość właściwości jest zwracany przez <xref:System.Windows.DependencyProperty.GetHashCode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca metadane skojarzone z tą właściwością zależności, zgodnie z jego lokalizacją dla określonego typu. Może to być typ tam, gdzie właściwość zależności nie pierwszy z nich zarejestrowany, do którego został dodany później, lub typu, w którym właściwość zależności została uzyskana za pośrednictwem dziedziczenia, ale metadane zostały zostało pominięte.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : Type -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata forType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">Określony typ, z którego można pobrać metadanych właściwości zależności.</param>
        <summary>Zwraca metadane dla tej właściwości zależności, zgodnie z jego lokalizacją w określonym istniejącego typu.</summary>
        <returns>Obiekt metadanych właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określanie typu lub odwołanie do obiektu, do użycia jako typ jest to konieczne, ponieważ metadane mogą się różnić od oryginalnej rejestracji ze względu na <xref:System.Windows.DependencyProperty.AddOwner%2A> lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> wywołań, które zmiany metadanych właściwości zależności, zgodnie z jego lokalizacją w danym typie.  
  
   
  
## Examples  
 Poniższy przykład pobiera metadane dla właściwości zależności na podstawie jego typu. Typ uzyskuje się za pomocą `typeof` operatora.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObject -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Obiekt zależności, który jest sprawdzany pod kątem typu, aby określić wersję właściwości zależności typu metadanych powinny pochodzić z.</param>
        <summary>Zwraca metadane dla tej właściwości zależności, ponieważ znajduje się na wystąpienie określonego obiektu.</summary>
        <returns>Obiekt metadanych właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określanie typu lub odwołanie do obiektu jest konieczne, ponieważ metadane wszelkie danej właściwości zależności mogą się różnić od oryginalnej rejestracji ze względu na <xref:System.Windows.DependencyProperty.AddOwner%2A> lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> wywołań, które można dostosować metadanych właściwości modelu, ponieważ znajduje się na Typ.  
  
 W przypadku żądania metadanych właściwości modelu w oparciu o wystąpienie, tylko przekazujesz wystąpienie, aby jego typu, które mogą być obliczane wewnętrznie. Metadane zależności właściwości nie mogą różnić się dla każdego wystąpienia; jest zawsze spójne dla dowolnej kombinacji właściwości danego typu.  
  
   
  
## Examples  
 Poniższy przykład pobiera metadane dla właściwości zależności, w oparciu o określonym <xref:System.Windows.DependencyObject> wystąpienia.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObjectType -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObjectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">Określonego obiektu, który rejestruje zależność typu obiektu, z którego pożądany jest metadane zależności właściwości.</param>
        <summary>Zwraca metadane dla tej właściwości zależności, zgodnie z jego lokalizacją w określonym typie.</summary>
        <returns>Obiekt metadanych właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określanie typu lub odwołanie do obiektu jest konieczne, ponieważ metadane wszelkie danej właściwości zależności mogą się różnić od oryginalnej rejestracji ze względu na <xref:System.Windows.DependencyProperty.AddOwner%2A> lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> wywołań, które można dostosować metadanych właściwości modelu, ponieważ znajduje się na Typ.  
  
   
  
## Examples  
 Poniższy przykład pobiera metadane dla właściwości zależności, na podstawie jego <xref:System.Windows.DependencyObjectType>.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalIndex : int" Usage="System.Windows.DependencyProperty.GlobalIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wewnętrznie generowane, który unikatowo identyfikuje właściwość zależności.</summary>
        <value>Unikatowy identyfikator liczbowy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość jest liczbą całkowitą nie Unikatowy identyfikator globalny (GUID). Ogólnie rzecz biorąc ta wartość indeksu nie jest wymagane, a brak jest indeks dostępu do tabel wszystkich właściwości zależności. Właściwości zależności zamiast tego należy odwoływać się ich pola identyfikator.  
  
 <xref:System.Windows.DependencyProperty.GlobalIndex%2A> jest używana wewnętrznie do szybszy dostęp do struktury danych, które używają <xref:System.Windows.DependencyProperty.GlobalIndex%2A> jako indeks tablicę indeksowaną od zera. Użycie podobnych niektóre aplikacje dla projektantów i narzędzi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidType : obj -&gt; bool" Usage="dependencyProperty.IsValidType value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do sprawdzenia.</param>
        <summary>Określa, czy określona wartość jest dopuszczalny dla tej właściwości zależności typu, jak porównywany z typem właściwości podane w pierwotnej rejestracji właściwość zależności.</summary>
        <returns><see langword="true" /> Jeśli określona wartość jest typu zarejestrowaną właściwość lub dopuszczalny Typ pochodny; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość `null` jest prawidłowym typem dla właściwości zależności typu odwołania lub <xref:System.Nullable%601> właściwości zależności i zwróci `true` tych przypadkach. W przypadkach, gdy właściwość zależności jest ani odwołaniem ani <xref:System.Nullable%601> typu <xref:System.Windows.DependencyProperty.IsValidType%2A> zwróci `false` na wartość null zamiast Zgłoś wyjątek.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Windows.DependencyProperty.IsValidType%2A> w celu sprawdzenia przed wywołaniem <xref:System.Windows.DependencyObject.SetValue%2A> we właściwości zależności.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidValue : obj -&gt; bool" Usage="dependencyProperty.IsValidValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do sprawdzenia.</param>
        <summary>Określa, czy podana wartość jest akceptowana w przypadku typu właściwości indent typ podstawowy, a także potencjalnie jeśli znajduje się w dozwolonym zakresem wartości dla tego typu.</summary>
        <returns><see langword="true" /> Jeśli wartość jest dopuszczalne i poprawnego typu lub typ pochodny; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla właściwości zależności, można określić zakres dozwolonych wartości dla tego typu za pomocą <xref:System.Windows.ValidateValueCallback> dostarczanym rejestrację właściwości zależności.  
  
 Ta metoda wywołuje <xref:System.Windows.DependencyProperty.IsValidType%2A> wewnętrznie. Jeśli nie ma właściwości zależności w danym <xref:System.Windows.ValidateValueCallback>, a następnie wywołaniem tej metody jest skutecznie równoważne z wywoływaniem <xref:System.Windows.DependencyProperty.IsValidType%2A>. Jeśli właściwość zależności <xref:System.Windows.ValidateValueCallback>i jeśli <xref:System.Windows.DependencyProperty.IsValidType%2A> będzie musiał zwrócić `true`, zwracana wartość będzie zaimplementowanego w wywołania zwrotnego.  
  
 Wartość null jest prawidłową wartością dla właściwości zależności typu odwołania lub <xref:System.Nullable%601> właściwości zależności i zwróci `true` tych przypadkach. W przypadkach, gdy właściwość zależności jest ani odwołaniem ani <xref:System.Nullable%601> typu <xref:System.Windows.DependencyProperty.IsValidType%2A> zwróci `false` na wartość null zamiast Zgłoś wyjątek.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Windows.DependencyProperty.IsValidValue%2A> w celu sprawdzenia przed wywołaniem <xref:System.Windows.DependencyObject.SetValue%2A> we właściwości zależności.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.DependencyProperty.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę właściwości zależności.</summary>
        <value>Nazwa właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej właściwości pobiera nazwa podana jako `name` parametru podczas rejestracji właściwość zależności. Ta nazwa jest niemodyfikowalna i nie może być `null` ani być pustym ciągiem. W ten sam typ właściciela rejestrację zduplikowanej nazwy są niedozwolone i zgłosi wyjątek podczas próby zarejestrowania duplikat.  
  
> [!IMPORTANT]
>  <xref:System.Windows.DependencyProperty.Name%2A> Zależności właściwość musi postępuj zgodnie z Konwencją pasującą do nazwy identyfikatora właściwości zależności minus sufiks "Property". Aby uzyskać więcej informacji, zobacz [niestandardowe właściwości zależności](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
   
  
## Examples  
 Poniższy przykład wykonuje kwerendę różne cechy identyfikatora właściwości zależności, w tym <xref:System.Windows.DependencyProperty.Name%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dostarcza alternatywnych metadanych dla tej właściwości zależności, gdy nie jest obecny na wystąpieniach o określonym typie, a metadane, które zostały zapewnione na rejestrację właściwości zależności początkowej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">Typ, w której ta właściwość zależności jest dziedziczona i gdzie zostaną zastosowane podane metadane alternatywne.</param>
        <param name="typeMetadata">Metadane właściwości zależności typu nadrzędne.</param>
        <summary>Określa alternatywne metadanych dla tej właściwości zależności, gdy nie jest obecny na wystąpieniach o określonym typie, zastępowanie metadanych, które istniały dla właściwości zależności, jak jest dziedziczona z typów podstawowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metadane zależności właściwości powinna zostać zastąpiona, zanim system właściwość używa właściwości zależności. To jest równa czas, jaki konkretne wystąpienia są tworzone przy użyciu klasy, która rejestruje właściwość zależności. Wywołania <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> powinny zostać wykonane tylko w konstruktorach statycznych typu, który zapewnia siebie jako `forType` parametru tej metody lub za pośrednictwem podobne podczas tworzenia wystąpienia. Podjęto próbę zmiany metadanych po istnieje jedno wystąpienie typu właściciela nie generuje wyjątków, ale spowoduje zachowania niespójność w systemie właściwości.  
  
 Po nawiązaniu metadanych dla zastąpienia określonej klasy pochodnej przy użyciu tej metody kolejne próby, aby zastąpić metadane w tej samej klasy pochodnej zgłosi wyjątek.  
  
 Podany metadanych jest scalany z metadanych właściwości dla właściwości zależności, zgodnie z jego lokalizacją podstawowego właściciela. Wszystkie właściwości, które zostały określone w odpowiednich oryginalnych metadanych podstawowy utrwali; tylko te cechy, które konkretnie zostały zmienione w nowymi metadanymi spowoduje zastąpienie właściwości podstawowej metadanych. Niektóre cechy, takie jak <xref:System.Windows.PropertyMetadata.DefaultValue%2A> zostały zastąpione, jeśli określona w nowymi metadanymi. Inne, takie jak <xref:System.Windows.PropertyChangedCallback>, są połączone. Ostatecznie zachowania scalania jest zależna od typ metadanych właściwości, które są używane do zastąpienia, więc opisane tu zachowanie występuje dla istniejących klas metadanych właściwości używane przez [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] właściwości zależności. Aby uzyskać więcej informacji, zobacz [metadane zależności właściwości](~/docs/framework/wpf/advanced/dependency-property-metadata.md) i [metadane właściwości szablonu](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Próbowano zastąpić metadane dla właściwości zależności tylko do odczytu (nie można wykonać operacji przy użyciu tej sygnatury).</exception>
        <exception cref="T:System.ArgumentException">Metadane już została włączona dla właściwości zależności, zgodnie z jego lokalizacją dla podanego typu.</exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata * System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">Typ, w której ta właściwość zależności jest dziedziczona i gdzie zostaną zastosowane podane metadane alternatywne.</param>
        <param name="typeMetadata">Metadane właściwości zależności typu nadrzędne.</param>
        <param name="key">Klucz dostępu dla właściwości zależności tylko do odczytu.</param>
        <summary>Dostarcza alternatywnych metadane dla właściwości zależności tylko do odczytu, gdy nie jest obecny na wystąpieniach o określonym typie, zastępowanie metadanych, które zostały zapewnione na rejestrację właściwości zależności początkowej. Należy przekazać <see cref="T:System.Windows.DependencyPropertyKey" /> dla właściwości zależności tylko do odczytu, aby uniknąć zgłaszania wyjątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podpis zawiera podstawowej implementacji dla identyfikatora właściwości zależności tylko do odczytu (<xref:System.Windows.DependencyPropertyKey>) metody. Zastępowanie metadanych właściwości zależności odczytu i zapisu, użyć <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>.  
  
 Metadane zależności właściwości powinna zostać zastąpiona, zanim system właściwość używa właściwości zależności. To jest równa godzina określone obiekty są tworzone dla klasy, która rejestruje właściwość zależności. Wywołania <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> powinny zostać wykonane tylko w konstruktorach statycznych typu, który zapewnia siebie jako `forType` parametru tej metody lub za pośrednictwem podobne podczas tworzenia wystąpienia. Podjęto próbę zmiany metadanych po istnieje jedno wystąpienie typu właściciela nie generuje wyjątków, ale spowoduje zachowania niespójność w systemie właściwości.  
  
 Po nawiązaniu metadanych dla zastąpienia określonej klasy pochodnej przy użyciu tej metody kolejne próby, aby zastąpić metadane w tej samej klasy pochodnej zgłosi wyjątek.  
  
 Podany metadanych jest scalany z metadanych właściwości dla właściwości zależności, zgodnie z jego lokalizacją podstawowego właściciela. Wszystkie właściwości, które zostały określone w odpowiednich oryginalnych metadanych podstawowy utrwali; tylko te cechy, które konkretnie zostały zmienione w nowymi metadanymi spowoduje zastąpienie właściwości podstawowej metadanych. Niektóre cechy, takie jak <xref:System.Windows.PropertyMetadata.DefaultValue%2A> zostały zastąpione, jeśli określona w nowymi metadanymi. Inne, takie jak <xref:System.Windows.PropertyChangedCallback>, są połączone. Zachowanie scalania zależy od typ metadanych właściwości, które są używane do zastępowania. Aby uzyskać więcej informacji, zobacz [metadane zależności właściwości](~/docs/framework/wpf/advanced/dependency-property-metadata.md) i [metadane właściwości szablonu](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerType : Type" Usage="System.Windows.DependencyProperty.OwnerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ obiektu, który jest zarejestrowany w systemie właściwości właściwość zależności lub dodaje się jako właściciel właściwości.</summary>
        <value>Typ obiektu, który zarejestrowanych właściwości lub dodaje się jako właściciel właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość została dostarczona podczas rejestracji właściwości. Właściciel będzie albo oryginalnego rejestrowania typu w przypadku właściwości <xref:System.Windows.DependencyProperty> identyfikator wygenerowany na podstawie <xref:System.Windows.DependencyProperty.Register%2A> wywołania lub typ, który dodaje się jako właściciel w przypadku <xref:System.Windows.DependencyProperty> identyfikator wygenerowany na podstawie <xref:System.Windows.DependencyProperty.AddOwner%2A> wywołania.  
  
 <xref:System.Windows.DependencyProperty.OwnerType%2A> w dowolnej podanej <xref:System.Windows.DependencyProperty> jest niemodyfikowalna i nie może być `null` w prawidłowym <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 Poniższy przykład pobiera typ właściciela, na podstawie identyfikatora właściwości zależności `dp`, a następnie pobiera metadane na typ właściciela dla tego samego identyfikatora. Ta operacja jest w rzeczywistości odpowiednikiem wprowadzenie <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> na `dp`.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Windows.DependencyProperty.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ, który używa jej wartość właściwości zależności.</summary>
        <value><see cref="T:System.Type" /> Wartości właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość raporty typ wartości właściwości w postaci zadeklarowanej przez oryginalnej rejestracji właściwości, za pośrednictwem `propertyType` parametru. Podobnie jak <xref:System.Windows.DependencyProperty.Name%2A>, właściwość typu właściwość zależności jest niezmienny po rejestracji.  
  
   
  
## Examples  
 Poniższy przykład wykonuje kwerendę różne cechy identyfikatora właściwości zależności, w tym <xref:System.Windows.DependencyProperty.PropertyType%2A>. Ciąg nazwy typu <xref:System.Windows.DependencyProperty.PropertyType%2A> są uzyskiwane ze zwracanego <xref:System.Type>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool" Usage="System.Windows.DependencyProperty.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy właściwość zależności identyfikowane przez to <see cref="T:System.Windows.DependencyProperty" /> wystąpienie jest właściwości zależności tylko do odczytu.</summary>
        <value><see langword="true" /> Jeśli właściwość zależności jest tylko do odczytu. w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości zależności tylko do odczytu są zarejestrowane w systemie właściwości przez wywołanie metody <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> metody, w przeciwieństwie do <xref:System.Windows.DependencyProperty.Register%2A> metody. Właściwości dołączone, również może być rejestrowany jako tylko do odczytu. zobacz <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.  
  
 Właściwości zależności tylko do odczytu wymaga <xref:System.Windows.DependencyPropertyKey> identyfikatora zamiast <xref:System.Windows.DependencyProperty> identyfikator, aby wykonywać operacje metadane, takie jak zastępowanie metadane lub ustawienia wartości. Jeśli użytkownik uzyskał zbiór <xref:System.Windows.DependencyProperty> identyfikatory za pomocą wywołania <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> lub inne [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] który uwidacznia identyfikatorów sprawdzenie <xref:System.Windows.DependencyProperty.ReadOnly%2A> wartość przed podjęciem próby wywołania <xref:System.Windows.DependencyObject.SetValue%2A> lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> za pomocą tego Identyfikator właściwości zależności jako parametr wejściowy, aby zweryfikować, że właściwość zależności, który reprezentuje identyfikator nie jest tylko do odczytu. Jeśli wartość <xref:System.Windows.DependencyProperty.ReadOnly%2A> jest `true` na właściwość zależności jest programowy sposób uzyskać odwołania do <xref:System.Windows.DependencyPropertyKey> identyfikatora właściwości zależności, z metadanych lub <xref:System.Windows.DependencyProperty> identyfikator; identyfikator muszą być dostępne jako statyczne pole w celu wywołania <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> względem właściwości zależności tylko do odczytu.  
  
 Podczas tworzenia właściwości zależności niestandardowej, a następnie zarejestruj go jako tylko do odczytu, należy zdefiniować tylko akcesor pobierania dla [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] właściwość otoki. W przeciwnym razie klasy mają mylące model obiektów dla otoki właściwości w porównaniu do dostępu do właściwości zależności zapasowy. Aby uzyskać więcej informacji, zobacz [niestandardowe właściwości zależności](~/docs/framework/wpf/advanced/custom-dependency-properties.md) lub [właściwości zależności tylko do odczytu](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
   
  
## Examples  
 Poniższy przykład pobiera metadane domyślne i właściwości identyfikatora właściwości zależności z różnych pól właściwości zależności, a informacje są używane do wypełniania tabeli, aby zaimplementować "Przeglądarka metadanych".  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje właściwość zależności.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności, aby zarejestrować. Nazwa musi być unikatowa w przestrzeni nazw rejestracji typu właściciela.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwość zależności.</param>
        <summary>Określona nazwa właściwości, typ właściwości i typ właściciela rejestruje właściwość zależności.</summary>
        <returns>Identyfikator właściwości zależności, które mają być używane do ustawiania wartości <see langword="public static readonly" /> pole w klasie. Ten identyfikator jest następnie używany do odwołań właściwość zależności w późniejszym czasie, dla operacji, takich jak programowo ustawiając jej wartość lub uzyskiwanie metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat rejestracji właściwość zależności, zobacz <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności, aby zarejestrować.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwość zależności.</param>
        <param name="typeMetadata">Metadane właściwości dla właściwości zależności.</param>
        <summary>Rejestruje właściwości zależności określona nazwa właściwości, typ właściwości, typ właściciela i metadanych właściwości modelu.</summary>
        <returns>Identyfikator właściwości zależności, które mają być używane do ustawiania wartości <see langword="public static readonly" /> pole w klasie. Ten identyfikator jest następnie używany do odwołań właściwość zależności w późniejszym czasie, dla operacji, takich jak programowo ustawiając jej wartość lub uzyskiwanie metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat rejestracji właściwość zależności, zobacz <xref:System.Windows.DependencyProperty>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności, aby zarejestrować.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwość zależności.</param>
        <param name="typeMetadata">Metadane właściwości dla właściwości zależności.</param>
        <param name="validateValueCallback">Odwołanie do wywołania zwrotnego, które należy wykonać wszelkie niestandardowego sprawdzania poprawności wartości właściwości zależności poza typowy Typ weryfikacji.</param>
        <summary>Określona nazwa właściwości, typ właściwości, typ właściciela, metadanych właściwości modelu i wywołanie zwrotne weryfikacji wartości dla właściwości rejestruje właściwość zależności.</summary>
        <returns>Identyfikator właściwości zależności, które mają być używane do ustawiania wartości <see langword="public static readonly" /> pole w klasie. Ten identyfikator jest następnie używany do odwołań właściwość zależności w późniejszym czasie, dla operacji, takich jak programowo ustawiając jej wartość lub uzyskiwanie metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat rejestracji właściwość zależności, zobacz <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 Poniższy przykład rejestruje właściwości zależności, w tym wywołanie zwrotne weryfikacji (definicja wywołanie zwrotne nie jest wyświetlany; szczegółowe informacje na temat definicji wywołania zwrotnego, <xref:System.Windows.ValidateValueCallback>).  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje dołączoną właściwość systemie właściwości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności, aby zarejestrować.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwość zależności.</param>
        <summary>Rejestruje dołączoną właściwość określona nazwa właściwości, typ właściwości i typ właściciela.</summary>
        <returns>Identyfikator właściwości zależności, które mają być używane do ustawiania wartości <see langword="public static readonly" /> pole w klasie. Ten identyfikator jest następnie używany do odwołań właściwość zależności w późniejszym czasie, dla operacji, takich jak programowo ustawiając jej wartość lub uzyskiwanie metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dołączona właściwość jest pojęciem właściwości zdefiniowane przez [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementuje dołączonych właściwości jako właściwości zależności. Ponieważ [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] właściwości dołączone właściwości zależności, mogą mieć stosowane metadanych, który może służyć przez system właściwości Ogólne operacje, takie jak raportowanie layout charakterystyki. Aby uzyskać więcej informacji, zobacz [Przegląd właściwości dołączonych](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Aby uzyskać więcej informacji na temat rejestracji właściwość zależności, zobacz <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 Poniższy przykład rejestruje dołączoną właściwość dla klasy abstrakcyjnej za pomocą tego <xref:System.Windows.DependencyProperty.RegisterAttached%2A> podpisu.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności, aby zarejestrować.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwość zależności.</param>
        <param name="defaultMetadata">Metadane właściwości dla właściwości zależności. Może to obejmować wartość domyślną, a także inne właściwości.</param>
        <summary>Rejestruje dołączoną właściwość określona nazwa właściwości, typ właściwości, typ właściciela i metadanych właściwości modelu.</summary>
        <returns>Identyfikator właściwości zależności, które mają być używane do ustawiania wartości <see langword="public static readonly" /> pole w klasie. Ten identyfikator jest następnie używany do odwołań właściwość zależności w późniejszym czasie, dla operacji, takich jak programowo ustawiając jej wartość lub uzyskiwanie metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dołączona właściwość jest pojęciem właściwości zdefiniowane przez [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementuje dołączonych właściwości jako właściwości zależności. Ponieważ [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] właściwości dołączone właściwości zależności, mogą mieć stosowane metadanych, który może służyć przez system właściwości Ogólne operacje, takie jak raportowanie layout charakterystyki. Aby uzyskać więcej informacji, zobacz [Przegląd właściwości dołączonych](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Aby uzyskać więcej informacji na temat rejestracji właściwość zależności, zobacz <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Użyj RegisterAttached dziedziczenie wartości właściwości zależności  
 Jednego konkretnego scenariusza dla rejestracji przy użyciu właściwości zależności <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zamiast <xref:System.Windows.DependencyProperty.Register%2A> służy do obsługi dziedziczenie wartości właściwości. Należy zarejestrować dziedziczenie wartości właściwości zależności za pomocą <xref:System.Windows.DependencyProperty.RegisterAttached%2A> nawet wtedy, gdy klasa definiuje metod dostępu do otoki właściwości, które uwidaczniają właściwości zależności, a nawet wtedy, gdy nie będą do udostępnienia Get * i * zestaw metod statycznych, aby zapewnić PRAWDA dołączone Właściwość metody dostępu pomocy technicznej.   Mimo że dziedziczenie wartości właściwości może pojawić się działać w przypadku właściwości zależności nie dołączony, zachowanie dziedziczenia nie dołączony właściwości przy użyciu pewnych granic elementu w drzewie środowiska uruchomieniowego jest niezdefiniowane. Rejestrowanie właściwości, jak skutecznie dołączone sprawia, że dołączona właściwość Właściwość globalną systemowi właściwości i gwarantuje, że dziedziczenie wartości właściwości działa w granicach wszystkich w obrębu drzewa. Zawsze używaj <xref:System.Windows.DependencyProperty.RegisterAttached%2A> można zarejestrować właściwości, w którym można określić <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> w metadanych. Aby uzyskać więcej informacji, zobacz [dziedziczenie wartości właściwości](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności, aby zarejestrować.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwość zależności.</param>
        <param name="defaultMetadata">Metadane właściwości dla właściwości zależności. Może to obejmować wartość domyślną, a także inne właściwości.</param>
        <param name="validateValueCallback">Odwołanie do wywołania zwrotnego, które należy wykonać wszelkie niestandardowego sprawdzania poprawności wartości właściwości zależności poza typowy Typ weryfikacji.</param>
        <summary>Rejestruje dołączoną właściwość z określonym typem właściwości, typ właściciela, metadanych właściwości modelu i wywołanie zwrotne weryfikacji wartości dla właściwości.</summary>
        <returns>Identyfikator właściwości zależności, które mają być używane do ustawiania wartości <see langword="public static readonly" /> pole w klasie. Ten identyfikator jest następnie używany do odwołań właściwość zależności w późniejszym czasie, dla operacji, takich jak programowo ustawiając jej wartość lub uzyskiwanie metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dołączona właściwość jest pojęciem właściwości zdefiniowane przez [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementuje dołączonych właściwości jako właściwości zależności. Ponieważ [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] właściwości dołączone właściwości zależności, mogą mieć stosowane metadanych, który może służyć przez system właściwości Ogólne operacje, takie jak raportowanie layout charakterystyki. Aby uzyskać więcej informacji, zobacz [Przegląd właściwości dołączonych](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Aby uzyskać więcej informacji na temat rejestracji właściwość zależności, zobacz <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Użyj RegisterAttached dziedziczenie wartości właściwości zależności  
 Jednego konkretnego scenariusza dla rejestracji przy użyciu właściwości zależności <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zamiast <xref:System.Windows.DependencyProperty.Register%2A> służy do obsługi dziedziczenie wartości właściwości. Należy zarejestrować dziedziczenie wartości właściwości zależności za pomocą <xref:System.Windows.DependencyProperty.RegisterAttached%2A> nawet wtedy, gdy klasa definiuje metod dostępu do otoki właściwości, które uwidaczniają właściwości zależności, a nawet wtedy, gdy nie będą do udostępnienia Get * i * zestaw metod statycznych, aby zapewnić PRAWDA dołączone Właściwość metody dostępu pomocy technicznej.   Mimo że dziedziczenie wartości właściwości może pojawić się działać w przypadku właściwości zależności nie dołączony, zachowanie dziedziczenia nie dołączony właściwości przy użyciu pewnych granic elementu w drzewie środowiska uruchomieniowego jest niezdefiniowane. Rejestrowanie właściwości, jak skutecznie dołączone sprawia, że dołączona właściwość Właściwość globalną systemowi właściwości i gwarantuje, że dziedziczenie wartości właściwości działa w granicach wszystkich w obrębu drzewa. Zawsze używaj <xref:System.Windows.DependencyProperty.RegisterAttached%2A> można zarejestrować właściwości, w którym można określić <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> w metadanych. Aby uzyskać więcej informacji, zobacz [dziedziczenie wartości właściwości](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
   
  
## Examples  
 Poniższy przykład rejestruje dołączoną właściwość dla klasy abstrakcyjnej za pomocą tego <xref:System.Windows.DependencyProperty.RegisterAttached%2A> podpisu. Ta dołączoną właściwość jest właściwością typu wyliczenia, a rejestracja dodaje wywołanie zwrotne weryfikacji, aby sprawdzić, czy podana wartość jest wartością wyliczenia.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje w trybie tylko do odczytu dołączona właściwość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności, aby zarejestrować.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwość zależności.</param>
        <param name="defaultMetadata">Metadane właściwości dla właściwości zależności.</param>
        <summary>Rejestruje tylko do odczytu właściwości dołączone, z określonym typem właściwości, typ właściciela i metadanych właściwości modelu.</summary>
        <returns>Klucz właściwości zależności, które mają być używane do ustawiania wartości statycznego pola tylko do odczytu w klasie, która jest następnie używany do odwołań właściwość zależności w późniejszym czasie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca typ <xref:System.Windows.DependencyPropertyKey>, podczas gdy <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zwraca typ <xref:System.Windows.DependencyProperty>. Zazwyczaj nie zostaną wprowadzone publiczne, klucze, które reprezentują właściwości tylko do odczytu, ponieważ klucze mogą być używane do ustawiania wartości właściwości zależności, wywołując <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Projekt klasy będzie miało wpływ na Twoje wymagania, ale zazwyczaj zalecane jest ograniczenie dostępu i widoczność dowolnego <xref:System.Windows.DependencyPropertyKey> tylko te części kodu, które są niezbędne, można ustawić tę właściwość zależności w ramach klasy lub aplikację logiki. Zaleca się również udostępnić identyfikator właściwości zależności dla właściwości zależności tylko do odczytu, zapewniając wartość <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> jako `public static readonly` pola w swojej klasie.  
  
 Dołączone właściwości tylko do odczytu są rzadkie scenariuszu, ponieważ podstawowy scenariusz dla dołączonej właściwości jest jej użycia w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Bez publicznej metody ustawiającej dołączonej właściwości nie można ustawić w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] składni.  
  
 Aby uzyskać więcej informacji na temat rejestracji właściwość zależności, zobacz <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Użyj RegisterAttached dziedziczenie wartości właściwości zależności  
 Jednego konkretnego scenariusza rejestrowania właściwości zależności jako dołączona jest obsługuje dziedziczenie wartości właściwości. Należy zarejestrować dziedziczenie wartości właściwości zależności za pomocą <xref:System.Windows.DependencyProperty.RegisterAttached%2A> nawet wtedy, gdy klasa definiuje metod dostępu do otoki właściwości, które uwidaczniają właściwości zależności, a nawet wtedy, gdy nie będą do udostępnienia Get * i * zestaw metod statycznych, aby zapewnić PRAWDA dołączone Właściwość metody dostępu pomocy technicznej.   Mimo że dziedziczenie wartości właściwości może pojawić się działać w przypadku właściwości zależności nie dołączony, zachowanie dziedziczenia nie dołączony właściwości przy użyciu pewnych granic elementu w drzewie środowiska uruchomieniowego jest niezdefiniowane. Rejestrowanie właściwości, jak skutecznie dołączone sprawia, że dołączona właściwość Właściwość globalną systemowi właściwości i gwarantuje, że dziedziczenie wartości właściwości działa w granicach wszystkich w obrębu drzewa. Zawsze używaj <xref:System.Windows.DependencyProperty.RegisterAttached%2A> można zarejestrować właściwości, w którym można określić <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> w metadanych. Aby uzyskać więcej informacji, zobacz [dziedziczenie wartości właściwości](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności, aby zarejestrować.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwość zależności.</param>
        <param name="defaultMetadata">Metadane właściwości dla właściwości zależności.</param>
        <param name="validateValueCallback">Odwołanie do utworzonych przez użytkownika wywołanie zwrotne, które należy wykonać wszelkie niestandardowego sprawdzania poprawności wartości właściwości zależności poza typowy Typ weryfikacji.</param>
        <summary>Rejestruje tylko do odczytu właściwości dołączone, z określonym typem właściwości, typ właściciela, metadanych właściwości modelu i wywołanie zwrotne weryfikacji.</summary>
        <returns>Klucz właściwości zależności, które mają być używane do ustawiania wartości statycznego pola tylko do odczytu w klasie, która jest następnie używany do odwoływać się do właściwości zależności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca typ <xref:System.Windows.DependencyPropertyKey>, podczas gdy <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zwraca typ <xref:System.Windows.DependencyProperty>. Zazwyczaj klucze, które reprezentuje typ <xref:System.Windows.DependencyProperty>. Zazwyczaj nie zostaną wprowadzone publiczne, klucze, które reprezentują właściwości tylko do odczytu, ponieważ klucze mogą być używane do ustawiania wartości właściwości zależności, wywołując <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Projekt klasy będzie miało wpływ na Twoje wymagania, ale zazwyczaj zalecane jest ograniczenie dostępu i widoczność dowolnego <xref:System.Windows.DependencyPropertyKey> tylko te części kodu, które są niezbędne, można ustawić tę właściwość zależności w ramach klasy lub aplikację logiki. Zaleca się również udostępnić identyfikator właściwości zależności dla właściwości zależności tylko do odczytu, zapewniając wartość <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> jako `public static readonly` pola w swojej klasie.  
  
 Dołączone właściwości tylko do odczytu są rzadkie scenariuszu, ponieważ podstawowy scenariusz dla dołączonej właściwości jest jej użycia w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Bez publicznej metody ustawiającej dołączonej właściwości nie można ustawić w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] składni.  
  
 Aby uzyskać więcej informacji na temat rejestracji właściwość zależności, zobacz <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Użyj RegisterAttached dziedziczenie wartości właściwości zależności  
 Jednego konkretnego scenariusza rejestrowania właściwości zależności, jak dołączone zamiast <xref:System.Windows.DependencyProperty.Register%2A> służy do obsługi dziedziczenie wartości właściwości. Należy zarejestrować dziedziczenie wartości właściwości zależności za pomocą <xref:System.Windows.DependencyProperty.RegisterAttached%2A> nawet wtedy, gdy klasa definiuje metod dostępu do otoki właściwości, które uwidaczniają właściwości zależności, a nawet wtedy, gdy nie będą do udostępnienia Get * i * zestaw metod statycznych, aby zapewnić PRAWDA dołączone Właściwość metody dostępu pomocy technicznej.   Mimo że dziedziczenie wartości właściwości może pojawić się działać w przypadku właściwości zależności nie dołączony, zachowanie dziedziczenia nie dołączony właściwości przy użyciu pewnych granic elementu w drzewie środowiska uruchomieniowego jest niezdefiniowane. Rejestrowanie właściwości, jak skutecznie dołączone sprawia, że dołączona właściwość Właściwość globalną systemowi właściwości i gwarantuje, że dziedziczenie wartości właściwości działa w granicach wszystkich w obrębu drzewa. Zawsze używaj <xref:System.Windows.DependencyProperty.RegisterAttached%2A> można zarejestrować właściwości, w którym można określić <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> w metadanych. Aby uzyskać więcej informacji, zobacz [dziedziczenie wartości właściwości](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje właściwości zależności jako właściwości zależności tylko do odczytu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności, aby zarejestrować.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwość zależności.</param>
        <param name="typeMetadata">Metadane właściwości dla właściwości zależności.</param>
        <summary>Rejestruje właściwości zależności tylko do odczytu z określonym typem właściwości, typ właściciela i metadanych właściwości modelu.</summary>
        <returns>Klucz właściwości zależności, które mają być używane do ustawiania wartości statycznego pola tylko do odczytu w klasie, która jest następnie używany do odwoływać się do właściwości zależności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca typ <xref:System.Windows.DependencyPropertyKey>, podczas gdy <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zwraca typ <xref:System.Windows.DependencyProperty>. Zazwyczaj nie zostaną wprowadzone publiczne, klucze, które reprezentują właściwości tylko do odczytu, ponieważ klucze mogą być używane do ustawiania wartości właściwości zależności, wywołując <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Projekt klasy będzie miało wpływ na Twoje wymagania, ale zazwyczaj zalecane jest ograniczenie dostępu i widoczność dowolnego <xref:System.Windows.DependencyPropertyKey> tylko te części kodu, które są niezbędne, można ustawić tę właściwość zależności w ramach klasy lub aplikację logiki. Zaleca się również udostępnić identyfikator właściwości zależności dla właściwości zależności tylko do odczytu, zapewniając wartość <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> jako `public static readonly` pola w swojej klasie.  
  
 Właściwości zależności tylko do odczytu są dość typowy scenariusz zarówno w istniejącym [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] i dostosowania, ponieważ inne [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] funkcje mogą wymagać właściwości zależności, nawet jeśli ta właściwość nie ma być można ustawić za obiekty wywołujące. Można użyć wartości właściwości zależności tylko do odczytu jako podstawy dla innych operacji systemu właściwości, które przyjmują właściwość zależności, takie jak utworzenie <xref:System.Windows.Trigger> na właściwość zależności w stylu.  
  
 Aby uzyskać więcej informacji na temat rejestracji właściwość zależności, zobacz <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 Poniższy przykład rejestruje `AquariumSize` właściwości zależności tylko do odczytu. W przykładzie zdefiniowano `AquariumSizeKey` kluczem wewnętrznym (tak że inne klasy w zestawie można zastąpić metadane) oraz udostępnia identyfikatora właściwości zależności na podstawie tego klucza jako `AquariumSizeProperty`. Ponadto otoki jest tworzony dla `AquariumSize`, za pomocą tylko akcesor pobierania.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności, aby zarejestrować.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwość zależności.</param>
        <param name="typeMetadata">Metadane właściwości dla właściwości zależności.</param>
        <param name="validateValueCallback">Odwołanie do utworzonych przez użytkownika wywołanie zwrotne, które należy wykonać wszelkie niestandardowego sprawdzania poprawności wartości właściwości zależności poza typowy Typ weryfikacji.</param>
        <summary>Rejestruje właściwości zależności tylko do odczytu z określonym typem właściwości, typ właściciela, metadanych właściwości modelu i wywołanie zwrotne weryfikacji.</summary>
        <returns>Klucz właściwości zależności, które mają być używane do ustawiania wartości statycznego pola tylko do odczytu w klasie, która jest następnie używany do odwołań właściwość zależności w późniejszym czasie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca typ <xref:System.Windows.DependencyPropertyKey>, podczas gdy <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zwraca typ <xref:System.Windows.DependencyProperty>. Zazwyczaj nie zostaną wprowadzone publiczne, klucze, które reprezentują właściwości tylko do odczytu, ponieważ klucze mogą być używane do ustawiania wartości właściwości zależności, wywołując <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Projekt klasy będzie miało wpływ na Twoje wymagania, ale zazwyczaj zalecane jest ograniczenie dostępu i widoczność dowolnego <xref:System.Windows.DependencyPropertyKey> tylko te części kodu, które są niezbędne, można ustawić tę właściwość zależności w ramach klasy lub aplikację logiki. Zaleca się również udostępnić identyfikator właściwości zależności dla właściwości zależności tylko do odczytu, zapewniając wartość <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> jako `public static readonly` pola w swojej klasie.  
  
 Właściwości zależności tylko do odczytu są dość typowy scenariusz. Można użyć wartości właściwości zależności tylko do odczytu jako podstawy dla innych operacji systemu właściwości, które przyjmują właściwość zależności, takie jak utworzenie <xref:System.Windows.Trigger> na właściwość zależności w stylu.  
  
 Aby uzyskać więcej informacji na temat rejestracji właściwość zależności, zobacz <xref:System.Windows.DependencyProperty>.  
  
 Sprawdzanie poprawności właściwości zależności tylko do odczytu może być mniej ważne. Poziom dostępu niepublicznych, które określisz dla klucza zmniejsza prawdopodobieństwo dla dowolnego nieprawidłowe dane wejściowe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dependencyProperty.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca ciąg reprezentujący właściwość zależności.</summary>
        <returns>Ciąg reprezentujący właściwość zależności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja zwraca <xref:System.Windows.DependencyProperty.Name%2A> wartości właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnsetValue : obj" Usage="System.Windows.DependencyProperty.UnsetValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa wartość statyczna, która jest używana przez [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] system właściwości zamiast <see langword="null" /> aby wskazać, czy właściwość istnieje, ale nie ma jej wartości ustawione przez system właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty.UnsetValue> jest to wartość wartownik, która jest używany w scenariuszach gdzie [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] właściwość system nie mógł określić zażądano <xref:System.Windows.DependencyProperty> wartość. <xref:System.Windows.DependencyProperty.UnsetValue> jest używana zamiast `null`, ponieważ `null` może być prawidłową wartością właściwości, a także prawidłowy (i często używane) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> nigdy nie jest zwracana z <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>. Gdy wywołujesz <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType> we właściwości zależności na <xref:System.Windows.DependencyObject> wypadku stosuje jedną z następujących:  
  
-   Właściwości zależności ma wartość domyślną w metadanych i ta wartość jest zwracana. Ta wartość może pochodzić z <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
-   Niektóre inne wartości zostało ustanowione przez system właściwości, a wartością domyślną jest już nieaktualny. Aby uzyskać więcej informacji, zobacz [następstwo wartości właściwości](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Ustawienie <xref:System.Windows.PropertyMetadata.DefaultValue%2A> z <xref:System.Windows.DependencyProperty.UnsetValue> specjalnie jest niedozwolone.  
  
 <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> Zwraca <xref:System.Windows.DependencyProperty.UnsetValue> kiedy żądana właściwość nie została lokalnie ustawiona.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> ma specjalne znaczenie, gdy jest używana jako wartość zwracaną <xref:System.Windows.CoerceValueCallback>. Aby uzyskać więcej informacji, zobacz [zależność wartości wywołania zwrotnego i walidacji](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 Jeśli dokonywane jest wiązanie bazę danych, należy pamiętać, że <xref:System.Windows.DependencyProperty.UnsetValue> nie jest odpowiednikiem <xref:System.DBNull.Value>, w podobny sposób jak <xref:System.DBNull.Value> nie jest równoważna wartości true wartość null.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidateValueCallback : System.Windows.ValidateValueCallback" Usage="System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wywołanie zwrotne weryfikacji wartości dla właściwości zależności.</summary>
        <value>Wywołanie zwrotne weryfikacji wartość tej właściwości zależności, zgodnie z <paramref name="validateValueCallback" /> parametru w pierwotnej rejestracji właściwość zależności.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość będzie zawierać `null` dla dowolnej właściwości zależności, bez weryfikacji zarejestrowanego wywołania zwrotnego.  
  
 Sprawdź poprawność wartości wywołania zwrotne musi działać w sensie statyczne: stosowane za pośrednictwem weryfikacji <xref:System.Windows.ValidateValueCallback> nie może określić, czy podana wartość jest prawidłowa dla każdego określonego wystąpienia. Wywołanie zwrotne tylko można określić, czy wszystkie obiekty, które posiadają właściwości zależności powinien lub nie powinien akceptować podanej wartości jako prawidłowy. Jeśli potrzebujesz do wykonywania sprawdzania poprawności, która zależy od wartości innych właściwości zależności na konkretnym wystąpieniu, użycia, wiedząc <xref:System.Windows.CoerceValueCallback> zamiast tego. <xref:System.Windows.CoerceValueCallback> Jest zarejestrowany w ramach metadane zależności właściwości, a nie bezpośrednio w ramach identyfikatora właściwości zależności. Aby uzyskać więcej informacji, zobacz [zależność wartości wywołania zwrotnego i walidacji](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>
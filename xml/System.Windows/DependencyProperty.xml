<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="de09d337e79e341ade969dc527e1b9b6c0b3d7c6" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36461427" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <TypeSignature Language="F#" Value="type DependencyProperty = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje właściwości, które można ustawić za pomocą metody takie jak, stylów, powiązań danych, animacji i dziedziczenia.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.DependencyProperty> obsługuje następujące funkcje w [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]:  
  
-   Właściwość można ustawić w stylu. Aby uzyskać więcej informacji, zobacz [stylami i tworzenia szablonów](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
-   Właściwość można ustawić za pomocą wiązania z danymi. Aby uzyskać więcej informacji na temat właściwości zależności wiązania danych zobacz [porady: powiązanie właściwości formantów dwóch](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md).  
  
-   Można ustawić właściwości z odwołaniem zasobu dynamicznego. Aby uzyskać więcej informacji, zobacz [zasobów XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
-   Właściwości mogą dziedziczyć wartość automatycznie elementu nadrzędnego w drzewie elementu. Aby uzyskać więcej informacji, zobacz [dziedziczenie wartości właściwości](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
-   Można animować właściwości. Aby uzyskać więcej informacji, zobacz [omówienie animacja](~/docs/framework/wpf/graphics-multimedia/animation-overview.md).  
  
-   Właściwość zgłosić po zmianie poprzedniej wartości właściwości i wartości właściwości mogą zostać przekształcone. Aby uzyskać więcej informacji, zobacz [wywołania zwrotne właściwości zależności i sprawdzania poprawności](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
-   Właściwość raportuje informacje do [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], takie jak czy zmiana wartości właściwości powinny wymagać systemu układu, aby przeskładać elementy wizualne dla elementu.  
  
-   Właściwość otrzymuje wsparcie w [!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)].  Na przykład właściwość może być edytowany w **właściwości** okna.  
  
 Aby dowiedzieć się więcej na temat właściwości zależności, zobacz [Przegląd właściwości zależności](~/docs/framework/wpf/advanced/dependency-properties-overview.md). Jeśli chcesz właściwości z typów niestandardowych do obsługi funkcji z powyższej listy, należy utworzyć właściwości zależności.  Informacje na temat tworzenia właściwości zależności niestandardowych, zobacz [niestandardowe właściwości zależności](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
 Dołączona właściwość jest właściwością umożliwiającą dowolnego obiektu na typ, który definiuje dołączona właściwość informacji w raporcie. W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], dowolnego typu, która dziedziczy <xref:System.Windows.DependencyObject> można użyć właściwości dołączonej niezależnie od tego, czy typ dziedziczy z typu, który definiuje właściwość. Dołączona właściwość jest funkcją [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] języka.  Aby ustawić właściwości dołączonej w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], użyj *ownerType*.* propertyName* składni. Na przykład dołączona właściwość <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> właściwości. Jeśli chcesz utworzyć właściwość, która może być używana na wszystkich <xref:System.Windows.DependencyObject> typów, a następnie należy utworzyć dołączona właściwość. Aby dowiedzieć się więcej na temat dołączone właściwości, oraz o sposobie ich tworzenia, zobacz [dołączony Przegląd właściwości](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="dependencyPropertyName"/>  
- or -  
<object property="ownerType.dependencyPropertyName"/>  
- or -  
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 `dependencyPropertyName`  
 Ciąg określający <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType> właściwości żądaną zależności. To może być poprzedzony przez prefiks przestrzeni nazw XML, jeśli właściwość nie ma domyślnej przestrzeni nazw XML (Aby uzyskać więcej informacji, zobacz [przestrzeń nazw XAML i Namespace mapowanie WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).)  
  
 `ownerType`.`dependencyPropertyName`  
 Ciąg określający typ właściciela właściwości zależności, kropkę (.), a następnie <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>. `ownerType` może być poprzedzone prefiks przestrzeni nazw XML. Dla style późnym wiązaniem i szablony, w którym należy określić właściciela właściwości zależności do analizowania kontekstu, ponieważ jest to użycie `TargetType` nie jest jeszcze znany. Aby uzyskać więcej informacji, zobacz [stylami i tworzenia szablonów](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
 `attachedPropertyOwnerType` *.* `attachedPropertyName`  
 Ciąg, który określa właściciela dołączona właściwość, kropkę (.), a następnie dołączona właściwość name. `attachedPropertyOwnerType` może być poprzedzone prefiks przestrzeni nazw XML.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje innego typu jako właściciela właściwości zależności, który został już zarejestrowany do typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner ownerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">Typ do dodania jako właściciela tej właściwości zależności.</param>
        <summary>Dodaje innego typu jako właściciela właściwości zależności, który został już zarejestrowany.</summary>
        <returns>Odwołanie do oryginalnej <see cref="T:System.Windows.DependencyProperty" /> identyfikator, który identyfikuje właściwości zależności. Ten identyfikator powinny zostać ujawnione przez dodanie klasę jako <see langword="public static readonly" /> pola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia systemowi właściwości rozpoznaje właściwości zależności na typ, który nie może zarejestrować danej właściwości zależności w szczególności początkowo.  
  
 Zazwyczaj <xref:System.Windows.DependencyProperty.AddOwner%2A> służy do dodawania właściwości zależności do klasy, które nie udostępniają już tą właściwością zależności za pomocą dziedziczenia klas zarządzanych (dziedziczenia klas spowodowałoby właściwości otoki być dziedziczone przez klasy pochodnej, dlatego czy zapewniają ogólne tabeli elementów członkowskich dostęp do właściwości zależności już). <xref:System.Windows.DependencyProperty.AddOwner%2A> Umożliwia systemowi właściwości rozpoznaje właściwości zależności na typ, który nie zarejestrował początkowo danej właściwości zależności.  
  
 Ta sygnatura nie zezwala na określanie metadanych.  Korzystając z tej metody, metadanych jest generowane automatycznie dla nowego <xref:System.Windows.DependencyProperty> i wpisz jego właściciela. Metadane automatycznie generowanej powstaje na podstawie metadanych scalony ze wszystkich typów podstawowych, których tej właściwości zdefiniowane. Jeśli brak scalonych metadanych nie jest dostępne, zostanie użyta domyślna metadane dla właściwości. Jeśli właściwość jest zarejestrowana przy użyciu <xref:System.Windows.DependencyProperty.RegisterAttached%2A> metody, a następnie metadanych domyślny jest taka sama jak metadanych, które jest tworzone, gdy <xref:System.Windows.DependencyProperty.RegisterAttached%2A> została wywołana. W przeciwnym razie <xref:System.Windows.PropertyMetadata> obiekt jest tworzony z <xref:System.Windows.PropertyMetadata.DefaultValue%2A> właściwość domyślny typ właściwości i wszystkie inne właściwości <xref:System.Windows.PropertyMetadata> ma ustawioną wartość `null`. Użyj <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> podpisu, aby zapewnić metadanych do wersji właściwości zależności, jak dodać do udostępnionego typu.  
  
 Zwracana wartość tej metody zwykle umożliwia deklarowanie i ujawnia właściwości zależności, przechowując identyfikatora właściwości zależności. Identyfikator zapewnia dostęp do właściwości zależności, aby wywołać właściwości systemu [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] względem właściwości zależności, szczególnie jako istnieje na dodawanie klasy właściciela. Tej samej nazwie właściwości pierwotnego właściciela i dodany właściciela powinny być służy do wskazania podobnych możliwościach. Należy używać <xref:System.Windows.DependencyProperty> wartość zwracana <xref:System.Windows.DependencyProperty.AddOwner%2A> metody do definiowania identyfikatora właściwości zależności, a także aby zadeklarować [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] otoki właściwości, dla właściwości zależności, które są dodawane do typów za pomocą <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 <xref:System.Windows.DependencyProperty.AddOwner%2A> Metodologii zalecanych jest używany podczas tworzenia właściwości zależności, które są zadeklarowane w [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Na przykład zarówno <xref:System.Windows.Controls.Border> i <xref:System.Windows.Controls.Control> zdefiniować `BorderBrush` właściwości zależności, które mają podobną funkcjonalność. <xref:System.Windows.Controls.Control> Definiuje jego `BorderBrush` właściwości do właściwości systemu przez wywołanie metody <xref:System.Windows.DependencyProperty.AddOwner%2A> oparte na pierwotny właściciel <xref:System.Windows.Controls.Border> i jego zarejestrowanych <xref:System.Windows.Controls.Border.BorderBrushProperty> identyfikatora właściwości zależności. <xref:System.Windows.DependencyProperty.AddOwner%2A> Zwrócić wartość jest następnie używany do ustanawiania nowego statycznego <xref:System.Windows.DependencyProperty> pola (<xref:System.Windows.Controls.Control.BorderBrushProperty>) dla tej właściwości na dodano właściciela i `BorderBrush` właściwości otoki jest również zadeklarowany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner (ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">Typ do dodania jako właściciela tej właściwości zależności.</param>
        <param name="typeMetadata">Metadane, które kwalifikują się właściwości zależności, ponieważ znajduje się na podanego typu.</param>
        <summary>Dodaje innego typu jako właściciela właściwości zależności, który został już zarejestrowany, zapewniając metadanych właściwości zależności dla właściwości zależności będą znajdować się na typ podanego właściciela.</summary>
        <returns>Odwołanie do oryginalnej <see cref="T:System.Windows.DependencyProperty" /> identyfikator, który identyfikuje właściwości zależności. Ten identyfikator powinny zostać ujawnione przez dodanie klasę jako <see langword="public static readonly" /> pola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia systemowi właściwości rozpoznaje właściwości zależności na typ, który nie może zarejestrować danej właściwości zależności w szczególności początkowo.  
  
 Zwracana wartość ta metoda służy do deklarowanie i ujawnia właściwości zależności szczególnie, ponieważ znajduje się ona na dodawanie klasy właściciela. Ogólnie rzecz biorąc tej samej nazwie właściwości pierwotnego właściciela i dodany właściciela powinny być służy do wskazania podobnych możliwościach. Dobrym rozwiązaniem do udostępnienia identyfikatorów, a także jako nowy jest [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] otoki właściwości, dla właściwości zależności, które są dodawane do typów za pomocą <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 <xref:System.Windows.DependencyProperty.AddOwner%2A> Metodologii zalecanych jest używany podczas tworzenia [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] zadeklarowanym w [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Na przykład zarówno <xref:System.Windows.Controls.Border> i <xref:System.Windows.Controls.Control> zdefiniować `BorderBrush` właściwości zależności, które mają podobną funkcjonalność. <xref:System.Windows.Controls.Control> Definiuje jego `BorderBrush` właściwości do właściwości systemu przez wywołanie metody <xref:System.Windows.DependencyProperty.AddOwner%2A> na pierwotny właściciel <xref:System.Windows.Controls.Border> i jego zarejestrowanych <xref:System.Windows.Controls.Border.BorderBrushProperty> identyfikatora właściwości zależności. <xref:System.Windows.DependencyProperty.AddOwner%2A> Zwrócić wartość jest następnie używany do ustanawiania statycznego <xref:System.Windows.DependencyProperty> pola (<xref:System.Windows.Controls.Control.BorderBrushProperty>) dla tej właściwości na dodano właściciela i `BorderBrush` właściwości otoki jest również zadeklarowany.  
  
 Identyfikator właściwości zależności właściciela dodano należy go używać w operacjach takich jak <xref:System.Windows.DependencyObject.GetValue%2A>. Jednak określonego typu obejmującego typów lub wystąpienia klasy, która została dodana jako właściciela o metadanych, będzie nadal zwraca oczekiwanych rezultatów nawet wtedy, gdy oryginalne (nie dodano właściciela) określono identyfikator właściwości zależności w wywołań metod takich jak <xref:System.Windows.DependencyObject.GetValue%2A> lub <xref:System.Windows.DependencyProperty.GetMetadata%2A>. Metadane dla właściciela dodany jest perpetuated przez <xref:System.Windows.DependencyProperty.AddOwner%2A> wywołać się nie odwołuje się do wyłącznie przez dodanie pola Identyfikator klasy właściciela. Niemniej jednak jest dobrym rozwiązaniem, aby prezentować identyfikator, a także jako nowy [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] otoki właściwości, dla właściwości zależności, które są dodawane do typów za pomocą <xref:System.Windows.DependencyProperty.AddOwner%2A>, ponieważ w przeciwnym razie tworzy różnice między [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] i [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] reprezentacje właściwości.  
  
 Metadane podane jest scalany z metadanych właściwości dla właściwości zależności, ponieważ znajduje się na podstawowy właściciel. Wszystkie właściwości, które zostały określone w oryginalnych metadanych podstawowej będzie umieszczony. Tylko te właściwości, które w szczególności zostały zmienione w nowych metadanych spowoduje zastąpienie właściwości podstawowej metadanych. Niektóre właściwości, takie jak <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, zostały zastąpione, jeśli są one określone w nowymi metadanymi. Inne, takie jak <xref:System.Windows.PropertyChangedCallback>, są połączone. Ostatecznie, zachowanie scalania zależy od typu metadanych właściwości używany do zastąpienia, dlatego dla istniejącej klasy metadanych właściwości używane przez zachowanie opisane tutaj [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] właściwości zależności. Aby uzyskać więcej informacji, zobacz [metadanych właściwości zależności](~/docs/framework/wpf/advanced/dependency-property-metadata.md) i [metadanych właściwości Framework](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMetadata : System.Windows.PropertyMetadata" Usage="System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera metadane domyślnej właściwości zależności.</summary>
        <value>Metadane domyślnej właściwości zależności.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metadane domyślne są metadane właściwości, która jest dostępna dla tego konkretnego obiektu lub typu pochodnego obiektu gdzie metadanych alternatywną, nie został dostarczony przez jawne <xref:System.Windows.DependencyProperty.Register%2A> lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> wywołania.  
  
 Jeśli właściciel oryginalnego zastosowano metadanych do pierwszej <xref:System.Windows.DependencyProperty.Register%2A> wywołaniu, które ustanowić właściwości zależności, a następnie tych metadanych jest zwracana jako <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
 Jeśli metadanych nie została zastosowana w oryginalnym <xref:System.Windows.DependencyProperty.Register%2A> wywołań, a następnie metadanych domyślne są generowane na podstawie poziomu <xref:System.Windows.DependencyProperty.Register%2A> połączeń i ta wartość jest zwracana jako <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
 Głównym celem o domyślnej metadane skojarzone z <xref:System.Windows.DependencyProperty> jest umożliwiają określanie wartości domyślnej dla tej właściwości na dowolnym <xref:System.Windows.DependencyObject> lub typu pochodnego.  
  
 Dla właściwości nie dołączony zwracane przez tę właściwość typu metadanych nie można rzutować na typy pochodne <xref:System.Windows.PropertyMetadata> typ, nawet jeśli właściwość pierwotnie został zarejestrowany z typu pochodnego metadanych. Jeśli pierwotnie zarejestrowanego metadanych, łącznie z jej oryginalnego typu pochodnego prawdopodobnie metadanych, należy wywołać <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29> przekazywanie oryginalnego rejestrowanie zamiast tego typu jako parametr.  
  
 W przypadku dołączonych właściwości typ metadanych zwróconych przez tę właściwość zostanie pasuje do typu podane w oryginalnym <xref:System.Windows.DependencyProperty.RegisterAttached%2A> metoda rejestracji.  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyProperty.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla tego <see cref="T:System.Windows.DependencyProperty" />.</summary>
        <returns>Wartość skrótu dla tego <see cref="T:System.Windows.DependencyProperty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość system używa swojego unikatowego identyfikatora <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, a wartość tej właściwości jest zwracany przez <xref:System.Windows.DependencyProperty.GetHashCode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca metadane skojarzone z tą właściwością zależności, ponieważ istnieje dla określonego typu. Może to być typ tam, gdzie właściwości zależności nie pierwsza z nich zarejestrowany, do której dodano później, lub typu, gdy właściwość zależności uzyskano za pośrednictwem dziedziczenia, ale metadane został zastąpiony.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : Type -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata forType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">Określony typ, z którego można pobrać metadanych właściwości zależności.</param>
        <summary>Zwraca metadane dla ta właściwość zależności, które znajdują się na określony typ istniejących.</summary>
        <returns>Właściwości obiektu metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określanie typu lub odwołanie do obiektu, do użycia jako typ jest niezbędne, ponieważ metadane mogą się różnić od oryginalnej rejestracji ze względu na <xref:System.Windows.DependencyProperty.AddOwner%2A> lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> wywołania, które zmienić metadanych właściwości zależności, ponieważ istnieje w typie.  
  
   
  
## Examples  
 Poniższy przykład pobiera metadane dla właściwości zależności na podstawie jego typu. Tego typu uzyskuje się za pomocą `typeof` operatora.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObject -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Obiekt zależności, który jest sprawdzany pod kątem typu, w celu ustalenia, która wersja określonego typu właściwości zależności metadanych powinna pochodzić z.</param>
        <summary>Zwraca metadane dla tej właściwości zależności, ponieważ znajduje się na wystąpienie określonego obiektu.</summary>
        <returns>Właściwości obiektu metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określanie typu lub odwołanie do obiektu jest konieczne, ponieważ metadane żadnych danej właściwości zależności mogą się różnić od oryginalnej rejestracji ze względu na <xref:System.Windows.DependencyProperty.AddOwner%2A> lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> wywołania, które można dostosować metadanych właściwości, które znajdują się na Typ.  
  
 W przypadku żądania metadanych właściwość w wystąpieniu, są tak naprawdę przekazywanie wystąpienie tak, aby jej typ może przyjmować wewnętrznie. Metadane właściwości zależności nie zmienia się na każde wystąpienie; zawsze jest spójne dla dowolnej kombinacji właściwości danego typu.  
  
   
  
## Examples  
 Poniższy przykład pobiera metadane dla właściwości zależności oparte na konkretnej <xref:System.Windows.DependencyObject> wystąpienia.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObjectType -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObjectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">Określonego obiektu, który rejestruje typ obiektu zależności, z którego jest pożądany metadanych właściwości zależności.</param>
        <summary>Zwraca metadane dla tej właściwości zależności, ponieważ znajduje się na określony typ.</summary>
        <returns>Właściwości obiektu metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określanie typu lub odwołanie do obiektu jest konieczne, ponieważ metadane żadnych danej właściwości zależności mogą się różnić od oryginalnej rejestracji ze względu na <xref:System.Windows.DependencyProperty.AddOwner%2A> lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> wywołania, które można dostosować metadanych właściwości, które znajdują się na Typ.  
  
   
  
## Examples  
 Poniższy przykład pobiera metadane dla właściwości zależności na podstawie jego <xref:System.Windows.DependencyObjectType>.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalIndex : int" Usage="System.Windows.DependencyProperty.GlobalIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wewnętrznie generowane, który unikatowo identyfikuje właściwości zależności.</summary>
        <value>Unikatowy identyfikator liczbowy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość jest liczbą całkowitą nie Unikatowy identyfikator globalny (GUID). Ogólnie rzecz biorąc przy użyciu tej wartości indeksu nie jest wymagane i brak jest indeks dostępu do tabel wszystkich właściwości zależności. Właściwości zależności zamiast tego należy odwoływać się swoich pól identyfikator.  
  
 <xref:System.Windows.DependencyProperty.GlobalIndex%2A> jest używana wewnętrznie do szybszy dostęp do struktury danych, które używają <xref:System.Windows.DependencyProperty.GlobalIndex%2A> jako indeks tablicy liczony od zera. Podobne obciążenie może być aplikacje dla projektantów lub narzędzia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidType : obj -&gt; bool" Usage="dependencyProperty.IsValidType value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do sprawdzenia.</param>
        <summary>Określa, czy określona wartość jest akceptowalne dla typu ta właściwość zależności, ponieważ sprawdza, czy typ właściwości zawarte w pierwotnej rejestracji właściwości zależności.</summary>
        <returns>
          <see langword="true" /> Jeśli określona wartość jest typu zarejestrowanej właściwości lub dopuszczalne typu pochodnego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość `null` jest prawidłowym typem dla właściwości zależności typu odwołania lub <xref:System.Nullable%601> właściwości zależności i zwróci `true` dla tych przypadków. W przypadkach, gdy właściwość zależności jest ani odwołaniem ani <xref:System.Nullable%601> typu <xref:System.Windows.DependencyProperty.IsValidType%2A> zwróci `false` na wartość null zamiast Zgłoś wyjątek.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Windows.DependencyProperty.IsValidType%2A> w celu sprawdzenia przed wywołaniem <xref:System.Windows.DependencyObject.SetValue%2A> we właściwości zależności.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidValue : obj -&gt; bool" Usage="dependencyProperty.IsValidValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do sprawdzenia.</param>
        <summary>Określa, czy podana wartość jest akceptowany dla typu właściwości, wybierając typ podstawowy, a także potencjalnie jeśli znajduje się w dozwolonym zakresem wartości dla tego typu.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość jest dopuszczalne i jest nieprawidłowego typu lub typu pochodnego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla właściwości zależności, można określić zakres dozwolonych wartości dla tego typu za pomocą <xref:System.Windows.ValidateValueCallback> dostarczanym rejestracji właściwości zależności.  
  
 Ta metoda wywołuje <xref:System.Windows.DependencyProperty.IsValidType%2A> wewnętrznie. Jeśli nie ma właściwości zależności w <xref:System.Windows.ValidateValueCallback>, wywołanie tej metody jest równoważne wywołanie <xref:System.Windows.DependencyProperty.IsValidType%2A>. Jeśli właściwość zależności <xref:System.Windows.ValidateValueCallback>i w razie <xref:System.Windows.DependencyProperty.IsValidType%2A> będzie musiał zwrócić `true`, zwracana wartość będzie zgodnie z implementacją w wywołania zwrotnego.  
  
 Wartość null jest prawidłową wartością dla właściwości zależności typu odwołania lub <xref:System.Nullable%601> właściwości zależności i zwróci `true` dla tych przypadków. W przypadkach, gdy właściwość zależności jest ani odwołaniem ani <xref:System.Nullable%601> typu <xref:System.Windows.DependencyProperty.IsValidType%2A> zwróci `false` na wartość null zamiast Zgłoś wyjątek.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Windows.DependencyProperty.IsValidValue%2A> w celu sprawdzenia przed wywołaniem <xref:System.Windows.DependencyObject.SetValue%2A> we właściwości zależności.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.DependencyProperty.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę właściwości zależności.</summary>
        <value>Nazwa właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość uzyskuje nazwę odpowiednio `name` parametru podczas rejestracji właściwości zależności. Ta nazwa jest niemodyfikowalna i nie może być `null` lub ciąg pusty. Rejestracje zduplikowanej nazwy do tego samego typu właściciela nie są dozwolone i zgłosi wyjątek podczas próby zarejestrowania duplikatu.  
  
> [!IMPORTANT]
>  <xref:System.Windows.DependencyProperty.Name%2A> Zależności właściwości należy postępować zgodnie z Konwencją pasującego do nazwy identyfikatora właściwości zależności minus sufiks "Property". Aby uzyskać więcej informacji, zobacz [właściwości zależności niestandardowe](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
   
  
## Examples  
 Poniższy przykład wysyła zapytanie do różnych właściwości identyfikatora właściwości zależności, w tym <xref:System.Windows.DependencyProperty.Name%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dostaw alternatywny metadanych dla tej właściwości zależności, gdy nie jest obecny w wystąpieniach określonego typu, a metadane, które podano w rejestracji właściwości zależności początkowej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">Typ, w którym ta właściwość zależności jest dziedziczona i gdzie zostaną zastosowane podane metadane alternatywny.</param>
        <param name="typeMetadata">Metadane dla właściwości zależności na zastępowanie typu.</param>
        <summary>Określa alternatywny metadanych dla tej właściwości zależności, gdy nie jest obecny w wystąpieniach o określonym typie, zastępowanie metadanych, które istniały dla właściwości zależności, ponieważ został on odziedziczony z typów podstawowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powinna zostać zastąpiona metadanych właściwości zależności, zanim system właściwości używa właściwości zależności. To jest równa czas określone wystąpienia są tworzone przy użyciu klasy, która rejestruje właściwości zależności. Wywołań <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> powinno być wykonywane jedynie konstruktorów statycznych typu, który udostępnia siebie jako `forType` parametru tej metody lub za pomocą podobnego wystąpienia. Podjęto próbę zmiany metadanych po istnieje wystąpienie typu właściciela nie będą zgłaszać wyjątków, ale spowoduje niespójność zachowania w systemie właściwości.  
  
 Po ustanowieniu metadanych dla elementu override określonej klasy pochodnej z tą metodą, kolejne próby na zastępowanie metadanych na tej samej klasy pochodnej zgłosi wyjątek.  
  
 Metadane podane jest scalany z metadanych właściwości dla właściwości zależności, ponieważ znajduje się na podstawowy właściciel. Wszystkie właściwości, które zostały określone w oryginalnych metadanych podstawowej będzie trwać; tylko te właściwości, które w szczególności zostały zmienione w nowych metadanych spowoduje zastąpienie właściwości podstawowej metadanych. Niektóre właściwości, takie jak <xref:System.Windows.PropertyMetadata.DefaultValue%2A> zostały zastąpione, jeśli określony w nowych metadanych. Inne, takie jak <xref:System.Windows.PropertyChangedCallback>, są połączone. Ostatecznie, zachowanie scalania zależy od typu metadanych właściwości używany do zastąpienia, dlatego dla istniejącej klasy metadanych właściwości używane przez zachowanie opisane tutaj [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] właściwości zależności. Aby uzyskać więcej informacji, zobacz [metadanych właściwości zależności](~/docs/framework/wpf/advanced/dependency-property-metadata.md) i [metadanych właściwości Framework](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba na zastępowanie metadanych właściwości tylko do odczytu zależności (nie można wykonać operacji przy użyciu tego podpisu).</exception>
        <exception cref="T:System.ArgumentException">Metadane już zostało ustanowione dla właściwości zależności, ponieważ znajduje się na podanego typu.</exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata * System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">Typ, w którym ta właściwość zależności jest dziedziczona i gdzie zostaną zastosowane podane metadane alternatywny.</param>
        <param name="typeMetadata">Metadane dla właściwości zależności na zastępowanie typu.</param>
        <param name="key">Klucz dostępu dla właściwości zależności tylko do odczytu.</param>
        <summary>Dostaw alternatywny metadane dla właściwości tylko do odczytu zależności, gdy nie jest obecny w wystąpieniach o określonym typie, zastępowanie metadanych, które podano w rejestracji właściwości zależności początkowej. Należy podać <see cref="T:System.Windows.DependencyPropertyKey" /> dla właściwości tylko do odczytu zależności uniknąć, który wywołał wyjątek.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta sygnatura zawiera implementacja dla identyfikatora właściwości zależności tylko do odczytu (<xref:System.Windows.DependencyPropertyKey>) metody. Jeśli Zastępowanie metadanych dla właściwości zależności odczytu i zapisu, użyj <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>.  
  
 Powinna zostać zastąpiona metadanych właściwości zależności, zanim system właściwości używa właściwości zależności. To jest równa czasu określone obiekty są tworzone dla klasy, która rejestruje właściwości zależności. Wywołań <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> powinno być wykonywane jedynie konstruktorów statycznych typu, który udostępnia siebie jako `forType` parametru tej metody lub za pomocą podobnego wystąpienia. Podjęto próbę zmiany metadanych po istnieje wystąpienie typu właściciela nie będą zgłaszać wyjątków, ale spowoduje niespójność zachowania w systemie właściwości.  
  
 Po ustanowieniu metadanych dla elementu override określonej klasy pochodnej z tą metodą, kolejne próby na zastępowanie metadanych na tej samej klasy pochodnej zgłosi wyjątek.  
  
 Metadane podane jest scalany z metadanych właściwości dla właściwości zależności, ponieważ znajduje się na podstawowy właściciel. Wszystkie właściwości, które zostały określone w oryginalnych metadanych podstawowej będzie trwać; tylko te właściwości, które w szczególności zostały zmienione w nowych metadanych spowoduje zastąpienie właściwości podstawowej metadanych. Niektóre właściwości, takie jak <xref:System.Windows.PropertyMetadata.DefaultValue%2A> zostały zastąpione, jeśli określony w nowych metadanych. Inne, takie jak <xref:System.Windows.PropertyChangedCallback>, są połączone. Zachowanie scalania zależy od typu metadanych właściwości używany do zastąpienia. Aby uzyskać więcej informacji, zobacz [metadanych właściwości zależności](~/docs/framework/wpf/advanced/dependency-property-metadata.md) i [metadanych właściwości Framework](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerType : Type" Usage="System.Windows.DependencyProperty.OwnerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ obiektu, który jest zarejestrowany w systemie właściwość właściwości zależności lub dodaje się jako właściciela właściwości.</summary>
        <value>Typ obiektu, który zarejestrowany właściwość lub dodaje się jako właściciela właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość zostało podane podczas rejestracji właściwości. Właściciel będzie albo oryginalnego rejestracji typu w odniesieniu <xref:System.Windows.DependencyProperty> generowane na podstawie identyfikatora <xref:System.Windows.DependencyProperty.Register%2A> wywołania lub typ, który dodaje się jako właściciel w przypadku <xref:System.Windows.DependencyProperty> generowane na podstawie identyfikatora <xref:System.Windows.DependencyProperty.AddOwner%2A> wywołania.  
  
 <xref:System.Windows.DependencyProperty.OwnerType%2A> Na żadnej podanej <xref:System.Windows.DependencyProperty> jest niemodyfikowalna i nie może być `null` w prawidłowej <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 Poniższy przykład pobiera typ właściciela na podstawie identyfikatora właściwości zależności `dp`, a następnie pobiera metadane dla typu właściciela dla tego samego identyfikatora. Ta operacja jest w rzeczywistości odpowiednikiem pobierania <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> na `dp`.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Windows.DependencyProperty.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ, który używa właściwości zależności dla jej wartości.</summary>
        <value>
          <see cref="T:System.Type" /> Wartości właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość raportuje typ wartości właściwości w postaci zadeklarowanej przez pierwotnej rejestracji właściwości, za pomocą `propertyType` parametru. Podobnie jak <xref:System.Windows.DependencyProperty.Name%2A>, typ właściwości właściwości zależności nie można modyfikować po rejestracji.  
  
   
  
## Examples  
 Poniższy przykład wysyła zapytanie do różnych właściwości identyfikatora właściwości zależności, w tym <xref:System.Windows.DependencyProperty.PropertyType%2A>. Ciąg nazwy typu <xref:System.Windows.DependencyProperty.PropertyType%2A> są uzyskiwane z zwróconego <xref:System.Type>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool" Usage="System.Windows.DependencyProperty.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy właściwość zależności jest identyfikowane przez to <see cref="T:System.Windows.DependencyProperty" /> wystąpienie jest właściwością tylko do odczytu zależności.</summary>
        <value>
          <see langword="true" /> Jeśli właściwość zależności jest tylko do odczytu. w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości tylko do odczytu zależności są zarejestrowane w systemie właściwości przez wywołanie metody <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> metody, w przeciwieństwie do <xref:System.Windows.DependencyProperty.Register%2A> metody. Dołączone właściwości może być również zarejestrowany jako tylko do odczytu. zobacz <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.  
  
 Właściwości tylko do odczytu zależności wymagają <xref:System.Windows.DependencyPropertyKey> identyfikator zamiast <xref:System.Windows.DependencyProperty> identyfikator do wykonywania operacji na metadanych, takich jak zastępowanie metadanych lub ustawiania wartości. Jeśli użytkownik uzyskał Kolekcja <xref:System.Windows.DependencyProperty> identyfikatory poprzez wywołanie <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> lub innym [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] który uwidacznia identyfikatorów, sprawdź <xref:System.Windows.DependencyProperty.ReadOnly%2A> wartość przed podjęciem ponownej próby wywołania <xref:System.Windows.DependencyObject.SetValue%2A> lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> za pomocą którego Identyfikator właściwości zależności jako parametr wejściowy, aby sprawdzić, czy właściwości zależności, który reprezentuje identyfikator nie jest tylko do odczytu. Jeśli wartość <xref:System.Windows.DependencyProperty.ReadOnly%2A> jest `true` we właściwości zależności nie istnieje sposób programowy uzyskać odwołania do <xref:System.Windows.DependencyPropertyKey> identyfikatora właściwości zależności, z metadanych lub <xref:System.Windows.DependencyProperty> identyfikator; identyfikator muszą być dostępne jako statyczne pole w celu wywołania <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> względem właściwości zależności tylko do odczytu.  
  
 Podczas tworzenia właściwości zależności niestandardowe i zarejestruj go jako tylko do odczytu, należy zdefiniować tylko metody dostępu get dla [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] właściwości otoki. W przeciwnym razie klasy mają mylące model obiektów dla otoki właściwości w porównaniu do dostępu do właściwości zależności zapasowego. Aby uzyskać więcej informacji, zobacz [właściwości zależności niestandardowe](~/docs/framework/wpf/advanced/custom-dependency-properties.md) lub [tylko do odczytu właściwości zależności](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
   
  
## Examples  
 Poniższy przykład uzyskuje metadanych domyślne i właściwości identyfikatora właściwości zależności z różnymi polami właściwości zależności, a informacje są używane do wypełnienia tabeli do zaimplementowania przeglądarką"metadanych".  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje właściwości zależności.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności, aby zarejestrować. Nazwa musi być unikatowa w ramach rejestracji przestrzeni nazw typu właściciela.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwości zależności.</param>
        <summary>Określona nazwa właściwości, typ właściwości i typ właściciela rejestruje właściwości zależności.</summary>
        <returns>Identyfikator właściwości zależności, które mają być używane, aby ustawić wartość <see langword="public static readonly" /> pole w klasie. Ten identyfikator jest następnie używany do później, odwołanie właściwości zależności dla operacji, takich jak programowo ustawiania dla niego wartości i uzyskiwanie metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji dotyczących rejestracji właściwości zależności, zobacz <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności, aby zarejestrować.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwości zależności.</param>
        <param name="typeMetadata">Metadane właściwości dla właściwości zależności.</param>
        <summary>Rejestruje właściwości zależności określona nazwa właściwości, typ właściwości, typ właściciela i metadane właściwości.</summary>
        <returns>Identyfikator właściwości zależności, które mają być używane, aby ustawić wartość <see langword="public static readonly" /> pole w klasie. Ten identyfikator jest następnie używany do później, odwołanie właściwości zależności dla operacji, takich jak programowo ustawiania dla niego wartości i uzyskiwanie metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji dotyczących rejestracji właściwości zależności, zobacz <xref:System.Windows.DependencyProperty>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności, aby zarejestrować.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwości zależności.</param>
        <param name="typeMetadata">Metadane właściwości dla właściwości zależności.</param>
        <param name="validateValueCallback">Odwołanie do wywołania zwrotnego, które należy wykonać wszelkie niestandardowego sprawdzania poprawności wartości właściwości zależności poza typowy Typ weryfikacji.</param>
        <summary>Określona nazwa właściwości, typ właściwości, typ właściciela, metadane właściwości i wywołanie zwrotne weryfikacji wartości dla właściwości rejestruje właściwości zależności.</summary>
        <returns>Identyfikator właściwości zależności, które mają być używane, aby ustawić wartość <see langword="public static readonly" /> pole w klasie. Ten identyfikator jest następnie używany do później, odwołanie właściwości zależności dla operacji, takich jak programowo ustawiania dla niego wartości i uzyskiwanie metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji dotyczących rejestracji właściwości zależności, zobacz <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 Poniższy przykład rejestruje właściwości zależności, w tym wywołanie zwrotne weryfikacji (definicja wywołanie zwrotne nie jest wyświetlany; szczegółowe informacje dotyczące definicji wywołania zwrotnego, zobacz <xref:System.Windows.ValidateValueCallback>).  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje dołączona właściwość z systemu właściwości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności, aby zarejestrować.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwości zależności.</param>
        <summary>Rejestruje dołączona właściwość o nazwie określonej właściwości, typ właściwości i typ właściciela.</summary>
        <returns>Identyfikator właściwości zależności, które mają być używane, aby ustawić wartość <see langword="public static readonly" /> pole w klasie. Ten identyfikator jest następnie używany do później, odwołanie właściwości zależności dla operacji, takich jak programowo ustawiania dla niego wartości i uzyskiwanie metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dołączona właściwość to pojęcie właściwości zdefiniowane przez [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementuje dołączone właściwości jako właściwości zależności. Ponieważ [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] właściwości zależności są dołączone właściwości, mogą oni mieć metadanych stosowane używaną przez system ogólne właściwości dla operacji, takich jak raportowanie właściwości układu. Aby uzyskać więcej informacji, zobacz [dołączony Przegląd właściwości](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Aby uzyskać więcej informacji dotyczących rejestracji właściwości zależności, zobacz <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 Poniższy przykład rejestruje dołączona właściwość dla klasy abstrakcyjnej za pomocą tej <xref:System.Windows.DependencyProperty.RegisterAttached%2A> podpisu.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności, aby zarejestrować.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwości zależności.</param>
        <param name="defaultMetadata">Metadane właściwości dla właściwości zależności. Mogą to wartość domyślna, a także inne właściwości.</param>
        <summary>Rejestruje dołączona właściwość określona nazwa właściwości, typ właściwości, typ właściciela i metadane właściwości.</summary>
        <returns>Identyfikator właściwości zależności, które mają być używane, aby ustawić wartość <see langword="public static readonly" /> pole w klasie. Ten identyfikator jest następnie używany do później, odwołanie właściwości zależności dla operacji, takich jak programowo ustawiania dla niego wartości i uzyskiwanie metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dołączona właściwość to pojęcie właściwości zdefiniowane przez [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementuje dołączone właściwości jako właściwości zależności. Ponieważ [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] właściwości zależności są dołączone właściwości, mogą oni mieć metadanych stosowane używaną przez system ogólne właściwości dla operacji, takich jak raportowanie właściwości układu. Aby uzyskać więcej informacji, zobacz [dołączony Przegląd właściwości](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Aby uzyskać więcej informacji dotyczących rejestracji właściwości zależności, zobacz <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Użyj RegisterAttached dziedziczenie wartość właściwości zależności  
 Jednego scenariusza rejestrowania właściwości zależności z <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zamiast <xref:System.Windows.DependencyProperty.Register%2A> służy do obsługi dziedziczenie wartości właściwości. Należy zarejestrować dziedziczenie wartość właściwości zależności z <xref:System.Windows.DependencyProperty.RegisterAttached%2A> nawet wtedy, gdy klasa definiuje otoki metod dostępu właściwości, które udostępniają właściwości zależności, a nawet wtedy, gdy nie zamierzasz ujawnia Get * i Set * statycznej metody w celu zapewnienia true dołączony metod dostępu do właściwości pomocy technicznej.   Mimo że dziedziczenie wartości właściwości mogą być wyświetlane dla właściwości zależności nie dołączony, zachowanie dziedziczenia właściwości nie dołączony do określonych granic elementu w drzewie środowiska uruchomieniowego jest niezdefiniowany. Rejestrowanie właściwości, jak skutecznie dołączone powoduje dołączona właściwość globalnych właściwości w systemie właściwości i gwarantuje, że dziedziczenie wartości właściwości działa przez wszystkie granice w drzewie elementu. Zawsze używaj <xref:System.Windows.DependencyProperty.RegisterAttached%2A> można zarejestrować właściwości, w którym można określić <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> w metadanych. Aby uzyskać więcej informacji, zobacz [dziedziczenie wartości właściwości](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności, aby zarejestrować.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwości zależności.</param>
        <param name="defaultMetadata">Metadane właściwości dla właściwości zależności. Mogą to wartość domyślna, a także inne właściwości.</param>
        <param name="validateValueCallback">Odwołanie do wywołania zwrotnego, które należy wykonać wszelkie niestandardowego sprawdzania poprawności wartości właściwości zależności poza typowy Typ weryfikacji.</param>
        <summary>Rejestruje dołączona właściwość z określonym typem właściwości, typ właściciela, metadane właściwości i wywołanie zwrotne weryfikacji wartości dla właściwości.</summary>
        <returns>Identyfikator właściwości zależności, które mają być używane, aby ustawić wartość <see langword="public static readonly" /> pole w klasie. Ten identyfikator jest następnie używany do później, odwołanie właściwości zależności dla operacji, takich jak programowo ustawiania dla niego wartości i uzyskiwanie metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dołączona właściwość to pojęcie właściwości zdefiniowane przez [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementuje dołączone właściwości jako właściwości zależności. Ponieważ [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] właściwości zależności są dołączone właściwości, mogą oni mieć metadanych stosowane używaną przez system ogólne właściwości dla operacji, takich jak raportowanie właściwości układu. Aby uzyskać więcej informacji, zobacz [dołączony Przegląd właściwości](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Aby uzyskać więcej informacji dotyczących rejestracji właściwości zależności, zobacz <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Użyj RegisterAttached dziedziczenie wartość właściwości zależności  
 Jednego scenariusza rejestrowania właściwości zależności z <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zamiast <xref:System.Windows.DependencyProperty.Register%2A> służy do obsługi dziedziczenie wartości właściwości. Należy zarejestrować dziedziczenie wartość właściwości zależności z <xref:System.Windows.DependencyProperty.RegisterAttached%2A> nawet wtedy, gdy klasa definiuje otoki metod dostępu właściwości, które udostępniają właściwości zależności, a nawet wtedy, gdy nie zamierzasz ujawnia Get * i Set * statycznej metody w celu zapewnienia true dołączony metod dostępu do właściwości pomocy technicznej.   Mimo że dziedziczenie wartości właściwości mogą być wyświetlane dla właściwości zależności nie dołączony, zachowanie dziedziczenia właściwości nie dołączony do określonych granic elementu w drzewie środowiska uruchomieniowego jest niezdefiniowany. Rejestrowanie właściwości, jak skutecznie dołączone powoduje dołączona właściwość globalnych właściwości w systemie właściwości i gwarantuje, że dziedziczenie wartości właściwości działa przez wszystkie granice w drzewie elementu. Zawsze używaj <xref:System.Windows.DependencyProperty.RegisterAttached%2A> można zarejestrować właściwości, w którym można określić <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> w metadanych. Aby uzyskać więcej informacji, zobacz [dziedziczenie wartości właściwości](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
   
  
## Examples  
 Poniższy przykład rejestruje dołączona właściwość dla klasy abstrakcyjnej za pomocą tej <xref:System.Windows.DependencyProperty.RegisterAttached%2A> podpisu. Ta dołączona właściwość jest właściwością typu wyliczenia i rejestracji dodaje wywołanie zwrotne weryfikacji, aby sprawdzić, czy podana wartość jest wartością wyliczenia.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje w trybie tylko do odczytu dołączona właściwość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności, aby zarejestrować.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwości zależności.</param>
        <param name="defaultMetadata">Metadane właściwości dla właściwości zależności.</param>
        <summary>Rejestruje tylko do odczytu dołączona właściwość, z określonym typem właściwości, typ właściciela i metadane właściwości.</summary>
        <returns>Klucz właściwości zależności, które mają być używane do wartości pola statycznego tylko do odczytu w klasie, która jest następnie używany do odwołać później właściwości zależności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca typ <xref:System.Windows.DependencyPropertyKey>, podczas gdy <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zwraca typ <xref:System.Windows.DependencyProperty>. Zazwyczaj nie zostaną wprowadzone publiczne, klucze, które reprezentują właściwości tylko do odczytu, ponieważ klucze można ustawić wartości właściwości zależności przez wywołanie metody <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Projekt klasy będzie miało wpływ na wymagania dotyczące, ale ogólnie zaleca się ograniczyć dostęp i widoczności dowolnego <xref:System.Windows.DependencyPropertyKey> tylko te części kodu, które są niezbędne, można ustawić tej właściwości zależności w ramach klasy lub aplikacji logiki. Zaleca się również ujawniać identyfikatora właściwości zależności dla właściwości tylko do odczytu zależności, w przypadku wystawianego wartość <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> jako `public static readonly` pole w klasie.  
  
 Dołączone właściwości tylko do odczytu są scenariusza rzadko, ponieważ podstawowy scenariusz dla właściwości dołączonej użyciem jej w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Bez publicznej metody ustawiającej właściwości dołączonej nie można ustawić w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] składni.  
  
 Aby uzyskać więcej informacji dotyczących rejestracji właściwości zależności, zobacz <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Użyj RegisterAttached dziedziczenie wartość właściwości zależności  
 Jednego scenariusza rejestrowania właściwości zależności jako dołączona jest zapewnienie pomocy technicznej dziedziczenie wartości właściwości. Należy zarejestrować dziedziczenie wartość właściwości zależności z <xref:System.Windows.DependencyProperty.RegisterAttached%2A> nawet wtedy, gdy klasa definiuje otoki metod dostępu właściwości, które udostępniają właściwości zależności, a nawet wtedy, gdy nie zamierzasz ujawnia Get * i Set * statycznej metody w celu zapewnienia true dołączony metod dostępu do właściwości pomocy technicznej.   Mimo że dziedziczenie wartości właściwości mogą być wyświetlane dla właściwości zależności nie dołączony, zachowanie dziedziczenia właściwości nie dołączony do określonych granic elementu w drzewie środowiska uruchomieniowego jest niezdefiniowany. Rejestrowanie właściwości, jak skutecznie dołączone powoduje dołączona właściwość globalnych właściwości w systemie właściwości i gwarantuje, że dziedziczenie wartości właściwości działa przez wszystkie granice w drzewie elementu. Zawsze używaj <xref:System.Windows.DependencyProperty.RegisterAttached%2A> można zarejestrować właściwości, w którym można określić <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> w metadanych. Aby uzyskać więcej informacji, zobacz [dziedziczenie wartości właściwości](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności, aby zarejestrować.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwości zależności.</param>
        <param name="defaultMetadata">Metadane właściwości dla właściwości zależności.</param>
        <param name="validateValueCallback">Odwołanie do utworzonych przez użytkownika wywołanie zwrotne, które należy wykonać wszelkie niestandardowego sprawdzania poprawności wartości właściwości zależności poza typowy Typ weryfikacji.</param>
        <summary>Rejestruje tylko do odczytu dołączona właściwość, z określonym typem właściwości, typ właściciela metadanych właściwości i wywołanie zwrotne weryfikacji.</summary>
        <returns>Klucz właściwości zależności, które mają być używane do wartości pola statycznego tylko do odczytu w klasie, która jest następnie używany do odwołania właściwości zależności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca typ <xref:System.Windows.DependencyPropertyKey>, podczas gdy <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zwraca typ <xref:System.Windows.DependencyProperty>. Zazwyczaj klucze, które reprezentują typ <xref:System.Windows.DependencyProperty>. Zazwyczaj nie zostaną wprowadzone publiczne, klucze, które reprezentują właściwości tylko do odczytu, ponieważ klucze można ustawić wartości właściwości zależności przez wywołanie metody <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Projekt klasy będzie miało wpływ na wymagania dotyczące, ale ogólnie zaleca się ograniczyć dostęp i widoczności dowolnego <xref:System.Windows.DependencyPropertyKey> tylko te części kodu, które są niezbędne, można ustawić tej właściwości zależności w ramach klasy lub aplikacji logiki. Zaleca się również ujawniać identyfikatora właściwości zależności dla właściwości tylko do odczytu zależności, w przypadku wystawianego wartość <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> jako `public static readonly` pole w klasie.  
  
 Dołączone właściwości tylko do odczytu są scenariusza rzadko, ponieważ podstawowy scenariusz dla właściwości dołączonej użyciem jej w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Bez publicznej metody ustawiającej właściwości dołączonej nie można ustawić w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] składni.  
  
 Aby uzyskać więcej informacji dotyczących rejestracji właściwości zależności, zobacz <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Użyj RegisterAttached dziedziczenie wartość właściwości zależności  
 Jednego scenariusza rejestrowania właściwości zależności jako dołączony zamiast <xref:System.Windows.DependencyProperty.Register%2A> służy do obsługi dziedziczenie wartości właściwości. Należy zarejestrować dziedziczenie wartość właściwości zależności z <xref:System.Windows.DependencyProperty.RegisterAttached%2A> nawet wtedy, gdy klasa definiuje otoki metod dostępu właściwości, które udostępniają właściwości zależności, a nawet wtedy, gdy nie zamierzasz ujawnia Get * i Set * statycznej metody w celu zapewnienia true dołączony metod dostępu do właściwości pomocy technicznej.   Mimo że dziedziczenie wartości właściwości mogą być wyświetlane dla właściwości zależności nie dołączony, zachowanie dziedziczenia właściwości nie dołączony do określonych granic elementu w drzewie środowiska uruchomieniowego jest niezdefiniowany. Rejestrowanie właściwości, jak skutecznie dołączone powoduje dołączona właściwość globalnych właściwości w systemie właściwości i gwarantuje, że dziedziczenie wartości właściwości działa przez wszystkie granice w drzewie elementu. Zawsze używaj <xref:System.Windows.DependencyProperty.RegisterAttached%2A> można zarejestrować właściwości, w którym można określić <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> w metadanych. Aby uzyskać więcej informacji, zobacz [dziedziczenie wartości właściwości](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje właściwości zależności jako właściwość zależności tylko do odczytu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności, aby zarejestrować.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwości zależności.</param>
        <param name="typeMetadata">Metadane właściwości dla właściwości zależności.</param>
        <summary>Rejestruje właściwości tylko do odczytu zależności, z określonym typem właściwości, typ właściciela i metadane właściwości.</summary>
        <returns>Klucz właściwości zależności, które mają być używane do wartości pola statycznego tylko do odczytu w klasie, która jest następnie używany do odwołania właściwości zależności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca typ <xref:System.Windows.DependencyPropertyKey>, podczas gdy <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zwraca typ <xref:System.Windows.DependencyProperty>. Zazwyczaj nie zostaną wprowadzone publiczne, klucze, które reprezentują właściwości tylko do odczytu, ponieważ klucze można ustawić wartości właściwości zależności przez wywołanie metody <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Projekt klasy będzie miało wpływ na wymagania dotyczące, ale ogólnie zaleca się ograniczyć dostęp i widoczności dowolnego <xref:System.Windows.DependencyPropertyKey> tylko te części kodu, które są niezbędne, można ustawić tej właściwości zależności w ramach klasy lub aplikacji logiki. Zaleca się również ujawniać identyfikatora właściwości zależności dla właściwości tylko do odczytu zależności, w przypadku wystawianego wartość <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> jako `public static readonly` pole w klasie.  
  
 Właściwości tylko do odczytu zależności są dość typowy scenariusz zarówno w istniejących [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] i dostosowania, ponieważ inne [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] funkcje mogą wymagać właściwości zależności, nawet jeśli tej właściwości nie ma być można ustawić przez obiekty wywołujące. Możesz użyć wartości właściwości tylko do odczytu zależności na podstawie innych operacji system właściwości, które przyjmują właściwość zależności, takich jak utworzenie <xref:System.Windows.Trigger> we właściwości zależności w stylu.  
  
 Aby uzyskać więcej informacji dotyczących rejestracji właściwości zależności, zobacz <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 Poniższy przykład rejestruje `AquariumSize` właściwości zależności jako tylko do odczytu. W przykładzie zdefiniowano `AquariumSizeKey` jako klucz wewnętrzny (aby klasy w zestawie można zastąpić metadanych) i ujawnia identyfikatora właściwości zależności na podstawie tego klucza jako `AquariumSizeProperty`. Ponadto otoka jest tworzona dla `AquariumSize`, z metodą dostępu get.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności, aby zarejestrować.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwości zależności.</param>
        <param name="typeMetadata">Metadane właściwości dla właściwości zależności.</param>
        <param name="validateValueCallback">Odwołanie do utworzonych przez użytkownika wywołanie zwrotne, które należy wykonać wszelkie niestandardowego sprawdzania poprawności wartości właściwości zależności poza typowy Typ weryfikacji.</param>
        <summary>Rejestruje właściwości tylko do odczytu zależności, z określonym typem właściwości, typ właściciela metadanych właściwości i wywołanie zwrotne weryfikacji.</summary>
        <returns>Klucz właściwości zależności, które mają być używane do wartości pola statycznego tylko do odczytu w klasie, która jest następnie używany do odwołać później właściwości zależności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca typ <xref:System.Windows.DependencyPropertyKey>, podczas gdy <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zwraca typ <xref:System.Windows.DependencyProperty>. Zazwyczaj nie zostaną wprowadzone publiczne, klucze, które reprezentują właściwości tylko do odczytu, ponieważ klucze można ustawić wartości właściwości zależności przez wywołanie metody <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Projekt klasy będzie miało wpływ na wymagania dotyczące, ale ogólnie zaleca się ograniczyć dostęp i widoczności dowolnego <xref:System.Windows.DependencyPropertyKey> tylko te części kodu, które są niezbędne, można ustawić tej właściwości zależności w ramach klasy lub aplikacji logiki. Zaleca się również ujawniać identyfikatora właściwości zależności dla właściwości tylko do odczytu zależności, w przypadku wystawianego wartość <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> jako `public static readonly` pole w klasie.  
  
 Właściwości tylko do odczytu zależności są dość typowy scenariusz. Możesz użyć wartości właściwości tylko do odczytu zależności na podstawie innych operacji system właściwości, które przyjmują właściwość zależności, takich jak utworzenie <xref:System.Windows.Trigger> we właściwości zależności w stylu.  
  
 Aby uzyskać więcej informacji dotyczących rejestracji właściwości zależności, zobacz <xref:System.Windows.DependencyProperty>.  
  
 Sprawdzanie poprawności właściwości tylko do odczytu zależności może być mniej ważne. Poziom dostępu niepubliczne, które określisz klucza zmniejsza prawdopodobieństwo dla dowolnego nieprawidłowe dane wejściowe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dependencyProperty.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca reprezentację ciągu właściwości zależności.</summary>
        <returns>Reprezentacja ciągu właściwości zależności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja zwraca <xref:System.Windows.DependencyProperty.Name%2A> wartości właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnsetValue : obj" Usage="System.Windows.DependencyProperty.UnsetValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa wartość statyczną, który jest używany przez [! System właściwości include[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-MD.MD)] zamiast <see langword="null" /> aby wskazać, że właściwość istnieje, ale nie ma jej wartość właściwości systemu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty.UnsetValue> jest wartością wartownik, która jest używana w scenariuszach, gdzie [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] właściwości system nie mógł określić zażądano <xref:System.Windows.DependencyProperty> wartość. <xref:System.Windows.DependencyProperty.UnsetValue> jest używany zamiast `null`, ponieważ `null` może mieć prawidłową wartość właściwości, a także prawidłowy (i często używane) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> nigdy nie jest zwracana z <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>. Podczas wywoływania <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType> we właściwości zależności na <xref:System.Windows.DependencyObject> wystąpienia, jedno z następujących dotyczy:  
  
-   Właściwość dependency ma wartość domyślną w metadanych i ta wartość jest zwracana. Ta wartość może pochodzić z <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
-   Wartość zostało ustanowione przez właściwości systemu, a wartość domyślna jest już nieaktualny. Aby uzyskać więcej informacji, zobacz [pierwszeństwo wartość właściwości zależności](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Ustawienie <xref:System.Windows.PropertyMetadata.DefaultValue%2A> z <xref:System.Windows.DependencyProperty.UnsetValue> w szczególności jest niedozwolone.  
  
 <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> Zwraca <xref:System.Windows.DependencyProperty.UnsetValue> gdy żądana właściwość nie została lokalnie ustawiona.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> ma specjalnego znaczenia, gdy jest używany jako wartość zwracaną <xref:System.Windows.CoerceValueCallback>. Aby uzyskać więcej informacji, zobacz [wywołania zwrotne właściwości zależności i sprawdzania poprawności](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 Są wiązane z bazą danych, należy pamiętać, że <xref:System.Windows.DependencyProperty.UnsetValue> nie jest odpowiednikiem <xref:System.DBNull.Value>, w podobny sposób jak <xref:System.DBNull.Value> nie jest równoważna wartości true wartość null.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidateValueCallback : System.Windows.ValidateValueCallback" Usage="System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wywołanie zwrotne weryfikacji wartości dla właściwości zależności.</summary>
        <value>Wywołanie zwrotne weryfikacji wartość dla tej właściwości zależności, zgodnie z <paramref name="validateValueCallback" /> parametru w pierwotnej rejestracji właściwości zależności.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość będzie zawierać `null` dla każdej właściwości zależności, bez sprawdzania poprawności w zarejestrowany wywołania zwrotnego.  
  
 Zweryfikować wartości wywołania zwrotne musi działać w statycznej znaczeniu: Sprawdzanie poprawności stosowane przy użyciu <xref:System.Windows.ValidateValueCallback> nie może określić, czy podana wartość jest nieprawidłowa dla dowolne wystąpienie. Wywołania zwrotnego tylko można określić, czy wszystkie obiekty, które posiadają właściwości zależności powinien lub nie powinien akceptować podanej wartości jako prawidłowy. Jeśli potrzebujesz sprawdzania poprawności opartym na wiedzy o wartości innych właściwości zależności na konkretnym wystąpieniu, użyj <xref:System.Windows.CoerceValueCallback> zamiast tego. <xref:System.Windows.CoerceValueCallback> Jest zarejestrowany w ramach metadanych właściwości zależności, a nie bezpośrednio z poziomu identyfikatora właściwości zależności. Aby uzyskać więcej informacji, zobacz [wywołania zwrotne właściwości zależności i sprawdzania poprawności](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>
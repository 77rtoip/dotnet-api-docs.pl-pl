<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="DependencyProperty.xml" source-language="en-US" target-language="pl-PL">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5cd5b6a2bc5d76e65fbad41cf01060484fb71b52e.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cd5b6a2bc5d76e65fbad41cf01060484fb71b52e</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Represents a property that can be set through methods such as, styling, data binding, animation, and inheritance.</source>
          <target state="translated">Reprezentuje właściwości, które można ustawić za pomocą metody takie jak, stylów, powiązań danych, animacji i dziedziczenia.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>A <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> supports the following capabilities in <ph id="ph2">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph>:</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> obsługuje następujące funkcje w <ph id="ph2">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph>:</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can be set in a style.</source>
          <target state="translated">Właściwość można ustawić w stylu.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>Styling and Templating<ept id="p1">](~/docs/framework/wpf/controls/styling-and-templating.md)</ept>.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <bpt id="p1">[</bpt>stylami i tworzenia szablonów<ept id="p1">](~/docs/framework/wpf/controls/styling-and-templating.md)</ept>.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can be set through data binding.</source>
          <target state="translated">Właściwość można ustawić za pomocą wiązania z danymi.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information about data binding dependency properties, see <bpt id="p1">[</bpt>How to: Bind the Properties of Two Controls<ept id="p1">](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md)</ept>.</source>
          <target state="translated">Aby uzyskać więcej informacji na temat właściwości zależności wiązania danych zobacz <bpt id="p1">[</bpt>porady: powiązanie właściwości formantów dwóch<ept id="p1">](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md)</ept>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can be set with a dynamic resource reference.</source>
          <target state="translated">Można ustawić właściwości z odwołaniem zasobu dynamicznego.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>XAML Resources<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <bpt id="p1">[</bpt>zasobów XAML<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can inherit its value automatically from a parent element in the element tree.</source>
          <target state="translated">Właściwości mogą dziedziczyć wartość automatycznie elementu nadrzędnego w drzewie elementu.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <bpt id="p1">[</bpt>dziedziczenie wartości właściwości<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can be animated.</source>
          <target state="translated">Można animować właściwości.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>Animation Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-overview.md)</ept>.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <bpt id="p1">[</bpt>omówienie animacja<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can report when the previous value of the property has been changed and the property value can be coerced.</source>
          <target state="translated">Właściwość zgłosić po zmianie poprzedniej wartości właściwości i wartości właściwości mogą zostać przekształcone.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>Dependency Property Callbacks and Validation<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <bpt id="p1">[</bpt>wywołania zwrotne właściwości zależności i sprawdzania poprawności<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property reports information to <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>, such as whether changing a property value should require the layout system to recompose the visuals for an element.</source>
          <target state="translated">Właściwość raportuje informacje do <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>, takie jak czy zmiana wartości właściwości powinny wymagać systemu układu, aby przeskładać elementy wizualne dla elementu.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property receives support in the <ph id="ph1">[!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)]</ph>.</source>
          <target state="translated">Właściwość otrzymuje wsparcie w <ph id="ph1">[!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For example, the property can be edited in the <bpt id="p1">**</bpt>Properties<ept id="p1">**</ept> window.</source>
          <target state="translated">Na przykład właściwość może być edytowany w <bpt id="p1">**</bpt>właściwości<ept id="p1">**</ept> okna.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>To learn more about dependency properties, see <bpt id="p1">[</bpt>Dependency Properties Overview<ept id="p1">](~/docs/framework/wpf/advanced/dependency-properties-overview.md)</ept>.</source>
          <target state="translated">Aby dowiedzieć się więcej na temat właściwości zależności, zobacz <bpt id="p1">[</bpt>Przegląd właściwości zależności<ept id="p1">](~/docs/framework/wpf/advanced/dependency-properties-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>If you want properties on your custom types to support the capabilities in the preceding list, you should create a dependency property.</source>
          <target state="translated">Jeśli chcesz właściwości z typów niestandardowych do obsługi funkcji z powyższej listy, należy utworzyć właściwości zależności.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>To learn how to create custom dependency properties, see <bpt id="p1">[</bpt>Custom Dependency Properties<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept>.</source>
          <target state="translated">Informacje na temat tworzenia właściwości zależności niestandardowych, zobacz <bpt id="p1">[</bpt>niestandardowe właściwości zależności<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>An attached property is a property that enables any object to report information to the type that defines the attached property.</source>
          <target state="translated">Dołączona właściwość jest właściwością umożliwiającą dowolnego obiektu na typ, który definiuje dołączona właściwość informacji w raporcie.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>In <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>, any type that inherits from <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> can use an attached property regardless of whether the type inherits from the type that defines the property.</source>
          <target state="translated">W <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>, dowolnego typu, która dziedziczy <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> można użyć właściwości dołączonej niezależnie od tego, czy typ dziedziczy z typu, który definiuje właściwość.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>An attached property is a feature of the <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> language.</source>
          <target state="translated">Dołączona właściwość jest funkcją <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> języka.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>To set an attached property in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, use the <bpt id="p1">*</bpt>ownerType<ept id="p1">*</ept>.<bpt id="p2">*</bpt>propertyName<ept id="p2">*</ept> syntax.</source>
          <target state="translated">Aby ustawić właściwości dołączonej w <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, użyj <bpt id="p1">*</bpt>ownerType<ept id="p1">*</ept>.<bpt id="p2">*</bpt> propertyName<ept id="p2">*</ept> składni.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>An example of an attached property is the <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Na przykład dołączona właściwość <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType&gt;</ph> właściwości.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>If you want to create a property that can be used on all <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> types, then you should create an attached property.</source>
          <target state="translated">Jeśli chcesz utworzyć właściwość, która może być używana na wszystkich <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> typów, a następnie należy utworzyć dołączona właściwość.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>To learn more about attached properties, including how to create them, see <bpt id="p1">[</bpt>Attached Properties Overview<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</source>
          <target state="translated">Aby dowiedzieć się więcej na temat dołączone właściwości, oraz o sposobie ich tworzenia, zobacz <bpt id="p1">[</bpt>dołączony Przegląd właściwości<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>XAML Attribute Usage</source>
          <target state="translated">Użycie atrybutu języka XAML</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>XAML Values</source>
          <target state="translated">Wartości XAML</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>A string that specifies the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType&gt;</ph> of the desired dependency property.</source>
          <target state="translated">Ciąg określający <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType&gt;</ph> właściwości żądaną zależności.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>This can be preceded by an XML namespace prefix if the property is not in the default XML namespace (for details, see <bpt id="p1">[</bpt>XAML Namespaces and Namespace Mapping for WPF XAML<ept id="p1">](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)</ept>.)</source>
          <target state="translated">To może być poprzedzony przez prefiks przestrzeni nazw XML, jeśli właściwość nie ma domyślnej przestrzeni nazw XML (Aby uzyskać więcej informacji, zobacz <bpt id="p1">[</bpt>przestrzeń nazw XAML i Namespace mapowanie WPF XAML<ept id="p1">](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source><ph id="ph1">`ownerType`</ph>.<ph id="ph2">`dependencyPropertyName`</ph></source>
          <target state="translated"><ph id="ph1">`ownerType`</ph>.<ph id="ph2">`dependencyPropertyName`</ph></target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>A string that specifies an owner type of a dependency property, a dot (.), then the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ciąg określający typ właściciela właściwości zależności, kropkę (.), a następnie <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source><ph id="ph1">`ownerType`</ph> can also be preceded by an XML namespace prefix.</source>
          <target state="translated"><ph id="ph1">`ownerType`</ph> może być poprzedzone prefiks przestrzeni nazw XML.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>This usage is particular to late-bound styles and templates, where the owner of the dependency property must be specified for parsing context because the <ph id="ph1">`TargetType`</ph> is not yet known.</source>
          <target state="translated">Dla style późnym wiązaniem i szablony, w którym należy określić właściciela właściwości zależności do analizowania kontekstu, ponieważ jest to użycie <ph id="ph1">`TargetType`</ph> nie jest jeszcze znany.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>Styling and Templating<ept id="p1">](~/docs/framework/wpf/controls/styling-and-templating.md)</ept>.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <bpt id="p1">[</bpt>stylami i tworzenia szablonów<ept id="p1">](~/docs/framework/wpf/controls/styling-and-templating.md)</ept>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source><ph id="ph1">`attachedPropertyOwnerType`</ph> <bpt id="p1">*</bpt>.<ept id="p1">*</ept></source>
          <target state="translated"><ph id="ph1">`attachedPropertyOwnerType`</ph> <bpt id="p1">*</bpt>.<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>A string that specifies  the owner of an attached property, a dot (.), then the attached property name.</source>
          <target state="translated">Ciąg, który określa właściciela dołączona właściwość, kropkę (.), a następnie dołączona właściwość name.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source><ph id="ph1">`attachedPropertyOwnerType`</ph> can also be preceded by an XML namespace prefix.</source>
          <target state="translated"><ph id="ph1">`attachedPropertyOwnerType`</ph> może być poprzedzone prefiks przestrzeni nazw XML.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Adds another type as an owner of a dependency property that has already been registered to a type.</source>
          <target state="translated">Dodaje innego typu jako właściciela właściwości zależności, który został już zarejestrowany do typu.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The type to add as an owner of this dependency property.</source>
          <target state="translated">Typ do dodania jako właściciela tej właściwości zależności.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>Adds another type as an owner of a dependency property that has already been registered.</source>
          <target state="translated">Dodaje innego typu jako właściciela właściwości zależności, który został już zarejestrowany.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>A reference to the original <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> identifier that identifies the dependency property.</source>
          <target state="translated">Odwołanie do oryginalnej <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> identyfikator, który identyfikuje właściwości zależności.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>This identifier should be exposed by the adding class as a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field.</source>
          <target state="translated">Ten identyfikator powinny zostać ujawnione przez dodanie klasę jako <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> pola.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>This method enables the property system to recognize a dependency property on a type that did not register that particular dependency property initially.</source>
          <target state="translated">Ta metoda umożliwia systemowi właściwości rozpoznaje właściwości zależności na typ, który nie może zarejestrować danej właściwości zależności w szczególności początkowo.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>Typically, <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> is used to add dependency properties to classes that do not already expose that dependency property through managed class inheritance (class inheritance would cause the wrapper properties to be inherited by the derived class, and thus would provide general members-table access to the dependency property already).</source>
          <target state="translated">Zazwyczaj <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> służy do dodawania właściwości zależności do klasy, które nie udostępniają już tą właściwością zależności za pomocą dziedziczenia klas zarządzanych (dziedziczenia klas spowodowałoby właściwości otoki być dziedziczone przez klasy pochodnej, dlatego czy zapewniają ogólne tabeli elementów członkowskich dostęp do właściwości zależności już).</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> enables the property system to recognize a dependency property on a type that did not register that dependency property initially.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> Umożliwia systemowi właściwości rozpoznaje właściwości zależności na typ, który nie zarejestrował początkowo danej właściwości zależności.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>This signature does not allow for specifying metadata.</source>
          <target state="translated">Ta sygnatura nie zezwala na określanie metadanych.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>When you use this method, the metadata is automatically generated for the new <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> and its owner type.</source>
          <target state="translated">Korzystając z tej metody, metadanych jest generowane automatycznie dla nowego <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> i wpisz jego właściciela.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The auto-generated metadata is the result of the merged metadata from all of the base types that have this property defined.</source>
          <target state="translated">Metadane automatycznie generowanej powstaje na podstawie metadanych scalony ze wszystkich typów podstawowych, których tej właściwości zdefiniowane.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>If no merged metadata is available, then the default metadata for the property is used.</source>
          <target state="translated">Jeśli brak scalonych metadanych nie jest dostępne, zostanie użyta domyślna metadane dla właściwości.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>If the property is registered by using the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> method, then the default metadata is the same as the metadata that is created when <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> was called.</source>
          <target state="translated">Jeśli właściwość jest zarejestrowana przy użyciu <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> metody, a następnie metadanych domyślny jest taka sama jak metadanych, które jest tworzone, gdy <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> została wywołana.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>Otherwise, the <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> object is created with the <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> property set to the property type's default and all other properties of the <ph id="ph3">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> is set to <ph id="ph4">`null`</ph>.</source>
          <target state="translated">W przeciwnym razie <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> obiekt jest tworzony z <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> właściwość domyślny typ właściwości i wszystkie inne właściwości <ph id="ph3">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> ma ustawioną wartość <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>Use the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph> signature if you want to provide metadata for the version of the dependency property as added to the provided type.</source>
          <target state="translated">Użyj <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph> podpisu, aby zapewnić metadanych do wersji właściwości zależności, jak dodać do udostępnionego typu.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The return value of this method is typically used to declare and expose the dependency property by storing a dependency property identifier.</source>
          <target state="translated">Zwracana wartość tej metody zwykle umożliwia deklarowanie i ujawnia właściwości zależności, przechowując identyfikatora właściwości zależności.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The identifier provides access to the dependency property if you want to call property system <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> against the dependency property, particularly as it exists on the adding owner class.</source>
          <target state="translated">Identyfikator zapewnia dostęp do właściwości zależności, aby wywołać właściwości systemu <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> względem właściwości zależności, szczególnie jako istnieje na dodawanie klasy właściciela.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The same property name for both original owner and added owner should be used to indicate the similar functionality.</source>
          <target state="translated">Tej samej nazwie właściwości pierwotnego właściciela i dodany właściciela powinny być służy do wskazania podobnych możliwościach.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>You should use the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> return value of the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> method to define the dependency property identifier, and also to declare <ph id="ph3">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> property wrappers, for dependency properties that are added to types using <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>.</source>
          <target state="translated">Należy używać <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> wartość zwracana <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> metody do definiowania identyfikatora właściwości zależności, a także aby zadeklarować <ph id="ph3">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> otoki właściwości, dla właściwości zależności, które są dodawane do typów za pomocą <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> methodology recommended above is used when creating the dependency properties that are declared within <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> Metodologii zalecanych jest używany podczas tworzenia właściwości zależności, które są zadeklarowane w <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>For instance, both <ph id="ph1">&lt;xref:System.Windows.Controls.Border&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> define a <ph id="ph3">`BorderBrush`</ph> dependency property, which have similar functionality.</source>
          <target state="translated">Na przykład zarówno <ph id="ph1">&lt;xref:System.Windows.Controls.Border&gt;</ph> i <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> zdefiniować <ph id="ph3">`BorderBrush`</ph> właściwości zależności, które mają podobną funkcjonalność.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source><ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> defines its <ph id="ph2">`BorderBrush`</ph> property to the property system by calling <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> based on the original owner <ph id="ph4">&lt;xref:System.Windows.Controls.Border&gt;</ph> and its registered <ph id="ph5">&lt;xref:System.Windows.Controls.Border.BorderBrushProperty&gt;</ph> dependency property identifer.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> Definiuje jego <ph id="ph2">`BorderBrush`</ph> właściwości do właściwości systemu przez wywołanie metody <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> oparte na pierwotny właściciel <ph id="ph4">&lt;xref:System.Windows.Controls.Border&gt;</ph> i jego zarejestrowanych <ph id="ph5">&lt;xref:System.Windows.Controls.Border.BorderBrushProperty&gt;</ph> identyfikatora właściwości zależności.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> return value is then used to establish a new static <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> field (<ph id="ph3">&lt;xref:System.Windows.Controls.Control.BorderBrushProperty&gt;</ph>) for that property on the added owner, and a <ph id="ph4">`BorderBrush`</ph> property wrapper is also declared.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> Zwrócić wartość jest następnie używany do ustanawiania nowego statycznego <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> pola (<ph id="ph3">&lt;xref:System.Windows.Controls.Control.BorderBrushProperty&gt;</ph>) dla tej właściwości na dodano właściciela i <ph id="ph4">`BorderBrush`</ph> właściwości otoki jest również zadeklarowany.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The type to add as owner of this dependency property.</source>
          <target state="translated">Typ do dodania jako właściciela tej właściwości zależności.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The metadata that qualifies the dependency property as it exists on the provided type.</source>
          <target state="translated">Metadane, które kwalifikują się właściwości zależności, ponieważ znajduje się na podanego typu.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Adds another type as an owner of a dependency property that has already been registered, providing dependency property metadata for the dependency property as it will exist on the provided owner type.</source>
          <target state="translated">Dodaje innego typu jako właściciela właściwości zależności, który został już zarejestrowany, zapewniając metadanych właściwości zależności dla właściwości zależności będą znajdować się na typ podanego właściciela.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>A reference to the original <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> identifier that identifies the dependency property.</source>
          <target state="translated">Odwołanie do oryginalnej <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> identyfikator, który identyfikuje właściwości zależności.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>This identifier should be exposed by the adding class as a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field.</source>
          <target state="translated">Ten identyfikator powinny zostać ujawnione przez dodanie klasę jako <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> pola.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>This method enables the property system to recognize a dependency property on a type that did not register that particular dependency property initially.</source>
          <target state="translated">Ta metoda umożliwia systemowi właściwości rozpoznaje właściwości zależności na typ, który nie może zarejestrować danej właściwości zależności w szczególności początkowo.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The return value of this method is used to declare and expose the dependency property, particularly as it exists on the adding owner class.</source>
          <target state="translated">Zwracana wartość ta metoda służy do deklarowanie i ujawnia właściwości zależności szczególnie, ponieważ znajduje się ona na dodawanie klasy właściciela.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Generally, the same property name for both original owner and added owner should be used to indicate the similar functionality.</source>
          <target state="translated">Ogólnie rzecz biorąc tej samej nazwie właściwości pierwotnego właściciela i dodany właściciela powinny być służy do wskazania podobnych możliwościach.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>It is good practice to expose the identifiers, as well as new <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> property wrappers, for dependency properties that are added to types using <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>.</source>
          <target state="translated">Dobrym rozwiązaniem do udostępnienia identyfikatorów, a także jako nowy jest <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> otoki właściwości, dla właściwości zależności, które są dodawane do typów za pomocą <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> methodology recommended above is used when creating <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> declared within <ph id="ph3">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> Metodologii zalecanych jest używany podczas tworzenia <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> zadeklarowanym w <ph id="ph3">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>For instance, both <ph id="ph1">&lt;xref:System.Windows.Controls.Border&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> define a <ph id="ph3">`BorderBrush`</ph> dependency property, which have similar functionality.</source>
          <target state="translated">Na przykład zarówno <ph id="ph1">&lt;xref:System.Windows.Controls.Border&gt;</ph> i <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> zdefiniować <ph id="ph3">`BorderBrush`</ph> właściwości zależności, które mają podobną funkcjonalność.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source><ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> defines its <ph id="ph2">`BorderBrush`</ph> property to the property system by calling <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> on original owner <ph id="ph4">&lt;xref:System.Windows.Controls.Border&gt;</ph> and its registered <ph id="ph5">&lt;xref:System.Windows.Controls.Border.BorderBrushProperty&gt;</ph> dependency property identifer.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> Definiuje jego <ph id="ph2">`BorderBrush`</ph> właściwości do właściwości systemu przez wywołanie metody <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> na pierwotny właściciel <ph id="ph4">&lt;xref:System.Windows.Controls.Border&gt;</ph> i jego zarejestrowanych <ph id="ph5">&lt;xref:System.Windows.Controls.Border.BorderBrushProperty&gt;</ph> identyfikatora właściwości zależności.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> return value is then used to establish a static <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> field (<ph id="ph3">&lt;xref:System.Windows.Controls.Control.BorderBrushProperty&gt;</ph>)for that property on the added owner, and a <ph id="ph4">`BorderBrush`</ph> property wrapper is also declared.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> Zwrócić wartość jest następnie używany do ustanawiania statycznego <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> pola (<ph id="ph3">&lt;xref:System.Windows.Controls.Control.BorderBrushProperty&gt;</ph>) dla tej właściwości na dodano właściciela i <ph id="ph4">`BorderBrush`</ph> właściwości otoki jest również zadeklarowany.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The added owner's dependency property identifier should be used for operations such as <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph>.</source>
          <target state="translated">Identyfikator właściwości zależności właściciela dodano należy go używać w operacjach takich jak <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>However, type-specific operations involving either types or instances of the class that was added as owner with different metadata will still return the expected results even if the original (not the added owner's) dependency property identifier is specified in calls to methods such as <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GetMetadata%2A&gt;</ph>.</source>
          <target state="translated">Jednak określonego typu obejmującego typów lub wystąpienia klasy, która została dodana jako właściciela o metadanych, będzie nadal zwraca oczekiwanych rezultatów nawet wtedy, gdy oryginalne (nie dodano właściciela) określono identyfikator właściwości zależności w wywołań metod takich jak <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> lub <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GetMetadata%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The metadata for the added owner is perpetuated by the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> call itself, not necessarily referenced exclusively by the adding owner class identifier field.</source>
          <target state="translated">Metadane dla właściciela dodany jest perpetuated przez <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> wywołać się nie odwołuje się do wyłącznie przez dodanie pola Identyfikator klasy właściciela.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Nevertheless, it is good practice to expose the  identifier, as well as new <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> property wrappers, for dependency properties that are added to types using <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, because failing to do so creates disparity between the <ph id="ph3">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> and <ph id="ph4">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> representations of your properties.</source>
          <target state="translated">Niemniej jednak jest dobrym rozwiązaniem, aby prezentować identyfikator, a także jako nowy <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> otoki właściwości, dla właściwości zależności, które są dodawane do typów za pomocą <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, ponieważ w przeciwnym razie tworzy różnice między <ph id="ph3">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> i <ph id="ph4">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> reprezentacje właściwości.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</source>
          <target state="translated">Metadane podane jest scalany z metadanych właściwości dla właściwości zależności, ponieważ znajduje się na podstawowy właściciel.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Any characteristics that were specified in the original base metadata will persist.</source>
          <target state="translated">Wszystkie właściwości, które zostały określone w oryginalnych metadanych podstawowej będzie umieszczony.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</source>
          <target state="translated">Tylko te właściwości, które w szczególności zostały zmienione w nowych metadanych spowoduje zastąpienie właściwości podstawowej metadanych.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Some characteristics, such as <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph>, are replaced if they are specified in the new metadata.</source>
          <target state="translated">Niektóre właściwości, takie jak <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph>, zostały zastąpione, jeśli są one określone w nowymi metadanymi.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Others, such as <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, are combined.</source>
          <target state="translated">Inne, takie jak <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, są połączone.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Ultimately, the merge behavior depends on the property metadata type being used for the override, so the behavior described here is for the existing property metadata classes used by <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> dependency properties.</source>
          <target state="translated">Ostatecznie, zachowanie scalania zależy od typu metadanych właściwości używany do zastąpienia, dlatego dla istniejącej klasy metadanych właściwości używane przez zachowanie opisane tutaj <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> właściwości zależności.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Metadata<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> and <bpt id="p2">[</bpt>Framework Property Metadata<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <bpt id="p1">[</bpt>metadanych właściwości zależności<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> i <bpt id="p2">[</bpt>metadanych właściwości Framework<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>Gets the default metadata of the dependency property.</source>
          <target state="translated">Pobiera metadane domyślnej właściwości zależności.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>The default metadata of the dependency property.</source>
          <target state="translated">Metadane domyślnej właściwości zależności.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>The default metadata is the property metadata that is available to that particular object or an object of a derived type where no alternative metadata was supplied by an explicit <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> call.</source>
          <target state="translated">Metadane domyślne są metadane właściwości, która jest dostępna dla tego konkretnego obiektu lub typu pochodnego obiektu gdzie metadanych alternatywną, nie został dostarczony przez jawne <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> lub <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> wywołania.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>If the original owner applied metadata to the first <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> call that established the dependency property, then that metadata is returned as <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</source>
          <target state="translated">Jeśli właściciel oryginalnego zastosowano metadanych do pierwszej <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> wywołaniu, które ustanowić właściwości zależności, a następnie tych metadanych jest zwracana jako <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>If no metadata was applied in the original <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> call, then default metadata is generated from within the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> call and this value is returned as the <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</source>
          <target state="translated">Jeśli metadanych nie została zastosowana w oryginalnym <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> wywołań, a następnie metadanych domyślne są generowane na podstawie poziomu <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> połączeń i ta wartość jest zwracana jako <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>The main purpose of having default metadata associated with a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> is to supply a default value for this property on any <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> or a derived type.</source>
          <target state="translated">Głównym celem o domyślnej metadane skojarzone z <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> jest umożliwiają określanie wartości domyślnej dla tej właściwości na dowolnym <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> lub typu pochodnego.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>For nonattached properties, the metadata type returned by this property cannot be cast to derived types of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> type, even if the property was originally registered with a derived metadata type.</source>
          <target state="translated">Dla właściwości nie dołączony zwracane przez tę właściwość typu metadanych nie można rzutować na typy pochodne <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> typ, nawet jeśli właściwość pierwotnie został zarejestrowany z typu pochodnego metadanych.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>If you want the originally registered metadata including its original possibly derived metadata type, call <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29&gt;</ph> instead, passing the original registering type as a parameter.</source>
          <target state="translated">Jeśli pierwotnie zarejestrowanego metadanych, łącznie z jej oryginalnego typu pochodnego prawdopodobnie metadanych, należy wywołać <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29&gt;</ph> przekazywanie oryginalnego rejestrowanie zamiast tego typu jako parametr.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>For attached properties, the type of the metadata returned by this property will match the type given in the original <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> registration method.</source>
          <target state="translated">W przypadku dołączonych właściwości typ metadanych zwróconych przez tę właściwość zostanie pasuje do typu podane w oryginalnym <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> metoda rejestracji.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetHashCode">
          <source>Returns a hash code for this <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>.</source>
          <target state="translated">Zwraca wartość skrótu dla tego <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetHashCode">
          <source>The hash code for this <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>.</source>
          <target state="translated">Wartość skrótu dla tego <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetHashCode">
          <source>The property system uses its own unique identifier <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph>, and the value of that property is returned by <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GetHashCode%2A&gt;</ph>.</source>
          <target state="translated">Właściwość system używa swojego unikatowego identyfikatora <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph>, a wartość tej właściwości jest zwracany przez <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GetHashCode%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Returns the metadata associated with this dependency property as it exists for a particular type.</source>
          <target state="translated">Zwraca metadane skojarzone z tą właściwością zależności, ponieważ istnieje dla określonego typu.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>This can be the type where the dependency property was first registered, one to which it was added subsequently, or a type where the dependency property was obtained through inheritance but the metadata was specifically overridden.</source>
          <target state="translated">Może to być typ tam, gdzie właściwości zależności nie pierwsza z nich zarejestrowany, do której dodano później, lub typu, gdy właściwość zależności uzyskano za pośrednictwem dziedziczenia, ale metadane został zastąpiony.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>The specific type from which to retrieve the dependency property metadata.</source>
          <target state="translated">Określony typ, z którego można pobrać metadanych właściwości zależności.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>Returns the metadata for this dependency property as it exists on a specified existing type.</source>
          <target state="translated">Zwraca metadane dla ta właściwość zależności, które znajdują się na określony typ istniejących.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>A property metadata object.</source>
          <target state="translated">Właściwości obiektu metadanych.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>Specifying either the type or an object reference to use as type is necessary because the metadata can vary from the original registration due either to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> calls that alter the metadata of the dependency property as it exists on a type.</source>
          <target state="translated">Określanie typu lub odwołanie do obiektu, do użycia jako typ jest niezbędne, ponieważ metadane mogą się różnić od oryginalnej rejestracji ze względu na <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> lub <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> wywołania, które zmienić metadanych właściwości zależności, ponieważ istnieje w typie.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>The following example gets metadata for a dependency property based on its type.</source>
          <target state="translated">Poniższy przykład pobiera metadane dla właściwości zależności na podstawie jego typu.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>The type is obtained by using a <ph id="ph1">`typeof`</ph> operator.</source>
          <target state="translated">Tego typu uzyskuje się za pomocą <ph id="ph1">`typeof`</ph> operatora.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>A dependency object that is checked for type, to determine which type-specific version of the dependency property the metadata should come from.</source>
          <target state="translated">Obiekt zależności, który jest sprawdzany pod kątem typu, w celu ustalenia, która wersja określonego typu właściwości zależności metadanych powinna pochodzić z.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>Returns the metadata for this dependency property as it exists on the specified object instance.</source>
          <target state="translated">Zwraca metadane dla tej właściwości zależności, ponieważ znajduje się na wystąpienie określonego obiektu.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>A property metadata object.</source>
          <target state="translated">Właściwości obiektu metadanych.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>Specifying either the type or an object reference is necessary because the metadata of any given dependency property can vary from the original registration due either to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> calls that can refine the property metadata as it exists on a type.</source>
          <target state="translated">Określanie typu lub odwołanie do obiektu jest konieczne, ponieważ metadane żadnych danej właściwości zależności mogą się różnić od oryginalnej rejestracji ze względu na <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> lub <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> wywołania, które można dostosować metadanych właściwości, które znajdują się na Typ.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>When you request property metadata based on an instance, you are really just passing the instance so that its type can be evaluated internally.</source>
          <target state="translated">W przypadku żądania metadanych właściwość w wystąpieniu, są tak naprawdę przekazywanie wystąpienie tak, aby jej typ może przyjmować wewnętrznie.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>Dependency property metadata does not vary per instance; it is always consistent for any given type-property combination.</source>
          <target state="translated">Metadane właściwości zależności nie zmienia się na każde wystąpienie; zawsze jest spójne dla dowolnej kombinacji właściwości danego typu.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>The following example gets metadata for a dependency property based on a specific <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> instance.</source>
          <target state="translated">Poniższy przykład pobiera metadane dla właściwości zależności oparte na konkretnej <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> wystąpienia.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)">
          <source>A specific object that records the dependency object type from which the dependency property metadata is desired.</source>
          <target state="translated">Określonego obiektu, który rejestruje typ obiektu zależności, z którego jest pożądany metadanych właściwości zależności.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)">
          <source>Returns the metadata for this dependency property as it exists on a specified type.</source>
          <target state="translated">Zwraca metadane dla tej właściwości zależności, ponieważ znajduje się na określony typ.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)">
          <source>A property metadata object.</source>
          <target state="translated">Właściwości obiektu metadanych.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)">
          <source>Specifying either the type or an object reference is necessary because the metadata of any given dependency property can vary from the original registration due either to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> calls that can refine the property metadata as it exists on a type.</source>
          <target state="translated">Określanie typu lub odwołanie do obiektu jest konieczne, ponieważ metadane żadnych danej właściwości zależności mogą się różnić od oryginalnej rejestracji ze względu na <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> lub <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> wywołania, które można dostosować metadanych właściwości, które znajdują się na Typ.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)">
          <source>The following example gets metadata for a dependency property based on its <ph id="ph1">&lt;xref:System.Windows.DependencyObjectType&gt;</ph>.</source>
          <target state="translated">Poniższy przykład pobiera metadane dla właściwości zależności na podstawie jego <ph id="ph1">&lt;xref:System.Windows.DependencyObjectType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>Gets an internally generated value that uniquely identifies the dependency property.</source>
          <target state="translated">Pobiera wartość wewnętrznie generowane, który unikatowo identyfikuje właściwości zależności.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>A unique numeric identifier.</source>
          <target state="translated">Unikatowy identyfikator liczbowy.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>This value is an integer, not a <ph id="ph1">[!INCLUDE[TLA#tla_guid](~/includes/tlasharptla-guid-md.md)]</ph>.</source>
          <target state="translated">Ta wartość nie jest liczbą całkowitą <ph id="ph1">[!INCLUDE[TLA#tla_guid](~/includes/tlasharptla-guid-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>Generally, using this index value is not required, and there is no index access to tables of all dependency properties.</source>
          <target state="translated">Ogólnie rzecz biorąc przy użyciu tej wartości indeksu nie jest wymagane i brak jest indeks dostępu do tabel wszystkich właściwości zależności.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>Dependency properties should instead be referenced by their identifier fields.</source>
          <target state="translated">Właściwości zależności zamiast tego należy odwoływać się swoich pól identyfikator.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph> is used internally for faster access to data structures that use the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph> as a zero-based array index.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph> jest używana wewnętrznie do szybszy dostęp do struktury danych, które używają <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph> jako indeks tablicy liczony od zera.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>A similar usage might have applications for designers or tools.</source>
          <target state="translated">Podobne obciążenie może być aplikacje dla projektantów lub narzędzia.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source>The value to check.</source>
          <target state="translated">Wartość do sprawdzenia.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source>Determines whether a specified value is acceptable for this dependency property's type, as checked against the property type provided in the original dependency property registration.</source>
          <target state="translated">Określa, czy określona wartość jest akceptowalne dla typu ta właściwość zależności, ponieważ sprawdza, czy typ właściwości zawarte w pierwotnej rejestracji właściwości zależności.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified value is the registered property type or an acceptable derived type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli określona wartość jest typu zarejestrowanej właściwości lub dopuszczalne typu pochodnego; w przeciwnym razie <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source>A value of <ph id="ph1">`null`</ph> is a valid type for reference type dependency properties, or for a <ph id="ph2">&lt;xref:System.Nullable%601&gt;</ph> dependency property, and would return <ph id="ph3">`true`</ph> for these cases.</source>
          <target state="translated">Wartość <ph id="ph1">`null`</ph> jest prawidłowym typem dla właściwości zależności typu odwołania lub <ph id="ph2">&lt;xref:System.Nullable%601&gt;</ph> właściwości zależności i zwróci <ph id="ph3">`true`</ph> dla tych przypadków.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source>In cases where the dependency property is neither a reference nor a <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> type, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> will return <ph id="ph3">`false`</ph> for a null value rather than raise an exception.</source>
          <target state="translated">W przypadkach, gdy właściwość zależności jest ani odwołaniem ani <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> typu <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> zwróci <ph id="ph3">`false`</ph> na wartość null zamiast Zgłoś wyjątek.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> as a check before calling <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> on the dependency property.</source>
          <target state="translated">W poniższym przykładzie użyto <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> w celu sprawdzenia przed wywołaniem <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> we właściwości zależności.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>The value to check.</source>
          <target state="translated">Wartość do sprawdzenia.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>Determines whether the provided value is accepted for the type of property through basic type checking, and also potentially if it is within the allowed range of values for that type.</source>
          <target state="translated">Określa, czy podana wartość jest akceptowany dla typu właściwości, wybierając typ podstawowy, a także potencjalnie jeśli znajduje się w dozwolonym zakresem wartości dla tego typu.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value is acceptable and is of the correct type or a derived type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli wartość jest dopuszczalne i jest nieprawidłowego typu lub typu pochodnego; w przeciwnym razie <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>For a dependency property, an allowed range of values for that type can be specified through a <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> that is provided in the dependency property registration.</source>
          <target state="translated">Dla właściwości zależności, można określić zakres dozwolonych wartości dla tego typu za pomocą <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> dostarczanym rejestracji właściwości zależności.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>This method calls <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> internally.</source>
          <target state="translated">Ta metoda wywołuje <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> wewnętrznie.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>If the dependency property in question has no <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>,then calling this method is effectively equivalent to calling <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph>.</source>
          <target state="translated">Jeśli nie ma właściwości zależności w <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>, wywołanie tej metody jest równoważne wywołanie <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>If the dependency property does have a <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>, and if <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> would have returned <ph id="ph3">`true`</ph>, then the value returned will be as implemented in the callback.</source>
          <target state="translated">Jeśli właściwość zależności <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>i w razie <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> będzie musiał zwrócić <ph id="ph3">`true`</ph>, zwracana wartość będzie zgodnie z implementacją w wywołania zwrotnego.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>A null value is a valid value for reference type dependency properties, or for a <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> dependency property, and would return <ph id="ph2">`true`</ph> for these cases.</source>
          <target state="translated">Wartość null jest prawidłową wartością dla właściwości zależności typu odwołania lub <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> właściwości zależności i zwróci <ph id="ph2">`true`</ph> dla tych przypadków.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>In cases where the dependency property is neither a reference nor a <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> type, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> will return <ph id="ph3">`false`</ph> for a null value rather than raise an exception.</source>
          <target state="translated">W przypadkach, gdy właściwość zależności jest ani odwołaniem ani <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> typu <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> zwróci <ph id="ph3">`false`</ph> na wartość null zamiast Zgłoś wyjątek.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidValue%2A&gt;</ph> as a check before calling <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> on the dependency property.</source>
          <target state="translated">W poniższym przykładzie użyto <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidValue%2A&gt;</ph> w celu sprawdzenia przed wywołaniem <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> we właściwości zależności.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.Name">
          <source>Gets the name of the dependency property.</source>
          <target state="translated">Pobiera nazwę właściwości zależności.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>The name of the property.</source>
          <target state="translated">Nazwa właściwości.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>This property gets the name provided as the <ph id="ph1">`name`</ph> parameter during dependency property registration.</source>
          <target state="translated">Ta właściwość uzyskuje nazwę odpowiednio <ph id="ph1">`name`</ph> parametru podczas rejestracji właściwości zależności.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>This name is immutable, and cannot be <ph id="ph1">`null`</ph> or an empty string.</source>
          <target state="translated">Ta nazwa jest niemodyfikowalna i nie może być <ph id="ph1">`null`</ph> lub ciąg pusty.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>Duplicate name registrations on the same owner type are not permitted, and will throw an exception when you attempt to register the duplicate.</source>
          <target state="translated">Rejestracje zduplikowanej nazwy do tego samego typu właściciela nie są dozwolone i zgłosi wyjątek podczas próby zarejestrowania duplikatu.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph> of a dependency property must follow the convention of matching the name of its dependency property identifier minus the suffix "Property".</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph> Zależności właściwości należy postępować zgodnie z Konwencją pasującego do nazwy identyfikatora właściwości zależności minus sufiks "Property".</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>For details, see <bpt id="p1">[</bpt>Custom Dependency Properties<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept>.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <bpt id="p1">[</bpt>właściwości zależności niestandardowe<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>The following example queries various characteristics of a dependency property identifier, including the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph>.</source>
          <target state="translated">Poniższy przykład wysyła zapytanie do różnych właściwości identyfikatora właściwości zależności, w tym <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Supplies alternate metadata for this dependency property when it is present on instances of a specified type, versus the metadata that was provided in the initial dependency property registration.</source>
          <target state="translated">Dostaw alternatywny metadanych dla tej właściwości zależności, gdy nie jest obecny w wystąpieniach określonego typu, a metadane, które podano w rejestracji właściwości zależności początkowej.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>The type where this dependency property is inherited and where the provided alternate metadata will be applied.</source>
          <target state="translated">Typ, w którym ta właściwość zależności jest dziedziczona i gdzie zostaną zastosowane podane metadane alternatywny.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>The metadata to apply to the dependency property on the overriding type.</source>
          <target state="translated">Metadane dla właściwości zależności na zastępowanie typu.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Specifies alternate metadata for this dependency property when it is present on instances of a specified type, overriding the metadata that existed for the dependency property as it was inherited from base types.</source>
          <target state="translated">Określa alternatywny metadanych dla tej właściwości zależności, gdy nie jest obecny w wystąpieniach o określonym typie, zastępowanie metadanych, które istniały dla właściwości zależności, ponieważ został on odziedziczony z typów podstawowych.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Dependency property metadata should be overridden before the property system uses the dependency property.</source>
          <target state="translated">Powinna zostać zastąpiona metadanych właściwości zależności, zanim system właściwości używa właściwości zależności.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>This equates to the time that specific instances are created using the class that registers the dependency property.</source>
          <target state="translated">To jest równa czas określone wystąpienia są tworzone przy użyciu klasy, która rejestruje właściwości zależności.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Calls to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> should only be performed within the static constructors of the type that provides itself as the <ph id="ph2">`forType`</ph> parameter of this method, or through similar instantiation.</source>
          <target state="translated">Wywołań <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> powinno być wykonywane jedynie konstruktorów statycznych typu, który udostępnia siebie jako <ph id="ph2">`forType`</ph> parametru tej metody lub za pomocą podobnego wystąpienia.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Attempting to change metadata after instances of the owner type exist will not raise exceptions, but will result in inconsistent behaviors in the property system.</source>
          <target state="translated">Podjęto próbę zmiany metadanych po istnieje wystąpienie typu właściciela nie będą zgłaszać wyjątków, ale spowoduje niespójność zachowania w systemie właściwości.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>After metadata for a particular derived class override is established with this method, subsequent attempts to override metadata on this same derived class will raise an exception.</source>
          <target state="translated">Po ustanowieniu metadanych dla elementu override określonej klasy pochodnej z tą metodą, kolejne próby na zastępowanie metadanych na tej samej klasy pochodnej zgłosi wyjątek.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</source>
          <target state="translated">Metadane podane jest scalany z metadanych właściwości dla właściwości zależności, ponieważ znajduje się na podstawowy właściciel.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Any characteristics that were specified in the original base metadata will persist; only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</source>
          <target state="translated">Wszystkie właściwości, które zostały określone w oryginalnych metadanych podstawowej będzie trwać; tylko te właściwości, które w szczególności zostały zmienione w nowych metadanych spowoduje zastąpienie właściwości podstawowej metadanych.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Some characteristics such as <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> are replaced if specified in the new metadata.</source>
          <target state="translated">Niektóre właściwości, takie jak <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> zostały zastąpione, jeśli określony w nowych metadanych.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Others, such as <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, are combined.</source>
          <target state="translated">Inne, takie jak <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, są połączone.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Ultimately, the merge behavior depends on the property metadata type being used for the override, so the behavior described here is for the existing property metadata classes used by <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> dependency properties.</source>
          <target state="translated">Ostatecznie, zachowanie scalania zależy od typu metadanych właściwości używany do zastąpienia, dlatego dla istniejącej klasy metadanych właściwości używane przez zachowanie opisane tutaj <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> właściwości zależności.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Metadata<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> and <bpt id="p2">[</bpt>Framework Property Metadata<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <bpt id="p1">[</bpt>metadanych właściwości zależności<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> i <bpt id="p2">[</bpt>metadanych właściwości Framework<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>An attempt was made to override metadata on a read-only dependency property (that operation cannot be done using this signature).</source>
          <target state="translated">Nastąpiła próba na zastępowanie metadanych właściwości tylko do odczytu zależności (nie można wykonać operacji przy użyciu tego podpisu).</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Metadata was already established for the dependency property as it exists on the provided type.</source>
          <target state="translated">Metadane już zostało ustanowione dla właściwości zależności, ponieważ znajduje się na podanego typu.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>The type where this dependency property is inherited and where the provided alternate metadata will be applied.</source>
          <target state="translated">Typ, w którym ta właściwość zależności jest dziedziczona i gdzie zostaną zastosowane podane metadane alternatywny.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>The metadata to apply to the dependency property on the overriding type.</source>
          <target state="translated">Metadane dla właściwości zależności na zastępowanie typu.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>The access key for a read-only dependency property.</source>
          <target state="translated">Klucz dostępu dla właściwości zależności tylko do odczytu.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Supplies alternate metadata for a read-only dependency property when it is present on instances of a specified type, overriding the metadata that was provided in the initial dependency property registration.</source>
          <target state="translated">Dostaw alternatywny metadane dla właściwości tylko do odczytu zależności, gdy nie jest obecny w wystąpieniach o określonym typie, zastępowanie metadanych, które podano w rejestracji właściwości zależności początkowej.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>You must pass the <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyKey" /&gt;</ph> for the read-only dependency property to avoid raising an exception.</source>
          <target state="translated">Należy podać <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyKey" /&gt;</ph> dla właściwości tylko do odczytu zależności uniknąć, który wywołał wyjątek.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>This signature provides underlying implementation for a read-only dependency property identifier (<ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>) method.</source>
          <target state="translated">Ta sygnatura zawiera implementacja dla identyfikatora właściwości zależności tylko do odczytu (<ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>) metody.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>If overriding metadata for a read-write dependency property, use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>.</source>
          <target state="translated">Jeśli Zastępowanie metadanych dla właściwości zależności odczytu i zapisu, użyj <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Dependency property metadata should be overridden before the property system uses the dependency property.</source>
          <target state="translated">Powinna zostać zastąpiona metadanych właściwości zależności, zanim system właściwości używa właściwości zależności.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>This equates to the time that specific objects are created for the class that registers the dependency property.</source>
          <target state="translated">To jest równa czasu określone obiekty są tworzone dla klasy, która rejestruje właściwości zależności.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Calls to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> should only be performed within the static constructors of the type that provides itself as the <ph id="ph2">`forType`</ph> parameter of this method, or through similar instantiation.</source>
          <target state="translated">Wywołań <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> powinno być wykonywane jedynie konstruktorów statycznych typu, który udostępnia siebie jako <ph id="ph2">`forType`</ph> parametru tej metody lub za pomocą podobnego wystąpienia.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Attempting to change metadata after instances of the owner type exist will not raise exceptions, but will result in inconsistent behaviors in the property system.</source>
          <target state="translated">Podjęto próbę zmiany metadanych po istnieje wystąpienie typu właściciela nie będą zgłaszać wyjątków, ale spowoduje niespójność zachowania w systemie właściwości.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>After metadata for a particular derived class override is established with this method, subsequent attempts to override metadata on this same derived class will raise an exception.</source>
          <target state="translated">Po ustanowieniu metadanych dla elementu override określonej klasy pochodnej z tą metodą, kolejne próby na zastępowanie metadanych na tej samej klasy pochodnej zgłosi wyjątek.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</source>
          <target state="translated">Metadane podane jest scalany z metadanych właściwości dla właściwości zależności, ponieważ znajduje się na podstawowy właściciel.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Any characteristics that were specified in the original base metadata will persist; only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</source>
          <target state="translated">Wszystkie właściwości, które zostały określone w oryginalnych metadanych podstawowej będzie trwać; tylko te właściwości, które w szczególności zostały zmienione w nowych metadanych spowoduje zastąpienie właściwości podstawowej metadanych.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Some characteristics such as <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> are replaced if specified in the new metadata.</source>
          <target state="translated">Niektóre właściwości, takie jak <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> zostały zastąpione, jeśli określony w nowych metadanych.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Others, such as <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, are combined.</source>
          <target state="translated">Inne, takie jak <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, są połączone.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>The merge behavior depends on the property metadata type being used for the override.</source>
          <target state="translated">Zachowanie scalania zależy od typu metadanych właściwości używany do zastąpienia.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Metadata<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> and <bpt id="p2">[</bpt>Framework Property Metadata<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <bpt id="p1">[</bpt>metadanych właściwości zależności<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> i <bpt id="p2">[</bpt>metadanych właściwości Framework<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>Gets the type of the object that registered the dependency property with the property system, or added itself as owner of the property.</source>
          <target state="translated">Pobiera typ obiektu, który jest zarejestrowany w systemie właściwość właściwości zależności lub dodaje się jako właściciela właściwości.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>The type of the object that registered the property or added itself as owner of the property.</source>
          <target state="translated">Typ obiektu, który zarejestrowany właściwość lub dodaje się jako właściciela właściwości.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>This value was provided during property registration.</source>
          <target state="translated">Ta wartość zostało podane podczas rejestracji właściwości.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>The owner will be either the original registering type in the case of a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier generated from a <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> call, or the type that added itself as owner in the case of a <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier generated from an <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> call.</source>
          <target state="translated">Właściciel będzie albo oryginalnego rejestracji typu w odniesieniu <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> generowane na podstawie identyfikatora <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> wywołania lub typ, który dodaje się jako właściciel w przypadku <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> generowane na podstawie identyfikatora <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> wywołania.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OwnerType%2A&gt;</ph> on any given <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> is immutable, and cannot be <ph id="ph3">`null`</ph> in a valid <ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OwnerType%2A&gt;</ph> Na żadnej podanej <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> jest niemodyfikowalna i nie może być <ph id="ph3">`null`</ph> w prawidłowej <ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>The following example gets the owner type based on a dependency property identifier <ph id="ph1">`dp`</ph>, and then gets metadata on the owner type for that same identifier.</source>
          <target state="translated">Poniższy przykład pobiera typ właściciela na podstawie identyfikatora właściwości zależności <ph id="ph1">`dp`</ph>, a następnie pobiera metadane dla typu właściciela dla tego samego identyfikatora.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>This operation is actually equivalent to getting <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph> on <ph id="ph2">`dp`</ph>.</source>
          <target state="translated">Ta operacja jest w rzeczywistości odpowiednikiem pobierania <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph> na <ph id="ph2">`dp`</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>Gets the type that the dependency property uses for its value.</source>
          <target state="translated">Pobiera typ, który używa właściwości zależności dla jej wartości.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the property value.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> Wartości właściwości.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>This property reports the type of the property's value as declared by the original property registration, through the <ph id="ph1">`propertyType`</ph> parameter.</source>
          <target state="translated">Ta właściwość raportuje typ wartości właściwości w postaci zadeklarowanej przez pierwotnej rejestracji właściwości, za pomocą <ph id="ph1">`propertyType`</ph> parametru.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>Similar to the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph>, the property type of a dependency property is immutable after registration.</source>
          <target state="translated">Podobnie jak <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph>, typ właściwości właściwości zależności nie można modyfikować po rejestracji.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>The following example queries various characteristics of a dependency property identifier, including the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.PropertyType%2A&gt;</ph>.</source>
          <target state="translated">Poniższy przykład wysyła zapytanie do różnych właściwości identyfikatora właściwości zależności, w tym <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.PropertyType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>The type name string of the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.PropertyType%2A&gt;</ph> is obtained from the returned <ph id="ph2">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Ciąg nazwy typu <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.PropertyType%2A&gt;</ph> są uzyskiwane z zwróconego <ph id="ph2">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>Gets a value that indicates whether the dependency property identified by this <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> instance is a read-only dependency property.</source>
          <target state="translated">Pobiera wartość wskazującą, czy właściwość zależności jest identyfikowane przez to <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> wystąpienie jest właściwością tylko do odczytu zależności.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property is read-only; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli właściwość zależności jest tylko do odczytu. w przeciwnym razie <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>Read-only dependency properties are registered within the property system by calling the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt;</ph> method as opposed to the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> method.</source>
          <target state="translated">Właściwości tylko do odczytu zależności są zarejestrowane w systemie właściwości przez wywołanie metody <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt;</ph> metody, w przeciwieństwie do <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>Attached properties can also be registered as read-only; see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;</ph>.</source>
          <target state="translated">Dołączone właściwości może być również zarejestrowany jako tylko do odczytu. zobacz <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>Read-only dependency properties require a <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> identifier rather than a <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier to perform metadata operations such as overriding the metadata or setting the value.</source>
          <target state="translated">Właściwości tylko do odczytu zależności wymagają <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> identyfikator zamiast <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identyfikator do wykonywania operacji na metadanych, takich jak zastępowanie metadanych lub ustawiania wartości.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>If you obtained a collection of <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifiers through a call to <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;</ph> or another <ph id="ph3">[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]</ph> that exposes identifiers, check the <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> value before attempting to call <ph id="ph5">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> or <ph id="ph6">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> using that dependency property identifier as an input parameter, to verify that the dependency property that the identifier represents is not read-only.</source>
          <target state="translated">Jeśli użytkownik uzyskał Kolekcja <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identyfikatory poprzez wywołanie <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;</ph> lub innym <ph id="ph3">[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]</ph> który uwidacznia identyfikatorów, sprawdź <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> wartość przed podjęciem ponownej próby wywołania <ph id="ph5">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> lub <ph id="ph6">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> za pomocą którego Identyfikator właściwości zależności jako parametr wejściowy, aby sprawdzić, czy właściwości zależności, który reprezentuje identyfikator nie jest tylko do odczytu.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>If the value of <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> is <ph id="ph2">`true`</ph> on a dependency property, there is no programmatic way to obtain a reference to the <ph id="ph3">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> identifier of that dependency property, from the metadata or from the <ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier; the identifier must be available as a static field in order to call <ph id="ph5">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph> against a read-only dependency property.</source>
          <target state="translated">Jeśli wartość <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> jest <ph id="ph2">`true`</ph> we właściwości zależności nie istnieje sposób programowy uzyskać odwołania do <ph id="ph3">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> identyfikatora właściwości zależności, z metadanych lub <ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identyfikator; identyfikator muszą być dostępne jako statyczne pole w celu wywołania <ph id="ph5">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph> względem właściwości zależności tylko do odczytu.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>When you create a custom dependency property, and register it as read-only, you should define only a get accessor for the <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> wrapper property.</source>
          <target state="translated">Podczas tworzenia właściwości zależności niestandardowe i zarejestruj go jako tylko do odczytu, należy zdefiniować tylko metody dostępu get dla <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> właściwości otoki.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>Otherwise, your class will have a confusing object model for the property wrapper as compared to the access to the backing dependency property.</source>
          <target state="translated">W przeciwnym razie klasy mają mylące model obiektów dla otoki właściwości w porównaniu do dostępu do właściwości zależności zapasowego.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>For details, see <bpt id="p1">[</bpt>Custom Dependency Properties<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept> or <bpt id="p2">[</bpt>Read-Only Dependency Properties<ept id="p2">](~/docs/framework/wpf/advanced/read-only-dependency-properties.md)</ept>.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <bpt id="p1">[</bpt>właściwości zależności niestandardowe<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept> lub <bpt id="p2">[</bpt>tylko do odczytu właściwości zależności<ept id="p2">](~/docs/framework/wpf/advanced/read-only-dependency-properties.md)</ept>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>The following example obtains the default metadata and the dependency property identifier properties from various dependency property fields, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">Poniższy przykład uzyskuje metadanych domyślne i właściwości identyfikatora właściwości zależności z różnymi polami właściwości zależności, a informacje są używane do wypełnienia tabeli do zaimplementowania przeglądarką"metadanych".</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Registers a dependency property.</source>
          <target state="translated">Rejestruje właściwości zależności.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nazwa właściwości zależności, aby zarejestrować.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>The name must be unique within the registration namespace of the owner type.</source>
          <target state="translated">Nazwa musi być unikatowa w ramach rejestracji przestrzeni nazw typu właściciela.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>The type of the property.</source>
          <target state="translated">Typ właściwości.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Typ właściciela, który rejestruje właściwości zależności.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>Registers a dependency property with the specified property name, property type, and owner type.</source>
          <target state="translated">Określona nazwa właściwości, typ właściwości i typ właściciela rejestruje właściwości zależności.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Identyfikator właściwości zależności, które mają być używane, aby ustawić wartość <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> pole w klasie.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Ten identyfikator jest następnie używany do później, odwołanie właściwości zależności dla operacji, takich jak programowo ustawiania dla niego wartości i uzyskiwanie metadanych.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Aby uzyskać więcej informacji dotyczących rejestracji właściwości zależności, zobacz <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nazwa właściwości zależności, aby zarejestrować.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The type of the property.</source>
          <target state="translated">Typ właściwości.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Typ właściciela, który rejestruje właściwości zależności.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Metadane właściwości dla właściwości zależności.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registers a dependency property with the specified property name, property type, owner type, and property metadata.</source>
          <target state="translated">Rejestruje właściwości zależności określona nazwa właściwości, typ właściwości, typ właściciela i metadane właściwości.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Identyfikator właściwości zależności, które mają być używane, aby ustawić wartość <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> pole w klasie.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Ten identyfikator jest następnie używany do później, odwołanie właściwości zależności dla operacji, takich jak programowo ustawiania dla niego wartości i uzyskiwanie metadanych.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Aby uzyskać więcej informacji dotyczących rejestracji właściwości zależności, zobacz <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nazwa właściwości zależności, aby zarejestrować.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The type of the property.</source>
          <target state="translated">Typ właściwości.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Typ właściciela, który rejestruje właściwości zależności.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Metadane właściwości dla właściwości zależności.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</source>
          <target state="translated">Odwołanie do wywołania zwrotnego, które należy wykonać wszelkie niestandardowego sprawdzania poprawności wartości właściwości zależności poza typowy Typ weryfikacji.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registers a dependency property with the specified property name, property type, owner type, property metadata, and a value validation callback for the property.</source>
          <target state="translated">Określona nazwa właściwości, typ właściwości, typ właściciela, metadane właściwości i wywołanie zwrotne weryfikacji wartości dla właściwości rejestruje właściwości zależności.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Identyfikator właściwości zależności, które mają być używane, aby ustawić wartość <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> pole w klasie.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Ten identyfikator jest następnie używany do później, odwołanie właściwości zależności dla operacji, takich jak programowo ustawiania dla niego wartości i uzyskiwanie metadanych.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Aby uzyskać więcej informacji dotyczących rejestracji właściwości zależności, zobacz <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The following example registers a dependency property, including a validation callback (the callback definition is not shown; for details on the callback definition, see <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>).</source>
          <target state="translated">Poniższy przykład rejestruje właściwości zależności, w tym wywołanie zwrotne weryfikacji (definicja wywołanie zwrotne nie jest wyświetlany; szczegółowe informacje dotyczące definicji wywołania zwrotnego, zobacz <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Registers an attached property with the property system.</source>
          <target state="translated">Rejestruje dołączona właściwość z systemu właściwości.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nazwa właściwości zależności, aby zarejestrować.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>The type of the property.</source>
          <target state="translated">Typ właściwości.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Typ właściciela, który rejestruje właściwości zależności.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>Registers an attached property with the specified property name, property type, and owner type.</source>
          <target state="translated">Rejestruje dołączona właściwość o nazwie określonej właściwości, typ właściwości i typ właściciela.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Identyfikator właściwości zależności, które mają być używane, aby ustawić wartość <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> pole w klasie.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Ten identyfikator jest następnie używany do później, odwołanie właściwości zależności dla operacji, takich jak programowo ustawiania dla niego wartości i uzyskiwanie metadanych.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>An attached property is a property concept defined by <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Dołączona właściwość to pojęcie właściwości zdefiniowane przez <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implements attached properties as dependency properties.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implementuje dołączone właściwości jako właściwości zależności.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>Because the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</source>
          <target state="translated">Ponieważ <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> właściwości zależności są dołączone właściwości, mogą oni mieć metadanych stosowane używaną przez system ogólne właściwości dla operacji, takich jak raportowanie właściwości układu.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>For more information, see <bpt id="p1">[</bpt>Attached Properties Overview<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <bpt id="p1">[</bpt>dołączony Przegląd właściwości<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Aby uzyskać więcej informacji dotyczących rejestracji właściwości zależności, zobacz <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>The following example registers an attached property on an abstract class using this <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> signature.</source>
          <target state="translated">Poniższy przykład rejestruje dołączona właściwość dla klasy abstrakcyjnej za pomocą tej <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> podpisu.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nazwa właściwości zależności, aby zarejestrować.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The type of the property.</source>
          <target state="translated">Typ właściwości.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Typ właściciela, który rejestruje właściwości zależności.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Metadane właściwości dla właściwości zależności.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>This can include the default value as well as other characteristics.</source>
          <target state="translated">Mogą to wartość domyślna, a także inne właściwości.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registers an attached property with the specified property name, property type, owner type, and property metadata.</source>
          <target state="translated">Rejestruje dołączona właściwość określona nazwa właściwości, typ właściwości, typ właściciela i metadane właściwości.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Identyfikator właściwości zależności, które mają być używane, aby ustawić wartość <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> pole w klasie.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Ten identyfikator jest następnie używany do później, odwołanie właściwości zależności dla operacji, takich jak programowo ustawiania dla niego wartości i uzyskiwanie metadanych.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>An attached property is a property concept defined by <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Dołączona właściwość to pojęcie właściwości zdefiniowane przez <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implements attached properties as dependency properties.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implementuje dołączone właściwości jako właściwości zależności.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Because the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</source>
          <target state="translated">Ponieważ <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> właściwości zależności są dołączone właściwości, mogą oni mieć metadanych stosowane używaną przez system ogólne właściwości dla operacji, takich jak raportowanie właściwości układu.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information, see <bpt id="p1">[</bpt>Attached Properties Overview<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <bpt id="p1">[</bpt>dołączony Przegląd właściwości<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Aby uzyskać więcej informacji dotyczących rejestracji właściwości zależności, zobacz <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Use RegisterAttached for Value-inheriting Dependency Properties</source>
          <target state="translated">Użyj RegisterAttached dziedziczenie wartość właściwości zależności</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>One particular scenario for registering a dependency property with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> instead of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> is to support property value inheritance.</source>
          <target state="translated">Jednego scenariusza rejestrowania właściwości zależności z <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> zamiast <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> służy do obsługi dziedziczenie wartości właściwości.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>You should register value-inheriting dependency properties with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set* static methods to provide true attached property support accessors.</source>
          <target state="translated">Należy zarejestrować dziedziczenie wartość właściwości zależności z <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> nawet wtedy, gdy klasa definiuje otoki metod dostępu właściwości, które udostępniają właściwości zależności, a nawet wtedy, gdy nie zamierzasz ujawnia Get * i Set * statycznej metody w celu zapewnienia true dołączony metod dostępu do właściwości pomocy technicznej.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</source>
          <target state="translated">Mimo że dziedziczenie wartości właściwości mogą być wyświetlane dla właściwości zależności nie dołączony, zachowanie dziedziczenia właściwości nie dołączony do określonych granic elementu w drzewie środowiska uruchomieniowego jest niezdefiniowany.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</source>
          <target state="translated">Rejestrowanie właściwości, jak skutecznie dołączone powoduje dołączona właściwość globalnych właściwości w systemie właściwości i gwarantuje, że dziedziczenie wartości właściwości działa przez wszystkie granice w drzewie elementu.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Always use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> to register properties where you specify <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in the metadata.</source>
          <target state="translated">Zawsze używaj <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> można zarejestrować właściwości, w którym można określić <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> w metadanych.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <bpt id="p1">[</bpt>dziedziczenie wartości właściwości<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nazwa właściwości zależności, aby zarejestrować.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The type of the property.</source>
          <target state="translated">Typ właściwości.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Typ właściciela, który rejestruje właściwości zależności.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Metadane właściwości dla właściwości zależności.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>This can include the default value as well as other characteristics.</source>
          <target state="translated">Mogą to wartość domyślna, a także inne właściwości.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</source>
          <target state="translated">Odwołanie do wywołania zwrotnego, które należy wykonać wszelkie niestandardowego sprawdzania poprawności wartości właściwości zależności poza typowy Typ weryfikacji.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registers an attached property with the specified property type, owner type, property metadata, and value validation callback for the property.</source>
          <target state="translated">Rejestruje dołączona właściwość z określonym typem właściwości, typ właściciela, metadane właściwości i wywołanie zwrotne weryfikacji wartości dla właściwości.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Identyfikator właściwości zależności, które mają być używane, aby ustawić wartość <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> pole w klasie.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Ten identyfikator jest następnie używany do później, odwołanie właściwości zależności dla operacji, takich jak programowo ustawiania dla niego wartości i uzyskiwanie metadanych.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>An attached property is a property concept defined by <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Dołączona właściwość to pojęcie właściwości zdefiniowane przez <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implements attached properties as dependency properties.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implementuje dołączone właściwości jako właściwości zależności.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Because the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</source>
          <target state="translated">Ponieważ <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> właściwości zależności są dołączone właściwości, mogą oni mieć metadanych stosowane używaną przez system ogólne właściwości dla operacji, takich jak raportowanie właściwości układu.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information, see <bpt id="p1">[</bpt>Attached Properties Overview<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <bpt id="p1">[</bpt>dołączony Przegląd właściwości<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Aby uzyskać więcej informacji dotyczących rejestracji właściwości zależności, zobacz <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Use RegisterAttached for Value-inheriting Dependency Properties</source>
          <target state="translated">Użyj RegisterAttached dziedziczenie wartość właściwości zależności</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>One particular scenario for registering a dependency property with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> instead of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> is to support property value inheritance.</source>
          <target state="translated">Jednego scenariusza rejestrowania właściwości zależności z <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> zamiast <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> służy do obsługi dziedziczenie wartości właściwości.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>You should register value-inheriting dependency properties with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set* static methods to provide true attached property support accessors.</source>
          <target state="translated">Należy zarejestrować dziedziczenie wartość właściwości zależności z <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> nawet wtedy, gdy klasa definiuje otoki metod dostępu właściwości, które udostępniają właściwości zależności, a nawet wtedy, gdy nie zamierzasz ujawnia Get * i Set * statycznej metody w celu zapewnienia true dołączony metod dostępu do właściwości pomocy technicznej.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</source>
          <target state="translated">Mimo że dziedziczenie wartości właściwości mogą być wyświetlane dla właściwości zależności nie dołączony, zachowanie dziedziczenia właściwości nie dołączony do określonych granic elementu w drzewie środowiska uruchomieniowego jest niezdefiniowany.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</source>
          <target state="translated">Rejestrowanie właściwości, jak skutecznie dołączone powoduje dołączona właściwość globalnych właściwości w systemie właściwości i gwarantuje, że dziedziczenie wartości właściwości działa przez wszystkie granice w drzewie elementu.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Always use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> to register properties where you specify <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in the metadata.</source>
          <target state="translated">Zawsze używaj <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> można zarejestrować właściwości, w którym można określić <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> w metadanych.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <bpt id="p1">[</bpt>dziedziczenie wartości właściwości<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The following example registers an attached property on an abstract class using this <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> signature.</source>
          <target state="translated">Poniższy przykład rejestruje dołączona właściwość dla klasy abstrakcyjnej za pomocą tej <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> podpisu.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>This attached property is an enumeration type property, and the registration adds a validation callback to verify that the provided value is a value of the enumeration.</source>
          <target state="translated">Ta dołączona właściwość jest właściwością typu wyliczenia i rejestracji dodaje wywołanie zwrotne weryfikacji, aby sprawdzić, czy podana wartość jest wartością wyliczenia.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Registers a read-only attached property.</source>
          <target state="translated">Rejestruje w trybie tylko do odczytu dołączona właściwość.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nazwa właściwości zależności, aby zarejestrować.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The type of the property.</source>
          <target state="translated">Typ właściwości.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Typ właściciela, który rejestruje właściwości zależności.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Metadane właściwości dla właściwości zależności.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registers a read-only attached property, with the specified property type, owner type, and property metadata.</source>
          <target state="translated">Rejestruje tylko do odczytu dołączona właściwość, z określonym typem właściwości, typ właściciela i metadane właściwości.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</source>
          <target state="translated">Klucz właściwości zależności, które mają być używane do wartości pola statycznego tylko do odczytu w klasie, która jest następnie używany do odwołać później właściwości zależności.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>This method returns the type <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, whereas <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> returns the type <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Ta metoda zwraca typ <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, podczas gdy <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> zwraca typ <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</source>
          <target state="translated">Zazwyczaj nie zostaną wprowadzone publiczne, klucze, które reprezentują właściwości tylko do odczytu, ponieważ klucze można ustawić wartości właściwości zależności przez wywołanie metody <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</source>
          <target state="translated">Projekt klasy będzie miało wpływ na wymagania dotyczące, ale ogólnie zaleca się ograniczyć dostęp i widoczności dowolnego <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> tylko te części kodu, które są niezbędne, można ustawić tej właściwości zależności w ramach klasy lub aplikacji logiki.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> as a <ph id="ph2">`public static readonly`</ph> field on your class.</source>
          <target state="translated">Zaleca się również ujawniać identyfikatora właściwości zależności dla właściwości tylko do odczytu zależności, w przypadku wystawianego wartość <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> jako <ph id="ph2">`public static readonly`</ph> pole w klasie.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Dołączone właściwości tylko do odczytu są scenariusza rzadko, ponieważ podstawowy scenariusz dla właściwości dołączonej użyciem jej w <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Without a public setter, an attached property cannot be set in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax.</source>
          <target state="translated">Bez publicznej metody ustawiającej właściwości dołączonej nie można ustawić w <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> składni.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Aby uzyskać więcej informacji dotyczących rejestracji właściwości zależności, zobacz <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Use RegisterAttached for Value-inheriting Dependency Properties</source>
          <target state="translated">Użyj RegisterAttached dziedziczenie wartość właściwości zależności</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>One particular scenario for registering a dependency property as attached is to support property value inheritance.</source>
          <target state="translated">Jednego scenariusza rejestrowania właściwości zależności jako dołączona jest zapewnienie pomocy technicznej dziedziczenie wartości właściwości.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>You should register value-inheriting dependency properties with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set* static methods to provide true attached property support accessors.</source>
          <target state="translated">Należy zarejestrować dziedziczenie wartość właściwości zależności z <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> nawet wtedy, gdy klasa definiuje otoki metod dostępu właściwości, które udostępniają właściwości zależności, a nawet wtedy, gdy nie zamierzasz ujawnia Get * i Set * statycznej metody w celu zapewnienia true dołączony metod dostępu do właściwości pomocy technicznej.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</source>
          <target state="translated">Mimo że dziedziczenie wartości właściwości mogą być wyświetlane dla właściwości zależności nie dołączony, zachowanie dziedziczenia właściwości nie dołączony do określonych granic elementu w drzewie środowiska uruchomieniowego jest niezdefiniowany.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</source>
          <target state="translated">Rejestrowanie właściwości, jak skutecznie dołączone powoduje dołączona właściwość globalnych właściwości w systemie właściwości i gwarantuje, że dziedziczenie wartości właściwości działa przez wszystkie granice w drzewie elementu.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Always use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> to register properties where you specify <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in the metadata.</source>
          <target state="translated">Zawsze używaj <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> można zarejestrować właściwości, w którym można określić <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> w metadanych.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <bpt id="p1">[</bpt>dziedziczenie wartości właściwości<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nazwa właściwości zależności, aby zarejestrować.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The type of the property.</source>
          <target state="translated">Typ właściwości.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Typ właściciela, który rejestruje właściwości zależności.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Metadane właściwości dla właściwości zależności.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</source>
          <target state="translated">Odwołanie do utworzonych przez użytkownika wywołanie zwrotne, które należy wykonać wszelkie niestandardowego sprawdzania poprawności wartości właściwości zależności poza typowy Typ weryfikacji.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registers a read-only attached property, with the specified property type, owner type, property metadata, and a validation callback.</source>
          <target state="translated">Rejestruje tylko do odczytu dołączona właściwość, z określonym typem właściwości, typ właściciela metadanych właściwości i wywołanie zwrotne weryfikacji.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</source>
          <target state="translated">Klucz właściwości zależności, które mają być używane do wartości pola statycznego tylko do odczytu w klasie, która jest następnie używany do odwołania właściwości zależności.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>This method returns the type <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, whereas <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> returns the type <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Ta metoda zwraca typ <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, podczas gdy <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> zwraca typ <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Typically, the keys that represent the type <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Zazwyczaj klucze, które reprezentują typ <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</source>
          <target state="translated">Zazwyczaj nie zostaną wprowadzone publiczne, klucze, które reprezentują właściwości tylko do odczytu, ponieważ klucze można ustawić wartości właściwości zależności przez wywołanie metody <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</source>
          <target state="translated">Projekt klasy będzie miało wpływ na wymagania dotyczące, ale ogólnie zaleca się ograniczyć dostęp i widoczności dowolnego <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> tylko te części kodu, które są niezbędne, można ustawić tej właściwości zależności w ramach klasy lub aplikacji logiki.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> as a <ph id="ph2">`public static readonly`</ph> field on your class.</source>
          <target state="translated">Zaleca się również ujawniać identyfikatora właściwości zależności dla właściwości tylko do odczytu zależności, w przypadku wystawianego wartość <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> jako <ph id="ph2">`public static readonly`</ph> pole w klasie.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Dołączone właściwości tylko do odczytu są scenariusza rzadko, ponieważ podstawowy scenariusz dla właściwości dołączonej użyciem jej w <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Without a public setter, an attached property cannot be set in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax.</source>
          <target state="translated">Bez publicznej metody ustawiającej właściwości dołączonej nie można ustawić w <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> składni.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Aby uzyskać więcej informacji dotyczących rejestracji właściwości zależności, zobacz <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Use RegisterAttached for Value-inheriting Dependency Properties</source>
          <target state="translated">Użyj RegisterAttached dziedziczenie wartość właściwości zależności</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>One particular scenario for registering a dependency property as attached instead of <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> is to support property value inheritance.</source>
          <target state="translated">Jednego scenariusza rejestrowania właściwości zależności jako dołączony zamiast <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> służy do obsługi dziedziczenie wartości właściwości.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>You should register value-inheriting dependency properties with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set* static methods to provide true attached property support accessors.</source>
          <target state="translated">Należy zarejestrować dziedziczenie wartość właściwości zależności z <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> nawet wtedy, gdy klasa definiuje otoki metod dostępu właściwości, które udostępniają właściwości zależności, a nawet wtedy, gdy nie zamierzasz ujawnia Get * i Set * statycznej metody w celu zapewnienia true dołączony metod dostępu do właściwości pomocy technicznej.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</source>
          <target state="translated">Mimo że dziedziczenie wartości właściwości mogą być wyświetlane dla właściwości zależności nie dołączony, zachowanie dziedziczenia właściwości nie dołączony do określonych granic elementu w drzewie środowiska uruchomieniowego jest niezdefiniowany.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</source>
          <target state="translated">Rejestrowanie właściwości, jak skutecznie dołączone powoduje dołączona właściwość globalnych właściwości w systemie właściwości i gwarantuje, że dziedziczenie wartości właściwości działa przez wszystkie granice w drzewie elementu.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Always use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> to register properties where you specify <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in the metadata.</source>
          <target state="translated">Zawsze używaj <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> można zarejestrować właściwości, w którym można określić <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> w metadanych.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <bpt id="p1">[</bpt>dziedziczenie wartości właściwości<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Registers a dependency property as a read-only dependency property.</source>
          <target state="translated">Rejestruje właściwości zależności jako właściwość zależności tylko do odczytu.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nazwa właściwości zależności, aby zarejestrować.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The type of the property.</source>
          <target state="translated">Typ właściwości.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Typ właściciela, który rejestruje właściwości zależności.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Metadane właściwości dla właściwości zależności.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registers a read-only dependency property, with the specified property type, owner type, and property metadata.</source>
          <target state="translated">Rejestruje właściwości tylko do odczytu zależności, z określonym typem właściwości, typ właściciela i metadane właściwości.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</source>
          <target state="translated">Klucz właściwości zależności, które mają być używane do wartości pola statycznego tylko do odczytu w klasie, która jest następnie używany do odwołania właściwości zależności.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>This method returns the type <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, whereas <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> returns the type <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Ta metoda zwraca typ <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, podczas gdy <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> zwraca typ <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</source>
          <target state="translated">Zazwyczaj nie zostaną wprowadzone publiczne, klucze, które reprezentują właściwości tylko do odczytu, ponieważ klucze można ustawić wartości właściwości zależności przez wywołanie metody <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</source>
          <target state="translated">Projekt klasy będzie miało wpływ na wymagania dotyczące, ale ogólnie zaleca się ograniczyć dostęp i widoczności dowolnego <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> tylko te części kodu, które są niezbędne, można ustawić tej właściwości zależności w ramach klasy lub aplikacji logiki.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> as a <ph id="ph2">`public static readonly`</ph> field on your class.</source>
          <target state="translated">Zaleca się również ujawniać identyfikatora właściwości zależności dla właściwości tylko do odczytu zależności, w przypadku wystawianego wartość <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> jako <ph id="ph2">`public static readonly`</ph> pole w klasie.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Read-only dependency properties are a fairly typical scenario both in the existing <ph id="ph1">[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]</ph> and for customization scenarios, because other <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> features might require a dependency property even if that property is not intended to be settable by callers.</source>
          <target state="translated">Właściwości tylko do odczytu zależności są dość typowy scenariusz zarówno w istniejących <ph id="ph1">[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]</ph> i dostosowania, ponieważ inne <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> funkcje mogą wymagać właściwości zależności, nawet jeśli tej właściwości nie ma być można ustawić przez obiekty wywołujące.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>You can use the value of a read-only dependency property as the basis for other property system operations that take a dependency property, such as basing a <ph id="ph1">&lt;xref:System.Windows.Trigger&gt;</ph> on the dependency property in a style.</source>
          <target state="translated">Możesz użyć wartości właściwości tylko do odczytu zależności na podstawie innych operacji system właściwości, które przyjmują właściwość zależności, takich jak utworzenie <ph id="ph1">&lt;xref:System.Windows.Trigger&gt;</ph> we właściwości zależności w stylu.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Aby uzyskać więcej informacji dotyczących rejestracji właściwości zależności, zobacz <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The following example registers an <ph id="ph1">`AquariumSize`</ph> dependency property as read-only.</source>
          <target state="translated">Poniższy przykład rejestruje <ph id="ph1">`AquariumSize`</ph> właściwości zależności jako tylko do odczytu.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The example defines <ph id="ph1">`AquariumSizeKey`</ph> as an internal key (so that other classes in the assembly could override metadata) and exposes the dependency property identifier based on that key as <ph id="ph2">`AquariumSizeProperty`</ph>.</source>
          <target state="translated">W przykładzie zdefiniowano <ph id="ph1">`AquariumSizeKey`</ph> jako klucz wewnętrzny (aby klasy w zestawie można zastąpić metadanych) i ujawnia identyfikatora właściwości zależności na podstawie tego klucza jako <ph id="ph2">`AquariumSizeProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Also, a wrapper is created for <ph id="ph1">`AquariumSize`</ph>, with only a get accessor.</source>
          <target state="translated">Ponadto otoka jest tworzona dla <ph id="ph1">`AquariumSize`</ph>, z metodą dostępu get.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nazwa właściwości zależności, aby zarejestrować.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The type of the property.</source>
          <target state="translated">Typ właściwości.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Typ właściciela, który rejestruje właściwości zależności.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Metadane właściwości dla właściwości zależności.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</source>
          <target state="translated">Odwołanie do utworzonych przez użytkownika wywołanie zwrotne, które należy wykonać wszelkie niestandardowego sprawdzania poprawności wartości właściwości zależności poza typowy Typ weryfikacji.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registers a read-only dependency property, with the specified property type, owner type, property metadata, and a validation callback.</source>
          <target state="translated">Rejestruje właściwości tylko do odczytu zależności, z określonym typem właściwości, typ właściciela metadanych właściwości i wywołanie zwrotne weryfikacji.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</source>
          <target state="translated">Klucz właściwości zależności, które mają być używane do wartości pola statycznego tylko do odczytu w klasie, która jest następnie używany do odwołać później właściwości zależności.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>This method returns the type <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, whereas <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> returns the type <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Ta metoda zwraca typ <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, podczas gdy <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> zwraca typ <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</source>
          <target state="translated">Zazwyczaj nie zostaną wprowadzone publiczne, klucze, które reprezentują właściwości tylko do odczytu, ponieważ klucze można ustawić wartości właściwości zależności przez wywołanie metody <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</source>
          <target state="translated">Projekt klasy będzie miało wpływ na wymagania dotyczące, ale ogólnie zaleca się ograniczyć dostęp i widoczności dowolnego <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> tylko te części kodu, które są niezbędne, można ustawić tej właściwości zależności w ramach klasy lub aplikacji logiki.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> as a <ph id="ph2">`public static readonly`</ph> field on your class.</source>
          <target state="translated">Zaleca się również ujawniać identyfikatora właściwości zależności dla właściwości tylko do odczytu zależności, w przypadku wystawianego wartość <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> jako <ph id="ph2">`public static readonly`</ph> pole w klasie.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Read-only dependency properties are a fairly typical scenario.</source>
          <target state="translated">Właściwości tylko do odczytu zależności są dość typowy scenariusz.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>You can use the value of a read-only dependency property as the basis for other property system operations that take a dependency property, such as basing a <ph id="ph1">&lt;xref:System.Windows.Trigger&gt;</ph> on the dependency property in a style.</source>
          <target state="translated">Możesz użyć wartości właściwości tylko do odczytu zależności na podstawie innych operacji system właściwości, które przyjmują właściwość zależności, takich jak utworzenie <ph id="ph1">&lt;xref:System.Windows.Trigger&gt;</ph> we właściwości zależności w stylu.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Aby uzyskać więcej informacji dotyczących rejestracji właściwości zależności, zobacz <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Validation on a read-only dependency property might be less important.</source>
          <target state="translated">Sprawdzanie poprawności właściwości tylko do odczytu zależności może być mniej ważne.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The nonpublic access level you specify for the key reduces the likelihood for arbitrary invalid input.</source>
          <target state="translated">Poziom dostępu niepubliczne, które określisz klucza zmniejsza prawdopodobieństwo dla dowolnego nieprawidłowe dane wejściowe.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.ToString">
          <source>Returns the string representation of the dependency property.</source>
          <target state="translated">Zwraca reprezentację ciągu właściwości zależności.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.ToString">
          <source>The string representation of the dependency property.</source>
          <target state="translated">Reprezentacja ciągu właściwości zależności.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.ToString">
          <source>This implementation returns the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph> property value.</source>
          <target state="translated">Ta implementacja zwraca <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph> wartości właściwości.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>Specifies a static value that is used by the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> property system rather than <ph id="ph2">&lt;see langword="null" /&gt;</ph> to indicate that the property exists, but does not have its value set by the property system.</source>
          <target state="translated">Określa wartość statyczną, który jest używany przez <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> właściwości systemu zamiast <ph id="ph2">&lt;see langword="null" /&gt;</ph> aby wskazać, że właściwość istnieje, ale nie ma jej wartość właściwości systemu.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> is a sentinel value that is used for scenarios where the <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> property system is unable to determine a requested <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> jest wartością wartownik, która jest używana w scenariuszach, gdzie <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> właściwości system nie mógł określić zażądano <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> wartość.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> is used rather than <ph id="ph2">`null`</ph>, because <ph id="ph3">`null`</ph> could be a valid property value, as well as a valid (and frequently used) <ph id="ph4">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> jest używany zamiast <ph id="ph2">`null`</ph>, ponieważ <ph id="ph3">`null`</ph> może mieć prawidłową wartość właściwości, a także prawidłowy (i często używane) <ph id="ph4">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> is never returned out of <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> nigdy nie jest zwracana z <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>When you call <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType&gt;</ph> on a dependency property on a <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> instance, one of the following applies:</source>
          <target state="translated">Podczas wywoływania <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType&gt;</ph> we właściwości zależności na <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> wystąpienia, jedno z następujących dotyczy:</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>A dependency property has a default value established in metadata and that value is returned.</source>
          <target state="translated">Właściwość dependency ma wartość domyślną w metadanych i ta wartość jest zwracana.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>This value might come from <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</source>
          <target state="translated">Ta wartość może pochodzić z <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>Some other value was established by the property system, and the default value is no longer relevant.</source>
          <target state="translated">Wartość zostało ustanowione przez właściwości systemu, a wartość domyślna jest już nieaktualny.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Value Precedence<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <bpt id="p1">[</bpt>pierwszeństwo wartość właściwości zależności<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>Setting a <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> is specifically disallowed.</source>
          <target state="translated">Ustawienie <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> z <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> w szczególności jest niedozwolone.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType&gt;</ph> returns <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> when the requested property has not been locally set.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType&gt;</ph> Zwraca <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> gdy żądana właściwość nie została lokalnie ustawiona.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has a special meaning when used as the return value of a <ph id="ph2">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> ma specjalnego znaczenia, gdy jest używany jako wartość zwracaną <ph id="ph2">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Callbacks and Validation<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <bpt id="p1">[</bpt>wywołania zwrotne właściwości zależności i sprawdzania poprawności<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>If you are binding to a database, note that <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> is not equivalent to <ph id="ph2">&lt;xref:System.DBNull.Value&gt;</ph>, in a similar way to how <ph id="ph3">&lt;xref:System.DBNull.Value&gt;</ph> is not equivalent to a true null.</source>
          <target state="translated">Są wiązane z bazą danych, należy pamiętać, że <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> nie jest odpowiednikiem <ph id="ph2">&lt;xref:System.DBNull.Value&gt;</ph>, w podobny sposób jak <ph id="ph3">&lt;xref:System.DBNull.Value&gt;</ph> nie jest równoważna wartości true wartość null.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>Gets the value validation callback for the dependency property.</source>
          <target state="translated">Pobiera wywołanie zwrotne weryfikacji wartości dla właściwości zależności.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>The value validation callback for this dependency property, as provided for the <ph id="ph1">&lt;paramref name="validateValueCallback" /&gt;</ph> parameter in the original dependency property registration.</source>
          <target state="translated">Wywołanie zwrotne weryfikacji wartość dla tej właściwości zależności, zgodnie z <ph id="ph1">&lt;paramref name="validateValueCallback" /&gt;</ph> parametru w pierwotnej rejestracji właściwości zależności.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>This property will contain <ph id="ph1">`null`</ph> for any dependency property with no registered validation callback.</source>
          <target state="translated">Ta właściwość będzie zawierać <ph id="ph1">`null`</ph> dla każdej właściwości zależności, bez sprawdzania poprawności w zarejestrowany wywołania zwrotnego.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>Validate value callbacks must act in a static sense: validation applied through the <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> cannot determine whether the provided value is valid for any particular instance.</source>
          <target state="translated">Zweryfikować wartości wywołania zwrotne musi działać w statycznej znaczeniu: Sprawdzanie poprawności stosowane przy użyciu <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> nie może określić, czy podana wartość jest nieprawidłowa dla dowolne wystąpienie.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>The callback can only determine whether all objects that possess the dependency property should or should not accept the provided value as valid.</source>
          <target state="translated">Wywołania zwrotnego tylko można określić, czy wszystkie obiekty, które posiadają właściwości zależności powinien lub nie powinien akceptować podanej wartości jako prawidłowy.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>If you need to perform validation that relies on knowing the values of other dependency properties on a particular instance, use a <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> instead.</source>
          <target state="translated">Jeśli potrzebujesz sprawdzania poprawności opartym na wiedzy o wartości innych właściwości zależności na konkretnym wystąpieniu, użyj <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> zamiast tego.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>The <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> is registered as part of dependency property metadata, rather than directly within the dependency property identifier.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> Jest zarejestrowany w ramach metadanych właściwości zależności, a nie bezpośrednio z poziomu identyfikatora właściwości zależności.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Callbacks and Validation<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <bpt id="p1">[</bpt>wywołania zwrotne właściwości zależności i sprawdzania poprawności<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>
<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata><Meta Name="ms.openlocfilehash" Value="21210545d8206e6e4e474c2b2e8040e528891f8a" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69434647" /></Metadata><TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <TypeSignature Language="F#" Value="type DependencyProperty = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje właściwość, którą można ustawić za pomocą metod, takich jak style, powiązanie danych, animacja i dziedziczenie.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Program <xref:System.Windows.DependencyProperty> A obsługuje następujące możliwości w [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]programie:  
  
-   Właściwość można ustawić w stylu. Aby uzyskać więcej informacji, zobacz [Style i tworzenia szablonów](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
-   Właściwość można ustawić za pomocą powiązania danych. Aby uzyskać więcej informacji na temat właściwości zależności powiązań danych [, zobacz How to: Powiąż właściwości dwóch kontrolek](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md).  
  
-   Właściwość można ustawić z odwołaniem do zasobu dynamicznego. Aby uzyskać więcej informacji, zobacz [zasoby XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
-   Właściwość może dziedziczyć swoją wartość automatycznie z elementu nadrzędnego w drzewie elementów. Aby uzyskać więcej informacji, zobacz [dziedziczenie wartości właściwości](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
-   Właściwość można animować. Aby uzyskać więcej informacji, zobacz [Omówienie animacji](~/docs/framework/wpf/graphics-multimedia/animation-overview.md).  
  
-   Właściwość może raportować, kiedy została zmieniona Poprzednia wartość właściwości, a wartość właściwości może być wymuszona. Aby uzyskać więcej informacji, zobacz [wywołania zwrotne właściwości zależności i walidacja](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
-   Właściwość raportuje informacje do [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], na przykład czy zmiana wartości właściwości powinna wymagać od systemu układu przetworzenia wizualizacji dla elementu.  
  
-   Właściwość otrzymuje obsługę w [!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)].  Na przykład właściwość można edytować w oknie **Właściwości** .  
  
 Aby dowiedzieć się więcej o właściwościach zależności, zobacz [Omówienie właściwości zależności](~/docs/framework/wpf/advanced/dependency-properties-overview.md). Jeśli chcesz, aby właściwości typów niestandardowych obsługiwały możliwości z powyższej listy, należy utworzyć właściwość zależności.  Aby dowiedzieć się, jak utworzyć niestandardowe właściwości zależności, zobacz [niestandardowe właściwości zależności](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
 Dołączona właściwość jest właściwością, która umożliwia każdemu obiektowi zgłaszanie informacji do typu, który definiuje załączoną właściwość. W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]programie każdy typ, który dziedziczy <xref:System.Windows.DependencyObject> z, może korzystać z dołączonej właściwości niezależnie od tego, czy typ dziedziczy z typu, który definiuje właściwość. Dołączona właściwość jest funkcją [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] języka.  Aby ustawić dołączoną właściwość w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], użyj elementu *OwnerType*. *Składnia propertyName* . Przykładem dołączonej właściwości jest <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> właściwość. Jeśli chcesz utworzyć właściwość, która może być używana dla wszystkich <xref:System.Windows.DependencyObject> typów, należy utworzyć dołączoną właściwość. Aby dowiedzieć się więcej o dołączanych właściwościach, w tym o sposobie ich tworzenia, zobacz [Omówienie dołączanych właściwości](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```xaml 
<object property="dependencyPropertyName"/>  
```

—lub—

```xaml
<object property="ownerType.dependencyPropertyName"/>  
```

—lub—

```xaml
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 `dependencyPropertyName`  
 Ciąg określający <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType> pożądaną właściwość zależności. Może to być poprzedzone prefiksem przestrzeni nazw XML, jeśli właściwość nie znajduje się w domyślnej przestrzeni nazw XML (Aby uzyskać szczegółowe informacje, zobacz sekcję [przestrzenie nazw XAML i mapowanie przestrzeni nazw dla WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)).  
  
 `ownerType`.`dependencyPropertyName`  
 Ciąg określający typ właściciela właściwości zależności, kropki (.), a następnie <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>. `ownerType`może być również poprzedzony prefiksem przestrzeni nazw XML. To użycie jest szczególnie powiązane ze stylami i szablonami, w których właściciel właściwości zależności musi być określony dla kontekstu analizy, ponieważ `TargetType` nie jest jeszcze znany. Aby uzyskać więcej informacji, zobacz [Style i tworzenia szablonów](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
 `attachedPropertyOwnerType` *.* `attachedPropertyName`  
 Ciąg określający właściciela dołączonej właściwości, kropkę (.), a następnie nazwę dołączonej właściwości. `attachedPropertyOwnerType`może być również poprzedzony prefiksem przestrzeni nazw XML.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje inny typ jako właściciela właściwości zależności, która została już zarejestrowana w typie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner ownerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">Typ, który ma zostać dodany jako właściciel tej właściwości zależności.</param>
        <summary>Dodaje inny typ jako właściciela właściwości zależności, która została już zarejestrowana.</summary>
        <returns>Odwołanie do oryginalnego <see cref="T:System.Windows.DependencyProperty" /> identyfikatora, który identyfikuje właściwość zależności. Ten identyfikator powinien być narażony przez Dodawanie klasy jako <see langword="public static readonly" /> pole.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia systemowi właściwości rozpoznawanie właściwości zależności w typie, który nie zarejestrował wcześniej konkretnej właściwości zależności.  
  
 <xref:System.Windows.DependencyProperty.AddOwner%2A> Zwykle jest używany do dodawania właściwości zależności do klas, które nie uwidaczniają już właściwości zależności za pomocą dziedziczenia klasy zarządzanej (dziedziczenie klas mogłoby spowodować dziedziczenie właściwości otoki przez klasę pochodną i w ten sposób zapewnia ogólne elementy członkowskie — dostęp do tabeli do właściwości zależności. <xref:System.Windows.DependencyProperty.AddOwner%2A>umożliwia systemowi właściwości rozpoznawanie właściwości zależności w typie, który nie zarejestrował właściwości zależności.  
  
 Ta sygnatura nie zezwala na określanie metadanych.  W przypadku korzystania z tej metody metadane są generowane automatycznie dla nowego <xref:System.Windows.DependencyProperty> i jego typu właściciela. Generowane automatycznie metadane są wynikiem scalonych metadanych ze wszystkich typów podstawowych, które mają zdefiniowaną tę właściwość. Jeśli żadne scalone metadane nie są dostępne, zostaną użyte domyślne metadane dla właściwości. Jeśli właściwość jest zarejestrowana przy użyciu <xref:System.Windows.DependencyProperty.RegisterAttached%2A> metody, metadane domyślne są takie same jak metadane, które są tworzone, gdy <xref:System.Windows.DependencyProperty.RegisterAttached%2A> została wywołana. W przeciwnym razie <xref:System.Windows.PropertyMetadata.DefaultValue%2A> <xref:System.Windows.PropertyMetadata> `null`obiekt jest tworzony z właściwością ustawioną na wartość domyślną typu właściwości, a wszystkie inne właściwości mają ustawioną wartość. <xref:System.Windows.PropertyMetadata> Użyj podpisu <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> , jeśli chcesz podać metadane dla wersji właściwości zależności dodanej do podanego typu.  
  
 Wartość zwracana przez tę metodę jest zwykle używana do deklarowania i uwidaczniania właściwości zależności przez zapisanie identyfikatora właściwości zależności. Identyfikator zapewnia dostęp do właściwości zależności, jeśli chcesz wywołać system [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] właściwości dla właściwości zależności, szczególnie, gdy istnieje ona w klasie dodawania właściciela. Aby wskazać podobną funkcję, należy użyć tej samej nazwy właściwości dla oryginalnego właściciela i dodanego właściciela. Należy użyć <xref:System.Windows.DependencyProperty> wartości <xref:System.Windows.DependencyProperty.AddOwner%2A> zwracanej przez metodę w celu zdefiniowania identyfikatora właściwości zależności, a także zadeklarować [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] otoki właściwości dla właściwości zależności, które są dodawane do typów przy użyciu <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 Zalecana powyżej [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]Metoda jest używana podczas tworzenia właściwości zależności, które są zadeklarowane w ramach. <xref:System.Windows.DependencyProperty.AddOwner%2A> Na przykład zarówno <xref:System.Windows.Controls.Border> , jak <xref:System.Windows.Controls.Control> i definiować `BorderBrush` właściwość zależności, która ma podobną funkcjonalność. <xref:System.Windows.Controls.Control>definiuje jej `BorderBrush` właściwość do systemu właściwości przez wywołanie <xref:System.Windows.DependencyProperty.AddOwner%2A> na podstawie pierwotnego właściciela <xref:System.Windows.Controls.Border> i zarejestrowanej <xref:System.Windows.Controls.Border.BorderBrushProperty> właściwości zależności identyfikator. Wartość zwracana jest następnie używana do ustanowienia nowego pola statycznego <xref:System.Windows.DependencyProperty> (<xref:System.Windows.Controls.Control.BorderBrushProperty>) dla tej `BorderBrush` właściwości na dodanym właścicielu, a także otoki właściwości. <xref:System.Windows.DependencyProperty.AddOwner%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner (ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">Typ, który ma zostać dodany jako właściciel tej właściwości zależności.</param>
        <param name="typeMetadata">Metadane, które kwalifikują właściwość zależności, tak jak istnieje w podanym typie.</param>
        <summary>Dodaje inny typ jako właściciela właściwości zależności, która została już zarejestrowana, dostarczając metadane właściwości zależności dla właściwości zależności, która będzie znajdować się w podanym typie właściciela.</summary>
        <returns>Odwołanie do oryginalnego <see cref="T:System.Windows.DependencyProperty" /> identyfikatora, który identyfikuje właściwość zależności. Ten identyfikator powinien być narażony przez Dodawanie klasy jako <see langword="public static readonly" /> pole.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia systemowi właściwości rozpoznawanie właściwości zależności w typie, który nie zarejestrował wcześniej konkretnej właściwości zależności.  
  
 Wartość zwracana przez tę metodę jest używana do deklarowania i uwidaczniania właściwości zależności, szczególnie w przypadku, gdy istnieje ona w klasie Dodaj właściciela. Ogólnie rzecz biorąc, należy użyć tej samej nazwy właściwości dla oryginalnego właściciela i dodanego właściciela, aby wskazać podobną funkcjonalność. Dobrym sposobem jest uwidocznienie identyfikatorów, a także nowych [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] otok właściwości, dla właściwości zależności, które są dodawane do typów przy użyciu. <xref:System.Windows.DependencyProperty.AddOwner%2A>  
  
 Zalecana powyżej [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]metodologia jest używana podczas tworzenia deklaracji zadeklarowanej w ramach. <xref:System.Windows.DependencyProperty.AddOwner%2A> Na przykład zarówno <xref:System.Windows.Controls.Border> , jak <xref:System.Windows.Controls.Control> i definiować `BorderBrush` właściwość zależności, która ma podobną funkcjonalność. <xref:System.Windows.Controls.Control>definiuje jej `BorderBrush` właściwość do systemu właściwości, wywołując <xref:System.Windows.DependencyProperty.AddOwner%2A> dla oryginalnego właściciela <xref:System.Windows.Controls.Border> i zarejestrowaną <xref:System.Windows.Controls.Border.BorderBrushProperty> właściwość zależności identyfikator. Wartość zwracana jest następnie używana do ustanowienia pola statycznego <xref:System.Windows.DependencyProperty> (<xref:System.Windows.Controls.Control.BorderBrushProperty>) dla tej `BorderBrush` właściwości na dodanym właścicielu, a także otoka właściwości. <xref:System.Windows.DependencyProperty.AddOwner%2A>  
  
 Identyfikator właściwości zależności dodanego właściciela powinien być używany w przypadku operacji takich <xref:System.Windows.DependencyObject.GetValue%2A>jak. Jednak operacje specyficzne dla typu obejmujące zarówno typy, jak i wystąpienia klasy, które zostały dodane jako właściciel z różnymi metadanymi, będą nadal zwracały oczekiwane wyniki, nawet jeśli oryginalny (nie dodany właściciel) identyfikator właściwości zależności jest określony w wywołania metod takich jak <xref:System.Windows.DependencyObject.GetValue%2A> lub. <xref:System.Windows.DependencyProperty.GetMetadata%2A> Metadane dodawanego właściciela to perpetuated przez <xref:System.Windows.DependencyProperty.AddOwner%2A> wywołanie, które nie muszą być odwoływane wyłącznie przez Dodawanie pola identyfikatora klasy właściciela. Niemniej jednak dobrym sposobem uwidocznienia identyfikatora, a także nowych [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] otok właściwości, dla właściwości zależności, które są dodawane do typów przy użyciu <xref:System.Windows.DependencyProperty.AddOwner%2A>, ponieważ Niewykonanie tej [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] czynności powoduje utworzenie różnic między i [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] reprezentacje właściwości.  
  
 Podane metadane są scalane z metadanymi właściwości dla właściwości zależności, ponieważ istnieją one w podstawowym właścicielu. Wszystkie cechy, które zostały określone w oryginalnych metadanych podstawowych, zostaną zachowane. Tylko te cechy, które zostały odpowiednio zmienione w nowych metadanych, przesłonią charakterystykę podstawowych metadanych. Niektóre cechy, takie jak <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, są zastępowane, jeśli zostały określone w nowych metadanych. Inne, takie jak <xref:System.Windows.PropertyChangedCallback>, są łączone. Ostatecznie zachowanie scalania zależy od typu metadanych właściwości używanego do przesłonięcia, więc zachowanie opisane tutaj dotyczy istniejących klas metadanych właściwości używanych przez [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] właściwości zależności. Aby uzyskać szczegółowe informacje, zobacz metadane [właściwości zależności](~/docs/framework/wpf/advanced/dependency-property-metadata.md) i [metadane właściwości struktury](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMetadata : System.Windows.PropertyMetadata" Usage="System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślne metadane właściwości zależności.</summary>
        <value>Domyślne metadane właściwości zależności.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metadane domyślne to metadane właściwości, które są dostępne dla danego obiektu lub obiektu typu pochodnego, w przypadku których nie dostarczono metadanych alternatywnych przez jawne <xref:System.Windows.DependencyProperty.Register%2A> lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> wywołanie.  
  
 Jeśli oryginalny właściciel zastosował metadane do pierwszego <xref:System.Windows.DependencyProperty.Register%2A> wywołania, które ustanowił właściwość zależności, to metadane są zwracane jako. <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>  
  
 Jeśli w oryginalnym <xref:System.Windows.DependencyProperty.Register%2A> wywołaniu nie zastosowano żadnych metadanych, domyślne metadane są generowane <xref:System.Windows.DependencyProperty.Register%2A> w wywołaniu i ta <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>wartość jest zwracana jako.  
  
 Głównym celem posiadania domyślnych metadanych skojarzonych z obiektem <xref:System.Windows.DependencyProperty> jest podanie wartości domyślnej dla tej właściwości w dowolnym <xref:System.Windows.DependencyObject> lub typie pochodnym.  
  
 W przypadku niedołączonych właściwości Typ metadanych zwracany przez tę właściwość nie może być rzutowany na typy <xref:System.Windows.PropertyMetadata> pochodne typu, nawet jeśli właściwość została pierwotnie zarejestrowana przy użyciu pochodnego typu metadanych. Jeśli chcesz, aby pierwotnie zarejestrowane metadane z uwzględnieniem oryginalnego, prawdopodobnie pochodnego typu <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29> metadanych, wywołaj zamiast tego, przekazując oryginalny typ rejestrowania jako parametr.  
  
 W przypadku dołączonych właściwości Typ metadanych zwracanych przez tę właściwość będzie zgodny z typem podanym w oryginalnej <xref:System.Windows.DependencyProperty.RegisterAttached%2A> metodzie rejestracji.  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyProperty.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla tego <see cref="T:System.Windows.DependencyProperty" />elementu.</summary>
        <returns>Kod skrótu dla tego <see cref="T:System.Windows.DependencyProperty" />elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 System właściwości używa własnego identyfikatora <xref:System.Windows.DependencyProperty.GlobalIndex%2A>unikatowego, a wartość tej właściwości jest zwracana przez. <xref:System.Windows.DependencyProperty.GetHashCode%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca metadane skojarzone z tą właściwością zależności, ponieważ istnieje dla określonego typu. Może to być typ, w którym właściwość zależności została po raz pierwszy zarejestrowana, do której został dodany później, lub typu, w którym właściwość zależności została uzyskana przez dziedziczenie, ale metadane zostały zasłonięte.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : Type -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata forType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">Konkretny typ, z którego mają zostać pobrane metadane właściwości zależności.</param>
        <summary>Zwraca metadane dla tej właściwości zależności, która istnieje w określonym istniejącym typie.</summary>
        <returns>Obiekt metadanych właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określenie typu lub odwołania do obiektu, który ma być używany jako typ, jest konieczne, ponieważ metadane mogą się różnić od oryginalnej rejestracji z <xref:System.Windows.DependencyProperty.AddOwner%2A> powodu <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> lub wywołań, które zmieniają metadane właściwości zależności, tak jak w typie.  
  
   
  
## Examples  
 Poniższy przykład pobiera metadane dla właściwości zależności na podstawie jej typu. Typ jest uzyskiwany za pomocą `typeof` operatora.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObject -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Obiekt zależności, który jest sprawdzany dla typu, aby określić, która wersja właściwości zależności powinna pochodzić z metadanych.</param>
        <summary>Zwraca metadane dla tej właściwości zależności, która istnieje w określonym wystąpieniu obiektu.</summary>
        <returns>Obiekt metadanych właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określenie typu lub odwołania do obiektu jest konieczne, ponieważ metadane danej właściwości zależności mogą się różnić od oryginalnej rejestracji z powodu <xref:System.Windows.DependencyProperty.AddOwner%2A> lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> wywołań, które mogą udoskonalać metadane właściwości, ponieważ istnieją one na Wprowadź.  
  
 Podczas żądania metadanych właściwości w oparciu o wystąpienie, wystarczy tylko przekazać wystąpienie, aby można było oszacować jego typ wewnętrznie. Metadane właściwości zależności nie różnią się w zależności od wystąpienia; jest on zawsze spójny dla każdej kombinacji właściwości typu.  
  
   
  
## Examples  
 Poniższy przykład pobiera metadane dla właściwości zależności w oparciu o określone <xref:System.Windows.DependencyObject> wystąpienie.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObjectType -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObjectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">Konkretny obiekt, który rejestruje typ obiektu zależności, z którego żądane są metadane właściwości zależności.</param>
        <summary>Zwraca metadane dla tej właściwości zależności, która istnieje w określonym typie.</summary>
        <returns>Obiekt metadanych właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określenie typu lub odwołania do obiektu jest konieczne, ponieważ metadane danej właściwości zależności mogą się różnić od oryginalnej rejestracji z powodu <xref:System.Windows.DependencyProperty.AddOwner%2A> lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> wywołań, które mogą udoskonalać metadane właściwości, ponieważ istnieją one na Wprowadź.  
  
   
  
## Examples  
 Poniższy przykład pobiera metadane dla właściwości zależności na podstawie jej <xref:System.Windows.DependencyObjectType>.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalIndex : int" Usage="System.Windows.DependencyProperty.GlobalIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wewnętrznie wygenerowaną wartość, która jednoznacznie identyfikuje właściwość zależności.</summary>
        <value>Unikatowy identyfikator liczbowy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość jest liczbą całkowitą, a nie globalnie unikatowym identyfikatorem (GUID). Ogólnie używanie tej wartości indeksu nie jest wymagane i nie ma dostępu do indeksu do tabel wszystkich właściwości zależności. W przypadku właściwości zależności należy odwoływać się do nich pola identyfikatorów.  
  
 <xref:System.Windows.DependencyProperty.GlobalIndex%2A>jest używany wewnętrznie do szybszego dostępu do struktur danych, które <xref:System.Windows.DependencyProperty.GlobalIndex%2A> korzystają z indeksu tablicowego opartego na zero. Podobne użycie może mieć aplikacje dla projektantów lub narzędzi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidType : obj -&gt; bool" Usage="dependencyProperty.IsValidType value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do sprawdzenia.</param>
        <summary>Określa, czy określona wartość jest akceptowalna dla tego typu właściwości zależności, sprawdzana względem typu właściwości podanego w oryginalnej rejestracji właściwości zależności.</summary>
        <returns><see langword="true" />Jeśli określona wartość jest zarejestrowanym typem właściwości lub akceptowalnym typem pochodnym; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość `null` jest prawidłowym typem dla właściwości zależności typu odwołania lub <xref:System.Nullable%601> dla właściwości zależności i zwróci `true` się w tych przypadkach. W przypadkach, gdy właściwość dependency nie jest odwołaniem ani <xref:System.Nullable%601> typem, <xref:System.Windows.DependencyProperty.IsValidType%2A> program zwróci `false` wartość null zamiast zgłosić wyjątek.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Windows.DependencyProperty.IsValidType%2A> jako sprawdzenie przed wywołaniem <xref:System.Windows.DependencyObject.SetValue%2A> właściwości zależności.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidValue : obj -&gt; bool" Usage="dependencyProperty.IsValidValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do sprawdzenia.</param>
        <summary>Określa, czy podana wartość jest akceptowana dla typu właściwości za pomocą podstawowego sprawdzania typów, a także może być w dozwolonym zakresie wartości dla tego typu.</summary>
        <returns><see langword="true" />Jeśli wartość jest akceptowalna i jest prawidłowym typem lub typem pochodnym; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla właściwości zależności dozwolony zakres wartości dla tego typu może być określony za pomocą <xref:System.Windows.ValidateValueCallback> , który jest dostępny w rejestracji właściwości zależności.  
  
 Ta metoda wywołuje <xref:System.Windows.DependencyProperty.IsValidType%2A> wewnętrznie. Jeśli dana właściwość zależności ma wartość nie <xref:System.Windows.ValidateValueCallback>, wywołanie tej metody jest efektywnie równoważne wywołaniu. <xref:System.Windows.DependencyProperty.IsValidType%2A> Jeśli właściwość dependency ma <xref:System.Windows.ValidateValueCallback>wartość, a w przypadku <xref:System.Windows.DependencyProperty.IsValidType%2A> zwrócenia `true`wartości zwrócona będzie jako zaimplementowana w wywołaniu zwrotnym.  
  
 Wartość null jest prawidłową wartością dla właściwości zależności typu odwołania lub dla <xref:System.Nullable%601> właściwości zależności, która zwróci `true` te przypadki. W przypadkach, gdy właściwość dependency nie jest odwołaniem ani <xref:System.Nullable%601> typem, <xref:System.Windows.DependencyProperty.IsValidType%2A> program zwróci `false` wartość null zamiast zgłosić wyjątek.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Windows.DependencyProperty.IsValidValue%2A> jako sprawdzenie przed wywołaniem <xref:System.Windows.DependencyObject.SetValue%2A> właściwości zależności.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.DependencyProperty.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę właściwości zależności.</summary>
        <value>Nazwa właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość pobiera nazwę podaną jako `name` parametr podczas rejestracji właściwości zależności. Ta nazwa jest niezmienna i nie może `null` być lub ciągiem pustym. Zduplikowane rejestracje nazw dla tego samego typu właściciela są niedozwolone i będą zgłaszać wyjątek podczas próby zarejestrowania duplikatu.  
  
> [!IMPORTANT]
>  <xref:System.Windows.DependencyProperty.Name%2A> Właściwość zależności musi następować przy użyciu konwencji odpowiadającej nazwie identyfikatora właściwości zależności pomniejszonej o sufiks "Property". Aby uzyskać szczegółowe informacje, zobacz [niestandardowe właściwości zależności](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
   
  
## Examples  
 Poniższy przykład wykonuje zapytania o różne cechy identyfikatora właściwości zależności, w <xref:System.Windows.DependencyProperty.Name%2A>tym.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dostarcza alternatywnych metadanych dla tej właściwości zależności, gdy jest ona obecna w wystąpieniach określonego typu, a także metadanych, które zostały podane w początkowej rejestracji właściwości zależności.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">Typ, w którym ta właściwość zależności jest dziedziczona i gdzie zostaną zastosowane podane alternatywne metadane.</param>
        <param name="typeMetadata">Metadane do zastosowania do właściwości zależności w typie przesłania.</param>
        <summary>Określa alternatywne metadane dla tej właściwości zależności, gdy jest ona obecna w wystąpieniach określonego typu, zastępując metadane, które istniały dla właściwości zależności, ponieważ zostały odziedziczone z typów podstawowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metadane właściwości zależności powinny zostać zastąpione, zanim system właściwości użyje właściwości zależności. Jest to równe czas tworzenia określonych wystąpień przy użyciu klasy, która rejestruje właściwość zależności. Wywołania powinny być wykonywane tylko w konstruktorach statycznych typu, który dostarcza siebie `forType` jako parametr tej metody lub za pomocą podobnego tworzenia wystąpienia. <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> Próba zmiany metadanych po wystąpieniu wystąpienia typu właściciela nie spowoduje wywołania wyjątków, ale spowoduje niespójne zachowania w systemie właściwości.  
  
 Po ustanowieniu metadanych dla konkretnego przesłonięcia klasy pochodnej przy użyciu tej metody, kolejne próby zastąpienia metadanych w tej samej klasie pochodnej spowodują wyjątek.  
  
 Podane metadane są scalane z metadanymi właściwości dla właściwości zależności, ponieważ istnieją one w podstawowym właścicielu. Wszystkie cechy, które zostały określone w oryginalnych metadanych podstawowych, będą utrwalane; tylko te cechy, które zostały odpowiednio zmienione w nowych metadanych, przesłonią charakterystykę podstawowych metadanych. Niektóre cechy, takie <xref:System.Windows.PropertyMetadata.DefaultValue%2A> jak są zastępowane w przypadku określenia w nowych metadanych. Inne, takie jak <xref:System.Windows.PropertyChangedCallback>, są łączone. Ostatecznie zachowanie scalania zależy od typu metadanych właściwości używanego do przesłonięcia, więc zachowanie opisane tutaj dotyczy istniejących klas metadanych właściwości używanych przez [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] właściwości zależności. Aby uzyskać szczegółowe informacje, zobacz metadane [właściwości zależności](~/docs/framework/wpf/advanced/dependency-property-metadata.md) i [metadane właściwości struktury](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę zastąpienia metadanych właściwości zależności tylko do odczytu (nie można wykonać tej operacji przy użyciu tej sygnatury).</exception>
        <exception cref="T:System.ArgumentException">Metadane zostały już ustanowione dla właściwości zależności, która istnieje w podanym typie.</exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata * System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">Typ, w którym ta właściwość zależności jest dziedziczona i gdzie zostaną zastosowane podane alternatywne metadane.</param>
        <param name="typeMetadata">Metadane do zastosowania do właściwości zależności w typie przesłania.</param>
        <param name="key">Klucz dostępu dla właściwości zależności tylko do odczytu.</param>
        <summary>Dostarcza alternatywne metadane dla właściwości zależności tylko do odczytu, gdy jest ona obecna w wystąpieniach określonego typu, zastępując metadane dostarczone w początkowej rejestracji właściwości zależności. Należy przekazać <see cref="T:System.Windows.DependencyPropertyKey" /> właściwość zależności tylko do odczytu, aby uniknąć ponoszenia wyjątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta sygnatura zawiera podstawową implementację metody identyfikatora właściwości zależności tylko do odczytu<xref:System.Windows.DependencyPropertyKey>(). W przypadku zastępowania metadanych dla właściwości zależności odczytu i zapisu Użyj <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>.  
  
 Metadane właściwości zależności powinny zostać zastąpione, zanim system właściwości użyje właściwości zależności. Jest to równe czas tworzenia określonych obiektów dla klasy, która rejestruje właściwość zależności. Wywołania powinny być wykonywane tylko w konstruktorach statycznych typu, który dostarcza siebie `forType` jako parametr tej metody lub za pomocą podobnego tworzenia wystąpienia. <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> Próba zmiany metadanych po wystąpieniu wystąpienia typu właściciela nie spowoduje wywołania wyjątków, ale spowoduje niespójne zachowania w systemie właściwości.  
  
 Po ustanowieniu metadanych dla konkretnego przesłonięcia klasy pochodnej przy użyciu tej metody, kolejne próby zastąpienia metadanych w tej samej klasie pochodnej spowodują wyjątek.  
  
 Podane metadane są scalane z metadanymi właściwości dla właściwości zależności, ponieważ istnieją one w podstawowym właścicielu. Wszystkie cechy, które zostały określone w oryginalnych metadanych podstawowych, będą utrwalane; tylko te cechy, które zostały odpowiednio zmienione w nowych metadanych, przesłonią charakterystykę podstawowych metadanych. Niektóre cechy, takie <xref:System.Windows.PropertyMetadata.DefaultValue%2A> jak są zastępowane w przypadku określenia w nowych metadanych. Inne, takie jak <xref:System.Windows.PropertyChangedCallback>, są łączone. Zachowanie scalania jest zależne od typu metadanych właściwości używanego podczas przesłonięcia. Aby uzyskać szczegółowe informacje, zobacz metadane [właściwości zależności](~/docs/framework/wpf/advanced/dependency-property-metadata.md) i [metadane właściwości struktury](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerType : Type" Usage="System.Windows.DependencyProperty.OwnerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ obiektu, który zarejestrował właściwość zależności z systemem właściwości lub został dodany jako właściciel właściwości.</summary>
        <value>Typ obiektu, który zarejestrował właściwość lub dodany jako właściciel właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość została podana podczas rejestracji właściwości. Właściciel będzie oryginalnym typem <xref:System.Windows.DependencyProperty> rejestrowania w przypadku identyfikatora wygenerowanego <xref:System.Windows.DependencyProperty.Register%2A> na podstawie wywołania lub typu, który został dodany jako właściciel <xref:System.Windows.DependencyProperty> w przypadku identyfikatora wygenerowanego na podstawie <xref:System.Windows.DependencyProperty.AddOwner%2A> wywołania.  
  
 W każdym podanym <xref:System.Windows.DependencyProperty> miejscu jest niezmienne i nie `null` może być prawidłowy <xref:System.Windows.DependencyProperty>. <xref:System.Windows.DependencyProperty.OwnerType%2A>  
  
   
  
## Examples  
 Poniższy przykład pobiera typ właściciela na podstawie identyfikatora `dp`właściwości zależności, a następnie pobiera metadane dla tego samego identyfikatora dla właściciela. Ta operacja jest w <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> `dp`rzeczywistości równoznaczna z wprowadzeniem.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Windows.DependencyProperty.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ, którego właściwość zależności używa dla jej wartości.</summary>
        <value><see cref="T:System.Type" /> Wartość właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość służy do raportowania typu wartości właściwości zadeklarowanej przez oryginalną rejestrację właściwości za pomocą `propertyType` parametru. Podobnie jak, typ właściwości właściwości zależności jest niezmienny po rejestracji. <xref:System.Windows.DependencyProperty.Name%2A>  
  
   
  
## Examples  
 Poniższy przykład wykonuje zapytania o różne cechy identyfikatora właściwości zależności, w <xref:System.Windows.DependencyProperty.PropertyType%2A>tym. Ciąg nazwy typu <xref:System.Windows.DependencyProperty.PropertyType%2A> jest uzyskiwany z zwracanego <xref:System.Type>elementu.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool" Usage="System.Windows.DependencyProperty.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy właściwość zależności identyfikowana przez to <see cref="T:System.Windows.DependencyProperty" /> wystąpienie jest właściwością zależności tylko do odczytu.</summary>
        <value><see langword="true" />Jeśli właściwość zależności jest tylko do odczytu; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości zależności tylko do odczytu są rejestrowane w systemie właściwości przez wywołanie <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> metody zamiast <xref:System.Windows.DependencyProperty.Register%2A> metody. Dołączone właściwości można także zarejestrować jako tylko do odczytu. Zobacz <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.  
  
 Właściwości zależności tylko do odczytu wymagają <xref:System.Windows.DependencyPropertyKey> identyfikatora, a nie <xref:System.Windows.DependencyProperty> identyfikatora do wykonywania operacji na metadanych, takich jak zastępowanie metadanych lub ustawienie wartości. <xref:System.Windows.DependencyProperty> Jeśli uzyskano kolekcję identyfikatorów za pośrednictwem <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> wywołania lub innego [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] , które ujawnia identyfikatory, sprawdź <xref:System.Windows.DependencyProperty.ReadOnly%2A> wartość przed podjęciem próby wywołania <xref:System.Windows.DependencyObject.SetValue%2A> lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> użycia tego elementu Identyfikator właściwości zależności jako parametr wejściowy, aby sprawdzić, czy właściwość zależności, którą reprezentuje identyfikator, nie jest tylko do odczytu. Jeśli wartość <xref:System.Windows.DependencyProperty.ReadOnly%2A> jest `true` we właściwości zależności, nie ma programistycznego sposobu <xref:System.Windows.DependencyPropertyKey> uzyskania odwołania do identyfikatora tej <xref:System.Windows.DependencyProperty> właściwości zależności, z metadanych lub z identyfikatora; identyfikator musi być dostępny jako pole statyczne, aby można było wywołać <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> właściwość zależności tylko do odczytu.  
  
 Podczas tworzenia niestandardowej właściwości zależności i rejestrowania jej jako tylko do odczytu należy zdefiniować tylko metodę dostępu get dla [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] właściwości otoki. W przeciwnym razie Klasa będzie miała mylący model obiektów dla otoki właściwości w porównaniu z dostępem do właściwości zależności. Aby uzyskać szczegółowe informacje, zobacz [właściwości zależności niestandardowych](~/docs/framework/wpf/advanced/custom-dependency-properties.md) lub [właściwości zależności tylko do odczytu](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
   
  
## Examples  
 Poniższy przykład pobiera domyślne metadane i właściwości zależności identyfikatora właściwości z różnych pól właściwości zależności i używa tych informacji do wypełniania tabeli w celu zaimplementowania "przeglądarki metadanych".  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje właściwość zależności.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności do zarejestrowania. Nazwa musi być unikatowa w obrębie przestrzeni nazw rejestracji typu właściciela.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwość zależności.</param>
        <summary>Rejestruje właściwość zależności z określoną nazwą właściwości, typem właściwości i typem właściciela.</summary>
        <returns>Identyfikator właściwości zależności, który powinien zostać użyty do ustawienia wartości <see langword="public static readonly" /> pola w klasie. Ten identyfikator jest następnie używany do odwoływania się do właściwości zależności później, w przypadku operacji, takich jak Ustawianie jej wartości programowo lub uzyskiwanie metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat rejestracji właściwości zależności <xref:System.Windows.DependencyProperty>, zobacz.  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności do zarejestrowania.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwość zależności.</param>
        <param name="typeMetadata">Metadane właściwości dla właściwości zależności.</param>
        <summary>Rejestruje właściwość zależności z określoną nazwą właściwości, typem właściwości, typem właściciela i metadanymi właściwości.</summary>
        <returns>Identyfikator właściwości zależności, który powinien zostać użyty do ustawienia wartości <see langword="public static readonly" /> pola w klasie. Ten identyfikator jest następnie używany do odwoływania się do właściwości zależności później, w przypadku operacji, takich jak Ustawianie jej wartości programowo lub uzyskiwanie metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat rejestracji właściwości zależności <xref:System.Windows.DependencyProperty>, zobacz.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności do zarejestrowania.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwość zależności.</param>
        <param name="typeMetadata">Metadane właściwości dla właściwości zależności.</param>
        <param name="validateValueCallback">Odwołanie do wywołania zwrotnego, które powinno wykonać wszelkie niestandardowe sprawdzanie poprawności wartości właściwości zależności poza typowym sprawdzaniem poprawności typu.</param>
        <summary>Rejestruje właściwość zależności z określoną nazwą właściwości, typem właściwości, typem właściciela, metadanymi właściwości i wywołaniem zwrotnym walidacji wartości właściwości.</summary>
        <returns>Identyfikator właściwości zależności, który powinien zostać użyty do ustawienia wartości <see langword="public static readonly" /> pola w klasie. Ten identyfikator jest następnie używany do odwoływania się do właściwości zależności później, w przypadku operacji, takich jak Ustawianie jej wartości programowo lub uzyskiwanie metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat rejestracji właściwości zależności <xref:System.Windows.DependencyProperty>, zobacz.  
  
   
  
## Examples  
 Poniższy przykład rejestruje właściwość zależności, łącznie z wywołaniem zwrotnym walidacji (definicja wywołania zwrotnego nie jest wyświetlana; Aby uzyskać szczegółowe informacje na temat <xref:System.Windows.ValidateValueCallback>definicji wywołania zwrotnego, zobacz).  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje załączoną właściwość w systemie właściwości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności do zarejestrowania.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwość zależności.</param>
        <summary>Rejestruje załączoną właściwość o określonej nazwie właściwości, typie właściwości i typie właściciela.</summary>
        <returns>Identyfikator właściwości zależności, który powinien zostać użyty do ustawienia wartości <see langword="public static readonly" /> pola w klasie. Ten identyfikator jest następnie używany do odwoływania się do właściwości zależności później, w przypadku operacji, takich jak Ustawianie jej wartości programowo lub uzyskiwanie metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dołączona właściwość jest koncepcji właściwości zdefiniowanej przez [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]implementuje dołączone właściwości jako właściwości zależności. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Ponieważ dołączone właściwości są właściwościami zależności, mogą mieć zastosowane metadane, które mogą być używane przez system właściwości ogólnych dla operacji, takich jak charakterystyki układu raportowania. Aby uzyskać więcej informacji, zobacz [Omówienie dołączonej właściwości](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Aby uzyskać więcej informacji na temat rejestracji właściwości zależności <xref:System.Windows.DependencyProperty>, zobacz.  
  
   
  
## Examples  
 Poniższy przykład rejestruje załączoną właściwość w klasie abstrakcyjnej przy użyciu tej <xref:System.Windows.DependencyProperty.RegisterAttached%2A> sygnatury.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności do zarejestrowania.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwość zależności.</param>
        <param name="defaultMetadata">Metadane właściwości dla właściwości zależności. Może to obejmować wartość domyślną, a także inne cechy.</param>
        <summary>Rejestruje dołączoną właściwość o określonej nazwie właściwości, typie właściwości, typie właściciela i metadanych właściwości.</summary>
        <returns>Identyfikator właściwości zależności, który powinien zostać użyty do ustawienia wartości <see langword="public static readonly" /> pola w klasie. Ten identyfikator jest następnie używany do odwoływania się do właściwości zależności później, w przypadku operacji, takich jak Ustawianie jej wartości programowo lub uzyskiwanie metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dołączona właściwość jest koncepcji właściwości zdefiniowanej przez [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]implementuje dołączone właściwości jako właściwości zależności. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Ponieważ dołączone właściwości są właściwościami zależności, mogą mieć zastosowane metadane, które mogą być używane przez system właściwości ogólnych dla operacji, takich jak charakterystyki układu raportowania. Aby uzyskać więcej informacji, zobacz [Omówienie dołączonej właściwości](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Aby uzyskać więcej informacji na temat rejestracji właściwości zależności <xref:System.Windows.DependencyProperty>, zobacz.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Użyj RegisterAttached dla właściwości zależności dziedziczenia wartości  
 Jednym z określonych scenariuszy rejestrowania właściwości zależności przy użyciu <xref:System.Windows.DependencyProperty.RegisterAttached%2A> polecenia INSTEAD <xref:System.Windows.DependencyProperty.Register%2A> of jest obsługa dziedziczenia wartości właściwości. Należy zarejestrować właściwości <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zależności wartości, nawet jeśli klasa definiuje metody dostępu otoki właściwości, które uwidaczniają właściwość zależności, a nawet jeśli nie zamierzasz uwidocznić funkcji get * i Set * static, aby zapewnić wartość true. metody dostępu do obsługi właściwości.   Chociaż dziedziczenie wartości właściwości może wydawać się niedołączone właściwości zależności, zachowanie dziedziczenia dla niedołączonej właściwości przy użyciu określonych granic elementów w drzewie środowiska uruchomieniowego jest niezdefiniowane. Zarejestrowanie właściwości jako dołączone efektywnie powoduje, że dołączona właściwość jest właściwością globalną do systemu właściwości i zapewnia, że dziedziczenie wartości właściwości działa dla wszystkich granic w drzewie elementów. Zawsze używaj <xref:System.Windows.DependencyProperty.RegisterAttached%2A> do rejestrowania właściwości, które są <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> określone w metadanych. Aby uzyskać więcej informacji, zobacz [dziedziczenie wartości właściwości](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności do zarejestrowania.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwość zależności.</param>
        <param name="defaultMetadata">Metadane właściwości dla właściwości zależności. Może to obejmować wartość domyślną, a także inne cechy.</param>
        <param name="validateValueCallback">Odwołanie do wywołania zwrotnego, które powinno wykonać wszelkie niestandardowe sprawdzanie poprawności wartości właściwości zależności poza typowym sprawdzaniem poprawności typu.</param>
        <summary>Rejestruje załączoną właściwość o określonym typie właściwości, typie właściciela, metadanych właściwości i wywołaniu zwrotnym walidacji wartości właściwości.</summary>
        <returns>Identyfikator właściwości zależności, który powinien zostać użyty do ustawienia wartości <see langword="public static readonly" /> pola w klasie. Ten identyfikator jest następnie używany do odwoływania się do właściwości zależności później, w przypadku operacji, takich jak Ustawianie jej wartości programowo lub uzyskiwanie metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dołączona właściwość jest koncepcji właściwości zdefiniowanej przez [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]implementuje dołączone właściwości jako właściwości zależności. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Ponieważ dołączone właściwości są właściwościami zależności, mogą mieć zastosowane metadane, które mogą być używane przez system właściwości ogólnych dla operacji, takich jak charakterystyki układu raportowania. Aby uzyskać więcej informacji, zobacz [Omówienie dołączonej właściwości](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Aby uzyskać więcej informacji na temat rejestracji właściwości zależności <xref:System.Windows.DependencyProperty>, zobacz.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Użyj RegisterAttached dla właściwości zależności dziedziczenia wartości  
 Jednym z określonych scenariuszy rejestrowania właściwości zależności przy użyciu <xref:System.Windows.DependencyProperty.RegisterAttached%2A> polecenia INSTEAD <xref:System.Windows.DependencyProperty.Register%2A> of jest obsługa dziedziczenia wartości właściwości. Należy zarejestrować właściwości <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zależności wartości, nawet jeśli klasa definiuje metody dostępu otoki właściwości, które uwidaczniają właściwość zależności, a nawet jeśli nie zamierzasz uwidocznić funkcji get * i Set * static, aby zapewnić wartość true. metody dostępu do obsługi właściwości.   Chociaż dziedziczenie wartości właściwości może wydawać się niedołączone właściwości zależności, zachowanie dziedziczenia dla niedołączonej właściwości przy użyciu określonych granic elementów w drzewie środowiska uruchomieniowego jest niezdefiniowane. Zarejestrowanie właściwości jako dołączone efektywnie powoduje, że dołączona właściwość jest właściwością globalną do systemu właściwości i zapewnia, że dziedziczenie wartości właściwości działa dla wszystkich granic w drzewie elementów. Zawsze używaj <xref:System.Windows.DependencyProperty.RegisterAttached%2A> do rejestrowania właściwości, które są <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> określone w metadanych. Aby uzyskać więcej informacji, zobacz [dziedziczenie wartości właściwości](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
   
  
## Examples  
 Poniższy przykład rejestruje załączoną właściwość w klasie abstrakcyjnej przy użyciu tej <xref:System.Windows.DependencyProperty.RegisterAttached%2A> sygnatury. Ta dołączona właściwość jest właściwością typu wyliczenia, a rejestracja dodaje wywołanie zwrotne walidacji, aby sprawdzić, czy podana wartość jest wartością wyliczenia.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje dołączoną właściwość tylko do odczytu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności do zarejestrowania.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwość zależności.</param>
        <param name="defaultMetadata">Metadane właściwości dla właściwości zależności.</param>
        <summary>Rejestruje dołączoną właściwość tylko do odczytu, z określonym typem właściwości, typem właściciela i metadanymi właściwości.</summary>
        <returns>Klucz właściwości zależności, który powinien zostać użyty do ustawienia wartości statycznego pola tylko do odczytu w klasie, która następnie jest używana do późniejszego odwoływania się do właściwości zależności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca typ <xref:System.Windows.DependencyPropertyKey>, podczas gdy <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zwraca typ. <xref:System.Windows.DependencyProperty> Zazwyczaj klucze reprezentujące właściwości tylko do odczytu nie są publiczne, ponieważ klucze mogą służyć do ustawiania wartości właściwości zależności przez wywołanie <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Projekt klasy będzie miał wpływ na wymagania, ale zazwyczaj zaleca się ograniczenie dostępu i widoczności elementów <xref:System.Windows.DependencyPropertyKey> tylko do tych części kodu, które są niezbędne do ustawienia tej właściwości zależności jako części logiki klasy lub aplikacji. Zaleca się również uwidocznienie identyfikatora właściwości zależności dla właściwości zależności tylko do odczytu przez udostępnienie wartości <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> `public static readonly` jako pola w klasie.  
  
 Właściwości dołączone tylko do odczytu są rzadkim scenariuszem, ponieważ podstawowy scenariusz dla dołączonej właściwości jest używany w programie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Bez publicznej metody ustawiającej nie można ustawić dołączonej właściwości w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] składni.  
  
 Aby uzyskać więcej informacji na temat rejestracji właściwości zależności <xref:System.Windows.DependencyProperty>, zobacz.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Użyj RegisterAttached dla właściwości zależności dziedziczenia wartości  
 Jednym z określonych scenariuszy rejestrowania właściwości zależności jako dołączonej jest obsługa dziedziczenia wartości właściwości. Należy zarejestrować właściwości <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zależności wartości, nawet jeśli klasa definiuje metody dostępu otoki właściwości, które uwidaczniają właściwość zależności, a nawet jeśli nie zamierzasz uwidocznić funkcji get * i Set * static, aby zapewnić wartość true. metody dostępu do obsługi właściwości.   Chociaż dziedziczenie wartości właściwości może wydawać się niedołączone właściwości zależności, zachowanie dziedziczenia dla niedołączonej właściwości przy użyciu określonych granic elementów w drzewie środowiska uruchomieniowego jest niezdefiniowane. Zarejestrowanie właściwości jako dołączone efektywnie powoduje, że dołączona właściwość jest właściwością globalną do systemu właściwości i zapewnia, że dziedziczenie wartości właściwości działa dla wszystkich granic w drzewie elementów. Zawsze używaj <xref:System.Windows.DependencyProperty.RegisterAttached%2A> do rejestrowania właściwości, które są <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> określone w metadanych. Aby uzyskać więcej informacji, zobacz [dziedziczenie wartości właściwości](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności do zarejestrowania.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwość zależności.</param>
        <param name="defaultMetadata">Metadane właściwości dla właściwości zależności.</param>
        <param name="validateValueCallback">Odwołanie do wywołania zwrotnego utworzonego przez użytkownika, które powinno wykonać wszelkie niestandardowe sprawdzanie poprawności wartości właściwości zależności poza typowym sprawdzaniem poprawności typu.</param>
        <summary>Rejestruje przyłączoną właściwość tylko do odczytu, z określonym typem właściwości, typem właściciela, metadanymi właściwości i wywołaniem zwrotnym walidacji.</summary>
        <returns>Klucz właściwości zależności, który powinien zostać użyty do ustawienia wartości statycznego pola tylko do odczytu w klasie, która jest następnie używana do odwoływania się do właściwości zależności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca typ <xref:System.Windows.DependencyPropertyKey>, podczas gdy <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zwraca typ. <xref:System.Windows.DependencyProperty> Zazwyczaj klucze reprezentujące typ <xref:System.Windows.DependencyProperty>. Zazwyczaj klucze reprezentujące właściwości tylko do odczytu nie są publiczne, ponieważ klucze mogą służyć do ustawiania wartości właściwości zależności przez wywołanie <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Projekt klasy będzie miał wpływ na wymagania, ale zazwyczaj zaleca się ograniczenie dostępu i widoczności elementów <xref:System.Windows.DependencyPropertyKey> tylko do tych części kodu, które są niezbędne do ustawienia tej właściwości zależności jako części logiki klasy lub aplikacji. Zaleca się również uwidocznienie identyfikatora właściwości zależności dla właściwości zależności tylko do odczytu przez udostępnienie wartości <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> `public static readonly` jako pola w klasie.  
  
 Właściwości dołączone tylko do odczytu są rzadkim scenariuszem, ponieważ podstawowy scenariusz dla dołączonej właściwości jest używany w programie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Bez publicznej metody ustawiającej nie można ustawić dołączonej właściwości w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] składni.  
  
 Aby uzyskać więcej informacji na temat rejestracji właściwości zależności <xref:System.Windows.DependencyProperty>, zobacz.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Użyj RegisterAttached dla właściwości zależności dziedziczenia wartości  
 Jednym z <xref:System.Windows.DependencyProperty.Register%2A> określonych scenariuszy rejestrowania właściwości zależności jako dołączone zamiast jest obsługa dziedziczenia wartości właściwości. Należy zarejestrować właściwości <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zależności wartości, nawet jeśli klasa definiuje metody dostępu otoki właściwości, które uwidaczniają właściwość zależności, a nawet jeśli nie zamierzasz uwidocznić funkcji get * i Set * static, aby zapewnić wartość true. metody dostępu do obsługi właściwości.   Chociaż dziedziczenie wartości właściwości może wydawać się niedołączone właściwości zależności, zachowanie dziedziczenia dla niedołączonej właściwości przy użyciu określonych granic elementów w drzewie środowiska uruchomieniowego jest niezdefiniowane. Zarejestrowanie właściwości jako dołączone efektywnie powoduje, że dołączona właściwość jest właściwością globalną do systemu właściwości i zapewnia, że dziedziczenie wartości właściwości działa dla wszystkich granic w drzewie elementów. Zawsze używaj <xref:System.Windows.DependencyProperty.RegisterAttached%2A> do rejestrowania właściwości, które są <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> określone w metadanych. Aby uzyskać więcej informacji, zobacz [dziedziczenie wartości właściwości](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje właściwość zależności jako właściwość zależności tylko do odczytu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności do zarejestrowania.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwość zależności.</param>
        <param name="typeMetadata">Metadane właściwości dla właściwości zależności.</param>
        <summary>Rejestruje właściwość zależności tylko do odczytu z określonym typem właściwości, typem właściciela i metadanymi właściwości.</summary>
        <returns>Klucz właściwości zależności, który powinien zostać użyty do ustawienia wartości statycznego pola tylko do odczytu w klasie, która jest następnie używana do odwoływania się do właściwości zależności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca typ <xref:System.Windows.DependencyPropertyKey>, podczas gdy <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zwraca typ. <xref:System.Windows.DependencyProperty> Zazwyczaj klucze reprezentujące właściwości tylko do odczytu nie są publiczne, ponieważ klucze mogą służyć do ustawiania wartości właściwości zależności przez wywołanie <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Projekt klasy będzie miał wpływ na wymagania, ale zazwyczaj zaleca się ograniczenie dostępu i widoczności elementów <xref:System.Windows.DependencyPropertyKey> tylko do tych części kodu, które są niezbędne do ustawienia tej właściwości zależności jako części logiki klasy lub aplikacji. Zaleca się również uwidocznienie identyfikatora właściwości zależności dla właściwości zależności tylko do odczytu przez udostępnienie wartości <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> `public static readonly` jako pola w klasie.  
  
 Właściwości zależności tylko do odczytu są dość typowym scenariuszem zarówno w istniejącym [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] , jak i w scenariuszach dostosowywania, ponieważ inne [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] funkcje mogą wymagać właściwości zależności, nawet jeśli ta właściwość nie jest przeznaczona do użycia przez wywołujących. Można użyć wartości właściwości zależności tylko do odczytu jako podstawy dla innych operacji systemu właściwości, które przyjmują właściwość zależności, takich jak bazowa a <xref:System.Windows.Trigger> na właściwości zależności w stylu.  
  
 Aby uzyskać więcej informacji na temat rejestracji właściwości zależności <xref:System.Windows.DependencyProperty>, zobacz.  
  
   
  
## Examples  
 Poniższy przykład rejestruje `AquariumSize` właściwość zależności jako tylko do odczytu. Przykład definiuje `AquariumSizeKey` jako klucz wewnętrzny (tak, że inne klasy w zestawie mogą przesłonić metadane) i uwidacznia identyfikator właściwości zależności na podstawie tego klucza jako `AquariumSizeProperty`. Ponadto otoka jest tworzona dla `AquariumSize`i ma tylko metodę dostępu get.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości zależności do zarejestrowania.</param>
        <param name="propertyType">Typ właściwości.</param>
        <param name="ownerType">Typ właściciela, który rejestruje właściwość zależności.</param>
        <param name="typeMetadata">Metadane właściwości dla właściwości zależności.</param>
        <param name="validateValueCallback">Odwołanie do wywołania zwrotnego utworzonego przez użytkownika, które powinno wykonać wszelkie niestandardowe sprawdzanie poprawności wartości właściwości zależności poza typowym sprawdzaniem poprawności typu.</param>
        <summary>Rejestruje właściwość zależności tylko do odczytu z określonym typem właściwości, typem właściciela, metadanymi właściwości i wywołaniem zwrotnym walidacji.</summary>
        <returns>Klucz właściwości zależności, który powinien zostać użyty do ustawienia wartości statycznego pola tylko do odczytu w klasie, która następnie jest używana do późniejszego odwoływania się do właściwości zależności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca typ <xref:System.Windows.DependencyPropertyKey>, podczas gdy <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zwraca typ. <xref:System.Windows.DependencyProperty> Zazwyczaj klucze reprezentujące właściwości tylko do odczytu nie są publiczne, ponieważ klucze mogą służyć do ustawiania wartości właściwości zależności przez wywołanie <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Projekt klasy będzie miał wpływ na wymagania, ale zazwyczaj zaleca się ograniczenie dostępu i widoczności elementów <xref:System.Windows.DependencyPropertyKey> tylko do tych części kodu, które są niezbędne do ustawienia tej właściwości zależności jako części logiki klasy lub aplikacji. Zaleca się również uwidocznienie identyfikatora właściwości zależności dla właściwości zależności tylko do odczytu przez udostępnienie wartości <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> `public static readonly` jako pola w klasie.  
  
 Właściwości zależności tylko do odczytu są dość typowym scenariuszem. Można użyć wartości właściwości zależności tylko do odczytu jako podstawy dla innych operacji systemu właściwości, które przyjmują właściwość zależności, takich jak bazowa a <xref:System.Windows.Trigger> na właściwości zależności w stylu.  
  
 Aby uzyskać więcej informacji na temat rejestracji właściwości zależności <xref:System.Windows.DependencyProperty>, zobacz.  
  
 Walidacja właściwości zależności tylko do odczytu może być mniej ważna. Poziom dostępu niepublicznego określony dla klucza zmniejsza prawdopodobieństwo wystąpienia nieprawidłowych danych wejściowych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dependencyProperty.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca ciąg reprezentujący właściwość zależności.</summary>
        <returns>Ciąg reprezentujący właściwość zależności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja zwraca <xref:System.Windows.DependencyProperty.Name%2A> wartość właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnsetValue : obj" Usage="System.Windows.DependencyProperty.UnsetValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa wartość statyczną używaną przez [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] system właściwości, <see langword="null" /> a nie wskazuje, że właściwość istnieje, ale nie ma ustawionej wartości przez system właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty.UnsetValue>jest wartością wskaźnikową, która jest używana w scenariuszach, [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] w których system właściwości nie może określić żądanych <xref:System.Windows.DependencyProperty> wartości. <xref:System.Windows.DependencyProperty.UnsetValue>jest używany zamiast `null`, ponieważ `null` może być prawidłową wartością właściwości, a także prawidłowym (i często używanym) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue>nigdy nie jest zwracana z <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>. Po wywołaniu <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType> właściwości zależności <xref:System.Windows.DependencyObject> w wystąpieniu występuje jeden z następujących warunków:  
  
-   Właściwość dependency ma wartość domyślną ustanowioną w metadanych i zwraca wartość. Ta wartość może pochodzić z <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
-   Inna wartość została ustanowiona przez system właściwości, a wartość domyślna nie jest już istotna. Aby uzyskać szczegółowe informacje, zobacz [pierwszeństwo wartości właściwości zależności](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Ustawienie a <xref:System.Windows.PropertyMetadata.DefaultValue%2A> <xref:System.Windows.DependencyProperty.UnsetValue> jest jawnie niedozwolone.  
  
 <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType>zwraca <xref:System.Windows.DependencyProperty.UnsetValue> wartość, jeśli żądana właściwość nie została ustawiona lokalnie.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue>ma specjalne znaczenie, gdy jest używana jako wartość zwracana przez <xref:System.Windows.CoerceValueCallback>. Aby uzyskać szczegółowe informacje, zobacz [wywołania zwrotne właściwości zależności i walidacja](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 Jeśli tworzysz powiązanie z bazą danych, pamiętaj, że <xref:System.Windows.DependencyProperty.UnsetValue> nie jest to <xref:System.DBNull.Value>odpowiednik, w podobny sposób, aby <xref:System.DBNull.Value> nie był odpowiednikiem prawdziwej wartości null.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidateValueCallback : System.Windows.ValidateValueCallback" Usage="System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wywołanie zwrotne walidacji wartości dla właściwości zależności.</summary>
        <value>Wywołanie zwrotne walidacji wartości dla tej właściwości zależności, jak podano dla <paramref name="validateValueCallback" /> parametru w oryginalnej rejestracji właściwości zależności.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość będzie zawierać `null` dla każdej właściwości zależności bez zarejestrowanego wywołania zwrotnego walidacji.  
  
 Sprawdzanie poprawności wartości wywołania zwrotne musi działać w sensie statycznym: Walidacja zastosowana za pomocą <xref:System.Windows.ValidateValueCallback> elementu nie może określić, czy podana wartość jest prawidłowa dla danego wystąpienia. Wywołanie zwrotne może określać, czy wszystkie obiekty, które mają właściwość dependency, powinny czy nie powinna akceptować podanej wartości jako prawidłowej. Jeśli musisz przeprowadzić walidację, która polega na Poznaniu wartości innych właściwości zależności w konkretnym wystąpieniu, użyj <xref:System.Windows.CoerceValueCallback> zamiast tego. Program <xref:System.Windows.CoerceValueCallback> jest zarejestrowany jako część metadanych właściwości zależności, a nie bezpośrednio w ramach identyfikatora właściwości zależności. Aby uzyskać szczegółowe informacje, zobacz [wywołania zwrotne właściwości zależności i walidacja](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="LocalValueEnumerator" FullName="System.Windows.LocalValueEnumerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bdf828bf4c7e352d7c7b4f9768e5d6f618baf253" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39737890" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct LocalValueEnumerator : System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit LocalValueEnumerator extends System.ValueType implements class System.Collections.IEnumerator" />
  <TypeSignature Language="DocId" Value="T:System.Windows.LocalValueEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public Structure LocalValueEnumerator&#xA;Implements IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public value class LocalValueEnumerator : System::Collections::IEnumerator" />
  <TypeSignature Language="F#" Value="type LocalValueEnumerator = struct&#xA;    interface IEnumerator" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Zapewnia obsługę wyliczenie dla wartości lokalnych właściwości zależności znajdujące się w elemencie <see cref="T:System.Windows.DependencyObject" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A *lokalna wartość* jest wartością dla właściwości zależności, która została ustawiona bezpośrednio na właściwość zależności, wywołując <xref:System.Windows.DependencyObject.SetValue%2A>, lub przeważnie, za pomocą metody dostępu set z [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] otoki właściwość, która wywołuje <xref:System.Windows.DependencyObject.SetValue%2A> wewnętrznie. Przykładami inne czynniki system właściwości, które nie są lokalne wartości są ustawione za pośrednictwem style wartości lub wartości domyślnej właściwości zależności. Aby uzyskać więcej informacji, zobacz [następstwo wartości właściwości](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 A <xref:System.Windows.LocalValueEnumerator> jest zwracany przez <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> metody i implementuje <xref:System.Collections.IEnumerator> interfejsu. Publiczny <xref:System.Windows.LocalValueEnumerator> Konstruktor nie istnieje; w związku z tym, należy wywołać <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> do uzyskania wystąpienie tej klasy.  
  
 Nie należy modyfikować wartości lokalnych (przez wywołanie metody <xref:System.Windows.DependencyObject.SetValue%2A> lub <xref:System.Windows.DependencyObject.ClearValue%2A>) podczas wyliczania wartości lokalnych. Jeśli zmienisz, lub wyczyść wartości właściwości na podstawie właściwości, które są zwracane przez moduł wyliczający, Zmień lub usuń zaznaczenie operacje nie unieważniają kolekcji modułu wyliczającego, tak jak w przypadku wielu <xref:System.Collections.IEnumerator> implementacji. Ponadto widoku moduł wyliczający jest migawką. Zmiany w kolekcji nie ma gwarancji bezpieczeństwa wątków i blokady nie są wymuszane. Inne wątki jeszcze bezpłatny dostęp do wartości lokalne w kontekście innej niż moduł wyliczający.  
  
 Użyj tego typu w przypadku operacji w klasie gdzie ważne jest, aby dowiedzieć się, czy wartość właściwości pochodzi z wartości lokalnej. Na przykład użyć tego typu w <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementacji, które chcesz zbadać metadanych lokalnie na wszystkich właściwości.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
  </Docs>
  <Members>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.LocalValueEnumerator.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Windows.LocalValueEnumerator.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów, które są reprezentowane w kolekcji.</summary>
        <value>Liczba elementów w kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość nie jest zdefiniowany członkiem <xref:System.Collections.IEnumerator> , ale jest dostarczana jako udogodnienie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Windows.LocalValueEntry Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.LocalValueEntry Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.LocalValueEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As LocalValueEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::LocalValueEntry Current { System::Windows::LocalValueEntry get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Windows.LocalValueEntry" Usage="System.Windows.LocalValueEnumerator.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LocalValueEntry</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący element w kolekcji.</summary>
        <value>Bieżący <see cref="T:System.Windows.LocalValueEntry" /> w kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja jest ogólnie dostępne właściwości zależy od migawki kolekcji, która jest wykonywana w momencie jego tworzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.LocalValueEnumerator.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="localValueEnumerator.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <see cref="T:System.Windows.LocalValueEnumerator" /> Do porównania z bieżącym <see cref="T:System.Windows.LocalValueEnumerator" />.</param>
        <summary>Określa, czy podany <see cref="T:System.Windows.LocalValueEnumerator" /> jest równoważny następującemu wyrażeniu <see cref="T:System.Windows.LocalValueEnumerator" />.</summary>
        <returns>
          <see langword="true" /> Jeśli określony <see cref="T:System.Windows.LocalValueEnumerator" /> jest taki sam, jak bieżący <see cref="T:System.Windows.LocalValueEnumerator" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja obsługuje tylko równości odwołań.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.LocalValueEnumerator.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="localValueEnumerator.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla bieżącego <see cref="T:System.Windows.LocalValueEnumerator" />.</summary>
        <returns>Kod skrótu 32-bitową liczbę całkowitą.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.LocalValueEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberSignature Language="F#" Value="abstract member MoveNext : unit -&gt; bool&#xA;override this.MoveNext : unit -&gt; bool" Usage="localValueEnumerator.MoveNext " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przesuwa modułu wyliczającego do następnego elementu kolekcji.</summary>
        <returns>
          <see langword="true" /> Jeśli moduł wyliczający został pomyślnie zaawansowane do następnego elementu; <see langword="false" /> Jeśli moduł wyliczający został przekazany na końcu kolekcji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.LocalValueEnumerator obj1, System.Windows.LocalValueEnumerator obj2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Windows.LocalValueEnumerator obj1, valuetype System.Windows.LocalValueEnumerator obj2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.LocalValueEnumerator.op_Equality(System.Windows.LocalValueEnumerator,System.Windows.LocalValueEnumerator)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (obj1 As LocalValueEnumerator, obj2 As LocalValueEnumerator) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::LocalValueEnumerator obj1, System::Windows::LocalValueEnumerator obj2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.LocalValueEnumerator * System.Windows.LocalValueEnumerator -&gt; bool" Usage="obj1 = obj2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj1" Type="System.Windows.LocalValueEnumerator" />
        <Parameter Name="obj2" Type="System.Windows.LocalValueEnumerator" />
      </Parameters>
      <Docs>
        <param name="obj1">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="obj2">Drugi obiekt, który będzie porównywany.</param>
        <summary>Porównuje, czy dwa określone <see cref="T:System.Windows.LocalValueEnumerator" /> obiekty są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="obj1" /><see cref="T:System.Windows.LocalValueEnumerator" /> jest równa <paramref name="obj2" /><see cref="T:System.Windows.LocalValueEnumerator" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja obsługuje tylko równości odwołań.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.LocalValueEnumerator obj1, System.Windows.LocalValueEnumerator obj2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Windows.LocalValueEnumerator obj1, valuetype System.Windows.LocalValueEnumerator obj2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.LocalValueEnumerator.op_Inequality(System.Windows.LocalValueEnumerator,System.Windows.LocalValueEnumerator)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (obj1 As LocalValueEnumerator, obj2 As LocalValueEnumerator) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::LocalValueEnumerator obj1, System::Windows::LocalValueEnumerator obj2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.LocalValueEnumerator * System.Windows.LocalValueEnumerator -&gt; bool" Usage="System.Windows.LocalValueEnumerator.op_Inequality (obj1, obj2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj1" Type="System.Windows.LocalValueEnumerator" />
        <Parameter Name="obj2" Type="System.Windows.LocalValueEnumerator" />
      </Parameters>
      <Docs>
        <param name="obj1">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="obj2">Drugi obiekt, który będzie porównywany.</param>
        <summary>Porównuje dwa określone <see cref="T:System.Windows.LocalValueEnumerator" /> obiektów w celu ustalenia, czy ich nie są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli wystąpienia nie są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja obsługuje tylko równości odwołań.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.LocalValueEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="localValueEnumerator.Reset " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia modułu wyliczającego początkową, czyli przed pierwszym elementem w kolekcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.LocalValueEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IEnumerator::Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IEnumerator.Current" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aby uzyskać opis składowe this, zobacz <see cref="P:System.Collections.IEnumerator.Current" />.</summary>
        <value>Bieżący element w kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.LocalValueEnumerator> wystąpienia jest rzutowany na <xref:System.Collections.IEnumerator> interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.LocalValueEnumerator.Current" />
      </Docs>
    </Member>
  </Members>
</Type>
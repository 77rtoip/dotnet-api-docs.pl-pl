<Type Name="ControlAdapter" FullName="System.Web.UI.Adapters.ControlAdapter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="32931f959545fbccc955d499802e8801510a11d2" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69047924" /></Metadata><TypeSignature Language="C#" Value="public abstract class ControlAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ControlAdapter extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Adapters.ControlAdapter" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ControlAdapter" />
  <TypeSignature Language="C++ CLI" Value="public ref class ControlAdapter abstract" />
  <TypeSignature Language="F#" Value="type ControlAdapter = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Dostosowuje renderowanie formantu pochodnego, do którego jest dołączona karta, aby zmodyfikować domyślne znaczniki lub zachowanie dla określonych przeglądarek i jest klasą bazową, z której dziedziczą wszystkie karty sterowania.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Adaptery sterowania są składnikami, <xref:System.Web.UI.Control> które zastępują pewne metody klasy i zdarzenia w cyklu życia wykonywania, aby zezwolić na obsługę przeglądarki lub konkretnego oznakowania. .NET Framework mapuje pojedynczą pochodną kartę kontrolną <xref:System.Web.UI.Control> na obiekt dla każdego żądania klienta.  
  
 Karta modyfikuje formant dla konkretnej przeglądarki lub klasy przeglądarek lub działa jako dowolny filtr w przypadku niektórych możliwości. Zazwyczaj karta jest definiowana przez język znaczników wykorzystywany przez przeglądarkę (na przykład XHTML lub HTML 3,2). Wiele możliwości adaptacji w zachowaniu renderowania można hermetyzować w wyspecjalizowanych klasach, które pochodzą od <xref:System.Web.UI.HtmlTextWriter> klasy. W związku z tym jest możliwe, że jedna karta może być używana przez wiele zachowań klas przeglądarki lub włączenie adaptacji w <xref:System.Web.UI.HtmlTextWriter> klasach może spowodować niepotrzebne użycie karty kontrolnej.  
  
 Adapter klasy kontroli ma zastosowanie do wszystkich kontrolek, które dziedziczą z tej klasy, chyba że są obecne bardziej wyspecjalizowane karty. Na przykład adapter dla <xref:System.Web.UI.WebControls.BaseValidator> klasy może być używany dla wszystkich `Validator` obiektów.  
  
 Karty zazwyczaj nie dziedziczą bezpośrednio z <xref:System.Web.UI.Adapters.ControlAdapter> klasy, ale z jednej z klas bazowych specyficznych dla konkretnego obiektu docelowego, które udostępniają dodatkowe funkcje specyficzne dla typu formantu i przeglądarki docelowej lub wymagane jest określone renderowanie.  
  
 Kontrolki same nie wymagają karty. Jeśli kontrolki są rozszerzane za pomocą kompozycji, zazwyczaj wystarczą podrzędne karty sterujące.  
  
 Każdy formant ma jawne mapowania do kart sieciowych za pomocą plików definicji przeglądarki. W ten sposób każdy dostęp do <xref:System.Web.UI.Control.Adapter%2A?displayProperty=nameWithType> właściwości <xref:System.Web.HttpBrowserCapabilities> używa obiektu wyodrębnionego z plików definicji przeglądarki w celu przeszukania mapowania karty do kontroli.  
  
 Podczas przetwarzania .NET Framework przechwytuje wywołania metodyki, które mogą być specyficzne dla elementu docelowego. W przypadku dołączenia karty kontrolnej .NET Framework wywołuje skojarzone metody adaptera.  
  
 Adapter wykonuje renderowanie kontrolki za pomocą <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> metody. Jeśli jest zastępowany, potencjalnie nie powinna wywołać implementacji klasy bazowej, <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> ponieważ wykonuje wywołanie z powrotem <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> metody. Może to spowodować, że renderowanie występuje dwa razy, raz przez kartę i jeden raz przez formant.  
  
 Metoda bazowa wywołuje z powrotem <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> metodę kontrolki. <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> W tym przypadku, jeśli <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>przesłonisz, nie należy wywoływać implementacji klasy bazowej, chyba że implementowane renderowanie jest uzupełnieniem <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> tego, co jest dostarczane przez formant.  
  
 Należy upewnić się, że .NET Framework wykonuje przechwycenie dla kart formantów podrzędnych. Można to zrobić, wywołując <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> metodę bazową, która <xref:System.Web.UI.Control.RenderChildren%2A?displayProperty=nameWithType> wywołuje metodę kontrolki z <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> przesłonięcia.  
  
 Metody <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> i <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> są wywoływane przez formant bezpośrednio przed i po (odpowiednio) formant wywołuje metodę. Jeśli przed i po wyrenderowaniu są jedyne wymagane zadania przetwarzania specyficzne dla przeglądarki, użycie <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> i <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> może uniemożliwić przesłonięcie <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>. Domyślne zachowanie <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> metod i <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> polega na wywołaniu odpowiednich metod <xref:System.Web.UI.HtmlTextWriter>.  
  
 Aby zachować własne informacje o stanie, adapter kontrolny może przesłonić <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>metody <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> i. <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> i<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> są wywoływane, gdy prywatne i Stany widoku są zapisywane i ładowane odpowiednio.  
  
 <xref:System.Web.UI.Control> Metody <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> ,<xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>i bazowe<xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> odwołują się z powrotem do odpowiednich metod klasy. W rezultacie każda z tych <xref:System.Web.UI.Adapters.ControlAdapter> metod, które są zastępowane, musi wywoływać metody podstawowe; w przeciwnym razie zdarzenie <xref:System.Web.UI.Control> skojarzone z metodą klasy nie zostanie zgłoszone.  
  
 Formanty i karty opcjonalnie implementują <xref:System.Web.UI.IPostBackDataHandler> interfejsy <xref:System.Web.UI.IPostBackEventHandler> i. .NET Framework określa, czy karta istnieje i czy karta implementuje te interfejsy. W takim przypadku adapter powinien zastąpić <xref:System.Web.UI.IPostBackDataHandler.LoadPostData%2A>metody, <xref:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent%2A>, i <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> , w razie potrzeby. Jeśli dane ogłaszania zwrotnego nie są rozpoznawane na karcie, muszą zostać wywywoływane z powrotem na kontrolce, aby ją przetworzyć. Kolejne programy obsługi zdarzeń muszą również wywołać z powrotem na kontrolce.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>W przypadku dziedziczenia z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy, formant, który wymaga funkcji adaptera ogólnego, powinien mieć odpowiadającą klasę bazową karty o nazwie <paramref name="ControlType" /> w wzorcu <see langword="Adapter" /> ( <see langword="TextBoxAdapter" />na przykład). Adapter powinien w minimalnej mierze zwracać wystąpienie o jednoznacznie określonym typie kontrolki za pomocą jego <see cref="P:System.Web.UI.Adapters.ControlAdapter.Control" /> właściwości.  
  
1.  Adaptery kontrolne dla danego typu kontrolki i języka adiustacji powinny być nazwane <paramref name="MarkupControlType" /> we wzorcu <see langword="Adapter" /> ( <see langword="XhtmlTextBoxAdapter" />na przykład). Adaptery dla kontrolki powinny być zaimplementowane w <see langword="Adapters" /> podprzestrzeni nazw.  
  
Adaptery kontrolne powinny dziedziczyć z odpowiedniej klasy bazowej i stosować ten sam model dziedziczenia co formant. Na przykład karta <see cref="T:System.Web.UI.Control" /> dla kontrolki dziedziczące z klasy bazowej powinna dziedziczyć <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> po klasie lub odpowiedniej <paramref name="ControlType" /> <see langword="Adapter" /> klasie.  
  
Wszystkie wyspecjalizowane karty powinny być zdefiniowane dla wyspecjalizowanej kontrolki pod wszystkimi węzłami urządzeń w plikach Configuration. browser.  
  
Prawidłowo zaimplementowana kontrola nie powinna zakładać, że karta jest dołączona lub że załączona karta implementuje określony interfejs. Zamiast tego należy sprawdzić je przed wywołaniem.  
  
Istnieje możliwość symulowania przesłaniania chronionych metod zdarzeń w formancie, takich jak <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> Metoda. <see cref="T:System.Web.UI.WebControls.LinkButton" /> Najpierw Utwórz klasę adaptera przy użyciu metody <c>onkliknięciu</c> . Następnie utwórz nową kontrolkę pochodną <see cref="T:System.Web.UI.WebControls.LinkButton" /> i <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> Zastąp metodę. Zastąpiona <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> metoda wywołuje metodę <c>onkliknięcia</c> karty. Obiekt adapter jest dostępny za pomocą chronionej <see cref="P:System.Web.UI.Control.Adapter" /> właściwości <see cref="T:System.Web.UI.Control" /> klasy. Właściwość kontrolki ma <see langword="null" /> brak skojarzonej karty, dlatego każdy kod powinien sprawdzić pod kątem tego warunku przed wywołaniem metody karty. <see cref="P:System.Web.UI.Control.Adapter" /></para></block>
    <altmember cref="T:System.Web.UI.Control" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ControlAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ControlAdapter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework wewnętrznie konstruuje ten adapter podczas tworzenia odpowiedniego <xref:System.Web.UI.Control> obiektu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="BeginRender">
      <MemberSignature Language="C#" Value="protected internal virtual void BeginRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void BeginRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub BeginRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void BeginRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.BeginRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Web.UI.HtmlTextWriter" /> Zawierające metody do renderowania danych wyjściowych specyficznych dla elementu docelowego.</param>
        <summary>Wywołuje się przed renderowaniem formantu. W klasie pochodnej karty generuje Tagi otwierające wymagane przez określony element docelowy, ale nie są wymagane przez przeglądarki HTML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest wywoływana tuż <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> przed metodą i służy do wykonania wstępnego przetwarzania specyficznego dla elementu docelowego przed renderowaniem formantu. <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>  
  
 Użyj metody w połączeniu z metodą, <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> aby upewnić się, że otwieranie i zamykanie spójności tagów. <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Gdy dziedziczysz z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> , Metoda bazowa wywołuje <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> metodę. W tym celu zastąpienia <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> metody powinny <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> wywołać metodę podstawową tylko wtedy, gdy jej przetwarzanie jest oprócz <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> metody, a nie zamiast,.</para></block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="protected System.Web.HttpBrowserCapabilities Browser { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Browser : System.Web.HttpBrowserCapabilities" Usage="System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do możliwości przeglądarki klienta wykonujące bieżące żądanie HTTP.</summary>
        <value><see cref="T:System.Web.HttpBrowserCapabilities" /> Określanie możliwości przeglądarki klienta i znaczników.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt określa możliwości przeglądarki klienta <xref:System.Web.HttpBrowserCapabilities> z obiektu <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> , który jest zwracany przez właściwość. <xref:System.Web.UI.Adapters.ControlAdapter> Dzięki <xref:System.Web.UI.Adapters.ControlAdapter> temu obiekt może renderować znaczniki specyficzne dla przeglądarki lub w inny sposób modyfikować zachowanie <xref:System.Web.UI.Control>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak używać <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> właściwości, aby uzyskać dostęp do szczegółów przeglądarki żądającej. W tym przykładzie kod sprawdza, czy przeglądarka jest zgodna z językiem JavaScript, a następnie pozwala deweloperowi na renderowanie niestandardowych danych wyjściowych w takim przypadku.  
  
 [!code-cpp[ControlAdapter_Browser#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_Browser/CPP/controladapter_browser.cpp#1)]
 [!code-csharp[ControlAdapter_Browser#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_Browser/CS/controladapter_browser.cs#1)]
 [!code-vb[ControlAdapter_Browser#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_Browser/VB/controladapter_browser.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="Control">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Control Control { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Control" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Control As Control" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Control ^ Control { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Control : System.Web.UI.Control" Usage="System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do kontrolki, do której jest dołączona ta karta sterowania.</summary>
        <value><see cref="T:System.Web.UI.Control" /> Do<see cref="T:System.Web.UI.Adapters.ControlAdapter" /> której jest dołączony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po dołączeniu adaptera kontroli pochodnej do kontrolki .NET Framework wywołuje niektórych członków karty zamiast członków formantu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć kontrolkę niestandardową z <xref:System.Web.UI.Control> klasy, a następnie tworzyć odpowiednią kartę, która dziedziczy <xref:System.Web.UI.Adapters.ControlAdapter> z klasy. Karta przesłania <xref:System.Web.UI.Adapters.ControlAdapter.Control%2A> Właściwość i zwraca odwołanie o jednoznacznie określonym typie do kontrolki.  
  
 [!code-cpp[ControlAdapter.Control#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter.Control/CPP/controladapter.control.cpp#1)]
 [!code-csharp[ControlAdapter.Control#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter.Control/CS/controladapter.control.cs#1)]
 [!code-vb[ControlAdapter.Control#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter.Control/VB/controladapter.control.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>W przypadku dziedziczenia z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy, należy <see langword="Control" /> zaimplementować właściwość w celu zwrócenia wystąpienia o jednoznacznie określonym typie formantu, jak pokazano w sekcji przykład.</para></block>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected internal virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CreateChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CreateChildControls();" />
      <MemberSignature Language="F#" Value="abstract member CreateChildControls : unit -&gt; unit&#xA;override this.CreateChildControls : unit -&gt; unit" Usage="controlAdapter.CreateChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy kontrolki podrzędne specyficzne dla elementu docelowego dla formantu złożonego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli istnieje adapter kontroli pochodnej dołączony do <xref:System.Web.UI.Control> obiektu, <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> a metoda zostanie zastąpiona, zamiast <xref:System.Web.UI.Control.CreateChildControls%2A?displayProperty=nameWithType> metody zostanie wywołane przesłonięcie. W tym celu można użyć do utworzenia podrzędnego zestawu kontrolnego określonego dla elementu docelowego. <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A>  
  
 Aby uzyskać więcej informacji na temat łączenia formantów w celu utworzenia nowej kontrolki, zobacz [kontrolki złożone](https://msdn.microsoft.com/library/fb174677-d845-467c-8bf3-cc096b2490b0).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Jeśli utworzysz klasę dziedziczenia i zastąpisz <see cref="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" /> metodę, nie wywołuj metody bazowej, chyba że chcesz dodać kontrolki do tych, które zostały utworzone przez metodę bazową. W przeciwnym razie można utworzyć dwa zestawy formantów podrzędnych.</para></block>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="EndRender">
      <MemberSignature Language="C#" Value="protected internal virtual void EndRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void EndRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub EndRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void EndRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member EndRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.EndRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.EndRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Web.UI.HtmlTextWriter" /> Zawierające metody do renderowania danych wyjściowych specyficznych dla elementu docelowego.</param>
        <summary>Wywoływana po renderowaniu kontrolki. W klasie pochodnej karty generuje tagi zamykające wymagane przez określony element docelowy, ale nie są wymagane przez przeglądarki HTML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest wywoływana tuż <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> po metodzie i służy do wykonywania dostosujesz specyficznych dla elementu docelowego po renderowaniu kontrolki. <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>  
  
 Użyj metody w połączeniu z metodą, <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> aby upewnić się, że otwieranie i zamykanie spójności tagów. <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Gdy dziedziczysz z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> , Metoda bazowa wywołuje <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> metodę. W tym celu zastąpienia <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> metody powinny <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> wywołać metodę podstawową tylko wtedy, gdy jej przetwarzanie jest oprócz <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> metody, a nie zamiast,.</para></block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.EndRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterControlState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterControlState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterControlState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterControlState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterControlState : obj -&gt; unit&#xA;override this.LoadAdapterControlState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterControlState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Zawiera informacje o stanie kontroli karty <see cref="T:System.Web.UI.StateBag" />jako. <see cref="T:System.Object" /></param>
        <summary>Ładuje informacje o stanie kontroli karty, które zostały <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" /> zapisane przez program podczas poprzedniego żądania do strony, na której znajduje się kontrolka skojarzona z tą kartą kontrolną.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Stan kontroli to podstawowe informacje o stanie wymagane nawet wtedy, gdy stan widoku jest wyłączony. Gdy karta musi zachować własne informacje o stanie kontroli, może przesłonić <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> metody i. <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>  
  
 Karta może wymagać utrzymania informacji o stanie kontroli, gdy istnieją funkcje, które muszą mieć stan, który jest niezależny od stanu skojarzonej kontrolki. Na przykład złożona kontrolka składająca się z dużego wyświetlania tekstu i grupy <xref:System.Web.UI.WebControls.RadioButton> formantów może być renderowana jako pojedynczy widok w przeglądarkach komputerów stacjonarnych. W innych przeglądarkach może on podzielić Render-jeden widok do wyświetlania tekstu, a drugi dla grupy przycisków radiowych. Karta musi obsługiwać własne informacje specyficzne dla elementu docelowego dotyczące aktualnie aktywnego widoku.  
  
 Metoda jest wywoływana natychmiast <xref:System.Web.UI.Control.LoadControlState%2A?displayProperty=nameWithType> po metodzie, na `LoadState` etapie cyklu życia. <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> Stan formantu karty jest oddzielny i oprócz stanu kontrolki formantu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterViewState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterViewState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterViewState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterViewState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterViewState : obj -&gt; unit&#xA;override this.LoadAdapterViewState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterViewState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Zawiera informacje o <see cref="T:System.Web.UI.StateBag" />stanie widoku karty. <see cref="T:System.Object" /></param>
        <summary>Ładuje informacje o stanie widoku karty, które zostały <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" /> zapisane przez program podczas poprzedniego żądania do strony, na której znajduje się kontrolka skojarzona z tą kartą kontrolną.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy karta musi zachować własne informacje o stanie widoku, może przesłonić <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> metody i. <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>  
  
 Adapter musi utrzymywać informacje o stanie widoku, gdy istnieją dane, które muszą być utrzymywane między żądaniami, niezależnie od stanu widoku powiązanej kontrolki. Na przykład kontrolka siatki w przeglądarkach komputerów stacjonarnych może być renderowana jako pojedynczy widok wierszy i kolumn wartości. W innych przeglądarkach może on podzielić Render na wiele oddzielnych widoków, takich jak lista wierszy i szczegóły pojedynczego wiersza. Karta musiałaby zachować dane dla widoków, które nie są obecnie aktywne w stanie widoku.  
  
 Metoda jest wywoływana bezpośrednio <xref:System.Web.UI.Control.LoadViewState%2A?displayProperty=nameWithType> przed metodą w `LoadState` fazie cyklu życia. <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> Stan widoku karty jest oddzielny i oprócz stanu widoku formantu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInit : EventArgs -&gt; unit&#xA;override this.OnInit : EventArgs -&gt; unit" Usage="controlAdapter.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> Zastępuje metodę skojarzoną z kontrolką.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli karta jest podłączona do <xref:System.Web.UI.Control> obiektu, <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> a metoda zostanie zastąpiona, Metoda przesłaniania <xref:System.Web.UI.Control.OnInit%2A?displayProperty=nameWithType> jest wywoływana zamiast metody.  
  
 Przesłoń <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> , aby przeprowadzić przetwarzanie specyficzne dla elementu `Initialize` docelowego na etapie cyklu kontroli. Zazwyczaj są to funkcje wykonywane podczas tworzenia formantu.  
  
   
  
## Examples  
 Poniższy przykład kodu dziedziczy niestandardową kartę kontrolną z <xref:System.Web.UI.Adapters.ControlAdapter> klasy. Następnie zastępuje <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> metodę, aby ustawić właściwość w skojarzonym formancie i wywołać metodę bazową w celu ukończenia inicjalizacji formantu.  
  
 [!code-cpp[ControlAdapter_OnInit#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_OnInit/CPP/controladapter_oninit.cpp#1)]
 [!code-csharp[ControlAdapter_OnInit#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_OnInit/CS/controladapter_oninit.cs#1)]
 [!code-vb[ControlAdapter_OnInit#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_OnInit/VB/controladapter_oninit.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Gdy dziedziczysz z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy, a karta <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" /> przesłania metodę, adapter musi wywołać odpowiadającą metodę klasy bazowej, <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> która z kolei wywołuje metodę. Jeśli metoda nie jest wywoływana <see cref="E:System.Web.UI.Control.Init" /> , zdarzenie nie zostanie zgłoszone. <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /></para></block>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <altmember cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoad : EventArgs -&gt; unit&#xA;override this.OnLoad : EventArgs -&gt; unit" Usage="controlAdapter.OnLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> Zastępuje metodę skojarzoną z kontrolką.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli karta jest podłączona do <xref:System.Web.UI.Control> obiektu, <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> a metoda zostanie zastąpiona, Metoda przesłaniania <xref:System.Web.UI.Control.OnLoad%2A?displayProperty=nameWithType> jest wywoływana zamiast metody.  
  
 Zastąp <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> metodę, aby przeprowadzić przetwarzanie specyficzne dla elementu docelowego `Load` na etapie cyklu kontroli. Zazwyczaj są to funkcje, które należy wykonać dla każdego żądania klienta.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Gdy dziedziczysz z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy, a karta <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" /> przesłania metodę, adapter musi wywołać odpowiadającą metodę klasy bazowej, <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> która z kolei wywołuje metodę. Jeśli <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> nie jest wywoływana <see cref="E:System.Web.UI.Control.Load" /> , zdarzenie nie zostanie zgłoszone.</para></block>
        <altmember cref="E:System.Web.UI.Control.Load" />
        <altmember cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreRender : EventArgs -&gt; unit&#xA;override this.OnPreRender : EventArgs -&gt; unit" Usage="controlAdapter.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> Zastępuje metodę skojarzoną z kontrolką.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli karta jest podłączona do <xref:System.Web.UI.Control> obiektu, <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> a metoda zostanie zastąpiona, Metoda przesłaniania <xref:System.Web.UI.Control.OnPreRender%2A?displayProperty=nameWithType> jest wywoływana zamiast metody.  
  
 Zastąp <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> metodę, aby przeprowadzić przetwarzanie specyficzne dla elementu docelowego `PreRender` na etapie cyklu kontroli. Zazwyczaj są to funkcje bezpośrednio poprzedzające renderowanie danych wyjściowych formantu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Gdy dziedziczysz z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy, a karta <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" /> przesłania metodę, adapter musi wywołać odpowiadającą metodę klasy bazowej, <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> która z kolei wywołuje metodę. Jeśli metoda nie jest wywoływana <see cref="E:System.Web.UI.Control.PreRender" /> , zdarzenie nie zostanie zgłoszone. <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /></para></block>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <altmember cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnload : EventArgs -&gt; unit&#xA;override this.OnUnload : EventArgs -&gt; unit" Usage="controlAdapter.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> Zastępuje metodę skojarzoną z kontrolką.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli karta jest podłączona do <xref:System.Web.UI.Control> obiektu, <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> a metoda zostanie zastąpiona, Metoda przesłaniania <xref:System.Web.UI.Control.OnUnload%2A?displayProperty=nameWithType> jest wywoływana zamiast metody.  
  
 Zastąp <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> metodę, aby przeprowadzić przetwarzanie specyficzne dla elementu docelowego `Unload` na etapie cyklu kontroli. Zazwyczaj są to funkcje oczyszczania, które poprzedzają usunięcie formantu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Gdy dziedziczysz z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy, a karta <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" /> przesłania metodę, adapter musi wywołać odpowiadającą metodę klasy bazowej, <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> która z kolei wywołuje metodę. Jeśli <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> nie jest wywoływana <see cref="E:System.Web.UI.Control.Unload" /> , zdarzenie nie zostanie zgłoszone.</para></block>
        <altmember cref="E:System.Web.UI.Control.Unload" />
        <altmember cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Page Page { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Page As Page" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Page ^ Page { System::Web::UI::Page ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Page : System.Web.UI.Page" Usage="System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do strony, na której znajduje się kontrolka skojarzona z tą kartą.</summary>
        <value>A <see cref="T:System.Web.UI.Page" /> , który zapewnia dostęp do wystąpienia strony, gdzie znajduje się skojarzony formant.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość zapewnia dostęp <xref:System.Web.UI.Page?displayProperty=nameWithType> do obiektu, w którym znajduje się kontrolka. <xref:System.Web.UI.Adapters.ControlAdapter.Page%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property PageAdapter As PageAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Adapters::PageAdapter ^ PageAdapter { System::Web::UI::Adapters::PageAdapter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageAdapter : System.Web.UI.Adapters.PageAdapter" Usage="System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do karty strony dla strony, w której znajduje się skojarzony formant.</summary>
        <value>A <see cref="T:System.Web.UI.Adapters.PageAdapter" /> dla strony, w której znajduje się kontrolka skojarzona z bieżącym <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.PageAdapter?displayProperty=nameWithType> <xref:System.Web.UI.Page> Właściwość zapewnia dostęp do obiektu <xref:System.Web.UI.Adapters.ControlAdapter> dlaobiektu,wktórymznajdujesięobiektskojarzonyzbieżącymobiektem.<xref:System.Web.UI.Control> <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A>  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> Właściwość może służyć do uzyskiwania dostępu do innych elementów na poziomie karty strony, takich jak typowe funkcje specyficzne dla elementu docelowego, które mogą mieć zastosowanie do kilku typów formantów na stronie.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Adapters.PageAdapter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Render : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Web.UI.HtmlTextWriter" /> Służy do renderowania danych wyjściowych specyficznych dla elementu docelowego.</param>
        <summary>Generuje oznakowanie specyficzne dla elementu docelowego dla kontrolki, do której jest dołączona karta sterowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastąp <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> metodę, aby wygenerować znaczniki specyficzne dla elementu docelowego do wysłania do przeglądarki klienta. Metoda jest wywoływana zamiast metody, <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> Jeśli <xref:System.Web.UI.Adapters.ControlAdapter> obiekt jest dołączony do <xref:System.Web.UI.Control> obiektu. <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Gdy dziedziczysz z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> , Metoda bazowa wywołuje <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> metodę. W tym celu zastąpienia <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> metody powinny <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> wywołać metodę podstawową tylko wtedy, gdy jej przetwarzanie jest oprócz <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> metody, a nie zamiast,.  
  
Dla kontrolki złożonej, deweloper karty musi upewnić się, że kontrolki podrzędne są renderowane. Jeśli metoda powoduje renderowanie formantów podrzędnych, ale nie generuje znacznika, może być odpowiednie <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> dla metody wywołującej metodę bazową. <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> Jeśli konieczne jest renderowanie kontrolki podrzędnej specyficzne dla elementu docelowego, karta powinna zaimplementować <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> metodę i <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> wywołać metodę z <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> metody.</para></block>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RenderChildren (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.RenderChildren writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Web.UI.HtmlTextWriter" /> Służy do renderowania danych wyjściowych specyficznych dla elementu docelowego.</param>
        <summary>Generuje oznakowanie specyficzne dla elementu docelowego dla kontrolek podrzędnych w kontrolce złożonej, do której jest dołączona karta sterowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastąp <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> metodę, gdy jest to konieczne w celu wygenerowania znacznika specyficznego dla elementu docelowego dla podrzędnego zestawu kontrolek, oprócz znaczników dla poszczególnych formantów podrzędnych.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>W przypadku dziedziczenia z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy dla kontrolki złożonej, deweloper karty musi upewnić się, że kontrolki podrzędne są renderowane. Jeśli karta przesłania <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> metodę, powinna <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> wywołać metodę <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> z przesłonięcia metody.  
  
Jeśli metoda powoduje renderowanie formantów podrzędnych, ale sama nie generuje znacznika, może być odpowiednie <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> do wywołania metody bazowej, która wywołuje <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> metodę, zamiast implementowania przesłonięcia dla <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> Metoda.</para></block>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterControlState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterControlState : unit -&gt; obj&#xA;override this.SaveAdapterControlState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapisuje informacje o stanie kontroli dla karty sterującej.</summary>
        <returns>Zawiera informacje o stanie kontroli karty <see cref="T:System.Web.UI.StateBag" />jako. <see cref="T:System.Object" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Stan kontroli to podstawowe informacje o stanie wymagane nawet wtedy, gdy stan widoku jest wyłączony. Gdy karta musi zachować własne informacje o stanie kontroli, może przesłonić <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> metody i. <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>  
  
 Karta może wymagać utrzymania informacji o stanie kontroli, gdy istnieją funkcje, które muszą mieć stan, który jest niezależny od stanu skojarzonej kontrolki. Na przykład złożona kontrolka składająca się z dużego wyświetlania tekstu i grupy <xref:System.Web.UI.WebControls.RadioButton> formantów może być renderowana jako pojedynczy widok w przeglądarkach komputerów stacjonarnych. W innych przeglądarkach może on podzielić Render-jeden widok do wyświetlania tekstu, a drugi dla grupy przycisków radiowych. Karta musi obsługiwać własne informacje specyficzne dla elementu docelowego dotyczące aktualnie aktywnego widoku.  
  
 Metoda jest wywoływana natychmiast <xref:System.Web.UI.Control.SaveControlState%2A?displayProperty=nameWithType> po metodzie na `SaveState` etapie cyklu życia. <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> Stan formantu karty jest oddzielny i oprócz stanu kontrolki formantu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterViewState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterViewState : unit -&gt; obj&#xA;override this.SaveAdapterViewState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapisuje informacje o stanie widoku dla karty sterującej.</summary>
        <returns>Zawiera informacje o <see cref="T:System.Web.UI.StateBag" />stanie widoku karty. <see cref="T:System.Object" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy karta musi zachować własne informacje o stanie widoku, może przesłonić <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> metody i. <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>  
  
 Adapter musi utrzymywać informacje o stanie widoku, gdy istnieją dane, które muszą być utrzymywane między żądaniami, niezależnie od skojarzonego stanu widoku formantu. Na przykład kontrolka siatki w przeglądarkach komputerów stacjonarnych może być renderowana jako pojedynczy widok wierszy i kolumn wartości. W innych przeglądarkach może on podzielić Render na wiele oddzielnych widoków, takich jak lista wierszy i szczegóły pojedynczego wiersza. Karta musiałaby zachować dane dla widoków, które nie są obecnie aktywne w stanie widoku.  
  
 Metoda jest wywoływana bezpośrednio <xref:System.Web.UI.Control.SaveViewState%2A?displayProperty=nameWithType> przed metodą w `SaveState` fazie cyklu życia. <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> Stan widoku karty jest oddzielny i oprócz stanu widoku formantu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
  </Members>
</Type>

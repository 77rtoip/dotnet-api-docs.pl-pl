<Type Name="ControlAdapter" FullName="System.Web.UI.Adapters.ControlAdapter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="92d5994d2f6188d664ca43f6b7dc75d96c4d81fd" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36394656" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ControlAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ControlAdapter extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Adapters.ControlAdapter" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ControlAdapter" />
  <TypeSignature Language="C++ CLI" Value="public ref class ControlAdapter abstract" />
  <TypeSignature Language="F#" Value="type ControlAdapter = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Dostosowuje renderowania dla formantu pochodnej, do której jest dołączona karty, aby zmodyfikować domyślne znaczników lub zachowanie dla przeglądarki, a jest klasy podstawowej, z których wszystkie kontrolki dziedziczą kart.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Formant karty są składniki, które zastępują niektórych <xref:System.Web.UI.Control> klas, metod i zdarzeń w jego cyklu życia wykonywania przeglądarki lub obsługa specyficzne dla znacznika. .NET Framework mapuje karty jeden formant pochodnej <xref:System.Web.UI.Control> obiekt dla każdego żądania klienta.  
  
 Karta modyfikuje kontroli dla konkretnej przeglądarki lub klasy przeglądarki lub działa jako filtr dowolnego na niektóre możliwości. Zazwyczaj karty jest definiowane przez język znaczników, który korzysta z przeglądarki (na przykład XHTML lub HTML 3.2). Znacznie przystosowanie w sposób renderowania są umieszczane w specjalne klas pochodzących od <xref:System.Web.UI.HtmlTextWriter> klasy. W związku z tym istnieje duże prawdopodobieństwo, że jedna karta może służyć do liczba zachowania klasy przeglądarki lub że włączenia przystosowanie w <xref:System.Web.UI.HtmlTextWriter> klasy można wykorzystać karty kontroli niepotrzebne.  
  
 Adaptera dla klasy formantu ma zastosowanie do wszystkich kontrolek, które dziedziczą z tej klasy, chyba że nie występują wyspecjalizowanego karty. Na przykład karta <xref:System.Web.UI.WebControls.BaseValidator> klasa może być używana dla wszystkich `Validator` obiektów.  
  
 Kart zwykle nie dziedziczyć bezpośrednio <xref:System.Web.UI.Adapters.ControlAdapter> klasy, ale z jednej karty specyficznych dla obiektu docelowego podstawowa klasy, które zapewniają dodatkowe funkcje specyficzne dla formantu typu i docelowej przeglądarki lub konkretnej renderowania wymagane.  
  
 Formanty się nie wymaga karty. Jeśli formanty zostały rozszerzone za pośrednictwem kompozycji, zazwyczaj kart kontrolki podrzędne są wystarczające.  
  
 Każdy formant ma jawnego mapowania do kart za pomocą .browser plików definicji. W związku z tym wszelkie dostęp do <xref:System.Web.UI.Control.Adapter%2A?displayProperty=nameWithType> używa właściwości <xref:System.Web.HttpBrowserCapabilities> obiektu wyodrębniony z plików definicji przeglądarki do wyszukiwania mapowania kart do formantu.  
  
 Podczas przetwarzania, .NET Framework przechwytuje wywołania nadpisywalnych metod formantu, który może być specyficznych dla obiektu docelowego. Jeśli karta kontroli jest dołączony, .NET Framework wywołuje metody skojarzonej karty.  
  
 Karta wykonywane jest renderowanie formantu za pośrednictwem <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> metody. Jeśli została zastąpiona, <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> potencjalnie nie powinny wywoływać implementację klasy podstawowej, ponieważ który wykonuje wywołanie do <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> metody. Może to spowodować renderowania występuje dwa razy, raz przez kartę i raz przez formant.  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> Podstawy wywołania metody <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> metody formantu. W związku z tym jeśli można zastąpić <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>, nie powinny wywoływać implementację klasy podstawowej, chyba że renderowania zaimplementowaniem oprócz są dostarczane przez <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> formantu.  
  
 Należy się upewnić, że programu .NET Framework wykonuje przechwytywaniu kart formantów podrzędnych. Można to zrobić przez wywołanie metody <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> podstawowa metoda, która wywołuje <xref:System.Web.UI.Control.RenderChildren%2A?displayProperty=nameWithType> metody formantu, z Twojego <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> zastąpienia.  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> i <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> metody są wywoływane przez kontrolkę, bezpośrednio przed i po (odpowiednio) wywołań kontroli <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> metody. Jeśli przed i po renderowania są tylko przeglądarki dotyczące przetwarzania zadań wymaganych przy użyciu <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> i <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> może być konieczne zastąpienie <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>. Domyślne zachowanie <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> i <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> metod jest wywołanie metody odpowiedniej <xref:System.Web.UI.HtmlTextWriter>.  
  
 Aby zachować informacje stanu, można zastąpić karty sterowania <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, i <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> metody. <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, i <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> są wywoływane podczas zapisywania i załadować odpowiednio prywatnej stanów widoku i kontroli.  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>, I <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> podstawowa do odpowiedniego wywołania metody <xref:System.Web.UI.Control> metody klasy. W związku z tym któregoś z powyższych <xref:System.Web.UI.Adapters.ControlAdapter> metod, które są zastępowane należy wywołać ich metod bazowych; w przeciwnym razie zdarzenia skojarzona z <xref:System.Web.UI.Control> metody klasy nie zostanie wygenerowany.  
  
 Formanty i kart opcjonalnie stosować <xref:System.Web.UI.IPostBackDataHandler> i <xref:System.Web.UI.IPostBackEventHandler> interfejsów. .NET Framework Określa, czy karta istnieje i czy adapter implementuje tych interfejsów. Jeśli tak, karta powinny zastępować <xref:System.Web.UI.IPostBackDataHandler.LoadPostData%2A>, <xref:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent%2A>, i <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> metod, w razie potrzeby. Jeśli nie rozpoznano danych odświeżania strony na karcie, musi ona wywołania zwrotnego w formancie go przetworzyć. Programy obsługi zdarzeń kolejnych również musi wywołania zwrotnego w formancie.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Przy dziedziczeniu z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasa, kontrolkę, która wymaga funkcji karty Ogólne powinna mieć odpowiedniej karty podstawowa klasa o nazwie we wzorcu <paramref name="ControlType" /><see langword="Adapter" /> (na przykład <see langword="TextBoxAdapter" />). Karta ma co najmniej zwracać jednoznacznie wystąpienia sterowanie za pośrednictwem jego <see cref="P:System.Web.UI.Adapters.ControlAdapter.Control" /> właściwości.  1.  Kontrolowanie kart dla danego formantu typ i język znaczników powinno być nazwanym we wzorcu <paramref name="MarkupControlType" /><see langword="Adapter" /> (na przykład <see langword="XhtmlTextBoxAdapter" />). Kart kontrolki powinny być implementowane w <see langword="Adapters" /> subnamespace.  Formantu karty powinny dziedziczyć z odpowiedniej klasy podstawowej i postępuj zgodnie z tym samym modelu dziedziczenia jako formant. Na przykład karty dziedziczenie z formantu <see cref="T:System.Web.UI.Control" /> klasy podstawowej należy dziedziczyć albo <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy lub odpowiedniego <paramref name="ControlType" /><see langword="Adapter" /> klasy.  Specjalne formantu we wszystkich węzłach urządzenia w plikach konfiguracji .browser powinien być zdefiniowany żadnych specjalnych kart sieciowych.  Właściwie zaimplementowana formant nie należy zakładać, że karta jest podłączona lub że podłączone karty implementuje określonego interfejsu. Zamiast tego należy sprawdzić tych przed wywołaniem.  Można symulować zastępowanie metod zdarzenie chronione w formancie, takich jak <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> metody <see cref="T:System.Web.UI.WebControls.LinkButton" />. Najpierw Utwórz klasę karty z <c>OnClick</c> metody. Następnie utwórz nowy formant pochodzi od <see cref="T:System.Web.UI.WebControls.LinkButton" /> i zastąpić <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> metody. Zastąpiona <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> wywołania metody <c>OnClick</c> metody karty. Obiekt karta jest dostępna za pośrednictwem chronionej <see cref="P:System.Web.UI.Control.Adapter" /> właściwość <see cref="T:System.Web.UI.Control" /> klasy. <see cref="P:System.Web.UI.Control.Adapter" /> Właściwości formantu jest <see langword="null" /> podczas brak skojarzonych karty, dlatego dowolny kod skontaktować się tego warunku przed wywołaniem metody karty.</para>
    </block>
    <altmember cref="T:System.Web.UI.Control" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ControlAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ControlAdapter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas tworzenia odpowiedniego środowiska .NET Framework wewnętrznie tworzy tej karty <xref:System.Web.UI.Control> obiektu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="BeginRender">
      <MemberSignature Language="C#" Value="protected internal virtual void BeginRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void BeginRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub BeginRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void BeginRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.BeginRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" /> Zawierający metody do danych wyjściowych specyficznych dla obiektu docelowego renderowania.</param>
        <summary>Wywoływane przed renderowanie formantu. W klasie pochodnej karty generuje otwarcia tagów, które są wymagane przez określony element docelowy, ale nie jest wymagane przez przeglądarki HTML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> Metoda jest wywoływana bezpośrednio przed <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> metody i jest używany do wykonania przed renderowanie formantu przetwarzania wstępnego specyficznych dla obiektu docelowego.  
  
 Użyj <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> w połączeniu z metody <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> metodę, aby zapewnić otwierający i zamykający tag spójności.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Przy dziedziczeniu z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> podstawowa wywołania metody <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> metody. W związku z tym zastąpień o <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> powinny wywoływać metodę <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> podstawowa metoda tylko wtedy, gdy jego przetwarzanie dodatkowe, a nie zamiast <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> metody.</para>
        </block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="protected System.Web.HttpBrowserCapabilities Browser { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Browser : System.Web.HttpBrowserCapabilities" Usage="System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do funkcji przeglądarki klienta wprowadzania bieżącego żądania HTTP.</summary>
        <value>
          <see cref="T:System.Web.HttpBrowserCapabilities" /> Określenie możliwości przeglądarki i znaczników klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Web.UI.Adapters.ControlAdapter> obiektu określa możliwości przeglądarki klienta z <xref:System.Web.HttpBrowserCapabilities> obiektu, który jest zwracany przez <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> właściwości. Dzięki temu <xref:System.Web.UI.Adapters.ControlAdapter> obiektu do renderowania kodu znaczników specyficzne dla przeglądarki lub w przeciwnym razie modyfikowanie <xref:System.Web.UI.Control>.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób użycia <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> właściwości dostępu szczegóły przeglądarki. W tym przykładzie kodu sprawdza czy jest zgodny z JavaScript przeglądarki, a następnie umożliwia deweloperowi renderowania dostosowane danych wyjściowych w tym przypadku.  
  
 [!code-cpp[ControlAdapter_Browser#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_Browser/CPP/controladapter_browser.cpp#1)]
 [!code-csharp[ControlAdapter_Browser#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_Browser/CS/controladapter_browser.cs#1)]
 [!code-vb[ControlAdapter_Browser#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_Browser/VB/controladapter_browser.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="Control">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Control Control { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Control" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Control As Control" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Control ^ Control { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Control : System.Web.UI.Control" Usage="System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do formantu, do której jest dołączona ta karta formantu.</summary>
        <value>
          <see cref="T:System.Web.UI.Control" /> Do której należy <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> jest dołączony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy karty pochodnej kontroli jest dołączony do formantu, .NET Framework wywołuje określone elementy karty zamiast członków kontroli.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób pochodzi z formantu niestandardowego <xref:System.Web.UI.Control> klasy, a następnie utwórz odpowiedniej karty, która dziedziczy <xref:System.Web.UI.Adapters.ControlAdapter> klasy. Karta zastępuje <xref:System.Web.UI.Adapters.ControlAdapter.Control%2A> właściwości i zwraca jednoznacznie odwołanie do formantu.  
  
 [!code-cpp[ControlAdapter.Control#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter.Control/CPP/controladapter.control.cpp#1)]
 [!code-csharp[ControlAdapter.Control#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter.Control/CS/controladapter.control.cs#1)]
 [!code-vb[ControlAdapter.Control#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter.Control/VB/controladapter.control.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Przy dziedziczeniu z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy, co najmniej, należy zaimplementować <see langword="Control" /> właściwość, aby zwrócić wystąpienie silnie typizowane kontroli, jak pokazano w przykładzie.</para>
        </block>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected internal virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CreateChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CreateChildControls();" />
      <MemberSignature Language="F#" Value="abstract member CreateChildControls : unit -&gt; unit&#xA;override this.CreateChildControls : unit -&gt; unit" Usage="controlAdapter.CreateChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy formantów dla formantu złożonego za elementem podrzędnym specyficznych dla obiektu docelowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku karty pochodnej kontroli dołączony do <xref:System.Web.UI.Control> obiektu i <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> metoda zostanie przesłonięta, zastąpienie jest wywoływana zamiast <xref:System.Web.UI.Control.CreateChildControls%2A?displayProperty=nameWithType> metody. W związku z tym <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> można użyć do utworzenia zestawu formant podrzędny specyficznych dla obiektu docelowego.  
  
 Aby uzyskać więcej informacji o łączeniu kontroli w celu utworzenia nowego formantu, zobacz [formanty złożone](http://msdn.microsoft.com/library/fb174677-d845-467c-8bf3-cc096b2490b0).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Jeśli podczas tworzenia klasy dziedziczące i zastąpić <see cref="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" /> metody, czy nie wywołania metody podstawowej, chyba że chcesz dodać do tych kontrolek utworzone przez metodę podstawową. W przeciwnym razie można utworzyć dwa zestawy elementu podrzędnego kontrolki.</para>
        </block>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="EndRender">
      <MemberSignature Language="C#" Value="protected internal virtual void EndRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void EndRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub EndRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void EndRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member EndRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.EndRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.EndRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" /> Zawierający metody do danych wyjściowych specyficznych dla obiektu docelowego renderowania.</param>
        <summary>Wywoływana po wykonaniu renderowania formantu. W klasie pochodnej karty generuje zamykające znaczniki, które są wymagane przez określony element docelowy, ale nie jest wymagane przez przeglądarki HTML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> Metoda jest wywoływana tuż po <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> metody i jest używany do wykonania po renderowania formantu postprocessing specyficznych dla obiektu docelowego.  
  
 Użyj <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> w połączeniu z metody <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> metodę, aby zapewnić otwierający i zamykający tag spójności.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Przy dziedziczeniu z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> podstawowa wywołania metody <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> metody. W związku z tym zastąpień o <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> powinny wywoływać metodę <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> podstawowa metoda tylko wtedy, gdy jego przetwarzanie dodatkowe, a nie zamiast <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> metody.</para>
        </block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.EndRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterControlState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterControlState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterControlState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterControlState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterControlState : obj -&gt; unit&#xA;override this.LoadAdapterControlState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterControlState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Object" /> Zawierający informacje o stanie formantu karty jako <see cref="T:System.Web.UI.StateBag" />.</param>
        <summary>Ładuje karty kontroli informacji o stanie zapisanych przez <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" /> podczas poprzedniego żądania do strony, gdzie znajduje się formantu skojarzony z tą kartą kontroli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Stan kontrolki jest informacje o stanie niezbędne potrzebne, nawet jeśli stan widoku jest wyłączone. Jeśli karta musi zachować informacje kontroli stanu, można zastąpić <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> i <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> metody.  
  
 Karta może być konieczne przechowuje informacji o stanie kontroli, gdy są funkcje, które muszą mieć stan przechowywanych w wielu żądań, niezależnie od stanu skojarzonym formancie. Na przykład formantu złożonego składające się z dużych wyświetlania tekstową i grupy <xref:System.Web.UI.WebControls.RadioButton> formanty może spowodować, że jako pojedynczy w przeglądarkach komputera stacjonarnego. W innych przeglądarkach mogą podzielić renderowania — jeden widok dla tekstową wyświetlania, a druga w grupie przycisków radiowych. Karta potrzebny do obsługi własnych informacji specyficznych dla obiektu docelowego o aktualnie aktywny widok.  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> Metoda jest wywoływana bezpośrednio po <xref:System.Web.UI.Control.LoadControlState%2A?displayProperty=nameWithType> metody w `LoadState` etap cyklu życia. Stan formantu karty jest oddzielne i oprócz stan formantu formantu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterViewState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterViewState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterViewState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterViewState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterViewState : obj -&gt; unit&#xA;override this.LoadAdapterViewState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterViewState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Object" /> Zawierający informacje o stanie widoku karty jako <see cref="T:System.Web.UI.StateBag" />.</param>
        <summary>Ładuje karty Wyświetl informacje o stanie zapisanych przez <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" /> podczas poprzedniego żądania do strony, gdzie znajduje się formantu skojarzony z tą kartą kontroli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy adaptera musi zachować informacje widok stanu, można zastąpić <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> i <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> metody.  
  
 Karta musi zachować informacje o stanie widoku po dane, które muszą zostać zachowane żądań, niezależnie od stan widoku formantu skojarzony. Na przykład formantu siatki w przeglądarkach, komputerów stacjonarnych może spowodować, że jako pojedynczego widoku wierszy i kolumn wartości. W innych przeglądarkach może ją podzielić renderowania do wielu oddzielnych widoków, takich jak lista wierszy i szczegółowe informacje o jeden wiersz. Karta potrzebny do przechowywania danych dla widoków, które nie są aktualnie aktywne w widoku stanu.  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> Metoda jest wywoływana bezpośrednio przed <xref:System.Web.UI.Control.LoadViewState%2A?displayProperty=nameWithType> metoda `LoadState` etap cyklu życia. Stan widoku karty jest osobnym oraz stan widoku formantu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInit : EventArgs -&gt; unit&#xA;override this.OnInit : EventArgs -&gt; unit" Usage="controlAdapter.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zastępuje <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> metodę skojarzony formant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku karta jest podłączona do <xref:System.Web.UI.Control> obiektu i <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> metoda zostanie przesłonięta, zamiast wywoływana jest metoda zastąpienie <xref:System.Web.UI.Control.OnInit%2A?displayProperty=nameWithType> metody.  
  
 Zastąpienie <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> do przetwarzania specyficznych dla obiektu docelowego w `Initialize` etap cyklu kontrolki. Zazwyczaj są funkcje, które są wykonywane, gdy formant zostanie utworzony.  
  
   
  
## Examples  
 Poniższy przykładowy kod pochodzi z kartą kontrolka niestandardowa z <xref:System.Web.UI.Adapters.ControlAdapter> klasy. Następnie zastępuje <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> metodę, aby ustawić właściwość w skojarzonym formancie i wywołaj metodę podstawową do zakończenia inicjowania formantu.  
  
 [!code-cpp[ControlAdapter_OnInit#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_OnInit/CPP/controladapter_oninit.cpp#1)]
 [!code-csharp[ControlAdapter_OnInit#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_OnInit/CS/controladapter_oninit.cs#1)]
 [!code-vb[ControlAdapter_OnInit#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_OnInit/VB/controladapter_oninit.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Przy dziedziczeniu z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy i zastąpień karty <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" /> , karta musi wywołanie metody odpowiedniej metody klasy podstawowej, która z kolei wywołuje <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> metody. Jeśli <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> nie jest wywoływana metoda, <see cref="E:System.Web.UI.Control.Init" /> zdarzenie nie zostanie wygenerowany.</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <altmember cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoad : EventArgs -&gt; unit&#xA;override this.OnLoad : EventArgs -&gt; unit" Usage="controlAdapter.OnLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zastępuje <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> metodę skojarzony formant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku karta jest podłączona do <xref:System.Web.UI.Control> obiektu i <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> metoda zostanie przesłonięta, zamiast wywoływana jest metoda zastąpienie <xref:System.Web.UI.Control.OnLoad%2A?displayProperty=nameWithType> metody.  
  
 Zastąpienie <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> metodę w celu przetwarzania specyficznych dla obiektu docelowego w `Load` etap cyklu kontrolki. Zazwyczaj są funkcje, które powinny być wykonywane dla każdego żądania klienta.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Przy dziedziczeniu z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy i zastąpień karty <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" /> , karta musi wywołanie metody odpowiedniej metody klasy podstawowej, która z kolei wywołuje <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> metody. Jeśli <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> nie jest wywoływany <see cref="E:System.Web.UI.Control.Load" /> zdarzenie nie zostanie wygenerowany.</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Load" />
        <altmember cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreRender : EventArgs -&gt; unit&#xA;override this.OnPreRender : EventArgs -&gt; unit" Usage="controlAdapter.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zastępuje <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> metodę skojarzony formant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku karta jest podłączona do <xref:System.Web.UI.Control> obiektu i <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> metoda zostanie przesłonięta, zamiast wywoływana jest metoda zastąpienie <xref:System.Web.UI.Control.OnPreRender%2A?displayProperty=nameWithType> metody.  
  
 Zastąpienie <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> metodę w celu przetwarzania specyficznych dla obiektu docelowego w `PreRender` etap cyklu kontrolki. Zazwyczaj są funkcje, które bezpośrednio poprzedzać renderowania formantu danych wyjściowych.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Przy dziedziczeniu z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy i zastąpień karty <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" /> , karta musi wywołanie metody odpowiedniej metody klasy podstawowej, która z kolei wywołuje <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> metody. Jeśli <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> nie jest wywoływana metoda, <see cref="E:System.Web.UI.Control.PreRender" /> zdarzenie nie zostanie wygenerowany.</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <altmember cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnload : EventArgs -&gt; unit&#xA;override this.OnUnload : EventArgs -&gt; unit" Usage="controlAdapter.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zastępuje <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> metodę skojarzony formant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku karta jest podłączona do <xref:System.Web.UI.Control> obiektu i <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> metoda zostanie przesłonięta, zamiast wywoływana jest metoda zastąpienie <xref:System.Web.UI.Control.OnUnload%2A?displayProperty=nameWithType> metody.  
  
 Zastąpienie <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> metody w tym przetwarzanie specyficznych dla obiektu docelowego w `Unload` etap cyklu kontrolki. Zazwyczaj są to funkcje oczyszczania, które należy poprzedzić dyspozycji formantu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Przy dziedziczeniu z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy i zastąpień karty <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" /> , karta musi wywołanie metody odpowiedniej metody klasy podstawowej, która z kolei wywołuje <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> metody. Jeśli <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> nie jest wywoływany <see cref="E:System.Web.UI.Control.Unload" /> zdarzenie nie zostanie wygenerowany.</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Unload" />
        <altmember cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Page Page { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Page As Page" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Page ^ Page { System::Web::UI::Page ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Page : System.Web.UI.Page" Usage="System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do strony, na którym znajduje się formantu skojarzony z tą kartą.</summary>
        <value>A <see cref="T:System.Web.UI.Page" /> , który zapewnia dostęp do wystąpienia page, w którym znajduje się skojarzony formant.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.Page%2A> Właściwości zapewnia dostęp do <xref:System.Web.UI.Page?displayProperty=nameWithType> obiektu, w którym znajduje się kontrolka.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property PageAdapter As PageAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Adapters::PageAdapter ^ PageAdapter { System::Web::UI::Adapters::PageAdapter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageAdapter : System.Web.UI.Adapters.PageAdapter" Usage="System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do karty strony dla strony, gdzie znajduje się skojarzony formant.</summary>
        <value>A <see cref="T:System.Web.UI.Adapters.PageAdapter" /> dla strony, gdzie formantu skojarzony z bieżącym <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> znajduje się.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> Właściwości zapewnia dostęp do <xref:System.Web.UI.Adapters.PageAdapter?displayProperty=nameWithType> obiekt do <xref:System.Web.UI.Page> obiektu gdzie <xref:System.Web.UI.Control> obiekt skojarzony z bieżącym <xref:System.Web.UI.Adapters.ControlAdapter> znajduje się obiekt.  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> Właściwości można uzyskiwać dostęp do innych elementów na poziomie strony karty, takie jak typowych funkcji specyficznych dla obiektu docelowego, które można zastosować do kilku typów kontrolki na stronie.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Adapters.PageAdapter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Render : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" /> Na potrzeby danych wyjściowych specyficznych dla obiektu docelowego renderowania.</param>
        <summary>Generuje kod znaczników specyficznych dla obiektu docelowego dla formantu, do której jest dołączona karty formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastąpienie <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> metodę, aby wygenerować kod znaczników specyficznych dla obiektu docelowego do wysłania do przeglądarki klienta. <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> Metoda jest wywoływana zamiast <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> metody Jeśli <xref:System.Web.UI.Adapters.ControlAdapter> obiekt jest dołączony do <xref:System.Web.UI.Control> obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Przy dziedziczeniu z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> podstawowa wywołania metody <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> metody. W związku z tym zastąpień o <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> powinny wywoływać metodę <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> podstawowa metoda tylko wtedy, gdy jego przetwarzanie dodatkowe, a nie zamiast <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> metody.  Formantu złożonego developer karty musi zapewniać renderowania formantów podrzędnych. Jeśli <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> metody powoduje, że kontrolki do renderowania elementu podrzędnego, ale nie generuje kod znaczników, może być odpowiednie dla <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> metodę do wywołania jego metody podstawowej. Jeśli konieczne jest specyficznych dla obiektu docelowego renderowania formantów podrzędnych, powinien implementować karta <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> — metoda i wywołanie <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> metody z <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> — metoda.</para>
        </block>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RenderChildren (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.RenderChildren writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" /> Na potrzeby danych wyjściowych specyficznych dla obiektu docelowego renderowania.</param>
        <summary>Generuje kod znaczników specyficznych dla obiektu docelowego dla formantów podrzędnych w formancie złożonego, do której jest dołączona formantu karty.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastąpienie <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> metody, gdy jest to konieczne do wygenerowania znaczników specyficznych dla obiektu docelowego dla zestawu formant podrzędny formantu złożonego, oprócz znaczników dla formantów podrzędnych poszczególnych.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Przy dziedziczeniu z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy dla formantu złożonego developer karty musi zapewnić renderowania formantów podrzędnych. Jeśli karta zastępuje <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> metody powinny wywoływać <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> metody z zastępująca <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> metody.  Jeśli <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> metody powoduje, że kontrolki do renderowania elementu podrzędnego, ale sam nie generuje kod znaczników, może być odpowiednie dla <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> metodę do wywołania metody podstawowej, która wywołuje <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> metody, zamiast zaimplementowanie przesłonięcia dla <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> metody.</para>
        </block>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterControlState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterControlState : unit -&gt; obj&#xA;override this.SaveAdapterControlState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapisuje kontrolować informacje o stanie dla formantu karty.</summary>
        <returns>
          <see cref="T:System.Object" /> Zawierający informacje o stanie formantu karty jako <see cref="T:System.Web.UI.StateBag" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Stan kontrolki jest informacje o stanie niezbędne potrzebne, nawet jeśli stan widoku jest wyłączone. Jeśli karta musi zachować informacje kontroli stanu, można zastąpić <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> i <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> metody.  
  
 Karta może być konieczne przechowuje informacji o stanie kontroli, gdy są funkcje, które muszą mieć stan przechowywanych w wielu żądań, niezależnie od stanu skojarzonym formancie. Na przykład formantu złożonego składające się z dużych wyświetlania tekstową i grupy <xref:System.Web.UI.WebControls.RadioButton> formanty może spowodować, że jako pojedynczy w przeglądarkach komputera stacjonarnego. W innych przeglądarkach mogą podzielić renderowania — jeden widok dla tekstową wyświetlania, a druga w grupie przycisków radiowych. Karta potrzebny do obsługi własnych informacji specyficznych dla obiektu docelowego o aktualnie aktywny widok.  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> Metoda jest wywoływana bezpośrednio po <xref:System.Web.UI.Control.SaveControlState%2A?displayProperty=nameWithType> metoda `SaveState` etap cyklu życia. Stan formantu karty jest oddzielne i oprócz stan formantu formantu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterViewState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterViewState : unit -&gt; obj&#xA;override this.SaveAdapterViewState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapisuje Wyświetl informacje o stanie dla formantu karty.</summary>
        <returns>
          <see cref="T:System.Object" /> Zawierający informacje o stanie widoku karty jako <see cref="T:System.Web.UI.StateBag" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy adaptera musi zachować informacje widok stanu, można zastąpić <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> i <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> metody.  
  
 Karta musi zachować informacje o stanie widoku po dane, które muszą zostać zachowane żądań, niezależnie od stan widoku skojarzonego formantu. Na przykład formantu siatki w przeglądarkach, komputerów stacjonarnych może spowodować, że jako pojedynczego widoku wierszy i kolumn wartości. W innych przeglądarkach może ją podzielić renderowania do wielu oddzielnych widoków, takich jak lista wierszy i szczegółowe informacje o jeden wiersz. Karta potrzebny do przechowywania danych dla widoków, które nie są aktualnie aktywne w widoku stanu.  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> Metoda jest wywoływana bezpośrednio przed <xref:System.Web.UI.Control.SaveViewState%2A?displayProperty=nameWithType> metoda `SaveState` etap cyklu życia. Stan widoku karty jest osobnym oraz stan widoku formantu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
  </Members>
</Type>
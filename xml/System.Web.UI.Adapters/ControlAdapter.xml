<Type Name="ControlAdapter" FullName="System.Web.UI.Adapters.ControlAdapter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="12b7cdc33437e3ecb53d715e213ce9bb8138c4e0" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39930830" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ControlAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ControlAdapter extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Adapters.ControlAdapter" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ControlAdapter" />
  <TypeSignature Language="C++ CLI" Value="public ref class ControlAdapter abstract" />
  <TypeSignature Language="F#" Value="type ControlAdapter = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Dostosowuje renderowania dla formantu pochodnej, do której jest dołączona karta, aby zmodyfikować domyślne znaczników lub zachowanie przeglądarki, i jest klasą bazową, z których wszystkie kontrolki dziedziczą kart.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontrolki karty są składniki, które zastępują pewnych <xref:System.Web.UI.Control> klasy, metody i zdarzenia w jego cyklu życia wykonywania, aby umożliwić przeglądarki lub obsługi specyficznej dla znaczników. .NET Framework mapuje karty jeden formant pochodnej <xref:System.Web.UI.Control> obiekt dla każdego żądania klienta.  
  
 Adapter modyfikuje kontroli dla przeglądarki lub klasa przeglądarki lub działa jako dowolnego przefiltruj niektóre możliwości. Zazwyczaj karty jest zdefiniowany przez język znaczników, który korzysta z przeglądarki (na przykład XHTML lub HTML 3.2). Większość przystosowanie w zachowaniu renderowania są umieszczane w klasach specjalne, które wynikają z <xref:System.Web.UI.HtmlTextWriter> klasy. W związku z tym, istnieje prawdopodobieństwo, że pojedyncza karta mogą być używane dla liczby zachowania klasy przeglądarki lub że włączenia zdolności adaptacyjnych w <xref:System.Web.UI.HtmlTextWriter> klasy może spowodować, że użycie karty Kontrola niepotrzebne.  
  
 Adapter dla klasy kontrolki ma zastosowanie do wszystkich formantów, które dziedziczą z klasy, chyba że istnieją bardziej wyspecjalizowane kart. Na przykład karta dla <xref:System.Web.UI.WebControls.BaseValidator> klasa może być używana dla wszystkich `Validator` obiektów.  
  
 Kart sieciowych zwykle nie dziedziczą bezpośrednio <xref:System.Web.UI.Adapters.ControlAdapter> klasy, ale z jednej karty specyficznych dla obiektu docelowego podstawowej klasy, które zapewniają dodatkowe funkcje specyficzne dla kontrolki typu i docelowej przeglądarki lub wymagane określonego renderowania.  
  
 Formanty sami nie muszą mieć karty. Jeśli kontrolki jest rozszerzony dzięki kompozycji, ogólnie rzecz biorąc adapterów kontrolek podrzędnych są wystarczające.  
  
 Każda kontrolka ma jawnego mapowania do kart sieciowych za pośrednictwem .browser plików definicji. W efekcie żadnego dostępu do <xref:System.Web.UI.Control.Adapter%2A?displayProperty=nameWithType> używa właściwości <xref:System.Web.HttpBrowserCapabilities> obiektu wyodrębnionych z plików definicji przeglądarki do wyszukiwania dla mapowania kart do formantu.  
  
 Podczas przetwarzania w programie .NET Framework przechwytuje wywołania możliwym do zastąpienia metody formant, który może być specyficznych dla obiektu docelowego. Jeśli karta kontroli jest dołączona, .NET Framework wywołuje metody skojarzone karty.  
  
 Karta wykonuje renderowania dla formantu za pomocą <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> metody. Jeśli je przesłonięto, <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> potencjalnie nie powinien wywoływać implementację klasy podstawowej, ponieważ wywołanie, wykonuje na <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> metody. Może to powodować renderowania występuje dwa razy, jeden raz przez kartę i jeden raz przez kontrolkę.  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> Podstawy wywołania metody <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> metoda formantu. W związku z tym Jeśli zastąpisz <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>, nie powinien wywoływać implementację klasy bazowej, chyba że renderowania, należy zaimplementować oprócz tego są dostarczane przez <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> formantu.  
  
 Należy się upewnić, że .NET Framework wykonuje przejmowanie kart formantów podrzędnych. Można to zrobić, wywołując <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> podstawowa metoda, która wywołuje <xref:System.Web.UI.Control.RenderChildren%2A?displayProperty=nameWithType> metoda kontrolki z Twojej <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> zastąpienia.  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> i <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> metody są wywoływane przez formant bezpośrednio przed i po nim (odpowiednio) kontrolki wywołuje <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> metody. Jeśli przed i po renderowania są tylko określone przeglądarki zadania przetwarzania wymagane, za pomocą <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> i <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> może być konieczne zastąpienie <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>. Domyślne zachowanie <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> i <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> metody jest wywołanie odpowiedniej metody <xref:System.Web.UI.HtmlTextWriter>.  
  
 Aby zachować swoje własne informacje o stanie, można zastąpić karty Kontrola <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, i <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> metody. <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, i <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> są wywoływane, gdy prywatnej stany kontrolka i widok zapisywania i załadowany, odpowiednio.  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>, I <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> podstawowa wywołanie metody ponownie w odpowiedniej <xref:System.Web.UI.Control> metody klasy. W efekcie któregoś z powyższych <xref:System.Web.UI.Adapters.ControlAdapter> metod, które są zastępowane musi wywołać ich metod bazowych; w przeciwnym razie zdarzenie skojarzone z <xref:System.Web.UI.Control> metody klasy nie zostaną wywołane.  
  
 Kontrolki i karty opcjonalnie zaimplementować <xref:System.Web.UI.IPostBackDataHandler> i <xref:System.Web.UI.IPostBackEventHandler> interfejsów. .NET Framework Określa, czy karta istnieje i czy karta implementuje te interfejsy. Jeśli tak jest, należy zastąpić karty <xref:System.Web.UI.IPostBackDataHandler.LoadPostData%2A>, <xref:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent%2A>, i <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> metod, zgodnie z potrzebami. Jeśli zwrotu danych nie jest rozpoznawany w karcie, musi on wywołania zwrotnego w kontrolce go przetworzyć. Programy obsługi zdarzeń kolejnych również musi wywołania zwrotnego w kontrolce.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Przy dziedziczeniu z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy, formant, który wymaga funkcji karty Ogólne powinny mieć odpowiednie karty, podstawowa klasę o nazwie we wzorcu <paramref name="ControlType" /><see langword="Adapter" /> (na przykład <see langword="TextBoxAdapter" />). Karta powinna co najmniej zwrócić wystąpienie silnie typizowane kontrolki za pomocą jego <see cref="P:System.Web.UI.Adapters.ControlAdapter.Control" /> właściwości.  1.  Kontrolowanie kart dla danej kontrolki typ i język znaczników powinno się nazywać we wzorcu <paramref name="MarkupControlType" /><see langword="Adapter" /> (na przykład <see langword="XhtmlTextBoxAdapter" />). Adaptery dla kontrolki powinny być zrealizowane w <see langword="Adapters" /> subnamespace.  Adapterów kontrolek powinien dziedziczyć z odpowiedniej klasy podstawowej i postępuj zgodnie z tego samego modelu dziedziczenia w postaci formantu. Na przykład karty dziedziczenie z kontrolki <see cref="T:System.Web.UI.Control" /> klasy bazowej powinien dziedziczyć albo <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy lub odpowiedniego <paramref name="ControlType" /><see langword="Adapter" /> klasy.  Wyspecjalizowane kontrolki, w obszarze wszystkie węzły urządzeń w plikach .browser konfiguracji należy zdefiniować żadnych specjalnych kart.  Właściwie zaimplementowana kontroli nie należy zakładać, że karta jest podłączona lub że dołączonych karty implementuje określonego interfejsu. Zamiast tego należy sprawdzić te przed wywołaniem.  Istnieje możliwość zasymulować, takie jak zastąpienie metody zdarzenie chronione w kontrolce <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> metody <see cref="T:System.Web.UI.WebControls.LinkButton" />. Najpierw należy utworzyć klasę karty z <c>OnClick</c> metody. Następnie utwórz nowy formant pochodzące z <see cref="T:System.Web.UI.WebControls.LinkButton" /> i zastąpić <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> metody. Zastąpiony <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> wywołania metody <c>OnClick</c> metoda karty sieciowej. Obiekt karta jest dostępna za pośrednictwem chronionego <see cref="P:System.Web.UI.Control.Adapter" /> właściwość <see cref="T:System.Web.UI.Control" /> klasy. <see cref="P:System.Web.UI.Control.Adapter" /> Jest właściwością kontrolki <see langword="null" /> gdy nie ma żadnych skojarzonych karty, więc jakiegokolwiek kodu powinna sprawdzać, czy tego warunku przed wywołaniem metody karty.</para>
    </block>
    <altmember cref="T:System.Web.UI.Control" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ControlAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ControlAdapter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas tworzenia odpowiedniego środowiska .NET Framework wewnętrznie tworzy tej karty <xref:System.Web.UI.Control> obiektu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="BeginRender">
      <MemberSignature Language="C#" Value="protected internal virtual void BeginRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void BeginRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub BeginRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void BeginRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.BeginRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" /> Zawierający metody do danych wyjściowych specyficznych dla obiektu docelowego renderowania.</param>
        <summary>Wywoływane przed renderowanie formantu. W klasie pochodnej karty generuje otwarcia tagów, które są wymagane przez określony element docelowy, ale nie jest wymagany przez przeglądarki HTML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> Metoda jest wywoływana tuż przed <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> metody i jest używany do wykonywania określonych docelowych przetwarzania wstępnego przed renderowanie formantu.  
  
 Użyj <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> metody w połączeniu z <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> metodę, aby upewnić się, otwierające i zamykające spójność tagów.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Przy dziedziczeniu z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> podstawowa metoda wywołuje metodę <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> metody. Zatem przesłonięć o <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> powinny wywoływać metodę <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> podstawowa metoda tylko wtedy, gdy jego przetwarzania oprócz zamiast zamiast <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> metody.</para>
        </block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="protected System.Web.HttpBrowserCapabilities Browser { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Browser : System.Web.HttpBrowserCapabilities" Usage="System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do funkcji przeglądarki klienta, dzięki czemu bieżącego żądania HTTP.</summary>
        <value>
          <see cref="T:System.Web.HttpBrowserCapabilities" /> Określenie możliwości klienta przeglądarki i znaczników.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Web.UI.Adapters.ControlAdapter> obiektu określa możliwości przeglądarki klienta z <xref:System.Web.HttpBrowserCapabilities> obiektu, który jest zwracany przez <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> właściwości. Dzięki temu <xref:System.Web.UI.Adapters.ControlAdapter> obiektu do renderowania kodu znaczników specyficzne dla przeglądarki lub inny sposób zmodyfikować zachowanie <xref:System.Web.UI.Control>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> właściwość, aby przeglądać szczegółowe informacje z przeglądarki. W tym przykładzie kod sprawdza czy przeglądarka jest zgodny z użyciem języka JavaScript, a następnie umożliwia deweloperowi renderowania dostosowanych danych wyjściowych w takim przypadku.  
  
 [!code-cpp[ControlAdapter_Browser#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_Browser/CPP/controladapter_browser.cpp#1)]
 [!code-csharp[ControlAdapter_Browser#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_Browser/CS/controladapter_browser.cs#1)]
 [!code-vb[ControlAdapter_Browser#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_Browser/VB/controladapter_browser.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="Control">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Control Control { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Control" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Control As Control" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Control ^ Control { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Control : System.Web.UI.Control" Usage="System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do formantu, do której jest dołączona ta karta kontroli.</summary>
        <value>
          <see cref="T:System.Web.UI.Control" /> Do którego należy to <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> jest dołączony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy karty pochodnej kontroli jest dołączony do formantu, .NET Framework wywołania niektórych członków karty zamiast członków kontroli.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje jak utworzyć pochodne formant niestandardowy z <xref:System.Web.UI.Control> klasy, a następnie utwórz odpowiednie karty, która dziedziczy <xref:System.Web.UI.Adapters.ControlAdapter> klasy. Karta zastępuje <xref:System.Web.UI.Adapters.ControlAdapter.Control%2A> właściwości i zwraca odwołanie do formantu silnie typizowane.  
  
 [!code-cpp[ControlAdapter.Control#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter.Control/CPP/controladapter.control.cpp#1)]
 [!code-csharp[ControlAdapter.Control#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter.Control/CS/controladapter.control.cs#1)]
 [!code-vb[ControlAdapter.Control#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter.Control/VB/controladapter.control.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Przy dziedziczeniu z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy, minimum, należy zaimplementować <see langword="Control" /> właściwość, aby zwrócić wystąpienie silnie typizowane kontrolki, jak pokazano w sekcji przykład.</para>
        </block>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected internal virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CreateChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CreateChildControls();" />
      <MemberSignature Language="F#" Value="abstract member CreateChildControls : unit -&gt; unit&#xA;override this.CreateChildControls : unit -&gt; unit" Usage="controlAdapter.CreateChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy element podrzędny określonego docelowego kontrolki złożonej kontrolki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku karty kontroli pochodne są dołączone do <xref:System.Web.UI.Control> obiektu i <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> metoda zostanie przesłonięta, zastąpienie jest wywoływana zamiast <xref:System.Web.UI.Control.CreateChildControls%2A?displayProperty=nameWithType> metody. W efekcie <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> może służyć do tworzenia zestaw formantów podrzędnych specyficznych dla obiektu docelowego.  
  
 Aby uzyskać więcej informacji na temat łączenia formantów, aby utworzyć nową kontrolkę, zobacz [formanty złożone](http://msdn.microsoft.com/library/fb174677-d845-467c-8bf3-cc096b2490b0).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Jeśli utworzysz klasie dziedziczącej i zastąpić <see cref="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" /> metody, czy nie wywołanie metody podstawowej, chyba że chcesz dodać formanty do tych utworzonych przez metody podstawowej. W przeciwnym razie można utworzyć dwa zestawy podrzędne kontrolki.</para>
        </block>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="EndRender">
      <MemberSignature Language="C#" Value="protected internal virtual void EndRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void EndRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub EndRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void EndRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member EndRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.EndRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.EndRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" /> Zawierający metody do danych wyjściowych specyficznych dla obiektu docelowego renderowania.</param>
        <summary>Wywoływane po renderowaniu kontrolki. W klasie pochodnej karty generuje zamykające znaczniki, które są wymagane przez określony element docelowy, ale nie jest wymagany przez przeglądarki HTML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> Metoda jest wywoływana zaraz po <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> metody i jest używany do wykonywania określonych docelowych postprocessing po renderowania formantu.  
  
 Użyj <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> metody w połączeniu z <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> metodę, aby upewnić się, otwierające i zamykające spójność tagów.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Przy dziedziczeniu z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> podstawowa metoda wywołuje metodę <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> metody. Zatem przesłonięć o <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> powinny wywoływać metodę <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> podstawowa metoda tylko wtedy, gdy jego przetwarzania oprócz zamiast zamiast <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> metody.</para>
        </block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.EndRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterControlState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterControlState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterControlState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterControlState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterControlState : obj -&gt; unit&#xA;override this.LoadAdapterControlState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterControlState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Object" /> Zawierający informacje o stanie kontrolki karty jako <see cref="T:System.Web.UI.StateBag" />.</param>
        <summary>Ładuje informacje stanu kontrolki karty, który został zapisany przez <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" /> podczas poprzedniego żądania do strony zawierającej kontrolki skojarzone z tą kartą kontrolki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Stan formantu jest potrzebny, nawet jeśli stan widoku jest wyłączone. informacje o stanie podstawowych. Gdy adapter musi utrzymywać własne informacje o stanie kontrolki, można zastąpić <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> i <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> metody.  
  
 Adapter może być konieczne do obsługi informacji o stanie kontroli w przypadku funkcji, które muszą mieć stan przechowywanych w wielu żądań, niezależnie od stanu skojarzonego formantu. Na przykład, kontrolki złożonej składające się z dużych wyświetlania tekstową i grupy <xref:System.Web.UI.WebControls.RadioButton> formantów może być renderowany jako pojedynczy widok na przeglądarki na komputery stacjonarne. W innych przeglądarkach może być podziału jej renderowania — jeden widok dla tekstową wyświetlania, a druga w grupie przycisków radiowych. Karta musi zachować swój własny informacji specyficznych dla obiektu docelowego o aktualnie aktywnego widoku.  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> Metoda jest wywoływana bezpośrednio po <xref:System.Web.UI.Control.LoadControlState%2A?displayProperty=nameWithType> metody w `LoadState` etapie cyklu życia. Stan formantu karty jest oddzielne i oprócz stan formantu formantu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterViewState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterViewState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterViewState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterViewState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterViewState : obj -&gt; unit&#xA;override this.LoadAdapterViewState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterViewState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Object" /> Zawierający informacje o stanie widoku karty jako <see cref="T:System.Web.UI.StateBag" />.</param>
        <summary>Ładuje karty informacje o stanie widoku zapisanego przez <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" /> podczas poprzedniego żądania do strony zawierającej kontrolki skojarzone z tą kartą kontrolki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dana karta musi utrzymywać własne informacje o stanie widoku, można zastąpić <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> i <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> metody.  
  
 Karta musi do obsługi informacji o stanie widoku w przypadku danych, która musi być utrzymywana na żądań, niezależnie od stanu widoku formant. Na przykład formantu siatki w przeglądarkach dla komputerów stacjonarnych może być renderowane jako pojedynczy widok wierszy i kolumn wartości. W innych przeglądarkach go może być podziału jej renderowania na wiele oddzielnych widoków, takich jak lista wierszy i szczegółowe informacje o jeden wiersz. Karta musi do obsługi danych dla widoków, które nie są aktualnie aktywne w widoku stanu.  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> Metoda jest wywoływana tuż przed <xref:System.Web.UI.Control.LoadViewState%2A?displayProperty=nameWithType> method in Class metoda `LoadState` etapie cyklu życia. Wyświetl stan karty jest oddzielne i oprócz stan widoku formantu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInit : EventArgs -&gt; unit&#xA;override this.OnInit : EventArgs -&gt; unit" Usage="controlAdapter.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zastępuje <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> metodę dla skojarzonego formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku karty dołączone do <xref:System.Web.UI.Control> obiektu i <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> metoda zostanie przesłonięta, zostanie wywołana metoda zastąpienie, zamiast <xref:System.Web.UI.Control.OnInit%2A?displayProperty=nameWithType> metody.  
  
 Zastąp <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> do wykonywania przetwarzania specyficznych dla obiektu docelowego w `Initialize` etap cyklu życia kontroli. Zazwyczaj są funkcje, które są wykonywane po utworzeniu kontrolki.  
  
   
  
## Examples  
 Poniższy przykładowy kod pochodzi z kartą kontrolki niestandardowej z <xref:System.Web.UI.Adapters.ControlAdapter> klasy. Następnie zastępuje <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> metodę, aby ustawić właściwości skojarzonego formantu i wywoływać metody podstawowej, aby zakończyć inicjowanie kontrolki.  
  
 [!code-cpp[ControlAdapter_OnInit#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_OnInit/CPP/controladapter_oninit.cpp#1)]
 [!code-csharp[ControlAdapter_OnInit#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_OnInit/CS/controladapter_oninit.cs#1)]
 [!code-vb[ControlAdapter_OnInit#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_OnInit/VB/controladapter_oninit.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Przy dziedziczeniu z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy i zastąpień karty <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" /> metody, karta musi wywołać odpowiedniej metody klasy bazowej, która z kolei wywołuje <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> metody. Jeśli <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> metoda nie jest wywoływana, <see cref="E:System.Web.UI.Control.Init" /> zdarzenia nie zostaną wywołane.</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <altmember cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoad : EventArgs -&gt; unit&#xA;override this.OnLoad : EventArgs -&gt; unit" Usage="controlAdapter.OnLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zastępuje <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> metodę dla skojarzonego formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku karty dołączone do <xref:System.Web.UI.Control> obiektu i <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> metoda zostanie przesłonięta, zostanie wywołana metoda zastąpienie, zamiast <xref:System.Web.UI.Control.OnLoad%2A?displayProperty=nameWithType> metody.  
  
 Zastąp <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> metodę w celu przetwarzania specyficznych dla obiektu docelowego w `Load` etap cyklu życia kontroli. Zazwyczaj są funkcje, które powinny być wykonywane dla każdego żądania klienta.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Przy dziedziczeniu z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy i zastąpień karty <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" /> metody, karta musi wywołać odpowiedniej metody klasy bazowej, która z kolei wywołuje <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> metody. Jeśli <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> nie jest wywoływana, <see cref="E:System.Web.UI.Control.Load" /> zdarzenia nie zostaną wywołane.</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Load" />
        <altmember cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreRender : EventArgs -&gt; unit&#xA;override this.OnPreRender : EventArgs -&gt; unit" Usage="controlAdapter.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zastępuje <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> metodę dla skojarzonego formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku karty dołączone do <xref:System.Web.UI.Control> obiektu i <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> metoda zostanie przesłonięta, zostanie wywołana metoda zastąpienie, zamiast <xref:System.Web.UI.Control.OnPreRender%2A?displayProperty=nameWithType> metody.  
  
 Zastąp <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> metodę w celu przetwarzania specyficznych dla obiektu docelowego w `PreRender` etap cyklu życia kontroli. Zazwyczaj są funkcje, które poprzedzają renderowanie kontrolki danych wyjściowych.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Przy dziedziczeniu z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy i zastąpień karty <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" /> metody, karta musi wywołać odpowiedniej metody klasy bazowej, która z kolei wywołuje <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> metody. Jeśli <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> metoda nie jest wywoływana, <see cref="E:System.Web.UI.Control.PreRender" /> zdarzenia nie zostaną wywołane.</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <altmember cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnload : EventArgs -&gt; unit&#xA;override this.OnUnload : EventArgs -&gt; unit" Usage="controlAdapter.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zastępuje <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> metodę dla skojarzonego formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku karty dołączone do <xref:System.Web.UI.Control> obiektu i <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> metoda zostanie przesłonięta, zostanie wywołana metoda zastąpienie, zamiast <xref:System.Web.UI.Control.OnUnload%2A?displayProperty=nameWithType> metody.  
  
 Zastąp <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> metody to wykonywać przetwarzanie specyficznych dla obiektu docelowego `Unload` etap cyklu życia kontroli. Zazwyczaj są to funkcje oczyszczania, które poprzedzają dyspozycji formantu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Przy dziedziczeniu z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy i zastąpień karty <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" /> metody, karta musi wywołać odpowiedniej metody klasy bazowej, która z kolei wywołuje <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> metody. Jeśli <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> nie jest wywoływana, <see cref="E:System.Web.UI.Control.Unload" /> zdarzenia nie zostaną wywołane.</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Unload" />
        <altmember cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Page Page { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Page As Page" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Page ^ Page { System::Web::UI::Page ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Page : System.Web.UI.Page" Usage="System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do strony zawierającej kontrolki skojarzone z tą kartą.</summary>
        <value>Element <see cref="T:System.Web.UI.Page" /> , który zapewnia dostęp do wystąpienia strony, w którym znajduje się skojarzonego formantu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.Page%2A> Właściwości zapewnia dostęp do <xref:System.Web.UI.Page?displayProperty=nameWithType> obiekt, w którym znajduje się kontrolka.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property PageAdapter As PageAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Adapters::PageAdapter ^ PageAdapter { System::Web::UI::Adapters::PageAdapter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageAdapter : System.Web.UI.Adapters.PageAdapter" Usage="System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do karty strony dla strony zawierającej skojarzonego formantu.</summary>
        <value>A <see cref="T:System.Web.UI.Adapters.PageAdapter" /> dla strony, gdzie kontrolki skojarzone z bieżącym <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> znajduje się.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> Właściwości zapewnia dostęp do <xref:System.Web.UI.Adapters.PageAdapter?displayProperty=nameWithType> dla obiektu <xref:System.Web.UI.Page> obiektu gdzie <xref:System.Web.UI.Control> obiekt skojarzony z bieżącym <xref:System.Web.UI.Adapters.ControlAdapter> znajduje się obiekt.  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> Właściwość może służyć do dostępu do innych elementów na poziomie karty strony, takie jak typowe funkcje specyficzne dla docelowych, które można zastosować do kilku typów kontrolki na stronie.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Adapters.PageAdapter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Render : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" /> Zostać użyty do wyświetlenia danych wyjściowych specyficznych dla obiektu docelowego.</param>
        <summary>Generuje znaczników specyficznych dla obiektu docelowego dla formantu, do której jest dołączona karta kontroli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastąp <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> metodę w celu wygenerowania znaczników specyficznych dla obiektu docelowego w celu wysłania do przeglądarki klienta. <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> Metoda jest wywoływana zamiast <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> metoda Jeśli <xref:System.Web.UI.Adapters.ControlAdapter> obiekt jest dołączony do <xref:System.Web.UI.Control> obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Przy dziedziczeniu z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> podstawowa metoda wywołuje metodę <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> metody. Zatem przesłonięć o <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> powinny wywoływać metodę <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> podstawowa metoda tylko wtedy, gdy jego przetwarzania oprócz zamiast zamiast <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> metody.  W przypadku złożonego formantu developer karty należy się upewnić, renderowania kontrolek podrzędnych. Jeśli <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> powoduje, że metoda elementu podrzędnego kontrolki do renderowania, ale nie generuje kod znaczników, może być odpowiednie dla <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> metodę do wywołania jej metody podstawowej. Jeśli konieczne jest specyficznych dla obiektu docelowego renderowania formantów podrzędnych, należy zaimplementować karty <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> metody i wywołania <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> metody z <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> metody.</para>
        </block>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RenderChildren (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.RenderChildren writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" /> Zostać użyty do wyświetlenia danych wyjściowych specyficznych dla obiektu docelowego.</param>
        <summary>Generuje znaczniki specyficznych dla obiektu docelowego dla formantów podrzędnych w kontrolce złożonego, do której jest dołączona karta kontroli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastąp <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> metody, gdy jest to konieczne, można wygenerować znaczników specyficznych dla obiektu docelowego dla zestawu kontrolki podrzędnej kontrolki złożonej oprócz znaczników dla formantów podrzędnych indywidualnych.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Przy dziedziczeniu z <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> klasy dla kontrolek złożonych developer karty należy upewnić się, renderowania kontrolek podrzędnych. Jeśli karta zastępuje <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> metody powinny wywoływać <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> z zastąpieniem metody <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> metody.  Jeśli <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> powoduje, że metoda elementu podrzędnego kontrolki do renderowania, ale sam nie generuje kod znaczników, może być odpowiednie dla <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> metodę do wywołania metody podstawowej, która wywołuje <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> metody, a nie Implementowanie zastąpienie <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> metody.</para>
        </block>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterControlState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterControlState : unit -&gt; obj&#xA;override this.SaveAdapterControlState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapisuje kontrolować informacje o stanie dla karty formantu.</summary>
        <returns>
          <see cref="T:System.Object" /> Zawierający informacje o stanie kontrolki karty jako <see cref="T:System.Web.UI.StateBag" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Stan formantu jest potrzebny, nawet jeśli stan widoku jest wyłączone. informacje o stanie podstawowych. Gdy adapter musi utrzymywać własne informacje o stanie kontrolki, można zastąpić <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> i <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> metody.  
  
 Adapter może być konieczne do obsługi informacji o stanie kontroli w przypadku funkcji, które muszą mieć stan przechowywanych w wielu żądań, niezależnie od stanu skojarzonego formantu. Na przykład, kontrolki złożonej składające się z dużych wyświetlania tekstową i grupy <xref:System.Web.UI.WebControls.RadioButton> formantów może być renderowany jako pojedynczy widok na przeglądarki na komputery stacjonarne. W innych przeglądarkach może być podziału jej renderowania — jeden widok dla tekstową wyświetlania, a druga w grupie przycisków radiowych. Karta musi zachować swój własny informacji specyficznych dla obiektu docelowego o aktualnie aktywnego widoku.  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> Metoda jest wywoływana bezpośrednio po <xref:System.Web.UI.Control.SaveControlState%2A?displayProperty=nameWithType> method in Class metoda `SaveState` etapie cyklu życia. Stan formantu karty jest oddzielne i oprócz stan formantu formantu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterViewState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterViewState : unit -&gt; obj&#xA;override this.SaveAdapterViewState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapisuje wyświetlić informacje o stanie dla karty formantu.</summary>
        <returns>
          <see cref="T:System.Object" /> Zawierający informacje o stanie widoku karty jako <see cref="T:System.Web.UI.StateBag" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dana karta musi utrzymywać własne informacje o stanie widoku, można zastąpić <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> i <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> metody.  
  
 Karta musi do obsługi informacji o stanie widoku w przypadku danych, która musi być utrzymywana na żądań, niezależnie od stanu widoku skojarzonego formantu. Na przykład formantu siatki w przeglądarkach dla komputerów stacjonarnych może być renderowane jako pojedynczy widok wierszy i kolumn wartości. W innych przeglądarkach go może być podziału jej renderowania na wiele oddzielnych widoków, takich jak lista wierszy i szczegółowe informacje o jeden wiersz. Karta musi do obsługi danych dla widoków, które nie są aktualnie aktywne w widoku stanu.  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> Metoda jest wywoływana tuż przed <xref:System.Web.UI.Control.SaveViewState%2A?displayProperty=nameWithType> method in Class metoda `SaveState` etapie cyklu życia. Wyświetl stan karty jest oddzielne i oprócz stan widoku formantu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
  </Members>
</Type>
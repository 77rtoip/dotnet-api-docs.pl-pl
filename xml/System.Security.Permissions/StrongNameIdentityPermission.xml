<Type Name="StrongNameIdentityPermission" FullName="System.Security.Permissions.StrongNameIdentityPermission">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a463af60ab4edfa6fe57431ad325d271e1f70c88" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30571894" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class StrongNameIdentityPermission : System.Security.CodeAccessPermission" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit StrongNameIdentityPermission extends System.Security.CodeAccessPermission" />
  <TypeSignature Language="DocId" Value="T:System.Security.Permissions.StrongNameIdentityPermission" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StrongNameIdentityPermission&#xA;Inherits CodeAccessPermission" />
  <TypeSignature Language="C++ CLI" Value="public ref class StrongNameIdentityPermission sealed : System::Security::CodeAccessPermission" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.CodeAccessPermission</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definiuje uprawnienia tożsamości dla silnej nazwy. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], uprawnienia dotyczące tożsamości nie są używane.  
>   
>  Wersje programu .NET Framework 1.0 i 1.1, nie mogą mieć uprawnienia dotyczące tożsamości <xref:System.Security.Permissions.PermissionState.Unrestricted> wartość stanu uprawnień. .NET Framework w wersji 2.0 lub nowszej uprawnienia dotyczące tożsamości mogą mieć dowolną wartość stanu uprawnień.  To oznacza, że w wersji 2.0 i nowszych wersjach uprawnienia dotyczące tożsamości ma takie samo zachowanie jako uprawnień, które implementują <xref:System.Security.Permissions.IUnrestrictedPermission> interfejsu. Oznacza to, że żądanie tożsamości zawsze zakończy się powodzeniem, niezależnie od tego, tożsamość zestawu, jeśli zestaw ma przyznane pełne zaufanie.  
  
 Użyj <xref:System.Security.Permissions.StrongNameIdentityPermission> aby potwierdzić, że kod wywołujący jest w zestawie określonego kodu o silnych nazwach. Pełne wymagania dla <xref:System.Security.Permissions.StrongNameIdentityPermission> powiedzie się tylko wtedy, gdy wszystkie zestawy w stosie poprawne dowód do zaspokojenia zapotrzebowania. Łącze wymaga używające <xref:System.Security.Permissions.StrongNameIdentityPermissionAttribute> atrybutu powiedzie się tylko wtedy, gdy poprawne dowód bezpośredniego obiektu wywołującego.  
  
 Tożsamość silnej nazwy jest oparta na kryptograficznych klucza publicznego o nazwie dużego obiektu binarnego (BLOB), która opcjonalnie jest połączona z nazwą i wersją określonego zestawu. Klucz definiuje unikatową przestrzeń nazw i udostępnia silną weryfikację, czy nazwa jest prawdziwe, ponieważ definicja nazwy musi znajdować się w zestawie, do którego jest podpisany przy użyciu odpowiedniego klucza prywatnego.  
  
 Należy pamiętać, że ważności klucza silnej nazwy jest niezależna w relacji zaufania lub dowolny certyfikat wystawiony niekoniecznie dla klucza.  
  
 W wersji systemu .NET Framework 1.0 i 1.1 wymagania dotyczące uprawnień tożsamości obowiązują nawet wtedy, gdy zestaw wywołujący jest w pełni zaufany. Oznacza to nawet wtedy, gdy zestaw wywołujący ma pełne zaufanie, zażąda uprawnień tożsamości kończy się niepowodzeniem, jeśli zestaw nie spełnia kryteriów żądane. W .NET Framework w wersji 2.0 lub nowszej, zapotrzebowanie na uprawnienia dotyczące tożsamości są nieskuteczne, jeśli zestaw wywołujący ma pełne zaufanie. To zapewnia spójności dla wszystkich uprawnień i eliminuje traktowanie uprawnienia dotyczące tożsamości w szczególnych przypadkach.  
  
 Aby uzyskać pełny opis silnych nazw, zobacz <xref:System.Security.Policy.StrongName> strony odwołania. Aby uzyskać więcej informacji na temat zestawów o silnych nazwach, zobacz [zestawy Strong-Named](~/docs/framework/app-domains/strong-named-assemblies.md).  
  
 <xref:System.Security.Permissions.StrongNameIdentityPermission> Klasa jest używana do definiowania silnej nazwy wymagania dotyczące uzyskiwania dostępu do publiczne elementy członkowskie typu. <xref:System.Security.Permissions.StrongNameIdentityPermissionAttribute> Atrybut może służyć do definiowania wymagań silnej nazwy na poziomie zestawu. W programie .NET Framework w wersji 2.0 lub nowszej, można również użyć <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> atrybut, aby określić, że wszystkie typy niepubliczne, w tym zestawie są widoczne dla innego zestawu. Aby uzyskać więcej informacji, zobacz [przyjazne zestawy](http://msdn.microsoft.com/library/df0c70ea-2c2a-4bdc-9526-df951ad2d055).  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Security.Permissions.StrongNameIdentityPermission" />
    <altmember cref="T:System.Security.Permissions.StrongNamePublicKeyBlob" />
    <altmember cref="T:System.Security.Policy.StrongName" />
    <altmember cref="T:System.Security.Policy.StrongNameMembershipCondition" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Permissions.StrongNameIdentityPermission" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StrongNameIdentityPermission (System.Security.Permissions.PermissionState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Security.Permissions.PermissionState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.StrongNameIdentityPermission.#ctor(System.Security.Permissions.PermissionState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (state As PermissionState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StrongNameIdentityPermission(System::Security::Permissions::PermissionState state);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="state" Type="System.Security.Permissions.PermissionState" />
      </Parameters>
      <Docs>
        <param name="state">Jeden z <see cref="T:System.Security.Permissions.PermissionState" /> wartości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Permissions.StrongNameIdentityPermission" /> klasy z określonym <see cref="T:System.Security.Permissions.PermissionState" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tworzy albo pełni ograniczeniami (`None`) lub `Unrestricted` uprawnienia.  
  
> [!NOTE]
>  Wersje programu .NET Framework 1.0 i 1.1, nie mogą mieć uprawnienia dotyczące tożsamości <xref:System.Security.Permissions.PermissionState.Unrestricted> wartość stanu uprawnień. .NET Framework w wersji 2.0 lub nowszej uprawnienia dotyczące tożsamości mogą mieć dowolną wartość stanu uprawnień.  To oznacza, że w wersji 2.0 i nowszych wersjach uprawnienia dotyczące tożsamości ma takie samo zachowanie jako uprawnień, które implementują <xref:System.Security.Permissions.IUnrestrictedPermission> interfejsu. Oznacza to, że żądanie tożsamości zawsze zakończy się powodzeniem, niezależnie od tego, tożsamość zestawu, jeśli zestaw ma przyznane pełne zaufanie.  
  
 W wersji systemu .NET Framework 1.0 i 1.1 wymagania dotyczące uprawnień tożsamości obowiązują, nawet wtedy, gdy zestaw wywołujący jest w pełni zaufany. Oznacza to mimo że zestaw wywołujący ma pełne zaufanie, zażąda uprawnień tożsamości wynik negatywny, jeśli zestaw nie spełnia kryteriów żądane. W .NET Framework w wersji 2.0 lub nowszej, zapotrzebowanie na uprawnienia dotyczące tożsamości są nieskuteczne, jeśli zestaw wywołujący ma pełne zaufanie. Zapewnia to spójność wszystkie uprawnienia, eliminując traktowanie uprawnienia dotyczące tożsamości w szczególnych przypadkach.  
  
 Użyj tego konstruktora z wartością stanu uprawnień <xref:System.Security.Permissions.PermissionState.None> można utworzyć uprawnienia tożsamości odpowiadający nie silnych nazw. Jeśli ustawisz następnie <xref:System.Security.Permissions.StrongNameIdentityPermission.Name%2A> i <xref:System.Security.Permissions.StrongNameIdentityPermission.Version%2A> tożsamości określonej silnej nazwy właściwości może być reprezentowany przez uprawnienia.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Security.Permissions.StrongNameIdentityPermission.%23ctor%2A> konstruktora.  
  
 [!code-cpp[System.Security.Permissions.StrongNameIdentityPermission#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CPP/strongnameidentity.cpp#7)]
 [!code-csharp[System.Security.Permissions.StrongNameIdentityPermission#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CS/strongnameidentity.cs#7)]
 [!code-vb[System.Security.Permissions.StrongNameIdentityPermission#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/VB/strongnameidentity.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="state" /> Parametr nie jest prawidłową wartością <see cref="T:System.Security.Permissions.PermissionState" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StrongNameIdentityPermission (System.Security.Permissions.StrongNamePublicKeyBlob blob, string name, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Permissions.StrongNamePublicKeyBlob blob, string name, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.StrongNameIdentityPermission.#ctor(System.Security.Permissions.StrongNamePublicKeyBlob,System.String,System.Version)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StrongNameIdentityPermission(System::Security::Permissions::StrongNamePublicKeyBlob ^ blob, System::String ^ name, Version ^ version);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="blob" Type="System.Security.Permissions.StrongNamePublicKeyBlob" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="version" Type="System.Version" />
      </Parameters>
      <Docs>
        <param name="blob">Klucz publiczny definiujący przestrzeń nazw tożsamości silnej nazwy.</param>
        <param name="name">Prosta nazwa część tożsamości silnej nazwy. Odpowiada to nazwa zestawu.</param>
        <param name="version">Numer wersji tożsamości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Permissions.StrongNameIdentityPermission" /> klasy dla określonej nazwy silnej tożsamości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `name` i `version` parametry mogą być `null` tylko, jeśli klucz publiczny używany do identyfikowania zestawu. Ciąg pusty ("") nie powinna być używana zamiast `null`. Jeśli `name` to ciąg pusty <xref:System.ArgumentException> jest generowany.  
  
 Aby uzyskać więcej informacji dotyczących nazwy i numery wersji zestawów, zobacz [zestawy Strong-Named](~/docs/framework/app-domains/strong-named-assemblies.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Security.Permissions.StrongNameIdentityPermission.%23ctor%2A> konstruktora.  
  
 [!code-cpp[System.Security.Permissions.StrongNameIdentityPermission#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CPP/strongnameidentity.cpp#8)]
 [!code-csharp[System.Security.Permissions.StrongNameIdentityPermission#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CS/strongnameidentity.cs#8)]
 [!code-vb[System.Security.Permissions.StrongNameIdentityPermission#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/VB/strongnameidentity.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="blob" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> Parametr jest pustym ciągiem ("").</exception>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public override System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.StrongNameIdentityPermission.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Copy () As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::IPermission ^ Copy();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy i zwraca identyczne kopię bieżącego uprawnień.</summary>
        <returns>Kopię bieżącego uprawnień.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kopię uprawnienie reprezentuje takie same prawa dostępu do zasobów oryginalnego uprawnienia.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia zachowanie <xref:System.Security.Permissions.StrongNameIdentityPermission.Copy%2A> metody. Ten przykład jest częścią większego przykładu udostępnionego dla <xref:System.Security.Permissions.StrongNameIdentityPermission> klasy. Najlepsze korzystanie w tym przykładzie jest do tworzenia i wykonać całą przykład i wyświetlić dane wyjściowe.  
  
> [!NOTE]
>  Przykładowy kod ma na celu Pokaż zachowanie metody, nie, aby zademonstrować jej użycia. Ogólnie rzecz biorąc metod klas uprawnienia są używane przez infrastrukturę zabezpieczeń; ich nie są zwykle używane w aplikacji.  
  
 [!code-cpp[System.Security.Permissions.StrongNameIdentityPermission#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CPP/strongnameidentity.cpp#5)]
 [!code-csharp[System.Security.Permissions.StrongNameIdentityPermission#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CS/strongnameidentity.cs#5)]
 [!code-vb[System.Security.Permissions.StrongNameIdentityPermission#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/VB/strongnameidentity.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromXml">
      <MemberSignature Language="C#" Value="public override void FromXml (System.Security.SecurityElement e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void FromXml(class System.Security.SecurityElement e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.StrongNameIdentityPermission.FromXml(System.Security.SecurityElement)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub FromXml (e As SecurityElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void FromXml(System::Security::SecurityElement ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Security.SecurityElement" />
      </Parameters>
      <Docs>
        <param name="e">Kodowanie XML na potrzeby rekonstrukcji uprawnienia.</param>
        <summary>Rekonstruuje uprawnienie o określonym stanie kodowania XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest używana przez kod aplikacji.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia zachowanie <xref:System.Security.Permissions.StrongNameIdentityPermission.FromXml%2A> metody. Ten przykład jest częścią większego przykładu udostępnionego dla <xref:System.Security.Permissions.StrongNameIdentityPermission> klasy. Najlepsze korzystanie w tym przykładzie jest do tworzenia i wykonać całą przykład i wyświetlić dane wyjściowe.  
  
> [!NOTE]
>  Przykładowy kod ma na celu Pokaż zachowanie metody, nie, aby zademonstrować jej użycia. Ogólnie rzecz biorąc metod klas uprawnienia są używane przez infrastrukturę zabezpieczeń; ich nie są zwykle używane w aplikacji.  
  
 [!code-cpp[System.Security.Permissions.StrongNameIdentityPermission#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CPP/strongnameidentity.cpp#6)]
 [!code-csharp[System.Security.Permissions.StrongNameIdentityPermission#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CS/strongnameidentity.cs#6)]
 [!code-vb[System.Security.Permissions.StrongNameIdentityPermission#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/VB/strongnameidentity.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="e" /> Parametr nie jest elementem prawidłowego uprawnienia.  
  
 —lub—  
  
 <paramref name="e" /> Parametru numer wersji jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public override System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.StrongNameIdentityPermission.Intersect(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Intersect (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::IPermission ^ Intersect(System::Security::IPermission ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Uprawnienie do intersect z uprawnieniami bieżącego. Należy tego samego typu co bieżący uprawnień.</param>
        <summary>Tworzy i zwraca uprawnienia, które jest przecięcia bieżące uprawnienia i określony.</summary>
        <returns>Nowe uprawnienia, które reprezentuje przecięciu bieżące uprawnienia i określonego uprawnienia lub <see langword="null" /> Jeśli część wspólną jest pusta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Część wspólną dwóch uprawnień jest uprawnienia, które opisano zestaw działań, które opisują one zarówno wspólnych. Tylko zażąda przekazuje oba oryginalnego uprawnienia zostaną spełnione przecięcie.  
  
 Część wspólną dwóch uprawnienia tożsamości identyczne silnej nazwy jest to uprawnienie. Część wspólną dwóch różnych (nie symbol wieloznaczny) wyrażenia jest pusty uprawnień. Przecięcia wyrażenia z symbolami wieloznacznymi i pasujące silnej nazwy jest silnej nazwy. Część wspólną dwóch wyrażeń wieloznacznych zgodne jest dłuższy, bardziej szczegółowe dwóch wyrażeń.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wyniki stosowania <xref:System.Security.Permissions.StrongNameIdentityPermission.Intersect%2A> metody, nie jak użyć tej metody. Ten przykład jest częścią większego przykładu udostępnionego dla <xref:System.Security.Permissions.StrongNameIdentityPermission> klasy. Najlepsze korzystanie w tym przykładzie jest do tworzenia i wykonać całą przykład i wyświetlić dane wyjściowe.  
  
> [!NOTE]
>  Przykładowy kod ma na celu Pokaż zachowanie metody, nie, aby zademonstrować jej użycia. Ogólnie rzecz biorąc metod klas uprawnienia są używane przez infrastrukturę zabezpieczeń; ich nie są zwykle używane w aplikacji.  
  
 [!code-cpp[System.Security.Permissions.StrongNameIdentityPermission#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CPP/strongnameidentity.cpp#4)]
 [!code-csharp[System.Security.Permissions.StrongNameIdentityPermission#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CS/strongnameidentity.cs#4)]
 [!code-vb[System.Security.Permissions.StrongNameIdentityPermission#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/VB/strongnameidentity.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> Parametr nie jest <see langword="null" /> i nie jest taki sam typ jak bieżące uprawnienia.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public override bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.StrongNameIdentityPermission.IsSubsetOf(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsSubsetOf (target As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsSubsetOf(System::Security::IPermission ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Uprawnienia, które ma być sprawdzane pod kątem relacji podzbioru. To uprawnienie musi być tego samego typu co bieżący uprawnień.</param>
        <summary>Określa, czy bieżące uprawnienia podzbiór określonego uprawnienia.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżące uprawnienia są podzbiorem określonego uprawnienia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżące uprawnienia jest podzbiorem określonego uprawnienia, jeśli uprawnienia bieżącego określa zestaw operacji jest całkowicie zawarty w określonego uprawnienia. Na przykład inne właściwości są takie same, tożsamość <xref:System.Security.Permissions.StrongNameIdentityPermission.Name%2A> zawierające wyrażenia z symbolami wieloznacznymi MyCompany.MyDepartment.* właściwości jest rozpoznawany jako podzbiór tożsamość <xref:System.Security.Permissions.StrongNameIdentityPermission.Name%2A> właściwości MyCompany.MyDepartment.MyFile .  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wyniki stosowania <xref:System.Security.Permissions.StrongNameIdentityPermission.IsSubsetOf%2A> metody, nie jak użyć tej metody. Ten przykład jest częścią większego przykładu udostępnionego dla <xref:System.Security.Permissions.StrongNameIdentityPermission> klasy. Najlepsze korzystanie w tym przykładzie jest do tworzenia i wykonać całą przykład i wyświetlić dane wyjściowe.  
  
> [!NOTE]
>  Przykładowy kod ma na celu Pokaż zachowanie metody, nie, aby zademonstrować jej użycia. Ogólnie rzecz biorąc metod klas uprawnienia są używane przez infrastrukturę zabezpieczeń; ich nie są zwykle używane w aplikacji.  
  
 [!code-cpp[System.Security.Permissions.StrongNameIdentityPermission#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CPP/strongnameidentity.cpp#2)]
 [!code-csharp[System.Security.Permissions.StrongNameIdentityPermission#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CS/strongnameidentity.cs#2)]
 [!code-vb[System.Security.Permissions.StrongNameIdentityPermission#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/VB/strongnameidentity.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> Parametr nie jest <see langword="null" /> i nie jest taki sam typ jak bieżące uprawnienia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Security.Permissions.StrongNameIdentityPermission.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia części prostą nazwą identity silnej nazwy.</summary>
        <value>Prosta nazwa tożsamości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.Security.Permissions.StrongNameIdentityPermission.Name%2A> właściwość może być dokładną nazwę lub może być modyfikowany przez symbolu wieloznacznego w ostatnim miejscu, na przykład zarówno MyCompany.MyDepartment.MyFile i MyCompany.MyDepartment.* są prawidłowe nazwy. Jeśli spróbujesz ustawić <xref:System.Security.Permissions.StrongNameIdentityPermission.Name%2A> właściwości na ciąg pusty (""), <xref:System.ArgumentException> jest generowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość jest pustym ciągiem ("").</exception>
        <exception cref="T:System.NotSupportedException">Nie można pobrać wartości właściwości, ponieważ zawiera ona niejednoznaczna tożsamości.</exception>
      </Docs>
    </Member>
    <Member MemberName="PublicKey">
      <MemberSignature Language="C#" Value="public System.Security.Permissions.StrongNamePublicKeyBlob PublicKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Permissions.StrongNamePublicKeyBlob PublicKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Permissions.StrongNameIdentityPermission.PublicKey" />
      <MemberSignature Language="VB.NET" Value="Public Property PublicKey As StrongNamePublicKeyBlob" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Permissions::StrongNamePublicKeyBlob ^ PublicKey { System::Security::Permissions::StrongNamePublicKeyBlob ^ get(); void set(System::Security::Permissions::StrongNamePublicKeyBlob ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Permissions.StrongNamePublicKeyBlob</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia publicznego klucza obiektu blob, definiujący przestrzeń nazw tożsamości silnej nazwy.</summary>
        <value>A <see cref="T:System.Security.Permissions.StrongNamePublicKeyBlob" /> zawierający klucz publiczny tożsamości, lub <see langword="null" /> Jeśli klucz nie istnieje.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Wartość właściwości jest równa <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Nie można pobrać wartości właściwości, ponieważ zawiera ona niejednoznaczna tożsamości.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public override System.Security.SecurityElement ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.SecurityElement ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.StrongNameIdentityPermission.ToXml" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToXml () As SecurityElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::SecurityElement ^ ToXml();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy kodowania XML uprawnienia i swojego bieżącego stanu.</summary>
        <returns>Kodowanie XML uprawnienia, łącznie z żadnych informacji o stanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest zwykle nieużywany przez kod aplikacji.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia zachowanie <xref:System.Security.Permissions.StrongNameIdentityPermission.ToXml%2A> metody.  
  
> [!NOTE]
>  Przykładowy kod ma na celu Pokaż zachowanie metody, nie, aby zademonstrować jej użycia. Ogólnie rzecz biorąc metod klas uprawnienia są używane przez infrastrukturę zabezpieczeń; ich nie są zwykle używane w aplikacji.  
  
 [!code-cpp[System.Security.Permissions.StrongNameIdentityPermission#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CPP/strongnameidentity.cpp#6)]
 [!code-csharp[System.Security.Permissions.StrongNameIdentityPermission#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CS/strongnameidentity.cs#6)]
 [!code-vb[System.Security.Permissions.StrongNameIdentityPermission#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/VB/strongnameidentity.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public override System.Security.IPermission Union (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.IPermission Union(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.StrongNameIdentityPermission.Union(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Union (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::IPermission ^ Union(System::Security::IPermission ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Uprawnienie do łączenia z uprawnieniami bieżącego. Należy tego samego typu co bieżący uprawnień.</param>
        <summary>Tworzy uprawnienia, które łączy bieżące uprawnienia i określony.</summary>
        <returns>Nowe uprawnienie reprezentuje złożenie bieżące uprawnienia i określony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wynik wywołania <xref:System.Security.Permissions.StrongNameIdentityPermission.Union%2A> jest uprawnienia, które reprezentuje wszystkie operacje reprezentowany przez bieżące uprawnienia i określonego uprawnienia. Wszelkie żądania, który przekazuje albo uprawnienie przekazuje ich union.  
  
 Unia uprawnienie i `null` uprawnień, który nie jest `null`. Unia uprawnienie i podzbiór uprawnienie jest zawierający inne uprawnienia. Inne kombinacje powoduje <xref:System.ArgumentException> zgłaszanego wyjątku.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wyniki stosowania <xref:System.Security.Permissions.StrongNameIdentityPermission.Union%2A> metody, nie jak użyć tej metody. Ten przykład jest częścią większego przykładu udostępnionego dla <xref:System.Security.Permissions.StrongNameIdentityPermission> klasy. Najlepsze korzystanie w tym przykładzie jest do tworzenia i wykonać całą przykład i wyświetlić dane wyjściowe.  
  
> [!NOTE]
>  Przykładowy kod ma na celu Pokaż zachowanie metody, nie, aby zademonstrować jej użycia. Ogólnie rzecz biorąc metod klas uprawnienia są używane przez infrastrukturę zabezpieczeń; ich nie są zwykle używane w aplikacji.  
  
 [!code-cpp[System.Security.Permissions.StrongNameIdentityPermission#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CPP/strongnameidentity.cpp#3)]
 [!code-csharp[System.Security.Permissions.StrongNameIdentityPermission#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CS/strongnameidentity.cs#3)]
 [!code-vb[System.Security.Permissions.StrongNameIdentityPermission#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/VB/strongnameidentity.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> Parametr nie jest <see langword="null" /> i nie jest taki sam typ jak bieżące uprawnienia.  
  
 —lub—  
  
 Dwa uprawnienia nie są takie same i jest podzbiorem innych.</exception>
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public Version Version { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Security.Permissions.StrongNameIdentityPermission.Version" />
      <MemberSignature Language="VB.NET" Value="Public Property Version As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ Version { Version ^ get(); void set(Version ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia numer wersji tożsamości.</summary>
        <value>Wersja tożsamości.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Nie można pobrać wartości właściwości, ponieważ zawiera ona niejednoznaczna tożsamości.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
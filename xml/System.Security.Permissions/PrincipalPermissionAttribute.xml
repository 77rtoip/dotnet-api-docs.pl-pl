<Type Name="PrincipalPermissionAttribute" FullName="System.Security.Permissions.PrincipalPermissionAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ee79134711e3d7eeddcdb72d0ebfea82a5ebec0f" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69081518" /></Metadata><TypeSignature Language="C#" Value="public sealed class PrincipalPermissionAttribute : System.Security.Permissions.CodeAccessSecurityAttribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit PrincipalPermissionAttribute extends System.Security.Permissions.CodeAccessSecurityAttribute" />
  <TypeSignature Language="DocId" Value="T:System.Security.Permissions.PrincipalPermissionAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class PrincipalPermissionAttribute&#xA;Inherits CodeAccessSecurityAttribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class PrincipalPermissionAttribute sealed : System::Security::Permissions::CodeAccessSecurityAttribute" />
  <TypeSignature Language="F#" Value="type PrincipalPermissionAttribute = class&#xA;    inherit CodeAccessSecurityAttribute" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Permissions.CodeAccessSecurityAttribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zezwala na stosowanie akcji <see cref="T:System.Security.Permissions.PrincipalPermission" /> zabezpieczeń do kodu przy użyciu zabezpieczeń deklaratywnych. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Permissions.PrincipalPermissionAttribute>może służyć do deklaratywnego zapotrzebowania, że użytkownicy korzystający z kodu należą do określonej roli lub zostali uwierzytelnieni. Użycie elementu <xref:System.Security.Permissions.PermissionState.Unrestricted> tworzy element <xref:System.Security.Permissions.PrincipalPermission> with <xref:System.Security.Permissions.PrincipalPermissionAttribute.Authenticated%2A> o wartości `true` i <xref:System.Security.Permissions.PrincipalPermissionAttribute.Name%2A> i ustawia<xref:System.Security.Permissions.PrincipalPermissionAttribute.Role%2A> wartość .`null`  
  
 Zakres deklaracji, która jest dozwolona, zależy <xref:System.Security.Permissions.SecurityAction> od używanej metody. <xref:System.Security.Permissions.PrincipalPermissionAttribute>nie można zastosować na poziomie zestawu.  
  
 Informacje o zabezpieczeniach zadeklarowane przez atrybut zabezpieczeń są przechowywane w metadanych obiektu docelowego atrybutu i są dostępne przez system w czasie wykonywania. Atrybuty zabezpieczeń są używane tylko w celu zapewnienia bezpieczeństwa deklaracyjnego. W celu zapewnienia bezpieczeństwa należy użyć odpowiedniej klasy uprawnień.  
  
> [!IMPORTANT]
>  Przed użyciem tej klasy do żądania uprawnień głównych należy ustawić wartość <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>wyliczenia dla zasad głównych domeny aplikacji. Domyślnie zasada główna jest ustawiona na <xref:System.Security.Principal.PrincipalPolicy.UnauthenticatedPrincipal>. Jeśli nie ustawisz zasad głównych na <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>, żądanie dotyczące uprawnienia podmiotu zabezpieczeń zakończy się niepowodzeniem. Następujący kod powinien zostać wykonany przed wymaganiem uprawnienia podmiotu zabezpieczeń:`AppDomain.CurrentDomain.SetPrincipalPolicy(PrincipalPolicy.WindowsPrincipal).`  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak <xref:System.Security.Permissions.PrincipalPermissionAttribute> Klasa jest używana deklaratywnie w celu zaspokojenia, że bieżący użytkownik jest administratorem.  
  
> [!NOTE]
>  W systemie Windows Vista Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod wymagający administratora, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
 [!code-cpp[Classic PrincipalPermissionAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic PrincipalPermissionAttribute Example/CPP/source.cpp#1)]
 [!code-csharp[Classic PrincipalPermissionAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic PrincipalPermissionAttribute Example/CS/source.cs#1)]
 [!code-vb[Classic PrincipalPermissionAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic PrincipalPermissionAttribute Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Security.Permissions.PrincipalPermission" />
    <related type="Article" href="~/docs/standard/attributes/index.md">Rozszerzanie metadanych za pomocą atrybutów</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PrincipalPermissionAttribute (System.Security.Permissions.SecurityAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Security.Permissions.SecurityAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.PrincipalPermissionAttribute.#ctor(System.Security.Permissions.SecurityAction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As SecurityAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PrincipalPermissionAttribute(System::Security::Permissions::SecurityAction action);" />
      <MemberSignature Language="F#" Value="new System.Security.Permissions.PrincipalPermissionAttribute : System.Security.Permissions.SecurityAction -&gt; System.Security.Permissions.PrincipalPermissionAttribute" Usage="new System.Security.Permissions.PrincipalPermissionAttribute action" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Security.Permissions.SecurityAction" />
      </Parameters>
      <Docs>
        <param name="action">Jedna z <see cref="T:System.Security.Permissions.SecurityAction" /> wartości.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Security.Permissions.PrincipalPermissionAttribute" /> klasy z określonym <see cref="T:System.Security.Permissions.SecurityAction" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Demand`, `InheritanceDemand`, i `LinkDemand` sąjedynymiwartościami,któremająznaczeniedlategoatrybutu.<xref:System.Security.Permissions.SecurityAction> Inne akcje nie dotyczą uprawnień, które nie są uprawnieniami dostępu do kodu.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Security.Permissions.PrincipalPermissionAttribute.%23ctor%2A> konstruktora do żądania, że bieżący użytkownik jest administratorem.  
  
> [!NOTE]
>  W systemie Windows Vista Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod wymagający administratora, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
 [!code-cpp[Classic PrincipalPermissionAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic PrincipalPermissionAttribute Example/CPP/source.cpp#1)]
 [!code-csharp[Classic PrincipalPermissionAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic PrincipalPermissionAttribute Example/CS/source.cs#1)]
 [!code-vb[Classic PrincipalPermissionAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic PrincipalPermissionAttribute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticated">
      <MemberSignature Language="C#" Value="public bool Authenticated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticated" />
      <MemberSignature Language="DocId" Value="P:System.Security.Permissions.PrincipalPermissionAttribute.Authenticated" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Authenticated : bool with get, set" Usage="System.Security.Permissions.PrincipalPermissionAttribute.Authenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy bieżący podmiot zabezpieczeń został uwierzytelniony przez bazowego zależnej od roli dostawcy.</summary>
        <value><see langword="true" />Jeśli bieżący podmiot zabezpieczeń został uwierzytelniony; w przeciwnym razie. <see langword="false" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreatePermission">
      <MemberSignature Language="C#" Value="public override System.Security.IPermission CreatePermission ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.IPermission CreatePermission() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.PrincipalPermissionAttribute.CreatePermission" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreatePermission () As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::IPermission ^ CreatePermission();" />
      <MemberSignature Language="F#" Value="override this.CreatePermission : unit -&gt; System.Security.IPermission" Usage="principalPermissionAttribute.CreatePermission " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy i zwraca nowy <see cref="T:System.Security.Permissions.PrincipalPermission" />.</summary>
        <returns><see cref="T:System.Security.Permissions.PrincipalPermission" /> Odpowiadający temu atrybutowi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna być wywoływana tylko przez system zabezpieczeń, a nie przez kod aplikacji.  
  
 W czasie kompilacji atrybuty konwertują deklaracje zabezpieczeń na serializowaną postać w metadanych. Deklaratywne dane zabezpieczeń w metadanych są tworzone na podstawie uprawnień, które ta metoda zwraca do tego atrybutu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Security.Permissions.PrincipalPermissionAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Security.Permissions.PrincipalPermissionAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę tożsamości skojarzonej z bieżącym podmiotem zabezpieczeń.</summary>
        <value>Nazwa, która ma być zgodna z podaną przez podstawowy dostawca zabezpieczeń oparty na rolach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dostawca uwierzytelniania to Windows NT, <xref:System.Security.Permissions.PrincipalPermissionAttribute.Name%2A> jest taka sama jak nazwa logowania systemu Windows NT użytkownika (w postaci "DomainName\UserName"). Sprawdź dokumentację hosta, aby określić, którego dostawcy uwierzytelniania używa i jak określa tożsamość bieżącego podmiotu zabezpieczeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Role">
      <MemberSignature Language="C#" Value="public string Role { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Role" />
      <MemberSignature Language="DocId" Value="P:System.Security.Permissions.PrincipalPermissionAttribute.Role" />
      <MemberSignature Language="VB.NET" Value="Public Property Role As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Role { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Role : string with get, set" Usage="System.Security.Permissions.PrincipalPermissionAttribute.Role" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia członkostwo w określonej roli zabezpieczeń.</summary>
        <value>Nazwa roli z bazowego dostawcy zabezpieczeń opartego na rolach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dostępne role różnią się w zależności od dostawcy uwierzytelniania używanego przez hosta. Jeśli dostawca uwierzytelniania to Windows NT, role są grupami użytkowników systemu Windows NT (w postaci "DomainName\GroupName"). Sprawdź dokumentację hosta, aby określić, którego dostawcy uwierzytelniania używa i jakie role użytkownicy mogą należeć do programu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="IsolatedStorageFilePermission" FullName="System.Security.Permissions.IsolatedStorageFilePermission">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5473260cf4cccf5919471d9e1518bdc7ea35fa12" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69058156" /></Metadata><TypeSignature Language="C#" Value="public sealed class IsolatedStorageFilePermission : System.Security.Permissions.IsolatedStoragePermission" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit IsolatedStorageFilePermission extends System.Security.Permissions.IsolatedStoragePermission" />
  <TypeSignature Language="DocId" Value="T:System.Security.Permissions.IsolatedStorageFilePermission" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class IsolatedStorageFilePermission&#xA;Inherits IsolatedStoragePermission" />
  <TypeSignature Language="C++ CLI" Value="public ref class IsolatedStorageFilePermission sealed : System::Security::Permissions::IsolatedStoragePermission" />
  <TypeSignature Language="F#" Value="type IsolatedStorageFilePermission = class&#xA;    inherit IsolatedStoragePermission" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Permissions.IsolatedStoragePermission</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Określa dozwolone użycie prywatnego wirtualnego systemu plików. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisko uruchomieniowe języka wspólnego (CLR) używa tej klasy do kontrolowania dostępu do magazynu izolowanego.  
  
 Magazyn izolowany tworzy unikatowy obszar przechowywania do użycia przez aplikację lub składnik. Zapewnia ona prawdziwą izolację, ponieważ tożsamość aplikacji jednoznacznie określa katalog główny wirtualnego systemu plików, do którego dostęp może uzyskać tylko ta aplikacja. W rezultacie każda aplikacja ma przypisany do niej własny obszar plików. Ten obszar plików jest w pełni odizolowany od innych aplikacji, co sprawia, że jest on prywatny dla tej aplikacji.  
  
> [!NOTE]
>  Nie ma żadnego efektu, jeśli używasz <xref:System.Security.CodeAccessPermission.Assert%2A>, <xref:System.Security.CodeAccessPermission.PermitOnly%2A>, lub <xref:System.Security.CodeAccessPermission.Deny%2A> , aby dodać Modyfikatory stosu dla użycia lub przydziału.  Użycie i przydział są określane na podstawie dowodów i nie jest wykonywane przeszukiwanie stosu dla potrzeb, co powoduje, że powyższe operacje nie działają.  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">w celu umożliwienia dziedziczenia i wyświetlania i modyfikowania zasad. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />,<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
    <altmember cref="T:System.Security.Permissions.IsolatedStorageFilePermissionAttribute" />
    <altmember cref="T:System.Security.Permissions.IsolatedStoragePermission" />
    <altmember cref="T:System.Security.Permissions.IsolatedStoragePermissionAttribute" />
    <altmember cref="T:System.Security.Permissions.IsolatedStorageContainment" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFilePermission (System.Security.Permissions.PermissionState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Security.Permissions.PermissionState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.IsolatedStorageFilePermission.#ctor(System.Security.Permissions.PermissionState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (state As PermissionState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFilePermission(System::Security::Permissions::PermissionState state);" />
      <MemberSignature Language="F#" Value="new System.Security.Permissions.IsolatedStorageFilePermission : System.Security.Permissions.PermissionState -&gt; System.Security.Permissions.IsolatedStorageFilePermission" Usage="new System.Security.Permissions.IsolatedStorageFilePermission state" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="state" Type="System.Security.Permissions.PermissionState" />
      </Parameters>
      <Docs>
        <param name="state">Jedna z <see cref="T:System.Security.Permissions.PermissionState" /> wartości.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Security.Permissions.IsolatedStorageFilePermission" /> klasy za pomocą w pełni ograniczonego lub nieograniczonego uprawnienia określonego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tworzy w pełni ograniczone (`None`) lub `Unrestricted` dostęp do izolowanych plików magazynu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Parametr nie jest prawidłową <see cref="T:System.Security.Permissions.PermissionState" />wartością. <paramref name="state" /></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">w celu umożliwienia dziedziczenia i wyświetlania i modyfikowania zasad. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />,<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public override System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.IsolatedStorageFilePermission.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Copy () As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::IPermission ^ Copy();" />
      <MemberSignature Language="F#" Value="override this.Copy : unit -&gt; System.Security.IPermission" Usage="isolatedStorageFilePermission.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy i zwraca identyczną kopię bieżącego uprawnienia.</summary>
        <returns>Kopia bieżącego uprawnienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kopia uprawnienia reprezentuje ten sam dostęp do zasobów co oryginalne uprawnienie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public override System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.IsolatedStorageFilePermission.Intersect(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Intersect (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::IPermission ^ Intersect(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="override this.Intersect : System.Security.IPermission -&gt; System.Security.IPermission" Usage="isolatedStorageFilePermission.Intersect target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Uprawnienie do przecięcia z bieżącym obiektem uprawnień. Musi być tego samego typu co bieżące uprawnienie.</param>
        <summary>Tworzy i zwraca uprawnienie, które jest częścią wspólną bieżącego uprawnienia i określonego uprawnienia.</summary>
        <returns>Nowe uprawnienie, które reprezentuje część wspólną bieżącego uprawnienia i określonego uprawnienia. To nowe uprawnienie jest <see langword="null" /> , jeśli część wspólna jest pusta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wspólną częścią dwóch uprawnień jest uprawnienie, które opisuje zestaw operacji, które oba często opisują. Tylko żądanie przekazujące pierwotne uprawnienia spowoduje przekazanie przedziału.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> Parametr nie<see langword="null" /> ma tego samego typu co bieżące uprawnienie.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public override bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.IsolatedStorageFilePermission.IsSubsetOf(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsSubsetOf (target As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsSubsetOf(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="override this.IsSubsetOf : System.Security.IPermission -&gt; bool" Usage="isolatedStorageFilePermission.IsSubsetOf target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Uprawnienie, które ma zostać przetestowane dla relacji podzbioru. To uprawnienie musi być tego samego typu co bieżące uprawnienie.</param>
        <summary>Określa, czy bieżące uprawnienie jest podzbiorem określonego uprawnienia.</summary>
        <returns><see langword="true" />Jeśli bieżące uprawnienie jest podzbiorem określonego uprawnienia; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżące uprawnienie jest podzbiorem określonego uprawnienia, jeśli bieżące uprawnienie określa zestaw operacji, które są w całości zawarte w określonym uprawnienia. Na przykład uprawnienie, które reprezentuje dostęp do C:\example.txt, jest podzbiorem uprawnienia, które reprezentuje dostęp do C:\\. Jeśli ta metoda zwróci `true`wartość, bieżące uprawnienie nie reprezentuje więcej dostępu do chronionego zasobu niż określone uprawnienie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> Parametr nie<see langword="null" /> ma tego samego typu co bieżące uprawnienie.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public override System.Security.SecurityElement ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.SecurityElement ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.IsolatedStorageFilePermission.ToXml" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToXml () As SecurityElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::SecurityElement ^ ToXml();" />
      <MemberSignature Language="F#" Value="override this.ToXml : unit -&gt; System.Security.SecurityElement" Usage="isolatedStorageFilePermission.ToXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy Kodowanie XML uprawnienia i jego bieżący stan.</summary>
        <returns>Kodowanie XML uprawnienia, w tym informacje o stanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Permissions.IsolatedStorageFilePermission.ToXml%2A> Metoda<xref:System.Security.Permissions.IsolatedStorageFilePermission> umożliwia Kodowanie XML ze względów bezpieczeństwa.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public override System.Security.IPermission Union (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.IPermission Union(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.IsolatedStorageFilePermission.Union(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Union (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::IPermission ^ Union(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="override this.Union : System.Security.IPermission -&gt; System.Security.IPermission" Usage="isolatedStorageFilePermission.Union target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Uprawnienie do łączenia z bieżącym uprawnieniem. Musi być tego samego typu co bieżące uprawnienie.</param>
        <summary>Tworzy uprawnienie, które jest złożeniem bieżącego uprawnienia i określonym uprawnieniem.</summary>
        <returns>Nowe uprawnienie, które reprezentuje związek z bieżącym uprawnieniem i określonym uprawnieniem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wynikiem wywołania <xref:System.Security.Permissions.IsolatedStorageFilePermission.Union%2A> jest uprawnienie, które reprezentuje wszystkie operacje reprezentowane przez bieżące uprawnienie i określone uprawnienie. Każde żądanie, które przekazuje jedno uprawnienie, przekazuje ich Unię.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> Parametr nie<see langword="null" /> ma tego samego typu co bieżące uprawnienie.</exception>
      </Docs>
    </Member>
  </Members>
</Type>

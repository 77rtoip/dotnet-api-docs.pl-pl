<Type Name="KeyContainerPermissionAccessEntryEnumerator" FullName="System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="66f862bbfa6c0776208bb1fde780133d2c230622" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30570379" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class KeyContainerPermissionAccessEntryEnumerator : System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit KeyContainerPermissionAccessEntryEnumerator extends System.Object implements class System.Collections.IEnumerator" />
  <TypeSignature Language="DocId" Value="T:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class KeyContainerPermissionAccessEntryEnumerator&#xA;Implements IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class KeyContainerPermissionAccessEntryEnumerator sealed : System::Collections::IEnumerator" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje moduł wyliczający dla <see cref="T:System.Security.Permissions.KeyContainerPermissionAccessEntry" /> obiekty w <see cref="T:System.Security.Permissions.KeyContainerPermissionAccessEntryCollection" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduły wyliczające Zezwalaj tylko do odczytu danych w kolekcji. Wyliczenia nie można zmodyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Reset%2A> — Metoda powoduje również moduł wyliczający do tej pozycji. At to pozycja, wywoływania <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current%2A> właściwości zgłasza wyjątek. W związku z tym należy wywołać <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> metodę modułu wyliczającego pierwszy element do kolekcji przed odczytywania wartości <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current%2A> właściwości.  
  
 <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current%2A> zwraca ten sam obiekt do momentu <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> lub <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Reset%2A> jest wywoływana. <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> Ustawia <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current%2A> do następnego elementu.  
  
 Po zakończeniu kolekcji jest moduł wyliczający jest rozmieszczanych za ostatnim elementem w kolekcji i wywoływania <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> zwraca `false`. Jeśli przez ostatnie wywołanie <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> zwrócił `false`, wywoływania <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current%2A> zgłasza wyjątek. Aby zresetować <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current%2A> do pierwszego elementu kolekcji, należy wywołać <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Reset%2A> następuje wywołanie <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli zmiany zostały wprowadzone do kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający jest bezpowrotnie unieważniona, a następne wywołanie <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> lub <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Reset%2A> zgłasza <xref:System.InvalidOperationException>. Jeśli kolekcja jest zmodyfikowany między wywoływaniem <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> i <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current%2A>, <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current%2A> zwraca element, do którego jest obecnie ustawiona, nawet wtedy, gdy moduł wyliczający jest już unieważnione.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public KeyContainerPermissionAccessEntryEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; KeyContainerPermissionAccessEntryEnumerator();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Security.Permissions.KeyContainerPermissionAccessEntry Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Permissions.KeyContainerPermissionAccessEntry Current" />
      <MemberSignature Language="DocId" Value="P:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As KeyContainerPermissionAccessEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Permissions::KeyContainerPermissionAccessEntry ^ Current { System::Security::Permissions::KeyContainerPermissionAccessEntry ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Permissions.KeyContainerPermissionAccessEntry</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący wpis w kolekcji.</summary>
        <value>Bieżący <see cref="T:System.Security.Permissions.KeyContainerPermissionAccessEntry" /> obiektu w kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po utworzeniu modułu wyliczającego nie wskazuje on do obiektu, więc <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current%2A> właściwość nie jest prawidłowy i zgłosi wyjątek, jeśli jest on dostępny. Najpierw musisz wywołać <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> metodę, aby umieść kursor na pierwszy obiekt w kolekcji.  
  
 Pobieranie <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current%2A> właściwości wiele razy przy użyciu nie pośredniczące wywołań <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> , którą będzie zwracać taki sam <xref:System.Security.Permissions.KeyContainerPermissionAccessEntry> obiektu zawsze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current" /> Dostępu do właściwości przed pierwszym wywołaniem <see cref="M:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext" /> metody. Kursor znajduje się przed pierwszym obiektu w kolekcji.  
  
 —lub—  
  
 <see cref="P:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current" /> Dostępu do właściwości po wywołaniu <see cref="M:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext" /> metoda zwraca <see langword="false" />, co oznacza, że kursor znajduje się po ostatnim obiektu w kolekcji.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przechodzi do następnego elementu w kolekcji.</summary>
        <returns>
          <see langword="true" /> Jeśli moduł wyliczający został pomyślnie poprawionym do następnego elementu; <see langword="false" /> po zakończeniu zbierania moduł wyliczający.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> Metoda zwraca `false` natychmiast, jeśli nie ma żadnych obiektów w kolekcji.  
  
 <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> Zwraca `true` dopóki osiągnie koniec kolekcji. Następnie zwraca `false` dla każdego kolejne wywołania. Jednak po <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> zwrócił `false`, podczas uzyskiwania dostępu do <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current%2A> właściwości zgłasza wyjątek.  
  
 Po utworzeniu, moduł wyliczający jest umieszczony przed pierwszą <xref:System.Security.Permissions.KeyContainerPermissionAccessEntry> obiektu w kolekcji i w pierwszym wywołaniu <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> umieszcza modułu wyliczającego do pierwszego obiektu w kolekcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje modułu wyliczającego na początku kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł wyliczający przenosi kierunku tylko do przodu. Ta metoda umożliwia powrotu do kolekcji.  
  
 <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Reset%2A> Metody umieszcza kursor na pierwszy obiekt w kolekcji. Po wywołaniu <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Reset%2A>, nie należy wywołać <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> Aby przesunąć kursor do przodu do pierwszego obiektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IEnumerator.Current { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący obiekt w kolekcji.</summary>
        <value>Bieżący obiekt w kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie wywołuj tej metody; Użyj <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current%2A> właściwości zamiast tego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
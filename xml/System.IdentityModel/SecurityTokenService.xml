<Type Name="SecurityTokenService" FullName="System.IdentityModel.SecurityTokenService">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b5c8d93b898d628b70967d33278c8cd9f33a66bf" />
    <Meta Name="ms.sourcegitcommit" Value="d0bb31ec8354fa58c62c2a646057eec11d3e2150" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/17/2018" />
    <Meta Name="ms.locfileid" Value="36479611" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SecurityTokenService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SecurityTokenService extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.SecurityTokenService" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SecurityTokenService" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityTokenService abstract" />
  <TypeSignature Language="F#" Value="type SecurityTokenService = class" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Abstrakcyjna klasa bazowa, która definiuje właściwości i metody usługi tokenu zabezpieczającego (STS).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby utworzyć usługę STS muszą pochodzić od <xref:System.IdentityModel.SecurityTokenService> klasy. W klasie niestandardowych co najmniej zastąpisz <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> i <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> metody. Za pomocą te zastąpienia może wystawiać tokeny zabezpieczające w odpowiedzi na zabezpieczenia żądania tokenu (RST) jest utworzone za pomocą Domyślna implementacja wszystkie inne metody zdefiniowanej w klasie usługi STS. Oznacza to, że powiązanie problem z definicją w specyfikacji WS-Trust jest zaimplementowana. To powiązanie jest zaimplementowana w <xref:System.IdentityModel.SecurityTokenService.Issue%2A> metody. Żaden z pozostałych powiązaniach protokołu WS-Trust (Odnów, Anuluj i sprawdź poprawność) są implementowane w na przypadek domyślny i odpowiednie błędów jest zwracany do obiektu wywołującego, jeśli zostanie osiągnięty RST, który odpowiada jednej z tych powiązań. Można oczywiście zastąpić właściwe metody (<xref:System.IdentityModel.SecurityTokenService.Renew%2A>, <xref:System.IdentityModel.SecurityTokenService.Cancel%2A>, i <xref:System.IdentityModel.SecurityTokenService.Validate%2A>) Aby zaimplementować te powiązania w usługi STS.  
  
> [!IMPORTANT]
>  Implementowanie STS gotowe do produkcji pociąga za sobą, staranne planowanie oraz dużo zasobów, aby ograniczyć potencjalne zagrożenia bezpieczeństwa związane z udostępnianie takiej usługi. Większość deweloperów przy użyciu Windows Identity Foundation (WIF) będzie można tworzenia aplikacji, które oddelegowania procesów zarządzania tożsamości do usługi STS, a nie sam tworzenia usługi tokenu Zabezpieczającego. Program WIF oferuje rozszerzenie programu Visual Studio, narzędzie tożsamości i dostępu dla programu Visual Studio 2012, aby pomóc deweloperom testowanie rozwiązań w środowisku programistycznym. To narzędzie zawiera usługę STS, `LocalSTS`, które można skonfigurować w celu obsługi określonych oświadczeń do aplikacji, który tworzysz. Aby uzyskać więcej informacji o narzędziu tożsamościami i dostępem, zobacz [narzędzie tożsamości i dostępu dla programu Visual Studio 2012](~/docs/framework/security/identity-and-access-tool-for-vs.md). W niektórych scenariuszach `LocalSTS` nie mogą zawierać funkcje niezbędne do odpowiednio testować swoją aplikację; na przykład w scenariuszu, która obejmuje tworzenie programu obsługi tokenów niestandardowych do użytku przez aplikację. W takich przypadkach może pochodzić z <xref:System.IdentityModel.SecurityTokenService> utworzyć jeden lub więcej prostych usługi STS, można wdrożyć w środowisku deweloperskim i który może służyć do testowania tych funkcji w aplikacji. Pozostała część tej sekcji skupiono się na metod udostępnianych przez <xref:System.IdentityModel.SecurityTokenService> klasę, która umożliwia Implementowanie prostego usługi STS i rozszerzanie potoku wystawiania tokenu.  
  
 Poniższa lista zawiera krótki przegląd metody podstawowe znaczenie dla dewelopera, do użytku w środowisku testowym lub deweloperskim.  
  
-   <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> Metody. Ta metoda zwraca <xref:System.IdentityModel.Scope> obiektu, który zawiera informacje dotyczące jednostki Uzależnionej. Ten obiekt jest używana w pozostałej części potoku wystawiania tokenów i zawiera informacje dotyczące podpisywania i szyfrowania poświadczeń do użycia w odpowiedzi, a także `AppliesTo` i `ReplyTo` (jeśli jest to wymagane) adresów. Należy przesłonić tę metodę.  
  
-   <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> Metody. Ta metoda zwraca <xref:System.Security.Claims.ClaimsIdentity> obiekt, który zawiera oświadczenia, aby powrócić do jednostki Uzależnionej. Należy przesłonić tę metodę.  
  
-   <xref:System.IdentityModel.SecurityTokenService.Issue%2A> Metody. Ta metoda implementuje potoku żądania tokenu, który przetwarza przychodzące żądanie tokenu zabezpieczeń (RST) i zwraca odpowiedź (RSTR) do obiektu wywołującego, który zawiera token, który może służyć do uwierzytelniania za pomocą jednostki Uzależnionej. Wiele innych metod, zdefiniowanych w <xref:System.IdentityModel.SecurityTokenService> klasy są wywoływane z tej metody, w tym <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> i <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> metody. Nie trzeba zastąpić tę metodę, ale zrozumienie potoku żądania tokenu, który implementuje mogą być pomocne.  
  
 Usługa STS jest skonfigurowana za pośrednictwem <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration> klasy.  
  
   
  
## Examples  
 Przykłady kodu, które są używane w <xref:System.IdentityModel.SecurityTokenService> tematy są pobierane z `Custom Token` próbki. W tym przykładzie zawiera niestandardowych klas, które umożliwiają przetwarzanie tokenów sieci Web proste (SWT), a także implementacja pasywną usługą STS, który umożliwia obsługę tokenu SWT. Na przykład sposób implementacji aktywną usługą STS widać `Federation Metadata` próbki. Aby uzyskać informacji o tych przykładów i inne przykłady, które są dostępne dla programu WIF i o tym, gdzie można je pobrać, zobacz [Indeks przykładów kodu programu WIF](~/docs/framework/security/wif-code-sample-index.md). Poniższy kod przedstawia implementację pasywną usługą STS przy użyciu <xref:System.IdentityModel.SecurityTokenService> klasy.  
  
 [!code-csharp[WIFCustomTokenSTS#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#3)]  
  
 Poniższy kod pokazuje, jak wywołać niestandardowy pasywną usługą STS do przetwarzania żądań protokołu WS-Federation, wywołując <xref:System.IdentityModel.Services.FederatedPassiveSecurityTokenServiceOperations.ProcessRequest%28System.Web.HttpRequest%2CSystem.Security.Claims.ClaimsPrincipal%2CSystem.IdentityModel.SecurityTokenService%2CSystem.Web.HttpResponse%29?displayProperty=nameWithType> metody w kodzie w `default.aspx.cs` pliku.  
  
 [!code-csharp[WIFCustomTokenSTS#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/default.aspx.cs#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Konieczne jest przesłonięcie zarówno <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" /> i <see cref="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" /> metody.</para>
    </block>
    <altmember cref="T:System.IdentityModel.Scope" />
    <altmember cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />
    <altmember cref="T:System.IdentityModel.Services.FederatedPassiveSecurityTokenServiceOperations" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SecurityTokenService (System.IdentityModel.Configuration.SecurityTokenServiceConfiguration securityTokenServiceConfiguration);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IdentityModel.Configuration.SecurityTokenServiceConfiguration securityTokenServiceConfiguration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.#ctor(System.IdentityModel.Configuration.SecurityTokenServiceConfiguration)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SecurityTokenService(System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ securityTokenServiceConfiguration);" />
      <MemberSignature Language="F#" Value="new System.IdentityModel.SecurityTokenService : System.IdentityModel.Configuration.SecurityTokenServiceConfiguration -&gt; System.IdentityModel.SecurityTokenService" Usage="new System.IdentityModel.SecurityTokenService securityTokenServiceConfiguration" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="securityTokenServiceConfiguration" Type="System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />
      </Parameters>
      <Docs>
        <param name="securityTokenServiceConfiguration">Element <see cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" /> zawierający ustawienia dla usługi STS.</param>
        <summary>Wywoływana w klasach pochodnych można zainicjować <see cref="T:System.IdentityModel.SecurityTokenService" /> przy użyciu ustawienia konfiguracji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zainicjować dostawcy zakresu i certyfikatu wystawcy tokenów, należy użyć tego konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="securityTokenServiceConfiguration" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginCancel">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginCancel (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginCancel(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginCancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginCancel (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginCancel(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginCancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginCancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginCancel (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> reprezentujący tożsamości obiektu żądającego tokenu.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący żądanie tokenu zabezpieczeń. W tym żądaniu wiadomości, a także innych klientów powiązane informacje, takie jak kontekst autoryzacji.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, która odbiera powiadomienia o zakończeniu operacji asynchronicznej anulowania.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie związane z operacją asynchroniczną Anuluj.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się asynchroniczne żądanie anulowania WS-Trust.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się operacja anulowania asynchronicznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected virtual IAsyncResult BeginGetOutputClaimsIdentity (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult BeginGetOutputClaimsIdentity(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IAsyncResult ^ BeginGetOutputClaimsIdentity(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginGetOutputClaimsIdentity : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginGetOutputClaimsIdentity : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginGetOutputClaimsIdentity (principal, request, scope, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> reprezentujący tożsamości obiektu żądającego tokenu.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący żądanie tokenu zabezpieczeń. W tym żądaniu wiadomości, a także innych klientów powiązane informacje, takie jak kontekst autoryzacji.</param>
        <param name="scope">
          <see cref="T:System.IdentityModel.Scope" /> Zawierający informacje dotyczące jednostki uzależnionej skojarzonej z żądaniem.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, która odbiera powiadomienia o zakończeniu operacji asynchronicznej.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie związane z operacją asynchroniczną.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się wywołanie asynchroniczne <see cref="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" /> metody.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się operacja asynchroniczna.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetScope">
      <MemberSignature Language="C#" Value="protected virtual IAsyncResult BeginGetScope (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult BeginGetScope(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function BeginGetScope (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IAsyncResult ^ BeginGetScope(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginGetScope : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginGetScope : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginGetScope (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> reprezentujący tożsamości obiektu żądającego tokenu.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący żądanie tokenu zabezpieczeń. W tym żądaniu wiadomości, a także innych klientów powiązane informacje, takie jak kontekst autoryzacji.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, która odbiera powiadomienia o zakończeniu operacji asynchronicznej.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie związane z operacją asynchroniczną.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się wywołania asynchronicznego dla <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" /> metody.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się operacja anulowania asynchronicznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginIssue">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginIssue (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginIssue(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginIssue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginIssue (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginIssue(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginIssue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginIssue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginIssue (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> reprezentujący tożsamości obiektu żądającego tokenu.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący żądanie tokenu zabezpieczeń. W tym żądaniu wiadomości, a także innych klientów powiązane informacje, takie jak kontekst autoryzacji.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odbiera powiadomienie o ukończeniu operacji asynchronicznej problem.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie związane z operacją asynchroniczną problem.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się asynchroniczne żądanie protokołu WS-Trust problem.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odwołujący się operacji asynchronicznych problem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRenew">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginRenew (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginRenew(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginRenew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginRenew (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginRenew(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginRenew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginRenew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginRenew (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> reprezentujący tożsamości obiektu żądającego tokenu.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący żądanie tokenu zabezpieczeń. W tym żądaniu wiadomości, a także innych klientów powiązane informacje, takie jak kontekst autoryzacji.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, która odbiera powiadomienia o zakończeniu asynchroniczną odnowić operacji.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie związane z asynchronicznymi odnowić operacji.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się asynchroniczne żądanie odnowienia WS-Trust.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Czy odwołania asynchroniczną odnowić operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginValidate">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginValidate (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginValidate(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginValidate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginValidate (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginValidate(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginValidate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginValidate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginValidate (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> reprezentujący tożsamości obiektu żądającego tokenu.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący żądanie tokenu zabezpieczeń. W tym żądaniu wiadomości, a także innych klientów powiązane informacje, takie jak kontekst autoryzacji.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, która odbiera powiadomienia o zakończeniu asynchroniczną weryfikowanie operacji.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie związane z asynchronicznymi zweryfikować operację.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się żądanie asynchroniczne sprawdzanie poprawności protokołu WS-Trust.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Czy odwołania asynchroniczną weryfikowanie operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cancel">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Cancel (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Cancel(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Cancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Cancel (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Cancel(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Cancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Cancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Cancel (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> reprezentujący tożsamości obiektu żądającego tokenu.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący żądanie tokenu zabezpieczeń. W tym żądaniu wiadomości, a także innych klientów powiązane informacje, takie jak kontekst autoryzacji.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, przetwarza żądanie anulowania WS-Trust.</summary>
        <returns>A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> reprezentujący RSTR, aby powrócić do obiektu wywołującego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSecurityTokenDescriptor">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.SecurityTokenDescriptor CreateSecurityTokenDescriptor (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityTokenDescriptor CreateSecurityTokenDescriptor(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.CreateSecurityTokenDescriptor(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::SecurityTokenDescriptor ^ CreateSecurityTokenDescriptor(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberSignature Language="F#" Value="abstract member CreateSecurityTokenDescriptor : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.SecurityTokenDescriptor&#xA;override this.CreateSecurityTokenDescriptor : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.SecurityTokenDescriptor" Usage="securityTokenService.CreateSecurityTokenDescriptor (request, scope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="request">Przychodzące żądania tokenu.</param>
        <param name="scope">
          <see cref="P:System.IdentityModel.SecurityTokenService.Scope" /> Obiekt zwracany z <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />.</param>
        <summary>Tworzy wystąpienie <see cref="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />.</summary>
        <returns>
          <see cref="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływane podczas wystawiania tokenu po <xref:System.IdentityModel.SecurityTokenService.GetScope%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="request" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="scope" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndCancel">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndCancel (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndCancel(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndCancel(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndCancel (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndCancel(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndCancel : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndCancel : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndCancel result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Zwracanym przez wywołanie <see cref="M:System.IdentityModel.SecurityTokenService.BeginCancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> metody.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wykonuje asynchroniczne żądanie anulowania WS-Trust.</summary>
        <returns>A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> reprezentujący RSTR, aby powrócić do obiektu wywołującego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected virtual System.Security.Claims.ClaimsIdentity EndGetOutputClaimsIdentity (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Security.Claims.ClaimsIdentity EndGetOutputClaimsIdentity(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndGetOutputClaimsIdentity(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function EndGetOutputClaimsIdentity (result As IAsyncResult) As ClaimsIdentity" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Security::Claims::ClaimsIdentity ^ EndGetOutputClaimsIdentity(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndGetOutputClaimsIdentity : IAsyncResult -&gt; System.Security.Claims.ClaimsIdentity&#xA;override this.EndGetOutputClaimsIdentity : IAsyncResult -&gt; System.Security.Claims.ClaimsIdentity" Usage="securityTokenService.EndGetOutputClaimsIdentity result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsIdentity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Zwracanym przez wywołanie <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" /> metody.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wykonuje asynchroniczne wywołanie do <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" /> metody.</summary>
        <returns>A <see cref="T:System.Security.Claims.ClaimsIdentity" /> , która zawiera kolekcję oświadczeń, które zostaną umieszczone w tokenie zabezpieczającym wystawione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetScope">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Scope EndGetScope (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Scope EndGetScope(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndGetScope(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function EndGetScope (result As IAsyncResult) As Scope" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Scope ^ EndGetScope(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndGetScope : IAsyncResult -&gt; System.IdentityModel.Scope&#xA;override this.EndGetScope : IAsyncResult -&gt; System.IdentityModel.Scope" Usage="securityTokenService.EndGetScope result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Zwracanym przez wywołanie <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> metody.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wykonuje asynchroniczne wywołanie do <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> metody.</summary>
        <returns>A <see cref="T:System.IdentityModel.Scope" /> która hermetyzuje jednostki uzależnionej informacje innych firm (RP) skojarzony z żądaniem (RST) określone w wywołaniu <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndIssue">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndIssue (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndIssue(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndIssue(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndIssue (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndIssue(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndIssue : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndIssue : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndIssue result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Zwracanym przez wywołanie <see cref="M:System.IdentityModel.SecurityTokenService.BeginIssue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> metody.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zostanie ukończone żądania asynchronicznego problem WS-Trust.</summary>
        <returns>A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> reprezentujący RSTR, aby powrócić do obiektu wywołującego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRenew">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndRenew (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndRenew(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndRenew(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndRenew (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndRenew(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndRenew : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndRenew : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndRenew result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Zwracanym przez wywołanie <see cref="M:System.IdentityModel.SecurityTokenService.BeginRenew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> metody.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wykonuje asynchroniczne żądanie odnowienia WS-Trust.</summary>
        <returns>A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> reprezentujący RSTR, aby powrócić do obiektu wywołującego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndValidate">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndValidate (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndValidate(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndValidate(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndValidate (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndValidate(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndValidate : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndValidate : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndValidate result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Zwracanym przez wywołanie <see cref="M:System.IdentityModel.SecurityTokenService.BeginValidate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> metody.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, kończy się sprawdzanie poprawności protokołu WS-Trust żądania asynchronicznego.</summary>
        <returns>A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> reprezentujący RSTR, aby powrócić do obiektu wywołującego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIssuerName">
      <MemberSignature Language="C#" Value="protected virtual string GetIssuerName ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetIssuerName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetIssuerName" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetIssuerName () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetIssuerName();" />
      <MemberSignature Language="F#" Value="abstract member GetIssuerName : unit -&gt; string&#xA;override this.GetIssuerName : unit -&gt; string" Usage="securityTokenService.GetIssuerName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera nazwę usługi tokenu zabezpieczającego (STS).</summary>
        <returns>Nazwa wystawcy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana z domyślnej potoku wystawiania tokenu jest zaimplementowana w <xref:System.IdentityModel.SecurityTokenService.Issue%2A> metody.  
  
 Domyślna implementacja zwraca <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.TokenIssuerName%2A> właściwości z konfiguracji dostępne za pośrednictwem <xref:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected abstract System.Security.Claims.ClaimsIdentity GetOutputClaimsIdentity (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Security.Claims.ClaimsIdentity GetOutputClaimsIdentity(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Security::Claims::ClaimsIdentity ^ GetOutputClaimsIdentity(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberSignature Language="F#" Value="abstract member GetOutputClaimsIdentity : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.Security.Claims.ClaimsIdentity" Usage="securityTokenService.GetOutputClaimsIdentity (principal, request, scope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsIdentity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> reprezentujący tożsamości obiektu żądającego tokenu.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący żądanie tokenu zabezpieczeń. W tym żądaniu wiadomości, a także innych klientów powiązane informacje, takie jak kontekst autoryzacji.</param>
        <param name="scope">
          <see cref="T:System.IdentityModel.Scope" /> Zawierający informacje dotyczące jednostki uzależnionej skojarzonej z żądaniem. Jest to <see cref="T:System.IdentityModel.Scope" /> obiekt, który został zwrócony przez <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" /> metody.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, ta metoda zwraca kolekcję podmiotów danych wyjściowych, które mają zostać uwzględnione w wystawiony token.</summary>
        <returns>A <see cref="T:System.Security.Claims.ClaimsIdentity" /> , która zawiera kolekcję oświadczeń, które zostaną umieszczone w tokenie zabezpieczającym wystawione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> Metoda jest wywoływana z potoku wystawiania tokenu jest implementowany przez <xref:System.IdentityModel.SecurityTokenService.Issue%2A> metody. Zwraca <xref:System.Security.Claims.ClaimsIdentity> zawierający oświadczenia do uwzględnienia w tokenie zabezpieczającym wystawiony, w oparciu o obiekt żądający tokenu ( `principal` parametru), RST przychodzące ( `request` parametru), i uzależnionej, dla którego token jest przeznaczony () `scope` parametru). Logic Apps w ramach tej metody jest przede wszystkim odpowiedzieć na następujące pytania:  
  
-   **Który typ oświadczenia powinny być uwzględnione w odpowiedzi na podstawie na jednostki Uzależnionej dla której jest przeznaczony?** Zwykle to decyzji na podstawie-RP z listy typów oświadczeń wymaganych dla każdej jednostki Uzależnionej lub na podstawie danego żądania, sprawdzając <xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken.Claims%2A> właściwości żądania. Jednak logika i szczegóły dotyczące określania oświadczeń do uwzględnienia w odpowiedzi jest całkowicie do implementacji.  
  
-   **Które roszczenie wartości powinny być przypisane do oświadczeń w odpowiedzi?** Dostawcy tożsamości (Usługa STS IP) zwykle oznacza to przy użyciu co najmniej jeden oświadczeń w żądającego <xref:System.Security.Claims.ClaimsPrincipal> (dostarczonych przez `principal` parametrów) do uzyskania dostępu do magazynu (lub inną jednostkę), aby zwrócić wartości dla wymaganych typów oświadczeń. W przypadku dostawcy federacyjnego (usługi STS R) zwykle oznacza to przeprowadzania pewnego rodzaju przetwarzania żądającego oświadczeń przychodzących do spełnienia żądania; prawdopodobnie wykonywania filtrowania lub przekształcania oświadczeń, niektóre przedstawione przez obiekt żądający, podczas przekazywania innymi przez niezmodyfikowane. Oczywiście tak jak w przypadku podejmowania decyzji o tym, które oświadczenia zostaną do uwzględnienia w odpowiedzi, szczegóły i logiki sposobu określania wartości te oświadczenia zależy od implementacji.  
  
   
  
## Examples  
 Przykład kodu, który jest używany w tym temacie jest pobierana z `Custom Token` próbki. W tym przykładzie zawiera niestandardowych klas, które umożliwiają przetwarzanie tokenów sieci Web proste (SWT), a także implementacja pasywną usługą STS, który umożliwia obsługę tokenu SWT. Na przykład sposób implementacji aktywną usługą STS widać `Federation Metadata` próbki. Aby uzyskać informacji o tych przykładów i inne przykłady, które są dostępne dla programu WIF i o tym, gdzie można je pobrać, zobacz [Indeks przykładów kodu programu WIF](~/docs/framework/security/wif-code-sample-index.md). Poniższy kod przedstawia sposób przesłonięcia <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> metodę, aby zwracać oświadczenia do usługi STS. W tym przykładzie komunikat żądania zabezpieczeń tokenu (RST) zostanie zignorowany i zwracana jest kolekcja oświadczenia na podstawie użytkownika, ponieważ uwierzytelnieniu Usługa STS.  
  
 [!code-csharp[WIFCustomTokenSTS#6](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Należy przesłonić tę metodę w danej implementacji <see cref="T:System.IdentityModel.SecurityTokenService" /> klasy.</para>
        </block>
        <altmember cref="T:System.IdentityModel.Scope" />
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetProofToken">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.ProofDescriptor GetProofToken (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.ProofDescriptor GetProofToken(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetProofToken(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::ProofDescriptor ^ GetProofToken(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberSignature Language="F#" Value="abstract member GetProofToken : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.ProofDescriptor&#xA;override this.GetProofToken : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.ProofDescriptor" Usage="securityTokenService.GetProofToken (request, scope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.ProofDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący przychodzące żądania tokenu (RST).</param>
        <param name="scope">
          <see cref="T:System.IdentityModel.Scope" /> Wystąpienia, który hermetyzuje informacje o jednostkę uzależnioną.</param>
        <summary>Pobiera token potwierdzenia do uwzględnienia w odpowiedzi (RSTR).</summary>
        <returns>A <see cref="T:System.IdentityModel.Tokens.ProofDescriptor" /> reprezentujący nowo utworzony dowód deskryptora. Dowód deskryptora może być asymetrycznego deskryptora dowód, deskryptor dowód symetrycznego lub <see langword="null" /> w przypadku tokenu elementu nośnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana z domyślnej potoku wystawiania tokenu jest zaimplementowana w <xref:System.IdentityModel.SecurityTokenService.Issue%2A> metody.  
  
 Domyślna implementacja zwraca deskryptor weryfikacji lub zgłasza wyjątek odpowiednie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="request" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="scope" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetRequestorProofEncryptingCredentials">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.EncryptingCredentials GetRequestorProofEncryptingCredentials (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.EncryptingCredentials GetRequestorProofEncryptingCredentials(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetRequestorProofEncryptingCredentials(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRequestorProofEncryptingCredentials (request As RequestSecurityToken) As EncryptingCredentials" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::EncryptingCredentials ^ GetRequestorProofEncryptingCredentials(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member GetRequestorProofEncryptingCredentials : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Tokens.EncryptingCredentials&#xA;override this.GetRequestorProofEncryptingCredentials : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Tokens.EncryptingCredentials" Usage="securityTokenService.GetRequestorProofEncryptingCredentials request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.EncryptingCredentials</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący przychodzące żądania tokenu (RST).</param>
        <summary>Pobiera dowód żądającego szyfrowania poświadczeń.</summary>
        <returns>
          <see cref="T:System.IdentityModel.Tokens.EncryptingCredentials" /> Obiekt, który reprezentuje obiekt żądający użytkownika szyfrowania poświadczeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana z <xref:System.IdentityModel.SecurityTokenService.GetProofToken%2A> metody.  
  
 Domyślna implementacja wykonuje następujące czynności. Zwraca `null` czy token nie szyfrowania określony w żądaniu ( <xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken.ProofEncryption%2A?displayProperty=nameWithType> właściwość `null`). W przeciwnym razie, jeśli ją pobrać token jako <xref:System.IdentityModel.Tokens.X509SecurityToken>, funkcja zwraca poświadczeń opartych na ten token. Jeśli nie można rozwiązać, token jako <xref:System.IdentityModel.Tokens.X509SecurityToken>, <xref:System.IdentityModel.RequestFailedException> zgłaszany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="request" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse GetResponse (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse GetResponse(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetResponse(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Tokens.SecurityTokenDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetResponse (request As RequestSecurityToken, tokenDescriptor As SecurityTokenDescriptor) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ GetResponse(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Tokens::SecurityTokenDescriptor ^ tokenDescriptor);" />
      <MemberSignature Language="F#" Value="abstract member GetResponse : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.GetResponse : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.GetResponse (request, tokenDescriptor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="tokenDescriptor" Type="System.IdentityModel.Tokens.SecurityTokenDescriptor" />
      </Parameters>
      <Docs>
        <param name="request">RST, który zawiera żądania tokenu.</param>
        <param name="tokenDescriptor">Tokenu deskryptor, który zawiera informacje na potrzeby wystawiony token.</param>
        <summary>Tworzy odpowiedź (RSTR), która zawiera wystawiony token przy użyciu określonego żądania (RST) i tokenu deskryptora zabezpieczeń.</summary>
        <returns>Odpowiedź (RSTR) lub <see langword="null" /> Jeżeli odpowiedź nie można utworzyć z określonego żądania i deskryptora tokenu. Domyślna implementacja zwraca <see langword="null" /> Jeśli <paramref name="tokenDescriptor" /> parametr <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A> Metoda jest wywoływana jako ostatni etap w potoku wystawiania tokenu jest implementowany przez <xref:System.IdentityModel.SecurityTokenService.Issue%2A> metody. Tworzy i zwraca odpowiedź (RSTR) przy użyciu oryginalnego żądania przychodzące (RST) i tokenu deskryptor, który został zbudowany w poprzednich krokach w potoku wystawiania tokenu.  
  
 Domyślna implementacja tworzy RSTR, przekazując RST określonego w parametrze żądania do <xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse.%23ctor%28System.IdentityModel.Protocols.WSTrust.WSTrustMessage%29?displayProperty=nameWithType> konstruktora, wywołując <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.ApplyTo%2A?displayProperty=nameWithType> metody deskryptora token przekazany do <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A> do jego właściwości w celu zastosowania nowo utworzone RSTR, ustawienie <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.AppliesTo%2A> właściwość RSTR przy użyciu <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A> właściwości deskryptora token, a na koniec <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.ReplyTo%2A> właściwość RSTR zgodnie z poniższą tabelą:  
  
|`RST.ReplyTo` Właściwość|<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A?displayProperty=nameWithType> Właściwość.|`RSTR.ReplyTo` Właściwość|  
|----------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------|  
|Zestaw|Nieustawiona|Nieustawiona|  
|Zestaw|Zestaw|<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A?displayProperty=nameWithType>|  
|Nieustawiona|Zestaw|Nieustawiona|  
|Nieustawiona|Nieustawiona|Nieustawiona|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetScope">
      <MemberSignature Language="C#" Value="protected abstract System.IdentityModel.Scope GetScope (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Scope GetScope(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScope (principal As ClaimsPrincipal, request As RequestSecurityToken) As Scope" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IdentityModel::Scope ^ GetScope(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member GetScope : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Scope" Usage="securityTokenService.GetScope (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> reprezentujący klienta wysyłającego żądanie.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący żądanie przychodzące (RST).</param>
        <summary>Pobiera <see cref="T:System.IdentityModel.Scope" /> obiektu, który zawiera informacje dotyczące jednostki uzależnionej (RP) skojarzonej z określonym żądaniem (RST). Należy przesłonić tę metodę w danej implementacji <see cref="T:System.IdentityModel.SecurityTokenService" /> klasy.</summary>
        <returns>A <see cref="T:System.IdentityModel.Scope" /> który hermetyzuje informacje RP skojarzony z tym żądaniem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> Metoda jest wywoływana z potoku wystawiania tokenu po <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> metody i powinien zwrócić <xref:System.IdentityModel.Scope> obiektu skonfigurowany do żądania przychodzącego. (Potoku wystawiania tokenu jest zaimplementowana w <xref:System.IdentityModel.SecurityTokenService.Issue%2A> metody.) <xref:System.IdentityModel.Scope> Obiektu hermetyzuje informacje dotyczące jednostki Uzależnionej skojarzonej z żądaniem tokenu zabezpieczeń (RST). Zawiera informacje dotyczące szyfrowania i podpisywania poświadczenia do użycia z RP i umożliwia określenie, czy szyfrowanie wystawione tokeny i/lub klucze symetryczne w odpowiedzi. Niektóre typowe zadania wykonywane w <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> metoda są:  
  
-   Określić, czy jednostki Uzależnionej, dla których przeznaczony jest token jest rozpoznany jednostki Uzależnionej. Jak można to osiągnąć, zależy od implementacji. Jeśli zamierzony punktu przywracania nie jest prawidłową jednostkę Uzależnioną dla tej usługi STS, a następnie metoda powinno zgłosić <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
-   Określić poświadczeń podpisywania używanych w odpowiedzi (RSTR) i ustaw <xref:System.IdentityModel.Scope.SigningCredentials%2A> właściwość odpowiednio.  
  
-   Określ, czy odpowiedź i/lub klucze symetryczne dołączony powinien być zaszyfrowany i poświadczenia, które mają być używane do szyfrowania. Ustaw <xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A>, <xref:System.IdentityModel.Scope.SymmetricKeyEncryptionRequired%2A>, i <xref:System.IdentityModel.Scope.EncryptingCredentials%2A> właściwości odpowiednio.  
  
    > [!IMPORTANT]
    >  Domyślnie <xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A> i <xref:System.IdentityModel.Scope.SymmetricKeyEncryptionRequired%2A> właściwości są ustawiane `true` aby uniemożliwić wystawianie tokenów, które nie są zabezpieczone przez usługi STS. Zalecane jest, że te nigdy nie można ustawić właściwości `false` w środowisku produkcyjnym.  
  
-   Określ adres, do którego ma zostać zwrócony odpowiedzi. Ustaw <xref:System.IdentityModel.Scope.AppliesToAddress%2A> lub <xref:System.IdentityModel.Scope.ReplyToAddress%2A> właściwość odpowiednio.  
  
   
  
## Examples  
 Przykład kodu, który jest używany w tym temacie jest pobierana z `Custom Token` próbki. W tym przykładzie zawiera niestandardowych klas, które umożliwiają przetwarzanie tokenów sieci Web proste (SWT), a także implementacja pasywną usługą STS, który umożliwia obsługę tokenu SWT. Na przykład sposób implementacji aktywną usługą STS widać `Federation Metadata` próbki. Aby uzyskać informacji o tych przykładów i inne przykłady, które są dostępne dla programu WIF i o tym, gdzie można je pobrać, zobacz [Indeks przykładów kodu programu WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 Poniższy przykład kodu przedstawia implementację <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> metody. Ta implementacja sprawdza, czy jednostki Uzależnionej jest rozpoznawany przez usługę STS, sprawdza poprawność <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.ReplyTo%2A> adres w żądaniu i zestawy <xref:System.IdentityModel.Scope.ReplyToAddress%2A?displayProperty=nameWithType> właściwość w związku z tym i certyfikatów podpisywania i szyfrowania poświadczeń do korzystania z jednostki Uzależnionej na podstawie zestawów stałe są w pliku.  
  
 [!code-csharp[WIFCustomTokenSTS#4](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#4)]  
[!code-csharp[WIFCustomTokenSTS#5](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#5)]  
[!code-csharp[WIFCustomTokenSTS#7](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Należy przesłonić tę metodę w danej implementacji <see cref="T:System.IdentityModel.SecurityTokenService" /> klasy.</para>
        </block>
        <altmember cref="T:System.IdentityModel.Scope" />
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityTokenHandler">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.SecurityTokenHandler GetSecurityTokenHandler (string requestedTokenType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityTokenHandler GetSecurityTokenHandler(string requestedTokenType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetSecurityTokenHandler(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSecurityTokenHandler (requestedTokenType As String) As SecurityTokenHandler" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::SecurityTokenHandler ^ GetSecurityTokenHandler(System::String ^ requestedTokenType);" />
      <MemberSignature Language="F#" Value="abstract member GetSecurityTokenHandler : string -&gt; System.IdentityModel.Tokens.SecurityTokenHandler&#xA;override this.GetSecurityTokenHandler : string -&gt; System.IdentityModel.Tokens.SecurityTokenHandler" Usage="securityTokenService.GetSecurityTokenHandler requestedTokenType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandler</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestedTokenType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="requestedTokenType">Ciąg, który zawiera identyfikator URI żądanego typu tokenu.</param>
        <summary>Pobiera programu obsługi tokenów zabezpieczeń odpowiednich do wystawiania tokenu zabezpieczeń dla określonego typu.</summary>
        <returns>A <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler" /> reprezentujący programu obsługi tokenów służący do tworzenia tokenu zabezpieczeń. Zwraca <see langword="null" /> Jeśli żądany typ tokenu nie jest obsługiwany (Brak żadna procedura obsługi skonfigurowane dla określonego typu tokenu).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W implementacji domyślnej Jeśli `requestedTokenType` jest `null` lub pusty ciąg, domyślnie używany jest typ tokenu z konfiguracji. Jest to określone przez <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenType%2A> własności obiektu konfiguracji usługi STS, które są dostępne za pośrednictwem <xref:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration%2A> właściwości.  
  
 Ta metoda jest wywoływana z domyślnej potoku wystawiania tokenu jest zaimplementowana w <xref:System.IdentityModel.SecurityTokenService.Issue%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetTokenLifetime">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Protocols.WSTrust.Lifetime GetTokenLifetime (System.IdentityModel.Protocols.WSTrust.Lifetime requestLifetime);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.Lifetime GetTokenLifetime(class System.IdentityModel.Protocols.WSTrust.Lifetime requestLifetime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetTokenLifetime(System.IdentityModel.Protocols.WSTrust.Lifetime)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTokenLifetime (requestLifetime As Lifetime) As Lifetime" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Protocols::WSTrust::Lifetime ^ GetTokenLifetime(System::IdentityModel::Protocols::WSTrust::Lifetime ^ requestLifetime);" />
      <MemberSignature Language="F#" Value="abstract member GetTokenLifetime : System.IdentityModel.Protocols.WSTrust.Lifetime -&gt; System.IdentityModel.Protocols.WSTrust.Lifetime&#xA;override this.GetTokenLifetime : System.IdentityModel.Protocols.WSTrust.Lifetime -&gt; System.IdentityModel.Protocols.WSTrust.Lifetime" Usage="securityTokenService.GetTokenLifetime requestLifetime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.Lifetime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestLifetime" Type="System.IdentityModel.Protocols.WSTrust.Lifetime" />
      </Parameters>
      <Docs>
        <param name="requestLifetime">A <see cref="T:System.IdentityModel.Protocols.WSTrust.Lifetime" /> reprezentujący żądanego okresu istnienia.</param>
        <summary>Pobiera okres istnienia dla wystawiony token.</summary>
        <returns>A <see cref="T:System.IdentityModel.Protocols.WSTrust.Lifetime" /> reprezentujący udzielone okresu istnienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody zwykle jest wywoływana z okresu istnienia, który dotarła RST. W implementacji domyślnej okres istnienia tokenu jest obliczany zgodnie z poniższą tabelą.  
  
|Utworzone (ruch przychodzący)|Wygasa (ruch przychodzący)|Utworzone (ruch przychodzący)|Wygasa (out)|  
|--------------------|--------------------|--------------------|---------------------|  
|`null`|`null`|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType>|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType> + <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenLifetime%2A?displayProperty=nameWithType>|  
|C|`null`|C|C + <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenLifetime%2A?displayProperty=nameWithType>|  
|`null`|E|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType>|E|  
|C|E|C|E|  
  
 Ta metoda jest wywoływana z domyślnej potoku wystawiania tokenu jest zaimplementowana w <xref:System.IdentityModel.SecurityTokenService.Issue%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="Issue">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Issue (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Issue(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Issue (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Issue(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Issue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Issue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Issue (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> reprezentujący tożsamości obiektu żądającego tokenu.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący żądanie tokenu zabezpieczeń. W tym żądaniu wiadomości, a także innych klientów powiązane informacje, takie jak kontekst autoryzacji.</param>
        <summary>Wystawia token zabezpieczający.</summary>
        <returns>Element <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> zawierający tokenu zabezpieczeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda implementuje powiązania problem z definicją w specyfikacji WS-Trust. Domyślna implementacja klasy <xref:System.IdentityModel.SecurityTokenService.Issue%2A> metoda przetwarza żądanie przychodzące (RST) za pośrednictwem potoku wystawiania tokenu (wystawiania oświadczeń) i zwraca albo odpowiedzi (RSTR) zawierający token zabezpieczający z odpowiednie oświadczenia do uwierzytelniania Obiekt żądający z jednostki Uzależnionej lub odpowiedni wyjątek. Potoku wystawiania tokenów w implementacji domyślnej składa się z następujących metod wywołania (z <xref:System.IdentityModel.SecurityTokenService> klasy).  
  
1.  <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> Metodę weryfikacji żądania (RST).  
  
2.  <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> Metodę, aby uzyskać <xref:System.IdentityModel.Scope> obiektu, który zawiera informacje dotyczące jednostki uzależnionej (RP) skojarzonej z żądaniem. Należy przesłonić tę metodę. Jeśli <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> zwraca `null`, <xref:System.InvalidOperationException> zgłaszany.  
  
3.  <xref:System.IdentityModel.SecurityTokenService.CreateSecurityTokenDescriptor%2A> Metody zwracają token deskryptor zabezpieczeń oparte na RST i <xref:System.IdentityModel.Scope> obiekt jest zwracany w poprzednim kroku. Token deskryptora zabezpieczeń (<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor>) zawiera informacje o żądaniu w formularzu, który może być używany przez program obsługi tokena. <xref:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor%2A?displayProperty=nameWithType> Właściwość jest ustawiona na deskryptora zwracany przez wywołanie. Jeśli `null` zwróceniem lub jeśli <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.SigningCredentials%2A> właściwości deskryptora `null`, <xref:System.InvalidOperationException> zgłaszany. Wyjątek również jest generowany, jeśli <xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A?displayProperty=nameWithType> właściwość `true` ale <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.EncryptingCredentials%2A> właściwości deskryptora zwracany jest `null`.  
  
4.  <xref:System.IdentityModel.SecurityTokenService.GetSecurityTokenHandler%2A> Metodę, aby uzyskać odpowiednie programu obsługi tokenów oparte na rodzaju żądanego tokenu. Jeśli `null` zwracany jest <xref:System.NotImplementedException> zgłaszany.  
  
5.  <xref:System.IdentityModel.SecurityTokenService.GetIssuerName%2A> Metodę, aby uzyskać nazwę wystawcy dla tokenu. Zgłasza <xref:System.InvalidOperationException> Jeśli nazwa jest `null` lub pusty; w przeciwnym razie ustawia <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.TokenIssuerName%2A> właściwości deskryptora.  
  
6.  <xref:System.IdentityModel.SecurityTokenService.GetTokenLifetime%2A> Metodę, aby uzyskać okres istnienia tokenu i zestawy <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Lifetime%2A> właściwości deskryptora.  
  
7.  <xref:System.IdentityModel.SecurityTokenService.GetProofToken%2A> Metodę, aby uzyskać token potwierdzenia, które mają zostać objęte wystawiony token i zestawy <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Proof%2A> właściwości deskryptora.  
  
8.  <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> Metodę, aby uzyskać oświadczenia, które mają zostać objęte wystawiony token i zestawy <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Subject%2A> właściwości deskryptora. Należy przesłonić tę metodę.  
  
9. <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A> Metody do tworzenia odpowiedzi (RSTR), który zawiera wystawiony token.  
  
 Można zastąpić <xref:System.IdentityModel.SecurityTokenService.Issue%2A> metody do zaimplementowania potoku wystawiania tokenów niestandardowych; jednak nie jest to zazwyczaj konieczne w środowiskach deweloperskich i testowych, które najbardziej niestandardowych implementacji <xref:System.IdentityModel.SecurityTokenService> klasy są przeznaczone. W wielu przypadkach możesz zastąpić <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> i <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> metod i opcjonalnie zastąpić <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> metody w celu zapewnienia zdatne do użytku usługi STS w danym środowisku. Są niezbędne dodatkowe dostosowania często zapewnia go poprzez zastąpienie metody, które implementują każdy etap potoku wystawiania tokenu wymienionych powyżej domyślne.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Principal">
      <MemberSignature Language="C#" Value="public System.Security.Claims.ClaimsPrincipal Principal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Claims.ClaimsPrincipal Principal" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Principal" />
      <MemberSignature Language="VB.NET" Value="Public Property Principal As ClaimsPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Claims::ClaimsPrincipal ^ Principal { System::Security::Claims::ClaimsPrincipal ^ get(); void set(System::Security::Claims::ClaimsPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Principal : System.Security.Claims.ClaimsPrincipal with get, set" Usage="System.IdentityModel.SecurityTokenService.Principal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia podmiot zabezpieczeń skojarzony z bieżącym wystąpieniem.</summary>
        <value>A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> reprezentujący bieżący podmiot zabezpieczeń.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Renew">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Renew (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Renew(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Renew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Renew (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Renew(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Renew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Renew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Renew (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> reprezentujący tożsamości obiektu żądającego tokenu.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący żądanie tokenu zabezpieczeń. W tym żądaniu wiadomości, a także innych klientów powiązane informacje, takie jak kontekst autoryzacji.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, przetwarza żądanie odnowienia WS-Trust.</summary>
        <returns>A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> reprezentujący RSTR, aby powrócić do obiektu wywołującego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Protocols.WSTrust.RequestSecurityToken Request { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken Request" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Request" />
      <MemberSignature Language="VB.NET" Value="Public Property Request As RequestSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ Request { System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ get(); void set(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken with get, set" Usage="System.IdentityModel.SecurityTokenService.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia żądanie tokenu zabezpieczeń (RST) skojarzone z bieżącym wystąpieniem.</summary>
        <value>Element <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> zawierający żądania.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Scope">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Scope Scope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Scope Scope" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Scope" />
      <MemberSignature Language="VB.NET" Value="Public Property Scope As Scope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Scope ^ Scope { System::IdentityModel::Scope ^ get(); void set(System::IdentityModel::Scope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Scope : System.IdentityModel.Scope with get, set" Usage="System.IdentityModel.SecurityTokenService.Scope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zakres skojarzony z bieżącym wystąpieniem.</summary>
        <value>A <see cref="T:System.IdentityModel.Scope" /> reprezentujący konfigurację dla żądania wystawiania tokenu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SecurityTokenDescriptor">
      <MemberSignature Language="C#" Value="protected System.IdentityModel.Tokens.SecurityTokenDescriptor SecurityTokenDescriptor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenDescriptor SecurityTokenDescriptor" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />
      <MemberSignature Language="VB.NET" Value="Protected Property SecurityTokenDescriptor As SecurityTokenDescriptor" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::IdentityModel::Tokens::SecurityTokenDescriptor ^ SecurityTokenDescriptor { System::IdentityModel::Tokens::SecurityTokenDescriptor ^ get(); void set(System::IdentityModel::Tokens::SecurityTokenDescriptor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityTokenDescriptor : System.IdentityModel.Tokens.SecurityTokenDescriptor with get, set" Usage="System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenDescriptor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.IdentityModel.Tokens.SecurityTokenDescriptor" /> skojarzone z bieżącym wystąpieniem.</summary>
        <value>Token deskryptora zabezpieczeń skojarzony z bieżącym wystąpieniem.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Podjęto próbę ustawienia właściwości <see langword="null" /> występuje.</exception>
      </Docs>
    </Member>
    <Member MemberName="SecurityTokenServiceConfiguration">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Configuration.SecurityTokenServiceConfiguration SecurityTokenServiceConfiguration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Configuration.SecurityTokenServiceConfiguration SecurityTokenServiceConfiguration" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SecurityTokenServiceConfiguration As SecurityTokenServiceConfiguration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ SecurityTokenServiceConfiguration { System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SecurityTokenServiceConfiguration : System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" Usage="System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Configuration.SecurityTokenServiceConfiguration</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera właściciela wystąpienia konfiguracji.</summary>
        <value>Element <see cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" /> zawierający konfigurację dla bieżącego wystąpienia.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Validate (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Validate(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Validate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Validate (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Validate(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Validate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Validate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Validate (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> reprezentujący tożsamości obiektu żądającego tokenu.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący żądanie tokenu zabezpieczeń. W tym żądaniu wiadomości, a także innych klientów powiązane informacje, takie jak kontekst autoryzacji.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, przetwarza żądanie weryfikacji WS-Trust.</summary>
        <returns>A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> reprezentujący RSTR, aby powrócić do obiektu wywołującego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateRequest">
      <MemberSignature Language="C#" Value="protected virtual void ValidateRequest (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ValidateRequest(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.ValidateRequest(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ValidateRequest (request As RequestSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ValidateRequest(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member ValidateRequest : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; unit&#xA;override this.ValidateRequest : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; unit" Usage="securityTokenService.ValidateRequest request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący żądanie.</param>
        <summary>Weryfikuje żądanie tokenu zabezpieczeń (RST) zamknięte przez to wystąpienie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> Metoda jest wywoływana z potoku wystawiania tokenu ( <xref:System.IdentityModel.SecurityTokenService.Issue%2A> metody) do sprawdzania poprawności RST przychodzących. RST jest weryfikowane względem wymagań (zasady) usługi STS i odpowiedni wyjątek jest generowany, jeśli jest on nieprawidłowy.  
  
 Domyślna implementacja klasy <xref:System.IdentityModel.SecurityTokenService> klasy obsługuje tylko wzorzec RST RSTR i powiązania w problem specyfikacji WS-Trust ( <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.RequestType%2A> musi być równa właściwości żądania <xref:System.IdentityModel.Protocols.WSTrust.RequestTypes.Issue?displayProperty=nameWithType>). Domyślna implementacja tej metody wymusza tych wymagań (i innych wymienionych w sekcji wyjątki). Mogą przesłaniać tę metodę, jeśli muszą wymuszać wymagań różnych weryfikacji dla swojej niestandardowej usługi STS.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IdentityModel.Protocols.WSTrust.InvalidRequestException">
          <paramref name="request" /> jest <see langword="null" />.  
  
—lub— 
<see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.RequestType" /> Nie ustawiono właściwości żądania <see cref="F:System.IdentityModel.Protocols.WSTrust.RequestTypes.Issue" />.  
  
—lub— 
<see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.KeyType" /> Właściwość żądania nie jest <see langword="null" /> lub jednej ze stałych zdefiniowane w <see cref="T:System.IdentityModel.Protocols.WSTrust.KeyTypes" /> klasy.  
  
—lub— 
<see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.KeyType" /> Żądania jest <see cref="F:System.IdentityModel.Protocols.WSTrust.KeyTypes.Bearer" /> i <see langword="KeySize" /> element jest obecny, ale jego wartość nie jest równa zero.</exception>
        <exception cref="T:System.IdentityModel.UnsupportedTokenTypeBadRequestException">Usługa tokenu Zabezpieczającego nie obsługuje typu token żądania (na podstawie wartości z <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.TokenType" /> właściwości żądania).</exception>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
  </Members>
</Type>
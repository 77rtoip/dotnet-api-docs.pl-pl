<Type Name="SecurityTokenService" FullName="System.IdentityModel.SecurityTokenService">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3072d0bfe35d86653ef23ec20b08a5f210b357ba" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30455643" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SecurityTokenService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SecurityTokenService extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.SecurityTokenService" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SecurityTokenService" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityTokenService abstract" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Abstrakcyjna klasa podstawowa, która definiuje właściwości i metody usługi tokenu zabezpieczającego (STS).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do utworzenia tokenu Zabezpieczającego musi pochodzić od <xref:System.IdentityModel.SecurityTokenService> klasy. W klasie niestandardowych co najmniej przesłonięcia <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> i <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> metody. Te zastąpienia STS utworzone za pomocą Domyślna implementacja wszystkie inne metody zdefiniowanej w klasie jest może wystawiać tokeny zabezpieczające w odpowiedzi na zabezpieczeń żądania tokenu (RST). Oznacza to, że powiązanie problem zdefiniowane w specyfikacji WS-Trust jest zaimplementowana. To powiązanie jest zaimplementowana w <xref:System.IdentityModel.SecurityTokenService.Issue%2A> metody. Brak innych powiązania WS-Trust (odnawiania, Anuluj i sprawdzania poprawności) zostały zaimplementowane w przypadku domyślnym i odpowiednie błąd jest zwracany do obiektu wywołującego po napotkaniu RST, która odpowiada jednej z tych powiązań. Oczywiście można zastąpić odpowiednie metody (<xref:System.IdentityModel.SecurityTokenService.Renew%2A>, <xref:System.IdentityModel.SecurityTokenService.Cancel%2A>, i <xref:System.IdentityModel.SecurityTokenService.Validate%2A>) do zaimplementowania tych powiązań w Twojej usługi STS.  
  
> [!IMPORTANT]
>  Implementowanie STS gotowe do produkcji pociąga za sobą, należy dokładnie zaplanować i znaczne zasobów, aby ograniczyć potencjalne zagrożenia bezpieczeństwa związane z udostępnianie takiej usługi. Większość deweloperów przy użyciu systemu Windows Identity Foundation (WIF) będzie można tworzenia aplikacji, które zewnętrzny Zarządzanie tożsamościami do usługi tokenu Zabezpieczającego, a nie samego tworzenia tokenu Zabezpieczającego. WIF udostępnia rozszerzenie programu Visual Studio, tożsamość i narzędzie dostępu do programu Visual Studio 2012, aby pomóc deweloperom testowanie rozwiązań w środowisku programistycznym. To narzędzie zawiera tokenu Zabezpieczającego `LocalSTS`, które można skonfigurować do obsługi oświadczenia właściwe dla aplikacji, które tworzysz. Aby uzyskać więcej informacji o narzędziu tożsamościami i dostępem, zobacz [tożsamości i dostępu do narzędzi dla programu Visual Studio 2012](~/docs/framework/security/identity-and-access-tool-for-vs.md). W niektórych scenariuszach `LocalSTS` mogą nie zapewniać funkcje niezbędne do odpowiednio przetestować aplikację; przykładowo w scenariuszu, która obejmuje tworzenie programu obsługi tokenów niestandardowych do użytku przez aplikację. W takich przypadkach mogą dziedziczyć po <xref:System.IdentityModel.SecurityTokenService> można utworzyć jeden lub więcej STSs proste który można wdrożyć w środowisku projektowania i który może służyć do testowania tych funkcji w aplikacji. W tej sekcji reszty koncentruje się na metody ujawnione przez <xref:System.IdentityModel.SecurityTokenService> klasy umożliwiające implementowanie prostego STS i rozszerzanie Potok wydawania tokenów.  
  
 Poniższa lista zawiera krótki przegląd metod podstawowe znaczenie deweloperowi do użycia w środowisku testowym lub programowanie.  
  
-   <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> Metody. Ta metoda zwraca <xref:System.IdentityModel.Scope> obiektu, który zawiera informacje o planu odzyskiwania. Ten obiekt jest używany w pozostałej części potok wydawania tokenów i zawiera informacje na temat podpisywania i szyfrowania poświadczeń do użycia w odpowiedzi, a także `AppliesTo` i `ReplyTo` (jeśli jest to wymagane) adresów. Należy przesłonić tę metodę.  
  
-   <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> Metody. Ta metoda zwraca <xref:System.Security.Claims.ClaimsIdentity> obiekt, który zawiera oświadczenia, aby powrócić do planu odzyskiwania. Należy przesłonić tę metodę.  
  
-   <xref:System.IdentityModel.SecurityTokenService.Issue%2A> Metody. Ta metoda implementuje potoku żądania tokenu, który przetwarza przychodzące żądanie tokenu zabezpieczeń (RST) i zwraca odpowiedź (odpowiedź RSTR) do obiektu wywołującego, który zawiera token, który może służyć do uwierzytelniania w usłudze RP. Wiele innych metod zdefiniowane w <xref:System.IdentityModel.SecurityTokenService> klasy są wywoływane z tej metody, w tym <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> i <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> metody. Nie należy przesłonić tę metodę, ale opis potoku żądania tokenu, który implementuje mogą być pomocne.  
  
 STS jest skonfigurowana za pośrednictwem <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration> klasy.  
  
   
  
## Examples  
 Przykłady kodu, które są używane w <xref:System.IdentityModel.SecurityTokenService> tematy są pobierane z `Custom Token` próbki. Ten przykład zawiera klas niestandardowych, które umożliwiają przetwarzania tokenów sieci Web proste (SWT), a także implementacja pasywnym STS jest w stanie obsłużyć SWT token. Na przykład sposobu wdrażania usługi tokenu Zabezpieczającego active widać `Federation Metadata` próbki. Dla informacji o te przykłady i inne przykłady, które są dostępne dla WIF i o tym, gdzie można je pobrać, zobacz [indeksu przykładowy kod WIF](~/docs/framework/security/wif-code-sample-index.md). Poniższy kod przedstawia implementację pasywnym STS przy użyciu <xref:System.IdentityModel.SecurityTokenService> klasy.  
  
 [!code-csharp[WIFCustomTokenSTS#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#3)]  
  
 Poniższy kod przedstawia sposób wywołania niestandardowych STS pasywnym żądania WS-Federation przez wywołanie metody <xref:System.IdentityModel.Services.FederatedPassiveSecurityTokenServiceOperations.ProcessRequest%28System.Web.HttpRequest%2CSystem.Security.Claims.ClaimsPrincipal%2CSystem.IdentityModel.SecurityTokenService%2CSystem.Web.HttpResponse%29?displayProperty=nameWithType> metoda w kodzie w `default.aspx.cs` pliku.  
  
 [!code-csharp[WIFCustomTokenSTS#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/default.aspx.cs#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Konieczne jest przesłonięcie zarówno <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" /> i <see cref="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" /> metody.</para>
    </block>
    <altmember cref="T:System.IdentityModel.Scope" />
    <altmember cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />
    <altmember cref="T:System.IdentityModel.Services.FederatedPassiveSecurityTokenServiceOperations" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SecurityTokenService (System.IdentityModel.Configuration.SecurityTokenServiceConfiguration securityTokenServiceConfiguration);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IdentityModel.Configuration.SecurityTokenServiceConfiguration securityTokenServiceConfiguration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.#ctor(System.IdentityModel.Configuration.SecurityTokenServiceConfiguration)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SecurityTokenService(System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ securityTokenServiceConfiguration);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="securityTokenServiceConfiguration" Type="System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />
      </Parameters>
      <Docs>
        <param name="securityTokenServiceConfiguration">A <see cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" /> zawierający ustawienia dla usługi STS.</param>
        <summary>Wywoływana z klas pochodnych zainicjować <see cref="T:System.IdentityModel.SecurityTokenService" /> przy użyciu określonych ustawień konfiguracyjnych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zainicjować dostawcy zakresu i certyfikat wystawcy tokenów, należy użyć tego konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="securityTokenServiceConfiguration" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginCancel">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginCancel (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginCancel(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginCancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginCancel (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginCancel(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> reprezentujący tożsamość żądającego tokenu.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący żądania tokenu zabezpieczeń. W tym żądaniu wiadomości, a także innych klienta powiązane informacje, takie jak kontekst autoryzacji.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, która odbiera powiadomienia o ukończeniu operacji asynchronicznej Anuluj.</param>
        <param name="state">Obiekt zawierający informacje o stanie skojarzone z operacji asynchronicznych anulowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się asynchroniczne żądanie usługi WS-Trust anulować.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się operacja asynchronicznego anulowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected virtual IAsyncResult BeginGetOutputClaimsIdentity (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult BeginGetOutputClaimsIdentity(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IAsyncResult ^ BeginGetOutputClaimsIdentity(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> reprezentujący tożsamość żądającego tokenu.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący żądania tokenu zabezpieczeń. W tym żądaniu wiadomości, a także innych klienta powiązane informacje, takie jak kontekst autoryzacji.</param>
        <param name="scope">
          <see cref="T:System.IdentityModel.Scope" /> Zawierający informacje dotyczące jednostki uzależnionej skojarzonej z żądaniem.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, która odbiera powiadomienia o ukończeniu operacji asynchronicznej.</param>
        <param name="state">Obiekt zawierający informacje o stanie skojarzone z operacji asynchronicznej.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się wywołanie asynchroniczne <see cref="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" /> metody.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się operacja asynchroniczna.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetScope">
      <MemberSignature Language="C#" Value="protected virtual IAsyncResult BeginGetScope (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult BeginGetScope(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function BeginGetScope (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IAsyncResult ^ BeginGetScope(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> reprezentujący tożsamość żądającego tokenu.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący żądania tokenu zabezpieczeń. W tym żądaniu wiadomości, a także innych klienta powiązane informacje, takie jak kontekst autoryzacji.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, która odbiera powiadomienia o ukończeniu operacji asynchronicznej.</param>
        <param name="state">Obiekt zawierający informacje o stanie skojarzone z operacji asynchronicznej.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się wywołanie asynchroniczne dla <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" /> metody.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się operacja asynchronicznego anulowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginIssue">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginIssue (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginIssue(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginIssue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginIssue (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginIssue(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> reprezentujący tożsamość żądającego tokenu.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący żądania tokenu zabezpieczeń. W tym żądaniu wiadomości, a także innych klienta powiązane informacje, takie jak kontekst autoryzacji.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, która odbiera powiadomienia o ukończeniu operacji asynchronicznej problem.</param>
        <param name="state">Obiekt zawierający informacje o stanie skojarzonych z operacją asynchroniczną problem.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się asynchroniczne żądanie usługi WS-Trust problem.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się operacja asynchronicznego problem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRenew">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginRenew (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginRenew(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginRenew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginRenew (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginRenew(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> reprezentujący tożsamość żądającego tokenu.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący żądania tokenu zabezpieczeń. W tym żądaniu wiadomości, a także innych klienta powiązane informacje, takie jak kontekst autoryzacji.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, która odbiera powiadomienia o zakończeniu asynchroniczną odnowić operacji.</param>
        <param name="state">Obiekt zawierający informacje o stanie skojarzone z asynchroniczną odnowić operacji.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się asynchroniczne żądanie odnowienia WS-Trust.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Czy odwołania asynchroniczną odnowić operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginValidate">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginValidate (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginValidate(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginValidate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginValidate (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginValidate(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> reprezentujący tożsamość żądającego tokenu.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący żądania tokenu zabezpieczeń. W tym żądaniu wiadomości, a także innych klienta powiązane informacje, takie jak kontekst autoryzacji.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, która odbiera powiadomienia o zakończeniu asynchroniczną weryfikowanie operacji.</param>
        <param name="state">Obiekt zawierający informacje o stanie skojarzone z asynchroniczną weryfikowanie operacji.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się asynchroniczne żądanie usługi WS-Trust sprawdzania poprawności.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Czy odwołania asynchroniczną weryfikowanie operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cancel">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Cancel (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Cancel(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Cancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Cancel (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Cancel(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> reprezentujący tożsamość żądającego tokenu.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący żądania tokenu zabezpieczeń. W tym żądaniu wiadomości, a także innych klienta powiązane informacje, takie jak kontekst autoryzacji.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, przetwarza żądanie anulowania WS-Trust.</summary>
        <returns>A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> reprezentujący odpowiedź RSTR, aby powrócić do obiektu wywołującego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSecurityTokenDescriptor">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.SecurityTokenDescriptor CreateSecurityTokenDescriptor (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityTokenDescriptor CreateSecurityTokenDescriptor(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.CreateSecurityTokenDescriptor(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::SecurityTokenDescriptor ^ CreateSecurityTokenDescriptor(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="request">Przychodzące żądania tokenu.</param>
        <param name="scope">
          <see cref="P:System.IdentityModel.SecurityTokenService.Scope" /> Obiektu zwróconego z <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />.</param>
        <summary>Tworzy wystąpienie <see cref="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />.</summary>
        <returns>
          <see cref="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływane podczas wystawiania tokenu po <xref:System.IdentityModel.SecurityTokenService.GetScope%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="request" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="scope" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndCancel">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndCancel (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndCancel(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndCancel(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndCancel (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndCancel(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Który jest zwracany przez wywołanie do <see cref="M:System.IdentityModel.SecurityTokenService.BeginCancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> metody.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wykonuje asynchroniczne żądanie anulowania WS-Trust.</summary>
        <returns>A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> reprezentujący odpowiedź RSTR, aby powrócić do obiektu wywołującego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected virtual System.Security.Claims.ClaimsIdentity EndGetOutputClaimsIdentity (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Security.Claims.ClaimsIdentity EndGetOutputClaimsIdentity(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndGetOutputClaimsIdentity(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function EndGetOutputClaimsIdentity (result As IAsyncResult) As ClaimsIdentity" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Security::Claims::ClaimsIdentity ^ EndGetOutputClaimsIdentity(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsIdentity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Który jest zwracany przez wywołanie do <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" /> metody.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wykonuje asynchroniczne wywołanie <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" /> metody.</summary>
        <returns>A <see cref="T:System.Security.Claims.ClaimsIdentity" /> zawierający kolekcję oświadczenia, które zostaną umieszczone w tokenie zabezpieczającym wystawione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetScope">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Scope EndGetScope (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Scope EndGetScope(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndGetScope(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function EndGetScope (result As IAsyncResult) As Scope" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Scope ^ EndGetScope(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Który jest zwracany przez wywołanie do <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> metody.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wykonuje asynchroniczne wywołanie <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> metody.</summary>
        <returns>A <see cref="T:System.IdentityModel.Scope" /> która hermetyzuje jednostki uzależnionej informacje firmy (RP) skojarzony z żądaniem (RST) określona w wywołaniu <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndIssue">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndIssue (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndIssue(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndIssue(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndIssue (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndIssue(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Który jest zwracany przez wywołanie do <see cref="M:System.IdentityModel.SecurityTokenService.BeginIssue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> metody.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wykonuje asynchroniczne żądanie usługi WS-Trust problem.</summary>
        <returns>A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> reprezentujący odpowiedź RSTR, aby powrócić do obiektu wywołującego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRenew">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndRenew (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndRenew(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndRenew(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndRenew (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndRenew(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Który jest zwracany przez wywołanie do <see cref="M:System.IdentityModel.SecurityTokenService.BeginRenew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> metody.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wykonuje asynchroniczne żądanie odnowienia WS-Trust.</summary>
        <returns>A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> reprezentujący odpowiedź RSTR, aby powrócić do obiektu wywołującego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndValidate">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndValidate (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndValidate(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndValidate(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndValidate (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndValidate(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Który jest zwracany przez wywołanie do <see cref="M:System.IdentityModel.SecurityTokenService.BeginValidate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> metody.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wykonuje asynchroniczne żądanie zweryfikowania WS-Trust.</summary>
        <returns>A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> reprezentujący odpowiedź RSTR, aby powrócić do obiektu wywołującego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIssuerName">
      <MemberSignature Language="C#" Value="protected virtual string GetIssuerName ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetIssuerName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetIssuerName" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetIssuerName () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetIssuerName();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera nazwę usługi tokenu zabezpieczającego (STS).</summary>
        <returns>Nazwa wystawcy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana z domyślnej potok wydawania tokenów zaimplementowana w <xref:System.IdentityModel.SecurityTokenService.Issue%2A> metody.  
  
 Domyślna implementacja zwraca <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.TokenIssuerName%2A> właściwości z konfiguracji dostępne za pośrednictwem <xref:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected abstract System.Security.Claims.ClaimsIdentity GetOutputClaimsIdentity (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Security.Claims.ClaimsIdentity GetOutputClaimsIdentity(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Security::Claims::ClaimsIdentity ^ GetOutputClaimsIdentity(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsIdentity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> reprezentujący tożsamość żądającego tokenu.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący żądania tokenu zabezpieczeń. W tym żądaniu wiadomości, a także innych klienta powiązane informacje, takie jak kontekst autoryzacji.</param>
        <param name="scope">
          <see cref="T:System.IdentityModel.Scope" /> Zawierający informacje dotyczące jednostki uzależnionej skojarzonej z żądaniem. Jest to <see cref="T:System.IdentityModel.Scope" /> obiekt, który został zwrócony przez <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" /> metody.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, ta metoda zwraca zbiór tematów dane wyjściowe do uwzględnienia w wystawionego tokenu.</summary>
        <returns>A <see cref="T:System.Security.Claims.ClaimsIdentity" /> zawierający kolekcję oświadczenia, które zostaną umieszczone w tokenie zabezpieczającym wystawione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> Metoda jest wywoływana z potoku wystawiania tokenu, który jest implementowany przez <xref:System.IdentityModel.SecurityTokenService.Issue%2A> metody. Zwraca <xref:System.Security.Claims.ClaimsIdentity> zawierający oświadczenia do uwzględnienia w tokenie zabezpieczeń oparte na obiekt żądający tokenu ( `principal` parametru), RST przychodzące ( `request` parametru), i uzależnionej, dla którego token jest przeznaczony () `scope` parametru). Logikę tej metody jest przede wszystkim odpowiedzieć na następujące pytania:  
  
-   **Które typy oświadczeń powinny być uwzględnione w odpowiedzi oparte na planu odzyskiwania, dla której jest przeznaczony?** Zwykle to decyzji na podstawie-RP z listy typów oświadczeń wymagane dla każdego planu odzyskiwania lub na podstawie danego żądania, sprawdzając <xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken.Claims%2A> właściwości żądania. Jednak wartości logiczne i szczegóły dotyczące określania oświadczeń do uwzględnienia w odpowiedzi jest całkowicie do implementacji.  
  
-   **Które wartości oświadczeń powinny zostać przypisane do oświadczeń w odpowiedzi?** Dla dostawcy tożsamości (Usługa STS protokołu IP) zazwyczaj oznacza to przy użyciu co najmniej jednego oświadczenia w obiektu żądającego <xref:System.Security.Claims.ClaimsPrincipal> (dostarczonych przez `principal` parametrów) do uzyskania dostępu do Sklepu (lub innego podmiotu), aby zwrócić wartości dla wymaganych typów oświadczeń. Dla dostawcy federacyjnego (R STS) zazwyczaj oznacza to wykonywanie określonego rodzaju przetwarzania na obiektu żądającego oświadczeń przychodzących do spełnienia żądania; na niektórych oświadczeń przedstawiony przez obiekt żądający, podczas przekazywania innymi przez niezmodyfikowany prawdopodobnie wykonywanie filtrowania lub transformacji. Oczywiście tak jak w przypadku podejmowania decyzji o tym, które oświadczenia do uwzględnienia w odpowiedzi szczegóły i logiki sposobu określania wartości tych oświadczeń zależy od implementacji.  
  
   
  
## Examples  
 Przykładowy kod, który jest używany w tym temacie jest pobierana z `Custom Token` próbki. Ten przykład zawiera klas niestandardowych, które umożliwiają przetwarzania tokenów sieci Web proste (SWT), a także implementacja pasywnym STS jest w stanie obsłużyć SWT token. Na przykład sposobu wdrażania usługi tokenu Zabezpieczającego active widać `Federation Metadata` próbki. Dla informacji o te przykłady i inne przykłady, które są dostępne dla WIF i o tym, gdzie można je pobrać, zobacz [indeksu przykładowy kod WIF](~/docs/framework/security/wif-code-sample-index.md). Poniższy kod przedstawia sposób przesłonięcia <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> metoda zwraca oświadczenia dla Twojej usługi STS. W tym przykładzie komunikat żądania zabezpieczeń tokenu (RST) zostanie zignorowany i zwracany jest kolekcją oświadczenia na podstawie użytkownika, jak uwierzytelnieniu Usługa tokenu Zabezpieczającego.  
  
 [!code-csharp[WIFCustomTokenSTS#6](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Należy przesłonić tę metodę w implementacji <see cref="T:System.IdentityModel.SecurityTokenService" /> klasy.</para>
        </block>
        <altmember cref="T:System.IdentityModel.Scope" />
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetProofToken">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.ProofDescriptor GetProofToken (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.ProofDescriptor GetProofToken(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetProofToken(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::ProofDescriptor ^ GetProofToken(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.ProofDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący przychodzącego żądania tokenu (RST).</param>
        <param name="scope">
          <see cref="T:System.IdentityModel.Scope" /> Wystąpienia, który hermetyzuje informacje dotyczące jednostki uzależnionej.</param>
        <summary>Pobiera token potwierdzenia do uwzględnienia w odpowiedzi (odpowiedź RSTR).</summary>
        <returns>A <see cref="T:System.IdentityModel.Tokens.ProofDescriptor" /> reprezentujący nowo utworzony potwierdzającego deskryptora. Deskryptor potwierdzającego może być asymetrycznego deskryptora potwierdzającego, deskryptor potwierdzającego symetrycznego lub <see langword="null" /> w przypadku tokenu elementu nośnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana z domyślnej potok wydawania tokenów zaimplementowana w <xref:System.IdentityModel.SecurityTokenService.Issue%2A> metody.  
  
 Domyślna implementacja zwraca deskryptor potwierdzającego lub zgłasza wyjątek odpowiednie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="request" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="scope" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetRequestorProofEncryptingCredentials">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.EncryptingCredentials GetRequestorProofEncryptingCredentials (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.EncryptingCredentials GetRequestorProofEncryptingCredentials(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetRequestorProofEncryptingCredentials(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRequestorProofEncryptingCredentials (request As RequestSecurityToken) As EncryptingCredentials" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::EncryptingCredentials ^ GetRequestorProofEncryptingCredentials(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.EncryptingCredentials</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący przychodzącego żądania tokenu (RST).</param>
        <summary>Pobiera dowód obiektu żądającego szyfrowania poświadczeń.</summary>
        <returns>
          <see cref="T:System.IdentityModel.Tokens.EncryptingCredentials" /> Obiekt, który reprezentuje obiekt żądający do szyfrowania poświadczeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana z <xref:System.IdentityModel.SecurityTokenService.GetProofToken%2A> metody.  
  
 Domyślna implementacja wykonuje następujące czynności. Zwraca `null` Jeśli jest nie tokenu szyfrowania określony w żądaniu ( <xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken.ProofEncryption%2A?displayProperty=nameWithType> jest właściwość `null`). W przeciwnym razie, jeśli można uzyskać tokenu jako <xref:System.IdentityModel.Tokens.X509SecurityToken>, zwraca poświadczeń na podstawie tego tokenów. Jeśli nie można rozpoznać tokenu jako <xref:System.IdentityModel.Tokens.X509SecurityToken>, <xref:System.IdentityModel.RequestFailedException> jest generowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="request" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse GetResponse (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse GetResponse(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetResponse(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Tokens.SecurityTokenDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetResponse (request As RequestSecurityToken, tokenDescriptor As SecurityTokenDescriptor) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ GetResponse(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Tokens::SecurityTokenDescriptor ^ tokenDescriptor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="tokenDescriptor" Type="System.IdentityModel.Tokens.SecurityTokenDescriptor" />
      </Parameters>
      <Docs>
        <param name="request">RST, który zawiera żądania tokenu.</param>
        <param name="tokenDescriptor">Deskryptora token, który zawiera informacje na potrzeby wystawionego tokenu.</param>
        <summary>Tworzy odpowiedź (odpowiedź RSTR), która zawiera wystawionego tokenu przy użyciu określonego żądania (RST) i tokenów deskryptora zabezpieczeń.</summary>
        <returns>Odpowiedź (odpowiedź RSTR) lub <see langword="null" /> Jeśli odpowiedzi nie można utworzyć określonego żądania i deskryptora tokenu. Domyślna implementacja zwraca <see langword="null" /> Jeśli <paramref name="tokenDescriptor" /> parametr jest <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A> Metoda jest wywoływana jako ostatni etap w potoku wystawiania tokenu, który jest implementowany przez <xref:System.IdentityModel.SecurityTokenService.Issue%2A> metody. Tworzy i zwraca odpowiedź (odpowiedź RSTR) przy użyciu oryginalnego żądania przychodzącego (RST) i deskryptora token, który został zbudowany w poprzednich krokach w potoku wystawiania tokenu.  
  
 Domyślna implementacja tworzy komunikacie RSTR przez przekazanie RST określony w parametrze żądania do <xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse.%23ctor%28System.IdentityModel.Protocols.WSTrust.WSTrustMessage%29?displayProperty=nameWithType> konstruktora, wywoływania <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.ApplyTo%2A?displayProperty=nameWithType> przekazany do metody dla tokenu deskryptora <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A> do jej właściwości w celu zastosowania nowo utworzyć odpowiedź RSTR, ustawienie <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.AppliesTo%2A> właściwości w komunikacie RSTR przy użyciu <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A> właściwość deskryptor tokenu i ostatecznie ustawienie <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.ReplyTo%2A> właściwości w komunikacie RSTR zgodnie z poniższą tabelą:  
  
|`RST.ReplyTo` Właściwość|<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A?displayProperty=nameWithType> Właściwość.|`RSTR.ReplyTo` Właściwość|  
|----------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------|  
|zestaw|Nieustawiona|Nieustawiona|  
|zestaw|zestaw|<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A?displayProperty=nameWithType>|  
|Nieustawiona|zestaw|Nieustawiona|  
|Nieustawiona|Nieustawiona|Nieustawiona|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetScope">
      <MemberSignature Language="C#" Value="protected abstract System.IdentityModel.Scope GetScope (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Scope GetScope(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScope (principal As ClaimsPrincipal, request As RequestSecurityToken) As Scope" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IdentityModel::Scope ^ GetScope(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> reprezentujący klienta zgłoszenia żądania.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący żądania przychodzącego (RST).</param>
        <summary>Pobiera <see cref="T:System.IdentityModel.Scope" /> obiekt, który zawiera informacje dotyczące jednostki uzależnionej (RP) skojarzony z określonym żądaniem (RST). Należy przesłonić tę metodę w implementacji <see cref="T:System.IdentityModel.SecurityTokenService" /> klasy.</summary>
        <returns>A <see cref="T:System.IdentityModel.Scope" /> który hermetyzuje informacje RP skojarzone z żądaniem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> Metoda jest wywoływana z potoku wystawiania tokenu po <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> — metoda i powinien zwrócić <xref:System.IdentityModel.Scope> obiektu skonfigurowane dla żądania przychodzącego. (Potok wydawania tokenów jest zaimplementowana w <xref:System.IdentityModel.SecurityTokenService.Issue%2A> metody.) <xref:System.IdentityModel.Scope> Obiekt hermetyzujący informacje o RP skojarzony z żądaniem tokenu zabezpieczeń (RST). Zawiera informacje dotyczące szyfrowania i podpisywania poświadczenia do użycia z planu odzyskiwania i czy nie można zaszyfrować wystawione tokeny i/lub kluczy symetrycznych w odpowiedzi. Niektóre typowe zadania wykonywane w <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> metody są:  
  
-   Ustalić, czy planu odzyskiwania, dla której jest przeznaczony ten token jest rozpoznany planu odzyskiwania. Jak to zrobić, zależy od implementacji. Jeśli danego planu odzyskiwania nie jest prawidłową planu odzyskiwania dla tej usługi STS, a następnie metoda powinien zgłosić <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
-   Określić poświadczeń podpisywania używanych w odpowiedzi (odpowiedź RSTR) i ustawić <xref:System.IdentityModel.Scope.SigningCredentials%2A> właściwości odpowiednio.  
  
-   Ustal, czy ma być szyfrowana odpowiedzi i/lub klucze symetryczne dołączone i poświadczenia, które mają być używane do szyfrowania. Ustaw <xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A>, <xref:System.IdentityModel.Scope.SymmetricKeyEncryptionRequired%2A>, i <xref:System.IdentityModel.Scope.EncryptingCredentials%2A> właściwości odpowiednio.  
  
    > [!IMPORTANT]
    >  Domyślnie <xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A> i <xref:System.IdentityModel.Scope.SymmetricKeyEncryptionRequired%2A> właściwości są ustawione `true` aby uniemożliwić wystawianie tokenów, które nie są zabezpieczone przez usługi STS. Zaleca się, że te właściwości nie można ustawić `false` w środowisku produkcyjnym.  
  
-   Określ adres, do którego ma zostać zwrócony odpowiedzi. Ustawić <xref:System.IdentityModel.Scope.AppliesToAddress%2A> lub <xref:System.IdentityModel.Scope.ReplyToAddress%2A> właściwości odpowiednio.  
  
   
  
## Examples  
 Przykładowy kod, który jest używany w tym temacie jest pobierana z `Custom Token` próbki. Ten przykład zawiera klas niestandardowych, które umożliwiają przetwarzania tokenów sieci Web proste (SWT), a także implementacja pasywnym STS jest w stanie obsłużyć SWT token. Na przykład sposobu wdrażania usługi tokenu Zabezpieczającego active widać `Federation Metadata` próbki. Dla informacji o te przykłady i inne przykłady, które są dostępne dla WIF i o tym, gdzie można je pobrać, zobacz [indeksu przykładowy kod WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 Poniższy przykładowy kod przedstawia implementację <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> metody. Ta implementacja sprawdza, czy RP jest rozpoznawany przez usługę STS, sprawdza poprawność <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.ReplyTo%2A> adresu w żądania i zestawy <xref:System.IdentityModel.Scope.ReplyToAddress%2A?displayProperty=nameWithType> właściwości w związku z tym i certyfikatów podpisywania i szyfrowania poświadczeń do użycia w usłudze RP oparte na zestawy, które w pliku, są zakodowane na stałe.  
  
 [!code-csharp[WIFCustomTokenSTS#4](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#4)]  
[!code-csharp[WIFCustomTokenSTS#5](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#5)]  
[!code-csharp[WIFCustomTokenSTS#7](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Należy przesłonić tę metodę w implementacji <see cref="T:System.IdentityModel.SecurityTokenService" /> klasy.</para>
        </block>
        <altmember cref="T:System.IdentityModel.Scope" />
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityTokenHandler">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.SecurityTokenHandler GetSecurityTokenHandler (string requestedTokenType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityTokenHandler GetSecurityTokenHandler(string requestedTokenType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetSecurityTokenHandler(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSecurityTokenHandler (requestedTokenType As String) As SecurityTokenHandler" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::SecurityTokenHandler ^ GetSecurityTokenHandler(System::String ^ requestedTokenType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandler</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestedTokenType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="requestedTokenType">Ciąg, który zawiera identyfikator URI żądanego typu tokenu.</param>
        <summary>Pobiera program obsługi tokenów zabezpieczeń odpowiednich do wystawiania tokenu zabezpieczającego określonego typu.</summary>
        <returns>A <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler" /> reprezentujący programu obsługi tokenów służący do tworzenia tokenu zabezpieczeń. Zwraca <see langword="null" /> Jeśli żądany typ tokenu nie jest obsługiwane (braku obsługi skonfigurowane dla określonego typu tokenu).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W implementacji domyślnej Jeśli `requestedTokenType` jest `null` lub pusty ciąg, wartość domyślna jest używany typ tokenu z konfiguracji. Jest to określone przez <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenType%2A> dostępne za pośrednictwem obiektu konfiguracji usługi STS <xref:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration%2A> właściwości.  
  
 Ta metoda jest wywoływana z domyślnej potok wydawania tokenów zaimplementowana w <xref:System.IdentityModel.SecurityTokenService.Issue%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetTokenLifetime">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Protocols.WSTrust.Lifetime GetTokenLifetime (System.IdentityModel.Protocols.WSTrust.Lifetime requestLifetime);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.Lifetime GetTokenLifetime(class System.IdentityModel.Protocols.WSTrust.Lifetime requestLifetime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetTokenLifetime(System.IdentityModel.Protocols.WSTrust.Lifetime)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTokenLifetime (requestLifetime As Lifetime) As Lifetime" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Protocols::WSTrust::Lifetime ^ GetTokenLifetime(System::IdentityModel::Protocols::WSTrust::Lifetime ^ requestLifetime);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.Lifetime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestLifetime" Type="System.IdentityModel.Protocols.WSTrust.Lifetime" />
      </Parameters>
      <Docs>
        <param name="requestLifetime">A <see cref="T:System.IdentityModel.Protocols.WSTrust.Lifetime" /> reprezentujący żądanego okresu istnienia.</param>
        <summary>Pobiera okres istnienia wystawionego tokenu.</summary>
        <returns>A <see cref="T:System.IdentityModel.Protocols.WSTrust.Lifetime" /> reprezentujący nadanego okres istnienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana zwykle z okresu istnienia, który dostarczona RST. W implementacji domyślnej okres istnienia tokenu jest obliczane zgodnie z poniższą tabelą.  
  
|Utworzony (ruch przychodzący)|Wygasa (ruch przychodzący)|Utworzony (ruch przychodzący)|Wygasa (out)|  
|--------------------|--------------------|--------------------|---------------------|  
|`null`|`null`|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType>|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType> + <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenLifetime%2A?displayProperty=nameWithType>|  
|C|`null`|C|C + <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenLifetime%2A?displayProperty=nameWithType>|  
|`null`|E|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType>|E|  
|C|E|C|E|  
  
 Ta metoda jest wywoływana z domyślnej potok wydawania tokenów zaimplementowana w <xref:System.IdentityModel.SecurityTokenService.Issue%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="Issue">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Issue (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Issue(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Issue (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Issue(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> reprezentujący tożsamość żądającego tokenu.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący żądania tokenu zabezpieczeń. W tym żądaniu wiadomości, a także innych klienta powiązane informacje, takie jak kontekst autoryzacji.</param>
        <summary>Wystawia token zabezpieczający.</summary>
        <returns>A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> zawierający token zabezpieczeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda implementuje powiązania problem zdefiniowane w specyfikacji WS-Trust. Domyślna implementacja <xref:System.IdentityModel.SecurityTokenService.Issue%2A> metoda przetwarza przychodzące żądanie (RST) przez potok wydawania tokenów (wystawiania oświadczeń) i zwraca albo odpowiedzi (odpowiedź RSTR), który zawiera token zabezpieczający z odpowiednich oświadczeń do uwierzytelniania Obiekt żądający z planu odzyskiwania lub odpowiednich wyjątków. Potok wydawania tokenów w implementacji domyślnej składa się z następujących metod wywołania (z <xref:System.IdentityModel.SecurityTokenService> klasy).  
  
1.  <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> Metodę weryfikacji żądania (RST).  
  
2.  <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> Metodę, aby pobrać <xref:System.IdentityModel.Scope> obiekt, który zawiera informacje dotyczące jednostki uzależnionej (RP) skojarzone z żądaniem. Należy przesłonić tę metodę. Jeśli <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> zwraca `null`, <xref:System.InvalidOperationException> jest generowany.  
  
3.  <xref:System.IdentityModel.SecurityTokenService.CreateSecurityTokenDescriptor%2A> Metodę, aby zwrócić token deskryptor zabezpieczeń oparte na RST i <xref:System.IdentityModel.Scope> obiekt jest zwracany w poprzednim kroku. Deskryptor tokenu zabezpieczeń (<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor>) zawiera informacje o żądaniu w postaci mogą być używane przez program obsługi tokena. <xref:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor%2A?displayProperty=nameWithType> Właściwość jest ustawiona na deskryptora zwrócony przez wywołanie. Jeśli `null` jest zwracany lub, jeśli <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.SigningCredentials%2A> właściwość deskryptora jest `null`, <xref:System.InvalidOperationException> jest generowany. Wyjątek jest również element zgłaszany, gdy <xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A?displayProperty=nameWithType> właściwość jest `true` , ale <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.EncryptingCredentials%2A> właściwość deskryptora zwracane jest `null`.  
  
4.  <xref:System.IdentityModel.SecurityTokenService.GetSecurityTokenHandler%2A> Metoda uzyskanie odpowiedniego programu obsługi tokenów oparta na rodzaj żądany token. Jeśli `null` jest zwracany, <xref:System.NotImplementedException> jest generowany.  
  
5.  <xref:System.IdentityModel.SecurityTokenService.GetIssuerName%2A> Metody można uzyskać nazwy wystawcy tokenu. Zgłasza wyjątek <xref:System.InvalidOperationException> Jeśli nazwa jest `null` lub pusty; w przeciwnym razie ustawia <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.TokenIssuerName%2A> właściwość deskryptora.  
  
6.  <xref:System.IdentityModel.SecurityTokenService.GetTokenLifetime%2A> Metodę, aby pobrać okres istnienia tokenu i zestawy <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Lifetime%2A> właściwość deskryptora.  
  
7.  <xref:System.IdentityModel.SecurityTokenService.GetProofToken%2A> Metodę, aby uzyskać token potwierdzenia do dołączenia wystawionego tokenu i zestawy <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Proof%2A> właściwość deskryptora.  
  
8.  <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> Metodę, aby pobrać oświadczenia do dołączenia wystawionego tokenu i zestawy <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Subject%2A> właściwość deskryptora. Należy przesłonić tę metodę.  
  
9. <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A> Metody do tworzenia odpowiedzi (odpowiedź RSTR), który zawiera wystawionego tokenu.  
  
 Można zastąpić <xref:System.IdentityModel.SecurityTokenService.Issue%2A> metody do zaimplementowania potok wydawania tokenów niestandardowych; jednak nie jest to zazwyczaj konieczne w przypadku środowisk projektowania i testowania, które najbardziej niestandardowych implementacji <xref:System.IdentityModel.SecurityTokenService> klasy są przeznaczone. W wielu przypadkach można zastąpić <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> i <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> metod i opcjonalnie Przesłoń <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> metodę w celu zapewnienia obsługiwanych STS dla danego środowiska. Są niezbędne dodatkowe dostosowania można często udostępniają go przez zastąpienie metody, które implementuje każdego etapu domyślne potok wydawania tokenów wymienionych powyżej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Principal">
      <MemberSignature Language="C#" Value="public System.Security.Claims.ClaimsPrincipal Principal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Claims.ClaimsPrincipal Principal" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Principal" />
      <MemberSignature Language="VB.NET" Value="Public Property Principal As ClaimsPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Claims::ClaimsPrincipal ^ Principal { System::Security::Claims::ClaimsPrincipal ^ get(); void set(System::Security::Claims::ClaimsPrincipal ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia podmiot zabezpieczeń skojarzony z bieżącym wystąpieniem.</summary>
        <value>A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> reprezentujący bieżący podmiot zabezpieczeń.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Renew">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Renew (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Renew(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Renew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Renew (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Renew(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> reprezentujący tożsamość żądającego tokenu.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący żądania tokenu zabezpieczeń. W tym żądaniu wiadomości, a także innych klienta powiązane informacje, takie jak kontekst autoryzacji.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, przetwarza żądanie odnowienia WS-Trust.</summary>
        <returns>A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> reprezentujący odpowiedź RSTR, aby powrócić do obiektu wywołującego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Protocols.WSTrust.RequestSecurityToken Request { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken Request" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Request" />
      <MemberSignature Language="VB.NET" Value="Public Property Request As RequestSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ Request { System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ get(); void set(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia żądanie tokenu zabezpieczeń (RST) skojarzone z bieżącym wystąpieniem.</summary>
        <value>A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> zawierający żądania.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Scope">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Scope Scope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Scope Scope" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Scope" />
      <MemberSignature Language="VB.NET" Value="Public Property Scope As Scope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Scope ^ Scope { System::IdentityModel::Scope ^ get(); void set(System::IdentityModel::Scope ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zakres skojarzony z bieżącym wystąpieniem.</summary>
        <value>A <see cref="T:System.IdentityModel.Scope" /> reprezentujący konfigurację dla żądania wydawania tokenów.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SecurityTokenDescriptor">
      <MemberSignature Language="C#" Value="protected System.IdentityModel.Tokens.SecurityTokenDescriptor SecurityTokenDescriptor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenDescriptor SecurityTokenDescriptor" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />
      <MemberSignature Language="VB.NET" Value="Protected Property SecurityTokenDescriptor As SecurityTokenDescriptor" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::IdentityModel::Tokens::SecurityTokenDescriptor ^ SecurityTokenDescriptor { System::IdentityModel::Tokens::SecurityTokenDescriptor ^ get(); void set(System::IdentityModel::Tokens::SecurityTokenDescriptor ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenDescriptor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.IdentityModel.Tokens.SecurityTokenDescriptor" /> skojarzone z bieżącym wystąpieniem.</summary>
        <value>Token deskryptora zabezpieczeń skojarzony z bieżącym wystąpieniem.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Próba ustawioną właściwość <see langword="null" /> występuje.</exception>
      </Docs>
    </Member>
    <Member MemberName="SecurityTokenServiceConfiguration">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Configuration.SecurityTokenServiceConfiguration SecurityTokenServiceConfiguration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Configuration.SecurityTokenServiceConfiguration SecurityTokenServiceConfiguration" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SecurityTokenServiceConfiguration As SecurityTokenServiceConfiguration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ SecurityTokenServiceConfiguration { System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Configuration.SecurityTokenServiceConfiguration</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera właściciela wystąpienia konfiguracji.</summary>
        <value>A <see cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" /> zawierający konfiguracji dla bieżącego wystąpienia.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Validate (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Validate(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Validate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Validate (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Validate(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> reprezentujący tożsamość żądającego tokenu.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący żądania tokenu zabezpieczeń. W tym żądaniu wiadomości, a także innych klienta powiązane informacje, takie jak kontekst autoryzacji.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, przetwarza żądanie zweryfikowania WS-Trust.</summary>
        <returns>A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> reprezentujący odpowiedź RSTR, aby powrócić do obiektu wywołującego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zgłasza <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateRequest">
      <MemberSignature Language="C#" Value="protected virtual void ValidateRequest (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ValidateRequest(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.ValidateRequest(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ValidateRequest (request As RequestSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ValidateRequest(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> reprezentujący żądanie.</param>
        <summary>Weryfikuje żądanie tokenu zabezpieczeń (RST) hermetyzowany przez to wystąpienie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> Metoda jest wywoływana z potoku wystawiania tokenu ( <xref:System.IdentityModel.SecurityTokenService.Issue%2A> metody) do sprawdzania poprawności przychodzących RST. RST jest weryfikowana pod kątem wymagań usługi STS (zasady) i jest zgłaszany wyjątek odpowiednie, jeśli nie jest prawidłowy.  
  
 Domyślna implementacja <xref:System.IdentityModel.SecurityTokenService> klasa obsługuje tylko wzorzec odpowiedź RSTR RST oraz tylko powiązanie problem ze specyfikacją WS-Trust ( <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.RequestType%2A> musi mieć ustawioną właściwość żądania <xref:System.IdentityModel.Protocols.WSTrust.RequestTypes.Issue?displayProperty=nameWithType>). Domyślna implementacja tej metody wymusza tych wymagań (i innych wymienionych w sekcji wyjątki). Można przesłonić tę metodę, jeśli muszą wymuszać weryfikacji różne wymagania dotyczące z STS niestandardowych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IdentityModel.Protocols.WSTrust.InvalidRequestException">
          <paramref name="request" /> jest <see langword="null" />.  
  
 —lub—  
  
 <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.RequestType" /> Nie ustawiono właściwości żądania <see cref="F:System.IdentityModel.Protocols.WSTrust.RequestTypes.Issue" />.  
  
 —lub—  
  
 <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.KeyType" /> Właściwość żądania nie jest <see langword="null" /> lub jednego z stałe zdefiniowane w <see cref="T:System.IdentityModel.Protocols.WSTrust.KeyTypes" /> klasy.  
  
 —lub—  
  
 <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.KeyType" /> Żądań <see cref="F:System.IdentityModel.Protocols.WSTrust.KeyTypes.Bearer" /> i <see langword="KeySize" /> element jest obecny, ale jego wartość nie jest równa zero.</exception>
        <exception cref="T:System.IdentityModel.UnsupportedTokenTypeBadRequestException">Usługa tokenu Zabezpieczającego nie obsługuje żądania tokenu typu (na podstawie wartości z <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.TokenType" /> właściwości żądania).</exception>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
  </Members>
</Type>
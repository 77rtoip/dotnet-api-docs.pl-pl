<Type Name="XmlStreamStore" FullName="System.Windows.Annotations.Storage.XmlStreamStore">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="72573dc58ce518e155bf22754475684a7e107efd" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39768492" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class XmlStreamStore : System.Windows.Annotations.Storage.AnnotationStore" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed XmlStreamStore extends System.Windows.Annotations.Storage.AnnotationStore" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Annotations.Storage.XmlStreamStore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class XmlStreamStore&#xA;Inherits AnnotationStore" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlStreamStore sealed : System::Windows::Annotations::Storage::AnnotationStore" />
  <TypeSignature Language="F#" Value="type XmlStreamStore = class&#xA;    inherit AnnotationStore" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Annotations.Storage.AnnotationStore</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje magazyn danych XML do zapisywania i odczytywania adnotacje użytkownika.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Annotations.Storage.XmlStreamStore" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlStreamStore (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Annotations.Storage.XmlStreamStore.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlStreamStore(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.Windows.Annotations.Storage.XmlStreamStore : System.IO.Stream -&gt; System.Windows.Annotations.Storage.XmlStreamStore" Usage="new System.Windows.Annotations.Storage.XmlStreamStore stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień we/wy do odczytywania i zapisywania adnotacje użytkownika.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Annotations.Storage.XmlStreamStore" /> klasy przy użyciu określonej operacji We/Wy <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `stream` musi być w prawidłowym kodem XML formatowania i są zgodne z [!INCLUDE[TLA#tla_caf](~/includes/tlasharptla-caf-md.md)] schematu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlStreamStore (System.IO.Stream stream, System.Collections.Generic.IDictionary&lt;Uri,System.Collections.Generic.IList&lt;Uri&gt;&gt; knownNamespaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Collections.Generic.IDictionary`2&lt;class System.Uri, class System.Collections.Generic.IList`1&lt;class System.Uri&gt;&gt; knownNamespaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Annotations.Storage.XmlStreamStore.#ctor(System.IO.Stream,System.Collections.Generic.IDictionary{System.Uri,System.Collections.Generic.IList{System.Uri}})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlStreamStore(System::IO::Stream ^ stream, System::Collections::Generic::IDictionary&lt;Uri ^, System::Collections::Generic::IList&lt;Uri ^&gt; ^&gt; ^ knownNamespaces);" />
      <MemberSignature Language="F#" Value="new System.Windows.Annotations.Storage.XmlStreamStore : System.IO.Stream * System.Collections.Generic.IDictionary&lt;Uri, System.Collections.Generic.IList&lt;Uri&gt;&gt; -&gt; System.Windows.Annotations.Storage.XmlStreamStore" Usage="new System.Windows.Annotations.Storage.XmlStreamStore (stream, knownNamespaces)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="knownNamespaces" Type="System.Collections.Generic.IDictionary&lt;System.Uri,System.Collections.Generic.IList&lt;System.Uri&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień we/wy do odczytywania i zapisywania adnotacje użytkownika.</param>
        <param name="knownNamespaces">Słownik listę znanych zgodnych przestrzeni nazw.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Annotations.Storage.XmlStreamStore" /> klasy przy użyciu określonej operacji We/Wy <see cref="T:System.IO.Stream" /> i słownika znanych zgodnych przestrzeni nazw.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To <xref:System.Windows.Annotations.Storage.XmlStreamStore.%23ctor%2A> Konstruktor umożliwia rejestrację specyficzne dla aplikacji znanych obszarów nazw.  
  
 `knownNamespace` Słownika definiuje przestrzenie nazw aplikacji, które są używane podczas niestandardowego zawartość jest przechowywana jako część adnotacji.  Klucz słownika jest podstawowej przestrzeni nazw, wiadomo, że program aplikacji.  Przestrzeń nazw klucz jest skojarzony z listy wartości starsze przestrzenie nazw, które są zgodne z przestrzenią nazw "key".  Po załadowaniu wszystkich przestrzeni nazw adnotacje z tej listy zostaną zastąpione przestrzeni nazw "key".  
  
 `stream` musi być w prawidłowym kodem XML formatowania i są zgodne z [schemat adnotacji](~/docs/framework/wpf/advanced/annotations-schema.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="stream" /> zawiera nieprawidłowy kod XML.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="knownNamespaces" /> Słownik zawiera zduplikowaną przestrzeń nazw.  - lub - <paramref name="knownNamespaces" /> słownik zawiera element, który ma <see langword="null" /> klucza.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAnnotation">
      <MemberSignature Language="C#" Value="public override void AddAnnotation (System.Windows.Annotations.Annotation newAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void AddAnnotation(class System.Windows.Annotations.Annotation newAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Annotations.Storage.XmlStreamStore.AddAnnotation(System.Windows.Annotations.Annotation)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub AddAnnotation (newAnnotation As Annotation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void AddAnnotation(System::Windows::Annotations::Annotation ^ newAnnotation);" />
      <MemberSignature Language="F#" Value="override this.AddAnnotation : System.Windows.Annotations.Annotation -&gt; unit" Usage="xmlStreamStore.AddAnnotation newAnnotation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newAnnotation" Type="System.Windows.Annotations.Annotation" />
      </Parameters>
      <Docs>
        <param name="newAnnotation">Adnotacja do dodania do magazynu.</param>
        <summary>Dodaje nowy <see cref="T:System.Windows.Annotations.Annotation" /> do magazynu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.Annotations.Storage.XmlStreamStore.AddAnnotation%2A> jest wywoływana, <xref:System.Windows.Annotations.Annotation.Id%2A> z <xref:System.Windows.Annotations.Annotation> jest sprawdzenie, czy <xref:System.Windows.Annotations.Annotation> został już dodany do magazynu.  Jeśli <xref:System.Windows.Annotations.Annotation> już został dodany i znajduje się w magazynie <xref:System.ArgumentException> , zostanie zgłoszony błąd.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newAnnotation" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Windows.Annotations.Annotation" /> o takiej samej <see cref="P:System.Windows.Annotations.Annotation.Id" /> już znajduje się w magazynie.</exception>
        <exception cref="T:System.InvalidOperationException">Operacje We/Wy <see cref="T:System.IO.Stream" /> nie została ustawiona w sklepie.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="Overload:System.Windows.Annotations.Storage.AnnotationStore.Dispose" /> Wywołano w sklepie.</exception>
        <altmember cref="M:System.Windows.Annotations.Storage.XmlStreamStore.DeleteAnnotation(System.Guid)" />
      </Docs>
    </Member>
    <Member MemberName="AutoFlush">
      <MemberSignature Language="C#" Value="public override bool AutoFlush { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoFlush" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Annotations.Storage.XmlStreamStore.AutoFlush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoFlush { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoFlush : bool with get, set" Usage="System.Windows.Annotations.Storage.XmlStreamStore.AutoFlush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy dane w adnotacji buforów ma być natychmiast zapisywane do magazynu danych fizycznych.</summary>
        <value>
          <see langword="true" /> Jeżeli dane w adnotacji buforów mają być zapisywane bezpośrednio w magazynie danych fizycznych dla każdej operacji; w przeciwnym razie <see langword="false" /> Jeśli dane w buforów adnotacji są zapisywane, gdy aplikacja jawnie wywołuje <see cref="M:System.Windows.Annotations.Storage.XmlStreamStore.Flush" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Annotations.Storage.XmlStreamStore.Flush" />
      </Docs>
    </Member>
    <Member MemberName="DeleteAnnotation">
      <MemberSignature Language="C#" Value="public override System.Windows.Annotations.Annotation DeleteAnnotation (Guid annotationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.Annotations.Annotation DeleteAnnotation(valuetype System.Guid annotationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Annotations.Storage.XmlStreamStore.DeleteAnnotation(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DeleteAnnotation (annotationId As Guid) As Annotation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::Annotations::Annotation ^ DeleteAnnotation(Guid annotationId);" />
      <MemberSignature Language="F#" Value="override this.DeleteAnnotation : Guid -&gt; System.Windows.Annotations.Annotation" Usage="xmlStreamStore.DeleteAnnotation annotationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Annotations.Annotation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotationId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="annotationId">Unikatowy identyfikator globalny (GUID) <see cref="P:System.Windows.Annotations.Annotation.Id" /> właściwość adnotacji do usunięcia.</param>
        <summary>Usuwa adnotacji z określonym <see cref="P:System.Windows.Annotations.Annotation.Id" /> ze sklepu.</summary>
        <returns>Adnotacja, który został usunięty; w przeciwnym razie <see langword="null" /> Jeśli adnotacji z określonym <paramref name="annotationId" /> nie został znaleziony w magazynie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Windows.Annotations.Storage.XmlStreamStore.DeleteAnnotation%2A> i <xref:System.Windows.Annotations.Storage.XmlStreamStore.Flush%2A> metody.  
  
 [!code-csharp[DocumentSerialize#DocSerDelete](~/samples/snippets/csharp/VS_Snippets_Wpf/DocumentSerialize/CSharp/ThumbViewer.cs#docserdelete)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="Overload:System.Windows.Annotations.Storage.AnnotationStore.Dispose" /> Wywołano w sklepie.</exception>
        <exception cref="T:System.InvalidOperationException">Operacje We/Wy <see cref="T:System.IO.Stream" /> nie została ustawiona w sklepie.</exception>
        <altmember cref="M:System.Windows.Annotations.Storage.XmlStreamStore.AddAnnotation(System.Windows.Annotations.Annotation)" />
        <altmember cref="M:System.Windows.Annotations.Storage.XmlStreamStore.GetAnnotation(System.Guid)" />
        <altmember cref="Overload:System.Windows.Annotations.Storage.XmlStreamStore.GetAnnotations" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Annotations.Storage.XmlStreamStore.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="xmlStreamStore.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Annotations.Storage.XmlStreamStore.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="xmlStreamStore.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wymusza żadnych danych adnotacji, przechowywane w bufory wewnętrzne są zapisywane w odpowiednie urządzenia magazynujące.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Windows.Annotations.Storage.XmlStreamStore.Flush%2A> metoda po zamknięciu aplikacji <xref:System.Windows.Annotations.AnnotationService>.  
  
 [!code-csharp[DocViewerAnnotationsXps#StopAnnotations](~/samples/snippets/csharp/VS_Snippets_Wpf/DocViewerAnnotationsXps/CSharp/AnnotationsHelperXps.cs#stopannotations)]
 [!code-vb[DocViewerAnnotationsXps#StopAnnotations](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DocViewerAnnotationsXps/visualbasic/annotationshelperxps.vb#stopannotations)]  
  
 W poniższym przykładzie pokazano użycie <xref:System.Windows.Annotations.Storage.XmlStreamStore.DeleteAnnotation%2A> i <xref:System.Windows.Annotations.Storage.XmlStreamStore.Flush%2A> metody.  
  
 [!code-csharp[DocumentSerialize#DocSerDelete](~/samples/snippets/csharp/VS_Snippets_Wpf/DocumentSerialize/CSharp/ThumbViewer.cs#docserdelete)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="Overload:System.Windows.Annotations.Storage.AnnotationStore.Dispose" /> Wywołano w sklepie.</exception>
        <exception cref="T:System.InvalidOperationException">Operacje We/Wy <see cref="T:System.IO.Stream" /> nie została ustawiona w sklepie.</exception>
        <exception cref="T:System.UnauthorizedAccessException">We/Wy magazynu <see cref="T:System.IO.Stream" /> jest tylko do odczytu i nie można uzyskać dostępu do danych wyjściowych.</exception>
        <altmember cref="P:System.Windows.Annotations.Storage.XmlStreamStore.AutoFlush" />
      </Docs>
    </Member>
    <Member MemberName="GetAnnotation">
      <MemberSignature Language="C#" Value="public override System.Windows.Annotations.Annotation GetAnnotation (Guid annotationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.Annotations.Annotation GetAnnotation(valuetype System.Guid annotationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Annotations.Storage.XmlStreamStore.GetAnnotation(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetAnnotation (annotationId As Guid) As Annotation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::Annotations::Annotation ^ GetAnnotation(Guid annotationId);" />
      <MemberSignature Language="F#" Value="override this.GetAnnotation : Guid -&gt; System.Windows.Annotations.Annotation" Usage="xmlStreamStore.GetAnnotation annotationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Annotations.Annotation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotationId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="annotationId">Identyfikator GUID <see cref="P:System.Windows.Annotations.Annotation.Id" /> właściwość adnotacji, które mają zostać zwrócone.</param>
        <summary>Zwraca wartość adnotacji z określonym <see cref="P:System.Windows.Annotations.Annotation.Id" /> ze sklepu.</summary>
        <returns>Adnotacja o danym <paramref name="annotationId" />; w przeciwnym razie <see langword="null" /> Jeśli adnotacji z określonym <paramref name="annotationId" /> nie został znaleziony w magazynie.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="Overload:System.Windows.Annotations.Storage.AnnotationStore.Dispose" /> Wywołano w sklepie.</exception>
        <altmember cref="Overload:System.Windows.Annotations.Storage.XmlStreamStore.GetAnnotations" />
        <altmember cref="M:System.Windows.Annotations.Storage.XmlStreamStore.DeleteAnnotation(System.Guid)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAnnotations">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca listę wszystkich adnotacji w magazynie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Windows.Annotations.Storage.XmlStreamStore.GetAnnotations%2A> metodę, aby określić, czy są wszystkie adnotacje zawarty w magazynie.  
  
 [!code-csharp[DocumentSerialize#DocSerCloseFile](~/samples/snippets/csharp/VS_Snippets_Wpf/DocumentSerialize/CSharp/ThumbViewer.cs#docserclosefile)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Annotations.Storage.XmlStreamStore.GetAnnotation(System.Guid)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAnnotations">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IList&lt;System.Windows.Annotations.Annotation&gt; GetAnnotations ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IList`1&lt;class System.Windows.Annotations.Annotation&gt; GetAnnotations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Annotations.Storage.XmlStreamStore.GetAnnotations" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetAnnotations () As IList(Of Annotation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Collections::Generic::IList&lt;System::Windows::Annotations::Annotation ^&gt; ^ GetAnnotations();" />
      <MemberSignature Language="F#" Value="override this.GetAnnotations : unit -&gt; System.Collections.Generic.IList&lt;System.Windows.Annotations.Annotation&gt;" Usage="xmlStreamStore.GetAnnotations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Windows.Annotations.Annotation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca listę wszystkich adnotacji w magazynie.</summary>
        <returns>Lista wszystkich adnotacji, które są obecnie dostępne w magazynie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Annotations.Storage.XmlStreamStore.GetAnnotations%2A> Nigdy nie zwróci metoda `null`; jednak lista może być pusta, jeśli magazyn nie zawiera żadnych adnotacji.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Windows.Annotations.Storage.XmlStreamStore.GetAnnotations%2A> metodę, aby określić, czy są wszystkie adnotacje w magazynie.  
  
 [!code-csharp[DocumentSerialize#DocSerCloseFile](~/samples/snippets/csharp/VS_Snippets_Wpf/DocumentSerialize/CSharp/ThumbViewer.cs#docserclosefile)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="Overload:System.Windows.Annotations.Storage.AnnotationStore.Dispose" /> Wywołano w sklepie.</exception>
        <altmember cref="M:System.Windows.Annotations.Storage.XmlStreamStore.GetAnnotation(System.Guid)" />
        <altmember cref="M:System.Windows.Annotations.Storage.XmlStreamStore.GetAnnotations(System.Windows.Annotations.ContentLocator)" />
      </Docs>
    </Member>
    <Member MemberName="GetAnnotations">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IList&lt;System.Windows.Annotations.Annotation&gt; GetAnnotations (System.Windows.Annotations.ContentLocator anchorLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IList`1&lt;class System.Windows.Annotations.Annotation&gt; GetAnnotations(class System.Windows.Annotations.ContentLocator anchorLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Annotations.Storage.XmlStreamStore.GetAnnotations(System.Windows.Annotations.ContentLocator)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetAnnotations (anchorLocator As ContentLocator) As IList(Of Annotation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Collections::Generic::IList&lt;System::Windows::Annotations::Annotation ^&gt; ^ GetAnnotations(System::Windows::Annotations::ContentLocator ^ anchorLocator);" />
      <MemberSignature Language="F#" Value="override this.GetAnnotations : System.Windows.Annotations.ContentLocator -&gt; System.Collections.Generic.IList&lt;System.Windows.Annotations.Annotation&gt;" Usage="xmlStreamStore.GetAnnotations anchorLocator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Windows.Annotations.Annotation&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anchorLocator" Type="System.Windows.Annotations.ContentLocator" />
      </Parameters>
      <Docs>
        <param name="anchorLocator">Początkowy <see cref="T:System.Windows.Annotations.ContentLocatorPart" /> sekwencji do zwrócenia dopasowywania adnotacji dla.</param>
        <summary>Zwraca listę adnotacji, które mają <see cref="P:System.Windows.Annotations.Annotation.Anchors" /> z lokalizatory, które zaczynają się od odpowiadającego <see cref="T:System.Windows.Annotations.ContentLocatorPart" /> sekwencji.</summary>
        <returns>Lista adnotacji, które mają <see cref="P:System.Windows.Annotations.Annotation.Anchors" /> z lokalizatory, które uruchamiają i dopasować danego <paramref name="anchorLocator" />; w przeciwnym razie <see langword="null" /> Jeśli brak pasującego adnotacji nie znaleziono.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To <xref:System.Windows.Annotations.Storage.XmlStreamStore.GetAnnotations%2A> używa wewnętrznie metody <xref:System.Windows.Annotations.ContentLocator.StartsWith%2A> metody <xref:System.Windows.Annotations.ContentLocator> klasy można wyszukiwać i dopasowania dla adnotacji do zwrócenia.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Windows.Annotations.Storage.XmlStreamStore.GetAnnotations%2A> metodę, aby określić, czy są wszystkie adnotacje w magazynie.  
  
 [!code-csharp[DocumentSerialize#DocSerCloseFile](~/samples/snippets/csharp/VS_Snippets_Wpf/DocumentSerialize/CSharp/ThumbViewer.cs#docserclosefile)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Annotations.Storage.XmlStreamStore.GetAnnotation(System.Guid)" />
        <altmember cref="M:System.Windows.Annotations.ContentLocator.StartsWith(System.Windows.Annotations.ContentLocator)" />
      </Docs>
    </Member>
    <Member MemberName="GetWellKnownCompatibleNamespaces">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IList&lt;Uri&gt; GetWellKnownCompatibleNamespaces (Uri name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IList`1&lt;class System.Uri&gt; GetWellKnownCompatibleNamespaces(class System.Uri name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Annotations.Storage.XmlStreamStore.GetWellKnownCompatibleNamespaces(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetWellKnownCompatibleNamespaces (name As Uri) As IList(Of Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IList&lt;Uri ^&gt; ^ GetWellKnownCompatibleNamespaces(Uri ^ name);" />
      <MemberSignature Language="F#" Value="static member GetWellKnownCompatibleNamespaces : Uri -&gt; System.Collections.Generic.IList&lt;Uri&gt;" Usage="System.Windows.Annotations.Storage.XmlStreamStore.GetWellKnownCompatibleNamespaces name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Uri&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="name">Początkowy identyfikator URI sekwencja zwrócić listę przestrzeni nazw dla.</param>
        <summary>Zwraca listę przestrzeni nazw, które są zgodne jako danych wejściowych przestrzeni nazw.</summary>
        <returns>Lista zgodnych przestrzenie nazw, które pasują <paramref name="name" />; w przeciwnym razie <see langword="null" /> czy nie znaleziono zgodnych przestrzeni nazw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `name` Parametr działa tylko w przypadku wstępnie zdefiniowane [!INCLUDE[TLA#tla_caf](~/includes/tlasharptla-caf-md.md)] przestrzeni nazw.  Dla innych przestrzeni nazw w `name` parametru <xref:System.Windows.Annotations.Storage.XmlStreamStore.GetWellKnownCompatibleNamespaces%2A> zwróci `null`, nawet tych obszarów nazw zarejestrowany przez `knownNamespaces` parametru <xref:System.Windows.Annotations.Storage.XmlStreamStore.%23ctor%2A> konstruktora.  
  
 Przestrzenie nazw wstępnie zdefiniowane przez [!INCLUDE[TLA2#tla_caf](~/includes/tla2sharptla-caf-md.md)] obejmują następujące elementy:  
  
-   http://schemas.microsoft.com/windows/annotations/2003/11/core  
  
-   http://schemas.microsoft.com/windows/annotations/2003/11/base  
  
-   http://schemas.microsoft.com/winfx/2006/xaml/presentation  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Annotations.Storage.XmlStreamStore.IgnoredNamespaces" />
        <altmember cref="P:System.Windows.Annotations.Storage.XmlStreamStore.WellKnownNamespaces" />
      </Docs>
    </Member>
    <Member MemberName="IgnoredNamespaces">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Uri&gt; IgnoredNamespaces { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Uri&gt; IgnoredNamespaces" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Annotations.Storage.XmlStreamStore.IgnoredNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IgnoredNamespaces As IList(Of Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;Uri ^&gt; ^ IgnoredNamespaces { System::Collections::Generic::IList&lt;Uri ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IgnoredNamespaces : System.Collections.Generic.IList&lt;Uri&gt;" Usage="System.Windows.Annotations.Storage.XmlStreamStore.IgnoredNamespaces" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Uri&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera listę przestrzeni nazw, które zostały zignorowane, gdy strumień XML został załadowany.</summary>
        <value>Lista przestrzeni nazw, które zostały zignorowane, gdy strumień XML został załadowany.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Annotations.Storage.XmlStreamStore.IgnoredNamespaces%2A> Właściwość nigdy nie będzie zwracać `null`, jednak zwrócona lista może być pusta, jeśli nie przestrzeni nazw są ignorowane.  
  
 <xref:System.Windows.Annotations.Storage.XmlStreamStore.IgnoredNamespaces%2A> pomaga w zgodność znaczników XML, gdy program czyta adnotacji zawartości tworzone przez różne wersje programu [!INCLUDE[TLA#tla_caf](~/includes/tlasharptla-caf-md.md)].  Gdy starszych aplikacji otrzymuje zawartości adnotacji utworzonej przy użyciu nowszej wersji [!INCLUDE[TLA2#tla_caf](~/includes/tla2sharptla-caf-md.md)], <xref:System.Windows.Annotations.Storage.XmlStreamStore.IgnoredNamespaces%2A> zwraca listę przestrzeni nazw XML dla elementów i atrybutów nie jest znany do starszej ramy.  Nieznany elementów XML oraz atrybuty skojarzone z nowszych przestrzenie nazw są ignorowane w przypadku zawartości adnotacji jest odczytywana i przeprowadzona przez starszych aplikacji.  Aby uzyskać więcej informacji, zobacz *specyfikacji zgodności znaczników XML* dostępne pod adresem [ http://go.microsoft.com/fwlink/?LinkId=73824 ](http://go.microsoft.com/fwlink/?LinkId=73824).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Annotations.Storage.XmlStreamStore.WellKnownNamespaces" />
        <altmember cref="M:System.Windows.Annotations.Storage.XmlStreamStore.GetWellKnownCompatibleNamespaces(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="OnStoreContentChanged">
      <MemberSignature Language="C#" Value="protected override void OnStoreContentChanged (System.Windows.Annotations.Storage.StoreContentChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnStoreContentChanged(class System.Windows.Annotations.Storage.StoreContentChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Annotations.Storage.XmlStreamStore.OnStoreContentChanged(System.Windows.Annotations.Storage.StoreContentChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnStoreContentChanged (e As StoreContentChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnStoreContentChanged(System::Windows::Annotations::Storage::StoreContentChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnStoreContentChanged : System.Windows.Annotations.Storage.StoreContentChangedEventArgs -&gt; unit" Usage="xmlStreamStore.OnStoreContentChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Annotations.Storage.StoreContentChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WellKnownNamespaces">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IList&lt;Uri&gt; WellKnownNamespaces { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.Generic.IList`1&lt;class System.Uri&gt; WellKnownNamespaces" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Annotations.Storage.XmlStreamStore.WellKnownNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property WellKnownNamespaces As IList(Of Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::Generic::IList&lt;Uri ^&gt; ^ WellKnownNamespaces { System::Collections::Generic::IList&lt;Uri ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WellKnownNamespaces : System.Collections.Generic.IList&lt;Uri&gt;" Usage="System.Windows.Annotations.Storage.XmlStreamStore.WellKnownNamespaces" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Uri&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera listę wszystkich przestrzeni nazw, które są wstępnie zdefiniowane przez [!INCLUDE[TLA2#tla_caf](~/includes/tla2sharptla-caf-md.md)].</summary>
        <value>Lista przestrzeni nazw, które są wstępnie zdefiniowane przez [!INCLUDE[TLA#tla_caf](~/includes/tlasharptla-caf-md.md)].</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przestrzenie nazw wstępnie zdefiniowane przez [!INCLUDE[TLA2#tla_caf](~/includes/tla2sharptla-caf-md.md)] obejmują następujące elementy:  
  
-   http://schemas.microsoft.com/windows/annotations/2003/11/core  
  
-   http://schemas.microsoft.com/windows/annotations/2003/11/base  
  
-   http://schemas.microsoft.com/winfx/2006/xaml/presentation  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Annotations.Storage.XmlStreamStore.IgnoredNamespaces" />
        <altmember cref="M:System.Windows.Annotations.Storage.XmlStreamStore.GetWellKnownCompatibleNamespaces(System.Uri)" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="PagedDataSource" FullName="System.Web.UI.WebControls.PagedDataSource">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7ba7288f24163824820db7818f70e798b28a24f5" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30691388" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class PagedDataSource : System.Collections.ICollection, System.ComponentModel.ITypedList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit PagedDataSource extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.ComponentModel.ITypedList" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.PagedDataSource" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class PagedDataSource&#xA;Implements ICollection, ITypedList" />
  <TypeSignature Language="C++ CLI" Value="public ref class PagedDataSource sealed : System::Collections::ICollection, System::ComponentModel::ITypedList" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ITypedList</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Hermetyzuje powiązane stronicowania właściwości kontrolki powiązania danych (takich jak <see cref="T:System.Web.UI.WebControls.DataGrid" />, <see cref="T:System.Web.UI.WebControls.GridView" />, <see cref="T:System.Web.UI.WebControls.DetailsView" />, i <see cref="T:System.Web.UI.WebControls.FormView" />) umożliwiające wykonywanie stronicowania. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.PagedDataSource> Klasa hermetyzuje właściwości, które umożliwia kontroli źródła danych, takich jak <xref:System.Web.UI.WebControls.DataGrid>, <xref:System.Web.UI.WebControls.GridView>, <xref:System.Web.UI.WebControls.DetailsView>, i <xref:System.Web.UI.WebControls.FormView>, aby wykonać stronicowania. Ta klasa jest używana przez deweloperów sterowania podczas dostarczania obsługę stronicowania niestandardowego formantu powiązanego z danymi.  
  
 Ta klasa używa najlepsza metoda wyliczyć danych należących do bieżącej strony. Jeśli dostęp indeksowany obsługuje źródła danych (takich jak <xref:System.Array?displayProperty=nameWithType> i <xref:System.Collections.IList?displayProperty=nameWithType>), ta klasa korzysta z niego. W przeciwnym razie używa utworzone przez moduł wyliczający <xref:System.Collections.IEnumerable.GetEnumerator%2A> metody.  
  
 Aby uzyskać listę początkowe wartości właściwości dla wystąpienia <xref:System.Web.UI.WebControls.PagedDataSource>, zobacz <xref:System.Web.UI.WebControls.PagedDataSource.%23ctor%2A> konstruktora.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.WebControls.DataGrid" />
    <altmember cref="T:System.Web.UI.WebControls.DetailsView" />
    <altmember cref="T:System.Web.UI.WebControls.FormView" />
    <altmember cref="T:System.Web.UI.WebControls.GridView" />
    <altmember cref="T:System.Collections.ICollection" />
    <altmember cref="T:System.Array" />
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.Collections.IEnumerable" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PagedDataSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.PagedDataSource.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PagedDataSource();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.UI.WebControls.PagedDataSource" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor umożliwia tworzenie i zainicjować nowe wystąpienie klasy <xref:System.Web.UI.WebControls.PagedDataSource> klasy.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Web.UI.WebControls.PagedDataSource>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Web.UI.WebControls.PagedDataSource.AllowCustomPaging%2A>|`false`|  
|<xref:System.Web.UI.WebControls.PagedDataSource.AllowPaging%2A>|`false`|  
|<xref:System.Web.UI.WebControls.PagedDataSource.AllowServerPaging%2A>|`false`|  
|<xref:System.Web.UI.WebControls.PagedDataSource.CurrentPageIndex%2A>|0|  
|<xref:System.Web.UI.WebControls.PagedDataSource.PageSize%2A>|10|  
|<xref:System.Web.UI.WebControls.PagedDataSource.VirtualCount%2A>|0|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowCustomPaging">
      <MemberSignature Language="C#" Value="public bool AllowCustomPaging { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowCustomPaging" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.PagedDataSource.AllowCustomPaging" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowCustomPaging As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowCustomPaging { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy w formancie powiązane z danymi włączono stronicowania niestandardowego.</summary>
        <value>
          <see langword="true" /> Jeśli włączono stronicowania niestandardowego; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.WebControls.PagedDataSource.AllowCustomPaging%2A> Właściwość wskazująca, czy włączono stronicowania niestandardowego. Stronicowania niestandardowego jest opcjonalny typ stronicowania, w szczególności przez podany <xref:System.Web.UI.WebControls.DataGrid> formantu. Formant powiązane z danymi programu ASP.NET w wersji 2.0 (takich jak <xref:System.Web.UI.WebControls.GridView>, <xref:System.Web.UI.WebControls.DetailsView>, i <xref:System.Web.UI.WebControls.FormView>) używa stronicowania po stronie serwera i nie obsługuje stronicowania niestandardowego. Stronicowania niestandardowego i stronicowania po stronie serwera wzajemnie się wykluczają. Jeśli ustawisz <xref:System.Web.UI.WebControls.PagedDataSource.AllowCustomPaging%2A> do `true`, upewnij się, że <xref:System.Web.UI.WebControls.PagedDataSource.AllowServerPaging%2A> ma ustawioną wartość `false`.  
  
 Aby uzyskać więcej informacji na temat stronicowania niestandardowego, zobacz <xref:System.Web.UI.WebControls.DataGrid.AllowCustomPaging%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.AllowPaging" />
      </Docs>
    </Member>
    <Member MemberName="AllowPaging">
      <MemberSignature Language="C#" Value="public bool AllowPaging { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowPaging" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.PagedDataSource.AllowPaging" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowPaging As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowPaging { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy stronicowanie zostało włączone w formancie powiązane z danymi.</summary>
        <value>
          <see langword="true" /> Jeśli stronicowanie zostało włączone; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.WebControls.PagedDataSource.AllowPaging%2A> właściwości w celu określenia, czy formant powiązany z danymi ma włączono stronicowania. Formanty powiązane z danymi programu ASP.NET w wersji 2.0 (takich jak <xref:System.Web.UI.WebControls.GridView>, <xref:System.Web.UI.WebControls.DetailsView>, i <xref:System.Web.UI.WebControls.FormView>) również użyć stronicowania po stronie serwera, aby zapewnić automatyczne funkcje stronicowania. Aby uzyskać więcej informacji dotyczących stronicowania po stronie serwera, zobacz <xref:System.Web.UI.WebControls.PagedDataSource.AllowServerPaging%2A>. Korzystając z <xref:System.Web.UI.WebControls.DataGrid> sterowania, można też podać własne niestandardowej logiki stronicowania. Aby uzyskać więcej informacji na stronicowania niestandardowego, zobacz <xref:System.Web.UI.WebControls.DataGrid.AllowCustomPaging%2A?displayProperty=nameWithType> i <xref:System.Web.UI.WebControls.PagedDataSource.AllowCustomPaging%2A?displayProperty=nameWithType>.  
  
 Aby uzyskać więcej informacji na temat obsługi stronicowania dla formantów powiązanych z danymi, zobacz `AllowPaging` właściwości formantu powiązanego z danymi.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.DataGrid.AllowCustomPaging" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.AllowCustomPaging" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.AllowServerPaging" />
        <altmember cref="P:System.Web.UI.WebControls.GridView.AllowPaging" />
        <altmember cref="P:System.Web.UI.WebControls.DetailsView.AllowPaging" />
        <altmember cref="P:System.Web.UI.WebControls.FormView.AllowPaging" />
        <altmember cref="P:System.Web.UI.WebControls.DataGrid.AllowPaging" />
      </Docs>
    </Member>
    <Member MemberName="AllowServerPaging">
      <MemberSignature Language="C#" Value="public bool AllowServerPaging { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowServerPaging" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.PagedDataSource.AllowServerPaging" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowServerPaging As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowServerPaging { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy włączono stronicowania po stronie serwera.</summary>
        <value>
          <see langword="true" /> Jeśli włączono stronicowania po stronie serwera; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Formanty powiązane z danymi programu ASP.NET w wersji 2.0 (takich jak <xref:System.Web.UI.WebControls.GridView>, <xref:System.Web.UI.WebControls.DetailsView>, i <xref:System.Web.UI.WebControls.FormView>) zapewniają automatyczne funkcji stronicowania za pośrednictwem stronicowania po stronie serwera. Korzystając z formantu powiązanego z danymi programu ASP.NET 2.0, należy ustawić tę właściwość na `true`.  
  
> [!NOTE]
>  Stronicowania po stronie serwera i stronicowania niestandardowego wzajemnie się wykluczają. Jeśli ustawisz <xref:System.Web.UI.WebControls.PagedDataSource.AllowServerPaging%2A> do `true`, upewnij się, że <xref:System.Web.UI.WebControls.PagedDataSource.AllowCustomPaging%2A> ma ustawioną wartość `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.AllowCustomPaging" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.AllowServerPaging" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.PagedDataSource.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Liczony od zera <see cref="T:System.Array" /> odbierająca skopiowane elementy ze źródła danych.</param>
        <param name="index">Pierwszą pozycję w określonym <see cref="T:System.Array" /> do odbierania skopiowane dane.</param>
        <summary>Kopiuje wszystkie elementy ze źródła danych do określonego <see cref="T:System.Array" />, rozpoczynając od określonego indeksu w <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia skopiowanie zawartości źródła danych do określonego <xref:System.Array?displayProperty=nameWithType>, rozpoczynając od określonego indeksu. <xref:System.Array?displayProperty=nameWithType> Jest często używany do iterowania po elementów w źródle danych.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.PagedDataSource.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów do użycia w źródle danych.</summary>
        <value>Liczba elementów do użycia w źródle danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.WebControls.PagedDataSource.Count%2A> właściwości w celu ustalenia liczby elementów do użycia w źródle danych. Wartość zwracana zależy od tego, czy jest włączone stronicowanie, i czy jest używany niestandardowy stronicowania.  
  
-   Wyłączenie stronicowania (przez ustawienie <xref:System.Web.UI.WebControls.PagedDataSource.IsPagingEnabled%2A> właściwości `false`), wartość <xref:System.Web.UI.WebControls.PagedDataSource.DataSourceCount%2A> zwracana jest właściwość.  
  
-   Jeśli stronicowanie zostało włączone (przez ustawienie <xref:System.Web.UI.WebControls.PagedDataSource.IsPagingEnabled%2A> właściwości `true`) i włączono stronicowania niestandardowego (przez ustawienie <xref:System.Web.UI.WebControls.PagedDataSource.IsCustomPagingEnabled%2A> ustawioną właściwość `true`), wartość <xref:System.Web.UI.WebControls.PagedDataSource.PageSize%2A> zwracana jest właściwość.  
  
-   Jeśli stronicowanie zostało włączone (przez ustawienie <xref:System.Web.UI.WebControls.PagedDataSource.IsPagingEnabled%2A> właściwości `true`) i <xref:System.Web.UI.WebControls.PagedDataSource.IsLastPage%2A> właściwość jest ustawiona na `false`, wartość <xref:System.Web.UI.WebControls.PagedDataSource.PageSize%2A> zwracana jest właściwość.  
  
-   Jeśli stronicowanie zostało włączone (przez ustawienie <xref:System.Web.UI.WebControls.PagedDataSource.IsPagingEnabled%2A> właściwości `true`), stronicowania niestandardowego jest wyłączone (przez ustawienie <xref:System.Web.UI.WebControls.PagedDataSource.IsCustomPagingEnabled%2A> właściwości `false`) i <xref:System.Web.UI.WebControls.PagedDataSource.IsLastPage%2A> właściwość jest ustawiona na `true`, wartość <xref:System.Web.UI.WebControls.PagedDataSource.DataSourceCount%2A>właściwości jest odejmowany od wartości <xref:System.Web.UI.WebControls.PagedDataSource.FirstIndexInPage%2A> właściwości przed zwróceniem jest.  
  
> [!NOTE]
>  Jeśli <xref:System.Web.UI.WebControls.PagedDataSource.DataSource%2A> zawiera właściwość `null`, zwracany jest 0.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.IsPagingEnabled" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.DataSourceCount" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.IsCustomPagingEnabled" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.IsLastPage" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.PageSize" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.FirstIndexInPage" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.DataSource" />
      </Docs>
    </Member>
    <Member MemberName="CurrentPageIndex">
      <MemberSignature Language="C#" Value="public int CurrentPageIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentPageIndex" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.PagedDataSource.CurrentPageIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentPageIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentPageIndex { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia indeks bieżącej strony.</summary>
        <value>Indeks bieżącej strony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.WebControls.PagedDataSource.CurrentPageIndex%2A> właściwości do określania indeks bieżącej strony.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.Count" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.PageCount" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.PageSize" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.VirtualCount" />
      </Docs>
    </Member>
    <Member MemberName="DataSource">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable DataSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerable DataSource" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.PagedDataSource.DataSource" />
      <MemberSignature Language="VB.NET" Value="Public Property DataSource As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IEnumerable ^ DataSource { System::Collections::IEnumerable ^ get(); void set(System::Collections::IEnumerable ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia źródło danych.</summary>
        <value>A <see cref="T:System.Collections.IEnumerable" /> zaimplementowany obiekt, który reprezentuje źródło danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.WebControls.PagedDataSource.DataSource%2A> właściwości do określania źródła danych jest stronicowanej.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.DataSourceCount" />
      </Docs>
    </Member>
    <Member MemberName="DataSourceCount">
      <MemberSignature Language="C#" Value="public int DataSourceCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DataSourceCount" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.PagedDataSource.DataSourceCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataSourceCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DataSourceCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów w źródle danych.</summary>
        <value>Liczba elementów w źródle danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.WebControls.PagedDataSource.DataSourceCount%2A> właściwości w celu ustalenia liczby elementów w źródle danych. Jeśli jest używany niestandardowy stronicowania lub stronicowania po stronie serwera, wartość <xref:System.Web.UI.WebControls.PagedDataSource.VirtualCount%2A> zwracana jest właściwość; w przeciwnym razie zwracany jest całkowita liczba elementów w źródle danych.  
  
> [!NOTE]
>  Jeśli <xref:System.Web.UI.WebControls.PagedDataSource.DataSource%2A> zawiera właściwość `null`, zwracany jest 0.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Źródło danych nie jest <see cref="T:System.Collections.ICollection" /> zaimplementowana obiektu.</exception>
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.IsCustomPagingEnabled" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.AllowServerPaging" />
      </Docs>
    </Member>
    <Member MemberName="FirstIndexInPage">
      <MemberSignature Language="C#" Value="public int FirstIndexInPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 FirstIndexInPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.PagedDataSource.FirstIndexInPage" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FirstIndexInPage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int FirstIndexInPage { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera indeks pierwszego rekordu wyświetlane na stronie.</summary>
        <value>Indeks pierwszego rekordu wyświetlane na stronie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.WebControls.PagedDataSource.FirstIndexInPage%2A> właściwości, aby określić indeks pierwszego elementu na bieżącej stronie.  
  
> [!NOTE]
>  Jeśli <xref:System.Web.UI.WebControls.PagedDataSource.IsPagingEnabled%2A> właściwość jest ustawiona na `false`, lub <xref:System.Web.UI.WebControls.PagedDataSource.IsCustomPagingEnabled%2A> lub <xref:System.Web.UI.WebControls.PagedDataSource.AllowServerPaging%2A> właściwości są ustawione na `true`, lub <xref:System.Web.UI.WebControls.PagedDataSource.DataSource%2A> zawiera właściwość `null`, zwracany jest 0.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.IsPagingEnabled" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.IsCustomPagingEnabled" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.DataSource" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.PagedDataSource.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Collections.IEnumerator" /> zaimplementowany obiekt, który zawiera wszystkie elementy w źródle danych.</summary>
        <returns>A <see cref="T:System.Collections.IEnumerator" /> zaimplementowany obiekt, który zawiera wszystkie elementy w źródle danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia <xref:System.Collections.IEnumerator?displayProperty=nameWithType> który można należy powtórzyć za pomocą można pobrać każdego elementu w źródle danych. Aby uzyskać dostęp do elementu w bieżącym położeniu w moduł wyliczający, użyj <xref:System.Collections.IEnumerator.Current%2A?displayProperty=nameWithType> właściwości. Użyj <xref:System.Collections.IEnumerator.MoveNext%2A?displayProperty=nameWithType> metody, aby przejść do następnego elementu w kolekcji. Aby przenieść moduł wyliczający początkową, użyj <xref:System.Collections.IEnumerator.Reset%2A?displayProperty=nameWithType> metody.  
  
> [!NOTE]
>  Po początkowym pobrania modułu wyliczającego lub użyj <xref:System.Collections.IEnumerator.Reset%2A?displayProperty=nameWithType> metodę, aby przenieść modułu wyliczającego do pierwszego elementu w kolekcji, należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A?displayProperty=nameWithType> metody. W przeciwnym razie element reprezentowany przez <xref:System.Collections.IEnumerator.Current%2A?displayProperty=nameWithType> właściwość jest niezdefiniowana.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="M:System.Collections.IEnumerator.Reset" />
        <altmember cref="M:System.Collections.IEnumerator.MoveNext" />
        <altmember cref="P:System.Collections.IEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="GetItemProperties">
      <MemberSignature Language="C#" Value="public System.ComponentModel.PropertyDescriptorCollection GetItemProperties (System.ComponentModel.PropertyDescriptor[] listAccessors);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.PropertyDescriptorCollection GetItemProperties(class System.ComponentModel.PropertyDescriptor[] listAccessors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.PagedDataSource.GetItemProperties(System.ComponentModel.PropertyDescriptor[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemProperties (listAccessors As PropertyDescriptor()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::PropertyDescriptorCollection ^ GetItemProperties(cli::array &lt;System::ComponentModel::PropertyDescriptor ^&gt; ^ listAccessors);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="listAccessors" Type="System.ComponentModel.PropertyDescriptor[]" />
      </Parameters>
      <Docs>
        <param name="listAccessors">Tablica <see cref="T:System.ComponentModel.PropertyDescriptor" /> zwracane obiekty, które zawiera nazwę listy. Może to być <see langword="null" />.</param>
        <summary>Zwraca <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> reprezentujący właściwości na każdy element używanych do wiązania danych.</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> Reprezentujący właściwości na każdy element używanych do wiązania danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.WebControls.PagedDataSource.GetItemProperties%2A> metodę w celu utworzenia <xref:System.ComponentModel.PropertyDescriptorCollection?displayProperty=nameWithType> reprezentujący właściwości na każdy element używanych do wiązania danych. Jeśli <xref:System.Web.UI.WebControls.PagedDataSource.DataSource%2A> właściwość jest `null` lub nie jest <xref:System.ComponentModel.ITypedList?displayProperty=nameWithType> zaimplementowany obiekt `null` jest zwracany. Aby uzyskać więcej informacji na temat <xref:System.Web.UI.WebControls.PagedDataSource.GetItemProperties%2A> metody, zobacz <xref:System.ComponentModel.ITypedList.GetItemProperties%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.ITypedList" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="M:System.ComponentModel.ITypedList.GetItemProperties(System.ComponentModel.PropertyDescriptor[])" />
      </Docs>
    </Member>
    <Member MemberName="GetListName">
      <MemberSignature Language="C#" Value="public string GetListName (System.ComponentModel.PropertyDescriptor[] listAccessors);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetListName(class System.ComponentModel.PropertyDescriptor[] listAccessors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.PagedDataSource.GetListName(System.ComponentModel.PropertyDescriptor[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetListName (listAccessors As PropertyDescriptor()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetListName(cli::array &lt;System::ComponentModel::PropertyDescriptor ^&gt; ^ listAccessors);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="listAccessors" Type="System.ComponentModel.PropertyDescriptor[]" />
      </Parameters>
      <Docs>
        <param name="listAccessors">Tablica <see cref="T:System.ComponentModel.PropertyDescriptor" /> zwracane obiekty, które zawiera nazwę listy. Może to być <see langword="null" />.</param>
        <summary>Zwraca nazwę listy. Ta metoda nie ma zastosowania do tej klasy.</summary>
        <returns>
          <see cref="F:System.String.Empty" /> we wszystkich przypadkach.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest odziedziczone <xref:System.ComponentModel.ITypedList?displayProperty=nameWithType> i nie ma zastosowania do tej klasy. Została ona zaimplementowana do zwrócenia <xref:System.String.Empty?displayProperty=nameWithType> we wszystkich przypadkach.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.ITypedList" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="M:System.ComponentModel.ITypedList.GetListName(System.ComponentModel.PropertyDescriptor[])" />
      </Docs>
    </Member>
    <Member MemberName="IsCustomPagingEnabled">
      <MemberSignature Language="C#" Value="public bool IsCustomPagingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomPagingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.PagedDataSource.IsCustomPagingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCustomPagingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCustomPagingEnabled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy włączono stronicowania niestandardowego.</summary>
        <value>
          <see langword="true" /> Jeśli włączono stronicowania niestandardowego; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.WebControls.PagedDataSource.IsCustomPagingEnabled%2A> właściwości w celu określenia, czy włączono stronicowania niestandardowego.  
  
> [!NOTE]
>  Zarówno <xref:System.Web.UI.WebControls.PagedDataSource.IsPagingEnabled%2A> i <xref:System.Web.UI.WebControls.PagedDataSource.AllowCustomPaging%2A> właściwości muszą być `true` dla tej właściwości zwrócić `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.IsPagingEnabled" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.AllowCustomPaging" />
      </Docs>
    </Member>
    <Member MemberName="IsFirstPage">
      <MemberSignature Language="C#" Value="public bool IsFirstPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.PagedDataSource.IsFirstPage" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFirstPage As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFirstPage { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżąca strona jest pierwszej strony.</summary>
        <value>
          <see langword="true" /> Jeśli bieżąca strona jest pierwszą stroną; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.WebControls.PagedDataSource.IsFirstPage%2A> właściwości w celu określenia, czy bieżąca strona jest pierwszej strony.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.IsLastPage" />
      </Docs>
    </Member>
    <Member MemberName="IsLastPage">
      <MemberSignature Language="C#" Value="public bool IsLastPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLastPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.PagedDataSource.IsLastPage" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLastPage As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLastPage { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżąca strona jest to ostatnia strona.</summary>
        <value>
          <see langword="true" /> Jeśli bieżąca strona jest to ostatnia strona; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.WebControls.PagedDataSource.IsLastPage%2A> właściwości w celu określenia, czy bieżąca strona jest to ostatnia strona.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.IsFirstPage" />
      </Docs>
    </Member>
    <Member MemberName="IsPagingEnabled">
      <MemberSignature Language="C#" Value="public bool IsPagingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPagingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.PagedDataSource.IsPagingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPagingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPagingEnabled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy jest włączone stronicowanie.</summary>
        <value>
          <see langword="true" /> Jeśli stronicowanie zostało włączone; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.WebControls.PagedDataSource.IsPagingEnabled%2A> właściwości w celu określenia, czy jest włączone stronicowanie.  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.PagedDataSource.AllowPaging%2A> Właściwość musi być `true` i <xref:System.Web.UI.WebControls.PagedDataSource.PageSize%2A> nie można ustawić właściwości na wartość 0 dla tej właściwości zwrócić `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.AllowPaging" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.PageSize" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.PagedDataSource.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy źródło danych jest tylko do odczytu.</summary>
        <value>
          <see langword="false" /> we wszystkich przypadkach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest zaimplementowana do zawsze zwracają `false`, co oznacza, że źródło danych można zmodyfikować we wszystkich przypadkach.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsServerPagingEnabled">
      <MemberSignature Language="C#" Value="public bool IsServerPagingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsServerPagingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.PagedDataSource.IsServerPagingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsServerPagingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsServerPagingEnabled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy jest włączona obsługa stronicowania po stronie serwera.</summary>
        <value>
          <see langword="true" /> Jeśli stronicowanie zostało włączone i stronicowania po stronie serwera jest sygnalizowany <see cref="P:System.Web.UI.WebControls.PagedDataSource.AllowServerPaging" /> właściwość; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Włączono stronicowania po stronie serwera podczas <xref:System.Web.UI.WebControls.PagedDataSource.AllowPaging%2A> i <xref:System.Web.UI.WebControls.PagedDataSource.AllowServerPaging%2A> właściwości są ustawione na `true`, i ilość danych pobieranych przez źródło danych nie można wyświetlić na jednej stronie.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.AllowPaging" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.AllowServerPaging" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.PageCount" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.PagedDataSource.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy dostęp do źródła danych jest zsynchronizowany (wątkowo).</summary>
        <value>
          <see langword="false" /> we wszystkich przypadkach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest określana na podstawie <xref:System.Collections.ICollection?displayProperty=nameWithType> klasy i zastąpić jest zawsze zwracają `false` aby wskazać, że ta klasa nie jest bezpieczne wątkowo.  
  
 Aby uzyskać więcej informacji na temat <xref:System.Web.UI.WebControls.PagedDataSource.IsSynchronized%2A> właściwości, zobacz <xref:System.Collections.ICollection.IsSynchronized%2A?displayProperty=nameWithType> właściwość <xref:System.Collections.ICollection?displayProperty=nameWithType> interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="PageCount">
      <MemberSignature Language="C#" Value="public int PageCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PageCount" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.PagedDataSource.PageCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PageCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PageCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera łączną liczbą stron niezbędne do wyświetlania wszystkich elementów w źródle danych.</summary>
        <value>Liczba stron niezbędne do wyświetlania wszystkich elementów w źródle danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.WebControls.PagedDataSource.PageCount%2A> właściwości w celu określenia liczby stron niezbędne do wyświetlania wszystkich elementów w źródle danych.  
  
> [!NOTE]
>  Jeśli <xref:System.Web.UI.WebControls.PagedDataSource.DataSource%2A> właściwość jest `null`, zwracany jest 0. Jeśli <xref:System.Web.UI.WebControls.PagedDataSource.IsPagingEnabled%2A> właściwość jest ustawiona na `false` lub <xref:System.Web.UI.WebControls.PagedDataSource.DataSourceCount%2A> właściwość jest ustawiona na wartość 0 lub mniej, zwracana jest 1.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.Count" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.CurrentPageIndex" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.DataSourceCount" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.PageSize" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.VirtualCount" />
      </Docs>
    </Member>
    <Member MemberName="PageSize">
      <MemberSignature Language="C#" Value="public int PageSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PageSize" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.PagedDataSource.PageSize" />
      <MemberSignature Language="VB.NET" Value="Public Property PageSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PageSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia liczbę elementów do wyświetlenia na jednej stronie.</summary>
        <value>Liczba elementów do wyświetlenia na jednej stronie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.WebControls.PagedDataSource.PageSize%2A> właściwości, aby określić lub określić liczbę elementów do wyświetlenia na jednej stronie.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.Count" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.CurrentPageIndex" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.DataSourceCount" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.PageCount" />
        <altmember cref="P:System.Web.UI.WebControls.PagedDataSource.VirtualCount" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.PagedDataSource.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizujący dostęp do kolekcji.</summary>
        <value>Obiekt, który może służyć do synchronizujący dostęp do kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt zwrócony w tej implementacji jest <xref:System.Web.UI.WebControls.PagedDataSource> samego obiektu.  
  
 Aby uzyskać więcej informacji na temat <xref:System.Web.UI.WebControls.DataGridColumnCollection.SyncRoot%2A> właściwości, zobacz <xref:System.Collections.ICollection.SyncRoot%2A?displayProperty=nameWithType> właściwość <xref:System.Collections.ICollection?displayProperty=nameWithType> interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <Member MemberName="VirtualCount">
      <MemberSignature Language="C#" Value="public int VirtualCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualCount" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.PagedDataSource.VirtualCount" />
      <MemberSignature Language="VB.NET" Value="Public Property VirtualCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualCount { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wirtualnego liczba elementów w źródle danych, użycie stronicowania niestandardowego.</summary>
        <value>Wirtualne liczba elementów w źródle danych, gdy jest używany niestandardowy stronicowania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.WebControls.PagedDataSource.VirtualCount%2A> właściwość podczas stronicowania niestandardowego lub stronicowania po stronie serwera służy do określania wirtualnego liczba elementów w źródle danych. Aby uzyskać więcej informacji na temat <xref:System.Web.UI.WebControls.PagedDataSource.VirtualCount%2A> właściwości, zobacz <xref:System.Web.UI.WebControls.DataGrid.VirtualItemCount%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.DataGrid.VirtualItemCount" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="LinqDataSource" FullName="System.Web.UI.WebControls.LinqDataSource">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2428f9fb506effcb3a27648da9609ff286984250" /><Meta Name="ms.sourcegitcommit" Value="e7974886b08aa83a8fb461e8550f31a7d4331ee3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/23/2019" /><Meta Name="ms.locfileid" Value="68393189" /></Metadata><TypeSignature Language="C#" Value="public class LinqDataSource : System.Web.UI.WebControls.ContextDataSource, System.Web.DynamicData.IDynamicDataSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit LinqDataSource extends System.Web.UI.WebControls.ContextDataSource implements class System.Web.DynamicData.IDynamicDataSource, class System.Web.UI.IDataSource" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.LinqDataSource" />
  <TypeSignature Language="VB.NET" Value="Public Class LinqDataSource&#xA;Inherits ContextDataSource&#xA;Implements IDynamicDataSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class LinqDataSource : System::Web::UI::WebControls::ContextDataSource, System::Web::DynamicData::IDynamicDataSource" />
  <TypeSignature Language="F#" Value="type LinqDataSource = class&#xA;    inherit ContextDataSource&#xA;    interface IDynamicDataSource&#xA;    interface IDataSource" />
  <AssemblyInfo>
    <AssemblyName>System.Web.Extensions</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.WebControls.ContextDataSource</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-3.5">System.Web.UI.DataSourceControl</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.DynamicData.IDynamicDataSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IDataSource</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Selecting")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("ContextTypeName")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.LinqDataSourceDesigner, System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Drawing.ToolboxBitmap(typeof(System.Web.UI.WebControls.LinqDataSource), "LinqDataSource.bmp")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.LinqDataSourceDesigner, System.Web.Extensions.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5">
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Web.Extensions, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", System.ComponentModel.ToolboxItemFilterType.Require)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5">
      <AttributeName>System.Drawing.ToolboxBitmap(typeof(System.Web.UI.WebControls.LinqDataSource), "LinqDataSource.ico")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Umożliwia korzystanie z zapytań zintegrowanych z językiem (LINQ) na stronie sieci Web ASP.NET za pomocą znaczników tekstu do pobierania i modyfikowania danych z obiektu danych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W tym temacie:  
  
-   [Wprowadzenie](#introduction)  
  
-   [Kolejność operacji](#order_of_operations)  
  
-   [Porządkowanie danych](#ordering_data)  
  
-   [Grupowanie danych](#grouping_data)  
  
-   [Modyfikacje danych](#data_modifications)  
  
-   [Ocenianie wartości w czasie wykonywania](#evaluating_value_at_run_time)  
  
-   [Praca z procedurami składowanymi](#working_with_stored_procedures)  
  
-   [Składnia deklaracyjne](#declarative_syntax)  
  
<a name="introduction"></a>   
## <a name="introduction"></a>Wprowadzenie  
 Language-Integrated Query (LINQ) to Składnia zapytania, która definiuje zestaw operatorów zapytań, które umożliwiają przechodzenie, filtrowanie i projekcję, które mają być wyrażone w sposób deklaratywny. Język programowania oparty na sieci. Obiekt danych może być kolekcją danych w pamięci lub obiektem, który reprezentuje dane z bazy danych. Dane można pobrać lub zmodyfikować bez konieczności pisania poleceń SQL dla każdej operacji.  
  
 <xref:System.Web.UI.WebControls.LinqDataSource> Kontrolka umożliwia użycie LINQ na stronie sieci Web ASP.NET przez ustawienie właściwości w tekście znaczników. <xref:System.Web.UI.WebControls.LinqDataSource> Kontrolka używa LINQ to SQL do automatycznego generowania poleceń dotyczących danych. Aby uzyskać więcej informacji na temat LINQ to SQL, zobacz [LINQ to SQL](https://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655).  
  
 Podczas pobierania danych z zbierania danych w pamięci należy ustawić <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A> właściwość na klasę, która zawiera kolekcję danych. <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> Właściwość jest ustawiana na właściwość lub pole, które zwraca zbieranie danych. Można na przykład mieć klasę o nazwie `Person` , która zawiera właściwość o nazwie `FavoriteCities` , która zwraca tablicę wartości ciągu. W takim <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A> przypadku należy ustawić właściwość na `Person` i ustawić <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> właściwość na `FavoriteCities`.  
  
 Podczas wykonywania zapytania dotyczącego bazy danych należy najpierw utworzyć klasy jednostek, które reprezentują bazę danych i jej tabele. Aby wygenerować te klasy [!INCLUDE[vs_ordesigner_long](~/includes/vs-ordesigner-long-md.md)] , można użyć narzędzia lub SQLMetal. exe. Następnie należy ustawić <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A> właściwość na klasę reprezentującą bazę danych i <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> ustawić właściwość, która reprezentuje tabelę bazy danych.  
  
<a name="order_of_operations"></a>   
## <a name="order-of-operations"></a>Kolejność operacji  
 <xref:System.Web.UI.WebControls.LinqDataSource> Formant stosuje operacje na danych w następującej kolejności:  
  
1.  Gdzie (określić rekordy danych do zwrócenia).  
  
2.  Order by (Sort).  
  
3.  Grupuj według (Agreguj rekordy danych, które współużytkują wartości).  
  
4.  Grupuj grupy według (Sortuj pogrupowane dane).  
  
5.  Wybierz (Określ pola lub właściwości do zwrócenia).  
  
6.  Sortuj według Autokorekty (Sortuj rekordy danych według właściwości, która została wybrana przez użytkownika).  
  
7.  AutoPage (pobieranie podzbioru rekordów danych, które zostały wybrane przez użytkownika).  
  
 Możesz dodać warunki do <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> właściwości, aby odfiltrować rekordy danych, które są zwracane z zapytania. Jeśli właściwość nie jest ustawiona <xref:System.Web.UI.WebControls.LinqDataSource> , formant pobiera każdy rekord z obiektu danych. <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>  
  
<a name="ordering_data"></a>   
## <a name="ordering-data"></a>Porządkowanie danych  
 Użyj właściwości, <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> aby określić nazwy właściwości z zwracanych danych, według których ma zostać wykonane sortowanie.  
  
> [!NOTE]
>  Gdy używasz <xref:System.Web.UI.WebControls.LinqDataSource> kontrolki z [!INCLUDE[ssEW](~/includes/ssew-md.md)] [!INCLUDE[ss2k](~/includes/ss2k-md.md)] lub, a <xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A> `true` Właściwość<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> jest ustawiona na, musisz podać wartość we właściwości. Domyślnie <xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A> właściwość jest `true`. W przypadku przypisywania wartości do <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości, należy również uwzględnić wszystkie kolumny tożsamości na liście właściwości, które są zwracane w zapytaniu.  
  
<a name="grouping_data"></a>   
## <a name="grouping-data"></a>Grupowanie danych  
 Użyj <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwości, aby określić, które właściwości są używane do konsolidowania rekordów danych, które mają te same wartości. Podczas grupowania danych można uwzględnić `Key` i `It`, które są dynamicznie <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> tworzone właściwości, we właściwości. `Key` Właściwość odwołuje się do wartości we właściwości lub właściwościach, które były używane do grupowania danych. Na przykład, Jeśli grupujesz według właściwości o nazwie `Category` `Key` , właściwość będzie zawierać `Category` wszystkie unikatowe wartości we właściwości. `It` Właściwość odwołuje się do kolekcji pojedynczych rekordów w grupie danych. Można wykonać iterację we `It` właściwości, aby pobrać pojedyncze rekordy, które zostały skonsolidowane w operacji grupowania. Na przykład Jeśli grupujesz według właściwości o nazwie `Category` `It` , właściwość zawiera wszystkie pojedyncze rekordy, które mają wspólną wartość we `Category` właściwości.  
  
 Użyj właściwości, <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A> aby określić właściwości, które mają być używane do sortowania pogrupowanych danych. Gdy grupujesz dane, <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> Właściwość określa sposób sortowania poszczególnych rekordów w pogrupowanych danych.  
  
 Domyślnie <xref:System.Web.UI.WebControls.LinqDataSource> formant pobiera wartości dla wszystkich właściwości z obiektu danych. Użyj właściwości, <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> aby określić, które właściwości mają być zwracane, jeśli chcesz korzystać z podzestawu dostępnych właściwości. Operacja SELECT jest stosowana po operacji WHERE, Order by i Group by. W związku z tym, jeśli tworzysz alias w klauzuli select, alias nie będzie dostępny w innych klauzulach.  
  
<a name="data_modifications"></a>   
## <a name="data-modifications"></a>Modyfikacje danych  
 Można określić <xref:System.Web.UI.WebControls.LinqDataSource.EnableDelete%2A>, czy modyfikacje danych są włączone przy użyciu właściwości <xref:System.Web.UI.WebControls.LinqDataSource.EnableInsert%2A>, i <xref:System.Web.UI.WebControls.LinqDataSource.EnableUpdate%2A> . Interfejs użytkownika służący do modyfikowania danych z <xref:System.Web.UI.WebControls.LinqDataSource> formantu jest zwykle dostarczany przez kontrolkę powiązaną z danymi, taką <xref:System.Web.UI.WebControls.DetailsView> jak kontrolka. Oprócz ustawienia <xref:System.Web.UI.WebControls.LinqDataSource.EnableDelete%2A>, <xref:System.Web.UI.WebControls.LinqDataSource.EnableInsert%2A>, lub <xref:System.Web.UI.WebControls.LinqDataSource.EnableUpdate%2A> do `true`, następujące warunki są wymagane do włączenia automatycznych modyfikacji danych:  
  
-   Do <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości nie można przypisać wartości.  
  
-   Do <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwości nie można przypisać wartości.  
  
-   Klasa, która jest przypisana do <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A> właściwości, musi pochodzić <xref:System.Data.Linq.DataContext>od.  
  
-   Właściwość, która jest przypisana do <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> właściwości, musi pochodzić <xref:System.Data.Linq.Table%601>od.  
  
 Można ograniczyć, które właściwości są wyświetlane w formancie powiązanym z danymi na dwa sposoby. Można ustawić <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwość na podzbiór właściwości lub można zdefiniować pola dla kontrolki powiązanej z danymi, dodając <xref:System.Web.UI.WebControls.DataControlField> formanty. Jeśli jednak ustawisz <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwość, oznacza to, że nie można włączyć operacji automatycznego aktualizowania, wstawiania i usuwania. Jeśli chcesz włączyć automatyczne modyfikacje danych podczas pracy z podzbiorem dostępnych właściwości, nie ustawiaj <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości. Zamiast tego należy pobrać wszystkie właściwości z obiektu danych i zarządzać tymi, które są wyświetlane przy użyciu formantu powiązanego z danymi. W <xref:System.Web.UI.WebControls.DetailsView> przypadku używania `false`kontrolki <xref:System.Web.UI.WebControls.GridView> lub kontrolki, należy również ustawić <xref:System.Web.UI.WebControls.DetailsView.AutoGenerateRows%2A> właściwości lub <xref:System.Web.UI.WebControls.GridView.AutoGenerateColumns%2A> . Dzięki temu formant powiązany z danymi nie jest automatycznie uwzględniany w celu edytowania i usuwania danych. Wszystkie wartości, które nie są wyświetlane w formancie powiązanym z danymi, są przechowywane w stanie widoku. Są one przenoszone bez zmian do źródła danych podczas przeprowadzania aktualizacji danych.  
  
<a name="evaluating_value_at_run_time"></a>   
## <a name="evaluating-values-at-run-time"></a>Ocenianie wartości w czasie wykonywania  
 Jeśli trzeba oszacować wartości w czasie wykonywania w celu porządkowania, filtrowania lub grupowania wartości, można dodać <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>parametry do kolekcji <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters%2A>, <xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A>,, lub <xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A> .  
  
 Jeśli chcesz określić wartości domyślne, możesz dodać parametry do <xref:System.Web.UI.WebControls.LinqDataSource.InsertParameters%2A> kolekcji.  
  
 Jeśli chcesz przejrzeć lub zmodyfikować <xref:System.Web.UI.WebControls.LinqDataSource.Deleting>wartości przed wykonaniem operacji na danych, możesz obsłużyć zdarzenia <xref:System.Web.UI.WebControls.LinqDataSource.Selecting>, <xref:System.Web.UI.WebControls.LinqDataSource.Inserting>,, lub <xref:System.Web.UI.WebControls.LinqDataSource.Updating> . Można także obsłużyć te zdarzenia w celu anulowania operacji na danych lub sprawdzenia błędów sprawdzania poprawności, które wystąpiły podczas ustawiania właściwości w klasie danych na podstawie danych wejściowych użytkownika.  
  
 Aby przeanalizować wartości po zakończeniu operacji na danych, obsługuj <xref:System.Web.UI.WebControls.LinqDataSource.Deleted>zdarzenia <xref:System.Web.UI.WebControls.LinqDataSource.Inserted> <xref:System.Web.UI.WebControls.LinqDataSource.Selected>,, lub <xref:System.Web.UI.WebControls.LinqDataSource.Updated> .  
  
<a name="working_with_stored_procedures"></a>   
## <a name="working-with-stored-procedures"></a>Praca z procedurami składowanymi  
 <xref:System.Web.UI.WebControls.LinqDataSource> Kontrolka służy do pobierania danych z procedury składowanej przez utworzenie programu obsługi zdarzeń <xref:System.Web.UI.WebControls.LinqDataSource.Selecting> dla zdarzenia. W procedurze obsługi zdarzeń należy wywołać metodę w klasie kontekstu danych, która reprezentuje procedurę składowaną, i ustawić wynik na <xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs.Result%2A> Właściwość <xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs> obiektu. Jeśli chcesz włączyć automatyczne operacje aktualizowania, wstawiania i usuwania danych, typ, który jest zwracany z metody, musi być zgodny z typem, który jest określony we <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> właściwości. Aby uzyskać więcej informacji na temat tworzenia metod kontekstu danych [, zobacz How to: Utwórz metody DataContext zamapowane na procedury składowane i funkcje (Projektant O/](https://msdn.microsoft.com/library/e7ca32f1-50b3-48af-ad92-ceafd749296a)R).  
  
<a name="declarative_syntax"></a>   
## <a name="declarative-syntax"></a>Składnia deklaracyjna  
  
```  
<asp:LinqDataSource  
    AutoGenerateOrderByClause="True|False"  
    AutoGenerateWhereClause="True|False"  
    AutoPage="True|False"  
    AutoSort="True|False"  
    ContextTypeName="string"  
    EnableDelete="True|False"  
    EnableInsert="True|False"  
    EnableTheming="True|False"  
    EnableUpdate="True|False"  
    EnableViewState="True|False"  
    GroupBy="string"  
    ID="string"  
    OnContextCreated="ContextCreated event handler"  
    OnContextCreating="ContextCreating event handler"  
    OnContextDisposing="ContextDisposing event handler"  
    OnDataBinding="DataBinding event handler"  
    OnDeleted="Deleted event handler"  
    OnDeleting="Deleting event handler"  
    OnDisposed="Disposed event handler"  
    OnInit="Init event handler"  
    OnInserted="Inserted event handler"  
    OnInserting="Inserting event handler"  
    OnLoad="Load event handler"  
    OnPreRender="PreRender event handler"  
    OnSelected="Selected event handler"  
    OnSelecting="Selecting event handler"  
    OnUnload="Unload event handler"  
    OnUpdated="Updated event handler"  
    OnUpdating="Updating event handler"  
    OrderBy="string"  
    runat="server"  
    Select="string"  
    SkinID="string"  
    StoreOriginalValuesInViewState="True|False"  
    TableName="string"  
    Visible="True|False"  
    Where="string"  
>  
        <GroupByParameters />  
        <InsertParameters />  
        <OrderByParameters />  
        <SelectParameters />  
        <WhereParameters />  
</asp:LinqDataSource>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje <xref:System.Web.UI.WebControls.LinqDataSource> kontrolkę, która pobiera dane z klasy jednostki o nazwie `Products`. Klasa jednostki mogła zostać wygenerowana przy użyciu [!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)] narzędzia lub SQLMetal. exe. Właściwość jest ustawiona tak, aby zwracała tylko rekordy, które mają wartość `Price` we właściwości większej niż 50. <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> Formant jest powiązany <xref:System.Web.UI.WebControls.LinqDataSource> z kontrolką, aby wyświetlić dane. <xref:System.Web.UI.WebControls.GridView>  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default5.aspx#5)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default5.aspx#5)]  
  
 Poniższy przykład pokazuje <xref:System.Web.UI.WebControls.LinqDataSource> formant, który umożliwia użytkownikom aktualizowanie, usuwanie i wstawianie rekordów w źródle danych. Formant jest powiązany <xref:System.Web.UI.WebControls.LinqDataSource> z kontrolką i umożliwia użytkownikom wyświetlanie i modyfikowanie danych. <xref:System.Web.UI.WebControls.DetailsView> Zwróć uwagę, że polecenia SQL nie są wymagane, aby można było wybierać, aktualizować, usuwać lub wstawiać rekordy.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default2.aspx#2)]  
  
 Poniższy przykład pokazuje procedurę obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Selecting> zdarzenia, które ustawia obiekt danych na podstawie wartości na stronie sieci Web.  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSourceSelectEventArgs#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceSelectEventArgs/cs/Default3.aspx.cs#3)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSourceSelectEventArgs#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceSelectEventArgs/vb/Default3.aspx.vb#3)]  
  
 Poniższy przykład pokazuje <xref:System.Web.UI.WebControls.LinqDataSource> kontrolkę, która jest skonfigurowana do grupowania według dwóch kolumn. Właściwość odwołuje się do obiektu, który ma dwie `ProductCategory` właściwości, i `Color`. `Key` Obiekt reprezentowany przez `It` jest z nazwą (z aliasem) `Products`na. Obiekt o `Products` zmienionej nazwie zawiera kolekcję pojedynczych rekordów w grupie. Każde wystąpienie będzie zawierać wszystkie kolumny z `Products` tabeli.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.GroupBy#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.GroupBy#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/vb/Default.aspx#1)]  
  
 Poniższy przykład pokazuje dwie <xref:System.Web.UI.WebControls.ListView> kontrolki, które wyświetlają dane <xref:System.Web.UI.WebControls.LinqDataSource> z kontrolki w poprzednim przykładzie. W <xref:System.Web.UI.WebControls.ListView> jednym formancie są wyświetlane zgrupowane dane, a w <xref:System.Web.UI.WebControls.ListView> drugiej kontrolce są wyświetlane poszczególne nazwy produktów należących do tej grupy. <xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A> Właściwość zagnieżdżonej kontrolki powiązanej z danymi jest ustawiona `Products`na, która `It` jest aliasem obiektu.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.GroupBy#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/cs/Default.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.GroupBy#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/vb/Default.aspx#2)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655">LINQ do SQL</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LinqDataSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LinqDataSource();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoGenerateOrderByClause">
      <MemberSignature Language="C#" Value="public bool AutoGenerateOrderByClause { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoGenerateOrderByClause" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoGenerateOrderByClause As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoGenerateOrderByClause { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoGenerateOrderByClause : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> kontrolka dynamicznie tworzy klauzulę ORDER by na podstawie wartości <see cref="P:System.Web.UI.WebControls.LinqDataSource.OrderByParameters" /> w kolekcji.</summary>
        <value><see langword="true" />Jeśli formant tworzy klauzulę ORDER by; <see langword="false" />w przeciwnym razie. <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po ustawieniu <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A> właściwości na `true`, <xref:System.Web.UI.WebControls.LinqDataSource> formant dynamicznie tworzy klauzulę ORDER by, <xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A> która jest oparta na wartościach w kolekcji. <xref:System.Web.UI.WebControls.LinqDataSource> Kontrolka sortuje dane według pierwszego parametru, a następnie sortuje dane dla każdego dodatkowego parametru. Parametry, które `null` zawierają lub wartość pustą, nie są uwzględnione w klauzuli Order by.  
  
 Nie ustawiasz <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> właściwości, <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A> gdy jest ustawiona na `true`, ponieważ Analizator dynamicznie tworzy klauzulę ORDER by. Kontrolka zgłasza wyjątek, <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A> `true` Jeśli<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> jest ustawiona na, a właściwość jest przypisana wartości. <xref:System.Web.UI.WebControls.LinqDataSource>  
  
   
  
## Examples  
 Poniższy przykład pokazuje <xref:System.Web.UI.WebControls.LinqDataSource> kontrolkę <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A> z ustawioną na `true`. Parametr jest dołączany do <xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A> kolekcji, która porządkuje dane na podstawie nazwy właściwości, którą użytkownik wybiera <xref:System.Web.UI.WebControls.DropDownList> z formantu.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#8](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default8.aspx#8)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#8](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default8.aspx#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoGenerateWhereClause">
      <MemberSignature Language="C#" Value="public bool AutoGenerateWhereClause { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoGenerateWhereClause" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoGenerateWhereClause As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoGenerateWhereClause { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoGenerateWhereClause : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.AutoGenerateWhereClause</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> kontrolka dynamicznie tworzy klauzulę WHERE na podstawie wartości zdefiniowanych <see cref="P:System.Web.UI.WebControls.LinqDataSource.WhereParameters" /> w kolekcji.</summary>
        <value><see langword="true" />Jeśli kontrolka utworzy klauzulę WHERE; <see langword="false" />w przeciwnym razie. <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po ustawieniu <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A> właściwości na `true`, <xref:System.Web.UI.WebControls.LinqDataSource> formant dynamicznie tworzy klauzulę WHERE z parametrów w <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> kolekcji. Każdy parametr dodawany do <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> kolekcji musi <xref:System.Web.UI.WebControls.Parameter.Name%2A> mieć Właściwość ustawioną na wartość zgodną z właściwością w obiekcie danych, który jest wysyłany do zapytania. Automatycznie wygenerowana klauzula WHERE sprawdzi, czy wartość określona w <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> kolekcji jest równa wartości właściwości pasującej w obiekcie danych. Jeśli podano więcej niż jeden parametr, parametry są połączone z operacją logiczną `AND` . Parametry, które `null` zawierają lub wartość pustą, nie są uwzględnione w klauzuli WHERE.  
  
 Automatycznie wygenerowana <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> klauzula może testować tylko pod kątem równości i łączyć parametry tylko `AND` z operacją. Nie ustawiaj <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A> właściwości na `true` , jeśli musisz dodać warunek, który nie sprawdza się pod kątem równości lub jeśli musisz powiązać parametry z `OR` operacją. Te zadania można <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A> wykonać przez ustawienie właściwości na `false` i <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> dodanie symboli zastępczych we właściwości dla każdego parametru w <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> kolekcji. <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> We właściwości, należy poprzedzić każdą nazwę symbolu zastępczego symbolem @.  
  
 <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> Właściwość<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A> nie jest`true`ustawiana, ponieważ Analizator dynamicznie tworzy klauzulę WHERE. Kontrolka zgłasza wyjątek, <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A> Jeśli właściwość jest `true` i <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> jest przypisywana wartość właściwości. <xref:System.Web.UI.WebControls.LinqDataSource>  
  
   
  
## Examples  
 Poniższy przykład pokazuje <xref:System.Web.UI.WebControls.LinqDataSource> kontrolkę <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A> z ustawioną na `true`. Kontrolka jest powiązana <xref:System.Web.UI.WebControls.LinqDataSource> z kontrolką w celu wyświetlenia danych zwracanych z zapytania. <xref:System.Web.UI.WebControls.GridView> Dołączono <xref:System.Web.UI.WebControls.DropDownList> kontrolkę zawierającą trzy wartości. Parametr jest dołączany <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> do kolekcji z ustawioną nazwą, `Category,` która pasuje do jednej z właściwości obiektu danych. Właściwość jest ustawiona na identyfikator <xref:System.Web.UI.WebControls.DropDownList> kontrolki. <xref:System.Web.UI.WebControls.ControlParameter.ControlID%2A> Formant automatycznie tworzy właściwość w celu filtrowania rekordów na podstawie wartości wybieranej przez użytkownika z <xref:System.Web.UI.WebControls.DropDownList> kontrolki. <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> <xref:System.Web.UI.WebControls.LinqDataSource> Zapytanie zwraca rekordy, których `Category` Właściwość pasuje do wartości, która została wybrana przez użytkownika <xref:System.Web.UI.WebControls.DropDownList> z kontrolki.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default7.aspx#7)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default7.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoPage">
      <MemberSignature Language="C#" Value="public bool AutoPage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.AutoPage" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoPage As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoPage { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoPage : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.AutoPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> kontrolka obsługuje nawigowanie przez sekcje danych w czasie wykonywania.</summary>
        <value><see langword="true" />Jeśli użytkownik może przechodzić przez dane, w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw właściwość na `true` , aby włączyć stronicowanie w formancie.<xref:System.Web.UI.WebControls.LinqDataSource> <xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A> Aby umożliwić użytkownikowi dostęp do danych, Połącz formant powiązany z danymi, który udostępnia interfejs do stronicowania <xref:System.Web.UI.WebControls.LinqDataSource> w formancie. Gdy właściwość jest ustawiona na `true`, <xref:System.Web.UI.WebControls.LinqDataSource> formant pobiera tylko wystarczającą liczbę rekordów dla jednej strony w formancie powiązanym z danymi. <xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A> Używa <xref:System.Linq.Enumerable.Skip%2A> metod i <xref:System.Linq.Enumerable.Take%2A> do pobierania rekordów dla bieżącej strony.  
  
   
  
## Examples  
 Poniższy <xref:System.Web.UI.WebControls.LinqDataSource> przykład pokazuje kontrolkę `true` <xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A> z ustawioną <xref:System.Web.UI.WebControls.GridView> właściwością <xref:System.Web.UI.WebControls.LinqDataSource> i formantem, który jest powiązany z kontrolką. Właściwość kontrolki jest ustawiona na `true` , aby zapewnić interfejs, który umożliwia użytkownikom przechodzenie przez dane. <xref:System.Web.UI.WebControls.GridView> <xref:System.Web.UI.WebControls.GridView.AllowPaging%2A>  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSort">
      <MemberSignature Language="C#" Value="public bool AutoSort { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSort" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.AutoSort" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoSort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoSort { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoSort : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.AutoSort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> kontrolka obsługuje sortowanie danych w czasie wykonywania.</summary>
        <value><see langword="true" />Jeśli użytkownik może sortować dane; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource> Kontrolka obsługuje dwa podejścia do sortowania danych. Możesz użyć <xref:System.Web.UI.WebControls.LinqDataSource.AutoSort%2A> właściwości, aby włączyć sortowanie w czasie wykonywania, lub <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> ustawić właściwość w celu zdefiniowania sortowania w czasie projektowania.  
  
 Ustaw właściwość na `true` , aby włączyć sortowanie w formancie,któryjestopartynawyrażeniachsortowaniazformantupowiązanegozdanymi.<xref:System.Web.UI.WebControls.LinqDataSource> <xref:System.Web.UI.WebControls.LinqDataSource.AutoSort%2A> Formant powiązany z danymi udostępnia interfejs umożliwiający użytkownikowi wybranie w czasie wykonywania, którego właściwość ma być używana do sortowania.  
  
 Można programowo ustawić kolejność, w której dane są zwracane przez ustawienie <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> właściwości na właściwość lub właściwości używane do sortowania. Gdy właściwość jest ustawiona na właściwość, <xref:System.Web.UI.WebControls.LinqDataSource.AutoSort%2A> a właściwość jest `true`, wyrażenie sortowania z <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> formantu powiązanego z danymi jest stosowane po wyrażeniu we właściwości. <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> W związku z tym określa ostateczne sortowanie danych.  
  
   
  
## Examples  
 Poniższy <xref:System.Web.UI.WebControls.LinqDataSource> przykład pokazuje kontrolkę `true` <xref:System.Web.UI.WebControls.LinqDataSource.AutoSort%2A> z ustawioną <xref:System.Web.UI.WebControls.GridView> właściwością <xref:System.Web.UI.WebControls.LinqDataSource> i formantem, który jest powiązany z kontrolką. Właściwość kontrolki jest ustawiona na `true` , aby zapewnić interfejs, który umożliwia użytkownikom sortowanie danych. <xref:System.Web.UI.WebControls.GridView> <xref:System.Web.UI.WebControls.GridView.AllowSorting%2A>  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextCreated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; ContextCreated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; ContextCreated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.ContextCreated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextCreated As EventHandler(Of LinqDataSourceStatusEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceStatusEventArgs ^&gt; ^ ContextCreated;" />
      <MemberSignature Language="F#" Value="member this.ContextCreated : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " Usage="member this.ContextCreated : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po utworzeniu wystąpienia obiektu typu kontekstu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsłuż <xref:System.Web.UI.WebControls.LinqDataSource.ContextCreated> zdarzenie, aby przeanalizować obiekt typu kontekstu lub przejrzeć wyjątki, które są wywoływane podczas tworzenia obiektu. Obiekt typu kontekstu jest pobierany z <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Result%2A> właściwości <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs> obiektu, który jest skojarzony z tym zdarzeniem. Zostanie pobrany wyjątek, który został wywołany podczas operacji na danych z <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A> właściwości.  
  
 Obiekt typu kontekstu jest tworzony podczas operacji SELECT, Update, INSERT i DELETE i jest ponownie używany w ramach żądania.  
  
 Istnieje jeden raz, gdy zdarzenie nie zostanie zgłoszone. Jest to możliwe, gdy programowo ustawisz <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Result%2A> właściwość na obiekt <xref:System.Web.UI.WebControls.LinqDataSource.Selecting> w trakcie zdarzenia. Dodatkowym warunkiem jest to, że oryginalne wartości nie muszą być przechowywane w stanie widoku lub obiekt we <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Result%2A> właściwości <xref:System.Data.Linq.ITable> implementuje interfejs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextCreating">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceContextEventArgs&gt; ContextCreating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceContextEventArgs&gt; ContextCreating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.ContextCreating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextCreating As EventHandler(Of LinqDataSourceContextEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceContextEventArgs ^&gt; ^ ContextCreating;" />
      <MemberSignature Language="F#" Value="member this.ContextCreating : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceContextEventArgs&gt; " Usage="member this.ContextCreating : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceContextEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceContextEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje przed utworzeniem wystąpienia obiektu typu kontekstu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Web.UI.WebControls.LinqDataSource> formant tworzy wystąpienie typu, który jest określony <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A> we właściwości. <xref:System.Web.UI.WebControls.LinqDataSource> Kontrolka wywołuje bezparametryczny Konstruktor obiektu kontekstu danych, aby utworzyć wystąpienie obiektu. Istnieje możliwość, że należy użyć konstruktora bez parametrów lub trzeba utworzyć obiekt, który różni się od elementu określonego we <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A> właściwości. W takim przypadku należy obsłużyć <xref:System.Web.UI.WebControls.LinqDataSource.ContextCreating> zdarzenie i ręcznie utworzyć obiekt kontekstu danych.  
  
 Obiekt typu kontekstu jest tworzony podczas operacji SELECT, Update, INSERT i DELETE.  
  
 Istnieje jeden raz, gdy zdarzenie nie zostanie zgłoszone. Jest to możliwe, gdy programowo ustawisz <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Result%2A> właściwość na obiekt w programie obsługi zdarzeń <xref:System.Web.UI.WebControls.LinqDataSource.Selecting> dla zdarzenia. Dodatkowym warunkiem jest to, że oryginalne wartości nie muszą być przechowywane w stanie widoku lub obiekt we <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Result%2A> właściwości <xref:System.Data.Linq.ITable> implementuje interfejs.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć obiekt kontekstu danych przy użyciu konstruktora bez parametrów podczas <xref:System.Web.UI.WebControls.LinqDataSource.ContextCreating> zdarzenia. Kod przypisuje obiekt do <xref:System.Web.UI.WebControls.LinqDataSourceContextEventArgs.ObjectInstance%2A> właściwości.  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.ContextCreating#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.ContextCreating/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.ContextCreating#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.ContextCreating/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextDisposing">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDisposeEventArgs&gt; ContextDisposing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceDisposeEventArgs&gt; ContextDisposing" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.ContextDisposing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextDisposing As EventHandler(Of LinqDataSourceDisposeEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceDisposeEventArgs ^&gt; ^ ContextDisposing;" />
      <MemberSignature Language="F#" Value="member this.ContextDisposing : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDisposeEventArgs&gt; " Usage="member this.ContextDisposing : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDisposeEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDisposeEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje przed usunięciem obiektu typu kontekstu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz obsłużyć <xref:System.Web.UI.WebControls.LinqDataSource.ContextDisposing> zdarzenie, aby usunąć obiekt ręcznie, lub wykonać czyszczenie, które jest specyficzne dla obiektu, zanim obiekt zostanie zniszczony.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextTypeName">
      <MemberSignature Language="C#" Value="public override string ContextTypeName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContextTypeName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.ContextTypeName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContextTypeName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContextTypeName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextTypeName : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.ContextTypeName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę typu, który zawiera właściwość, której wartość zawiera dane, które mają zostać pobrane.</summary>
        <value>Nazwa klasy, z której mają zostać pobrane dane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku używania <xref:System.Web.UI.WebControls.LinqDataSource> kontrolki do pobierania danych z kolekcji danych znajdującej się w pamięci lub w bazie danych należy określić dwie właściwości. Pierwszy jest klasą kontekstu danych, która reprezentuje źródło danych. Druga jest właściwością w klasie kontekstu danych, która zawiera dane. Należy ustawić <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A> właściwość na nazwę klasy kontekstu danych i <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> ustawić właściwość na kolekcję danych, która zawiera dane.  
  
 Na przykład podczas pobierania danych z bazy danych należy ustawić <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A> właściwość na nazwę klasy, która reprezentuje bazę danych. Ustaw <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> również właściwość na właściwość, która reprezentuje tabelę w bazie danych. Aby wygenerować klasy z bazy danych, należy użyć [!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)] narzędzia lub SQLMetal. exe do automatycznego wygenerowania tych klas.  
  
 Podczas pobierania danych z kolekcji danych znajdującej się w pamięci, takiej jak tablica, należy ustawić <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A> właściwość na nazwę klasy, która zawiera właściwość Array. Następnie ustaw <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> właściwość na właściwość, która pobiera tablicę.  
  
 Aby włączyć automatyczne aktualizowanie, wstawianie lub usuwanie operacji za pośrednictwem <xref:System.Web.UI.WebControls.LinqDataSource> kontrolki, Klasa przypisana <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A> do właściwości musi pochodzić od <xref:System.Data.Linq.DataContext>. Ponadto Właściwość przypisana do <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> właściwości musi pochodzić od. <xref:System.Data.Linq.Table%601> Jeśli nie musisz włączać operacji automatycznego aktualizowania, wstawiania lub usuwania, możesz przypisać do <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A> właściwości nazwę dowolnego typu klasy.  
  
 Aby uzyskać informacje o sposobach wybierania danych z wystąpienia klasy, zobacz <xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs.Result%2A> właściwość.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A> jak ustawić właściwość na klasę, która zawiera tablicę ciągów. Pokazano również, jak ustawić właściwość na klasę (wygenerowaną przez [!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)]), która reprezentuje bazę danych.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/cs/Default.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/vb/Default.aspx#2)]  
  
 Klasa o nazwie `ExampleDataContext` , która reprezentuje tabelę bazy danych, nie jest pokazana w tym przykładzie. Aby ten przykład działał, należy utworzyć tę klasę przez dodanie klasy LINQ to SQL o nazwie example. dbml i przeciąganie tabeli o nazwie Movie na [!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)]. Klasa o nazwie `ExampleDataContext` z właściwością o `Movies` nazwie została wygenerowana.  
  
 W poniższym przykładzie pokazano klasę o nazwie `MovieLibrary` , do której odwołuje <xref:System.Web.UI.WebControls.LinqDataSource> się kontrolka.  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/cs/App_Code/MovieLibrary.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/vb/App_Code/MovieLibrary.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655">LINQ do SQL</related>
      </Docs>
    </Member>
    <Member MemberName="CreateQueryableView">
      <MemberSignature Language="C#" Value="protected override System.Web.UI.WebControls.QueryableDataSourceView CreateQueryableView ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.WebControls.QueryableDataSourceView CreateQueryableView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.CreateQueryableView" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateQueryableView () As QueryableDataSourceView" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Web::UI::WebControls::QueryableDataSourceView ^ CreateQueryableView();" />
      <MemberSignature Language="F#" Value="override this.CreateQueryableView : unit -&gt; System.Web.UI.WebControls.QueryableDataSourceView" Usage="linqDataSource.CreateQueryableView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.QueryableDataSourceView</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca widok queryable.</summary>
        <returns>Widok queryable.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateView">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.LinqDataSourceView CreateView ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.LinqDataSourceView CreateView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.CreateView" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateView () As LinqDataSourceView" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::LinqDataSourceView ^ CreateView();" />
      <MemberSignature Language="F#" Value="abstract member CreateView : unit -&gt; System.Web.UI.WebControls.LinqDataSourceView&#xA;override this.CreateView : unit -&gt; System.Web.UI.WebControls.LinqDataSourceView" Usage="linqDataSource.CreateView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.LinqDataSourceView</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nowe wystąpienie <see cref="T:System.Web.UI.WebControls.LinqDataSourceView" /> klasy skojarzonej z tym formantem.</summary>
        <returns>Obiekt, który działa jako interfejs dla formantów powiązanych z danymi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zapewnić widok niestandardowy, można zastąpić tę metodę w klasie pochodnej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public int Delete (System.Collections.IDictionary keys, System.Collections.IDictionary oldValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Delete(class System.Collections.IDictionary keys, class System.Collections.IDictionary oldValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.Delete(System.Collections.IDictionary,System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function Delete (keys As IDictionary, oldValues As IDictionary) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Delete(System::Collections::IDictionary ^ keys, System::Collections::IDictionary ^ oldValues);" />
      <MemberSignature Language="F#" Value="member this.Delete : System.Collections.IDictionary * System.Collections.IDictionary -&gt; int" Usage="linqDataSource.Delete (keys, oldValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.IDictionary" />
        <Parameter Name="oldValues" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="keys">Wartości klucza wiersza dla rekordów do usunięcia.</param>
        <param name="oldValues">Wartości wierszy, które są oceniane do wykrywania konfliktów danych.</param>
        <summary>Wykonuje operację usuwania.</summary>
        <returns>Liczba rekordów, których dotyczy operacja usuwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj nie trzeba wywoływać <xref:System.Web.UI.WebControls.LinqDataSource.Delete%2A> metody z kodu. Gdy używasz <xref:System.Web.UI.WebControls.LinqDataSource> kontrolki z kontrolką powiązaną z danymi, formant powiązany z danymi automatycznie wywoła metodę, <xref:System.Web.UI.WebControls.LinqDataSource.Delete%2A> gdy użytkownik podejmie akcję, aby usunąć rekord. Metodę należy jawnie wywołać <xref:System.Web.UI.WebControls.LinqDataSource.Delete%2A> , gdy chcesz utworzyć własny proces usuwania danych. Można na przykład wywołać <xref:System.Web.UI.WebControls.LinqDataSource.Delete%2A> metodę, gdy chcesz usunąć rekord na podstawie zdarzenia poza formantem związanym z danymi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deleted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Deleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Deleted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Deleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleted As EventHandler(Of LinqDataSourceStatusEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceStatusEventArgs ^&gt; ^ Deleted;" />
      <MemberSignature Language="F#" Value="member this.Deleted : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " Usage="member this.Deleted : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zakończeniu operacji usuwania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsłuż <xref:System.Web.UI.WebControls.LinqDataSource.Deleted> zdarzenie, aby przechwytywać wyjątki z operacji usuwania, lub aby poznać parametry wyjściowe po zakończeniu operacji. Parametry wyjściowe można pobrać z <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs> obiektu, który jest przesyłany do programów obsługi zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection DeleteParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection DeleteParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.DeleteParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeleteParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ DeleteParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeleteParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.DeleteParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ta właściwość nie jest używana przez <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> klasę.</summary>
        <value>Kolekcja parametrów.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Deleting">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs&gt; Deleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs&gt; Deleting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Deleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleting As EventHandler(Of LinqDataSourceDeleteEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceDeleteEventArgs ^&gt; ^ Deleting;" />
      <MemberSignature Language="F#" Value="member this.Deleting : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs&gt; " Usage="member this.Deleting : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje przed operacją usuwania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsłuż <xref:System.Web.UI.WebControls.LinqDataSource.Deleting> zdarzenie, aby sprawdzić poprawność obiektu do usunięcia, aby sprawdzić błędy walidacji danych z klasy danych, zmienić wartość przed operacją usuwania lub anulować operację usuwania. Kontrolka przekazuje obiekt do obsługi <xref:System.Web.UI.WebControls.LinqDataSource.Deleting> zdarzeń dla zdarzenia. <xref:System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs> <xref:System.Web.UI.WebControls.LinqDataSource> <xref:System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs> Obiekt zawiera dane, które zostaną usunięte i umożliwi anulowanie operacji usuwania. Jeśli Klasa danych zgłasza <xref:System.Web.UI.WebControls.LinqDataSourceValidationException> wyjątek <xref:System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs> , obiekt <xref:System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs.Exception%2A> zawiera ten wyjątek we właściwości.  
  
 Jeśli wyjątek jest zgłaszany w procedurze obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Deleting> zdarzenia, należy obsłużyć wyjątek w tym obsłudze zdarzeń. Wyjątek nie zostanie przesłany do procedury obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Deleted> zdarzenia ( <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A> przez właściwość <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs> obiektu). Właściwość zawiera tylko wyjątki, które są zgłaszane <xref:System.Web.UI.WebControls.LinqDataSource.Deleting> po zdarzeniu. <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>  
  
   
  
## Examples  
 Poniższy przykład pokazuje procedurę obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Deleting> zdarzenia. Kod anuluje operację usuwania na podstawie właściwości we <xref:System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs.OriginalObject%2A> właściwości i wartości ze strony sieci Web. W przykładzie, gdy `OnSale` właściwość jest ustawiona na `true`, użytkownik musi wybrać <xref:System.Web.UI.WebControls.CheckBox> kontrolkę, aby potwierdzić, że rekord powinien zostać usunięty.  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.Deleting#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Deleting/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.Deleting#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Deleting/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableDelete">
      <MemberSignature Language="C#" Value="public bool EnableDelete { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableDelete" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.EnableDelete" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableDelete As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableDelete { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableDelete : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.EnableDelete" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.EnableDelete</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy rekordy danych mogą być usuwane przez <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> formant.</summary>
        <value><see langword="true" />Jeśli automatyczne operacje usuwania są włączone; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw właściwość na `true` , jeśli chcesz umożliwić użytkownikom usuwanie rekordu danych za pomocą <xref:System.Web.UI.WebControls.LinqDataSource> kontrolki. <xref:System.Web.UI.WebControls.LinqDataSource.EnableDelete%2A> Gdy <xref:System.Web.UI.WebControls.LinqDataSource.EnableDelete%2A> tak `true`jest ,<xref:System.Web.UI.WebControls.LinqDataSource> formant używa LINQ to SQL, aby automatycznie utworzyć polecenie w celu usunięcia danych. Musisz dołączyć interfejs, który umożliwia użytkownikom wybranie rekordu do usunięcia, takiego jak <xref:System.Web.UI.WebControls.DetailsView> kontrolka.  
  
 Formant nie obsługuje operacji automatycznego usuwania, <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> gdy właściwość lub <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwość jest ustawiona. <xref:System.Web.UI.WebControls.LinqDataSource> W takim przypadku <xref:System.Web.UI.WebControls.LinqDataSource> formant zgłasza wyjątek w przypadku próby usunięcia operacji usuwania.  
  
   
  
## Examples  
 Poniższy przykład pokazuje <xref:System.Web.UI.WebControls.LinqDataSource> kontrolkę, która ma <xref:System.Web.UI.WebControls.LinqDataSource.EnableDelete%2A> ustawioną `true`wartość. <xref:System.Web.UI.WebControls.DetailsView> Kontrolka wyświetla dane i tworzy przycisk umożliwiający użytkownikom usuwanie rekordu danych.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default2.aspx#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655">LINQ do SQL</related>
      </Docs>
    </Member>
    <Member MemberName="EnableInsert">
      <MemberSignature Language="C#" Value="public bool EnableInsert { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableInsert" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.EnableInsert" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableInsert As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableInsert { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableInsert : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.EnableInsert" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.EnableInsert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy rekordy danych mogą być wstawiane przez <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> formant.</summary>
        <value><see langword="true" />Jeśli automatyczne operacje wstawiania są włączone; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw właściwość na `true` , jeśli chcesz, aby użytkownicy mogli wstawiać <xref:System.Web.UI.WebControls.LinqDataSource> nowy rekord danych za pomocą kontrolki. <xref:System.Web.UI.WebControls.LinqDataSource.EnableInsert%2A> Gdy <xref:System.Web.UI.WebControls.LinqDataSource.EnableInsert%2A> tak `true`jest ,<xref:System.Web.UI.WebControls.LinqDataSource> formant używa LINQ to SQL, aby automatycznie utworzyć polecenie wstawiania danych. Musisz dołączyć interfejs, który umożliwia użytkownikom wstawianie nowego rekordu, takiego jak <xref:System.Web.UI.WebControls.DetailsView> kontrolka.  
  
 Formant nie obsługuje operacji automatycznego wstawiania, <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> gdy właściwość lub <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwość jest ustawiona. <xref:System.Web.UI.WebControls.LinqDataSource> W takim przypadku <xref:System.Web.UI.WebControls.LinqDataSource> formant zgłasza wyjątek, jeśli operacja wstawiania zostanie podjęta.  
  
   
  
## Examples  
 Poniższy przykład pokazuje <xref:System.Web.UI.WebControls.LinqDataSource> kontrolkę, która ma <xref:System.Web.UI.WebControls.LinqDataSource.EnableInsert%2A> ustawioną `true`wartość. <xref:System.Web.UI.WebControls.DetailsView> Kontrolka wyświetla dane i wyświetla przycisk służący do przełączania kontrolki w tryb wstawiania, w którym użytkownicy mogą tworzyć i zapisywać nowe rekordy.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default2.aspx#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655">LINQ do SQL</related>
      </Docs>
    </Member>
    <Member MemberName="EnableObjectTracking">
      <MemberSignature Language="C#" Value="public bool EnableObjectTracking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableObjectTracking" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.EnableObjectTracking" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableObjectTracking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableObjectTracking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableObjectTracking : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.EnableObjectTracking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy zmiany w obiekcie kontekstu danych są śledzone.</summary>
        <value><see langword="true" />Jeśli obiekt kontekstu danych jest śledzony pod kątem zmian; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource.EnableObjectTracking%2A> Właściwość jest używana tylko podczas wybierania danych z obiektu kontekstu danych LINQ to SQL.  
  
 W przypadku korzystania z danych tylko do odczytu, ustawienie <xref:System.Web.UI.WebControls.LinqDataSource.EnableObjectTracking%2A> właściwości w celu `false` zwiększenia wydajności, ponieważ dane nie są buforowane, aby określić, czy uległy zmianie. Jednak powoduje także wyłączenie odroczonego wykonywania zapytań. Ta właściwość musi być ustawiona na `true` , jeśli chcesz użyć odroczonego wykonywania zapytań.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" />
      </Docs>
    </Member>
    <Member MemberName="EnableUpdate">
      <MemberSignature Language="C#" Value="public bool EnableUpdate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableUpdate" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.EnableUpdate" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableUpdate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableUpdate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableUpdate : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.EnableUpdate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.EnableUpdate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy rekordy danych mogą być aktualizowane przez <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> formant.</summary>
        <value><see langword="true" />Jeśli automatyczne operacje aktualizacji są włączone; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw właściwość na `true` , jeśli chcesz, aby użytkownicy mogli aktualizować rekord <xref:System.Web.UI.WebControls.LinqDataSource> danych przy użyciu formantu. <xref:System.Web.UI.WebControls.LinqDataSource.EnableUpdate%2A> Gdy <xref:System.Web.UI.WebControls.LinqDataSource.EnableUpdate%2A> tak `true`jest ,<xref:System.Web.UI.WebControls.LinqDataSource> formant używa LINQ to SQL, aby automatycznie utworzyć polecenie w celu zaktualizowania danych. Musisz dołączyć interfejs, który umożliwia użytkownikom aktualizowanie rekordu, takiego jak <xref:System.Web.UI.WebControls.DetailsView> kontrolka.  
  
 Formant nie obsługuje operacji automatycznej aktualizacji, <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> gdy właściwość lub <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwość jest ustawiona. <xref:System.Web.UI.WebControls.LinqDataSource> W takim przypadku <xref:System.Web.UI.WebControls.LinqDataSource> formant zgłasza wyjątek, Jeśli podjęto próbę wykonania operacji aktualizacji.  
  
   
  
## Examples  
 Poniższy przykład pokazuje <xref:System.Web.UI.WebControls.LinqDataSource> kontrolkę, która ma <xref:System.Web.UI.WebControls.LinqDataSource.EnableUpdate%2A> ustawioną `true`wartość. <xref:System.Web.UI.WebControls.DetailsView> Kontrolka wyświetla dane i tworzy przycisk umożliwiający użytkownikom aktualizację rekordu danych.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default2.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetView">
      <MemberSignature Language="C#" Value="protected override System.Web.UI.DataSourceView GetView (string viewName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.DataSourceView GetView(string viewName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.GetView(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetView (viewName As String) As DataSourceView" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Web::UI::DataSourceView ^ GetView(System::String ^ viewName);" />
      <MemberSignature Language="F#" Value="override this.GetView : string -&gt; System.Web.UI.DataSourceView" Usage="linqDataSource.GetView viewName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IDataSource.GetView(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.DataSourceView</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="viewName" Type="System.String" Index="0" FrameworkAlternate="netframework-3.5" />
      </Parameters>
      <Docs>
        <param name="viewName">Nazwa widoku do pobrania, który musi mieć wartość "DefaultView".</param>
        <summary>Zwraca widok źródła danych, który jest skojarzony z <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> obiektem.</summary>
        <returns>Widok źródła danych, który jest skojarzony z <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> obiektem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<xref:System.Web.UI.WebControls.LinqDataSource> Kontrolka obsługuje tylko jeden widok źródła danych. <xref:System.Web.UI.WebControls.LinqDataSourceView> Obiekt ma domyślną nazwę "DefaultView". <xref:System.Web.UI.WebControls.LinqDataSourceView> Obiekt definiuje możliwości kontroli źródła danych, pobiera dane z podstawowej bazy danych i wykonuje operacje, takie jak sortowanie, wstawianie, usuwanie i aktualizowanie.

]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><p>widokname ma wartość null (Nothing w Visual Basic) lub coś innego niż "DefaultView".</p></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb547113(v=vs.100)">Formant LinqDataSource serwera sieci Web — Omówienie</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178359(v=vs.110)">{1&amp;gt;Omówienie dostępu do danych w programie ASP.NET&amp;lt;1}</related>
      </Docs>
    </Member>
    <Member MemberName="GetViewNames">
      <MemberSignature Language="C#" Value="protected override System.Collections.ICollection GetViewNames ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Collections.ICollection GetViewNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.GetViewNames" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetViewNames () As ICollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Collections::ICollection ^ GetViewNames();" />
      <MemberSignature Language="F#" Value="override this.GetViewNames : unit -&gt; System.Collections.ICollection" Usage="linqDataSource.GetViewNames " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IDataSource.GetViewNames</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kolekcję nazw reprezentującą listę obiektów widoku, które są skojarzone z <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> kontrolką.</summary>
        <returns>Kolekcja z jednym elementem, który zawiera nazwę "DefaultView".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Kontrolka obsługuje tylko jeden widok na danych źródłowych o nazwie `DefaultView`. <xref:System.Web.UI.WebControls.LinqDataSource> W `GetViewNames` związku z tym metoda zwraca kolekcję mającą tylko jeden element, który zawiera nazwę tego widoku.

]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb547113(v=vs.100)">Formant LinqDataSource serwera sieci Web — Omówienie</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178359(v=vs.110)">{1&amp;gt;Omówienie dostępu do danych w programie ASP.NET&amp;lt;1}</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy">
      <MemberSignature Language="C#" Value="public string GroupBy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string GroupBy" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.GroupBy" />
      <MemberSignature Language="VB.NET" Value="Public Property GroupBy As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ GroupBy { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.GroupBy : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.GroupBy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, które właściwości są używane do grupowania pobranych danych.</summary>
        <value>Ciąg, który jest używany do tworzenia klauzuli Group by.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwości, aby określić, które właściwości są używane do konsolidowania rekordów danych, które mają takie same wartości. Jeśli na przykład ustawisz <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwość na `Name`, wszystkie rekordy w zapytaniu, które mają taką samą `Name` wartość właściwości, są zwracane jako pojedynczy rekord skonsolidowany.  
  
 Do <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwości można przypisać więcej niż jedną właściwość, umieszczając wszystkie właściwości `new` w funkcji i oddzielając każdą właściwość za pomocą przecinka. Na przykład, aby pogrupować według `Name` właściwości, `Category`a następnie ustawić <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwość na `new(Name, Category)`.  
  
 Wartości właściwości, które są używane do grupowania są zwracane przez wygenerowaną właściwość o nazwie `Key`. Aby pobrać zgrupowane `Key` wartości, należy <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> uwzględnić Właściwość we właściwości. Możesz ustawić `Key` właściwość na alias przy `As` użyciu słowa kluczowego, ale nie jest wymagane używanie aliasu. Na przykład możesz ustawić <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwość na właściwość o nazwie. `Category` Można pobrać skonsolidowane wartości z `Category` właściwości przez <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> ustawienie właściwości na `new(Key As ProductCategory)`.  
  
 Możesz uzyskać dostęp do poszczególnych rekordów w grupowaniu, dołączając `It` Właściwość <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> we właściwości. `It` Właściwość zawiera kolekcję rekordów, które współdzielą wartość we właściwości zgrupowane. Aby pobrać pojedyncze rekordy, `It` można wykonać iterację we właściwości.  
  
 <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> Właściwość jest często używana z metodami agregacji. Można użyć następujących metod agregowania:  
  
-   `Count()`  
  
-   `Average(` *column* `)`  
  
-   `Sum(` *column* `)`  
  
-   `Max(` *column* `)`  
  
-   `Min(` *column* `)`  
  
-   `Where(`*warunek*`)`  
  
-   `Any()`  
  
-   `All(`*warunek*`)`  
  
 Aby uzyskać więcej informacji, [zobacz NIB: Formant serwera sieci Web programu](https://msdn.microsoft.com/library/104cfc3f-7385-47d3-8a51-830dfa791136) LinqDataSource [— omówienie i instrukcje: Grupowanie i agregowanie danych przy użyciu kontrolki](https://msdn.microsoft.com/library/b922cf69-251f-4158-b405-ea960993a1af)LinqDataSource.  
  
   
  
## Examples  
 Poniższy przykład pokazuje <xref:System.Web.UI.WebControls.LinqDataSource> kontrolkę grupującą dane zwrócone przez właściwość o nazwie `Category`. Zwraca wartości udostępnione i oblicza średnią cenę pogrupowanych rekordów.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default3.aspx#3)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default3.aspx#3)]  
  
 Poniższy przykład pokazuje <xref:System.Web.UI.WebControls.LinqDataSource> kontrolkę, która jest skonfigurowana do grupowania według dwóch kolumn. Właściwość odwołuje się do obiektu, który ma dwie `ProductCategory` właściwości, i `Color`. `Key` Zmieniono nazwę `It` `Products`obiektu reprezentowanego przez. Obiekt o `Products` zmienionej nazwie zawiera kolekcję pojedynczych rekordów w grupowaniu, a każde wystąpienie zawiera wszystkie kolumny w tabeli Products.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.GroupBy#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.GroupBy#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/vb/Default.aspx#1)]  
  
 Poniższy przykład przedstawia dwie <xref:System.Web.UI.WebControls.ListView> kontrolki do wyświetlania danych <xref:System.Web.UI.WebControls.LinqDataSource> z kontrolki w poprzednim przykładzie. W <xref:System.Web.UI.WebControls.ListView> jednym formancie są wyświetlane zgrupowane dane, a <xref:System.Web.UI.WebControls.ListView> w drugiej kontrolce są wyświetlane poszczególne nazwy produktów należących do tej grupy. <xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A> Właściwość zagnieżdżonej kontrolki powiązanej z danymi jest ustawiona `Products`na, która `It` jest aliasem obiektu.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.GroupBy#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/cs/Default.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.GroupBy#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/vb/Default.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupByParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection GroupByParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection GroupByParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.GroupByParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GroupByParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ GroupByParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GroupByParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.GroupByParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję parametrów, które są używane do tworzenia klauzuli Group by.</summary>
        <value>Parametry, które są używane do tworzenia klauzuli Group by.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontrolka używa parametrów <xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A> w kolekcji, aby utworzyć klauzulę Group by w czasie wykonywania. <xref:System.Web.UI.WebControls.LinqDataSource> Zazwyczaj nie będziesz używać <xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A> kolekcji do grupowania danych. Zamiast tego można użyć <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwości. <xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A> Kolekcja jest używana tylko wtedy, gdy wartość w klauzuli Group by musi być ustawiona w czasie wykonywania, a ta wartość nie jest nazwą właściwości. Na przykład użyj <xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A> kolekcji, aby grupować dane na podstawie tego, `LastName` czy właściwość w rekordach danych jest równa wartości dostarczonej przez użytkownika.  
  
 Jeśli chcesz grupować dane według właściwości, a ta właściwość nie musi być ustawiona w czasie wykonywania, możesz zdefiniować Właściwość grupowania we <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwości. Na przykład, aby zwrócić wartości z tabeli bazy danych pogrupowane `LastName`według, <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> ustaw na "LastName" bez żadnych parametrów. Jeśli chcesz dynamicznie grupować dane według właściwości, Utwórz procedurę obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Selecting> zdarzenia i <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> Dostosuj Właściwość zgodnie z wymaganiami.  
  
 Nie można przypisać nazwy właściwości jako wartości parametru w <xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A> kolekcji. Dodaj parametry do <xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A> kolekcji, jeśli chcesz dodać warunek <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> do właściwości, która musi być ustawiona w czasie wykonywania.  
  
 Aby ustawić wartości w <xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A> kolekcji, należy przypisać nazwę do każdego parametru, a następnie dodać symbol zastępczy <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> we właściwości dla tego nazwanego parametru. W klauzuli Group by nie należy określać nazwy każdego parametru za pomocą znaku @.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public int Insert (System.Collections.IDictionary values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Insert(class System.Collections.IDictionary values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.Insert(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (values As IDictionary) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Insert(System::Collections::IDictionary ^ values);" />
      <MemberSignature Language="F#" Value="member this.Insert : System.Collections.IDictionary -&gt; int" Usage="linqDataSource.Insert values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="values">Wartości wierszy, które mają zostać wstawione do źródła danych.</param>
        <summary>Wykonuje operację wstawiania.</summary>
        <returns>Liczba wierszy, na które ma wpływ operacja wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj nie trzeba wywoływać <xref:System.Web.UI.WebControls.LinqDataSource.Insert%2A> metody z kodu. Formant powiązany z danymi automatycznie wywoła metodę, <xref:System.Web.UI.WebControls.LinqDataSource.Insert%2A> gdy użytkownik podejmie akcję, aby wstawić nowy rekord. Metodę należy jawnie wywołać <xref:System.Web.UI.WebControls.LinqDataSource.Insert%2A> , gdy chcesz utworzyć własny proces wstawiania danych.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak programowo wstawić nowy rekord w źródle danych po kliknięciu przycisku przez użytkownika. Kod przekazuje <xref:System.Collections.Specialized.ListDictionary> obiekt, który zawiera wartości domyślne <xref:System.Web.UI.WebControls.LinqDataSource.Insert%2A> do metody.  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.Insert#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Insert/cs/Default2.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Insert/vb/Default2.aspx.vb#1)]  
  
 W poniższym przykładzie pokazano znaczniki dla poprzedniego przykładu.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.Insert#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Insert/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.Insert#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Insert/vb/Default2.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Inserted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Inserted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Inserted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Inserted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Inserted As EventHandler(Of LinqDataSourceStatusEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceStatusEventArgs ^&gt; ^ Inserted;" />
      <MemberSignature Language="F#" Value="member this.Inserted : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " Usage="member this.Inserted : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zakończeniu operacji wstawiania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsłuż <xref:System.Web.UI.WebControls.LinqDataSource.Inserted> zdarzenie, aby przechwycić wszelkie wyjątki z operacji wstawiania lub przeanalizować wartości po zakończeniu operacji wstawiania. Możesz pobrać nowe wartości za pomocą <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs> obiektu, który jest przesyłany do programów obsługi zdarzeń. Na przykład można użyć <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs> obiektu do pobrania właściwości tożsamości wygenerowanej przez bazę danych dla nowego rekordu danych.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć procedurę obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Inserted> zdarzenia, które sprawdza obecność wyjątków i pobiera właściwość Identity dla nowego rekordu.  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSourceStatusEventArgs#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceStatusEventArgs/cs/Default.aspx#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSourceStatusEventArgs#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceStatusEventArgs/vb/Default.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Inserting">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceInsertEventArgs&gt; Inserting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceInsertEventArgs&gt; Inserting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Inserting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Inserting As EventHandler(Of LinqDataSourceInsertEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceInsertEventArgs ^&gt; ^ Inserting;" />
      <MemberSignature Language="F#" Value="member this.Inserting : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceInsertEventArgs&gt; " Usage="member this.Inserting : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceInsertEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceInsertEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje przed operacją INSERT.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsłuż <xref:System.Web.UI.WebControls.LinqDataSource.Inserting> zdarzenie, aby sprawdzić poprawność obiektu do wstawienia, aby sprawdzić błędy walidacji danych z klasy danych, zmienić wartość przed operacją INSERT lub aby anulować operację wstawiania. <xref:System.Web.UI.WebControls.LinqDataSourceInsertEventArgs> Obiekt przesłany do obsługi zdarzeń dla tego zdarzenia zawiera nowy obiekt do wstawienia w źródle danych.  
  
 Jeśli podczas operacji wstawiania wystąpi błąd walidacji, <xref:System.Web.UI.WebControls.LinqDataSourceInsertEventArgs> obiekt zawiera wyjątki walidacji, które są zgłaszane przez klasę danych. Błąd walidacji występuje, jeśli wartość, która ma zostać wstawiona, nie pasuje do typu właściwości w klasie danych lub jeśli nie przeszedł niestandardowego sprawdzania poprawności. W procedurze obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Inserting> zdarzenia można pobrać wyjątki walidacji i podjąć odpowiednie działania.  
  
 Jeśli wyjątek jest zgłaszany w procedurze obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Inserting> zdarzenia, należy obsłużyć wyjątek w tym obsłudze zdarzeń. Wyjątek nie zostanie przesłany do procedury obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Inserted> zdarzenia ( <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A> przez właściwość <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs> obiektu). Właściwość zawiera tylko wyjątki, które są zgłaszane <xref:System.Web.UI.WebControls.LinqDataSource.Inserting> po zdarzeniu. <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>  
  
   
  
## Examples  
 Poniższy przykład pokazuje procedurę obsługi <xref:System.Web.UI.WebControls.LinqDataSource.Inserting> zdarzeń, która modyfikuje dane przed operacją wstawiania. Obiekt z <xref:System.Web.UI.WebControls.LinqDataSourceInsertEventArgs.NewObject%2A> właściwości jest rzutowany na typ o nazwie `Product`. `DateModified` Właściwość`Product` obiektu jest ustawiona na bieżącą datę i godzinę.  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.Inserting#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Inserting/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.Inserting#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Inserting/vb/Default.aspx.vb#1)]  
  
 Poniższy przykład pokazuje program obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Inserting> zdarzenia, które pobiera wyjątki walidacji.  
  
```vb  
Protected Sub LinqDataSource_Inserting(ByVal sender As Object, _  
        ByVal e As LinqDataSourceInsertEventArgs)  
    If (e.Exception IsNot Nothing) Then  
        For Each innerException As KeyValuePair(Of String, Exception) _  
               In e.Exception.InnerExceptions  
            Label1.Text &= innerException.Key & ": " & _  
                innerException.Value.Message & "<br />"  
        Next  
        e.ExceptionHandled = True  
    End If  
End Sub  
```  
  
```csharp  
protected void LinqDataSource_Inserting(object sender,   
        LinqDataSourceInsertEventArgs e)  
{  
    if (e.Exception != null)  
    {  
        foreach (KeyValuePair<string, Exception> innerException in   
             e.Exception.InnerExceptions)  
        {  
        Label1.Text += innerException.Key + ": " +   
            innerException.Value.Message + "<br />";  
        }  
        e.ExceptionHandled = true;  
    }  
}  
```  
  
 Poprzedni przykład pobiera wyjątki walidacji. Wyjątek może zostać wygenerowany, jeśli wartość nie jest zgodna z typem właściwości. Może być również zgłaszane z dostosowanego sprawdzenia, takiego jak ten w poniższym przykładzie. Metoda sprawdza, czy liczba `Age` właściwości nie jest ujemna. `OnAgeChanging`  
  
```csharp  
partial void  OnAgeChanging(int? value)  
{  
    if (value < 0)  
    {  
        throw new Exception("Age cannot be a negative number.");  
    }  
}  
```  
  
```vb  
Private Sub OnAgeChanging(ByVal value As System.Nullable(Of Integer))  
    If (value < 0) Then  
        Throw New Exception("Age cannot be a negative number.")  
    End If  
End Sub  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection InsertParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection InsertParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.InsertParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InsertParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ InsertParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InsertParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.InsertParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję parametrów, które są używane podczas operacji wstawiania.</summary>
        <value>Parametry, które są używane podczas operacji wstawiania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj wartości, które są konieczne dla operacji wstawiania, są przenoszone do <xref:System.Web.UI.WebControls.LinqDataSource> kontrolki przez formant powiązany z danymi. Należy określić parametry INSERT, jeśli chcesz podać wartość domyślną, lub zdefiniować, czy przekonwertować puste wartości na `null`. Nie trzeba podawać parametru dla każdej wartości, która zostanie wstawiona, tylko dla wartości, które muszą być obsługiwane, gdy użytkownik nie poda wartości.  
  
 Wartości, które podano w <xref:System.Web.UI.WebControls.LinqDataSource.InsertParameters%2A> kolekcji, są używane tylko dla pól, które są zdefiniowane w źródle danych, ale nie są powiązane z formantem danych. Załóżmy na przykład, że tabela bazy danych ma kolumny o nazwie name, Address i KodPocztowy, ale <xref:System.Web.UI.WebControls.ListView> formant, który jest powiązany z tabelą, jest powiązany tylko z polami nazwa i adres. Wartości w <xref:System.Web.UI.WebControls.LinqDataSource.InsertParameters%2A> kolekcji będą używane tylko dla pola KodPocztowy. Nie będą one używane w polu Nazwa i adres. Jest to prawdziwe, nawet jeśli nie wprowadzono żadnej wartości dla tych pól. Jeśli formant powiązany z danymi automatycznie generuje pola dla wszystkich pól w źródle danych, nie będą używane żadne wartości z <xref:System.Web.UI.WebControls.LinqDataSource.InsertParameters%2A> kolekcji.  
  
   
  
## Examples  
 Poniższy przykład pokazuje <xref:System.Web.UI.WebControls.LinqDataSource> kontrolkę z parametrem, który zawiera wartość domyślną <xref:System.Web.UI.WebControls.LinqDataSource.InsertParameters%2A> w kolekcji. Jeśli użytkownik nie poda wartości `Category` właściwości, wartość domyślna podana przez parametr jest zapisywana w bazie danych.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#9](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default9.aspx#9)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#9](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default9.aspx#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadViewState">
      <MemberSignature Language="C#" Value="protected override void LoadViewState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void LoadViewState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.LoadViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub LoadViewState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void LoadViewState(System::Object ^ savedState);" />
      <MemberSignature Language="F#" Value="override this.LoadViewState : obj -&gt; unit" Usage="linqDataSource.LoadViewState savedState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" Index="0" FrameworkAlternate="netframework-3.5" />
      </Parameters>
      <Docs>
        <param name="savedState">Obiekt, który reprezentuje stan <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> formantu.</param>
        <summary>Ładuje stan wartości w <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> kontrolce, która musi być utrwalona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Metoda służy do ładowania poprzednio zapisanego stanu <xref:System.Web.UI.WebControls.LinqDataSource> widoku formantu. `LoadViewState`

]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb547113(v=vs.100)">Formant LinqDataSource serwera sieci Web — Omówienie</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178359(v=vs.110)">{1&amp;gt;Omówienie dostępu do danych w programie ASP.NET&amp;lt;1}</related>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnInit : EventArgs -&gt; unit" Usage="linqDataSource.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane dotyczące zdarzenia.</param>
        <summary><see cref="T:System.Web.UI.WebControls.LinqDataSource" /> Inicjuje obiekt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal override void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnUnload : EventArgs -&gt; unit" Usage="linqDataSource.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Obiekt, który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Web.UI.Control.Unload" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OrderBy">
      <MemberSignature Language="C#" Value="public string OrderBy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OrderBy" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.OrderBy" />
      <MemberSignature Language="VB.NET" Value="Public Property OrderBy As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OrderBy { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OrderBy : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.OrderBy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, które pola są używane do porządkowania pobranych danych.</summary>
        <value>Ciąg, który jest używany do tworzenia klauzuli Order by.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj właściwości, <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> aby określić, które właściwości zwracanych danych mają być używane do sortowania. Właściwość sortowania danych musi znajdować się w oryginalnym źródle danych, ale nie musi być uwzględniona we <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości. Można dodać spację i `Ascending` `Descending`, `ASC`,, lub `DESC` do właściwości w ciągu, <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> aby określić sposób zwrócenia uporządkowanych danych.  
  
 W <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> właściwości można podać więcej niż jedną właściwość, rozdzielając każdą właściwość za pomocą przecinka. Na przykład aby zamówić według właściwości o nazwie `LastName` i `FirstName`, ustaw <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> właściwość na "LastName, FirstName".  
  
> [!NOTE]
>  Gdy używasz <xref:System.Web.UI.WebControls.LinqDataSource> kontrolki z [!INCLUDE[ssEW](~/includes/ssew-md.md)] [!INCLUDE[ss2k](~/includes/ss2k-md.md)] lub, a <xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A> `true` Właściwość<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> jest ustawiona na, musisz podać wartość we właściwości. Domyślnie <xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A> właściwość jest `true`. W przypadku przypisywania wartości do <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości, należy również uwzględnić wszystkie kolumny tożsamości na liście właściwości, które są zwracane w zapytaniu.  
  
 Jeśli właściwość jest ustawiona na `true`, formant powiązany z danymi może przekazać wyrażenie sortowania do <xref:System.Web.UI.WebControls.LinqDataSource> kontrolki w czasie wykonywania. <xref:System.Web.UI.WebControls.LinqDataSource.AutoSort%2A> Kontrolka zastosuje wyrażenie sortowania z kontrolki powiązanej z danymi, po <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> zastosowaniu właściwości. <xref:System.Web.UI.WebControls.LinqDataSource> W związku z tym dane są zwracane zgodnie z wyrażeniem sortowania z formantu powiązanego z danymi.  
  
   
  
## Examples  
 Poniższy przykład zwraca dane w odwrotnej kolejności alfabetycznej na podstawie wartości we `Category` właściwości.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default4.aspx#4)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default4.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OrderByParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection OrderByParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection OrderByParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.OrderByParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OrderByParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ OrderByParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OrderByParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.OrderByParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję parametrów, które są używane do tworzenia klauzuli Order by.</summary>
        <value>Parametry, które są używane do tworzenia klauzuli Order by.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontrolka używa parametrów <xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A> w kolekcji, aby utworzyć klauzulę ORDER by w czasie wykonywania. <xref:System.Web.UI.WebControls.LinqDataSource> Zazwyczaj <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A> właściwość jest ustawiana na `true` wartość po dodaniu parametrów do <xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A> kolekcji. Gdy właściwość jest ustawiona na `true` <xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A> , każdy parametr w kolekcji zostanie dodany do klauzuli Order by w sekwencji, która jest określona w <xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A> kolekcji. <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A> Gdy właściwość ma `true`wartość, parametry nie muszą mieć nazwy, ponieważ są stosowane w sekwencji i nie są zgodne z symbolem zastępczym. <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A>  
  
 Jeśli nie musisz ustawiać wartości w czasie wykonywania w klauzuli Order by, nie musisz używać <xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A> kolekcji. Można zdefiniować pola, które mają być używane do porządkowania danych we <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> właściwości. Na przykład, aby zwrócić wartości z tabeli bazy danych uporządkowane `LastName`według, <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> ustaw na "LastName" bez żadnych parametrów.  
  
 Można ustawić parametry w <xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A> kolekcji i dopasować parametry do symboli zastępczych <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> we właściwości, ale takie podejście ma ograniczoną aplikację. W przypadku korzystania z tego podejścia parametry w <xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A> kolekcji nie mogą reprezentować nazwy kolumny. Można ustawić parametr na wartość, a następnie porównać tę wartość z wartościami we właściwości. Na przykład można zamówić dane na podstawie tego, czy wartości w właściwości są mniejsze niż wartość w czasie wykonywania reprezentowana przez parametr.  
  
   
  
## Examples  
 Poniższy przykład pokazuje <xref:System.Web.UI.WebControls.LinqDataSource> kontrolkę <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A> z właściwością ustawioną na `true`. Parametr jest dołączany do <xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A> kolekcji, która porządkuje dane na podstawie nazwy właściwości, którą użytkownik wybiera <xref:System.Web.UI.WebControls.DropDownList> z formantu.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#8](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default8.aspx#8)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#8](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default8.aspx#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OrderGroupsBy">
      <MemberSignature Language="C#" Value="public string OrderGroupsBy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OrderGroupsBy" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy" />
      <MemberSignature Language="VB.NET" Value="Public Property OrderGroupsBy As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OrderGroupsBy { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OrderGroupsBy : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia pola, które są używane do porządkowania pogrupowanych danych.</summary>
        <value>Ciąg, który jest używany do tworzenia klauzuli Order Groups by.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj właściwości, <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A> aby określić sposób sortowania grup danych. Na przykład można pogrupować według `CategoryID` właściwości, a następnie posortować każdą grupę identyfikatorów kategorii według średniej `Price` właściwości.  
  
 <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A> Właściwość można ustawić tylko wtedy, gdy zostały zgrupowane dane. Jeśli ustawisz <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A> Właściwość bez <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> ustawiania właściwości, <xref:System.Web.UI.WebControls.LinqDataSource> formant zgłosi wyjątek.  
  
 Właściwość, która jest używana do sortowania danych, musi być właściwością, która jest używana do grupowania danych lub wynik funkcji agregacji dla pogrupowanych danych. Aby określić sposób sortowania danych, można dodać spację i ciąg "Ascending", "ASC", "malejąco" lub "DESC" do nazwy właściwości w <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A> ciągu.  
  
 W <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A> właściwości można określić więcej niż jedną właściwość. Oddziel każdą właściwość za pomocą przecinka.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak grupować dane przy użyciu dwóch właściwości i jak sortować pogrupowane dane przy użyciu jednej z tych właściwości. Dane z tabeli o nazwie `Products` są grupowane przy użyciu właściwości o nazwie `CategoryID` i. `Discontinued` Pogrupowane dane są sortowane według `CategoryID` właściwości.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy/vb/Default.aspx#1)]  
  
 Poniższy przykład pokazuje, jak grupować dane przy użyciu właściwości i jak sortować ją na podstawie wyników funkcji agregacji. Dane z `Products` tabeli są grupowane przy `CategoryID` użyciu właściwości. Jest ono sortowane na podstawie średniej `UnitPrice` właściwości w każdej grupie.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy/vb/Default2.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OrderGroupsByParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection OrderGroupsByParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection OrderGroupsByParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OrderGroupsByParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ OrderGroupsByParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OrderGroupsByParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję parametrów, które są używane do tworzenia klauzuli Order Groups by.</summary>
        <value>Parametry, które są używane do tworzenia klauzuli Order Groups by.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontrolka używa parametrów <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters%2A> w kolekcji do tworzenia klauzuli Order Group by w czasie wykonywania. <xref:System.Web.UI.WebControls.LinqDataSource>  
  
 Wartości do <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters%2A> kolekcji należy dodawać tylko wtedy, gdy musisz ustawić wartości w czasie wykonywania w klauzuli Order Group by. Można zdefiniować pola, które są używane do porządkowania danych przy użyciu <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A> właściwości.  
  
 Można ustawić parametry w <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters%2A> kolekcji i dopasować parametry do symboli zastępczych <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A> we właściwości. Jednak podczas korzystania z tego podejścia parametry w <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters%2A> kolekcji nie mogą reprezentować nazwy kolumny; muszą reprezentować wartości. Można ustawić parametr na wartość, a następnie porównać tę wartość z właściwością. Na przykład można zamówić dane na podstawie tego, czy wartości w właściwości są mniejsze niż wartość w czasie wykonywania reprezentowana przez parametr.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveViewState">
      <MemberSignature Language="C#" Value="protected override object SaveViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance object SaveViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.SaveViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function SaveViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Object ^ SaveViewState();" />
      <MemberSignature Language="F#" Value="override this.SaveViewState : unit -&gt; obj" Usage="linqDataSource.SaveViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapisuje bieżący stan <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> widoku formantu.</summary>
        <returns>Obiekt, który zawiera zapisany stan <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> formantu.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb547113(v=vs.100)">Formant LinqDataSource serwera sieci Web — Omówienie</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178359(v=vs.110)">{1&amp;gt;Omówienie dostępu do danych w programie ASP.NET&amp;lt;1}</related>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public string Select { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Select" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.Select" />
      <MemberSignature Language="VB.NET" Value="Public Property Select As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Select { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Select : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.Select" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia właściwości oraz wartości obliczeniowe, które są uwzględnione w pobranych danych.</summary>
        <value>Ciąg, który jest używany do tworzenia klauzuli select.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwość nie zostanie ustawiona <xref:System.Web.UI.WebControls.LinqDataSource> , formant pobiera wszystkie właściwości (kolumny danych) z obiektu danych. Za pomocą <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości można pobrać podzbiór właściwości z obiektu lub obliczyć nowe wartości podczas pobierania danych.  
  
 Należy określić właściwości do pobrania przez ustawienie <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości na nazwy właściwości, które mają zostać uwzględnione w zwracanych danych.  
  
 W przypadku pobrania podzestawu właściwości z obiektu <xref:System.Web.UI.WebControls.LinqDataSource> dane formant dynamicznie tworzy klasę, która zawiera tylko właściwości określone <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> we właściwości. Klasa jest również tworzona dynamicznie w przypadku obliczenia właściwości, które nie są właściwościami w obiekcie danych. W takich przypadkach obiekt zwrócony z zapytania nie jest wystąpieniem klasy, która jest określona we <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> właściwości. Zamiast tego należy użyć `new` metody <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> we właściwości, aby wskazać, że nowa klasa jest zwracana z zapytania. Na przykład, `FirstName` aby zwrócić tylko właściwości i `LastName` z obiektu, który zawiera więcej niż <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> te właściwości, należy ustawić właściwość na `new(FirstName, LastName)`. Kontrolka spowoduje dynamiczne utworzenie nowej klasy, która została określona `new` w metodzie. <xref:System.Web.UI.WebControls.LinqDataSource>  
  
 Możesz użyć słowa kluczowego, `As` aby przypisać alias do wybranej wartości. Jeśli przypiszesz alias, musisz uwzględnić właściwości z aliasem w `new` metodzie. Wszystkie kontrolki powiązane z danymi, które wiążą się z wynikami <xref:System.Web.UI.WebControls.LinqDataSource> kontrolki, muszą odwoływać się do właściwości przez alias. Na <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> przykład, jeśli ustawisz właściwość na `new(Region As SalesRegion, Revenue / 1000 As RevenueThousands)`, formant powiązany z danymi `SalesRegion` będzie mógł uzyskać dostęp do dwóch właściwości i `RevenueThousands`.  
  
 `new` Używasz funkcji<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> we właściwości zgodnie z warunkami wymienionymi w poniższej tabeli.  
  
|Wybierz|Korzystanie z nowych|Przykład|  
|------------|----------------|-------------|  
|Pojedyncza właściwość.|`new`Niewymagane.|`Select="Category"`|  
|Wiele właściwości.|`new`wymagana.|`Select="new(Category, Name)"`|  
|Jedno lub wiele właściwości, które mają alias.|`new`wymagana.|`Select="new(Category As CategoryGroup)"`|  
  
 Jeśli chcesz włączyć automatyczne modyfikacje danych, ale nie chcesz wyświetlać wszystkich właściwości z obiektu danych, nie ustawiaj <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości. Zamiast tego Zarządzaj wyświetlaniem za pomocą kontrolki powiązanej z danymi. Gdy <xref:System.Web.UI.WebControls.DetailsView> używasz kontrolki <xref:System.Web.UI.WebControls.DetailsView.AutoGenerateRows%2A> <xref:System.Web.UI.WebControls.GridView> lub kontrolki, musisz <xref:System.Web.UI.WebControls.GridView.AutoGenerateColumns%2A> również ustawić właściwość `false`lub na wartość. Wszystkie wartości, które nie są wyświetlane w formancie powiązanym z danymi, są przechowywane w stanie widoku. Są one przenoszone bez zmian do źródła danych podczas przeprowadzania aktualizacji danych.  
  
 Gdy grupujesz dane w zapytaniu, możesz uwzględnić metody agregujące we <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości. Można użyć następujących metod agregowania:  
  
-   `Count()`  
  
-   `Average(` *column* `)`  
  
-   `Sum(` *column* `)`  
  
-   `Max(` *column* `)`  
  
-   `Min(` *column* `)`  
  
-   `Where(`*warunek*`)`  
  
-   `Any()`  
  
-   `All(`*warunek*`)`  
  
 Aby uzyskać więcej informacji, [zobacz NIB: Formant serwera sieci Web programu](https://msdn.microsoft.com/library/104cfc3f-7385-47d3-8a51-830dfa791136) LinqDataSource [— omówienie i instrukcje: Grupowanie i agregowanie danych przy użyciu kontrolki](https://msdn.microsoft.com/library/b922cf69-251f-4158-b405-ea960993a1af)LinqDataSource.  
  
 Podczas grupowania danych można uwzględnić `Key` i `It`, które są dynamicznie <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> tworzone właściwości, we właściwości. `Key` Właściwość odwołuje się do wartości we właściwości lub właściwościach, które były używane do grupowania danych. Na przykład, Jeśli grupujesz według właściwości o nazwie `Category` `Key` , właściwość będzie zawierać `Category` każdą unikatową wartość we właściwości. `It` Właściwość odwołuje się do kolekcji pojedynczych rekordów w grupie danych. Można wykonać iterację we `It` właściwości, aby pobrać pojedyncze rekordy, które zostały skonsolidowane w operacji grupowania. Na przykład Jeśli grupujesz według właściwości o nazwie `Category` `It` , właściwość zawiera wszystkie pojedyncze rekordy, które mają wspólną wartość we `Category` właściwości.  
  
 Jeśli dołączysz `It` słowo kluczowe <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> do właściwości podczas grupowania danych, musisz `It` przypisać alias do słowa kluczowego. Kontrolka zgłosi wyjątek, jeśli `It` nie ma aliasu. <xref:System.Web.UI.WebControls.LinqDataSource> Można przypisać alias do `Key` słowa kluczowego, ale nie jest to wymagane.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak ustawić <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwość na podzbiór właściwości w obiekcie danych.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#10](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default10.aspx#10)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#10](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default10.aspx#10)]  
  
 Poniższy przykład pokazuje, jak pobrać wartości we właściwości, która została użyta do grupowania danych i pobrać średnią dla pogrupowanych rekordów. `Key` Słowo kluczowe zawiera właściwość, która została użyta do grupowania danych. W tym przykładzie `Key` będzie zawierać wartości udostępnione `ProductCategory` z właściwości.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default3.aspx#3)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default3.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Selected">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Selected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Selected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Selected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Selected As EventHandler(Of LinqDataSourceStatusEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceStatusEventArgs ^&gt; ^ Selected;" />
      <MemberSignature Language="F#" Value="member this.Selected : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " Usage="member this.Selected : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zakończeniu operacji pobierania danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsłuż <xref:System.Web.UI.WebControls.LinqDataSource.Selected> zdarzenie, aby przechwycić wszelkie wyjątki z operacji pobierania danych lub przeanalizować obiekt danych po zakończeniu operacji pobierania. Obiekt jest dostępny z <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs> obiektu, który jest przesyłany do programów obsługi zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Selecting">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceSelectEventArgs&gt; Selecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceSelectEventArgs&gt; Selecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Selecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Selecting As EventHandler(Of LinqDataSourceSelectEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceSelectEventArgs ^&gt; ^ Selecting;" />
      <MemberSignature Language="F#" Value="member this.Selecting : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceSelectEventArgs&gt; " Usage="member this.Selecting : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceSelectEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceSelectEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje przed operacją pobierania danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsłuż <xref:System.Web.UI.WebControls.LinqDataSource.Selecting> zdarzenie, aby wykonać następujące zadania:  
  
-   Modyfikuj parametry pobierania danych.  
  
-   Wygeneruj zapytanie programowo.  
  
-   Zmodyfikuj wartości w celu sortowania lub stronicowania.  
  
-   Wykonaj niestandardowe sortowanie lub stronicowanie.  
  
-   Anuluj operację pobierania danych.  
  
 <xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs> Obiekt, który jest przesyłany do obsługi zdarzeń dla tego zdarzenia, zawiera parametry dla operacji pobierania danych. Parametry w programie <xref:System.Web.UI.WebControls.LinqDataSource.Selecting> obsługi zdarzeń można modyfikować przed wykonaniem zapytania lub można utworzyć nowy zestaw wyników i przypisać <xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs.Result%2A> go do właściwości.  
  
 Możliwość implementacji niestandardowego sortowania lub stronicowania w obsłudze dla tego zdarzenia może być ograniczona przez formant, który jest powiązany z <xref:System.Web.UI.WebControls.LinqDataSource>. Na przykład po kliknięciu nagłówka <xref:System.Web.UI.WebControls.GridView> kolumny kontrolki kontrolka wykonuje automatyczne sortowanie, które może przesłonić dowolną kolejność ustanowioną w programie obsługi zdarzeń.  
  
 Jeśli wyjątek jest zgłaszany w procedurze obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Selecting> zdarzenia, należy obsłużyć wyjątek w tym obsłudze zdarzeń. Wyjątek nie zostanie przesłany do procedury obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Selected> zdarzenia ( <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A> przez właściwość <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs> obiektu). Właściwość zawiera tylko wyjątki, które są zgłaszane <xref:System.Web.UI.WebControls.LinqDataSource.Selecting> po zdarzeniu. <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>  
  
   
  
## Examples  
 Poniższy przykład pokazuje procedurę obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Selecting> zdarzenia. Program obsługi tworzy zapytanie, które pobiera wartości z tablicy wartości ciągu na stronie sieci Web.  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSourceSelectEventArgs#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceSelectEventArgs/cs/Default3.aspx.cs#3)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSourceSelectEventArgs#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceSelectEventArgs/vb/Default3.aspx.vb#3)]  
  
 Poniższy przykład pokazuje, jak przypisać <xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs.Result%2A> właściwość do obiektu, który jest zwracany z metody, która reprezentuje procedurę składowaną.  
  
```vb  
Protected Sub LinqDataSource_Selecting(ByVal sender As Object, _  
        ByVal e As LinqDataSourceSelectEventArgs)  
    Dim exampleContext As ExampleDataContext = New ExampleDataContext()  
    e.Result = exampleContext.GetRegisteredCustomers()  
End Sub  
```  
  
```csharp  
protected void LinqDataSource_Selecting(object sender,   
        LinqDataSourceSelectEventArgs e)  
{  
    ExampleDataContext exampleContext = new ExampleDataContext();  
    e.Result = exampleContext.GetRegisteredCustomers();  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection SelectParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection SelectParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.SelectParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ SelectParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.SelectParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję parametrów, które są używane podczas operacji pobierania danych.</summary>
        <value>Parametry, które są używane do tworzenia klauzuli select.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontrolka używa parametrów <xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A> w kolekcji, aby utworzyć klauzulę SELECT w czasie wykonywania. <xref:System.Web.UI.WebControls.LinqDataSource> Dodaj parametry do <xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A> kolekcji, jeśli chcesz użyć wartości w czasie wykonywania w klauzuli select. Na przykład można dodać parametr do <xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A> kolekcji, aby reprezentować właściwość w profilu użytkownika. Następnie można użyć tej właściwości i wartości ze źródła danych w celu obliczenia nowej wartości.  
  
 Jeśli nie musisz ustawiać wartości w czasie wykonywania w klauzuli select, nie musisz używać <xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A> kolekcji. Można zdefiniować właściwości do pobrania we <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości. Na przykład, aby zwrócić `FirstName` wartości i `LastName` z tabeli bazy danych, ustaw wartość <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> "FirstName, LastName" bez żadnych parametrów.  
  
 Aby ustawić wartości w <xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A> kolekcji, należy dodać symbol zastępczy <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> we właściwości nazwanego parametru. W klauzuli select, należy poprzedzić każdą nazwę parametru znakiem @.  
  
 Nie można użyć parametru w <xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A> kolekcji do reprezentowania nazwy właściwości. Aby dynamicznie ustawić <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwość na nazwę właściwości, Utwórz procedurę obsługi zdarzeń <xref:System.Web.UI.WebControls.LinqDataSource.Selecting> dla zdarzenia i Dostosuj Właściwość zgodnie z <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> wymaganiami.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak użyć wartości dostarczonej przez użytkownika, aby obliczyć wartość w zwracanych danych. Użytkownik może wprowadzić wartość w polu tekstowym, która reprezentuje liczbę dni produkcyjnych. Ta wartość jest podzielona przez wartość z bazy danych, która reprezentuje liczbę dni produkcji produktu. Zwracana wartość wskazuje liczbę produktów, które można wyprodukować w ciągu określonej liczby dni. Dane wejściowe użytkownika są uwzględniane w poleceniu SELECT za pomocą <xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A> kolekcji.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.SelectParameters#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.SelectParameters/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.SelectParameters#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.SelectParameters/vb/Default.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StoreOriginalValuesInViewState">
      <MemberSignature Language="C#" Value="public bool StoreOriginalValuesInViewState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool StoreOriginalValuesInViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.StoreOriginalValuesInViewState" />
      <MemberSignature Language="VB.NET" Value="Public Property StoreOriginalValuesInViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool StoreOriginalValuesInViewState { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.StoreOriginalValuesInViewState : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.StoreOriginalValuesInViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy dane ze źródła danych powinny być przechowywane w stanie widoku, aby upewnić się, że dane nie zostały zmienione przez inny proces przed jego zaktualizowaniem lub usunięciem.</summary>
        <value><see langword="true" />Jeśli wartości będą przechowywane w stanie widoku; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie po włączeniu <xref:System.Web.UI.WebControls.LinqDataSource> operacji aktualizowania i usuwania Formant przechowuje oryginalne wartości dla wszystkich rekordów w stanie widoku. Kontrolka przechowuje wartości dla wszystkich kluczy podstawowych i wszystkie właściwości, które nie `UpdateCheck.Never` są oznaczone `Column` przy użyciu atrybutu. <xref:System.Web.UI.WebControls.LinqDataSource> `UpdateCheck` [!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)]Właściwość atrybutujestustawianaw`Column` .  
  
 Przed LINQ to SQL aktualizuje lub usuwa dane, sprawdza wartości w stanie widoku względem bieżących wartości w źródle danych. Jeśli wartości nie są zgodne, rekord źródła danych został zmieniony. W takim przypadku LINQ to SQL zgłasza wyjątek i nie kontynuuje operacji aktualizowania ani usuwania. Aby uzyskać więcej informacji na temat LINQ to SQL, zobacz [LINQ to SQL](https://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655).  
  
 Przechowywanie oryginalnych wartości w stanie widoku może spowodować niepotrzebne zwiększenie rozmiaru strony i uwidocznić poufne dane dla złośliwego użytkownika. Można wyłączyć przechowywanie wartości w stanie widoku przez ustawienie <xref:System.Web.UI.WebControls.LinqDataSource.StoreOriginalValuesInViewState%2A> właściwości na. `false` Jeśli to zrobisz, musisz zapewnić własny sposób, aby upewnić się, że dane nie uległy zmianie. Jeśli ustawisz <xref:System.Web.UI.WebControls.LinqDataSource.StoreOriginalValuesInViewState%2A> właściwość na `false`, oryginalne wartości nie będą utrwalane w stanie widoku dla kontrolki powiązanej z danymi. W takim przypadku LINQ to SQL nie może zweryfikować integralności danych. LINQ to SQL zgłosi wyjątek wskazujący konflikt danych, nawet jeśli dane w źródle danych nie zostały faktycznie zmienione.  
  
 Jeśli bazowe źródło danych zawiera pole sygnatur czasowych, które jest automatycznie aktualizowane podczas aktualizacji, można przechowywać tylko tę wartość w stanie widoku. W takim przypadku Właściwość timestamp w klasie Entity ma ustawioną wartość `IsVersion=true` i wszystkie właściwości są ustawione na. `UpdateCheck.Never` Ponieważ pole sygnatury czasowej jest automatycznie aktualizowane przez bazę danych za każdym razem, gdy dane w tym rekordzie ulegają zmianie, LINQ to SQL określa od tej wartości, jeśli dane uległy zmianie. Pozwala to zmniejszyć rozmiar widoku, a dane poufne nie są ujawniane. LINQ to SQL sprawdzi spójność danych, porównując wartość sygnatury czasowej w stanie widoku z wartością sygnatury czasowej w bazie danych. Aby uzyskać więcej informacji, [zobacz Przewodnik: Używanie sygnatury czasowej z kontrolką LinqDataSource do sprawdzania](https://msdn.microsoft.com/library/e7700162-4f05-4130-81f7-3be1361027fa)integralności danych.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655">LINQ do SQL</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.DynamicData.IDynamicDataSource.ContextType">
      <MemberSignature Language="C#" Value="Type System.Web.DynamicData.IDynamicDataSource.ContextType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type System.Web.DynamicData.IDynamicDataSource.ContextType" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.System#Web#DynamicData#IDynamicDataSource#ContextType" />
      <MemberSignature Language="VB.NET" Value=" Property ContextType As Type Implements IDynamicDataSource.ContextType" />
      <MemberSignature Language="C++ CLI" Value="property Type ^ System::Web::DynamicData::IDynamicDataSource::ContextType { Type ^ get(); void set(Type ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Web.DynamicData.IDynamicDataSource.ContextType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.ContextType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="T:System.Web.DynamicData.IDynamicDataSource" />Zobacz.</summary>
        <value>Typ, który jest skojarzony z klasą.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Web.UI.WebControls.LinqDataSource> gdy wystąpienie jest rzutowane <xref:System.Web.DynamicData.IDynamicDataSource> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.DynamicData.IDynamicDataSource.EntitySetName">
      <MemberSignature Language="C#" Value="string System.Web.DynamicData.IDynamicDataSource.EntitySetName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string System.Web.DynamicData.IDynamicDataSource.EntitySetName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.System#Web#DynamicData#IDynamicDataSource#EntitySetName" />
      <MemberSignature Language="VB.NET" Value=" Property EntitySetName As String Implements IDynamicDataSource.EntitySetName" />
      <MemberSignature Language="C++ CLI" Value="property System::String ^ System::Web::DynamicData::IDynamicDataSource::EntitySetName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Web.DynamicData.IDynamicDataSource.EntitySetName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.EntitySetName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="T:System.Web.DynamicData.IDynamicDataSource" />Zobacz.</summary>
        <value>Nazwa jednostki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Web.UI.WebControls.LinqDataSource> gdy wystąpienie jest rzutowane <xref:System.Web.DynamicData.IDynamicDataSource> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.DynamicData.IDynamicDataSource.Exception">
      <MemberSignature Language="C#" Value="event EventHandler&lt;System.Web.DynamicData.DynamicValidatorEventArgs&gt; System.Web.DynamicData.IDynamicDataSource.Exception;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.DynamicData.DynamicValidatorEventArgs&gt; System.Web.DynamicData.IDynamicDataSource.Exception" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.System#Web#DynamicData#IDynamicDataSource#Exception" />
      <MemberSignature Language="VB.NET" Value="Custom Event Exception As EventHandler(Of DynamicValidatorEventArgs) Implements System.Web.DynamicData.IDynamicDataSource" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Web.DynamicData.IDynamicDataSource.Exception</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.DynamicData.DynamicValidatorEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="T:System.Web.DynamicData.IDynamicDataSource" />Zobacz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Web.UI.WebControls.LinqDataSource> gdy wystąpienie jest rzutowane <xref:System.Web.DynamicData.IDynamicDataSource> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableName">
      <MemberSignature Language="C#" Value="public string TableName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TableName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.TableName" />
      <MemberSignature Language="VB.NET" Value="Public Property TableName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TableName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TableName : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.TableName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę właściwości lub pola w klasie kontekstu danych, która reprezentuje kolekcję danych.</summary>
        <value>Ciąg, który zawiera nazwę właściwości zawierającej zbieranie danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> Ustaw właściwość na nazwę właściwości lub pola, które reprezentuje dane, które chcesz pobrać. W przypadku łączenia się z tabelą bazy danych nazwa właściwości jest zwykle taka sama jak nazwa tabeli. Podczas łączenia się z kolekcją danych w pamięci, należy ustawić <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> właściwość na nazwę właściwości lub pola, które zwraca kolekcję danych.  
  
 Do <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> właściwości operacji pobierania można przypisać właściwość zwracającą dowolny typ. Jeśli obiekt, który jest reprezentowany przez właściwość nie implementuje <xref:System.Collections.IEnumerable> <xref:System.Web.UI.WebControls.LinqDataSource> , formant automatycznie umieści obiekt <xref:System.Collections.IEnumerable> w wystąpieniu obiektu.  
  
 Aby włączyć operacje automatycznego aktualizowania, wstawiania lub usuwania, Klasa, która jest <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A> przypisana do właściwości, musi pochodzić od <xref:System.Data.Linq.DataContext> i Właściwość <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> , która jest przypisana do właściwości, musi pochodzić <xref:System.Data.Linq.Table%601>od.  
  
 Aby uzyskać informacje o sposobach wybierania danych z wystąpienia klasy, zobacz <xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs.Result%2A> właściwość.  
  
   
  
## Examples  
 Poniższy przykład przedstawia dwie <xref:System.Web.UI.WebControls.LinqDataSource> kontrolki. W jednym <xref:System.Web.UI.WebControls.LinqDataSource> formancie <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> właściwość jest ustawiana na właściwość w klasie. Ta właściwość zwraca tablicę ciągów. W innym <xref:System.Web.UI.WebControls.LinqDataSource> formancie <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> właściwość jest ustawiana na właściwość, która reprezentuje tabelę bazy danych.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/cs/Default.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/vb/Default.aspx#2)]  
  
 Klasa o nazwie `ExampleDataContext` , która reprezentuje tabelę bazy danych, nie jest pokazana w tym przykładzie. Aby ten przykład działał, należy utworzyć tę klasę poprzez dodanie klasy LINQ to SQL o nazwie example. dbml i przeciąganie tabeli o nazwie Movie na [!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)]. Klasa o nazwie `ExampleDataContext` z właściwością o `Movies` nazwie została wygenerowana.  
  
 W poniższym przykładzie pokazano klasę o nazwie `MovieLibrary` , do której odwołuje <xref:System.Web.UI.WebControls.LinqDataSource> się kontrolka.  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/cs/App_Code/MovieLibrary.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/vb/App_Code/MovieLibrary.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected override void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void TrackViewState();" />
      <MemberSignature Language="F#" Value="override this.TrackViewState : unit -&gt; unit" Usage="linqDataSource.TrackViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Śledzi zmiany <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> stanu widoku w kontrolce, tak aby zmiany mogły być przechowywane <see cref="T:System.Web.UI.StateBag" /> w obiekcie dla kontrolki.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb547113(v=vs.100)">Formant LinqDataSource serwera sieci Web — Omówienie</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178359(v=vs.110)">{1&amp;gt;Omówienie dostępu do danych w programie ASP.NET&amp;lt;1}</related>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Collections.IDictionary keys, System.Collections.IDictionary values, System.Collections.IDictionary oldValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Update(class System.Collections.IDictionary keys, class System.Collections.IDictionary values, class System.Collections.IDictionary oldValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.Update(System.Collections.IDictionary,System.Collections.IDictionary,System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function Update (keys As IDictionary, values As IDictionary, oldValues As IDictionary) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(System::Collections::IDictionary ^ keys, System::Collections::IDictionary ^ values, System::Collections::IDictionary ^ oldValues);" />
      <MemberSignature Language="F#" Value="member this.Update : System.Collections.IDictionary * System.Collections.IDictionary * System.Collections.IDictionary -&gt; int" Usage="linqDataSource.Update (keys, values, oldValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.IDictionary" />
        <Parameter Name="values" Type="System.Collections.IDictionary" />
        <Parameter Name="oldValues" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="keys">Wartości klucza wiersza dla rekordów do zaktualizowania.</param>
        <param name="values">Wartości wierszy do zaktualizowania w źródle danych.</param>
        <param name="oldValues">Wartości wierszy, które są oceniane do wykrywania konfliktów danych.</param>
        <summary>Wykonuje operację aktualizacji.</summary>
        <returns>Liczba rekordów, których dotyczy operacja aktualizacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj nie trzeba wywoływać <xref:System.Web.UI.WebControls.LinqDataSource.Update%2A> metody z kodu. Formant powiązany z danymi automatycznie wywoła metodę, <xref:System.Web.UI.WebControls.LinqDataSource.Update%2A> gdy użytkownik podejmie akcję w celu zaktualizowania rekordu. Metodę należy jawnie wywołać <xref:System.Web.UI.WebControls.LinqDataSource.Update%2A> , gdy chcesz utworzyć własny proces aktualizowania danych.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak programowo zaktualizować rekord w źródle danych po kliknięciu przycisku przez użytkownika. Kod przekazuje <xref:System.Collections.Specialized.ListDictionary> obiekt, który zawiera wartość klucza <xref:System.Collections.Specialized.ListDictionary> , obiekt, który zawiera <xref:System.Collections.Specialized.ListDictionary> pierwotne wartości, oraz <xref:System.Web.UI.WebControls.LinqDataSource.Update%2A> obiekt, który zawiera nowe wartości do metody.  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.Update#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Update/cs/Default2.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.Update#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Update/vb/Default3.aspx.vb#1)]  
  
 W poniższym przykładzie pokazano znaczniki dla poprzedniego przykładu.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.Update#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Update/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.Update#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Update/vb/Default3.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Updated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Updated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Updated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Updated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Updated As EventHandler(Of LinqDataSourceStatusEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceStatusEventArgs ^&gt; ^ Updated;" />
      <MemberSignature Language="F#" Value="member this.Updated : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " Usage="member this.Updated : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zakończeniu operacji aktualizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsłuż <xref:System.Web.UI.WebControls.LinqDataSource.Updated> zdarzenie, aby przechwycić wszelkie wyjątki z operacji aktualizacji lub przeanalizować wartości parametrów wyjściowych po zakończeniu operacji aktualizacji. Parametry wyjściowe są dostępne z <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs> obiektu, który jest przesyłany do programów obsługi zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection UpdateParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection UpdateParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.UpdateParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UpdateParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ UpdateParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UpdateParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.UpdateParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ta kolekcja nie jest używana przez <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> klasę.</summary>
        <value>Kolekcja parametrów.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Updating">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs&gt; Updating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs&gt; Updating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Updating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Updating As EventHandler(Of LinqDataSourceUpdateEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceUpdateEventArgs ^&gt; ^ Updating;" />
      <MemberSignature Language="F#" Value="member this.Updating : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs&gt; " Usage="member this.Updating : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje przed operacją Update.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsłuż <xref:System.Web.UI.WebControls.LinqDataSource.Updating> zdarzenie, aby sprawdzić poprawność obiektu do zaktualizowania, aby sprawdzić błędy walidacji danych z klasy danych, zmienić wartość przed operacją aktualizacji lub aby anulować operację aktualizacji. <xref:System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs> Obiekt, który jest przesyłany do programów obsługi zdarzeń, zawiera zarówno oryginalny obiekt, jak i zaktualizowany obiekt.  
  
 Jeśli podczas operacji aktualizacji wystąpi błąd walidacji, <xref:System.Web.UI.WebControls.LinqDataSourceInsertEventArgs> obiekt zawiera wyjątki walidacji, które są zgłaszane przez klasę danych. Błąd walidacji występuje, jeśli wartość, która ma zostać zaktualizowana, jest niezgodna z typem właściwości w klasie danych lub jeśli nie przeszedł niestandardowego sprawdzania poprawności. W procedurze obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Updating> zdarzenia można pobrać wyjątki walidacji i podjąć odpowiednie działania.  
  
 Jeśli wyjątek jest zgłaszany w procedurze obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Updating> zdarzenia, należy obsłużyć wyjątek w tym obsłudze zdarzeń. Wyjątek nie zostanie przesłany do procedury obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Updated> zdarzenia ( <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A> przez właściwość <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs> obiektu). Właściwość zawiera tylko wyjątki, które są zgłaszane <xref:System.Web.UI.WebControls.LinqDataSource.Updating> po zdarzeniu. <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>  
  
   
  
## Examples  
 Poniższy przykład pokazuje procedurę obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Updating> zdarzenia. Kod porównuje właściwości z <xref:System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs.OriginalObject%2A> właściwością <xref:System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs.NewObject%2A> i właściwością, aby zobaczyć, czy wartość została zmieniona. Jeśli wartość została zmieniona, wartość <xref:System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs.NewObject%2A> właściwości jest ustawiona na. `true`  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.Updating#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Updating/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.Updating#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Updating/vb/Default.aspx.vb#1)]  
  
 Poniższy przykład pokazuje program obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Updating> zdarzenia, które pobiera wyjątki walidacji.  
  
```vb  
Protected Sub LinqDataSource_Updating(ByVal sender As Object, _  
        ByVal e As LinqDataSourceUpdateEventArgs)  
    If (e.Exception IsNot Nothing) Then  
        For Each innerException As KeyValuePair(Of String, Exception) _  
               In e.Exception.InnerExceptions  
            Label1.Text &= innerException.Key & ": " & _  
                innerException.Value.Message & "<br />"  
        Next  
        e.ExceptionHandled = True  
    End If  
End Sub  
```  
  
```csharp  
protected void LinqDataSource_Updating(object sender,   
        LinqDataSourceUpdateEventArgs e)  
{  
    if (e.Exception != null)  
    {  
        foreach (KeyValuePair<string, Exception> innerException in   
             e.Exception.InnerExceptions)  
        {  
        Label1.Text += innerException.Key + ": " +   
            innerException.Value.Message + "<br />";  
        }  
        e.ExceptionHandled = true;  
    }  
}  
```  
  
 Poprzedni przykład pobiera wyjątki walidacji. Wyjątek może zostać wygenerowany, jeśli wartość nie jest zgodna z typem właściwości. Może być również zgłaszane z dostosowanego sprawdzenia, takiego jak ten w poniższym przykładzie. Metoda sprawdza, czy liczba `Age` właściwości nie jest ujemna. `OnAgeChanging`  
  
```csharp  
partial void  OnAgeChanging(int? value)  
{  
    if (value < 0)  
    {  
        throw new Exception("Age cannot be a negative number.");  
    }  
}  
```  
  
```vb  
Private Sub OnAgeChanging(ByVal value As System.Nullable(Of Integer))  
    If (value < 0) Then  
        Throw New Exception("Age cannot be a negative number.")  
    End If  
End Sub  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Where">
      <MemberSignature Language="C#" Value="public string Where { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Where" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.Where" />
      <MemberSignature Language="VB.NET" Value="Public Property Where As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Where { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Where : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.Where" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.Where</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, jakie warunki muszą mieć wartość true dla rekordu, który ma być uwzględniony w pobranych danych.</summary>
        <value>Ciąg, który jest używany do tworzenia klauzuli WHERE.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj właściwości, <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> aby określić warunki dla rekordu, który ma zostać zwrócony z zapytania. Składnia <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> właściwości jest taka sama jak składnia dla klauzuli LINQ WHERE w C#.  
  
 Należy określić wyrażenie, które daje w wyniku wartość logiczną, a jeśli wyrażenie oblicza `true` dla danego wiersza, wiersz zostanie uwzględniony w zestawie wyników. Wyrażenia składają się z nazw kolumn, operatorów porównania i wartości do porównania, jak pokazano w następującym przykładzie:  
  
```  
<asp:LinqDataSource ... Where="Price > 50"...>  
```  
  
 Aby określić wiele wyrażeń połączonych przez operatora `AND` logicznego OR `OR` , użyj `&&` jako operatora logicznego and oraz `||` operatora logicznego OR, jak pokazano w następującym przykładzie:  
  
```  
<asp:LinqDataSource ... Where="Price > 50 && Price < 100"...>  
<asp:LinqDataSource ... Where="Price <= 50 || Price >= 100"...>  
```  
  
 Jeśli chcesz przetestować Właściwość względem wartości ciągu literału, wartość ciągu literału musi być ujęta w znaki podwójnego cudzysłowu. Aby to zrobić w znaczniku, należy ująć <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> wartość klauzuli w znaki pojedynczego cudzysłowu, jak pokazano w następującym przykładzie:  
  
```  
<asp:LinqDataSource ... Where='Category = "Sports"' ... >  
```  
  
 Aby przeprowadzić test względem wartości ciągu literału w kodzie, należy użyć znaków ucieczki właściwych dla języka, który jest używany w celu wstawiania podwójnych cudzysłowów, jak pokazano w następującym przykładzie:  
  
```vb  
LinqDataSource1.Where = "Category = ""Sports"""  
```  
  
```csharp  
LinqDataSource1.Where = "Category = \"Sports\"";  
```  
  
 Jeśli chcesz sprawdzić, czy ciąg jest większy niż lub mniejszy niż inny ciąg, musisz użyć metod <xref:System.String> klasy zamiast używać `<` operatorów or `>` między nazwą kolumny a wartością ciągu. W poniższych przykładach pokazano, jak wybrać wiersze, które mają wartości kategorii mniejsze niż lub równe, większe niż lub większe niż lub równe "Sport":  
  
```  
<asp:LinqDataSource ... Where='Category.CompareTo("Sports") < 0' ... >  
<asp:LinqDataSource ... Where='Category.CompareTo("Sports") <= 0' ... >  
<asp:LinqDataSource ... Where='Category.CompareTo("Sports") > 0' ... >  
<asp:LinqDataSource ... Where='Category.CompareTo("Sports") >= 0' ... >  
```  
  
 Można również użyć innych <xref:System.String> metod klasy, takich jak <xref:System.String.StartsWith%2A>, <xref:System.String.EndsWith%2A>, i <xref:System.String.Contains%2A>. Aby uzyskać więcej informacji na temat porównywania ciągów, zobacz [Porównywanie ciągów](~/docs/standard/base-types/comparing.md). Aby uzyskać więcej informacji na temat składni klauzuli WHERE, zobacz [ C# operatory](https://msdn.microsoft.com/library/0301e31f-22ad-49af-ac3c-d5eae7f0ac43) i [klauzula WHERE](~/docs/csharp/language-reference/keywords/where-clause.md).  
  
 Oprócz filtrowania na podstawie wartości statycznych, które definiujesz podczas tworzenia strony sieci Web, można filtrować na podstawie wartości dynamicznych, które są oceniane w czasie wykonywania. W takim przypadku w <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> właściwości należy umieścić nazwany parametr, który działa jako symbol zastępczy dla wartości. Następnie należy dodać parametr, który ma pasującą nazwę do <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> kolekcji.  
  
 Alternatywnie można ustawić <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A> właściwość na `true` i <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> zdefiniować parametry w kolekcji. Gdy właściwość ma `true`wartość, nie trzeba uwzględniać parametrów nazwanych we <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> właściwości. <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A> Zamiast tego, <xref:System.Web.UI.WebControls.LinqDataSource> formant automatycznie generuje klauzulę WHERE z parametrów <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> we właściwości.  
  
 Aby uzyskać więcej informacji o sposobach filtrowania danych, [zobacz Przewodnik: Wybieranie i filtrowanie podzestawu danych za pomocą kontrolek](https://msdn.microsoft.com/library/c1cca3e8-86e4-4e69-a29f-1c05b91f2205)LinqDataSource i GridView.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak filtrować dane zwracane z zapytania na podstawie warunku statycznego.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default5.aspx#5)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default5.aspx#5)]  
  
 Poniższy przykład pokazuje, jak odfiltrować dane na podstawie wartości dostarczonej przez użytkownika w czasie wykonywania. W tym przykładzie <xref:System.Web.UI.WebControls.DropDownList> kontrolka <xref:System.Web.UI.WebControls.GridView> i kontrolka są wyświetlane na stronie. Gdy użytkownik wybierze jedną z wartości <xref:System.Web.UI.WebControls.DropDownList> w kontrolce <xref:System.Web.UI.WebControls.LinqDataSource> , formant wybiera z `Products` tabeli tylko wiersze, które mają `UserPrice` wartości równe wybranej wartości. Następnie <xref:System.Web.UI.WebControls.GridView> formant Wyświetla filtrowane dane.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default6.aspx#6)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default6.aspx#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WhereParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection WhereParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection WhereParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.WhereParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WhereParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ WhereParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WhereParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.WhereParameters" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.WhereParameters</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję parametrów, które są używane do tworzenia klauzuli WHERE.</summary>
        <value>Kolekcja parametrów, które są używane do tworzenia klauzuli WHERE we <see cref="P:System.Web.UI.WebControls.LinqDataSource.Where" /> właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontrolka używa parametrów <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> w kolekcji, aby utworzyć klauzulę WHERE w czasie wykonywania. <xref:System.Web.UI.WebControls.LinqDataSource> Dodaj parametry do <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> kolekcji, jeśli chcesz programowo ustawić jeden lub więcej warunków w klauzuli WHERE. Można na przykład wyszukać tabelę bazy danych pod kątem rekordów o nazwie odpowiadającej wartości <xref:System.Web.UI.WebControls.TextBox> formantu. W takim przypadku należy dodać parametr do <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> kolekcji dla wartości pola tekstowego.  
  
 Jeśli nie musisz ustawiać wartości w czasie wykonywania w klauzuli WHERE, nie musisz używać <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> kolekcji. Można zdefiniować pola do pobrania we <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> właściwości. Na przykład, aby zwrócić wartości z tabeli bazy danych, `LastName` gdzie jest równa "Adams" w znaczniku, `'LastName = "Adams"'` <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> ustaw właściwość na bez żadnych parametrów.  
  
 Aby ustawić wartości w <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> kolekcji, należy przypisać nazwę do każdego parametru, a następnie dodać symbol zastępczy <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> we właściwości dla tego parametru. W klauzuli WHERE, należy poprzedzić każdą nazwę parametru znakiem @.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> kolekcji do dynamicznego tworzenia klauzuli WHERE. Kontrolka zwraca wszystkie rekordy z wartością `Price` w kolumnie, która jest większa niż wartość wybrana <xref:System.Web.UI.WebControls.DropDownList> przez użytkownika w kontrolce. <xref:System.Web.UI.WebControls.LinqDataSource>  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default6.aspx#6)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default6.aspx#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="LinqDataSource" FullName="System.Web.UI.WebControls.LinqDataSource">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="eb47995a42e8b5a63458997b016e35704034a00a" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30691721" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class LinqDataSource : System.Web.UI.WebControls.ContextDataSource, System.Web.DynamicData.IDynamicDataSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit LinqDataSource extends System.Web.UI.WebControls.ContextDataSource implements class System.Web.DynamicData.IDynamicDataSource, class System.Web.UI.IDataSource" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.LinqDataSource" />
  <TypeSignature Language="VB.NET" Value="Public Class LinqDataSource&#xA;Inherits ContextDataSource&#xA;Implements IDynamicDataSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class LinqDataSource : System::Web::UI::WebControls::ContextDataSource, System::Web::DynamicData::IDynamicDataSource" />
  <AssemblyInfo>
    <AssemblyName>System.Web.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.WebControls.ContextDataSource</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.DynamicData.IDynamicDataSource</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Selecting")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("ContextTypeName")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.LinqDataSourceDesigner, System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Drawing.ToolboxBitmap(typeof(System.Web.UI.WebControls.LinqDataSource), "LinqDataSource.bmp")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Umożliwia korzystanie z język Language-Integrated zapytania (LINQ) na stronie sieci Web ASP.NET za pomocą znacznika tekstu, aby pobrać i zmodyfikować danych z obiektu danych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W tym temacie:  
  
-   [Wprowadzenie](#introduction)  
  
-   [Kolejność operacji](#order_of_operations)  
  
-   [Porządkowanie danych](#ordering_data)  
  
-   [Grupowanie danych](#grouping_data)  
  
-   [Data modyfikacji](#data_modifications)  
  
-   [Obliczenia wartości w czasie wykonywania](#evaluating_value_at_run_time)  
  
-   [Praca z procedur składowanych](#working_with_stored_procedures)  
  
-   [Składni deklaratywnej](#declarative_syntax)  
  
<a name="introduction"></a>   
## <a name="introduction"></a>Wprowadzenie  
 Zapytanie języku zintegrowanym (LINQ) jest składnia zapytania, który definiuje zestaw operatorów zapytań, umożliwiające przechodzenie, filtrować i projekcji operacji wyrażane w deklaratywne w żadnym. Języka programowania opartego na sieci. Obiekt danych może być zbierania danych w pamięci lub obiekt, który reprezentuje dane z bazy danych. Można pobrać lub modyfikować dane bez konieczności pisania poleceń SQL dla każdej operacji.  
  
 <xref:System.Web.UI.WebControls.LinqDataSource> Kontroli pozwala na użycie LINQ na stronie sieci Web ASP.NET przez ustawienie właściwości w tekście znaczników. <xref:System.Web.UI.WebControls.LinqDataSource> Formant używa LINQ do SQL mają być automatycznie generowane polecenia danych. Aby uzyskać więcej informacji dotyczących składnika LINQ to SQL, zobacz [LINQ do SQL](http://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655).  
  
 Jeśli dane są pobierane z kolekcji danych w pamięci, można skonfigurować ustawienie <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A> właściwości do klasy, który zawiera kolekcję danych. Możesz ustawić <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> właściwości właściwość lub pole, które zwraca zbierania danych. Na przykład może mieć klasy o nazwie `Person` zawiera właściwość o nazwie `FavoriteCities` zwracająca tablicę wartości ciągu. W takim przypadku należy ustawić <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A> właściwości `Person` i ustaw <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> właściwości `FavoriteCities`.  
  
 Podczas wykonywania zapytań dotyczących bazy danych, użytkownik musi najpierw utworzyć klas jednostek, które reprezentują bazy danych i jego tabele. Można użyć [!INCLUDE[vs_ordesigner_long](~/includes/vs-ordesigner-long-md.md)] lub narzędzia SqlMetal.exe do wygenerowania tych klas. Następnie ustaw <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A> właściwości klasy, która reprezentuje bazy danych i ustaw <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> właściwości właściwość, która reprezentuje tabeli bazy danych.  
  
<a name="order_of_operations"></a>   
## <a name="order-of-operations"></a>Kolejność operacji  
 <xref:System.Web.UI.WebControls.LinqDataSource> Kontroli stosuje operacje na danych w następującej kolejności:  
  
1.  Gdzie (Określ dane, które rejestruje do zwrócenia).  
  
2.  Order By (sortowania).  
  
3.  Group By (rekordy agregacji danych, które współużytkują wartości).  
  
4.  Kolejność grup według (sortowanie pogrupowanych danych).  
  
5.  Wybierz (Określ pola lub właściwości do zwrócenia).  
  
6.  Automatyczne sortowanie (Sortowanie rekordów danych według właściwości wybranego przez użytkownika).  
  
7.  Strona automatycznie (pobierania ich podzbiór rekordów danych, które zostały wybrane przez użytkownika).  
  
 Dodawanie warunków do <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> właściwości do filtrowania rekordów danych, które są zwracane z kwerendy. Jeśli <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> nie ustawiono właściwości <xref:System.Web.UI.WebControls.LinqDataSource> kontroli pobiera każdego rekordu z obiektu danych.  
  
<a name="ordering_data"></a>   
## <a name="ordering-data"></a>Porządkowanie danych  
 Możesz użyć <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> właściwości w celu określenia nazwy z zwrócone dane można sortować według właściwości.  
  
> [!NOTE]
>  Jeśli używasz <xref:System.Web.UI.WebControls.LinqDataSource> sterować za pomocą [!INCLUDE[ss2k](~/includes/ss2k-md.md)] lub [!INCLUDE[ssEW](~/includes/ssew-md.md)] i <xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A> właściwość jest ustawiona na `true`, należy podać wartość w <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> właściwości. Domyślnie <xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A> jest właściwość `true`. Jeśli przypisanie wartości do <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości, należy również umieścić wszystkie kolumny tożsamości na liście właściwości, która jest zwracana w zapytaniu.  
  
<a name="grouping_data"></a>   
## <a name="grouping-data"></a>Grupowanie danych  
 Możesz użyć <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwości w celu określenia właściwości, które są używane do konsolidacji rekordów danych, które mają takie same wartości. Grupując dane mogą obejmować `Key` i `It`, które są tworzone dynamicznie właściwości, w <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości. `Key` Właściwość odwołuje się do wartości właściwości lub właściwości, które były używane do grupowania danych. Na przykład, jeśli grupowanie według właściwości o nazwie `Category`, `Key` właściwości będzie zawierać wszystkie unikatowe wartości w `Category` właściwości. `It` Właściwość odwołuje się do kolekcji poszczególne rekordy w metodzie grupowania danych. Można przejść przez `It` właściwość, aby pobrać poszczególne rekordy, które mają zostać skonsolidowane w operacji grupowania. Na przykład, jeśli grupowanie według właściwości o nazwie `Category`, `It` właściwość zawiera wszystkie poszczególne rekordy, które wspólną wartość w `Category` właściwości.  
  
 Możesz użyć <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A> właściwości w celu określenia właściwości, które mają zostać użyte do sortowania zgrupowanych danych. W przypadku grupowania danych, <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> właściwość określa sposób sortowania poszczególnych rekordów w zgrupowanych danych.  
  
 Domyślnie <xref:System.Web.UI.WebControls.LinqDataSource> kontroli pobiera wartości dla wszystkich właściwości z obiektu danych. Możesz użyć <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości w celu określenia właściwości, które do zwrócenia, jeśli chcesz pracować z podzbioru dostępnych właściwości. Operacja Select są stosowane po Where, Order By i operacje Group By. W związku z tym Jeśli tworzysz nazwa aliasu w klauzuli Select, alias nie jest dostępna w innych klauzul.  
  
<a name="data_modifications"></a>   
## <a name="data-modifications"></a>Data modyfikacji  
 Można określić, czy włączono modyfikacji danych przy użyciu <xref:System.Web.UI.WebControls.LinqDataSource.EnableDelete%2A>, <xref:System.Web.UI.WebControls.LinqDataSource.EnableInsert%2A>, i <xref:System.Web.UI.WebControls.LinqDataSource.EnableUpdate%2A> właściwości. Interfejs użytkownika do modyfikacji danych z <xref:System.Web.UI.WebControls.LinqDataSource> formant jest zwykle zapewniany przez formant powiązany z danymi, takich jak <xref:System.Web.UI.WebControls.DetailsView> formantu. Oprócz ustawienia <xref:System.Web.UI.WebControls.LinqDataSource.EnableDelete%2A>, <xref:System.Web.UI.WebControls.LinqDataSource.EnableInsert%2A>, lub <xref:System.Web.UI.WebControls.LinqDataSource.EnableUpdate%2A> do `true`, poniższe warunki są wymagane do włączenia modyfikacji danych automatyczne:  
  
-   <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> Właściwość nie może być przypisana wartość.  
  
-   <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> Właściwość nie może być przypisana wartość.  
  
-   Klasa, która jest przypisana do <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A> właściwości musi pochodzić od <xref:System.Data.Linq.DataContext>.  
  
-   Właściwość, która jest przypisana do <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> właściwości musi pochodzić od <xref:System.Data.Linq.Table%601>.  
  
 Można ograniczyć, właściwości, które są wyświetlane w formancie powiązane z danymi na dwa sposoby. Można albo zestaw <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> podzbiór właściwości, lub dla właściwości można zdefiniować pól dla formantu powiązanego z danymi, dodając <xref:System.Web.UI.WebControls.DataControlField> kontrolki. Jednak jeśli ustawisz <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości, oznacza to, że nie można włączyć automatycznego aktualizowania, wstawiania i operacji usuwania. Jeśli chcesz umożliwić modyfikacje danych podczas pracy z podzbioru dostępnych właściwości, nie należy ustawiać <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości. Zamiast tego należy pobrać wszystkie właściwości obiektu danych i zarządzania, które są wyświetlane przy użyciu formantu powiązanego z danymi. Jeśli używasz <xref:System.Web.UI.WebControls.DetailsView> kontroli lub <xref:System.Web.UI.WebControls.GridView> formantu, należy także ustawić <xref:System.Web.UI.WebControls.DetailsView.AutoGenerateRows%2A> lub <xref:System.Web.UI.WebControls.GridView.AutoGenerateColumns%2A> właściwości `false`. Zapobiega to przyciski umożliwiające edytowanie i usuwanie danych w tym automatycznie formantu powiązanego z danymi. Wartości, które nie są wyświetlane w formancie powiązane z danymi są przechowywane w widoku stanu. Są one przekazywane bez zmian w źródle danych podczas aktualizacji danych.  
  
<a name="evaluating_value_at_run_time"></a>   
## <a name="evaluating-values-at-run-time"></a>Obliczenia wartości w czasie wykonywania  
 Jeśli masz pozwala obliczyć wartości w czasie wykonywania porządkowania, filtrowanie, lub grupowanie wartości, należy dodać parametry <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>, <xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A>, <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters%2A>, lub <xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A> kolekcji.  
  
 Jeśli chcesz określić wartości domyślne, można dodać parametry <xref:System.Web.UI.WebControls.LinqDataSource.InsertParameters%2A> kolekcji.  
  
 Jeśli chcesz przejrzeć lub zmodyfikuj wartości przed wykonaniem operacji danych może obsłużyć <xref:System.Web.UI.WebControls.LinqDataSource.Deleting>, <xref:System.Web.UI.WebControls.LinqDataSource.Inserting>, <xref:System.Web.UI.WebControls.LinqDataSource.Selecting>, lub <xref:System.Web.UI.WebControls.LinqDataSource.Updating> zdarzenia. Można również obsługiwać te zdarzenia, aby anulować operację danych lub Sprawdź błędy sprawdzania poprawności, które wystąpiły podczas ustawiania właściwości w klasie danych oparte na danych wejściowych użytkownika.  
  
 Zbadanie wartości po zakończeniu operacji danych, obsługa <xref:System.Web.UI.WebControls.LinqDataSource.Deleted>, <xref:System.Web.UI.WebControls.LinqDataSource.Inserted>, <xref:System.Web.UI.WebControls.LinqDataSource.Selected>, lub <xref:System.Web.UI.WebControls.LinqDataSource.Updated> zdarzenia.  
  
<a name="working_with_stored_procedures"></a>   
## <a name="working-with-stored-procedures"></a>Praca z procedur składowanych  
 Możesz użyć <xref:System.Web.UI.WebControls.LinqDataSource> formant do pobierania danych przez utworzenie programu obsługi zdarzeń dla procedury składowanej <xref:System.Web.UI.WebControls.LinqDataSource.Selecting> zdarzeń. Zdarzeń programu obsługi, należy wywołać metodę w klasa kontekstu danych, która reprezentuje procedury składowanej i ustaw dla wyniku <xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs.Result%2A> właściwość <xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs> obiektu. Jeśli chcesz włączyć automatycznego aktualizowania, wstawiania i operacji usuwania dla danych typu, który jest zwracany przez metodę musi odpowiadać typowi określonego w <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> właściwości. Aby uzyskać więcej informacji o tworzeniu metod kontekstu danych, zobacz [porady: metody tworzenia DataContext mapowane na procedury składowane i funkcje (Projektanta obiektów relacyjnych)](http://msdn.microsoft.com/library/e7ca32f1-50b3-48af-ad92-ceafd749296a).  
  
<a name="declarative_syntax"></a>   
## <a name="declarative-syntax"></a>Składnia deklaracyjna  
  
```  
<asp:LinqDataSource  
    AutoGenerateOrderByClause="True|False"  
    AutoGenerateWhereClause="True|False"  
    AutoPage="True|False"  
    AutoSort="True|False"  
    ContextTypeName="string"  
    EnableDelete="True|False"  
    EnableInsert="True|False"  
    EnableTheming="True|False"  
    EnableUpdate="True|False"  
    EnableViewState="True|False"  
    GroupBy="string"  
    ID="string"  
    OnContextCreated="ContextCreated event handler"  
    OnContextCreating="ContextCreating event handler"  
    OnContextDisposing="ContextDisposing event handler"  
    OnDataBinding="DataBinding event handler"  
    OnDeleted="Deleted event handler"  
    OnDeleting="Deleting event handler"  
    OnDisposed="Disposed event handler"  
    OnInit="Init event handler"  
    OnInserted="Inserted event handler"  
    OnInserting="Inserting event handler"  
    OnLoad="Load event handler"  
    OnPreRender="PreRender event handler"  
    OnSelected="Selected event handler"  
    OnSelecting="Selecting event handler"  
    OnUnload="Unload event handler"  
    OnUpdated="Updated event handler"  
    OnUpdating="Updating event handler"  
    OrderBy="string"  
    runat="server"  
    Select="string"  
    SkinID="string"  
    StoreOriginalValuesInViewState="True|False"  
    TableName="string"  
    Visible="True|False"  
    Where="string"  
>  
        <GroupByParameters />  
        <InsertParameters />  
        <OrderByParameters />  
        <SelectParameters />  
        <WhereParameters />  
</asp:LinqDataSource>  
```  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono <xref:System.Web.UI.WebControls.LinqDataSource> formant, który pobiera dane z klasy jednostki o nazwie `Products`. Klasa jednostki można wygenerować za pomocą [!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)] lub narzędzia SqlMetal.exe. <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> Właściwość jest ustawiona na zwraca tylko te rekordy, które mają wartość w `Price` właściwości większa niż 50. A <xref:System.Web.UI.WebControls.GridView> kontrolka jest powiązana z <xref:System.Web.UI.WebControls.LinqDataSource> formantu, aby wyświetlić dane.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default5.aspx#5)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default5.aspx#5)]  
  
 W poniższym przykładzie przedstawiono <xref:System.Web.UI.WebControls.LinqDataSource> formant, który umożliwia użytkownikom aktualizowanie, usuwanie i wstawianie rekordów w źródle danych. A <xref:System.Web.UI.WebControls.DetailsView> kontrolka jest powiązana z <xref:System.Web.UI.WebControls.LinqDataSource> kontroli i umożliwia użytkownikom wyświetlić i zmodyfikować dane. Zwróć uwagę, że żadnych poleceń SQL są niezbędne, aby wybrać, zaktualizować, usunięcia lub wstawienia rekordy.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default2.aspx#2)]  
  
 W poniższym przykładzie przedstawiono program obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Selecting> zdarzeń, która ustawia obiekt danych na podstawie wartości na stronie sieci Web.  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSourceSelectEventArgs#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceSelectEventArgs/cs/Default3.aspx.cs#3)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSourceSelectEventArgs#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceSelectEventArgs/vb/Default3.aspx.vb#3)]  
  
 W poniższym przykładzie przedstawiono <xref:System.Web.UI.WebControls.LinqDataSource> kontrolować, który jest skonfigurowany do grupy przez dwie kolumny. `Key` Właściwość odwołuje się do obiektu, który ma dwie właściwości `ProductCategory` i `Color`. Obiekt reprezentowany przez `It` ma zmienioną nazwę (alias) `Products`. Zmieniono nazwę `Products` obiektu zawiera kolekcję pojedynczych rekordów w grupowanie. Każde wystąpienie będzie zawierać wszystkie kolumny z `Products` tabeli.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.GroupBy#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.GroupBy#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/vb/Default.aspx#1)]  
  
 Poniższy przykład przedstawia dwa <xref:System.Web.UI.WebControls.ListView> formantów, które są wyświetlane dane z <xref:System.Web.UI.WebControls.LinqDataSource> kontroli w poprzednim przykładzie. Jeden <xref:System.Web.UI.WebControls.ListView> kontrolka ma wyświetlać pogrupowanych danych, a drugi <xref:System.Web.UI.WebControls.ListView> kontroli Wyświetla nazwy poszczególnych produktów, które należą do tej grupy. Zagnieżdżony formant powiązany z danymi <xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A> właściwość jest ustawiona na `Products`, która jest alias `It` obiektu.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.GroupBy#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/cs/Default.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.GroupBy#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/vb/Default.aspx#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LinqDataSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LinqDataSource();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoGenerateOrderByClause">
      <MemberSignature Language="C#" Value="public bool AutoGenerateOrderByClause { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoGenerateOrderByClause" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoGenerateOrderByClause As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoGenerateOrderByClause { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> kontroli dynamicznie tworzy klauzuli Order By, na podstawie wartości w <see cref="P:System.Web.UI.WebControls.LinqDataSource.OrderByParameters" /> kolekcji.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> kontroli tworzy klauzuli Order By; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas ustawiania <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A> właściwości `true`, <xref:System.Web.UI.WebControls.LinqDataSource> kontroli dynamicznie tworzy klauzuli Order By, która jest oparta na wartości znajdujące się w <xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A> kolekcji. <xref:System.Web.UI.WebControls.LinqDataSource> Kontroli dane są sortowane według pierwszy parametr i dodatkowo sortuje dane dla każdego dodatkowego parametru. Parametry, które zawierają `null` lub wartość pustą nie znajdują się w klauzuli Order By.  
  
 Nie ustawiaj <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> właściwości podczas <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A> ma ustawioną wartość `true`, ponieważ analizator dynamicznie tworzy klauzuli Order By. <xref:System.Web.UI.WebControls.LinqDataSource> Kontroli zgłasza wyjątek, jeśli <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A> ustawiono `true` i <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> właściwości przypisano wartości.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono <xref:System.Web.UI.WebControls.LinqDataSource> sterować za pomocą <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A> ustawioną `true`. Parametr jest uwzględniona w <xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A> kolekcji, która porządkuje danych na podstawie właściwości nazw, które użytkownik wybiera z <xref:System.Web.UI.WebControls.DropDownList> formantu.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#8](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default8.aspx#8)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#8](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default8.aspx#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoGenerateWhereClause">
      <MemberSignature Language="C#" Value="public bool AutoGenerateWhereClause { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoGenerateWhereClause" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoGenerateWhereClause As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoGenerateWhereClause { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.AutoGenerateWhereClause</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> kontroli dynamicznie tworzy Where klauzuli na podstawie wartości zdefiniowane w <see cref="P:System.Web.UI.WebControls.LinqDataSource.WhereParameters" /> kolekcji.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> kontrolki spowoduje utworzenie Where klauzuli; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas ustawiania <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A> właściwości `true`, <xref:System.Web.UI.WebControls.LinqDataSource> kontroli dynamicznie tworzy Where klauzuli z parametrów w <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> kolekcji. Każdego parametru dodawanego do <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> , Kolekcja musi mieć jego <xref:System.Web.UI.WebControls.Parameter.Name%2A> właściwość, ustaw wartość odpowiadającą właściwością w obiekcie danych, którego dotyczy zapytanie. Automatycznie wygenerowany gdzie klauzuli sprawdzi, czy określona wartość w <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> kolekcji jest równa wartości zgodnej właściwości w obiekcie danych. Jeśli podasz więcej niż jeden parametr parametry są połączone funkcją logiczną `AND` operacji. Parametry, które zawierają `null` lub wartość pustą nie są uwzględniane w klauzuli.  
  
 Automatycznie wygenerowany <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> klauzuli można przetestować tylko pod względem równości i połączyć parametry tylko z `AND` operacji. Nie ustawiaj <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A> właściwości `true` Jeśli trzeba dodać warunek, który nie sprawdza pod kątem równości lub jeśli zajdzie potrzeba dotyczą parametrów z `OR` operacji. Te zadania można wykonać przez ustawienie <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A> właściwości `false` i Dodawanie zastępczych w <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> właściwości dla każdego parametru w <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> kolekcji. W <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> właściwości każdej nazwie symbol zastępczy jest poprzedzony znakiem @.  
  
 Nie ustawiaj <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> właściwości podczas <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A> właściwość jest `true`, ponieważ analizator dynamicznie tworzy Where klauzuli. <xref:System.Web.UI.WebControls.LinqDataSource> Kontroli zgłasza wyjątek, jeśli <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A> właściwość jest `true` i <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> właściwości przypisano wartości.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono <xref:System.Web.UI.WebControls.LinqDataSource> sterować za pomocą <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A> ustawioną `true`. A <xref:System.Web.UI.WebControls.GridView> kontrolka jest powiązana z <xref:System.Web.UI.WebControls.LinqDataSource> formantu, aby wyświetlić dane, które jest zwróconych przez kwerendę. A <xref:System.Web.UI.WebControls.DropDownList> jest dostępny czyli wypełniane przy użyciu trzech wartości. Parametr jest uwzględniona w <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> kolekcji o nazwie ustawioną `Category,` zgodnej z jednej z właściwości obiektu danych. Jego <xref:System.Web.UI.WebControls.ControlParameter.ControlID%2A> właściwość jest ustawiona na identyfikator <xref:System.Web.UI.WebControls.DropDownList> formantu. <xref:System.Web.UI.WebControls.LinqDataSource> Formant automatycznie tworzy <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> właściwości do filtrowania rekordów oparta na wartości, która użytkownik wybiera z <xref:System.Web.UI.WebControls.DropDownList> formantu. Zapytanie zwraca rekordy których `Category` właściwości zgodna z wartością użytkownik wybrał z <xref:System.Web.UI.WebControls.DropDownList> formantu.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default7.aspx#7)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default7.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoPage">
      <MemberSignature Language="C#" Value="public bool AutoPage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.AutoPage" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoPage As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoPage { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> sterowanie obsługuje nawigację fragmentów danych w czasie wykonywania.</summary>
        <value>
          <see langword="true" /> Jeśli użytkownik może przeglądania danych; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw <xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A> właściwości `true` Aby włączyć stronicowanie w <xref:System.Web.UI.WebControls.LinqDataSource> formantu. Aby umożliwić użytkownikowi przeglądanie danych, należy połączyć formantu powiązanego z danymi, który udostępnia interfejs umożliwiający stronicowania, aby <xref:System.Web.UI.WebControls.LinqDataSource> formantu. Gdy <xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A> właściwość jest ustawiona na `true`, <xref:System.Web.UI.WebControls.LinqDataSource> kontroli pobiera tylko wystarczającej liczby rekordów na jednej stronie formantu powiązanego z danymi. Używa <xref:System.Linq.Enumerable.Skip%2A> i <xref:System.Linq.Enumerable.Take%2A> metody w celu pobrania rekordów dla bieżącej strony.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono <xref:System.Web.UI.WebControls.LinqDataSource> sterować za pomocą <xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A> ustawioną właściwość `true` i <xref:System.Web.UI.WebControls.GridView> formant, który jest powiązany z <xref:System.Web.UI.WebControls.LinqDataSource> formantu. <xref:System.Web.UI.WebControls.GridView.AllowPaging%2A> Właściwość <xref:System.Web.UI.WebControls.GridView> kontrola jest ustawiona na `true` zapewnia interfejs, umożliwiający użytkownikom Przejrzyj dane.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSort">
      <MemberSignature Language="C#" Value="public bool AutoSort { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSort" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.AutoSort" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoSort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoSort { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> sterowanie obsługuje sortowanie danych w czasie wykonywania.</summary>
        <value>
          <see langword="true" /> Jeśli użytkownik może sortować dane; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource> Kontrolka obsługuje dwa podejścia do sortowania danych. Można użyć <xref:System.Web.UI.WebControls.LinqDataSource.AutoSort%2A> można ustawić właściwości, aby włączyć sortowanie w czasie wykonywania, lub <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> właściwości, aby zdefiniować sortowania w czasie projektowania.  
  
 Ustaw <xref:System.Web.UI.WebControls.LinqDataSource.AutoSort%2A> właściwości `true` Aby włączyć sortowanie w <xref:System.Web.UI.WebControls.LinqDataSource> formant, który jest oparty na wyrażenia sortowania z formantu powiązanego z danymi. Kontrolki powiązane z danymi udostępnia interfejs, który umożliwia użytkownikowi wybranie w czasie wykonywania, które właściwości można użyć do sortowania.  
  
 Programowo można ustawić kolejność, w którym dane są zwracane przez ustawienie <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> właściwości z właściwością lub właściwości używane do sortowania. Gdy <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> właściwość ma ustawioną właściwość i <xref:System.Web.UI.WebControls.LinqDataSource.AutoSort%2A> właściwość jest `true`, wyrażenia sortowania z formantu powiązanego z danymi jest stosowana po wyrażeniu w <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> właściwości. W związku z tym określa końcowego sortowania danych.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono <xref:System.Web.UI.WebControls.LinqDataSource> sterować za pomocą <xref:System.Web.UI.WebControls.LinqDataSource.AutoSort%2A> ustawioną właściwość `true` i <xref:System.Web.UI.WebControls.GridView> formant, który jest powiązany z <xref:System.Web.UI.WebControls.LinqDataSource> formantu. <xref:System.Web.UI.WebControls.GridView.AllowSorting%2A> Właściwość <xref:System.Web.UI.WebControls.GridView> kontrola jest ustawiona na `true` zapewnia interfejs, umożliwiający użytkownikom posortuj dane.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextCreated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; ContextCreated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; ContextCreated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.ContextCreated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextCreated As EventHandler(Of LinqDataSourceStatusEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceStatusEventArgs ^&gt; ^ ContextCreated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po utworzeniu wystąpienia obiektu typu kontekstu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsługa <xref:System.Web.UI.WebControls.LinqDataSource.ContextCreated> zdarzeń, aby sprawdzić obiekt typ kontekstu lub sprawdź wyjątki, które są generowane podczas tworzenia obiektu. Pobierz obiekt typu kontekstu z <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Result%2A> właściwość <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs> obiektu, który jest skojarzony z tym zdarzeniem. Pobrać wyjątek zgłoszony podczas operacji danych z <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A> właściwości.  
  
 Obiekt typu kontekstu jest tworzona podczas select, aktualizowania, wstawiania i operacji usunięcia i zostanie ponownie użyty w żądaniu.  
  
 Istnieje jeden raz, jeśli zdarzenie nie jest wywoływane. Jest to w przypadku programowane Ustawianie <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Result%2A> właściwości do obiektu podczas <xref:System.Web.UI.WebControls.LinqDataSource.Selecting> zdarzeń. Dodatkowy warunek jest, że oryginalne wartości nie musi być przechowywane w widoku stanu lub obiekt w <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Result%2A> implementuje właściwości <xref:System.Data.Linq.ITable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextCreating">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceContextEventArgs&gt; ContextCreating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceContextEventArgs&gt; ContextCreating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.ContextCreating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextCreating As EventHandler(Of LinqDataSourceContextEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceContextEventArgs ^&gt; ^ ContextCreating;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceContextEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje przed utworzeniem wystąpienia obiektu typu kontekstu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Web.UI.WebControls.LinqDataSource> kontroli tworzy wystąpienia typu określonego w <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A> właściwości. <xref:System.Web.UI.WebControls.LinqDataSource> Kontroli wywołuje konstruktor domyślny obiektu kontekstu danych można utworzyć wystąpienia obiektu. Możliwe, że z korzystaniem z systemem innym niż domyślny konstruktor lub należy utworzyć obiekt, który różni się od określonej w <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A> właściwości. W takim przypadku musi obsługiwać <xref:System.Web.UI.WebControls.LinqDataSource.ContextCreating> zdarzeń i ręcznie utworzyć obiekt kontekstu danych.  
  
 Obiekt typu kontekst został utworzony podczas select, aktualizowania, wstawiania i operacji usuwania.  
  
 Istnieje jeden raz, jeśli zdarzenie nie jest wywoływane. Jest to w przypadku programowane Ustawianie <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Result%2A> właściwości do obiektu w obsłudze zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Selecting> zdarzeń. Dodatkowy warunek jest, że oryginalne wartości nie musi być przechowywane w widoku stanu lub obiekt w <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Result%2A> implementuje właściwości <xref:System.Data.Linq.ITable> interfejsu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak można utworzyć obiektu kontekstu danych za pomocą konstruktora domyślnego z systemem innym niż podczas <xref:System.Web.UI.WebControls.LinqDataSource.ContextCreating> zdarzeń. Kod przypisuje obiekt do <xref:System.Web.UI.WebControls.LinqDataSourceContextEventArgs.ObjectInstance%2A> właściwości.  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.ContextCreating#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.ContextCreating/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.ContextCreating#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.ContextCreating/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextDisposing">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDisposeEventArgs&gt; ContextDisposing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceDisposeEventArgs&gt; ContextDisposing" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.ContextDisposing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextDisposing As EventHandler(Of LinqDataSourceDisposeEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceDisposeEventArgs ^&gt; ^ ContextDisposing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDisposeEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje przed disposing obiekt typu kontekstu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsługi <xref:System.Web.UI.WebControls.LinqDataSource.ContextDisposing> zdarzeń do usunięcia obiektu ręcznie lub wykonania oczyszczania, które są specyficzne dla obiekt przed obiekt zostanie zniszczony.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextTypeName">
      <MemberSignature Language="C#" Value="public override string ContextTypeName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContextTypeName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.ContextTypeName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContextTypeName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContextTypeName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę typu, który zawiera właściwość, którego wartość ma dane, które ma zostać pobrane.</summary>
        <value>Nazwa klasy można pobrać danych z.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz <xref:System.Web.UI.WebControls.LinqDataSource> sterowania do pobierania danych z zbierania danych w pamięci lub bazy danych, należy określić dwie właściwości. Pierwsza to klasa kontekstu danych, które reprezentuje źródło danych. Drugim jest właściwość klasy kontekstu danych, która zawiera dane. Możesz ustawić <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A> właściwość na nazwę klasy kontekstu danych, a wartość <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> właściwości do zbierania danych, która zawiera dane.  
  
 Na przykład podczas pobierania danych z bazy danych, ustaw <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A> właściwość na nazwę klasy, która reprezentuje bazy danych. Również ustawić <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> właściwości właściwość, która reprezentuje tabeli w bazie danych. Aby wygenerować klas z bazy danych, należy użyć [!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)] lub narzędzie SqlMetal.exe w celu automatycznego wygenerowania tych klas.  
  
 Podczas pobierania danych z kolekcji danych w pamięci, takich jak tablicy, ustaw <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A> nazwę klasy, który zawiera właściwości tablicy dla właściwości. Następnie ustaw <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> właściwości dla właściwości, która pobiera tablicy.  
  
 Aby włączyć automatyczną aktualizację, wstawiania lub usuwania operacji za pomocą <xref:System.Web.UI.WebControls.LinqDataSource> kontrolować klasy przypisanej <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A> właściwości musi pochodzić od <xref:System.Data.Linq.DataContext>. Ponadto właściwość przypisane do <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> właściwości musi pochodzić od <xref:System.Data.Linq.Table%601>. Jeśli nie wymagają aby włączyć automatyczną aktualizację, wstawiania lub usuwanie operacji, można przypisać nazwy dowolnego typu klasy, aby <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A> właściwości.  
  
 Aby uzyskać informacje o wybieraniu danych z wystąpienia klasy, zobacz <xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs.Result%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób ustawiania <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A> właściwości do klasy, która zawiera tablicę ciągów. Przedstawiono również sposób ustawiania właściwości do klasy (generowane przez [!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)]) reprezentujący bazy danych.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/cs/Default.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/vb/Default.aspx#2)]  
  
 Klasa o nazwie `ExampleDataContext` czy reprezentuje tabeli bazy danych nie jest widoczne w tym przykładzie. Na przykład do pracy tej klasy należy utworzyć przez dodanie klasy LINQ do SQL o nazwie Example.dbml i przeciągając tabeli o nazwie filmu na [!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)]. Klasa o nazwie `ExampleDataContext` z właściwości o nazwie `Movies` jest generowany.  
  
 W poniższym przykładzie przedstawiono klasę o nazwie `MovieLibrary` mowa w <xref:System.Web.UI.WebControls.LinqDataSource> formantu.  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/cs/App_Code/MovieLibrary.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/vb/App_Code/MovieLibrary.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateQueryableView">
      <MemberSignature Language="C#" Value="protected override System.Web.UI.WebControls.QueryableDataSourceView CreateQueryableView ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.WebControls.QueryableDataSourceView CreateQueryableView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.CreateQueryableView" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateQueryableView () As QueryableDataSourceView" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Web::UI::WebControls::QueryableDataSourceView ^ CreateQueryableView();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.QueryableDataSourceView</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kolejność widoku.</summary>
        <returns>Kolejność widoku.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateView">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.LinqDataSourceView CreateView ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.LinqDataSourceView CreateView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.CreateView" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateView () As LinqDataSourceView" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::LinqDataSourceView ^ CreateView();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.LinqDataSourceView</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nowe wystąpienie klasy <see cref="T:System.Web.UI.WebControls.LinqDataSourceView" /> klasy, która jest skojarzona z tym formantem.</summary>
        <returns>Obiekt, który działa jako interfejs dla formantów powiązanych z danymi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby podać niestandardowy widok, można przesłonić tę metodę w klasie pochodnej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public int Delete (System.Collections.IDictionary keys, System.Collections.IDictionary oldValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Delete(class System.Collections.IDictionary keys, class System.Collections.IDictionary oldValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.Delete(System.Collections.IDictionary,System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function Delete (keys As IDictionary, oldValues As IDictionary) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Delete(System::Collections::IDictionary ^ keys, System::Collections::IDictionary ^ oldValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.IDictionary" />
        <Parameter Name="oldValues" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="keys">Wartości klucza wiersza dla rekordy do usunięcia.</param>
        <param name="oldValues">Wartości wierszy, które są oceniane w celu wykrycia konfliktów danych.</param>
        <summary>Wykonuje operację usuwania.</summary>
        <returns>Liczba zmodyfikowanych przez operację usuwania rekordów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj nie trzeba wywołać <xref:System.Web.UI.WebControls.LinqDataSource.Delete%2A> metody w kodzie. Jeśli używasz <xref:System.Web.UI.WebControls.LinqDataSource> automatycznie wywoła kontroli z formantem powiązane z danymi formantu powiązanego z danymi <xref:System.Web.UI.WebControls.LinqDataSource.Delete%2A> metody, gdy użytkownik wykona akcję, aby usunąć rekord. Jawnie wywołać <xref:System.Web.UI.WebControls.LinqDataSource.Delete%2A> metody, jeśli chcesz utworzyć własny proces usuwania danych. Na przykład można wywołać <xref:System.Web.UI.WebControls.LinqDataSource.Delete%2A> metody, jeśli chcesz usunąć rekord na podstawie zdarzenia poza kontrolą powiązane z danymi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deleted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Deleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Deleted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Deleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleted As EventHandler(Of LinqDataSourceStatusEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceStatusEventArgs ^&gt; ^ Deleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zakończeniu operacji usuwania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsługa <xref:System.Web.UI.WebControls.LinqDataSource.Deleted> zdarzeń catch wszelkie wyjątki przez operację usuwania lub Sprawdź parametry wyjściowe po zakończeniu operacji. Parametry wyjściowe można pobrać <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs> obiekt, który zostanie przekazany do procedury obsługi zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection DeleteParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection DeleteParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.DeleteParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeleteParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ DeleteParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ta właściwość nie jest używana przez <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> klasy.</summary>
        <value>Kolekcja parametrów.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Deleting">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs&gt; Deleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs&gt; Deleting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Deleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleting As EventHandler(Of LinqDataSourceDeleteEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceDeleteEventArgs ^&gt; ^ Deleting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje przed wykonaniem operacji delete.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsługa <xref:System.Web.UI.WebControls.LinqDataSource.Deleting> zdarzeń do sprawdzania poprawności obiektu do usunięcia, aby sprawdzić błędy sprawdzania poprawności danych z klasy danych, aby zmienić wartość przed operacją delete lub anulować operację usuwania. <xref:System.Web.UI.WebControls.LinqDataSource> Kontrola przechodzi <xref:System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs> obiekt do obsługi zdarzeń <xref:System.Web.UI.WebControls.LinqDataSource.Deleting> zdarzeń. <xref:System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs> Obiekt zawiera dane, które zostaną usunięte i pozwala anulować operację usuwania. Jeśli dane klasy zgłasza <xref:System.Web.UI.WebControls.LinqDataSourceValidationException> wyjątek, <xref:System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs> obiekt zawiera ten wyjątek w <xref:System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs.Exception%2A> właściwości.  
  
 Jeśli jest zwracany wyjątek w obsłudze zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Deleting> zdarzeń, musi obsługiwać wyjątek w tej obsłudze zdarzeń. Wyjątek nie zostaną przekazane do programu obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Deleted> zdarzenia (za pośrednictwem <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A> właściwość <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs> obiektu). <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A> Właściwość zawiera tylko wyjątki, które są generowane po <xref:System.Web.UI.WebControls.LinqDataSource.Deleting> zdarzeń.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono program obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Deleting> zdarzeń. Kod anuluje operację usuwania na podstawie właściwości w <xref:System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs.OriginalObject%2A> właściwości i wartości ze strony sieci Web. W tym przykładzie podczas `OnSale` właściwość jest ustawiona na `true`, użytkownik musi wybrać <xref:System.Web.UI.WebControls.CheckBox> sterowania, aby upewnić się, że należy usunąć rekord.  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.Deleting#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Deleting/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.Deleting#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Deleting/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableDelete">
      <MemberSignature Language="C#" Value="public bool EnableDelete { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableDelete" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.EnableDelete" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableDelete As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableDelete { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.EnableDelete</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy można usunąć rekordów danych za pośrednictwem <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> formantu.</summary>
        <value>
          <see langword="true" /> Jeśli włączono automatyczne usuwanie operacji; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw <xref:System.Web.UI.WebControls.LinqDataSource.EnableDelete%2A> właściwości `true` aby użytkownicy mogli usunąć rekord danych za pośrednictwem <xref:System.Web.UI.WebControls.LinqDataSource> formantu. Gdy <xref:System.Web.UI.WebControls.LinqDataSource.EnableDelete%2A> jest `true`, <xref:System.Web.UI.WebControls.LinqDataSource> kontroli używa LINQ do SQL do automatycznego tworzenia polecenie, aby usunąć dane. Musi zawierać interfejs, który umożliwia użytkownikom wybór rekord, aby usunąć, takich jak <xref:System.Web.UI.WebControls.DetailsView> formantu.  
  
 <xref:System.Web.UI.WebControls.LinqDataSource> Formant nie obsługuje operacji automatycznego usuwania podczas <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości lub <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwość jest ustawiona. W takim przypadku <xref:System.Web.UI.WebControls.LinqDataSource> kontroli zgłasza wyjątek, jeśli zostanie podjęta próba operacji usuwania.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono <xref:System.Web.UI.WebControls.LinqDataSource> formantu, który ma <xref:System.Web.UI.WebControls.LinqDataSource.EnableDelete%2A> ustawioną `true`. A <xref:System.Web.UI.WebControls.DetailsView> kontroli wyświetla dane i tworzy przycisku, który pozwala użytkownikom na usuwanie rekordu danych.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default2.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableInsert">
      <MemberSignature Language="C#" Value="public bool EnableInsert { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableInsert" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.EnableInsert" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableInsert As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableInsert { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.EnableInsert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy rekordy danych mogą być wstawiane przez <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> formantu.</summary>
        <value>
          <see langword="true" /> Jeśli są włączone operacje automatycznego wstawiania; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw <xref:System.Web.UI.WebControls.LinqDataSource.EnableInsert%2A> właściwości `true` aby umożliwić użytkownikom wstawić nowy rekord danych za pośrednictwem <xref:System.Web.UI.WebControls.LinqDataSource> formantu. Gdy <xref:System.Web.UI.WebControls.LinqDataSource.EnableInsert%2A> jest `true`, <xref:System.Web.UI.WebControls.LinqDataSource> kontroli używa LINQ do SQL do automatycznego tworzenia polecenie, aby wstawić dane. Musi zawierać interfejs, który umożliwia użytkownikom wstawić nowy rekord, takich jak <xref:System.Web.UI.WebControls.DetailsView> formantu.  
  
 <xref:System.Web.UI.WebControls.LinqDataSource> Formant nie obsługuje operacji wstawiania automatyczne podczas <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości lub <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwość jest ustawiona. W takim przypadku <xref:System.Web.UI.WebControls.LinqDataSource> kontroli zgłasza wyjątek, jeśli zostanie podjęta próba operacji wstawiania.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono <xref:System.Web.UI.WebControls.LinqDataSource> formantu, który ma <xref:System.Web.UI.WebControls.LinqDataSource.EnableInsert%2A> ustawioną `true`. A <xref:System.Web.UI.WebControls.DetailsView> wyświetla dane i wyświetla przycisku, który zmienia formantu do wstawienia tryb, w którym użytkownicy mogą tworzyć i Zapisz nowy rekord kontroli.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default2.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableObjectTracking">
      <MemberSignature Language="C#" Value="public bool EnableObjectTracking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableObjectTracking" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.EnableObjectTracking" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableObjectTracking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableObjectTracking { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy są śledzone zmiany obiektu kontekstu danych.</summary>
        <value>
          <see langword="true" /> Jeśli obiekt kontekstu danych śledzenia zmian; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource.EnableObjectTracking%2A> Właściwość jest używana tylko podczas wybierania danych z obiektu kontekstu danych LINQ do SQL.  
  
 Gdy użytkownik korzysta z danych tylko do odczytu, ustawienie <xref:System.Web.UI.WebControls.LinqDataSource.EnableObjectTracking%2A> właściwości `false` zwiększa wydajność, ponieważ dane nie są buforowane ustalenie, jeśli została ona zmieniona. Jednak on również wyłącza wykonywanie zapytań odroczonych. Ta właściwość musi mieć ustawioną `true` Jeśli chcesz używać do wykonywania zapytań odroczonych.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" />
      </Docs>
    </Member>
    <Member MemberName="EnableUpdate">
      <MemberSignature Language="C#" Value="public bool EnableUpdate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableUpdate" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.EnableUpdate" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableUpdate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableUpdate { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.EnableUpdate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy rekordy danych może być aktualizowana za pośrednictwem <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> formantu.</summary>
        <value>
          <see langword="true" /> Jeśli włączono automatyczną aktualizację operacji; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw <xref:System.Web.UI.WebControls.LinqDataSource.EnableUpdate%2A> właściwości `true` aby umożliwić użytkownikom zaktualizować rekord danych przy użyciu <xref:System.Web.UI.WebControls.LinqDataSource> formantu. Gdy <xref:System.Web.UI.WebControls.LinqDataSource.EnableUpdate%2A> jest `true`, <xref:System.Web.UI.WebControls.LinqDataSource> kontroli używa LINQ do SQL do automatycznego tworzenia polecenie, aby zaktualizować dane. Musi zawierać interfejs, który umożliwia użytkownikom zaktualizowania rekordu, takich jak <xref:System.Web.UI.WebControls.DetailsView> formantu.  
  
 <xref:System.Web.UI.WebControls.LinqDataSource> Formant nie obsługuje operacji aktualizacji automatycznych przy <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości lub <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwość jest ustawiona. W takim przypadku <xref:System.Web.UI.WebControls.LinqDataSource> kontroli zgłasza wyjątek, jeśli zostanie podjęta próba operacji aktualizacji.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono <xref:System.Web.UI.WebControls.LinqDataSource> formantu, który ma <xref:System.Web.UI.WebControls.LinqDataSource.EnableUpdate%2A> ustawioną `true`. A <xref:System.Web.UI.WebControls.DetailsView> kontroli wyświetla dane i tworzy przycisk umożliwiający użytkownikom aktualizowanie rekordu danych.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default2.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupBy">
      <MemberSignature Language="C#" Value="public string GroupBy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string GroupBy" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.GroupBy" />
      <MemberSignature Language="VB.NET" Value="Public Property GroupBy As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ GroupBy { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, właściwości, które są używane do grupowania pobrane dane.</summary>
        <value>Ciąg, który jest używany do tworzenia w klauzuli Group By.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwości w celu określenia właściwości, które są używane do konsolidacji rekordów danych, które mają takie same wartości. Na przykład jeśli ustawisz <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwości `Name`, wszystkie rekordy w zapytaniu, które mają taki sam `Name` wartość właściwości są zwracane jako pojedynczy rekord skonsolidowany.  
  
 Można przypisać więcej niż jedną właściwość do <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwości umieszczając wszystkie właściwości w `new` funkcji i oddzielając każdej właściwości za pomocą przecinka. Na przykład do grupy za pomocą właściwości `Name` , a następnie `Category`ustaw <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwości `new(Name, Category)`.  
  
 Wartości właściwości, które są używane do grupowania są zwracane przez wygenerowanej właściwości o nazwie `Key`. Możesz uwzględnić `Key` właściwości w <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości do pobrania grupowanych wartości. Można ustawić `Key` właściwości aliasu przy użyciu `As` — słowo kluczowe, ale nie muszą korzystać z aliasu. Na przykład można ustawić <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwości do właściwości o nazwie `Category`. Można pobrać wartości skonsolidowanego z `Category` właściwości przez ustawienie <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości `new(Key As ProductCategory)`.  
  
 Aby dostęp do poszczególnych rekordów grupowanie, w tym `It` właściwości w <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości. `It` Właściwość zawiera zestaw rekordów, które mają wartość we właściwości grupowanych. Można przejść przez `It` właściwości w celu pobrania poszczególnych rekordów.  
  
 <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> Jest często używana z metody agregacji. Można użyć następujących metod agregacji:  
  
-   `Count()`  
  
-   `Average(` *column* `)`  
  
-   `Sum(` *column* `)`  
  
-   `Max(` *column* `)`  
  
-   `Min(` *column* `)`  
  
-   `Where(` *Warunek* `)`  
  
-   `Any()`  
  
-   `All(` *Warunek* `)`  
  
 Aby uzyskać więcej informacji, zobacz [NIB: omówienie kontrolki serwera sieci Web LinqDataSource](http://msdn.microsoft.com/library/104cfc3f-7385-47d3-8a51-830dfa791136) i [jak: grupy i agregacji danych za pomocą formantu LinqDataSource](http://msdn.microsoft.com/library/b922cf69-251f-4158-b405-ea960993a1af).  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono <xref:System.Web.UI.WebControls.LinqDataSource> formant, który grupuje dane zwrócone przez właściwość o nazwie `Category`. Zwraca wartości udostępnionego, a oblicza średnią cenę grupowanych rekordów.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default3.aspx#3)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default3.aspx#3)]  
  
 W poniższym przykładzie przedstawiono <xref:System.Web.UI.WebControls.LinqDataSource> kontrolować, który jest skonfigurowany do grupy przez dwie kolumny. `Key` Właściwość odwołuje się do obiektu, który ma dwie właściwości `ProductCategory` i `Color`. Obiekt reprezentowany przez `It` zostanie zmieniona nazwa `Products`. Zmieniono nazwę `Products` obiektu zawiera kolekcję pojedynczych rekordów w grupowanie i każde wystąpienie zawiera wszystkie kolumny z tabeli Produkty.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.GroupBy#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.GroupBy#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/vb/Default.aspx#1)]  
  
 Poniższy przykład przedstawia dwa <xref:System.Web.UI.WebControls.ListView> służy do wyświetlania danych z <xref:System.Web.UI.WebControls.LinqDataSource> kontroli w poprzednim przykładzie. Jeden <xref:System.Web.UI.WebControls.ListView> kontrolka ma wyświetlać pogrupowanych danych, a druga <xref:System.Web.UI.WebControls.ListView> kontroli Wyświetla nazwy poszczególnych produktów, które należą do tej grupy. Zagnieżdżony formant powiązany z danymi <xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A> właściwość jest ustawiona na `Products`, która jest alias `It` obiektu.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.GroupBy#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/cs/Default.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.GroupBy#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/vb/Default.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupByParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection GroupByParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection GroupByParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.GroupByParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GroupByParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ GroupByParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję parametrów, które są używane do tworzenia w klauzuli Group By.</summary>
        <value>Parametry, które są używane do tworzenia w klauzuli Group By.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource> Kontroli korzysta z parametrów w <xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A> kolekcji można utworzyć w klauzuli Group By w czasie wykonywania. Zwykle nie użyjesz <xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A> kolekcji do grupowania danych. Zamiast tego można użyć <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwości. Możesz użyć <xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A> kolekcji tylko wtedy, gdy wartości w klauzuli Group By musi zostać ustawiona w czasie wykonywania, a ta wartość nie jest nazwą właściwości. Na przykład użyć <xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A> kolekcji do grupowania danych na ich podstawie `LastName` właściwości w rekordach danych jest równa wartości podanego przez użytkownika.  
  
 Jeśli chcesz dane grupy według właściwości tej właściwości nie muszą być ustawione w czasie wykonywania, można zdefiniować właściwości grupowania w <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwości. Na przykład, aby zwrócić wartości z tabeli bazy danych pogrupowane według `LastName`ustaw <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> "LastName" bez parametrów. Jeśli chcesz dynamicznie dane grupy według właściwości utworzyć programu obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Selecting> zdarzeń i dostosować <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwości zgodnie z potrzebami.  
  
 Nazwa właściwości nie można przypisać jako wartość parametru w <xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A> kolekcji. Dodawanie parametrów do <xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A> kolekcji, jeśli chcesz dodać warunek <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwość, która musi być ustawiona w czasie wykonywania.  
  
 Aby ustawić wartości <xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A> kolekcji, należy przypisać nazwę każdego parametru i dodać element zastępczy w <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwość o nazwie parametru. W klauzuli Group By każdej nazwie parametru jest poprzedzony znakiem @.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public int Insert (System.Collections.IDictionary values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Insert(class System.Collections.IDictionary values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.Insert(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (values As IDictionary) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Insert(System::Collections::IDictionary ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="values">Wartości wierszy można wstawiać do źródła danych.</param>
        <summary>Wykonuje operację wstawiania.</summary>
        <returns>Liczba wierszy wpływ operacji insert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj nie trzeba wywołać <xref:System.Web.UI.WebControls.LinqDataSource.Insert%2A> metody w kodzie. Automatycznie wywoła formantu powiązanego z danymi <xref:System.Web.UI.WebControls.LinqDataSource.Insert%2A> metody, gdy użytkownik wykona akcję, aby wstawić nowy rekord. Jawnie wywołać <xref:System.Web.UI.WebControls.LinqDataSource.Insert%2A> metody, gdy chcesz utworzyć procesu do wstawiania danych.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak programowo wstawić nowy rekord w źródle danych, po kliknięciu przycisku. Przekazuje kod <xref:System.Collections.Specialized.ListDictionary> obiekt zawierający domyślne wartości do <xref:System.Web.UI.WebControls.LinqDataSource.Insert%2A> metody.  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.Insert#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Insert/cs/Default2.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Insert/vb/Default2.aspx.vb#1)]  
  
 W poniższym przykładzie pokazano kod znaczników w poprzednim przykładzie.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.Insert#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Insert/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.Insert#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Insert/vb/Default2.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Inserted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Inserted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Inserted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Inserted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Inserted As EventHandler(Of LinqDataSourceStatusEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceStatusEventArgs ^&gt; ^ Inserted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zakończeniu operacji wstawiania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsługa <xref:System.Web.UI.WebControls.LinqDataSource.Inserted> zdarzenia można przechwytywać wszelkie wyjątki przez operację wstawiania lub do sprawdzenia wartości po zakończeniu operacji insert. Możesz pobrać nowe wartości za pośrednictwem <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs> obiekt, który zostanie przekazany do procedury obsługi zdarzeń. Na przykład można użyć <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs> obiekt, aby pobrać właściwość identity wygenerowanych przez bazę danych dla nowego rekordu danych.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć programu obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Inserted> zdarzenie, które sprawdza, czy wyjątki i pobiera właściwość tożsamości dla nowego rekordu.  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSourceStatusEventArgs#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceStatusEventArgs/cs/Default.aspx#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSourceStatusEventArgs#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceStatusEventArgs/vb/Default.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Inserting">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceInsertEventArgs&gt; Inserting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceInsertEventArgs&gt; Inserting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Inserting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Inserting As EventHandler(Of LinqDataSourceInsertEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceInsertEventArgs ^&gt; ^ Inserting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceInsertEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje przed wykonaniem operacji insert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsługa <xref:System.Web.UI.WebControls.LinqDataSource.Inserting> zdarzenia w celu zweryfikowania obiekt ma zostać wstawiony, aby sprawdzić błędy sprawdzania poprawności danych z klasy danych, aby zmienić wartość przed wykonaniem operacji wstawiania lub anulować operacji insert. <xref:System.Web.UI.WebControls.LinqDataSourceInsertEventArgs> Obiekt przekazany do procedury obsługi zdarzeń dla tego zdarzenia zawiera nowy obiekt do wstawienia w źródle danych.  
  
 Jeśli wystąpi błąd sprawdzania poprawności podczas operacji wstawiania <xref:System.Web.UI.WebControls.LinqDataSourceInsertEventArgs> obiekt zawiera wyjątki sprawdzania poprawności, które są generowane przez klasy danych. Jeśli wartości do wstawienia nie jest zgodny z typem właściwości w klasie danych lub nie zostały spełnione sprawdzanie poprawności niestandardowego wystąpienia błędu weryfikacji. W obsłudze zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Inserting> zdarzeń, może pobrać wyjątki poprawności i podejmij odpowiednią akcję.  
  
 Jeśli jest zwracany wyjątek w obsłudze zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Inserting> zdarzeń, musi obsługiwać wyjątek w tej obsłudze zdarzeń. Wyjątek nie zostaną przekazane do programu obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Inserted> zdarzenia (za pośrednictwem <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A> właściwość <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs> obiektu). <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A> Właściwość zawiera tylko wyjątki, które są generowane po <xref:System.Web.UI.WebControls.LinqDataSource.Inserting> zdarzeń.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono program obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Inserting> zdarzenie, które modyfikuje danych przed wykonaniem operacji insert. Obiekt z <xref:System.Web.UI.WebControls.LinqDataSourceInsertEventArgs.NewObject%2A> właściwości jest rzutowane na typu o nazwie `Product`. `DateModified` Właściwość `Product` obiektu jest ustawiona na bieżącą datę i godzinę.  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.Inserting#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Inserting/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.Inserting#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Inserting/vb/Default.aspx.vb#1)]  
  
 W poniższym przykładzie przedstawiono program obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Inserting> zdarzenie, które pobiera wyjątki poprawności.  
  
```vb  
Protected Sub LinqDataSource_Inserting(ByVal sender As Object, _  
        ByVal e As LinqDataSourceInsertEventArgs)  
    If (e.Exception IsNot Nothing) Then  
        For Each innerException As KeyValuePair(Of String, Exception) _  
               In e.Exception.InnerExceptions  
            Label1.Text &= innerException.Key & ": " & _  
                innerException.Value.Message & "<br />"  
        Next  
        e.ExceptionHandled = True  
    End If  
End Sub  
```  
  
```csharp  
protected void LinqDataSource_Inserting(object sender,   
        LinqDataSourceInsertEventArgs e)  
{  
    if (e.Exception != null)  
    {  
        foreach (KeyValuePair<string, Exception> innerException in   
             e.Exception.InnerExceptions)  
        {  
        Label1.Text += innerException.Key + ": " +   
            innerException.Value.Message + "<br />";  
        }  
        e.ExceptionHandled = true;  
    }  
}  
```  
  
 Poprzedni przykład pobiera wyjątki poprawności. Wystąpił wyjątek może zostać zgłoszone, jeśli wartość nie jest zgodny z typem właściwości. Również może zostać wygenerowany z dostosowanych wyboru, takie jak w poniższym przykładzie. `OnAgeChanging` Metoda sprawdza, czy liczba dla `Age` właściwość nie jest ujemna.  
  
```csharp  
partial void  OnAgeChanging(int? value)  
{  
    if (value < 0)  
    {  
        throw new Exception("Age cannot be a negative number.");  
    }  
}  
```  
  
```vb  
Private Sub OnAgeChanging(ByVal value As System.Nullable(Of Integer))  
    If (value < 0) Then  
        Throw New Exception("Age cannot be a negative number.")  
    End If  
End Sub  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection InsertParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection InsertParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.InsertParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InsertParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ InsertParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję parametrów, które są używane podczas operacji wstawiania.</summary>
        <value>Parametry, które są używane podczas operacji wstawiania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle wartości, które są wymagane przez operację wstawiania są przekazywane do <xref:System.Web.UI.WebControls.LinqDataSource> kontroli przez formant powiązany z danymi. Określ parametry insert, jeśli chcesz podać wartości domyślnej wartości lub określa, czy można przekonwertować wartości puste, aby `null`. Nie trzeba podać parametr dla każdej wartość, która zostanie wstawiony tylko dla wartości, które muszą być obsługiwane, gdy użytkownik nie dostarcza wartość.  
  
 Wartości, które należy podać w <xref:System.Web.UI.WebControls.LinqDataSource.InsertParameters%2A> kolekcji są używane tylko dla pól, które zostały zdefiniowane w źródle danych, ale nie są powiązane w formancie danych. Na przykład załóżmy, że tabela bazy danych ma kolumny o nazwach nazwa, adres i KodPocztowy, ale <xref:System.Web.UI.WebControls.ListView> formant, który jest powiązany z tabelą jest powiązany tylko z polami nazwy i adresu. Wartości w <xref:System.Web.UI.WebControls.LinqDataSource.InsertParameters%2A> zbierania będzie można używać tylko w przypadku pola KodPocztowy. Będą one nie służyć do pola nazwy i adresu. Dotyczy to nawet wtedy, gdy została wprowadzona żadna wartość dla tych pól. Jeśli źródłowy pól automatycznie generuje kontrolki powiązania danych dla wszystkich pól danych, bez wartości z <xref:System.Web.UI.WebControls.LinqDataSource.InsertParameters%2A> kolekcji będą używane.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono <xref:System.Web.UI.WebControls.LinqDataSource> kontroli z parametrem, który dostarcza wartość domyślną w <xref:System.Web.UI.WebControls.LinqDataSource.InsertParameters%2A> kolekcji. Jeśli użytkownik nie ma wartości `Category` właściwość domyślną wartość, która jest dostarczana przez parametr jest zapisywany w bazie danych.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#9](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default9.aspx#9)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#9](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default9.aspx#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane dotyczące zdarzenia.</param>
        <summary>Inicjuje <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> obiektu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal override void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnUnload(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Obiekt, który zawiera dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Web.UI.Control.Unload" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OrderBy">
      <MemberSignature Language="C#" Value="public string OrderBy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OrderBy" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.OrderBy" />
      <MemberSignature Language="VB.NET" Value="Public Property OrderBy As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OrderBy { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, pola, które są używane do ustalania kolejności pobrane dane.</summary>
        <value>Ciąg, który jest używany do tworzenia klauzuli Order By.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> właściwości w celu określenia właściwości, które z zwróconych danych do użycia podczas sortowania. Właściwość sortowania danych musi istnieć w źródle danych, ale nie ma być uwzględniony w <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości. Można dodać spację i `Ascending`, `ASC`, `Descending`, lub `DESC` właściwości w <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> ciąg, aby określić, jak uporządkowanej dane są zwracane.  
  
 Możesz podać więcej niż jedną właściwość <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> właściwości, rozdzielając poszczególne właściwości za pomocą przecinka. Na przykład, aby kolejność według właściwości o nazwie `LastName` i `FirstName`ustaw <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> właściwości "Lastname, FirstName".  
  
> [!NOTE]
>  Jeśli używasz <xref:System.Web.UI.WebControls.LinqDataSource> sterować za pomocą [!INCLUDE[ss2k](~/includes/ss2k-md.md)] lub [!INCLUDE[ssEW](~/includes/ssew-md.md)] i <xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A> właściwość jest ustawiona na `true`, należy podać wartość w <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> właściwości. Domyślnie <xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A> jest właściwość `true`. Jeśli przypisanie wartości do <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości, należy również umieścić wszystkie kolumny tożsamości na liście właściwości, która jest zwracana w zapytaniu.  
  
 Jeśli <xref:System.Web.UI.WebControls.LinqDataSource.AutoSort%2A> właściwość jest ustawiona na `true`, formantu powiązanego z danymi można przekazać wyrażenia sortowania do <xref:System.Web.UI.WebControls.LinqDataSource> formantu w czasie wykonywania. <xref:System.Web.UI.WebControls.LinqDataSource> Kontroli zostaną zastosowane wyrażenie sortowania z formantu powiązanego z danymi, po zastosowaniu <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> właściwości. W związku z tym dane są zwracane zgodnie z wyrażenia sortowania z formantu powiązanego z danymi.  
  
   
  
## Examples  
 Poniższy przykład zwraca dane w odwrotnej kolejności alfabetycznej na podstawie wartości w `Category` właściwości.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default4.aspx#4)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default4.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OrderByParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection OrderByParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection OrderByParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.OrderByParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OrderByParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ OrderByParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję parametrów, które są używane do tworzenia klauzuli Order By.</summary>
        <value>Parametry, które są używane do tworzenia klauzuli Order By.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource> Kontroli korzysta z parametrów w <xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A> kolekcji można utworzyć klauzuli Order By w czasie wykonywania. Zwykle ustawiana <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A> właściwości `true` podczas dodawania parametrów do <xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A> kolekcji. Gdy <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A> właściwość jest ustawiona na `true`, każdego parametru w <xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A> kolekcji jest dodawany do klauzuli Order By w sekwencji, że są one określone w <xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A> kolekcji. Gdy <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A> właściwość jest `true`, nie trzeba nazwanych, ponieważ są stosowane w kolejności i nie są dopasowane do symbol zastępczy parametrów.  
  
 Jeśli nie ma wartości w czasie wykonywania w klauzuli Order By, nie trzeba używać <xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A> kolekcji. Można zdefiniować pól do użycia na potrzeby porządkowanie danych w <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> właściwości. Na przykład, aby zwrócić wartości z tabeli bazy danych uporządkowanych według `LastName`ustaw <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> "LastName" bez parametrów.  
  
 Można ustawić parametry <xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A> kolekcji i zgodne z parametrami symbole zastępcze w <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> właściwości, ale ta metoda ma ograniczoną aplikacji. Gdy posłuż się tą metodą, parametrów w <xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A> kolekcji nie może reprezentować nazwę kolumny. Można ustawić wartości parametru, a następnie porównaj tę wartość do wartości właściwości. Można na przykład kolejność danych w oparciu czy wartości we właściwości są mniejsze niż wartość czasu wykonywania reprezentowanego przez parametr.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono <xref:System.Web.UI.WebControls.LinqDataSource> sterować za pomocą <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A> ustawioną właściwość `true`. Parametr jest uwzględniona w <xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A> kolekcji, która porządkuje danych na podstawie właściwości nazw, które użytkownik wybiera z <xref:System.Web.UI.WebControls.DropDownList> formantu.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#8](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default8.aspx#8)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#8](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default8.aspx#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OrderGroupsBy">
      <MemberSignature Language="C#" Value="public string OrderGroupsBy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OrderGroupsBy" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy" />
      <MemberSignature Language="VB.NET" Value="Public Property OrderGroupsBy As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OrderGroupsBy { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia pola, które są używane do sortowania zgrupowanych danych.</summary>
        <value>Ciąg, który służy do tworzenia grup klauzuli Order.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A> właściwości w celu określenia sposobu sortowania grupy danych. Na przykład można grupować wg `CategoryID` właściwości i następnie Sortuj każdy identyfikator kategorii Grupuj według średnią `Price` właściwości.  
  
 Można ustawić <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A> właściwość tylko wtedy, gdy jest zgrupowaniu danych. Jeśli ustawisz <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A> właściwości bez ustawienia <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> właściwość <xref:System.Web.UI.WebControls.LinqDataSource> kontroli zgłasza wyjątek.  
  
 Właściwość, która jest używana do sortowania danych musi być właściwość, która służy do grupowania danych lub wynik funkcji agregacji na zgrupowanych danych. Aby określić, jak dane są sortowane, można dodać spację, a ciąg "Ascending", "ASC", "Malejąco" lub "Opis" do nazwy właściwości w <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A> ciągu.  
  
 Można określić więcej niż jedną właściwość <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A> właściwości. Oddziel każdej właściwości, za pomocą przecinka.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób grupowania danych za pomocą dwóch właściwości oraz sposób posortuj dane zgrupowane za pomocą jednej z tych właściwości. Dane z tabeli o nazwie `Products` jest zgrupowana za pomocą właściwości o nazwie `CategoryID` i `Discontinued`. Dane zgrupowane są sortowane według `CategoryID` właściwości.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy/vb/Default.aspx#1)]  
  
 Poniższy przykład przedstawia sposób grupowania danych przy użyciu właściwości i sposób sortowania go na podstawie wyników funkcji agregacji. Dane z `Products` tabeli jest zgrupowana za pomocą `CategoryID` właściwości. Są sortowane według średnią `UnitPrice` właściwości w każdej grupie.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy/vb/Default2.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OrderGroupsByParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection OrderGroupsByParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection OrderGroupsByParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OrderGroupsByParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ OrderGroupsByParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję parametrów, które są używane do tworzenia grup klauzuli Order.</summary>
        <value>Parametry, które są używane do tworzenia grup klauzuli Order.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource> Kontroli korzysta z parametrów w <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters%2A> kolekcji można utworzyć grupy klauzuli Order w czasie wykonywania.  
  
 Dodawanie wartości do <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters%2A> kolekcji tylko po ustawieniu wartości w czasie wykonywania w grupach klauzuli Order. Można określić pola, które są używane do kolejność danych przy użyciu <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A> właściwości.  
  
 Można ustawić parametry <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters%2A> kolekcji i zgodne z parametrami symbole zastępcze w <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A> właściwości. Jednak jeśli używasz tej metody, parametrów w <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters%2A> kolekcji nie może reprezentować nazwę kolumny; musi reprezentują wartości. Można ustawić wartości parametru, a następnie porównaj tę wartość do właściwości. Można na przykład kolejność danych w oparciu czy wartości we właściwości są mniejsze niż wartość czasu wykonywania reprezentowanego przez parametr.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public string Select { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Select" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.Select" />
      <MemberSignature Language="VB.NET" Value="Public Property Select As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Select { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia właściwości i obliczone wartości, które są objęte pobrane dane.</summary>
        <value>Ciąg, który jest używany do tworzenia klauzuli Select.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie ustawisz <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwość <xref:System.Web.UI.WebControls.LinqDataSource> kontroli pobiera wszystkie właściwości (kolumny danych) z obiektu danych. Możesz użyć <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości do pobrania podzbiór właściwości z obiektu lub do obliczania nowych wartości, podczas pobierania danych.  
  
 Określ właściwości, które można pobrać przez ustawienie <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> dla właściwości nazwy właściwości, które chcesz uwzględnić w zwróconych danych.  
  
 Jeśli pobierasz podzbiór właściwości z obiektu danych <xref:System.Web.UI.WebControls.LinqDataSource> kontroli dynamicznie tworzy klasę, która zawiera tylko właściwości określone w <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości. Klasa tworzona jest również dynamicznie Jeśli obliczania właściwości, które nie są właściwości obiektu danych. W takich przypadkach obiektów zwróconych przez kwerendę nie jest wystąpieniem klasy, która została określona w <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> właściwości. Zamiast tego należy użyć `new` metody w <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości, aby wskazać, że nowa klasa jest zwróconych przez kwerendę. Na przykład, aby zwrócić tylko `FirstName` i `LastName` właściwości z obiektu, który zawiera więcej niż te właściwości, należy ustawić <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości `new(FirstName, LastName)`. <xref:System.Web.UI.WebControls.LinqDataSource> Kontroli dynamicznie spowoduje utworzenie nowej klasy określonej w `new` metody.  
  
 Można użyć `As` — słowo kluczowe można przypisać aliasu do wybranej wartości. Po przypisaniu alias musi zawierać Aliasy właściwości w `new` metody. Każdego formantu powiązanego z danymi, który jest powiązany z wyników z <xref:System.Web.UI.WebControls.LinqDataSource> kontroli musi odwoływać się do właściwości przez alias. Na przykład jeśli ustawisz <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości `new(Region As SalesRegion, Revenue / 1000 As RevenueThousands)`, kontrolki powiązania danych mogą uzyskiwać dostęp do dwóch właściwości `SalesRegion` i `RevenueThousands`.  
  
 Możesz użyć `new` działać w <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości zgodnie z warunkami wymienione w poniższej tabeli.  
  
|Wybierz|Użycie nowego|Przykład|  
|------------|----------------|-------------|  
|Jednej właściwości.|`new` nie jest wymagany.|`Select="Category"`|  
|Wiele właściwości.|`new` wymagane.|`Select="new(Cateogry, Name)"`|  
|Jeden lub wiele właściwości, które mają alias.|`new` wymagane.|`Select="new(Category As CategoryGroup)"`|  
  
 Jeśli chcesz włączyć modyfikacji danych automatyczne, ale nie chcesz wyświetlić wszystkie właściwości z obiektu danych, nie należy ustawiać <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości. Zamiast tego należy zarządzać wyświetlanej przez formant powiązany z danymi. Jeśli używasz <xref:System.Web.UI.WebControls.DetailsView> kontroli lub <xref:System.Web.UI.WebControls.GridView> formantu, należy także ustawić <xref:System.Web.UI.WebControls.DetailsView.AutoGenerateRows%2A> lub <xref:System.Web.UI.WebControls.GridView.AutoGenerateColumns%2A> właściwości `false`. Wartości, które nie są wyświetlane w formancie powiązane z danymi są przechowywane w widoku stanu. Są one przekazywane bez zmian w źródle danych podczas aktualizacji danych.  
  
 W przypadku grupowania danych w zapytaniu, może zawierać agregacji metod w <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości. Można użyć następujących metod agregacji:  
  
-   `Count()`  
  
-   `Average(` *column* `)`  
  
-   `Sum(` *column* `)`  
  
-   `Max(` *column* `)`  
  
-   `Min(` *column* `)`  
  
-   `Where(` *Warunek* `)`  
  
-   `Any()`  
  
-   `All(` *Warunek* `)`  
  
 Aby uzyskać więcej informacji, zobacz [NIB: omówienie kontrolki serwera sieci Web LinqDataSource](http://msdn.microsoft.com/library/104cfc3f-7385-47d3-8a51-830dfa791136) i [jak: grupy i agregacji danych za pomocą formantu LinqDataSource](http://msdn.microsoft.com/library/b922cf69-251f-4158-b405-ea960993a1af).  
  
 Grupując dane mogą obejmować `Key` i `It`, które są tworzone dynamicznie właściwości, w <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości. `Key` Właściwość odwołuje się do wartości właściwości lub właściwości, które były używane do grupowania danych. Na przykład, jeśli grupowanie według właściwości o nazwie `Category`, `Key` właściwości będzie zawierać każdej unikatowej wartości w `Category` właściwości. `It` Właściwość odwołuje się do kolekcji poszczególne rekordy w metodzie grupowania danych. Można przejść przez `It` właściwość, aby pobrać poszczególne rekordy, które mają zostać skonsolidowane w operacji grupowania. Na przykład, jeśli grupowanie według właściwości o nazwie `Category`, `It` właściwość zawiera wszystkie poszczególne rekordy, które wspólną wartość w `Category` właściwości.  
  
 Jeśli dołączysz `It` — słowo kluczowe w <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości grupowania danych, należy przypisać aliasu `It` — słowo kluczowe. <xref:System.Web.UI.WebControls.LinqDataSource> Kontrolki spowoduje zgłoszenie wyjątku, jeśli `It` nie ma aliasu. Można przypisać aliasu `Key` — słowo kluczowe, ale nie jest wymagana.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób ustawiania <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości do podzbioru właściwości obiektu danych.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#10](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default10.aspx#10)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#10](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default10.aspx#10)]  
  
 Poniższy przykład pokazuje, jak można pobrać wartości właściwości, który został użyty do grupowania danych oraz do pobierania średnią grupowanych rekordów. `Key` — Słowo kluczowe zawiera właściwość, która została użyta do grupowania danych. W tym przykładzie `Key` będzie zawierać wartości udostępnionych z `ProductCategory` właściwości.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default3.aspx#3)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default3.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Selected">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Selected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Selected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Selected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Selected As EventHandler(Of LinqDataSourceStatusEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceStatusEventArgs ^&gt; ^ Selected;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zakończeniu operacji pobierania danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsługa <xref:System.Web.UI.WebControls.LinqDataSource.Selected> zdarzeń catch wszelkie wyjątki przez operację pobierania danych lub sprawdź obiekt danych po zakończeniu operacji pobierania. Obiekt jest dostępny z <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs> obiekt, który zostanie przekazany do procedury obsługi zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Selecting">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceSelectEventArgs&gt; Selecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceSelectEventArgs&gt; Selecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Selecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Selecting As EventHandler(Of LinqDataSourceSelectEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceSelectEventArgs ^&gt; ^ Selecting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceSelectEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje przed wykonaniem operacji pobierania danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsługa <xref:System.Web.UI.WebControls.LinqDataSource.Selecting> zdarzeń, aby można było wykonać następujące zadania:  
  
-   Zmodyfikuj parametry w celu pobierania danych.  
  
-   Wygeneruj zapytanie programowo.  
  
-   Zmodyfikuj wartości sortowania i stronicowania.  
  
-   Wykonaj niestandardowy sortowania i stronicowania.  
  
-   Anuluj operację pobierania danych.  
  
 <xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs> Obiekt, który jest przekazywany do obsługi zdarzeń dla tego zdarzenia zawiera parametry dla operacji pobierania danych. Można zmodyfikować parametry w <xref:System.Web.UI.WebControls.LinqDataSource.Selecting> obsługi zdarzeń przed wykonuje zapytania lub można utworzyć nowego zestawu wyników i przypisać do <xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs.Result%2A> właściwości.  
  
 Możliwość implementacji niestandardowych sortowania i stronicowania w programy obsługi dla tego zdarzenia może być ograniczone przez formant powiązany z <xref:System.Web.UI.WebControls.LinqDataSource>. Na przykład, jeśli nagłówek <xref:System.Web.UI.WebControls.GridView> formant zostanie kliknięty, formantu przeprowadza automatyczne sortowanie której może zastąpienie niezależnie od kolejności należy ustanowić zdarzeń programu obsługi.  
  
 Jeśli jest zwracany wyjątek w obsłudze zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Selecting> zdarzeń, musi obsługiwać wyjątek w tej obsłudze zdarzeń. Wyjątek nie zostaną przekazane do programu obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Selected> zdarzenia (za pośrednictwem <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A> właściwość <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs> obiektu). <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A> Właściwość zawiera tylko wyjątki, które są generowane po <xref:System.Web.UI.WebControls.LinqDataSource.Selecting> zdarzeń.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono program obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Selecting> zdarzeń. Program obsługi tworzy kwerendę, która pobiera wartości z tablicy wartości ciągu na stronie sieci Web.  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSourceSelectEventArgs#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceSelectEventArgs/cs/Default3.aspx.cs#3)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSourceSelectEventArgs#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceSelectEventArgs/vb/Default3.aspx.vb#3)]  
  
 Poniższy przykład pokazuje, jak można przypisać <xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs.Result%2A> właściwości do obiektu, który jest zwracany z metody, która reprezentuje procedury składowanej.  
  
```vb  
Protected Sub LinqDataSource_Selecting(ByVal sender As Object, _  
        ByVal e As LinqDataSourceSelectEventArgs)  
    Dim exampleContext As ExampleDataContext = New ExampleDataContext()  
    e.Result = exampleContext.GetRegisteredCustomers()  
End Sub  
```  
  
```csharp  
protected void LinqDataSource_Selecting(object sender,   
        LinqDataSourceSelectEventArgs e)  
{  
    ExampleDataContext exampleContext = new ExampleDataContext();  
    e.Result = exampleContext.GetRegisteredCustomers();  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection SelectParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection SelectParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.SelectParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ SelectParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję parametrów, które są używane podczas operacji pobierania danych.</summary>
        <value>Parametry, które są używane do tworzenia klauzuli Select.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource> Kontroli korzysta z parametrów w <xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A> kolekcji można utworzyć klauzuli Select w czasie wykonywania. Dodawanie parametrów do <xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A> kolekcji, jeśli chcesz użyć wartości czasu wykonywania w klauzuli Select. Na przykład można dodać parametr <xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A> kolekcję, aby reprezentować właściwość profilu użytkownika. Następnie można użyć tej właściwości i wartości ze źródła danych do obliczenia nowej wartości.  
  
 Jeśli nie ma wartości w czasie wykonywania w klauzuli Select, nie trzeba używać <xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A> kolekcji. Można zdefiniować właściwości do pobrania w <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości. Na przykład, aby zwrócić `FirstName` i `LastName` wartości z tabeli bazy danych, ustaw <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> do "FirstName, LastName" bez parametrów.  
  
 Aby ustawić wartości <xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A> kolekcji, Dodaj element zastępczy w <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości dla tego parametru. W klauzuli Select jest poprzedzony nazwy parametrów z znaku @.  
  
 Nie można użyć parametru w <xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A> kolekcji do reprezentowania nazwy właściwości. Można ustawić dynamicznie <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwość na nazwę właściwości, utworzyć programu obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Selecting> zdarzeń i dostosować <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> właściwości zgodnie z potrzebami.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie wartości dostarczone przez użytkownika do obliczenia wartości zwracanych danych. Użytkownik może wprowadzić wartość w polu tekstowym, reprezentujący liczbę dni produkcji. Ta wartość jest podzielona przez wartość z bazy danych, która reprezentuje liczbę dni w celu wytworzenia produktu. Zwrócona wartość wskazuje, ile produktów można wyprodukować ciągu określonej liczby dni. Wejściowych użytkownika znajduje się w poleceniu Select za pośrednictwem <xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A> kolekcji.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.SelectParameters#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.SelectParameters/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.SelectParameters#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.SelectParameters/vb/Default.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StoreOriginalValuesInViewState">
      <MemberSignature Language="C#" Value="public bool StoreOriginalValuesInViewState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool StoreOriginalValuesInViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.StoreOriginalValuesInViewState" />
      <MemberSignature Language="VB.NET" Value="Public Property StoreOriginalValuesInViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool StoreOriginalValuesInViewState { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy dane ze źródła danych powinny być przechowywane w stan widoku, aby upewnić się, że dane nie został zmieniony przez inny proces przed jego zaktualizowane lub usunięte.</summary>
        <value>
          <see langword="true" /> Jeśli wartości będą przechowywane w widoku stanu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie, kiedy aktualizować i usuwać operacje zostały włączone, <xref:System.Web.UI.WebControls.LinqDataSource> formant przechowuje oryginalnych wartości dla wszystkich rekordów w widoku stanu. <xref:System.Web.UI.WebControls.LinqDataSource> Formant przechowuje wartości dla wszystkich kluczy podstawowych i wszystkie właściwości nie jest oznaczony atrybutem `UpdateCheck.Never` w `Column` atrybutu. Możesz ustawić `UpdateCheck` właściwość `Column` atrybutu w [!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)].  
  
 LINQ do SQL aktualizuje lub usuwa dane, sprawdza wartości w widoku stanu względem bieżącej wartości w źródle danych. Jeśli wartości nie są zgodne, rekord źródła danych został zmieniony. W takim przypadku LINQ do SQL zgłasza wyjątek i nie kontynuować aktualizację lub operacji usuwania. Aby uzyskać więcej informacji dotyczących składnika LINQ to SQL, zobacz [LINQ do SQL](http://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655).  
  
 Przechowywanie oryginalnych wartości w widoku stanu może spowodować, że rozmiar strony, aby stać się niepotrzebnie i mogą uwidaczniać poufne dane do złośliwy użytkownik. Możesz wyłączyć przechowywanie wartości w widoku stanu przez ustawienie <xref:System.Web.UI.WebControls.LinqDataSource.StoreOriginalValuesInViewState%2A> właściwości `false`. Jeśli to zrobisz, musisz podać własne sposób, aby upewnić się, że dane nie uległy zmianie. Jeśli ustawisz <xref:System.Web.UI.WebControls.LinqDataSource.StoreOriginalValuesInViewState%2A> właściwości `false`, oryginalnych wartości nie są zachowywane w stan widoku formantu powiązanego z danymi. W takim przypadku LINQ do SQL nie może sprawdzić integralności danych. LINQ do SQL zgłosi wyjątek, który wskazuje na konflikt danych, nawet jeśli nie zmienił faktycznie danych w źródle danych.  
  
 Jeśli źródła danych zawiera pola sygnatury czasowej, który jest automatycznie aktualizowany podczas aktualizacji, można przechowywać tylko tej wartości w widoku stanu. W takim przypadku ma ustawioną właściwość sygnatury czasowej w klasie jednostki `IsVersion=true` i wszystkie właściwości są ustawione na `UpdateCheck.Never`. Ponieważ pola sygnatury czasowej jest automatycznie aktualizowany przez bazę danych, za każdym razem, gdy zmiany danych w tym rekordzie, LINQ do SQL określa z tej wartości, jeśli dane zostały zmienione. Pozwala to zmniejszyć rozmiar stan widoku, i jest narażony żadnych poufnych danych. LINQ do SQL sprawdza spójność danych przez porównanie wartości sygnatury czasowej w widoku stanu o wartości znaczników czasu w bazie danych. Aby uzyskać więcej informacji, zobacz [wskazówki: używanie sygnatury czasowej z formantu LinqDataSource, aby sprawdzić integralność danych](http://msdn.microsoft.com/library/e7700162-4f05-4130-81f7-3be1361027fa).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.DynamicData.IDynamicDataSource.ContextType">
      <MemberSignature Language="C#" Value="Type System.Web.DynamicData.IDynamicDataSource.ContextType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type System.Web.DynamicData.IDynamicDataSource.ContextType" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.System#Web#DynamicData#IDynamicDataSource#ContextType" />
      <MemberSignature Language="VB.NET" Value=" Property ContextType As Type Implements IDynamicDataSource.ContextType" />
      <MemberSignature Language="C++ CLI" Value="property Type ^ System.Web.DynamicData.IDynamicDataSource.ContextType { Type ^ get(); void set(Type ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.ContextType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="T:System.Web.DynamicData.IDynamicDataSource" />.</summary>
        <value>Typ, który jest skojarzony z klasą.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Web.UI.WebControls.LinqDataSource> wystąpienia jest rzutowane na <xref:System.Web.DynamicData.IDynamicDataSource> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.DynamicData.IDynamicDataSource.EntitySetName">
      <MemberSignature Language="C#" Value="string System.Web.DynamicData.IDynamicDataSource.EntitySetName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string System.Web.DynamicData.IDynamicDataSource.EntitySetName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.System#Web#DynamicData#IDynamicDataSource#EntitySetName" />
      <MemberSignature Language="VB.NET" Value=" Property EntitySetName As String Implements IDynamicDataSource.EntitySetName" />
      <MemberSignature Language="C++ CLI" Value="property System::String ^ System.Web.DynamicData.IDynamicDataSource.EntitySetName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.EntitySetName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="T:System.Web.DynamicData.IDynamicDataSource" />.</summary>
        <value>Nazwa jednostki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Web.UI.WebControls.LinqDataSource> wystąpienia jest rzutowane na <xref:System.Web.DynamicData.IDynamicDataSource> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.DynamicData.IDynamicDataSource.Exception">
      <MemberSignature Language="C#" Value="event EventHandler&lt;System.Web.DynamicData.DynamicValidatorEventArgs&gt; System.Web.DynamicData.IDynamicDataSource.Exception;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.DynamicData.DynamicValidatorEventArgs&gt; System.Web.DynamicData.IDynamicDataSource.Exception" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.System#Web#DynamicData#IDynamicDataSource#Exception" />
      <MemberSignature Language="VB.NET" Value="Custom Event Exception As EventHandler(Of DynamicValidatorEventArgs) Implements System.Web.DynamicData.IDynamicDataSource" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Web.DynamicData.IDynamicDataSource.Exception</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.DynamicData.DynamicValidatorEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TableName">
      <MemberSignature Language="C#" Value="public string TableName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TableName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.TableName" />
      <MemberSignature Language="VB.NET" Value="Public Property TableName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TableName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę właściwości lub pola w klasa kontekstu danych, która reprezentuje zbierania danych.</summary>
        <value>Ciąg zawierający nazwę właściwości, który zawiera kolekcję danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> właściwość na nazwę właściwości lub pola, które reprezentuje dane, które ma zostać pobrane. Jeśli łączysz się z tabeli bazy danych, nazwa właściwości jest zwykle taka sama jak nazwa tabeli. Jeśli łączysz się zbierania danych w pamięci, należy skonfigurować <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> właściwość na nazwę właściwości lub pola, które zwraca zbierania danych.  
  
 Można przypisać właściwości, która zwraca dowolnego typu do <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> właściwości dla operacji pobierania. Jeśli nie implementuje obiektu reprezentowanego przez właściwość <xref:System.Collections.IEnumerable>, <xref:System.Web.UI.WebControls.LinqDataSource> formant będzie automatycznie zawijany obiekt w wystąpieniu <xref:System.Collections.IEnumerable> obiektu.  
  
 Aby włączyć automatyczną aktualizację, wstawiania lub usuwania działań, klasy, która jest przypisana do <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A> właściwości musi pochodzić od <xref:System.Data.Linq.DataContext> i właściwości, która jest przypisana do <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> właściwości musi pochodzić od <xref:System.Data.Linq.Table%601>.  
  
 Aby uzyskać informacje o wybieraniu danych z wystąpienia klasy, zobacz <xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs.Result%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład przedstawia dwa <xref:System.Web.UI.WebControls.LinqDataSource> kontrolki. W jednym <xref:System.Web.UI.WebControls.LinqDataSource> kontroli, <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> właściwość ma wartość właściwości w klasie. Tej właściwości zwraca tablicę ciągów. W innych <xref:System.Web.UI.WebControls.LinqDataSource> kontroli, <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> właściwość ma ustawioną właściwość, która reprezentuje tabeli bazy danych.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/cs/Default.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/vb/Default.aspx#2)]  
  
 Klasa o nazwie `ExampleDataContext` czy reprezentuje tabeli bazy danych nie jest widoczne w tym przykładzie. W tym przykładzie do pracy, należy utworzyć przez dodanie LINQ do SQL klasy o nazwie Example.dbml i przeciągając tabeli o nazwie filmu na tej klasy [!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)]. Klasa o nazwie `ExampleDataContext` z właściwości o nazwie `Movies` jest generowany.  
  
 W poniższym przykładzie przedstawiono klasę o nazwie `MovieLibrary` mowa w <xref:System.Web.UI.WebControls.LinqDataSource> formantu.  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/cs/App_Code/MovieLibrary.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/vb/App_Code/MovieLibrary.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Collections.IDictionary keys, System.Collections.IDictionary values, System.Collections.IDictionary oldValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Update(class System.Collections.IDictionary keys, class System.Collections.IDictionary values, class System.Collections.IDictionary oldValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.Update(System.Collections.IDictionary,System.Collections.IDictionary,System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function Update (keys As IDictionary, values As IDictionary, oldValues As IDictionary) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(System::Collections::IDictionary ^ keys, System::Collections::IDictionary ^ values, System::Collections::IDictionary ^ oldValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.IDictionary" />
        <Parameter Name="values" Type="System.Collections.IDictionary" />
        <Parameter Name="oldValues" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="keys">Wartości klucza wiersza dla rekordów do aktualizacji.</param>
        <param name="values">Wartości wierszy do zaktualizowania w źródle danych.</param>
        <param name="oldValues">Wartości wierszy, które są oceniane w celu wykrycia konfliktów danych.</param>
        <summary>Wykonuje operację aktualizacji.</summary>
        <returns>Liczba rekordów dotyczy operacji aktualizacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj nie trzeba wywołać <xref:System.Web.UI.WebControls.LinqDataSource.Update%2A> metody w kodzie. Automatycznie wywoła formantu powiązanego z danymi <xref:System.Web.UI.WebControls.LinqDataSource.Update%2A> metody, gdy użytkownik podejmuje działania w celu zaktualizowania rekordu. Jawnie wywołać <xref:System.Web.UI.WebControls.LinqDataSource.Update%2A> metody, jeśli chcesz utworzyć własny proces aktualizowania danych.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak programowo zaktualizować rekord w źródle danych, po kliknięciu przycisku. Przekazuje kod <xref:System.Collections.Specialized.ListDictionary> obiekt, który zawiera wartość klucza <xref:System.Collections.Specialized.ListDictionary> obiekt, który zawiera wartości początkowe i <xref:System.Collections.Specialized.ListDictionary> obiekt, który zawiera nowe wartości do <xref:System.Web.UI.WebControls.LinqDataSource.Update%2A> metody.  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.Update#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Update/cs/Default2.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.Update#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Update/vb/Default3.aspx.vb#1)]  
  
 W poniższym przykładzie pokazano kod znaczników w poprzednim przykładzie.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.Update#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Update/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.Update#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Update/vb/Default3.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Updated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Updated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Updated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Updated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Updated As EventHandler(Of LinqDataSourceStatusEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceStatusEventArgs ^&gt; ^ Updated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zakończeniu operacji aktualizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsługa <xref:System.Web.UI.WebControls.LinqDataSource.Updated> zdarzenia można przechwytywać wszelkie wyjątki z operacji aktualizacji lub do sprawdzenia wartości parametrów output, po zakończeniu operacji aktualizacji. Parametry wyjściowe są dostępne z <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs> obiekt, który zostanie przekazany do procedury obsługi zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection UpdateParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection UpdateParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.UpdateParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UpdateParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ UpdateParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ta kolekcja nie jest używany przez <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> klasy.</summary>
        <value>Kolekcja parametrów.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Updating">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs&gt; Updating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs&gt; Updating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Updating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Updating As EventHandler(Of LinqDataSourceUpdateEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceUpdateEventArgs ^&gt; ^ Updating;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje przed wykonaniem operacji aktualizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsługa <xref:System.Web.UI.WebControls.LinqDataSource.Updating> zdarzeń do sprawdzania poprawności obiektu, należy zaktualizować, aby sprawdzić błędy sprawdzania poprawności danych z klasy danych, aby zmienić wartość przed wykonaniem operacji aktualizacji lub anulować operacji aktualizacji. <xref:System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs> Obiekt, który zostanie przekazany do procedury obsługi zdarzeń zawiera obiekt oryginalny i zaktualizowany obiekt.  
  
 Jeśli wystąpi błąd sprawdzania poprawności podczas operacji update <xref:System.Web.UI.WebControls.LinqDataSourceInsertEventArgs> obiekt zawiera wyjątki sprawdzania poprawności, które są generowane przez klasy danych. Jeśli wartość aktualizacji nie jest zgodny z typem właściwości w klasie danych lub nie zostały spełnione niestandardowego sprawdzania wystąpienia błędu weryfikacji. W obsłudze zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Updating> zdarzeń, może pobrać wyjątki poprawności i podejmij odpowiednią akcję.  
  
 Jeśli jest zwracany wyjątek w obsłudze zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Updating> zdarzeń, musi obsługiwać wyjątek w tej obsłudze zdarzeń. Wyjątek nie zostaną przekazane do programu obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Updated> zdarzenia (za pośrednictwem <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A> właściwość <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs> obiektu). <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A> Właściwość zawiera tylko wyjątki, które są generowane po <xref:System.Web.UI.WebControls.LinqDataSource.Updating> zdarzeń.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono program obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Updating> zdarzeń. Kod porównuje właściwości z <xref:System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs.OriginalObject%2A> właściwości i <xref:System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs.NewObject%2A> właściwości, aby sprawdzić, czy wartość została zmieniona. Jeśli wartość została zmieniona, wartość <xref:System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs.NewObject%2A> właściwość jest ustawiona na `true`.  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.Updating#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Updating/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.Updating#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Updating/vb/Default.aspx.vb#1)]  
  
 W poniższym przykładzie przedstawiono program obsługi zdarzeń dla <xref:System.Web.UI.WebControls.LinqDataSource.Updating> zdarzenie, które pobiera wyjątki poprawności.  
  
```vb  
Protected Sub LinqDataSource_Updating(ByVal sender As Object, _  
        ByVal e As LinqDataSourceUpdateEventArgs)  
    If (e.Exception IsNot Nothing) Then  
        For Each innerException As KeyValuePair(Of String, Exception) _  
               In e.Exception.InnerExceptions  
            Label1.Text &= innerException.Key & ": " & _  
                innerException.Value.Message & "<br />"  
        Next  
        e.ExceptionHandled = True  
    End If  
End Sub  
```  
  
```csharp  
protected void LinqDataSource_Updating(object sender,   
        LinqDataSourceUpdateEventArgs e)  
{  
    if (e.Exception != null)  
    {  
        foreach (KeyValuePair<string, Exception> innerException in   
             e.Exception.InnerExceptions)  
        {  
        Label1.Text += innerException.Key + ": " +   
            innerException.Value.Message + "<br />";  
        }  
        e.ExceptionHandled = true;  
    }  
}  
```  
  
 Poprzedni przykład pobiera wyjątki poprawności. Wystąpił wyjątek może zostać zgłoszone, jeśli wartość nie jest zgodny z typem właściwości. Również może zostać wygenerowany z dostosowanych wyboru, takie jak w poniższym przykładzie. `OnAgeChanging` Metoda sprawdza, czy liczba dla `Age` właściwość nie jest ujemna.  
  
```csharp  
partial void  OnAgeChanging(int? value)  
{  
    if (value < 0)  
    {  
        throw new Exception("Age cannot be a negative number.");  
    }  
}  
```  
  
```vb  
Private Sub OnAgeChanging(ByVal value As System.Nullable(Of Integer))  
    If (value < 0) Then  
        Throw New Exception("Age cannot be a negative number.")  
    End If  
End Sub  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Where">
      <MemberSignature Language="C#" Value="public string Where { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Where" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.Where" />
      <MemberSignature Language="VB.NET" Value="Public Property Where As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Where { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.Where</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, jaki warunki musi być prawdziwe dla rekordu do uwzględnienia w pobrane dane.</summary>
        <value>Ciąg, który jest używany do tworzenia Where klauzuli.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> właściwości w celu określenia warunków rekord, który ma zostać zwrócone w wyniku zapytania. Składnia <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> właściwości jest taka sama jak składnia klauzuli LINQ Where w C#.  
  
 Określ wyrażenie, których wynikiem jest wartość logiczna, a jeśli wyrażenie ma `true` dla danego wiersza, wiersz jest uwzględniony w zestawie wyników. Wyrażeń składają się z nazwy kolumn operatory porównania i wartości do porównania, jak pokazano w poniższym przykładzie:  
  
```  
<asp:LinqDataSource ... Where="Price > 50"...>  
```  
  
 Aby określić wiele wyrażeń logicznych połączone `AND` lub `OR` operatorów, należy użyć `&&` jako operator logiczny AND i `||` jako operator logiczny OR, jak pokazano w poniższym przykładzie:  
  
```  
<asp:LinqDataSource ... Where="Price > 50 && Price < 100"...>  
<asp:LinqDataSource ... Where="Price <= 50 || Price >= 100"...>  
```  
  
 Jeśli chcesz przetestować właściwości na wartość literału ciągu, wartości literału ciągu musi być ujęta w znaki cudzysłowu. Aby to zrobić w znaczniku, ujmij <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> wartość klauzuli w pojedynczy cudzysłów, jak pokazano w poniższym przykładzie:  
  
```  
<asp:LinqDataSource ... Where='Category = "Sports"' ... >  
```  
  
 Aby przetestować wartość literału ciągu w kodzie, należy użyć znaki specjalne, które są odpowiednie dla języka używanego w celu wstawienia znaki cudzysłowu, jak pokazano w poniższym przykładzie:  
  
```vb  
LinqDataSource1.Where = "Category = ""Sports"""  
```  
  
```csharp  
LinqDataSource1.Where = "Category = \"Sports\"";  
```  
  
 Jeśli chcesz sprawdzić, czy ciąg jest większa lub mniejsza niż inny ciąg, należy użyć metody <xref:System.String> klasy zamiast `<` lub `>` operatorów między nazwę kolumny oraz wartość ciągu. Następujące przykłady przedstawiają sposób wybierania wierszy, które mają wartości kategorii, które są mniejsze niż mniejsza niż lub równe, większe niż, lub większa niż lub równa "Sport":  
  
```  
<asp:LinqDataSource ... Where='Category.CompareTo("Sports") < 0' ... >  
<asp:LinqDataSource ... Where='Category.CompareTo("Sports") <= 0' ... >  
<asp:LinqDataSource ... Where='Category.CompareTo("Sports") > 0' ... >  
<asp:LinqDataSource ... Where='Category.CompareTo("Sports") >= 0' ... >  
```  
  
 Można również użyć innych metod <xref:System.String> klas, takich jak <xref:System.String.StartsWith%2A>, <xref:System.String.EndsWith%2A>, i <xref:System.String.Contains%2A>. Aby uzyskać więcej informacji o tym, jak należy porównywać ciągi, zobacz [porównywanie ciągów](~/docs/standard/base-types/comparing.md). Aby uzyskać więcej informacji o tym, gdzie klauzuli składni, zobacz [operatory C#](http://msdn.microsoft.com/library/0301e31f-22ad-49af-ac3c-d5eae7f0ac43) i [gdzie klauzuli](~/docs/csharp/language-reference/keywords/where-clause.md).  
  
 Oprócz filtrowanie na podstawie wartości statycznej zdefiniować podczas tworzenia strony sieci Web, można filtrować na podstawie wartości dynamiczne, które są oceniane w czasie wykonywania. W takim przypadku obejmują nazwany parametr w <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> właściwość, która działa jako symbol zastępczy wartości. Następnie dodaj parametr o nazwie pasującego do <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> kolekcji.  
  
 Alternatywnie, można ustawić <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A> właściwości `true` i definiować parametry w <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> kolekcji. Gdy <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A> właściwość jest `true`, nie trzeba uwzględnić parametry nazwane w <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> właściwości. Zamiast tego <xref:System.Web.UI.WebControls.LinqDataSource> formant automatycznie generuje Where klauzuli z parametrów w <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> właściwości.  
  
 Aby uzyskać więcej informacji o tym, jak można filtrować dane, zobacz [wskazówki: filtrowanie podzbiór danych z LinqDataSource i kontrolki GridView i wybierając](http://msdn.microsoft.com/library/c1cca3e8-86e4-4e69-a29f-1c05b91f2205).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak do filtrowania danych zwróconych z zapytania na podstawie warunku statycznych.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default5.aspx#5)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default5.aspx#5)]  
  
 Poniższy przykład pokazuje, jak do filtrowania danych na podstawie wartości dostarczone przez użytkownika w czasie wykonywania. W tym przykładzie <xref:System.Web.UI.WebControls.DropDownList> kontroli i <xref:System.Web.UI.WebControls.GridView> sterowania są wyświetlane na stronie. Gdy użytkownik może wybrać jedną z wartości w <xref:System.Web.UI.WebControls.DropDownList> kontroli, <xref:System.Web.UI.WebControls.LinqDataSource> kontroli wybiera z `Products` tylko wiersze z tabeli `UserPrice` do wybranej wartości są równe. <xref:System.Web.UI.WebControls.GridView> Kontrola następnie wyświetla to odfiltrowane dane.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default6.aspx#6)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default6.aspx#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WhereParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection WhereParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection WhereParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.WhereParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WhereParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ WhereParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.WhereParameters</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zbiór parametrów, który jest używany do tworzenia Where klauzuli.</summary>
        <value>Kolekcja parametrów, które są używane do tworzenia Where w klauzuli <see cref="P:System.Web.UI.WebControls.LinqDataSource.Where" /> właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource> Kontroli korzysta z parametrów w <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> kolekcji, aby utworzyć Where klauzuli w czasie wykonywania. Dodawanie parametrów do <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> kolekcji, jeśli chcesz programowo ustawić co najmniej jeden z warunków w klauzuli Where klauzuli. Na przykład można przeszukać tabeli bazy danych dla rekordów o nazwisko równa wartości <xref:System.Web.UI.WebControls.TextBox> formantu. W takim przypadku Dodaj parametr <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> kolekcji dla wartość pola tekstowego.  
  
 Jeśli nie trzeba ustawić wartość w czasie wykonywania w przypadku, gdy klauzula, nie trzeba używać <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> kolekcji. Można zdefiniować pól do pobrania w <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> właściwości. Na przykład, aby zwrócić wartości z tabeli bazy danych gdzie `LastName` wartość jest równa "Zawadzki" w znaczniku, <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> właściwości `'LastName = "Adams"'` bez żadnych parametrów.  
  
 Aby ustawić wartości <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> kolekcji, należy przypisać nazwę każdego parametru i dodać element zastępczy w <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> właściwości tego parametru. W klauzuli Where klauzuli każdej nazwie parametru jest poprzedzony znakiem @.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A> kolekcji można dynamicznie utworzyć Where klauzuli. <xref:System.Web.UI.WebControls.LinqDataSource> Sterowania wszystkie rekordy z wartością w `Price` kolumny, która jest większa niż wartość wybrane przez użytkownika w <xref:System.Web.UI.WebControls.DropDownList> formantu.  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default6.aspx#6)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default6.aspx#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
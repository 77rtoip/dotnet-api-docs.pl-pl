<Type Name="HttpListenerPrefixCollection" FullName="System.Net.HttpListenerPrefixCollection">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cfa3eeaf3cab8656bedc2b83b0c1899983f4e2a5" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69091056" /></Metadata><TypeSignature Language="C#" Value="public class HttpListenerPrefixCollection : System.Collections.Generic.ICollection&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;string&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit HttpListenerPrefixCollection extends System.Object implements class System.Collections.Generic.ICollection`1&lt;string&gt;, class System.Collections.Generic.IEnumerable`1&lt;string&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpListenerPrefixCollection" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpListenerPrefixCollection&#xA;Implements ICollection(Of String), IEnumerable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpListenerPrefixCollection : System::Collections::Generic::ICollection&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;System::String ^&gt;" />
  <TypeSignature Language="F#" Value="type HttpListenerPrefixCollection = class&#xA;    interface ICollection&lt;string&gt;&#xA;    interface seq&lt;string&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.HttpListener</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje kolekcję służącą do przechowywania prefiksów Uniform Resource Identifier (URI) dla <see cref="T:System.Net.HttpListener" /> obiektów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta <xref:System.Net.HttpListener.Prefixes%2A> Właściwość zwraca wystąpienia tej kolekcji.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy i dodaje <xref:System.Net.HttpListener> do niego <xref:System.Net.HttpListenerPrefixCollection>prefiksy określone przez użytkownika.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
 [!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (string uriPrefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(string uriPrefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.Add(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (uriPrefix As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::String ^ uriPrefix);" />
      <MemberSignature Language="F#" Value="abstract member Add : string -&gt; unit&#xA;override this.Add : string -&gt; unit" Usage="httpListenerPrefixCollection.Add uriPrefix" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriPrefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriPrefix">A <see cref="T:System.String" /> , który identyfikuje informacje o identyfikatorze URI, które są porównywane w żądaniach przychodzących. Prefiks musi być zakończony ukośnikiem ("/").</param>
        <summary>Dodaje prefiks Uniform Resource Identifier (URI) do kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dodaje do zestawu prefiksów identyfikatora URI, które są zarządzane przez skojarzony <xref:System.Net.HttpListener> obiekt. Podczas sprawdzania `uriPrefix` , aby upewnić się, że jest on prawidłowy, wielkość liter jest ignorowana.  
  
 Ciąg prefiksu identyfikatora URI składa się ze schematu (http lub https), hosta, opcjonalnego portu i opcjonalnej ścieżki, na przykład "`http://www.contoso.com:8080/customerData/`". Prefiks musi być zakończony ukośnikiem ("/"). <xref:System.Net.HttpListener> Z prefiksem, który najlepiej pasuje do żądanego identyfikatora URI odpowiada na żądanie. Wiele <xref:System.Net.HttpListener> obiektów nie może dodać tego samego prefiksu. Wyjątek jest zgłaszany w <xref:System.Net.HttpListener> przypadku dodania prefiksu, który jest już używany. <xref:System.Net.HttpListenerException>  
  
 Gdy port jest określony, element hosta można zastąpić "`*`", aby wskazać <xref:System.Net.HttpListener> , że akceptowane żądania wysyłane do portu, jeśli żądany identyfikator URI nie jest zgodny z żadnym innym prefiksem. Na przykład, aby otrzymywać wszystkie żądania wysyłane do portu 8080, gdy żądany identyfikator URI nie jest obsługiwany przez żadne <xref:System.Net.HttpListener>inne, prefiks jest "`http://*:8080/`". Analogicznie, aby określić, <xref:System.Net.HttpListener> że akceptowane są wszystkie żądania wysyłane do portu, Zastąp element hosta "`+`" znakiem`https://+:8080/`"". Znaki "`*`" i "`+`" mogą występować w prefiksach, które zawierają ścieżki.  
  
 Począwszy od platformy .NET 4.5.3 i systemu Windows 10, symbole wieloznaczne są obsługiwane w prefiksach URI, które są zarządzane <xref:System.Net.HttpListener> przez obiekt. Aby określić poddomenę z symbolami wieloznacznymi, użyj znaku "\*" jako części nazwy hosta w prefiksie identyfikatora URI: na `http://*.foo.com/`przykład, i przekaż go jako argument do metody HttpListenerPrefixCollection. Add. Ta współpraca będzie działała w przypadku platformy .NET 4.5.3 i systemu Windows 10. w starszych wersjach spowoduje to wygenerowanie<xref:System.Net.HttpListenerException>  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy i dodaje <xref:System.Net.HttpListener> do niego <xref:System.Net.HttpListenerPrefixCollection>prefiksy określone przez użytkownika.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
 [!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="uriPrefix" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="uriPrefix" />nie używa schematu http://ani https://. Są to jedyne schematy obsługiwane dla <see cref="T:System.Net.HttpListener" /> obiektów.  
  
—lub— 
 <paramref name="uriPrefix" />nie jest poprawnie sformatowanym prefiksem identyfikatora URI. Upewnij się, że ciąg jest zakończony znakiem "/".</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.HttpListener" /> Skojarzenie skojarzone z tą kolekcją jest zamknięte.</exception>
        <exception cref="T:System.Net.HttpListenerException">Wywołanie funkcji systemu Windows nie powiodło się. Sprawdź <see cref="P:System.Net.HttpListenerException.ErrorCode" /> Właściwość wyjątku, aby określić przyczynę wyjątku. Ten wyjątek jest zgłaszany, <see cref="T:System.Net.HttpListener" /> jeśli inny został już dodany <paramref name="uriPrefix" />prefiks.</exception>
        <permission cref="T:System.Net.WebPermission">W celu zaakceptowania połączeń sieciowych. Skojarzone Wyliczenie:<see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="httpListenerPrefixCollection.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie prefiksy Uniform Resource Identifier (URI) z kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu tej metody nie można uruchomić skojarzonej <xref:System.Net.HttpListener> bez dodawania nowych prefiksów; Jeśli spróbujesz to zrobić, zostanie zgłoszony wyjątek.  
  
   
  
## Examples  
 Poniższy przykład kodu usuwa wszystkie prefiksy w <xref:System.Net.HttpListenerPrefixCollection>.  
  
 [!code-csharp[Net_Listener_Basic#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#6)]  
 [!code-vb[Net_Listener_Basic#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Wywołanie funkcji systemu Windows nie powiodło się. Sprawdź <see cref="P:System.Net.HttpListenerException.ErrorCode" /> Właściwość wyjątku, aby określić przyczynę wyjątku.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.HttpListener" /> Skojarzenie skojarzone z tą kolekcją jest zamknięte.</exception>
        <block subset="none" type="usage"><para>Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string uriPrefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(string uriPrefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (uriPrefix As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::String ^ uriPrefix);" />
      <MemberSignature Language="F#" Value="abstract member Contains : string -&gt; bool&#xA;override this.Contains : string -&gt; bool" Usage="httpListenerPrefixCollection.Contains uriPrefix" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriPrefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriPrefix">A <see cref="T:System.String" /> , który zawiera prefiks Uniform Resource Identifier (URI) do przetestowania.</param>
        <summary><see cref="T:System.Boolean" /> Zwraca wartość wskazującą, czy określony prefiks jest zawarty w kolekcji.</summary>
        <returns><see langword="true" />Jeśli ta kolekcja zawiera prefiks określony przez <paramref name="uriPrefix" />; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określony prefiks musi być dokładnie dopasowany do istniejącej wartości.  
  
   
  
## Examples  
 Poniższy przykład kodu sprawdza, czy prefiks określony przez użytkownika jest zawarty w kolekcji <xref:System.Net.HttpListener>prefiksów.  
  
 [!code-csharp[Net_Listener_Basic#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#4)]  
 [!code-vb[Net_Listener_Basic#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="uriPrefix" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiuje zawartość <see cref="T:System.Net.HttpListenerPrefixCollection" /> do określonej tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tablica musi być w stanie zawierać ciągi i nie może być wielowymiarowych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, int offset);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Array * int -&gt; unit" Usage="httpListenerPrefixCollection.CopyTo (array, offset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jeden wymiar <see cref="T:System.Array" /> , który odbiera ciągi prefiksu Uniform Resource Identifier (URI) w tej kolekcji.</param>
        <param name="offset">Indeks (liczony od zera) <paramref name="array" /> , w którym rozpoczyna się kopiowanie.</param>
        <summary>Kopiuje zawartość <see cref="T:System.Net.HttpListenerPrefixCollection" /> do określonej tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tablica musi być w stanie zawierać ciągi i nie może być wielowymiarowych.  
  
   
  
## Examples  
 Poniższy przykład kodu kopiuje prefiksy w <xref:System.Net.HttpListenerPrefixCollection>.  
  
 [!code-csharp[Net_Listener_Basic#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#7)]  
 [!code-vb[Net_Listener_Basic#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="array" />ma więcej niż jeden wymiar.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Ta kolekcja zawiera więcej elementów niż może być przechowywana w <paramref name="array" /> czasie <paramref name="offset" />od.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.HttpListener" /> Skojarzenie skojarzone z tą kolekcją jest zamknięte.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="array" />nie można przechowywać wartości ciągu.</exception>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (string[] array, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(string[] array, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.CopyTo(System.String[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As String(), offset As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;System::String ^&gt; ^ array, int offset);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : string[] * int -&gt; unit&#xA;override this.CopyTo : string[] * int -&gt; unit" Usage="httpListenerPrefixCollection.CopyTo (array, offset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.String[]" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica ciągów jednowymiarowych, która otrzymuje ciągi prefiksu Uniform Resource Identifier (URI) w tej kolekcji.</param>
        <param name="offset">Indeks (liczony od zera) <paramref name="array" /> , w którym rozpoczyna się kopiowanie.</param>
        <summary>Kopiuje zawartość <see cref="T:System.Net.HttpListenerPrefixCollection" /> do określonej tablicy ciągów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tablica musi być w stanie zawierać ciągi i nie może być wielowymiarowych.  
  
   
  
## Examples  
 Poniższy przykład kodu kopiuje prefiksy w <xref:System.Net.HttpListenerPrefixCollection>.  
  
 [!code-csharp[Net_Listener_Basic#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#7)]  
 [!code-vb[Net_Listener_Basic#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="array" />ma więcej niż jeden wymiar.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Ta kolekcja zawiera więcej elementów niż może być przechowywana w <paramref name="array" /> czasie <paramref name="offset" />od.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.HttpListener" /> Skojarzenie skojarzone z tą kolekcją jest zamknięte.</exception>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerPrefixCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Net.HttpListenerPrefixCollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę prefiksów zawartych w kolekcji.</summary>
        <value><see cref="T:System.Int32" /> Zawierający liczbę prefiksów w tej kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu wyświetla prefiksy w kolekcji.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
 [!code-vb[Net_Listener_Basic#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;string&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;string&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerator&lt;System::String ^&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;string&gt;&#xA;override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;string&gt;" Usage="httpListenerPrefixCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca obiekt, którego można użyć do iteracji w kolekcji.</summary>
        <returns>Obiekt, który implementuje <see cref="T:System.Collections.IEnumerator" /> interfejs i zapewnia dostęp do ciągów w tej kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt, który jest zwracany przez tę metodę jest początkowo umieszczony przed pierwszym elementem w tej kolekcji. Musisz wywołać metodę, <xref:System.Collections.IEnumerator.MoveNext%2A> Aby uzyskać dostęp do pierwszego elementu. Aby uzyskać dostęp do elementu w bieżącym położeniu, wywołaj <xref:System.Collections.IEnumerator.Current%2A> właściwość.  
  
 Nie należy modyfikować kolekcji przy użyciu modułu wyliczającego. Jeśli kolekcja zostanie zmodyfikowana, gdy moduł wyliczający jest w użyciu, próba ustawienia pozycji przez wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> powoduje <xref:System.InvalidOperationException>.  
  
 Aby uzyskać szczegółowy opis modułów wyliczających, zobacz dokumentację <xref:System.Collections.IEnumerator> klasy <xref:System.Collections.IEnumerable.GetEnumerator%2A> i metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje Wyliczanie za pomocą kolekcji. Należy zauważyć, że Visual Basic C# i przykłady używają instrukcji specyficznych dla języka do wyliczenia w kolekcji, a nie do pobierania modułu wyliczającego.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
 [!code-vb[Net_Listener_Basic#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerPrefixCollection.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Net.HttpListenerPrefixCollection.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy dostęp do kolekcji jest tylko do odczytu.</summary>
        <value>Zawsze zwraca <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerPrefixCollection.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Net.HttpListenerPrefixCollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy dostęp do kolekcji jest synchronizowany (bezpieczny wątkowo).</summary>
        <value>Ta właściwość zawsze zwraca <see langword="false" />wartość.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego wyliczenia lub przechwycić wyjątki wynikające ze zmian wprowadzonych przez inne wątki.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (string uriPrefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(string uriPrefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.Remove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (uriPrefix As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(System::String ^ uriPrefix);" />
      <MemberSignature Language="F#" Value="abstract member Remove : string -&gt; bool&#xA;override this.Remove : string -&gt; bool" Usage="httpListenerPrefixCollection.Remove uriPrefix" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriPrefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriPrefix">A <see cref="T:System.String" /> , który zawiera prefiks identyfikatora URI do usunięcia.</param>
        <summary>Usuwa określony Uniform Resource Identifier (URI) z listy prefiksów obsłużonych przez <see cref="T:System.Net.HttpListener" /> obiekt.</summary>
        <returns><see langword="true" />Jeśli znaleziono w i usunięty; w przeciwnym razie <see langword="false" />. <see cref="T:System.Net.HttpListenerPrefixCollection" /> <paramref name="uriPrefix" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `uriPrefix` nie znajduje się w kolekcji, ta metoda nie wykonuje żadnych operacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="uriPrefix" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.HttpListenerException">Wywołanie funkcji systemu Windows nie powiodło się. Aby określić przyczynę wyjątku, sprawdź kod błędu wyjątku.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.HttpListener" /> Skojarzenie skojarzone z tą kolekcją jest zamknięte.</exception>
        <block subset="none" type="usage"><para>Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca obiekt, którego można użyć do iteracji w kolekcji.</summary>
        <returns>Obiekt, który implementuje <see cref="T:System.Collections.IEnumerator" /> interfejs i zapewnia dostęp do ciągów w tej kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt, który jest zwracany przez tę metodę jest początkowo umieszczony przed pierwszym elementem w tej kolekcji. Musisz wywołać metodę, <xref:System.Collections.IEnumerator.MoveNext%2A> Aby uzyskać dostęp do pierwszego elementu. Aby uzyskać dostęp do elementu w bieżącym położeniu, wywołaj <xref:System.Collections.IEnumerator.Current%2A> właściwość.  
  
 Nie należy modyfikować kolekcji przy użyciu modułu wyliczającego. Jeśli kolekcja zostanie zmodyfikowana, gdy moduł wyliczający jest w użyciu, próba ustawienia pozycji przez wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> powoduje <xref:System.InvalidOperationException>.  
  
 Aby uzyskać szczegółowy opis modułów wyliczających, zobacz dokumentację <xref:System.Collections.IEnumerator> klasy <xref:System.Collections.IEnumerable.GetEnumerator%2A> i metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="HttpListenerRequest" FullName="System.Net.HttpListenerRequest">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d940242925d794878f76e4a5fbb52244dd635067" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36549115" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpListenerRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpListenerRequest extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpListenerRequest" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpListenerRequest" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpListenerRequest sealed" />
  <TypeSignature Language="F#" Value="type HttpListenerRequest = class" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.HttpListener</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>W tym artykule opisano przychodzące żądanie HTTP do <see cref="T:System.Net.HttpListener" /> obiektu. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy klient wysyła żądanie do zasobu identyfikator URI (Uniform) obsługiwany przez <xref:System.Net.HttpListener> obiektu <xref:System.Net.HttpListener> zapewnia <xref:System.Net.HttpListenerContext> obiektu, który zawiera informacje o nadawcy, żądania i odpowiedzi, który jest wysyłany do klienta. <xref:System.Net.HttpListenerContext.Request%2A?displayProperty=nameWithType> Zwraca właściwość <xref:System.Net.HttpListenerRequest> obiektu, który opisuje żądania.  
  
 <xref:System.Net.HttpListenerRequest> Zawiera informacje o żądaniu, takich jak żądanie <xref:System.Net.HttpListenerRequest.HttpMethod%2A> ciągu <xref:System.Net.HttpListenerRequest.UserAgent%2A> ciąg i dane treści żądania (zobacz <xref:System.Net.HttpListenerRequest.InputStream%2A> właściwości).  
  
 Aby odpowiedzieć na żądanie, należy uzyskać przy użyciu skojarzonego odpowiedzi <xref:System.Net.HttpListenerContext.Response%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak otrzymywać i reagowanie na <xref:System.Net.HttpListenerRequest>.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.HttpListener" />
    <altmember cref="T:System.Net.HttpListenerContext" />
    <altmember cref="T:System.Net.HttpListenerResponse" />
  </Docs>
  <Members>
    <Member MemberName="AcceptTypes">
      <MemberSignature Language="C#" Value="public string[] AcceptTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AcceptTypes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.AcceptTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AcceptTypes As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AcceptTypes { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AcceptTypes : string[]" Usage="System.Net.HttpListenerRequest.AcceptTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typy MIME zaakceptowane przez klienta.</summary>
        <value>A <see cref="T:System.String" /> tablica, która zawiera nazwy typu określony w żądaniu <see langword="Accept" /> nagłówka lub <see langword="null" /> Jeśli żądanie klienta nie zawiera <see langword="Accept" /> nagłówka.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Accept` Nagłówka to ciąg rozdzielany nazwy typów protokołu dynamicznej konfiguracji hosta (MIME, Multipurpose Internet Mail Extensions) (na przykład `image/jpeg`), które wskazują typy MIME, które klient jest gotowa do akceptowania i przetwarzania w odpowiedzi. `*/*` Wpis wskazuje, czy klient akceptuje dowolny typ MIME. Aby uzyskać szczegółowy opis `Accept` nagłówka, zobacz RFC 2616 dostępne pod adresem [ https://www.rfc-editor.org ](https://www.rfc-editor.org/).  
  
 Aby uzyskać pełną listę nagłówków żądań, zobacz <xref:System.Net.HttpRequestHeader> wyliczenia.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, za pomocą tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="BeginGetClientCertificate">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginGetClientCertificate (AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginGetClientCertificate(class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerRequest.BeginGetClientCertificate(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginGetClientCertificate (requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginGetClientCertificate(AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginGetClientCertificate : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpListenerRequest.BeginGetClientCertificate (requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="requestCallback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po zakończeniu operacji.</param>
        <param name="state">Obiekt użytkownika, który zawiera informacje na temat operacji. Ten obiekt jest przekazywany do delegata wywołania zwrotnego, po zakończeniu operacji.</param>
        <summary>Rozpoczyna żądanie asynchroniczne dla klienta X.509 v.3 certyfikatu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Wskazuje, że stan operacji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificateError">
      <MemberSignature Language="C#" Value="public int ClientCertificateError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ClientCertificateError" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ClientCertificateError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientCertificateError As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ClientCertificateError { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificateError : int" Usage="System.Net.HttpListenerRequest.ClientCertificateError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kod błędu, który wykryje problem z <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" /> dostarczonych przez klienta.</summary>
        <value>
          <see cref="T:System.Int32" /> Wartość, która zawiera kod błędu systemu Windows.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawiera kod błędu systemu Windows zwracane przez bezpiecznego kanału (Schannel) dostawcy obsługi zabezpieczeń interfejsu (SSPI), który jest używany do weryfikacji certyfikatu. Aby uzyskać więcej informacji na temat obsługi interfejsu SSPI dla dostawcy Schannel, zobacz "Tworzenie zabezpieczyć połączenie przy użyciu Schannel" w dokumentacji zabezpieczeń w [ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library).  
  
   
  
## Examples  
 Poniższy przykład kodu sprawdza tę właściwość, aby ustalić, czy żądanie zawiera prawidłowy certyfikat klienta.  
  
 [!code-csharp[NCLListener#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#3)]
 [!code-vb[NCLListener#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie zainicjowano jeszcze certyfikatu klienta przez wywołanie do <see cref="M:System.Net.HttpListenerRequest.BeginGetClientCertificate(System.AsyncCallback,System.Object)" /> lub <see cref="M:System.Net.HttpListenerRequest.GetClientCertificate" /> metody - lub - operacja jest w toku.</exception>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentEncoding : System.Text.Encoding" Usage="System.Net.HttpListenerRequest.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kodowanie zawartości, która może być używany z danych wysłanych w żądaniu</summary>
        <value>
          <see cref="T:System.Text.Encoding" /> Obiektu odpowiednie do użycia z danymi w <see cref="P:System.Net.HttpListenerRequest.InputStream" /> właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding> Obiekt może służyć do konwertowania sekwencji bajtów do zestawów znaków (stron kodowych) i znaki do sekwencji bajtów. Ta właściwość używa wartości charset z `Content-Type` nagłówka określić kodowania. Jeśli te informacje nie jest dostępny, ta właściwość zwraca <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, przy użyciu <xref:System.Net.HttpListenerRequest.ContentEncoding%2A> właściwości.  
  
 [!code-csharp[Net_Listener_Basic#16](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="ContentLength64">
      <MemberSignature Language="C#" Value="public long ContentLength64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength64" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ContentLength64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentLength64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ContentLength64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength64 : int64" Usage="System.Net.HttpListenerRequest.ContentLength64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera długość treści dane zawarte w żądaniu.</summary>
        <value>Wartość w żądaniu <see langword="Content-Length" /> nagłówka. Ta wartość wynosi -1, jeśli długość treści nie jest znany.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Content-Length` Nagłówka wyraża w bajtach długość danych treści towarzyszący żądaniu.  
  
 Aby uzyskać pełną listę nagłówków żądań, zobacz <xref:System.Net.HttpRequestHeader> wyliczenia.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.HttpListenerRequest.ContentLength64%2A> właściwości podczas przetwarzania danych treści.  
  
 [!code-csharp[Net_Listener_Basic#16](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string" Usage="System.Net.HttpListenerRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ MIME treści dane zawarte w żądaniu.</summary>
        <value>A <see cref="T:System.String" /> zawiera treść żądania <see langword="Content-Type" /> nagłówka.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klienta zawiera treść danych w żądaniu, deklaruje typ poczty rozszerzenia MIME (Multipurpose Internet) danych treści w `Content-Type` nagłówka. Na przykład domyślny typ MIME danych zwracane z formularza sieci Web przy użyciu `POST` jest metoda `application/x-www-form-urlencoded`.  
  
 Aby uzyskać pełną listę nagłówków żądań, zobacz <xref:System.Net.HttpRequestHeader> wyliczenie i RFC 2616 dostępne pod adresem [ https://www.rfc-editor.org ](https://www.rfc-editor.org/).  
  
 <xref:System.Net.HttpListenerRequest.ContentType%2A> Ma wartość null, gdy ma nie `Content-Type` nagłówka w żądaniu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak używać tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#16](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Net.CookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As CookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::CookieCollection ^ Cookies { System::Net::CookieCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cookies : System.Net.CookieCollection" Usage="System.Net.HttpListenerRequest.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.CookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pliki cookie wysłanych w żądaniu.</summary>
        <value>A <see cref="T:System.Net.CookieCollection" /> zawierający pliki cookie, dołączone do żądania. Ta właściwość zwraca pustą kolekcję, jeśli żądanie nie zawiera plików cookie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plik cookie jest dane tekstowe nazwa/wartość z serwera sieci Web, która jest przechowywana na komputerze lokalnym (klient).  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia wartości plików cookie wysłanych w żądaniu.  
  
 [!code-csharp[Net_Listener_Basic#18](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#18)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="EndGetClientCertificate">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509Certificate2 EndGetClientCertificate (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.Cryptography.X509Certificates.X509Certificate2 EndGetClientCertificate(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerRequest.EndGetClientCertificate(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetClientCertificate (asyncResult As IAsyncResult) As X509Certificate2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::Cryptography::X509Certificates::X509Certificate2 ^ EndGetClientCertificate(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndGetClientCertificate : IAsyncResult -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="httpListenerRequest.EndGetClientCertificate asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate2</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oczekujące żądanie certyfikatu.</param>
        <summary>Kończy żądanie asynchroniczne dla klienta X.509 v.3 certyfikatu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiekt, który jest zwracany, gdy operacja rozpoczęta.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie uzyskano przez wywołanie metody <see cref="M:System.Net.HttpListenerRequest.BeginGetClientCertificate(System.AsyncCallback,System.Object)" /><paramref name="e." /></exception>
        <exception cref="T:System.InvalidOperationException">Ta metoda już wywołano dla operacji identyfikowanych <paramref name="asyncResult" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetClientCertificate">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509Certificate2 GetClientCertificate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.Cryptography.X509Certificates.X509Certificate2 GetClientCertificate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerRequest.GetClientCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Function GetClientCertificate () As X509Certificate2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::Cryptography::X509Certificates::X509Certificate2 ^ GetClientCertificate();" />
      <MemberSignature Language="F#" Value="member this.GetClientCertificate : unit -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="httpListenerRequest.GetClientCertificate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate2</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera certyfikat v.3 X.509.</summary>
        <returns>A <see cref="N:System.Security.Cryptography.X509Certificates" /> obiekt, który zawiera certyfikat v.3 X.509.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia blokowanie do momentu pobrania certyfikatu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wywołanie tej metody można pobrać certyfikat v.3 X.509 klienta jest w toku i w związku z tym innym wywołaniu tej metody nie można dokonać korekty.</exception>
        <altmember cref="N:System.Security.Cryptography.X509Certificates" />
      </Docs>
    </Member>
    <Member MemberName="GetClientCertificateAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Security.Cryptography.X509Certificates.X509Certificate2&gt; GetClientCertificateAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Security.Cryptography.X509Certificates.X509Certificate2&gt; GetClientCertificateAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerRequest.GetClientCertificateAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function GetClientCertificateAsync () As Task(Of X509Certificate2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Security::Cryptography::X509Certificates::X509Certificate2 ^&gt; ^ GetClientCertificateAsync();" />
      <MemberSignature Language="F#" Value="member this.GetClientCertificateAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Security.Cryptography.X509Certificates.X509Certificate2&gt;" Usage="httpListenerRequest.GetClientCertificateAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Security.Cryptography.X509Certificates.X509Certificate2&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera certyfikat v.3 X.509 klienta jako operację asynchroniczną.</summary>
        <returns>Zwraca <see cref="T:System.Threading.Tasks.Task`1" />.  Obiekt zadania reprezentujący operację asynchroniczną. <see cref="P:System.Threading.Tasks.Task`1.Result" /> Zwraca właściwości dla obiektu task <see cref="N:System.Security.Cryptography.X509Certificates" /> obiekt, który zawiera certyfikat v.3 X.509.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja nie będzie blokować. Zwrócona <xref:System.Threading.Tasks.Task%601> obiektu ukończy po pobraniu certyfikatu.  
  
 Jeśli wywołanie tej metody można pobrać certyfikat v.3 X.509 klienta jest w toku, nie można wprowadzić inne wywołanie tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Security.Cryptography.X509Certificates" />
      </Docs>
    </Member>
    <Member MemberName="HasEntityBody">
      <MemberSignature Language="C#" Value="public bool HasEntityBody { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasEntityBody" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.HasEntityBody" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasEntityBody As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasEntityBody { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasEntityBody : bool" Usage="System.Net.HttpListenerRequest.HasEntityBody" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Boolean" /> wartość, która wskazuje, czy żądanie jest skojarzony danych treści.</summary>
        <value>
          <see langword="true" /> Jeśli żądanie ma skojarzone danych treści. w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Żądania, który wysyła dane do serwera przy użyciu `POST` metody, na przykład powinien mieć treści jednostki.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, za pomocą tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#16](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Collections.Specialized.NameValueCollection" Usage="System.Net.HttpListenerRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję par nazw i wartości nagłówka wysłanych w żądaniu.</summary>
        <value>A <see cref="T:System.Net.WebHeaderCollection" /> zawiera nagłówki HTTP zawarte w żądaniu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nagłówki żądania zawierają informacje o metadanych. Na przykład nagłówków może zawierać jednolity identyfikator zasobów (URI) zasobu określonego przez klienta do serwera, tożsamość agenta użytkownika zatrudnieni przez klienta i MIME dopuszczalne typy danych w treści odpowiedzi.  
  
 Aby uzyskać pełną listę nagłówków żądań, zobacz <xref:System.Net.HttpRequestHeader> wyliczenia.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia wszystkie informacje w danym <xref:System.Net.WebHeaderCollection> obiektu.  
  
 [!code-csharp[Net_Listener_Basic#21](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#21)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="HttpMethod">
      <MemberSignature Language="C#" Value="public string HttpMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HttpMethod" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.HttpMethod" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HttpMethod As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ HttpMethod { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HttpMethod : string" Usage="System.Net.HttpListenerRequest.HttpMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera metody HTTP określonej przez klienta.</summary>
        <value>A <see cref="T:System.String" /> zawiera metodę użytą w żądaniu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda HTTP jest zwykle GET lub POST, w zależności od akcji żądanego przez klienta.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, za pomocą tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="InputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream InputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream InputStream" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.InputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ InputStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InputStream : System.IO.Stream" Usage="System.Net.HttpListenerRequest.InputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera strumień, który zawiera dane treści wysłane przez klienta.</summary>
        <value>Czytelny <see cref="T:System.IO.Stream" /> obiekt, który zawiera bajtów wysłanych przez klienta w treści żądania. Ta właściwość zwraca <see cref="F:System.IO.Stream.Null" /> Jeśli żadne dane nie są wysyłane z żądaniem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klient przesyła dane (na przykład przy użyciu protokołu HTTP `POST` metodę), Strumień zwrócony przez tę metodę zawiera dane.  
  
> [!NOTE]
>  Zamknięcie żądania nie zamknięcia Strumień zwrócony przez tę właściwość. Gdy strumień jest nie są już potrzebne, zamknij go przez wywołanie metody <xref:System.IO.Stream.Close%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, za pomocą tej właściwości można odczytać danych wysłanych z żądaniem.  
  
 [!code-csharp[Net_Listener_Basic#16](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#16)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Ten element członkowski generuje informacje o śledzeniu, gdy włączone śledzenie sieci w aplikacji. Aby uzyskać więcej informacji zobacz [sieci śledzenia .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAuthenticated : bool" Usage="System.Net.HttpListenerRequest.IsAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Always returns false")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Boolean" /> wartość, która wskazuje, czy klient wysyła to żądanie jest uwierzytelniony.</summary>
        <value>
          <see langword="true" /> Jeśli klient został uwierzytelniony; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja żądań klienta uwierzytelnianie przy użyciu <xref:System.Net.HttpListener.AuthenticationSchemes%2A> lub <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> właściwości.  
  
 Aplikacja nie otrzyma <xref:System.Net.HttpListenerContext> żądania od klientów, którzy nie zostali pomyślnie uwierzytelnieni.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia wartość <xref:System.Net.HttpListenerRequest.IsAuthenticated%2A> właściwości.  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="IsLocal">
      <MemberSignature Language="C#" Value="public bool IsLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLocal" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.IsLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLocal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLocal : bool" Usage="System.Net.HttpListenerRequest.IsLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Boolean" /> wartość, która wskazuje, czy żądanie jest wysyłane z komputera lokalnego.</summary>
        <value>
          <see langword="true" /> Jeśli żądanie pochodzi na tym samym komputerze co <see cref="T:System.Net.HttpListener" /> obiektu dostarczonego żądania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacje mogą używać tej właściwości wykonywanie specjalnego przetwarzania, w przypadku żądań z komputera lokalnego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, przy użyciu <xref:System.Net.HttpListenerRequest.IsLocal%2A> właściwości.  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="IsSecureConnection">
      <MemberSignature Language="C#" Value="public bool IsSecureConnection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecureConnection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.IsSecureConnection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSecureConnection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSecureConnection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecureConnection : bool" Usage="System.Net.HttpListenerRequest.IsSecureConnection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Boolean" /> wartość, która wskazuje, czy połączenie TCP, używaną do wysyłania żądania przy użyciu protokołu Secure Sockets Layer (SSL).</summary>
        <value>
          <see langword="true" /> Jeśli połączenie TCP jest przy użyciu protokołu SSL; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby poprosić o bezpiecznego połączenia, żądanie klienta używa <xref:System.Uri.UriSchemeHttps> zamiast <xref:System.Uri.UriSchemeHttp>. Jeśli nie można nawiązać połączenia przy użyciu protokołu SSL, klient odbierze <xref:System.Net.WebException> udostępniająca informacje o tym błędzie.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, przy użyciu <xref:System.Net.HttpListenerRequest.IsSecureConnection%2A> właściwości.  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequest">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequest" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.IsWebSocketRequest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequest As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequest { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequest : bool" Usage="System.Net.HttpListenerRequest.IsWebSocketRequest" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Boolean" /> wartość, która wskazuje, czy połączenie TCP zostało żądanie protokołu WebSocket.</summary>
        <value>Zwraca <see cref="T:System.Boolean" />.  
  
 <see langword="true" /> Jeśli połączenie TCP jest żądaniem protokołu WebSocket; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool" Usage="System.Net.HttpListenerRequest.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Boolean" /> wartość, która wskazuje, czy klient żąda trwałe połączenie.</summary>
        <value>
          <see langword="true" /> Jeśli połączenie należy zachować; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klient HTTP i serwer powinien wymiany danych wielokrotnie w krótkim czasie, połączenie trwałe przyspiesza komunikację przez pozwalający na uniknięcie dodatkowych czynności wymaganych do otwierania i zamykania połączenia TCP dla każdego komunikatu. Dla klientów korzystających z protokołu HTTP/1.1, wartością domyślną dla tej właściwości jest `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, za pomocą tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.IPEndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IPEndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As IPEndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::IPEndPoint ^ LocalEndPoint { System::Net::IPEndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.IPEndPoint" Usage="System.Net.HttpListenerRequest.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPEndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobierz adres IP i port numer do którego kierowane jest żądanie serwera.</summary>
        <value>
          <see cref="T:System.Net.IPEndPoint" /> Reprezentujący adres IP, które żądania są wysyłane do.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest przydatna, jeśli chcesz odpowiadać na żądania na podstawie sposobu ich są kierowane.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, za pomocą tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolVersion : Version" Usage="System.Net.HttpListenerRequest.ProtocolVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wersję protokołu HTTP używanego przez klienta.</summary>
        <value>A <see cref="T:System.Version" /> identyfikujący wersję klienta HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możliwości różnych wersji protokołu HTTP są określone w dokumentach dostępne pod adresem [ https://www.rfc-editor.org ](https://www.rfc-editor.org/).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, za pomocą tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="QueryString">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection QueryString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection QueryString" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.QueryString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property QueryString As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ QueryString { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.QueryString : System.Collections.Specialized.NameValueCollection" Usage="System.Net.HttpListenerRequest.QueryString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ciąg zapytania w żądaniu uwzględniono.</summary>
        <value>A <see cref="T:System.Collections.Specialized.NameValueCollection" /> obiekt zawierający dane zapytania w żądaniu uwzględniono <see cref="P:System.Net.HttpListenerRequest.Url" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W adresie URL informacje o kwerendzie jest oddzielony od informacje o ścieżce znakiem zapytania (?). Pary nazwa/wartość są oddzielone znakiem równości (=). Uzyskiwanie dostępu do danych zapytania jako pojedynczy ciąg, Pobierz <xref:System.Uri.Query%2A> wartość właściwości z <xref:System.Uri> obiektu zwróconego przez <xref:System.Net.HttpListenerRequest.Url%2A>.  
  
> [!NOTE]
>  Zapytania bez znaku równości (przykład: [ http://www.contoso.com/query.htm?Name ](http://www.contoso.com/query.htm?Name) ) są dodawane do `null` klucza w <xref:System.Collections.Specialized.NameValueCollection>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, przy użyciu <xref:System.Net.HttpListenerRequest.QueryString%2A> właściwości.  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="RawUrl">
      <MemberSignature Language="C#" Value="public string RawUrl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RawUrl" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.RawUrl" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawUrl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RawUrl { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RawUrl : string" Usage="System.Net.HttpListenerRequest.RawUrl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje adresu URL (bez hosta i portu) żądanego przez klienta.</summary>
        <value>A <see cref="T:System.String" /> zawierający nieprzetworzony adres URL dla tego żądania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nieprzetworzony adres URL jest zdefiniowany jako część adresu URL następujące informacje o domenie. W ciągu adresu URL `http://www.contoso.com/articles/recent.aspx`, nieprzetworzony adres URL jest `/articles/recent.aspx`. Nieprzetworzony adres URL zawiera ciąg zapytania, jeśli jest obecny.  
  
 Aby uzyskać informacje na temat hosta i portu, użyj <xref:System.Net.HttpListenerRequest.RemoteEndPoint%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, przy użyciu <xref:System.Net.HttpListenerRequest.RawUrl%2A> właściwości.  
  
 [!code-csharp[Net_Listener_Basic#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.IPEndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IPEndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As IPEndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::IPEndPoint ^ RemoteEndPoint { System::Net::IPEndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.IPEndPoint" Usage="System.Net.HttpListenerRequest.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPEndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera klienta IP adres i numer portu z której pochodzi żądanie.</summary>
        <value>
          <see cref="T:System.Net.IPEndPoint" /> Reprezentujący adres IP i port numer z której pochodzi żądanie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, za pomocą tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="RequestTraceIdentifier">
      <MemberSignature Language="C#" Value="public Guid RequestTraceIdentifier { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid RequestTraceIdentifier" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.RequestTraceIdentifier" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RequestTraceIdentifier As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid RequestTraceIdentifier { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestTraceIdentifier : Guid" Usage="System.Net.HttpListenerRequest.RequestTraceIdentifier" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Always returns Guid.Empty")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator żądania przychodzące żądanie HTTP.</summary>
        <value>A <see cref="T:System.Guid" /> obiekt, który zawiera identyfikator żądania HTTP.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceName">
      <MemberSignature Language="C#" Value="public string ServiceName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServiceName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ServiceName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServiceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ServiceName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServiceName : string" Usage="System.Net.HttpListenerRequest.ServiceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dostawcę nazwy usługi (SPN) wysyłanej przez klienta w żądaniu.</summary>
        <value>A <see cref="T:System.String" /> zawierający nazwę SPN wysłanych w żądaniu klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja może użyć <xref:System.Net.HttpListenerRequest.ServiceName%2A> właściwości do wykonywania niestandardowego sprawdzania poprawności nazwy Podaj usługi (SPN).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="P:System.Net.HttpListenerRequest.TransportContext" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="TransportContext">
      <MemberSignature Language="C#" Value="public System.Net.TransportContext TransportContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.TransportContext TransportContext" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.TransportContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransportContext As TransportContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::TransportContext ^ TransportContext { System::Net::TransportContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TransportContext : System.Net.TransportContext" Usage="System.Net.HttpListenerRequest.TransportContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.TransportContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Net.TransportContext" /> dla żądania klienta.</summary>
        <value>A <see cref="T:System.Net.TransportContext" /> dla żądania klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.TransportContext> Właściwości może służyć do pobierania token wiązania kanałów (CBT) dla <xref:System.Net.HttpListenerRequest> wysłania przy użyciu protokołu HTTPS.  
  
 Aplikacja może użyć <xref:System.Net.TransportContext> właściwości, aby wykonać niestandardowe uwierzytelnianie przy użyciu wywołań natywnych Win32 [działanie funkcji AcceptSecurityContext](http://go.microsoft.com/fwlink/?LinkId=147021) funkcji.  
  
 Jeśli aplikacja próbuje pobrać token wiązania kanałów (CBT) to <xref:System.Net.HttpListenerRequest.TransportContext%2A> za pomocą właściwości <xref:System.Net.TransportContext.GetChannelBinding%2A> — metoda i <xref:System.Security.Authentication.ExtendedProtection.ChannelBindingKind> nie jest <xref:System.Security.Authentication.ExtendedProtection.ChannelBindingKind.Endpoint>, a następnie <xref:System.Net.HttpListenerRequest> zgłosi <xref:System.NotSupportedException>. <xref:System.Net.HttpListenerRequest> Zastępuje <xref:System.Net.TransportContext.GetChannelBinding%2A> metody za pomocą wewnętrznej implementacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="P:System.Net.HttpListenerRequest.ServiceName" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="Url">
      <MemberSignature Language="C#" Value="public Uri Url { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Url" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.Url" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Url As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Url { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Url : Uri" Usage="System.Net.HttpListenerRequest.Url" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Uri" /> obiektu żądanego przez klienta.</summary>
        <value>A <see cref="T:System.Uri" /> obiekt, który identyfikuje zasób żądanego przez klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListenerRequest.Url%2A> Właściwości umożliwia uzyskiwanie informacji dostępnych w <xref:System.Uri> obiektu. Jeśli musisz wiedzieć nieprzetworzony tekst żądanie identyfikatora URI, należy rozważyć użycie <xref:System.Net.HttpListenerRequest.RawUrl%2A> właściwości zamiast tego.  
  
 <xref:System.Net.HttpListenerRequest.Url%2A> Właściwość ma wartość null Jeśli <xref:System.Uri> z klienta nie można przeanalizować.  
  
 <xref:System.Net.Configuration.HttpListenerElement.UnescapeRequestUrl%2A> Właściwość wskazuje, czy <xref:System.Net.HttpListener> używa raw URI niezmienionym znaczeniu zamiast przekonwertowanego identyfikatora URI, gdzie wartości procent, kodowane są konwertowane, i są pobierane z procedurą normalizacji.  
  
 Gdy <xref:System.Net.HttpListener> wystąpienia odbiera żądanie za pośrednictwem `http.sys` usługi, tworzy wystąpienie ciągu identyfikatora URI dostarczonych przez `http.sys`i uwidacznia go jako <xref:System.Net.HttpListenerRequest.Url%2A?displayProperty=nameWithType> właściwości.  
  
 `http.sys` Usługi udostępnia dwa ciągi identyfikatora URI żądania:  
  
-   Nieprzetworzona identyfikatora URI.  
  
-   Przekonwertowana identyfikatora URI.  
  
 Nieprzetworzona identyfikator URI jest <xref:System.Uri?displayProperty=nameWithType> dostępne w wierszu żądania HTTP żądania:  
  
 `GET /path/`  
  
 `Host: www.contoso.com`  
  
 Nieprzetworzone udostępniane przez identyfikator URI `http.sys` dla żądania wymienionych powyżej, jest "/ path /". Reprezentuje ciąg następujący zlecenie HTTP, jak została wysłana przez sieć.  
  
 `http.sys` Usługi tworzy przekonwertowanego identyfikatora URI na podstawie informacji dostępnych w żądaniu przy użyciu identyfikatora URI, dostępne w wierszu żądania HTTP i powinny zostać przekazane nagłówek hosta, aby określić serwer pochodzenia żądania. Jest to realizowane przez porównanie informacji z żądania z zestawem zarejestrowanych prefiksów identyfikatorów URI. Aby można było porównać wartości, należy jednak wykonać niektóre normalizacji na żądanie. Dla przykładu powyżej przekonwertowanego identyfikator URI będzie w następujący sposób:  
  
 `http://www.contoso.com/path/`  
  
 `http.sys` Usługi łączy <xref:System.Uri.Host%2A?displayProperty=nameWithType> wartość właściwości i ciąg w wierszu żądania do utworzenia przekonwertowanego identyfikatora URI. Ponadto `http.sys` i <xref:System.Uri?displayProperty=nameWithType> klasy również wykonać następujące czynności:  
  
-   Wyrejestruj specjalne procent wszystkich wartości zakodowany.  
  
-   Konwertuje procent, kodowane znaki spoza zestawu ASCII w reprezentacji znaków UTF-16. Należy pamiętać, że oraz znaków Unicode (kodowanie Unicode w formacie % uXXXX) są obsługiwane znaki UTF-8 i ANSI/zestawów znaków Dwubajtowych.  
  
-   Wykonuje inne czynności normalizacji, takie jak ścieżka kompresji.  
  
 Ponieważ żądanie nie zawiera żadnych informacji o kodowanie używane z algorytmem procent wartości, nie może być określić poprawne kodowanie właśnie, analizując kodowany w formacie procent wartości.  
  
 W związku z tym `http.sys` zawiera dwa klucze rejestru do modyfikowania proces:  
  
|Klucz rejestru|Wartość domyślna|Opis|  
|------------------|-------------------|-----------------|  
|EnableNonUTF8|1|Jeśli zero, `http.sys` akceptuje tylko adresy URL algorytmem UTF-8.<br /><br /> Jeśli niezerową, `http.sys` również akceptuje kodowaniu ANSI lub kodowany w formacie DBCS adresów URL w żądaniach.|  
|FavorUTF8|1|Jeśli niezerową, `http.sys` zawsze próbuje dekodowanie adresu URL jako UTF-8 najpierw; Jeśli tej konwersji nie powiedzie się i EnableNonUTF8 jest różna od zera, sterownik Http.sys, a następnie próbuje zdekodować kodowaniu ANSI lub zestawów znaków Dwubajtowych.<br /><br /> Jeśli zero (i EnableNonUTF8 jest różna od zera) `http.sys` podejmuje próbę zdekodowania kodowaniu ANSI lub DBCS; Jeśli się nie powiedzie, próby konwersji UTF-8.|  
  
 Gdy <xref:System.Net.HttpListener> odbiera żądanie, używa przekonwertowanego identyfikatora URI z `http.sys` jako wejściowych do <xref:System.Net.HttpListenerRequest.Url%2A> właściwości.  
  
 Istnieje potrzeba do obsługi znaki oprócz znaków i liczb w identyfikatorów URI. Przykładem jest następujący identyfikator URI, który służy do pobierania informacji klienta dla klienta numer "1/3812":  
  
 `http://www.contoso.com/Customer('1%2F3812')/`  
  
 Należy zwrócić uwagę ukośnika procent, kodowane w identyfikatorze Uri (% 2F). Jest to konieczne, ponieważ w takim przypadku znaku ukośnika reprezentuje danych i nie ogranicznik ścieżki.  
  
 Przekazywanie ciągu identyfikatora Uri konstruktora doprowadzi do następującego identyfikatora URI:  
  
 `http://www.contoso.com/Customer('1/3812')/`  
  
 Dzielenie na jego segmenty ścieżki spowoduje następujące elementy:  
  
 `Customer('1`  
  
 `3812')`  
  
 To nie jest celem nadawca żądania.  
  
 Jeśli <xref:System.Net.Configuration.HttpListenerElement.UnescapeRequestUrl%2A> właściwość jest ustawiona na wartość false, a następnie po <xref:System.Net.HttpListener> odbiera żądanie, używa raw URI zamiast przekonwertowanego identyfikatora URI z `http.sys` jako wejściowych do <xref:System.Net.HttpListenerRequest.Url%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, przy użyciu <xref:System.Net.HttpListenerRequest.Url%2A> właściwości.  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Configuration.HttpListenerElement" />
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="UrlReferrer">
      <MemberSignature Language="C#" Value="public Uri UrlReferrer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri UrlReferrer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.UrlReferrer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UrlReferrer As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ UrlReferrer { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UrlReferrer : Uri" Usage="System.Net.HttpListenerRequest.UrlReferrer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera jednolity identyfikator zasobów (URI) zasobu określonego przez klienta do serwera.</summary>
        <value>A <see cref="T:System.Uri" /> obiekt, który zawiera treść żądania <see cref="F:System.Net.HttpRequestHeader.Referer" /> nagłówka, lub <see langword="null" /> Jeśli nagłówek nie został uwzględniony w żądaniu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klient ma wykonane hiperłącza do żądanego identyfikatora URI, żądania mogą zawierać `Referrer` nagłówek, który identyfikuje identyfikator URI zasobu, który zawiera hiperłącza.  
  
 Klienci mogą fałszowanie lub wybierz nie przedstawić <xref:System.Net.HttpRequestHeader.Referer> nagłówka. W związku z tym podczas <xref:System.Net.HttpListenerRequest.UrlReferrer%2A> właściwość może być przydatny do identyfikowania podstawowe trendy w ruchu w sieci Web; nie należy używać go jako część schematu autoryzacji do kontrolowania dostępu do danych.  
  
 Aby uzyskać pełną listę nagłówków żądań, zobacz <xref:System.Net.HttpRequestHeader> wyliczenia.  
  
 <xref:System.Net.HttpListenerRequest.UrlReferrer%2A> Ma wartość null, gdy istnieje nie `Referrer` nagłówka w żądaniu lub gdy `Referrer` nagłówka jest obecny w żądaniu, ale nie analizuje do prawidłowej <xref:System.Uri>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, za pomocą tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string" Usage="System.Net.HttpListenerRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera agenta użytkownika przedstawione przez klienta.</summary>
        <value>A <see cref="T:System.String" /> obiekt, który zawiera treść żądania <see langword="User-Agent" /> nagłówka.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `User-Agent` Nagłówka zwykle zawiera tekst, który określa nazwę i wersję liczbę oprogramowania służącego do generowania żądania.  
  
 Aby uzyskać pełną listę nagłówków żądań, zobacz <xref:System.Net.HttpRequestHeader> wyliczenia.  
  
 <xref:System.Net.HttpListenerRequest.UserAgent%2A> Ma wartość null, gdy ma nie `User-Agent` nagłówka w żądaniu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, za pomocą tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="UserHostAddress">
      <MemberSignature Language="C#" Value="public string UserHostAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostAddress" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.UserHostAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostAddress { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserHostAddress : string" Usage="System.Net.HttpListenerRequest.UserHostAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera adres IP i port numer do którego kierowane jest żądanie serwera.</summary>
        <value>A <see cref="T:System.String" /> zawierający informacje o adresie hosta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informacje zwracane przez tę właściwość jest również dostępna w <xref:System.Net.HttpListenerRequest.LocalEndPoint%2A> wartości właściwości.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia wartość tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="UserHostName">
      <MemberSignature Language="C#" Value="public string UserHostName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.UserHostName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserHostName : string" Usage="System.Net.HttpListenerRequest.UserHostName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę DNS i, jeśli zostanie podana, numer portu określony przez klienta.</summary>
        <value>A <see cref="T:System.String" /> wartości, która zawiera treść żądania <see langword="Host" /> nagłówka.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Host` Nagłówek zawiera nazwę hosta żądanej serwera i numer portu, jeśli jest określony, oddzielone dwukropkiem (na przykład `www.contoso.com:8080`).  
  
 Ta właściwość służy do zwracania odpowiedzi różne w zależności od nazwy hosta określonej w żądaniu.  
  
 Aby uzyskać pełną listę nagłówków żądań, zobacz <xref:System.Net.HttpRequestHeader> wyliczenia.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, za pomocą tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="UserLanguages">
      <MemberSignature Language="C#" Value="public string[] UserLanguages { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] UserLanguages" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.UserLanguages" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserLanguages As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ UserLanguages { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserLanguages : string[]" Usage="System.Net.HttpListenerRequest.UserLanguages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera języków naturalnych, które są preferowane dla odpowiedzi.</summary>
        <value>A <see cref="T:System.String" /> tablica zawierająca języków określony w żądaniu <see cref="F:System.Net.HttpRequestHeader.AcceptLanguage" /> nagłówka lub <see langword="null" /> Jeśli żądanie klienta nie zawiera <see cref="F:System.Net.HttpRequestHeader.AcceptLanguage" /> nagłówka.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać szczegółowy opis `Accept-Language` nagłówka, w sekcji RFC 2616 14.4 dostępne pod adresem [ https://www.rfc-editor.org ](https://www.rfc-editor.org/).  
  
 Aby uzyskać pełną listę nagłówków żądań, zobacz <xref:System.Net.HttpRequestHeader> wyliczenia.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia językach w żądaniu `Accept-Language` nagłówka.  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
  </Members>
</Type>
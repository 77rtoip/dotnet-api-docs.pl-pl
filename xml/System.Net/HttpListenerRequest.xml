<Type Name="HttpListenerRequest" FullName="System.Net.HttpListenerRequest">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7121ea733b1306868bd3111e0fe52b94622831bc" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58714688" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpListenerRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpListenerRequest extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpListenerRequest" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpListenerRequest" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpListenerRequest sealed" />
  <TypeSignature Language="F#" Value="type HttpListenerRequest = class" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.HttpListener</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>W tym artykule opisano przychodzących żądań HTTP w ramach <see cref="T:System.Net.HttpListener" /> obiektu. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy klient wysyła żądanie do jednolite zasobów identyfikator (URI) obsługiwane przez <xref:System.Net.HttpListener> obiektu <xref:System.Net.HttpListener> zapewnia <xref:System.Net.HttpListenerContext> obiektu, który zawiera informacje o nadawcy, żądania i odpowiedzi, które są wysyłane do klienta. <xref:System.Net.HttpListenerContext.Request%2A?displayProperty=nameWithType> Właściwość zwraca <xref:System.Net.HttpListenerRequest> obiekt, który opisuje żądania.  
  
 <xref:System.Net.HttpListenerRequest> Obiekt zawiera informacje o żądaniu, takie jak żądania <xref:System.Net.HttpListenerRequest.HttpMethod%2A> ciągu, <xref:System.Net.HttpListenerRequest.UserAgent%2A> ciąg i dane w treści żądania (zobacz <xref:System.Net.HttpListenerRequest.InputStream%2A> właściwości).  
  
 Aby odpowiedzieć na żądanie, należy uzyskać przy użyciu odpowiedzi skojarzona <xref:System.Net.HttpListenerContext.Response%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak otrzymywanie i odpowiadanie na <xref:System.Net.HttpListenerRequest>.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.HttpListener" />
    <altmember cref="T:System.Net.HttpListenerContext" />
    <altmember cref="T:System.Net.HttpListenerResponse" />
  </Docs>
  <Members>
    <Member MemberName="AcceptTypes">
      <MemberSignature Language="C#" Value="public string[] AcceptTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AcceptTypes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.AcceptTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AcceptTypes As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AcceptTypes { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AcceptTypes : string[]" Usage="System.Net.HttpListenerRequest.AcceptTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typy MIME zaakceptowane przez klienta.</summary>
        <value>A <see cref="T:System.String" /> tablicy, która zawiera nazwy typu, określony w żądaniu <see langword="Accept" /> nagłówek lub <see langword="null" /> Jeśli żądanie klienta nie zawiera <see langword="Accept" /> nagłówka.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Accept` Nagłówka to ciąg rozdzielonych spacjami nazwy typów protokołu dynamicznej konfiguracji hosta (MIME, Multipurpose Internet Mail Extensions) (na przykład `image/jpeg`), które wskazują typy MIME, które klient jest przygotowany do przyjmował i przetwarzał w odpowiedzi. `*/*` Wpis wskazuje, czy klient akceptuje dowolny typ MIME. Aby uzyskać szczegółowy opis `Accept` nagłówka, zobacz RFC 2616, dostępne pod adresem [ https://www.rfc-editor.org ](https://www.rfc-editor.org/).  
  
 Aby uzyskać pełną listę nagłówków żądań, zobacz <xref:System.Net.HttpRequestHeader> wyliczenia.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, użycie tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="BeginGetClientCertificate">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginGetClientCertificate (AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginGetClientCertificate(class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerRequest.BeginGetClientCertificate(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginGetClientCertificate (requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginGetClientCertificate(AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginGetClientCertificate : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpListenerRequest.BeginGetClientCertificate (requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="requestCallback"><see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po ukończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje na temat operacji. Ten obiekt jest przekazywany do delegata wywołania zwrotnego, po zakończeniu operacji.</param>
        <summary>Rozpoczyna się asynchroniczne żądanie klienta X.509 v.3 certyfikatu.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Oznacza stan operacji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificateError">
      <MemberSignature Language="C#" Value="public int ClientCertificateError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ClientCertificateError" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ClientCertificateError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientCertificateError As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ClientCertificateError { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificateError : int" Usage="System.Net.HttpListenerRequest.ClientCertificateError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kod błędu, który wykryje problem z <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" /> dostarczonych przez klienta.</summary>
        <value><see cref="T:System.Int32" /> Wartość, która zawiera kod błędu Windows.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawiera kod błędu Windows, zwrócony przez bezpiecznego kanału (Schannel) zabezpieczeń interfejs dostawcy obsługi (SSPI), który jest używany do weryfikacji certyfikatu. Aby uzyskać więcej informacji na temat obsługi interfejsu SSPI dla dostawcy Schannel, zobacz "Tworzenie zabezpieczyć połączenie przy użyciu kanału Schannel" w dokumentacji zabezpieczeń na [ http://msdn.microsoft.com/library ](https://msdn.microsoft.com/library).  
  
   
  
## Examples  
 Poniższy przykład kodu sprawdza tę właściwość, aby ustalić, czy żądanie zawiera prawidłowy certyfikat klienta.  
  
 [!code-csharp[NCLListener#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#3)]
 [!code-vb[NCLListener#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie zainicjowano jeszcze certyfikatu klienta za pomocą wywołania <see cref="M:System.Net.HttpListenerRequest.BeginGetClientCertificate(System.AsyncCallback,System.Object)" /> lub <see cref="M:System.Net.HttpListenerRequest.GetClientCertificate" /> metody 
- lub - 
Operacja jest nadal w toku.</exception>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentEncoding : System.Text.Encoding" Usage="System.Net.HttpListenerRequest.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kodowanie zawartości, które mogą być używane z danych przesyłanych z żądaniem</summary>
        <value><see cref="T:System.Text.Encoding" /> Odpowiedni do użytku z danymi w obiekcie <see cref="P:System.Net.HttpListenerRequest.InputStream" /> właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding> Obiekt może służyć do konwertowania sekwencji bajtów do zestawów znaków (stron kodowych) i znaki na sekwencje bajtów. Ta właściwość używa wartości charset `Content-Type` nagłówek, aby określić kodowanie. Jeśli te informacje nie są dostępne, właściwość ta zwraca <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Net.HttpListenerRequest.ContentEncoding%2A> właściwości.  
  
 [!code-csharp[Net_Listener_Basic#16](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="ContentLength64">
      <MemberSignature Language="C#" Value="public long ContentLength64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength64" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ContentLength64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentLength64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ContentLength64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength64 : int64" Usage="System.Net.HttpListenerRequest.ContentLength64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera długość danych treści zawarte w żądaniu.</summary>
        <value>Wartość w żądaniu <see langword="Content-Length" /> nagłówka. Ta wartość jest wartość -1, jeśli długość zawartości jest nieznany.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Content-Length` Nagłówka określa długość w bajtach, danych treści, który towarzyszy żądania.  
  
 Aby uzyskać pełną listę nagłówków żądań, zobacz <xref:System.Net.HttpRequestHeader> wyliczenia.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.HttpListenerRequest.ContentLength64%2A> właściwości podczas przetwarzania danych treści.  
  
 [!code-csharp[Net_Listener_Basic#16](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string" Usage="System.Net.HttpListenerRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ MIME danych treści zawarte w żądaniu.</summary>
        <value>A <see cref="T:System.String" /> zawierające tekst żądania <see langword="Content-Type" /> nagłówka.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klient zawiera dane treści w żądaniu, deklaruje typ protokołu dynamicznej konfiguracji hosta (MIME, Multipurpose Internet Mail Extensions) danych treści w `Content-Type` nagłówka. Na przykład domyślny typ MIME danych zwróciło formularza sieci Web przy użyciu `POST` metodą jest `application/x-www-form-urlencoded`.  
  
 Aby uzyskać pełną listę nagłówków żądań, zobacz <xref:System.Net.HttpRequestHeader> wyliczenie i w dokumencie RFC 2616, dostępne pod adresem [ https://www.rfc-editor.org ](https://www.rfc-editor.org/).  
  
 <xref:System.Net.HttpListenerRequest.ContentType%2A> Ma wartość null, gdy istnieje nie `Content-Type` nagłówka w żądaniu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak używać tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#16](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Net.CookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As CookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::CookieCollection ^ Cookies { System::Net::CookieCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cookies : System.Net.CookieCollection" Usage="System.Net.HttpListenerRequest.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.CookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pliki cookie wysłanych z żądaniem.</summary>
        <value>Element <see cref="T:System.Net.CookieCollection" /> zawierający pliki cookie, dołączone do żądania. Ta właściwość zwraca pustą kolekcję, jeśli żądanie nie zawiera plików cookie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plik cookie jest nazwa/wartość danych tekstowych z serwera sieci Web, która jest przechowywana na komputerze lokalny (klient).  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartości plików cookie wysłanych z żądaniem.  
  
 [!code-csharp[Net_Listener_Basic#18](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#18)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="EndGetClientCertificate">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509Certificate2 EndGetClientCertificate (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.Cryptography.X509Certificates.X509Certificate2 EndGetClientCertificate(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerRequest.EndGetClientCertificate(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetClientCertificate (asyncResult As IAsyncResult) As X509Certificate2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::Cryptography::X509Certificates::X509Certificate2 ^ EndGetClientCertificate(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndGetClientCertificate : IAsyncResult -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="httpListenerRequest.EndGetClientCertificate asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate2</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oczekujące żądanie certyfikatu.</param>
        <summary>Kończy żądanie asynchroniczne dla klienta X.509 v.3 certyfikatu.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt, który jest zwracany, jeśli operacja rozpoczęta.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> nie uzyskano przez wywołanie metody <see cref="M:System.Net.HttpListenerRequest.BeginGetClientCertificate(System.AsyncCallback,System.Object)" /><paramref name="e." /></exception>
        <exception cref="T:System.InvalidOperationException">Ta metoda już została wywołana dla operacji identyfikowane przez <paramref name="asyncResult" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetClientCertificate">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509Certificate2 GetClientCertificate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.Cryptography.X509Certificates.X509Certificate2 GetClientCertificate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerRequest.GetClientCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Function GetClientCertificate () As X509Certificate2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::Cryptography::X509Certificates::X509Certificate2 ^ GetClientCertificate();" />
      <MemberSignature Language="F#" Value="member this.GetClientCertificate : unit -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="httpListenerRequest.GetClientCertificate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate2</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera certyfikat v.3 X.509 klienta.</summary>
        <returns>A <see cref="N:System.Security.Cryptography.X509Certificates" /> obiekt, który zawiera certyfikat v.3 X.509 klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda blokuje do momentu pobrania jest certyfikat.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wywołanie tej metody do pobierania klienta X.509 v.3 certyfikatów jest w toku i dlatego nie można wprowadzać inne wywołanie tej metody.</exception>
        <altmember cref="N:System.Security.Cryptography.X509Certificates" />
      </Docs>
    </Member>
    <Member MemberName="GetClientCertificateAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Security.Cryptography.X509Certificates.X509Certificate2&gt; GetClientCertificateAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Security.Cryptography.X509Certificates.X509Certificate2&gt; GetClientCertificateAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerRequest.GetClientCertificateAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function GetClientCertificateAsync () As Task(Of X509Certificate2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Security::Cryptography::X509Certificates::X509Certificate2 ^&gt; ^ GetClientCertificateAsync();" />
      <MemberSignature Language="F#" Value="member this.GetClientCertificateAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Security.Cryptography.X509Certificates.X509Certificate2&gt;" Usage="httpListenerRequest.GetClientCertificateAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Security.Cryptography.X509Certificates.X509Certificate2&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera certyfikat v.3 X.509 klienta jako operację asynchroniczną.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną. <see cref="P:System.Threading.Tasks.Task`1.Result" /> Zwraca właściwości dla obiektu task <see cref="N:System.Security.Cryptography.X509Certificates" /> obiekt, który zawiera certyfikat v.3 X.509 klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja nie będzie blokować. Zwrócony <xref:System.Threading.Tasks.Task%601> obiektu zostanie ukończone, gdy certyfikat zostały pobrane.  
  
 Jeśli wywołanie tej metody do pobierania klienta X.509 v.3 certyfikatów jest w toku, nie można wprowadzać inne wywołanie tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Security.Cryptography.X509Certificates" />
      </Docs>
    </Member>
    <Member MemberName="HasEntityBody">
      <MemberSignature Language="C#" Value="public bool HasEntityBody { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasEntityBody" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.HasEntityBody" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasEntityBody As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasEntityBody { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasEntityBody : bool" Usage="System.Net.HttpListenerRequest.HasEntityBody" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Boolean" /> wartość, która wskazuje, czy żądanie ma skojarzone dane treści.</summary>
        <value><see langword="true" /> Jeśli żądanie ma skojarzone danych treści. w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Żądanie, która wysyła dane do serwera przy użyciu `POST` metody, na przykład, powinien mieć treści jednostki.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, użycie tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#16](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Collections.Specialized.NameValueCollection" Usage="System.Net.HttpListenerRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję par nazwa/wartość nagłówka w żądaniu.</summary>
        <value>Element <see cref="T:System.Net.WebHeaderCollection" /> zawierający nagłówki HTTP, zawarty w żądaniu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nagłówki żądania zawierają informacje o metadanych. Na przykład nagłówki mogą zawierać jednolity identyfikator zasobów (URI) zasobu określonego klienta do serwera, tożsamość agenta użytkownika zatrudnionych przez klienta i MIME akceptowane typy danych w treści odpowiedzi.  
  
 Aby uzyskać pełną listę nagłówków żądań, zobacz <xref:System.Net.HttpRequestHeader> wyliczenia.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wszystkie informacje w danym <xref:System.Net.WebHeaderCollection> obiektu.  
  
 [!code-csharp[Net_Listener_Basic#21](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#21)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="HttpMethod">
      <MemberSignature Language="C#" Value="public string HttpMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HttpMethod" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.HttpMethod" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HttpMethod As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ HttpMethod { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HttpMethod : string" Usage="System.Net.HttpListenerRequest.HttpMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera metody HTTP, określony przez klienta.</summary>
        <value>Element <see cref="T:System.String" /> zawierający metodę używaną w żądaniu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda HTTP jest zazwyczaj GET lub POST, w zależności od akcji żądanego przez klienta.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, użycie tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="InputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream InputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream InputStream" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.InputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ InputStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InputStream : System.IO.Stream" Usage="System.Net.HttpListenerRequest.InputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera strumień, który zawiera dane treści wysłane przez klienta.</summary>
        <value>Czytelny <see cref="T:System.IO.Stream" /> obiekt, który zawiera bajty wysłane przez klienta w treści żądania. Ta właściwość zwraca <see cref="F:System.IO.Stream.Null" /> Jeśli żadne dane nie są wysyłane z żądaniem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klient przesyła dane (na przykład przy użyciu protokołu HTTP `POST` metoda), strumienia zwracanego przez tę metodę zawiera dane.  
  
> [!NOTE]
>  Zamknięcie żądania nie zamyka Strumień zwrócony przez tę właściwość. Jeśli nie potrzebujesz już strumienia, zamknij go, wywołując <xref:System.IO.Stream.Close%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, za pomocą tej właściwości można odczytać dane wysłane z żądaniem.  
  
 [!code-csharp[Net_Listener_Basic#16](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#16)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAuthenticated : bool" Usage="System.Net.HttpListenerRequest.IsAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Always returns false")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Boolean" /> wartość, która wskazuje, czy jest uwierzytelniany klient wysyła to żądanie.</summary>
        <value><see langword="true" /> Jeśli klient został uwierzytelniony; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uwierzytelnianie klienta przy użyciu żądań aplikacji <xref:System.Net.HttpListener.AuthenticationSchemes%2A> lub <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> właściwości.  
  
 Aplikacja nie otrzyma <xref:System.Net.HttpListenerContext> żądania od klientów, które nie zostały pomyślnie uwierzytelnione.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość <xref:System.Net.HttpListenerRequest.IsAuthenticated%2A> właściwości.  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="IsLocal">
      <MemberSignature Language="C#" Value="public bool IsLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLocal" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.IsLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLocal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLocal : bool" Usage="System.Net.HttpListenerRequest.IsLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Boolean" /> wartość, która wskazuje, czy żądanie jest wysyłane z komputera lokalnego.</summary>
        <value><see langword="true" /> Jeśli żądanie pochodzi z tym samym komputerze co <see cref="T:System.Net.HttpListener" /> obiekt, który podano żądania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacje można użyć tej właściwości, wykonywanie specjalnego przetwarzania, w przypadku żądań z komputera lokalnego.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Net.HttpListenerRequest.IsLocal%2A> właściwości.  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="IsSecureConnection">
      <MemberSignature Language="C#" Value="public bool IsSecureConnection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecureConnection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.IsSecureConnection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSecureConnection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSecureConnection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecureConnection : bool" Usage="System.Net.HttpListenerRequest.IsSecureConnection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Boolean" /> wartość, która wskazuje, czy połączenie TCP używany do wysyłania żądania przy użyciu protokołu Secure Sockets Layer (SSL).</summary>
        <value><see langword="true" /> Jeśli połączenie TCP jest przy użyciu protokołu SSL; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zażądać bezpiecznego połączenia, żądanie klienta używa <xref:System.Uri.UriSchemeHttps> zamiast <xref:System.Uri.UriSchemeHttp>. Jeśli nie można nawiązać połączenia przy użyciu protokołu SSL, klient odbierze <xref:System.Net.WebException> zawierające informacje o błędzie.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Net.HttpListenerRequest.IsSecureConnection%2A> właściwości.  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequest">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequest" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.IsWebSocketRequest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequest As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequest { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequest : bool" Usage="System.Net.HttpListenerRequest.IsWebSocketRequest" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Boolean" /> wartość, która wskazuje, czy połączenie TCP zostało żądanie protokołu WebSocket.</summary>
        <value>Zwraca <see cref="T:System.Boolean" />.  
  
 <see langword="true" /> Jeśli połączenie TCP jest żądanie protokołu WebSocket; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool" Usage="System.Net.HttpListenerRequest.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Boolean" /> wartość, która wskazuje, czy klient żąda trwałego połączenia.</summary>
        <value><see langword="true" /> Jeśli połączenie należy zachować; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klient HTTP i serwer powinien wymiany danych wielokrotnie w krótkim czasie, połączenie trwałe przyspiesza komunikację, umożliwiając im uniknąć dodatkowych czynności wymaganych do otwierania i zamykania połączenia protokołu TCP dla każdego komunikatu. Dla klientów używających protokołu HTTP/1.1, wartością domyślną dla tej właściwości jest `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, użycie tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.IPEndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IPEndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As IPEndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::IPEndPoint ^ LocalEndPoint { System::Net::IPEndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.IPEndPoint" Usage="System.Net.HttpListenerRequest.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPEndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera serwera IP adres i numer portu do którego kierowane jest żądanie.</summary>
        <value><see cref="T:System.Net.IPEndPoint" /> Reprezentujący adres IP, które żądania są wysyłane do.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest przydatna, gdy chcesz odpowiadać na żądania, w oparciu o sposób, w jaki są adresowane.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, użycie tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolVersion : Version" Usage="System.Net.HttpListenerRequest.ProtocolVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wersję protokołu HTTP używaną przez klienta.</summary>
        <value>A <see cref="T:System.Version" /> określający wersję klienta HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możliwości w różnych wersjach HTTP są określone w dokumentach, które są dostępne pod adresem [ https://www.rfc-editor.org ](https://www.rfc-editor.org/).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, użycie tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="QueryString">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection QueryString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection QueryString" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.QueryString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property QueryString As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ QueryString { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.QueryString : System.Collections.Specialized.NameValueCollection" Usage="System.Net.HttpListenerRequest.QueryString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ciąg zapytania, zawarty w żądaniu.</summary>
        <value>A <see cref="T:System.Collections.Specialized.NameValueCollection" /> obiekt, który zawiera dane dla zapytania w żądaniu uwzględniono <see cref="P:System.Net.HttpListenerRequest.Url" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W adresie URL dane zapytania jest oddzielone od informacji o ścieżce przez znak zapytania (?). Pary nazwa/wartość są oddzielone znak równości (=). Aby uzyskać dostęp do danych zapytania jako pojedynczy ciąg, Uzyskaj <xref:System.Uri.Query%2A> wartość właściwości z <xref:System.Uri> obiektu zwróconego przez <xref:System.Net.HttpListenerRequest.Url%2A>.  
  
> [!NOTE]
>  Zapytania bez znaku równości (przykład: [ http://www.contoso.com/query.htm?Name ](http://www.contoso.com/query.htm?Name) ) są dodawane do `null` w <xref:System.Collections.Specialized.NameValueCollection>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Net.HttpListenerRequest.QueryString%2A> właściwości.  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="RawUrl">
      <MemberSignature Language="C#" Value="public string RawUrl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RawUrl" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.RawUrl" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawUrl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RawUrl { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RawUrl : string" Usage="System.Net.HttpListenerRequest.RawUrl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje adresu URL (bez hosta i portu) zażądane przez klienta.</summary>
        <value>Element <see cref="T:System.String" /> zawierający pierwotnym adresem URL dla tego żądania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pierwotnym adresem URL jest definiowana jako część adresu URL następujące informacje o domenie. W ciągu adresu URL `http://www.contoso.com/articles/recent.aspx`, jest pierwotnym adresem URL `/articles/recent.aspx`. Pierwotnym adresem URL zawiera ciąg zapytania, jeśli jest obecny.  
  
 Aby uzyskać informacje o hoście i porcie, użyj <xref:System.Net.HttpListenerRequest.RemoteEndPoint%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Net.HttpListenerRequest.RawUrl%2A> właściwości.  
  
 [!code-csharp[Net_Listener_Basic#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.IPEndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IPEndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As IPEndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::IPEndPoint ^ RemoteEndPoint { System::Net::IPEndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.IPEndPoint" Usage="System.Net.HttpListenerRequest.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPEndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera klienta IP adres i numer portu z której pochodzi żądanie.</summary>
        <value><see cref="T:System.Net.IPEndPoint" /> Reprezentujący adres IP i port numer z której pochodzi żądanie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje, użycie tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="RequestTraceIdentifier">
      <MemberSignature Language="C#" Value="public Guid RequestTraceIdentifier { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid RequestTraceIdentifier" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.RequestTraceIdentifier" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RequestTraceIdentifier As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid RequestTraceIdentifier { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestTraceIdentifier : Guid" Usage="System.Net.HttpListenerRequest.RequestTraceIdentifier" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Always returns Guid.Empty")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator żądania przychodzące żądanie HTTP.</summary>
        <value>A <see cref="T:System.Guid" /> obiekt, który zawiera identyfikator żądania HTTP.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceName">
      <MemberSignature Language="C#" Value="public string ServiceName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServiceName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ServiceName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServiceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ServiceName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServiceName : string" Usage="System.Net.HttpListenerRequest.ServiceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dostawcę nazwy usługi (SPN), klient wysyłał żądania.</summary>
        <value>Element <see cref="T:System.String" /> zawierający nazwę SPN klienta wysyłany na żądanie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja może użyć <xref:System.Net.HttpListenerRequest.ServiceName%2A> właściwości do wykonywania niestandardowego sprawdzania poprawności nazwy zapewniają usługi (SPN).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="P:System.Net.HttpListenerRequest.TransportContext" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Windows zintegrowane uwierzytelnianie przy użyciu mechanizmu rozszerzonej ochrony</related>
      </Docs>
    </Member>
    <Member MemberName="TransportContext">
      <MemberSignature Language="C#" Value="public System.Net.TransportContext TransportContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.TransportContext TransportContext" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.TransportContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransportContext As TransportContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::TransportContext ^ TransportContext { System::Net::TransportContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TransportContext : System.Net.TransportContext" Usage="System.Net.HttpListenerRequest.TransportContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.TransportContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Net.TransportContext" /> dla żądania klienta.</summary>
        <value>Element <see cref="T:System.Net.TransportContext" /> obiektu dla żądania klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.TransportContext> Właściwość może służyć do pobierania token wiązania kanałów (CBT) dla <xref:System.Net.HttpListenerRequest> której wysłano przy użyciu protokołu HTTPS.  
  
 Aplikacja może użyć <xref:System.Net.TransportContext> właściwości, aby wykonać niestandardowe uwierzytelnianie przy użyciu wywołania natywny Win32 [działanie funkcji AcceptSecurityContext](https://go.microsoft.com/fwlink/?LinkId=147021) funkcji.  
  
 Jeśli aplikacja próbuje pobrać token wiązania kanałów (CBT) z tego <xref:System.Net.HttpListenerRequest.TransportContext%2A> właściwość za pomocą <xref:System.Net.TransportContext.GetChannelBinding%2A> metody i <xref:System.Security.Authentication.ExtendedProtection.ChannelBindingKind> nie <xref:System.Security.Authentication.ExtendedProtection.ChannelBindingKind.Endpoint>, a następnie <xref:System.Net.HttpListenerRequest> zgłosi <xref:System.NotSupportedException>. <xref:System.Net.HttpListenerRequest> Zastępuje <xref:System.Net.TransportContext.GetChannelBinding%2A> metody za pomocą wewnętrznej implementacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="P:System.Net.HttpListenerRequest.ServiceName" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Windows zintegrowane uwierzytelnianie przy użyciu mechanizmu rozszerzonej ochrony</related>
      </Docs>
    </Member>
    <Member MemberName="Url">
      <MemberSignature Language="C#" Value="public Uri Url { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Url" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.Url" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Url As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Url { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Url : Uri" Usage="System.Net.HttpListenerRequest.Url" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Uri" /> obiektu zażądane przez klienta.</summary>
        <value>A <see cref="T:System.Uri" /> obiekt, który identyfikuje zasób zażądane przez klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListenerRequest.Url%2A> Właściwość pozwala uzyskać wszystkie informacje dostępne <xref:System.Uri> obiektu. Jeśli musisz wiedzieć nieprzetworzony tekst w żądaniu identyfikatora URI, należy rozważyć użycie <xref:System.Net.HttpListenerRequest.RawUrl%2A> właściwości zamiast tego.  
  
 <xref:System.Net.HttpListenerRequest.Url%2A> Właściwość ma wartość null Jeśli <xref:System.Uri> od klienta nie można przeanalizować.  
  
 <xref:System.Net.Configuration.HttpListenerElement.UnescapeRequestUrl%2A> Wskazuje właściwość, jeśli <xref:System.Net.HttpListener> używa pierwotne URI o niezmienionym znaczeniu zamiast przekonwertowanego identyfikator URI, gdzie wszystkie zakodowane w formacie procent wartości są konwertowane i są podjąć inne kroki normalizacji.  
  
 Gdy <xref:System.Net.HttpListener> wystąpienia odbiera żądanie za pośrednictwem `http.sys` usługi, tworzy wystąpienie ciągu identyfikatora URI, dostarczone przez `http.sys`i uwidacznia go jako <xref:System.Net.HttpListenerRequest.Url%2A?displayProperty=nameWithType> właściwości.  
  
 `http.sys` Service udostępnia dwa ciągi identyfikatora URI żądania:  
  
-   Identyfikator URI nieprzetworzone  
  
-   Przekonwertowana identyfikatora URI  
  
 Nieprzetworzone identyfikator URI jest <xref:System.Uri?displayProperty=nameWithType> podane w wierszu żądania żądania HTTP:  
  
 `GET /path/`  
  
 `Host: www.contoso.com`  
  
 Nieprzetworzone dostarczone przez identyfikator URI `http.sys` dla żądania, o których wspomniano powyżej, jest "/ path /". Reprezentuje ciąg po zlecenie HTTP, ponieważ została wysłana przez sieć.  
  
 `http.sys` Usługa tworzy przekonwertowanego identyfikatora URI z informacji podanych w żądanie przy użyciu podanego w wierszu żądania HTTP identyfikatora URI i nagłówek hosta, aby określić serwer pochodzenia żądania powinien być przekazywany do. Odbywa się przez porównywanie informacji dotyczących z żądania z zestawem zarejestrowanych prefiksów identyfikatorów URI. Aby można było porównać te wartości, musi wykonać niektóre normalizacji na żądanie. W przykładzie powyżej przekonwertowanego identyfikator URI będzie następujący:  
  
 `http://www.contoso.com/path/`  
  
 `http.sys` Usługi łączy w sobie <xref:System.Uri.Host%2A?displayProperty=nameWithType> wartości właściwości, a ciąg w wierszu żądania do utworzenia przekonwertowanego identyfikatora URI. Ponadto `http.sys` i <xref:System.Uri?displayProperty=nameWithType> klasy również wykonać następujące czynności:  
  
-   ONZ anuluje wszystkie zakodowany wartość procentowa.  
  
-   Konwertuje kodowany w formacie procent znaki spoza zestawu ASCII w reprezentacji znaków UTF-16. Należy pamiętać, że UTF-8 i ANSI/DBCS są obsługiwane znaki oraz znaki Unicode (kodowanie Unicode przy użyciu formatu uXXXX %).  
  
-   Wykonuje inne czynności normalizacji, takie jak kompresja ścieżki.  
  
 Ponieważ żądanie nie zawiera żadnych informacji o kodowanie używane do zakodowane w formacie procent wartości, nie może być określić poprawne kodowanie przez analizowanie zakodowane w formacie procent wartości.  
  
 W związku z tym `http.sys` zawiera dwa klucze rejestru do modyfikowania procesu:  
  
|Klucz rejestru|Wartość domyślna|Opis|  
|------------------|-------------------|-----------------|  
|EnableNonUTF8|1|Jeśli zero, `http.sys` akceptuje tylko adresy URL algorytmem UTF-8.<br /><br /> Jeśli różna od zera, `http.sys` akceptuje także kodowaniu ANSI lub zakodowane w formacie DBCS adresy URL w żądaniach.|  
|FavorUTF8|1|Jeśli różna od zera, `http.sys` zawsze próbuje dekodowanie adresu URL jako UTF-8 najpierw; Jeśli tej konwersji nie powiedzie się i EnableNonUTF8 jest różna od zera, sterownik Http.sys, a następnie próbuje go dekodować w kodowaniu ANSI lub znaków Dwubajtowych.<br /><br /> Jeśli zero i EnableNonUTF8 jest różna od zera, `http.sys` podejmuje próbę zdekodowania kodowaniu ANSI lub znaków Dwubajtowych; Jeśli to się nie powiedzie, podejmuje próby konwersji UTF-8.|  
  
 Gdy <xref:System.Net.HttpListener> odbiera żądanie, używa ona przekonwertowana identyfikatora URI z `http.sys` jako danych wejściowych do <xref:System.Net.HttpListenerRequest.Url%2A> właściwości.  
  
 Istnieje potrzeba do obsługi znaki oprócz znaków i numery identyfikatorów URI. Przykładem jest następujący identyfikator URI, który służy do pobierania informacji klienta dla klientów number "1/3812":  
  
 `http://www.contoso.com/Customer('1%2F3812')/`  
  
 Należy pamiętać, ukośnika procent, kodowane w identyfikatorze Uri (% 2F). Jest to konieczne, ponieważ w tym przypadku reprezentuje znak ukośnika, danych i nie ogranicznika ścieżka.  
  
 Przekazywanie ciągu identyfikatora Uri konstruktora doprowadzi do następujący identyfikator URI:  
  
 `http://www.contoso.com/Customer('1/3812')/`  
  
 Dzielenie ścieżkę na jej segmenty mogłoby spowodować następujące elementy:  
  
 `Customer('1`  
  
 `3812')`  
  
 Nie jest celem nadawca żądania.  
  
 Jeśli <xref:System.Net.Configuration.HttpListenerElement.UnescapeRequestUrl%2A> właściwość jest ustawiona na wartość false, a następnie po <xref:System.Net.HttpListener> odbiera żądanie, używa raw URI zamiast przekonwertowanego identyfikatora URI z `http.sys` jako danych wejściowych do <xref:System.Net.HttpListenerRequest.Url%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Net.HttpListenerRequest.Url%2A> właściwości.  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Configuration.HttpListenerElement" />
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/network/index.md">Schemat ustawień sieci</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f121fd-3f2e-4033-bb39-48ae996bfbd9">&lt;httpListener&gt; — Element (ustawienia sieci)</related>
      </Docs>
    </Member>
    <Member MemberName="UrlReferrer">
      <MemberSignature Language="C#" Value="public Uri UrlReferrer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri UrlReferrer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.UrlReferrer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UrlReferrer As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ UrlReferrer { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UrlReferrer : Uri" Usage="System.Net.HttpListenerRequest.UrlReferrer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator URI (Uniform Resource) zasobu określonego klienta do serwera.</summary>
        <value>A <see cref="T:System.Uri" /> obiekt, który zawiera tekst żądania <see cref="F:System.Net.HttpRequestHeader.Referer" /> nagłówka, lub <see langword="null" /> Jeśli nagłówek nie zostało uwzględnione w żądaniu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klient obserwują hiperłącze do żądanego identyfikatora URI, jego żądanie może zawierać `Referrer` nagłówek, który identyfikuje identyfikator URI zasobu, który zawierał hiperłącze.  
  
 Klientów można fałszowanie lub wybrać opcję nie przedstawić <xref:System.Net.HttpRequestHeader.Referer> nagłówka. W związku z tym, podczas gdy <xref:System.Net.HttpListenerRequest.UrlReferrer%2A> właściwość może być przydatne do identyfikowania trendów podstawowe w ruchu w sieci Web; nie należy używać go jako część schematu autoryzacji do kontrolowania dostępu do danych.  
  
 Aby uzyskać pełną listę nagłówków żądań, zobacz <xref:System.Net.HttpRequestHeader> wyliczenia.  
  
 <xref:System.Net.HttpListenerRequest.UrlReferrer%2A> Ma wartość null, gdy istnieje nie `Referrer` nagłówka w żądaniu lub podczas `Referrer` nagłówka znajduje się w żądaniu, ale nie analizuje do prawidłowego <xref:System.Uri>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, użycie tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string" Usage="System.Net.HttpListenerRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera agenta użytkownika, przedstawione przez klienta.</summary>
        <value>A <see cref="T:System.String" /> obiekt, który zawiera tekst żądania <see langword="User-Agent" /> nagłówka.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `User-Agent` Nagłówek zwykle zawiera tekst, który identyfikuje nazwę oraz numer wersji oprogramowania służącego do generowania żądania.  
  
 Aby uzyskać pełną listę nagłówków żądań, zobacz <xref:System.Net.HttpRequestHeader> wyliczenia.  
  
 <xref:System.Net.HttpListenerRequest.UserAgent%2A> Ma wartość null, gdy istnieje nie `User-Agent` nagłówka w żądaniu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, użycie tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="UserHostAddress">
      <MemberSignature Language="C#" Value="public string UserHostAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostAddress" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.UserHostAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostAddress { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserHostAddress : string" Usage="System.Net.HttpListenerRequest.UserHostAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera serwera IP adres i numer portu do którego kierowane jest żądanie.</summary>
        <value>Element <see cref="T:System.String" /> zawierający informacje o adresie hosta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane zwracane przez tę właściwość, jest również dostępna w <xref:System.Net.HttpListenerRequest.LocalEndPoint%2A> wartości właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="UserHostName">
      <MemberSignature Language="C#" Value="public string UserHostName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.UserHostName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserHostName : string" Usage="System.Net.HttpListenerRequest.UserHostName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę DNS i, jeśli nie dostarczono, numer portu jest określony przez klienta.</summary>
        <value>A <see cref="T:System.String" /> wartość, która zawiera tekst żądania <see langword="Host" /> nagłówka.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Host` Nagłówek zawiera nazwę hosta żądanego serwera i numer portu, jeśli zostanie określony, rozdzielone średnikiem (na przykład `www.contoso.com:8080`).  
  
 Ta właściwość służy do zwracania odpowiedzi różne w zależności od nazwy hosta określonej w żądaniu.  
  
 Aby uzyskać pełną listę nagłówków żądań, zobacz <xref:System.Net.HttpRequestHeader> wyliczenia.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, użycie tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="UserLanguages">
      <MemberSignature Language="C#" Value="public string[] UserLanguages { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] UserLanguages" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.UserLanguages" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserLanguages As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ UserLanguages { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserLanguages : string[]" Usage="System.Net.HttpListenerRequest.UserLanguages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera języki naturalnego, które są preferowane dla odpowiedzi.</summary>
        <value>A <see cref="T:System.String" /> tablicę, która zawiera języki określony w żądaniu <see cref="F:System.Net.HttpRequestHeader.AcceptLanguage" /> nagłówek lub <see langword="null" /> Jeśli żądanie klienta nie zawiera <see cref="F:System.Net.HttpRequestHeader.AcceptLanguage" /> nagłówka.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać szczegółowy opis `Accept-Language` nagłówka, zobacz sekcję dokumencie RFC 2616 14.4 dostępne pod adresem [ https://www.rfc-editor.org ](https://www.rfc-editor.org/).  
  
 Aby uzyskać pełną listę nagłówków żądań, zobacz <xref:System.Net.HttpRequestHeader> wyliczenia.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla języków w żądaniu `Accept-Language` nagłówka.  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
  </Members>
</Type>
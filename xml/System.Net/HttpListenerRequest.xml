<Type Name="HttpListenerRequest" FullName="System.Net.HttpListenerRequest">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bf59e4f1c53fc58cea1d544874a2351243f6832d" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69071673" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpListenerRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpListenerRequest extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpListenerRequest" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpListenerRequest" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpListenerRequest sealed" />
  <TypeSignature Language="F#" Value="type HttpListenerRequest = class" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.HttpListener</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Opisuje przychodzące żądanie HTTP do <see cref="T:System.Net.HttpListener" /> obiektu. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy klient wysyła żądanie do Uniform Resource Identifier (URI) obsługiwanego przez <xref:System.Net.HttpListener> obiekt <xref:System.Net.HttpListener> , udostępnia <xref:System.Net.HttpListenerContext> obiekt zawierający informacje o nadawcy, żądaniu i odpowiedzi wysyłanej do klienta. <xref:System.Net.HttpListenerContext.Request%2A?displayProperty=nameWithType> Właściwość<xref:System.Net.HttpListenerRequest> zwraca obiekt, który opisuje żądanie.  
  
 Obiekt zawiera informacje o żądaniu, takie jak ciąg żądania <xref:System.Net.HttpListenerRequest.HttpMethod%2A> , <xref:System.Net.HttpListenerRequest.UserAgent%2A> ciąg i dane treści żądania (zobacz <xref:System.Net.HttpListenerRequest.InputStream%2A> Właściwość). <xref:System.Net.HttpListenerRequest>  
  
 Aby odpowiedzieć na żądanie, należy uzyskać skojarzoną odpowiedź przy użyciu <xref:System.Net.HttpListenerContext.Response%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak odbierać i odpowiadać na <xref:System.Net.HttpListenerRequest>.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
 [!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.HttpListener" />
    <altmember cref="T:System.Net.HttpListenerContext" />
    <altmember cref="T:System.Net.HttpListenerResponse" />
  </Docs>
  <Members>
    <Member MemberName="AcceptTypes">
      <MemberSignature Language="C#" Value="public string[] AcceptTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AcceptTypes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.AcceptTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AcceptTypes As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AcceptTypes { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AcceptTypes : string[]" Usage="System.Net.HttpListenerRequest.AcceptTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typy MIME akceptowane przez klienta.</summary>
        <value>Tablica zawierająca nazwy typów określone w <see langword="Accept" /> nagłówku żądania lub <see langword="null" /> w <see langword="Accept" /> przypadku, gdy żądanie klienta nie zawierało nagłówka. <see cref="T:System.String" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nagłówek jest ciągiem nazw typów MIME (Multipurpose Internet Mail Extensions) (na `image/jpeg`przykład), które wskazują typy MIME przygotowane przez klienta do akceptowania i przetwarzania w odpowiedzi. `Accept` `*/*` Wpis wskazuje, że klient akceptuje dowolny typ MIME. Aby uzyskać szczegółowy opis `Accept` nagłówka, zobacz RFC 2616, dostępny pod adresem. [https://www.rfc-editor.org](https://www.rfc-editor.org/)  
  
 Aby uzyskać pełną listę nagłówków żądań, zobacz <xref:System.Net.HttpRequestHeader> Wyliczenie.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
 [!code-vb[Net_Listener_Basic#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="BeginGetClientCertificate">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginGetClientCertificate (AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginGetClientCertificate(class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerRequest.BeginGetClientCertificate(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginGetClientCertificate (requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginGetClientCertificate(AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginGetClientCertificate : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpListenerRequest.BeginGetClientCertificate (requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="requestCallback"><see cref="T:System.AsyncCallback" /> Delegat, który odwołuje się do metody do wywołania po zakończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji. Ten obiekt jest przesyłany do delegata wywołania zwrotnego po zakończeniu operacji.</param>
        <summary>Rozpoczyna asynchroniczne żądanie dla certyfikatu X. 509 v. 3 klienta.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Wskazuje stan operacji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificateError">
      <MemberSignature Language="C#" Value="public int ClientCertificateError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ClientCertificateError" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ClientCertificateError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientCertificateError As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ClientCertificateError { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificateError : int" Usage="System.Net.HttpListenerRequest.ClientCertificateError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kod błędu, który identyfikuje problem z <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" /> dostarczonym przez klienta.</summary>
        <value><see cref="T:System.Int32" /> Wartość, która zawiera kod błędu systemu Windows.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawiera kod błędu systemu Windows zwracany przez interfejs dostawcy obsługi zabezpieczeń (SSPI) bezpiecznego kanału (Schannel), który jest używany do sprawdzania poprawności certyfikatu. Aby uzyskać więcej informacji na temat obsługi interfejsu SSPI dla kanału Schannel, zobacz "Tworzenie bezpiecznego połączenia przy użyciu kanału Schannel" [http://msdn.microsoft.com/library](https://msdn.microsoft.com/library)w dokumentacji zabezpieczeń pod adresem.  
  
   
  
## Examples  
 Poniższy przykład kodu sprawdza tę właściwość, aby określić, czy żądanie zawiera prawidłowy certyfikat klienta.  
  
 [!code-csharp[NCLListener#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#3)]
 [!code-vb[NCLListener#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Certyfikat klienta nie został jeszcze zainicjowany przez wywołanie <see cref="M:System.Net.HttpListenerRequest.BeginGetClientCertificate(System.AsyncCallback,System.Object)" /> metody lub <see cref="M:System.Net.HttpListenerRequest.GetClientCertificate" /> 
oraz 
Operacja jest nadal w toku.</exception>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentEncoding : System.Text.Encoding" Usage="System.Net.HttpListenerRequest.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kodowanie zawartości, które może być używane z danymi wysyłanymi z żądaniem</summary>
        <value>Obiekt odpowiedni do użycia z danymi <see cref="P:System.Net.HttpListenerRequest.InputStream" /> we właściwości. <see cref="T:System.Text.Encoding" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding> Obiekt może służyć do konwertowania sekwencji bajtów do zestawów znaków (stron kodowych) i znaków w sekwencje bajtów. Ta właściwość używa wartości charset z `Content-Type` nagłówka, aby określić kodowanie. Jeśli te informacje nie są dostępne, ta właściwość zwraca <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>wartość.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.HttpListenerRequest.ContentEncoding%2A> właściwości.  
  
 [!code-csharp[Net_Listener_Basic#16](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#16)]  
 [!code-vb[Net_Listener_Basic#16](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="ContentLength64">
      <MemberSignature Language="C#" Value="public long ContentLength64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength64" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ContentLength64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentLength64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ContentLength64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength64 : int64" Usage="System.Net.HttpListenerRequest.ContentLength64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera długość danych treści zawartych w żądaniu.</summary>
        <value>Wartość z <see langword="Content-Length" /> nagłówka żądania. Ta wartość to-1, jeśli długość zawartości jest nieznana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Content-Length` Nagłówek wyraża długość w bajtach danych treści towarzyszących żądaniu.  
  
 Aby uzyskać pełną listę nagłówków żądań, zobacz <xref:System.Net.HttpRequestHeader> Wyliczenie.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Net.HttpListenerRequest.ContentLength64%2A> właściwości podczas przetwarzania danych treści.  
  
 [!code-csharp[Net_Listener_Basic#16](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#16)]  
 [!code-vb[Net_Listener_Basic#16](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string" Usage="System.Net.HttpListenerRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ MIME danych treści zawartych w żądaniu.</summary>
        <value>A <see cref="T:System.String" /> , który zawiera tekst <see langword="Content-Type" /> nagłówka żądania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klient zawiera dane treści w żądaniu, deklaruje typ MIME (Multipurpose Internet Mail Extensions) danych treści w `Content-Type` nagłówku. Na przykład domyślny typ MIME danych zwracanych z formularza sieci Web przy użyciu `POST` metody to. `application/x-www-form-urlencoded`  
  
 Aby uzyskać pełną listę nagłówków żądań, zobacz <xref:System.Net.HttpRequestHeader> Wyliczenie i RFC 2616, dostępne pod adresem. [https://www.rfc-editor.org](https://www.rfc-editor.org/)  
  
 Ma <xref:System.Net.HttpListenerRequest.ContentType%2A> wartość null, jeśli w żądaniu `Content-Type` nie ma nagłówka.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#16](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#16)]  
 [!code-vb[Net_Listener_Basic#16](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Net.CookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As CookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::CookieCollection ^ Cookies { System::Net::CookieCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cookies : System.Net.CookieCollection" Usage="System.Net.HttpListenerRequest.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.CookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pliki cookie wysyłane z żądaniem.</summary>
        <value><see cref="T:System.Net.CookieCollection" /> Zawierający pliki cookie, które towarzyszą żądaniu. Ta właściwość zwraca pustą kolekcję, jeśli żądanie nie zawiera plików cookie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plik cookie to dane tekstowe z nazwą/wartością z serwera sieci Web przechowywanego na komputerze lokalnym (kliencie).  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartości plików cookie wysyłanych z żądaniem.  
  
 [!code-csharp[Net_Listener_Basic#18](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#18)]  
 [!code-vb[Net_Listener_Basic#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#18)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="EndGetClientCertificate">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509Certificate2 EndGetClientCertificate (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.Cryptography.X509Certificates.X509Certificate2 EndGetClientCertificate(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerRequest.EndGetClientCertificate(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetClientCertificate (asyncResult As IAsyncResult) As X509Certificate2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::Cryptography::X509Certificates::X509Certificate2 ^ EndGetClientCertificate(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndGetClientCertificate : IAsyncResult -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="httpListenerRequest.EndGetClientCertificate asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate2</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oczekujące żądanie certyfikatu.</param>
        <summary>Zamyka asynchroniczne żądanie dla certyfikatu X. 509 v. 3 klienta.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt, który jest zwracany po rozpoczęciu operacji.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />nie został uzyskany przez wywołanie<see cref="M:System.Net.HttpListenerRequest.BeginGetClientCertificate(System.AsyncCallback,System.Object)" /><paramref name="e." /></exception>
        <exception cref="T:System.InvalidOperationException">Ta metoda została już wywołana dla operacji identyfikowanej przez <paramref name="asyncResult" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetClientCertificate">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509Certificate2 GetClientCertificate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.Cryptography.X509Certificates.X509Certificate2 GetClientCertificate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerRequest.GetClientCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Function GetClientCertificate () As X509Certificate2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::Cryptography::X509Certificates::X509Certificate2 ^ GetClientCertificate();" />
      <MemberSignature Language="F#" Value="member this.GetClientCertificate : unit -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="httpListenerRequest.GetClientCertificate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate2</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera certyfikat X. 509 v. 3 klienta.</summary>
        <returns><see cref="N:System.Security.Cryptography.X509Certificates" /> Obiekt, który zawiera certyfikat X. 509 v. 3 klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest blokowana, dopóki certyfikat nie zostanie pobrany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wywołanie tej metody w celu pobrania certyfikatu X. 509 v. 3 klienta jest w toku i w związku z tym inne wywołanie tej metody nie jest możliwe.</exception>
        <altmember cref="N:System.Security.Cryptography.X509Certificates" />
      </Docs>
    </Member>
    <Member MemberName="GetClientCertificateAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Security.Cryptography.X509Certificates.X509Certificate2&gt; GetClientCertificateAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Security.Cryptography.X509Certificates.X509Certificate2&gt; GetClientCertificateAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerRequest.GetClientCertificateAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function GetClientCertificateAsync () As Task(Of X509Certificate2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Security::Cryptography::X509Certificates::X509Certificate2 ^&gt; ^ GetClientCertificateAsync();" />
      <MemberSignature Language="F#" Value="member this.GetClientCertificateAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Security.Cryptography.X509Certificates.X509Certificate2&gt;" Usage="httpListenerRequest.GetClientCertificateAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Security.Cryptography.X509Certificates.X509Certificate2&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera certyfikat X. 509 v. 3 klienta jako operację asynchroniczną.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną. Właściwość obiektu Task <see cref="N:System.Security.Cryptography.X509Certificates" /> zwraca obiekt, który zawiera certyfikat X. 509 v. 3 klienta. <see cref="P:System.Threading.Tasks.Task`1.Result" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja nie będzie blokować. Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony, gdy zostanie pobrany certyfikat.  
  
 Jeśli wywołanie tej metody w celu pobrania certyfikatu X. 509 v. 3 klienta jest w toku, inne wywołanie tej metody nie jest możliwe.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Security.Cryptography.X509Certificates" />
      </Docs>
    </Member>
    <Member MemberName="HasEntityBody">
      <MemberSignature Language="C#" Value="public bool HasEntityBody { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasEntityBody" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.HasEntityBody" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasEntityBody As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasEntityBody { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasEntityBody : bool" Usage="System.Net.HttpListenerRequest.HasEntityBody" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" /> Pobiera wartość wskazującą, czy żądanie ma powiązane dane treści.</summary>
        <value><see langword="true" />Jeśli żądanie ma powiązane dane treści; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Żądanie, które wysyła dane do serwera przy użyciu `POST` metody, na przykład, powinno mieć treść jednostki.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#16](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#16)]  
 [!code-vb[Net_Listener_Basic#16](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Collections.Specialized.NameValueCollection" Usage="System.Net.HttpListenerRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję par nazwa/wartość nagłówka wysłanych w żądaniu.</summary>
        <value><see cref="T:System.Net.WebHeaderCollection" /> Zawierający nagłówki HTTP zawarte w żądaniu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nagłówki żądania zawierają informacje o metadanych. Na przykład nagłówki mogą zawierać Uniform Resource Identifier (URI) zasobu, który odwołuje się do serwera, tożsamość agenta użytkownika zatrudnionego przez klienta oraz akceptowalne typy MIME dla danych w treści odpowiedzi.  
  
 Aby uzyskać pełną listę nagłówków żądań, zobacz <xref:System.Net.HttpRequestHeader> Wyliczenie.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wszystkie informacje w danym <xref:System.Net.WebHeaderCollection> obiekcie.  
  
 [!code-csharp[Net_Listener_Basic#21](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#21)]  
 [!code-vb[Net_Listener_Basic#21](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#21)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="HttpMethod">
      <MemberSignature Language="C#" Value="public string HttpMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HttpMethod" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.HttpMethod" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HttpMethod As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ HttpMethod { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HttpMethod : string" Usage="System.Net.HttpListenerRequest.HttpMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera metodę HTTP określoną przez klienta.</summary>
        <value>A <see cref="T:System.String" /> , który zawiera metodę użytą w żądaniu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda HTTP jest zazwyczaj POBIERAna lub OGŁASZAna w zależności od akcji żądanej przez klienta.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
 [!code-vb[Net_Listener_Basic#17](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="InputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream InputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream InputStream" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.InputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ InputStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InputStream : System.IO.Stream" Usage="System.Net.HttpListenerRequest.InputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera strumień zawierający dane treści wysyłane przez klienta.</summary>
        <value>Obiekt możliwy <see cref="T:System.IO.Stream" /> do odczytu, zawierający Bajty wysłane przez klienta w treści żądania. Ta właściwość zwraca <see cref="F:System.IO.Stream.Null" /> wartość, jeśli do żądania nie są wysyłane żadne dane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klient przesyła dane (na przykład przy użyciu metody http `POST` ), strumień zwracany przez tę metodę zawiera te dane.  
  
> [!NOTE]
>  Zamknięcie żądania nie powoduje zamknięcia strumienia zwróconego przez tę właściwość. Gdy strumień nie jest już potrzebny, należy go zamknąć przez wywołanie <xref:System.IO.Stream.Close%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tej właściwości w celu odczytania danych wysyłanych z żądaniem.  
  
 [!code-csharp[Net_Listener_Basic#16](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#16)]  
 [!code-vb[Net_Listener_Basic#16](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#16)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAuthenticated : bool" Usage="System.Net.HttpListenerRequest.IsAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Always returns false")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" /> Pobiera wartość wskazującą, czy klient wysyłający to żądanie jest uwierzytelniany.</summary>
        <value><see langword="true" />Jeśli klient został uwierzytelniony; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja żąda uwierzytelniania klienta przy użyciu <xref:System.Net.HttpListener.AuthenticationSchemes%2A> właściwości lub. <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A>  
  
 Aplikacja nie odbiera <xref:System.Net.HttpListenerContext> żądań od klientów, których nie powiodła się.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość <xref:System.Net.HttpListenerRequest.IsAuthenticated%2A> właściwości.  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
 [!code-vb[Net_Listener_Basic#17](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="IsLocal">
      <MemberSignature Language="C#" Value="public bool IsLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLocal" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.IsLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLocal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLocal : bool" Usage="System.Net.HttpListenerRequest.IsLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" /> Pobiera wartość wskazującą, czy żądanie jest wysyłane z komputera lokalnego.</summary>
        <value><see langword="true" />Jeśli żądanie pochodziło na tym samym komputerze co <see cref="T:System.Net.HttpListener" /> obiekt, który dostarczył żądania; w przeciwnym razie,. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacje mogą używać tej właściwości do przeprowadzenia przetwarzania specjalnego, gdy żądania pochodzą z komputera lokalnego.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.HttpListenerRequest.IsLocal%2A> właściwości.  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
 [!code-vb[Net_Listener_Basic#17](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="IsSecureConnection">
      <MemberSignature Language="C#" Value="public bool IsSecureConnection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecureConnection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.IsSecureConnection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSecureConnection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSecureConnection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecureConnection : bool" Usage="System.Net.HttpListenerRequest.IsSecureConnection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" /> Pobiera wartość wskazującą, czy połączenie TCP używane do wysyłania żądania korzysta z protokołu SSL (SSL).</summary>
        <value><see langword="true" />Jeśli połączenie TCP korzysta z protokołu SSL; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zażądać bezpiecznego połączenia, żądanie klienta używa <xref:System.Uri.UriSchemeHttps> <xref:System.Uri.UriSchemeHttp>zamiast. Jeśli nie można nawiązać połączenia przy użyciu protokołu SSL, klient otrzymuje <xref:System.Net.WebException> informacje o błędzie.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.HttpListenerRequest.IsSecureConnection%2A> właściwości.  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
 [!code-vb[Net_Listener_Basic#17](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequest">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequest" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.IsWebSocketRequest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequest As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequest { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequest : bool" Usage="System.Net.HttpListenerRequest.IsWebSocketRequest" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" /> Pobiera wartość wskazującą, czy połączenie TCP było żądaniem protokołu WebSocket.</summary>
        <value>Zwraca <see cref="T:System.Boolean" />wartość.  
  
 <see langword="true" />Jeśli połączenie TCP jest żądaniem protokołu WebSocket; w przeciwnym razie. <see langword="false" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool" Usage="System.Net.HttpListenerRequest.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" /> Pobiera wartość wskazującą, czy klient żąda trwałego połączenia.</summary>
        <value><see langword="true" />Jeśli połączenie powinno być otwarte; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klient i serwer HTTP oczekują wymieniać dane wiele razy w krótkim czasie, połączenie trwałe przyspiesza komunikację, umożliwiając im uniknięcie obciążenia wymaganego do otwarcia i zamknięcia połączenia TCP dla każdego komunikatu. W przypadku klientów korzystających z protokołu HTTP/1.1 wartość domyślna tej właściwości `true`to.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
 [!code-vb[Net_Listener_Basic#17](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.IPEndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IPEndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As IPEndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::IPEndPoint ^ LocalEndPoint { System::Net::IPEndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.IPEndPoint" Usage="System.Net.HttpListenerRequest.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPEndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera adres IP serwera i numer portu, do którego jest kierowane żądanie.</summary>
        <value><see cref="T:System.Net.IPEndPoint" /> Reprezentuje adres IP, na który jest wysyłane żądanie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest przydatna, gdy chcesz odpowiedzieć na żądania na podstawie sposobu ich rozróżniania.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
 [!code-vb[Net_Listener_Basic#17](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolVersion : Version" Usage="System.Net.HttpListenerRequest.ProtocolVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wersję HTTP używaną przez żądającego klienta.</summary>
        <value>A <see cref="T:System.Version" /> który identyfikuje wersję protokołu HTTP klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możliwości różnych wersji protokołu HTTP są określone w dokumentach dostępnych pod adresem [https://www.rfc-editor.org](https://www.rfc-editor.org/).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
 [!code-vb[Net_Listener_Basic#17](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="QueryString">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection QueryString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection QueryString" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.QueryString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property QueryString As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ QueryString { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.QueryString : System.Collections.Specialized.NameValueCollection" Usage="System.Net.HttpListenerRequest.QueryString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ciąg zapytania zawartego w żądaniu.</summary>
        <value>Obiekt, który zawiera dane zapytania zawarte w żądaniu <see cref="P:System.Net.HttpListenerRequest.Url" />. <see cref="T:System.Collections.Specialized.NameValueCollection" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W adresie URL informacje o zapytaniu są oddzielone od informacji o ścieżce przez znak zapytania (?). Pary nazwa/wartość są oddzielone znakiem równości (=). Aby uzyskać dostęp do danych zapytania w postaci pojedynczego ciągu, Pobierz <xref:System.Uri.Query%2A> wartość właściwości <xref:System.Uri> z obiektu zwróconego przez <xref:System.Net.HttpListenerRequest.Url%2A>.  
  
> [!NOTE]
>  Zapytania bez znaku równości (przykład: [http://www.contoso.com/query.htm?Name](http://www.contoso.com/query.htm?Name) ) są dodawane `null` do klucza w <xref:System.Collections.Specialized.NameValueCollection>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.HttpListenerRequest.QueryString%2A> właściwości.  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
 [!code-vb[Net_Listener_Basic#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="RawUrl">
      <MemberSignature Language="C#" Value="public string RawUrl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RawUrl" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.RawUrl" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawUrl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RawUrl { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RawUrl : string" Usage="System.Net.HttpListenerRequest.RawUrl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje o adresie URL (bez hosta i portu) żądane przez klienta.</summary>
        <value>A <see cref="T:System.String" /> , który zawiera nieprzetworzony adres URL dla tego żądania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nieprzetworzony adres URL jest definiowany jako część adresu URL po informacji o domenie. W ciągu `http://www.contoso.com/articles/recent.aspx`adresu URL nieprzetworzony adres URL to `/articles/recent.aspx`. Nieprzetworzony adres URL zawiera ciąg zapytania, jeśli jest obecny.  
  
 Aby uzyskać informacje o hoście i porcie, użyj <xref:System.Net.HttpListenerRequest.RemoteEndPoint%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.HttpListenerRequest.RawUrl%2A> właściwości.  
  
 [!code-csharp[Net_Listener_Basic#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#11)]  
 [!code-vb[Net_Listener_Basic#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.IPEndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IPEndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As IPEndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::IPEndPoint ^ RemoteEndPoint { System::Net::IPEndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.IPEndPoint" Usage="System.Net.HttpListenerRequest.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPEndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera adres IP i numer portu klienta, z którego pochodzi żądanie.</summary>
        <value><see cref="T:System.Net.IPEndPoint" /> Reprezentuje adres IP i numer portu, z którego pochodzi żądanie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
 [!code-vb[Net_Listener_Basic#17](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="RequestTraceIdentifier">
      <MemberSignature Language="C#" Value="public Guid RequestTraceIdentifier { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid RequestTraceIdentifier" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.RequestTraceIdentifier" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RequestTraceIdentifier As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid RequestTraceIdentifier { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestTraceIdentifier : Guid" Usage="System.Net.HttpListenerRequest.RequestTraceIdentifier" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Always returns Guid.Empty")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator żądania przychodzącego żądania HTTP.</summary>
        <value><see cref="T:System.Guid" /> Obiekt, który zawiera identyfikator żądania HTTP.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceName">
      <MemberSignature Language="C#" Value="public string ServiceName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServiceName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ServiceName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServiceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ServiceName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServiceName : string" Usage="System.Net.HttpListenerRequest.ServiceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę dostawcy usług (SPN), którą klient wysłał do żądania.</summary>
        <value>A <see cref="T:System.String" /> , który zawiera nazwę SPN wysłaną przez klienta w żądaniu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja może użyć właściwości, <xref:System.Net.HttpListenerRequest.ServiceName%2A> aby przeprowadzić walidację nazwy usługi niestandardowej (SPN).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="P:System.Net.HttpListenerRequest.TransportContext" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Zintegrowane uwierzytelnianie systemu Windows z ochroną rozszerzoną</related>
      </Docs>
    </Member>
    <Member MemberName="TransportContext">
      <MemberSignature Language="C#" Value="public System.Net.TransportContext TransportContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.TransportContext TransportContext" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.TransportContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransportContext As TransportContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::TransportContext ^ TransportContext { System::Net::TransportContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TransportContext : System.Net.TransportContext" Usage="System.Net.HttpListenerRequest.TransportContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.TransportContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.TransportContext" /> Pobiera dla żądania klienta.</summary>
        <value><see cref="T:System.Net.TransportContext" /> Obiekt dla żądania klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość może służyć do pobierania tokenu powiązania kanału (CBT) dla elementu <xref:System.Net.HttpListenerRequest> , który został wysłany przy użyciu protokołu HTTPS. <xref:System.Net.TransportContext>  
  
 Aplikacja może używać <xref:System.Net.TransportContext> właściwości do wykonywania uwierzytelniania niestandardowego przy użyciu wywołań natywnej funkcji Win32 [działanie funkcji AcceptSecurityContext](https://go.microsoft.com/fwlink/?LinkId=147021) .  
  
 Jeśli <xref:System.Net.HttpListenerRequest.TransportContext%2A> aplikacja próbuje pobrać token powiązania kanału (CBT) z tej właściwości <xref:System.Net.TransportContext.GetChannelBinding%2A> przy użyciu metody, a <xref:System.Security.Authentication.ExtendedProtection.ChannelBindingKind> nie <xref:System.Security.Authentication.ExtendedProtection.ChannelBindingKind.Endpoint>jest, <xref:System.Net.HttpListenerRequest> zostanie <xref:System.NotSupportedException>zgłoszony. <xref:System.Net.HttpListenerRequest> Zastępujemetodę<xref:System.Net.TransportContext.GetChannelBinding%2A> implementacją wewnętrzną.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="P:System.Net.HttpListenerRequest.ServiceName" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Zintegrowane uwierzytelnianie systemu Windows z ochroną rozszerzoną</related>
      </Docs>
    </Member>
    <Member MemberName="Url">
      <MemberSignature Language="C#" Value="public Uri Url { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Url" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.Url" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Url As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Url { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Url : Uri" Usage="System.Net.HttpListenerRequest.Url" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Uri" /> Pobiera obiekt żądany przez klienta.</summary>
        <value><see cref="T:System.Uri" /> Obiekt, który identyfikuje zasób żądany przez klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość pozwala uzyskać wszystkie informacje dostępne <xref:System.Uri> z obiektu. <xref:System.Net.HttpListenerRequest.Url%2A> Jeśli musisz znać tylko nieprzetworzony tekst żądania identyfikatora URI, rozważ użycie <xref:System.Net.HttpListenerRequest.RawUrl%2A> właściwości.  
  
 Właściwość ma wartość null, <xref:System.Uri> Jeśli nie można przeanalizować elementu z klienta. <xref:System.Net.HttpListenerRequest.Url%2A>  
  
 Właściwość wskazuje, czy <xref:System.Net.HttpListener> używa nieprzetworzonego niezmienionego identyfikatora URI zamiast przekonwertowanego identyfikatora URI, gdzie wszystkie wartości kodowane w procentach są konwertowane i są wykonywane inne czynności normalizacji. <xref:System.Net.Configuration.HttpListenerElement.UnescapeRequestUrl%2A>  
  
 Gdy wystąpienie odbiera żądanie `http.sys` przez usługę, tworzy wystąpienie ciągu identyfikatora URI dostarczonego przez `http.sys`i uwidacznia je jako <xref:System.Net.HttpListenerRequest.Url%2A?displayProperty=nameWithType> właściwość. <xref:System.Net.HttpListener>  
  
 `http.sys` Usługa ujawnia dwa ciągi identyfikatorów URI żądania:  
  
-   Nieprzetworzony identyfikator URI  
  
-   Przekonwertowany identyfikator URI  
  
 Nieprzetworzony identyfikator URI jest <xref:System.Uri?displayProperty=nameWithType> podany w wierszu żądania żądania http:  
  
 `GET /path/`  
  
 `Host: www.contoso.com`  
  
 Nieprzetworzony identyfikator URI podany `http.sys` na żądanie wymienione powyżej ma wartość "/Path/". Reprezentuje ciąg następujący po zleceniu HTTP, który został wysłany przez sieć.  
  
 `http.sys` Usługa tworzy przekonwertowany identyfikator URI z informacji znajdujących się w żądaniu przy użyciu identyfikatora URI podanego w wierszu żądania HTTP i nagłówka hosta w celu określenia serwera pochodzenia, do którego żądanie powinno zostać przesłane dalej. W tym celu należy porównać informacje z żądania z zestawem zarejestrowanych prefiksów URI. Aby można było porównać te wartości, należy wykonać pewne normalizacji żądania. W przypadku przykładu powyżej przekonwertowanego identyfikatora URI można wykonać następujące czynności:  
  
 `http://www.contoso.com/path/`  
  
 `http.sys` Usługa łączywartośćwłaściwościiciągwwierszużądaniawceluutworzeniaprzekonwertowanego<xref:System.Uri.Host%2A?displayProperty=nameWithType> identyfikatora URI. Ponadto, `http.sys` <xref:System.Uri?displayProperty=nameWithType> a Klasa, należy również wykonać następujące czynności:  
  
-   Cofa wszystkie wartości zakodowane procentowo.  
  
-   Konwertuje znaki nienależące do zestawu znaków ASCII, które nie są zakodowane w formacie UTF-16. Należy zauważyć, że znaki UTF-8 i ANSI/DBCS są obsługiwane, a także znaki Unicode (kodowanie Unicode przy użyciu formatu% uXXXX).  
  
-   Wykonuje inne kroki normalizacji, takie jak kompresja ścieżki.  
  
 Ponieważ żądanie nie zawiera żadnych informacji o kodowaniu używanym dla wartości zakodowanych w procentach, może nie być możliwe określenie poprawnego kodowania tylko przez analizowanie wartości zakodowanych w procentach.  
  
 W `http.sys` związku z tym są dostępne dwa klucze rejestru do modyfikacji procesu:  
  
|Klucz rejestru|Wartość domyślna|Opis|  
|------------------|-------------------|-----------------|  
|EnableNonUTF8|1|Jeśli zero, `http.sys` akceptuje tylko adresy URL zakodowane w formacie UTF-8.<br /><br /> Jeśli wartość jest różna od `http.sys` zera, w żądaniach akceptowane są również adresy URL kodowane w formacie ANSI lub DBCS.|  
|FavorUTF8|1|Jeśli wartość jest różna od `http.sys` zera, program zawsze próbuje zdekodować adres URL jako pierwszy w formacie UTF-8. Jeśli konwersja nie powiedzie się, a EnableNonUTF8 jest różna od zera, http. sys próbuje zdekodować ją jako ANSI lub DBCS.<br /><br /> Jeśli zero (i EnableNonUTF8 jest różna od zera), `http.sys` próbuje zdekodować ją jako ANSI lub DBCS; Jeśli to nie powiodło się, próbuje konwersję UTF-8.|  
  
 Po <xref:System.Net.HttpListener> odebraniu żądania korzysta z przekonwertowanego identyfikatora URI `http.sys` z jako danych wejściowych <xref:System.Net.HttpListenerRequest.Url%2A> właściwości.  
  
 Istnieje potrzeba obsługi znaków oprócz znaków i cyfr w identyfikatorach URI. Przykładem jest następujący identyfikator URI, który służy do pobierania informacji o kliencie dla numeru klienta "1/3812":  
  
 `http://www.contoso.com/Customer('1%2F3812')/`  
  
 Zwróć uwagę na ukośnik zakodowany procentowo w identyfikatorze URI (% 2F). Jest to konieczne, ponieważ w tym przypadku znak ukośnika reprezentuje dane, a nie ogranicznik ścieżki.  
  
 Przekazywanie ciągu do konstruktora identyfikatora URI będzie prowadzić do następującego identyfikatora URI:  
  
 `http://www.contoso.com/Customer('1/3812')/`  
  
 Podział ścieżki na segmenty spowoduje następujące elementy:  
  
 `Customer('1`  
  
 `3812')`  
  
 Nie jest to cel nadawcy żądania.  
  
 Jeśli właściwość jest ustawiona na wartość false, wtedy, <xref:System.Net.HttpListener> gdy otrzyma żądanie, używa nieprzetworzonego identyfikatora URI zamiast przekonwertowanego identyfikatora URI `http.sys` <xref:System.Net.HttpListenerRequest.Url%2A> z jako danych wejściowych właściwości. <xref:System.Net.Configuration.HttpListenerElement.UnescapeRequestUrl%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.HttpListenerRequest.Url%2A> właściwości.  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
 [!code-vb[Net_Listener_Basic#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Configuration.HttpListenerElement" />
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/network/index.md">Schemat ustawień sieci</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f121fd-3f2e-4033-bb39-48ae996bfbd9">&lt;odbiornika HttpListener&gt; , element (Ustawienia sieci)</related>
      </Docs>
    </Member>
    <Member MemberName="UrlReferrer">
      <MemberSignature Language="C#" Value="public Uri UrlReferrer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri UrlReferrer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.UrlReferrer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UrlReferrer As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ UrlReferrer { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UrlReferrer : Uri" Usage="System.Net.HttpListenerRequest.UrlReferrer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera Uniform Resource Identifier (URI) zasobu, który powołuje klienta na serwer.</summary>
        <value>Obiekt, który zawiera tekst <see cref="F:System.Net.HttpRequestHeader.Referer" /> nagłówka żądania lub <see langword="null" /> nagłówek nie został uwzględniony w żądaniu. <see cref="T:System.Uri" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klient przełączył hiperłącze do żądanego identyfikatora URI, jego żądanie może zawierać `Referrer` nagłówek identyfikujący identyfikator URI zasobu, który zawierał hiperlink.  
  
 Klienci mogą fałszować lub zrezygnować z prezentowania <xref:System.Net.HttpRequestHeader.Referer> nagłówka. W związku z <xref:System.Net.HttpListenerRequest.UrlReferrer%2A> tym, chociaż właściwość może być przydatna do identyfikowania podstawowych trendów ruchu w sieci Web; nie należy używać jej jako części schematu autoryzacji w celu kontrolowania dostępu do danych.  
  
 Aby uzyskać pełną listę nagłówków żądań, zobacz <xref:System.Net.HttpRequestHeader> Wyliczenie.  
  
 Ma <xref:System.Net.HttpListenerRequest.UrlReferrer%2A> wartość null, jeśli w żądaniu `Referrer` nie ma nagłówka lub gdy `Referrer` nagłówek jest obecny w żądaniu, ale nie jest analizowany jako prawidłowy <xref:System.Uri>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
 [!code-vb[Net_Listener_Basic#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string" Usage="System.Net.HttpListenerRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera agenta użytkownika prezentowanego przez klienta.</summary>
        <value>Obiekt, który zawiera tekst <see langword="User-Agent" /> nagłówka żądania. <see cref="T:System.String" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `User-Agent` Nagłówek zwykle zawiera tekst, który identyfikuje nazwę i numer wersji oprogramowania używanego do generowania żądania.  
  
 Aby uzyskać pełną listę nagłówków żądań, zobacz <xref:System.Net.HttpRequestHeader> Wyliczenie.  
  
 Ma <xref:System.Net.HttpListenerRequest.UserAgent%2A> wartość null, jeśli w żądaniu `User-Agent` nie ma nagłówka.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
 [!code-vb[Net_Listener_Basic#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="UserHostAddress">
      <MemberSignature Language="C#" Value="public string UserHostAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostAddress" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.UserHostAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostAddress { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserHostAddress : string" Usage="System.Net.HttpListenerRequest.UserHostAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera adres IP serwera i numer portu, do którego jest kierowane żądanie.</summary>
        <value>A <see cref="T:System.String" /> , który zawiera informacje o adresie hosta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informacje zwrócone przez tę właściwość są również dostępne w <xref:System.Net.HttpListenerRequest.LocalEndPoint%2A> wartości właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
 [!code-vb[Net_Listener_Basic#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="UserHostName">
      <MemberSignature Language="C#" Value="public string UserHostName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.UserHostName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserHostName : string" Usage="System.Net.HttpListenerRequest.UserHostName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę DNS i, jeśli jest podany, numer portu określony przez klienta.</summary>
        <value>Wartość, która zawiera tekst <see langword="Host" /> nagłówka żądania. <see cref="T:System.String" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nagłówek zawiera żądaną nazwę hosta serwera i numer portu, jeśli jest określony, oddzielone dwukropkiem (na `www.contoso.com:8080`przykład). `Host`  
  
 Za pomocą tej właściwości można zwrócić różne odpowiedzi w zależności od nazwy hosta określonej w żądaniu.  
  
 Aby uzyskać pełną listę nagłówków żądań, zobacz <xref:System.Net.HttpRequestHeader> Wyliczenie.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
 [!code-vb[Net_Listener_Basic#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="UserLanguages">
      <MemberSignature Language="C#" Value="public string[] UserLanguages { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] UserLanguages" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.UserLanguages" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserLanguages As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ UserLanguages { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserLanguages : string[]" Usage="System.Net.HttpListenerRequest.UserLanguages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera Języki naturalne, które są preferowane dla odpowiedzi.</summary>
        <value>Tablica zawierająca języki określone w <see cref="F:System.Net.HttpRequestHeader.AcceptLanguage" /> nagłówku żądania lub <see langword="null" /> <see cref="F:System.Net.HttpRequestHeader.AcceptLanguage" /> Jeśli żądanie klienta nie zawierało nagłówka. <see cref="T:System.String" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać szczegółowy opis `Accept-Language` nagłówka, zobacz artykuł RFC 2616 Sekcja 14,4, dostępny pod adresem. [https://www.rfc-editor.org](https://www.rfc-editor.org/)  
  
 Aby uzyskać pełną listę nagłówków żądań, zobacz <xref:System.Net.HttpRequestHeader> Wyliczenie.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla Języki z `Accept-Language` nagłówka żądania.  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
 [!code-vb[Net_Listener_Basic#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
  </Members>
</Type>

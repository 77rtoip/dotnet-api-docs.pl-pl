<Type Name="AuthenticationManager" FullName="System.Net.AuthenticationManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ea45447b9690b774a446653fd361d963bc6300d3" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30561592" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class AuthenticationManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit AuthenticationManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.AuthenticationManager" />
  <TypeSignature Language="VB.NET" Value="Public Class AuthenticationManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class AuthenticationManager" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zarządza modułami uwierzytelniania wywołanymi podczas procesu uwierzytelniania klienta.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.AuthenticationManager> to statyczny klasa, która zarządza modułami uwierzytelniania, których używa aplikacja. Po wysłaniu żądania do chronionych zasobów, <xref:System.Net.AuthenticationManager> wywołania <xref:System.Net.AuthenticationManager.Authenticate%2A> metodę, aby pobrać <xref:System.Net.Authorization> wystąpienie do użycia w kolejnych żądań.  
  
 <xref:System.Net.AuthenticationManager> Odpytuje każdy moduł uwierzytelniania zarejestrowanych przez wywołanie metody <xref:System.Net.IAuthenticationModule.Authenticate%2A?displayProperty=nameWithType> metody dla każdego modułu. Pierwszy moduł uwierzytelniania do zwrócenia <xref:System.Net.Authorization> wystąpienia jest używany do uwierzytelniania żądania.  
  
 Moduły, które zapewniają podstawowe, szyfrowane negocjowania, NTLM, oraz typy uwierzytelniania Kerberos są zarejestrowane w usłudze <xref:System.Net.AuthenticationManager> domyślnie. Moduły dodatkowego uwierzytelniania, które implementują <xref:System.Net.IAuthenticationModule> interfejsu można dodać za pomocą <xref:System.Net.AuthenticationManager.Register%2A> metody. Moduły uwierzytelniania są wywoływane w kolejności, w jakiej zostały dodane do listy.  
  
> [!NOTE]
>  Protokołu Kerberos i negocjowanie typ uwierzytelniania nie jest obsługiwany w systemie Windows 95/98 lub Windows NT 4.0.  
  
   
  
## Examples  
 [!code-cpp[System.Net.Authentication#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Authentication/CPP/custombasicauthentication.cpp#1)]
 [!code-csharp[System.Net.Authentication#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Authentication/CS/custombasicauthentication.cs#1)]
 [!code-vb[System.Net.Authentication#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Authentication/VB/custombasicauthentication.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public static System.Net.Authorization Authenticate (string challenge, System.Net.WebRequest request, System.Net.ICredentials credentials);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.Authorization Authenticate(string challenge, class System.Net.WebRequest request, class System.Net.ICredentials credentials) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.AuthenticationManager.Authenticate(System.String,System.Net.WebRequest,System.Net.ICredentials)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Authenticate (challenge As String, request As WebRequest, credentials As ICredentials) As Authorization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::Authorization ^ Authenticate(System::String ^ challenge, System::Net::WebRequest ^ request, System::Net::ICredentials ^ credentials);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Authorization</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="challenge" Type="System.String" />
        <Parameter Name="request" Type="System.Net.WebRequest" />
        <Parameter Name="credentials" Type="System.Net.ICredentials" />
      </Parameters>
      <Docs>
        <param name="challenge">Wyzwanie zwracany przez Internet.</param>
        <param name="request">
          <see cref="T:System.Net.WebRequest" /> Który zainicjował żądanie uwierzytelnienia.</param>
        <param name="credentials">
          <see cref="T:System.Net.ICredentials" /> Skojarzony z tym żądaniem.</param>
        <summary>Wywołuje każdy moduł zarejestrowanych uwierzytelniania można znaleźć pierwszego modułu, który odpowiada na żądania uwierzytelnienia.</summary>
        <returns>Wystąpienie <see cref="T:System.Net.Authorization" /> klasa zawierająca wynik próby autoryzacji. Jeśli nie istnieje żadne moduł uwierzytelniania na odpowiedź na pytanie, ta metoda zwraca <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.AuthenticationManager.Authenticate%2A> Wywołania metody <xref:System.Net.IAuthenticationModule.Authenticate%2A?displayProperty=nameWithType> metody poszczególnych modułów zarejestrowanych uwierzytelniania, dopóki jeden moduł odpowiada <xref:System.Net.Authorization> wystąpienia.  
  
 Pierwszy <xref:System.Net.Authorization> wystąpienia zwracane jest używany do uwierzytelniania żądania. Jeśli moduł uwierzytelniania, nie można uwierzytelnić żądania, <xref:System.Net.AuthenticationManager.Authenticate%2A> metoda zwraca `null`.  
  
 Moduły uwierzytelniania są wywoływane w kolejności, w którym zostały zarejestrowane przy <xref:System.Net.AuthenticationManager>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="challenge" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="request" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="credentials" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CredentialPolicy">
      <MemberSignature Language="C#" Value="public static System.Net.ICredentialPolicy CredentialPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.ICredentialPolicy CredentialPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.AuthenticationManager.CredentialPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CredentialPolicy As ICredentialPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::ICredentialPolicy ^ CredentialPolicy { System::Net::ICredentialPolicy ^ get(); void set(System::Net::ICredentialPolicy ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ICredentialPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zasady dla żądań zasobów, które zostało nawiązane przy użyciu poświadczeń <see cref="T:System.Net.HttpWebRequest" /> klasy.</summary>
        <value>Obiekt, który implementuje <see cref="T:System.Net.ICredentialPolicy" /> interfejs, który określa, czy poświadczenia są wysyłane z żądania. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poświadczenie zasad określa, czy można wysłać poświadczeń podczas wysyłania żądania zasobu sieci, takich jak zawartość strony sieci Web. Jeśli poświadczenia zostaną wysłane, spróbować serwerów, które wymagają uwierzytelniania klienta do uwierzytelniania klienta po otrzymaniu żądania zamiast wysyłania odpowiedzi wskazujący, że są wymagane poświadczenia klienta. Podczas to zapisuje obiegu do serwera, musi to zostać zrównoważone zagrożenie bezpieczeństwa związane z wysyła poświadczenia w sieci. Serwer docelowy nie wymaga uwierzytelniania klienta najlepiej wysyła poświadczenia.  
  
 Zasady dostępu do poświadczeń będzie można wywołać tylko dla żądań, które Określ poświadczenia lub użyj <xref:System.Net.WebProxy> obiekt, który określa poświadczenia.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje ustawienie zasad poświadczeń.  
  
 [!code-cpp[NclCredPolicy#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLCredPolicy/CPP/NCLCredPolicy.cpp#2)]
 [!code-csharp[NclCredPolicy#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLCredPolicy/CS/websample.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomTargetNameDictionary">
      <MemberSignature Language="C#" Value="public static System.Collections.Specialized.StringDictionary CustomTargetNameDictionary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.Specialized.StringDictionary CustomTargetNameDictionary" />
      <MemberSignature Language="DocId" Value="P:System.Net.AuthenticationManager.CustomTargetNameDictionary" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CustomTargetNameDictionary As StringDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::Specialized::StringDictionary ^ CustomTargetNameDictionary { System::Collections::Specialized::StringDictionary ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.StringDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera słownik zawierający nazwy nazwy głównej usługi (SPN), które są używane do identyfikowania hostów podczas uwierzytelniania Kerberos dla żądań wysyłanych za pomocą <see cref="T:System.Net.WebRequest" /> i jej klas pochodnych.</summary>
        <value>Z możliwością zapisu <see cref="T:System.Collections.Specialized.StringDictionary" /> zawierający wartości nazwy SPN kluczy składa się z informacji o hoście.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwę SPN jest to nazwa, przez którą klient jednoznacznie identyfikuje wystąpienie usługi lub aplikacji na serwerze w celu uwierzytelniania wzajemnego. Zażądano domyślnie wzajemnego uwierzytelniania i można wymagać, ustawiając <xref:System.Net.WebRequest.AuthenticationLevel%2A?displayProperty=nameWithType> do <xref:System.Net.Security.AuthenticationLevel.MutualAuthRequired> w żądaniu.  
  
 Gdy <xref:System.Net.WebRequest> wymagają uwierzytelniania wzajemnego, główną nazwę usługi, miejsce docelowe muszą być dostarczane przez klienta. Jeśli znasz nazwę SPN, można dodać go do <xref:System.Net.AuthenticationManager.CustomTargetNameDictionary%2A> przed wysłaniem żądania. Jeśli nazwa SPN informacje nie zostały dodane do tego słownika <xref:System.Net.AuthenticationManager> używa <xref:System.Net.WebRequest.RequestUri%2A> metody compose najprawdopodobniej SPN; to jest jednak obliczoną wartością i mogą być niepoprawne. Jeśli nastąpiła wzajemnego uwierzytelniania i kończy się niepowodzeniem, można sprawdzić słownik do określenia obliczona główną nazwę usługi. Nie nazwy SPN jest wprowadzany do słownika, jeśli protokołem uwierzytelniania nie obsługuje uwierzytelniania wzajemnego.  
  
 Aby dodać wartości nazwy SPN do tego słownika, użyj <xref:System.Uri.AbsoluteUri%2A> z <xref:System.Net.WebRequest.RequestUri%2A> jako klucz. Wewnętrznie, klucz został obcięty do uwzględnienia <xref:System.Uri.Scheme%2A>, <xref:System.Uri.Host%2A>i <xref:System.Uri.Port%2A> Jeśli nie jest domyślny port.  
  
> [!NOTE]
>  Uzyskiwanie dostępu do metody i właściwości <xref:System.Net.AuthenticationManager.CustomTargetNameDictionary%2A> wymaga nieograniczony <xref:System.Net.WebPermission>.  
  
> [!NOTE]
>  W przypadku uwierzytelniania protokołu Kerberos przez serwer proxy, zarówno serwer proxy, jak i nazwy hosta ultimate muszą zostać rozwiązane do głównej nazwy usługi. Limit czasu rozpoznawania nazw serwera proxy jest chroniony. Rozpoznawanie nazwy hosta ultimate do SPN wymaga wyszukiwania DNS, i nie ma limitu czasu skojarzone bezpośrednio z tą operacją. W związku z tym operacji synchronicznych może trwać dłużej, aby limitu czasu. Aby rozwiązać ten problem, Dodaj prefiks URI ultimate hosta do pamięci podręcznej nazw SPN przed wykonaniem żądania.  
  
 W wersji 3.5 z dodatkiem SP1, teraz używane wartości domyślne, aby określić nazwę hosta w adresie URL żądania w SPN w uwierzytelnianiu NTLM (NT LAN Manager) programu exchange, kiedy <xref:System.Net.AuthenticationManager.CustomTargetNameDictionary%2A> nie ustawiono właściwości. Nazwa hosta używaną w adresie URL żądania mogą być inne niż określony w nagłówek hosta <xref:System.Net.HttpRequestHeader?displayProperty=nameWithType> w żądaniu klienta. Nazwa hosta używaną w adresie URL żądania może być inna niż nazwa hosta serwera, nazwa komputera serwera, adres IP komputera lub adres sprzężenia zwrotnego. W takich przypadkach Windows zakończy się niepowodzeniem żądania uwierzytelniania. Aby rozwiązać ten problem, konieczne może powiadomić systemu Windows, która nazwa hosta używana w adresie URL żądania w kliencie żądania ("contoso", na przykład) jest rzeczywiście alternatywną nazwę komputera lokalnego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, wyświetlania zawartości <xref:System.Net.AuthenticationManager.CustomTargetNameDictionary%2A>.  
  
 [!code-cpp[NclCredPolicy#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLCredPolicy/CPP/NCLCredPolicy.cpp#5)]
 [!code-csharp[NclCredPolicy#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLCredPolicy/CS/websample.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public static System.Net.Authorization PreAuthenticate (System.Net.WebRequest request, System.Net.ICredentials credentials);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.Authorization PreAuthenticate(class System.Net.WebRequest request, class System.Net.ICredentials credentials) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.AuthenticationManager.PreAuthenticate(System.Net.WebRequest,System.Net.ICredentials)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PreAuthenticate (request As WebRequest, credentials As ICredentials) As Authorization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::Authorization ^ PreAuthenticate(System::Net::WebRequest ^ request, System::Net::ICredentials ^ credentials);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Authorization</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Net.WebRequest" />
        <Parameter Name="credentials" Type="System.Net.ICredentials" />
      </Parameters>
      <Docs>
        <param name="request">A <see cref="T:System.Net.WebRequest" /> do zasobu internetowego.</param>
        <param name="credentials">
          <see cref="T:System.Net.ICredentials" /> Skojarzone z żądaniem.</param>
        <summary>Wstępnie uwierzytelnia żądanie.</summary>
        <returns>Wystąpienie <see cref="T:System.Net.Authorization" /> klasy, jeśli żądanie może być wstępnie uwierzytelniona; w przeciwnym razie <see langword="null" />. Jeśli <paramref name="credentials" /> jest <see langword="null" />, ta metoda zwraca <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli moduł uwierzytelniania można preauthenticate żądania, <xref:System.Net.AuthenticationManager.PreAuthenticate%2A> metoda zwraca wystąpienie uwierzytelniania i wysyła informacje o autoryzacji do serwera preemptively, zamiast czekać na zasób do wydania wyzwania. To zachowanie jest opisane w sekcji 3.3 RFC 2617 (uwierzytelnianie HTTP: Basic i uwierzytelniania szyfrowanego dostępu). Moduły uwierzytelniania wstępnego uwierzytelniania Zezwalaj klientom na poprawić wydajność serwera, unikając dodatkowe rund spowodowane wezwań do uwierzytelnienia.  
  
 Zestaw żąda autoryzacji modułów, które można preauthenticate <xref:System.Net.IAuthenticationModule.CanPreAuthenticate%2A?displayProperty=nameWithType> właściwości `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="request" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static void Register (System.Net.IAuthenticationModule authenticationModule);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Register(class System.Net.IAuthenticationModule authenticationModule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.AuthenticationManager.Register(System.Net.IAuthenticationModule)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Register (authenticationModule As IAuthenticationModule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Register(System::Net::IAuthenticationModule ^ authenticationModule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="authenticationModule" Type="System.Net.IAuthenticationModule" />
      </Parameters>
      <Docs>
        <param name="authenticationModule">
          <see cref="T:System.Net.IAuthenticationModule" /> Zarejestrować się w Menedżerze uwierzytelniania.</param>
        <summary>Rejestruje moduł uwierzytelniania przy użyciu Menedżera uwierzytelniania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.AuthenticationManager.Register%2A> Metody dodaje moduły uwierzytelniania na końcu listy modułów wywoływane przez <xref:System.Net.AuthenticationManager.Authenticate%2A> metody. Moduły uwierzytelniania są wywoływane w kolejności, w jakiej zostały dodane do listy. Jeśli moduł o tej samej <xref:System.Net.IAuthenticationModule.AuthenticationType%2A> jest już zarejestrowany, ta metoda usuwa zarejestrowanego modułu i dodaje `authenticationModule` na końcu listy.  
  
   
  
## Examples  
 Poniższy przykład rejestruje moduł uwierzytelniania przy użyciu Menedżera uwierzytelniania. Pełny przykład można znaleźć w temacie <xref:System.Net.AuthenticationManager> klasy.  
  
 [!code-cpp[System.Net.Sockets.Authentication#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Authentication/CPP/custombasicauthentication.cpp#2)]
 [!code-csharp[System.Net.Sockets.Authentication#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Authentication/CS/custombasicauthentication.cs#2)]
 [!code-vb[System.Net.Sockets.Authentication#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Authentication/VB/custombasicauthentication.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="authenticationModule" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do wykonywania kodu niezarządzanego. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="RegisteredModules">
      <MemberSignature Language="C#" Value="public static System.Collections.IEnumerator RegisteredModules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.IEnumerator RegisteredModules" />
      <MemberSignature Language="DocId" Value="P:System.Net.AuthenticationManager.RegisteredModules" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RegisteredModules As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::IEnumerator ^ RegisteredModules { System::Collections::IEnumerator ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera listę modułów uwierzytelniania, które są zarejestrowane w usłudze Menedżer uwierzytelniania.</summary>
        <value>
          <see cref="T:System.Collections.IEnumerator" /> , Który umożliwia moduły uwierzytelniania zarejestrowanych do odczytu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.AuthenticationManager.RegisteredModules%2A> Zawiera właściwość <xref:System.Collections.IEnumerator> wystąpienia, który umożliwia listę zarejestrowanych moduły uwierzytelniania do odczytu. <xref:System.Net.AuthenticationManager.Register%2A> Metody dodaje modułów do listy, a <xref:System.Net.AuthenticationManager.Unregister%2A> metoda usuwa modułów z niego.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Net.AuthenticationManager.RegisteredModules%2A> właściwość, aby uzyskać listę modułów uwierzytelniania, które są zarejestrowane w usłudze Menedżer uwierzytelniania. Pełny przykład można znaleźć w temacie <xref:System.Net.AuthenticationManager> klasy.  
  
 [!code-cpp[System.Net.Authentication#8](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Authentication/CPP/custombasicauthentication.cpp#8)]
 [!code-csharp[System.Net.Authentication#8](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Authentication/CS/custombasicauthentication.cs#8)]
 [!code-vb[System.Net.Authentication#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Authentication/VB/custombasicauthentication.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Unregister">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa moduły uwierzytelniania na liście zarejestrowanych modułów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unregister">
      <MemberSignature Language="C#" Value="public static void Unregister (System.Net.IAuthenticationModule authenticationModule);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unregister(class System.Net.IAuthenticationModule authenticationModule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.AuthenticationManager.Unregister(System.Net.IAuthenticationModule)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unregister (authenticationModule As IAuthenticationModule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unregister(System::Net::IAuthenticationModule ^ authenticationModule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="authenticationModule" Type="System.Net.IAuthenticationModule" />
      </Parameters>
      <Docs>
        <param name="authenticationModule">
          <see cref="T:System.Net.IAuthenticationModule" /> Można usunąć z listy modułów w zarejestrowany.</param>
        <summary>Usuwa moduł uwierzytelniania określonych na liście zarejestrowanych modułów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.AuthenticationManager.Unregister%2A> — Metoda usuwa moduł uwierzytelniania określonych na liście modułami uwierzytelniania wywołanymi <xref:System.Net.AuthenticationManager.Authenticate%2A> metody. Modułu należy dodać do listy przy użyciu <xref:System.Net.AuthenticationManager.Register%2A> metody można było usunąć z listy.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Net.AuthenticationManager.Unregister%2A> metodę, aby usunąć moduł uwierzytelniania określonych na liście zarejestrowanych modułów. Pełny przykład można znaleźć w temacie <xref:System.Net.AuthenticationManager> klasy.  
  
 [!code-cpp[System.Net.Sockets.Authentication#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Authentication/CPP/custombasicauthentication.cpp#2)]
 [!code-csharp[System.Net.Sockets.Authentication#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Authentication/CS/custombasicauthentication.cs#2)]
 [!code-vb[System.Net.Sockets.Authentication#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Authentication/VB/custombasicauthentication.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="authenticationModule" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Określony <see cref="T:System.Net.IAuthenticationModule" /> nie jest zarejestrowany.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do wykonywania kodu niezarządzanego. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Unregister">
      <MemberSignature Language="C#" Value="public static void Unregister (string authenticationScheme);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unregister(string authenticationScheme) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.AuthenticationManager.Unregister(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unregister (authenticationScheme As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unregister(System::String ^ authenticationScheme);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="authenticationScheme" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="authenticationScheme">Schemat uwierzytelniania modułu do usunięcia.</param>
        <summary>Usuwa moduły uwierzytelniania z określony schemat uwierzytelniania na liście zarejestrowanych modułów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.AuthenticationManager.Unregister%2A> Metoda usuwa moduł uwierzytelniania określony schemat uwierzytelniania z listy modułami uwierzytelniania wywołanymi <xref:System.Net.AuthenticationManager.Authenticate%2A> metody. Modułu należy dodać do listy przy użyciu <xref:System.Net.AuthenticationManager.Register%2A> metody można było usunąć z listy.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Net.AuthenticationManager.Unregister%2A> metodę, aby usunąć moduł uwierzytelniania z określony schemat uwierzytelniania na liście zarejestrowanych modułów.  
  
 [!code-cpp[AuthenticationManager_UnRegister2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/AuthenticationManager_UnRegister2/CPP/authenticationmanager_unregister2.cpp#2)]
 [!code-csharp[AuthenticationManager_UnRegister2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/AuthenticationManager_UnRegister2/CS/authenticationmanager_unregister2.cs#2)]
 [!code-vb[AuthenticationManager_UnRegister2#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/AuthenticationManager_UnRegister2/VB/authenticationmanager_unregister2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="authenticationScheme" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Modułu schematu uwierzytelniania nie jest zarejestrowany.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do wykonywania kodu niezarządzanego. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" />.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="ServicePointManager" FullName="System.Net.ServicePointManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="908099c11e9c314b244caa5cf91af3a83122d406" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36472193" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ServicePointManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ServicePointManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.ServicePointManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ServicePointManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServicePointManager" />
  <TypeSignature Language="F#" Value="type ServicePointManager = class" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.ServicePoint</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zarządza Kolekcja <see cref="T:System.Net.ServicePoint" /> obiektów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager> jest używany do tworzenia, obsługi i usuwania wystąpienia klasy statycznej <xref:System.Net.ServicePoint> klasy.  
  
 Gdy aplikacja żąda połączenie z zasobem internetowym identyfikator URI (Uniform Resource) za pośrednictwem <xref:System.Net.ServicePointManager> obiektu, <xref:System.Net.ServicePointManager> zwraca <xref:System.Net.ServicePoint> obiekt, który zawiera informacje o połączeniu dla hosta i schemat zidentyfikowane przez identyfikator URI. Jeśli istnieje <xref:System.Net.ServicePoint> obiekt dla tego hosta i schemat, <xref:System.Net.ServicePointManager> zwraca obiekt istniejące <xref:System.Net.ServicePoint> obiektu; w przeciwnym razie <xref:System.Net.ServicePointManager> tworzy nowy obiekt <xref:System.Net.ServicePoint> obiektu.  
  
 .NET Framework 4.6 obejmuje nowa funkcja zabezpieczeń, która blokuje niezabezpieczonych szyfrowania i tworzenia skrótów algorytmów dla połączenia. Aplikacje przy użyciu protokołu TLS/SSL za pośrednictwem interfejsów API, takich jak <xref:System.Net.Http.HttpClient>, <xref:System.Net.HttpWebRequest>, <xref:System.Net.FtpWebRequest>, <xref:System.Net.Mail.SmtpClient>, <xref:System.Net.Security.SslStream>, itp. i przeznaczonych dla platformy .NET Framework 4.6 bardziej bezpiecznych zachowanie domyślne.  
  
 Deweloperzy mogą chcesz zrezygnować z tego zachowania, aby zapewnić współdziałanie z ich istniejących usług SSL3 lub TLS z usługi szyfrowania RC4. [W tym artykule](https://support.microsoft.com/kb/3069494) wyjaśniono, jak zmodyfikować kod, tak aby nowe zachowanie jest wyłączona.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Net.ServicePoint> obiektu dla połączeń z www.contoso.com identyfikatora URI.  
  
 [!code-cpp[Classic ServicePoint Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic ServicePoint Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ServicePoint Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic ServicePoint Example/CS/source.cs#1)]
 [!code-vb[Classic ServicePoint Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic ServicePoint Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.ServicePoint" />
  </Docs>
  <Members>
    <Member MemberName="CertificatePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.ICertificatePolicy CertificatePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.ICertificatePolicy CertificatePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.CertificatePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CertificatePolicy As ICertificatePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::ICertificatePolicy ^ CertificatePolicy { System::Net::ICertificatePolicy ^ get(); void set(System::Net::ICertificatePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CertificatePolicy : System.Net.ICertificatePolicy with get, set" Usage="System.Net.ServicePointManager.CertificatePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use ServerCertificateValidationCallback instead", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICertificatePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zasady dotyczące certyfikatów serwera.</summary>
        <value>Obiekt, który implementuje <see cref="T:System.Net.ICertificatePolicy" /> interfejsu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Net.ServicePointManager.CertificatePolicy%2A> właściwość jest ustawiona na <xref:System.Net.ICertificatePolicy> obiektu interfejsu <xref:System.Net.ServicePointManager> obiekt używa zdefiniowane w tym wystąpieniu zamiast domyślnych zasad certyfikatów Zasady certyfikatu.  
  
 Domyślne zasady certyfikatów umożliwia prawidłowe certyfikaty i prawidłowe certyfikaty, które wygasły.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono sposób catch wyjątek zasad certyfikatu dla zasad niestandardowego certyfikatu. Zakłada się zdefiniowano obiektu zasad certyfikatu, czy jednolity identyfikator zasobów (URI) dla zasobu sieci Web jest przechowywana w zmiennej `myUri`i że istnieje metodę o nazwie `ProcessResponse` wykonująca pracy aplikacji.  
  
 [!code-cpp[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/CS/source.cs#1)]
 [!code-vb[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby ustawić <see cref="P:System.Net.ServicePointManager.CertificatePolicy" /> właściwości. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="CheckCertificateRevocationList">
      <MemberSignature Language="C#" Value="public static bool CheckCertificateRevocationList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CheckCertificateRevocationList" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.CheckCertificateRevocationList" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CheckCertificateRevocationList As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CheckCertificateRevocationList { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CheckCertificateRevocationList : bool with get, set" Usage="System.Net.ServicePointManager.CheckCertificateRevocationList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("CRL checks not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość, która wskazuje, czy certyfikat jest sprawdzany względem listy odwołania certyfikatów urzędu.</summary>
        <value>
          <see langword="true" /> Jeśli lista odwołania certyfikatów jest sprawdzana; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Net.ServicePointManager.CheckCertificateRevocationList%2A> jest `true`, certyfikat jest sprawdzany względem listy odwołania certyfikatów urzędu jako część procesu weryfikacji certyfikatu. Jego wartość domyślna to `false`.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawienie dla tej właściwości.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby ustawić tę właściwość. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="ClientCipherSuitesCallback">
      <MemberSignature Language="C#" Value="public static System.Net.CipherSuitesCallback ClientCipherSuitesCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.CipherSuitesCallback ClientCipherSuitesCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ClientCipherSuitesCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ClientCipherSuitesCallback As CipherSuitesCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::CipherSuitesCallback ^ ClientCipherSuitesCallback { System::Net::CipherSuitesCallback ^ get(); void set(System::Net::CipherSuitesCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCipherSuitesCallback : System.Net.CipherSuitesCallback with get, set" Usage="System.Net.ServicePointManager.ClientCipherSuitesCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This API is no longer supported.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CipherSuitesCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultConnectionLimit">
      <MemberSignature Language="C#" Value="public static int DefaultConnectionLimit { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultConnectionLimit" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.DefaultConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultConnectionLimit As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultConnectionLimit { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultConnectionLimit : int with get, set" Usage="System.Net.ServicePointManager.DefaultConnectionLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną liczbę równoczesnych połączeń dozwolona przez <see cref="T:System.Net.ServicePoint" /> obiektu.</summary>
        <value>Maksymalna liczba równoczesnych połączeń dozwolona przez <see cref="T:System.Net.ServicePoint" /> obiektu. Wartość domyślna to 2. Gdy aplikacja jest uruchomiona jako hosta platformy ASP.NET, nie jest możliwe do zmiany wartości tej właściwości przy użyciu pliku konfiguracji, jeśli ustawiono właściwość autokonfiguracji sieci <see langword="true" />. Jednak można zmienić wartość programowo, jeśli właściwość autokonfiguracji sieci ma <see langword="true" />. Wartość z preferowanych raz, podczas ładowania elementu AppDomain.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> Właściwość ustawia domyślną maksymalną liczbę równoczesnych połączeń <xref:System.Net.ServicePointManager> obiektu przypisuje <xref:System.Net.ServicePoint.ConnectionLimit%2A> właściwości podczas tworzenia <xref:System.Net.ServicePoint> obiektów.  
  
 Zmiana <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> właściwość nie ma wpływu na istniejące <xref:System.Net.ServicePoint> obiekty; wpływa tylko na <xref:System.Net.ServicePoint> obiektów, które są inicjowane po zmianie. Jeśli wartość tej właściwości nie została ustawiona, bezpośrednio lub za pomocą konfiguracji, domyślnie przyjmowana jest wartość stała <xref:System.Net.ServicePointManager.DefaultPersistentConnectionLimit>.  
  
> [!NOTE]
>  Zmiany wprowadzone w <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> właściwość dotyczy połączeń zarówno HTTP 1.0 i HTTP 1.1. Nie jest możliwa oddzielnie limit połączeń dla protokołów HTTP 1.0 i HTTP 1.1. W przypadku używania w środowisku serwera (ASP.NET) <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> wartości domyślnych do większej liczby połączeń, które wynosi 10.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawienie dla tej właściwości.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" /> jest mniejsze niż lub równa 0.</exception>
        <permission cref="T:System.Net.WebPermission">Aby uzyskać nieograniczony uprawnień sieci Web. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="DefaultNonPersistentConnectionLimit">
      <MemberSignature Language="C#" Value="public const int DefaultNonPersistentConnectionLimit = 4;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 DefaultNonPersistentConnectionLimit = (4)" />
      <MemberSignature Language="DocId" Value="F:System.Net.ServicePointManager.DefaultNonPersistentConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultNonPersistentConnectionLimit As Integer  = 4" />
      <MemberSignature Language="C++ CLI" Value="public: int DefaultNonPersistentConnectionLimit = 4;" />
      <MemberSignature Language="F#" Value="val mutable DefaultNonPersistentConnectionLimit : int" Usage="System.Net.ServicePointManager.DefaultNonPersistentConnectionLimit" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>4</MemberValue>
      <Docs>
        <summary>Domyślna liczba dozwolonych na trwałe połączeń (4) <see cref="T:System.Net.ServicePoint" /> obiekt połączony HTTP/1.0 lub nowszego serwera. To pole jest stałą, ale nie jest już używany w .NET Framework 2.0.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultPersistentConnectionLimit">
      <MemberSignature Language="C#" Value="public const int DefaultPersistentConnectionLimit = 2;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 DefaultPersistentConnectionLimit = (2)" />
      <MemberSignature Language="DocId" Value="F:System.Net.ServicePointManager.DefaultPersistentConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultPersistentConnectionLimit As Integer  = 2" />
      <MemberSignature Language="C++ CLI" Value="public: int DefaultPersistentConnectionLimit = 2;" />
      <MemberSignature Language="F#" Value="val mutable DefaultPersistentConnectionLimit : int" Usage="System.Net.ServicePointManager.DefaultPersistentConnectionLimit" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>Domyślna liczba połączeń trwałych (2) dozwolone na <see cref="T:System.Net.ServicePoint" /> obiekt połączony z protokołu HTTP/1.1 lub nowszego serwera. To pole jest stałe i służy do inicjowania <see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" /> właściwości Jeśli wartość <see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" /> nie ustawiono właściwości bezpośrednio lub za pośrednictwem konfiguracji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod przykładzie <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> właściwości za pomocą tego pola.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DnsRefreshTimeout">
      <MemberSignature Language="C#" Value="public static int DnsRefreshTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DnsRefreshTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.DnsRefreshTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DnsRefreshTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DnsRefreshTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DnsRefreshTimeout : int with get, set" Usage="System.Net.ServicePointManager.DnsRefreshTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, jak długo domeny Name Service (DNS) rozwiązania jest uważany za ważny.</summary>
        <value>Wartość limitu czasu w milisekundach. Wartość -1 wskazuje nieskończony limit czasu. Wartość domyślna to 120 000 milisekund (dwie minuty).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu ustawienie dla tej właściwości.  
  
 [!code-cpp[System.Net.ServicePointWhidbey#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/cpp/servicepoint.cpp#1)]
 [!code-csharp[System.Net.ServicePointWhidbey#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/CS/servicepoint.cs#1)]
 [!code-vb[System.Net.ServicePointWhidbey#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/VB/servicepoint.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="EnableDnsRoundRobin">
      <MemberSignature Language="C#" Value="public static bool EnableDnsRoundRobin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableDnsRoundRobin" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.EnableDnsRoundRobin" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableDnsRoundRobin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableDnsRoundRobin { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableDnsRoundRobin : bool with get, set" Usage="System.Net.ServicePointManager.EnableDnsRoundRobin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy rozdzielczość usługi nazw domen (DNS, Domain Name System) obraca się między odpowiednie adresy Internet Protocol (IP).</summary>
        <value>
          <see langword="false" /> Jeśli rozpoznawania DNS zawsze zwraca pierwszy adres IP dla określonego hosta; w przeciwnym razie <see langword="true" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy więcej niż jeden adres IP jest skojarzony z nazwą hosta, rozpoznawanie nazw DNS zwykle zwraca tylko pierwszy adres IP. Jeśli ta właściwość jest ustawiona na `true`, następnie kolejne rozwiązania DNS może mieć wszystkich dostępnych adresów IP dla określonego hosta. Ta opcja jest przydatna, gdy używane przez usługę DNS jako mechanizm między serwerów lub klastrów serwerów z równoważeniem obciążenia.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawienie dla tej właściwości.  
  
 [!code-cpp[System.Net.ServicePointWhidbey#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/cpp/servicepoint.cpp#1)]
 [!code-csharp[System.Net.ServicePointWhidbey#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/CS/servicepoint.cs#1)]
 [!code-vb[System.Net.ServicePointWhidbey#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/VB/servicepoint.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionPolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Security.EncryptionPolicy EncryptionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Net.Security.EncryptionPolicy EncryptionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.EncryptionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EncryptionPolicy As EncryptionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Security::EncryptionPolicy EncryptionPolicy { System::Net::Security::EncryptionPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionPolicy : System.Net.Security.EncryptionPolicy" Usage="System.Net.ServicePointManager.EncryptionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Always returns EncryptionPolicy.RequireEncryption.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Security.EncryptionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Net.Security.EncryptionPolicy" /> dla tego <see cref="T:System.Net.ServicePointManager" /> wystąpienia.</summary>
        <value>Zasady szyfrowania, które mają być używane dla tego <see cref="T:System.Net.ServicePointManager" /> wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość nie jest określona w pliku konfiguracyjnym <xref:System.Net.ServicePointManager.EncryptionPolicy%2A> wartością domyślną właściwości <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType>. To jest stosowany do sesji SSL/TLS na tym <xref:System.Net.ServicePointManager> wystąpienia.  
  
 Korzystanie z szyfrowania Null jest wymagane, gdy zasady szyfrowania jest ustawione na <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="P:System.Net.Configuration.ServicePointManagerElement.EncryptionPolicy" />
        <altmember cref="T:System.Net.Security.EncryptionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="Expect100Continue">
      <MemberSignature Language="C#" Value="public static bool Expect100Continue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Expect100Continue" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.Expect100Continue" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Expect100Continue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Expect100Continue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Expect100Continue : bool with get, set" Usage="System.Net.ServicePointManager.Expect100Continue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość, która określa, czy 100-kontynuować zachowanie jest używany.</summary>
        <value>
          <see langword="true" /> Aby włączyć 100-kontynuować działanie. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta właściwość jest równa `true`, 100-kontynuować zachowanie jest używany. Klient żąda używające `PUT` i `POST` metody spowoduje dodanie nagłówka oczekiwania na żądanie, jeśli <xref:System.Net.ServicePointManager.Expect100Continue%2A> właściwość jest `true` i <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości jest większa od zera lub <xref:System.Net.HttpWebRequest.SendChunked%2A> właściwość ma wartość true. Klient będzie oczekiwać 100-kontynuować odpowiedzi od serwera, aby wskazać, że klient ma wysłać zostać przesłane dane. Mechanizm ten umożliwia klientom unikać wysyłania dużych ilości danych za pośrednictwem sieci, gdy serwer od nagłówków żądań zamierza odrzucić żądanie.  
  
 Załóżmy na przykład <xref:System.Net.ServicePointManager.Expect100Continue%2A> jest właściwość `false`. Po wysłaniu żądania do serwera zawiera dane. Jeśli po odczytaniu nagłówków żądań, serwer wymaga uwierzytelnienia, a wysłanie odpowiedzi 401, klient musi ponownie dane z nagłówkami właściwe uwierzytelnienie.  
  
 Jeśli ta właściwość jest `true`, nagłówki żądania są wysyłane do serwera. Jeśli serwer nie zaakceptował żądania, wysyła 100-kontynuować odpowiedzi sygnalizowania, że mogą być przesyłane dane. Jeśli tak jak w poprzednim przykładzie serwer wymaga uwierzytelnienia, wysyłania odpowiedzi 401 i klienta nie ma niepotrzebnie przekazywane dane.  
  
 Zmiana wartości tej właściwości nie wpływa na istniejące <xref:System.Net.ServicePoint> obiektów. Tylko nowych <xref:System.Net.ServicePoint> dotyczą obiektów utworzonych po zmianie.  
  
 100-kontynuować zachowanie nie jest używana do żądania HTTP 1.0, nawet jeśli ta właściwość jest ustawiona na `true`.  
  
 Expect 100-kontynuować zachowanie szczegółowo opisano w sekcji IETF RFC 2616 10.1.1.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawienie dla tej właściwości.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindServicePoint">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Umożliwia znalezienie istniejące <see cref="T:System.Net.ServicePoint" /> obiektu lub tworzy nowy <see cref="T:System.Net.ServicePoint" /> obiektu do zarządzania komunikacji dla tego żądania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (Uri address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(class System.Uri address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (address As Uri) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(Uri ^ address);" />
      <MemberSignature Language="F#" Value="static member FindServicePoint : Uri -&gt; System.Net.ServicePoint" Usage="System.Net.ServicePointManager.FindServicePoint address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="address">
          <see cref="T:System.Uri" /> Obiektu zasobu internetowego, można skontaktować się z.</param>
        <summary>Umożliwia znalezienie istniejące <see cref="T:System.Net.ServicePoint" /> obiektu lub tworzy nowy <see cref="T:System.Net.ServicePoint" /> obiekt do zarządzania komunikacją z określonym <see cref="T:System.Uri" /> obiektu.</summary>
        <returns>
          <see cref="T:System.Net.ServicePoint" /> Obiekt, który zarządza komunikacji dla żądania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager.FindServicePoint%2A> Metoda zwraca <xref:System.Net.ServicePoint> obiekt skojarzony z określonej nazwy hosta w Internecie. Jeśli nie <xref:System.Net.ServicePoint> obiekt istnieje dla tego hosta <xref:System.Net.ServicePointManager> tworzy obiekt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Maksymalna liczba <see cref="T:System.Net.ServicePoint" /> obiektów zdefiniowanych w <see cref="P:System.Net.ServicePointManager.MaxServicePoints" /> został osiągnięty.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (string uriString, System.Net.IWebProxy proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(string uriString, class System.Net.IWebProxy proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.String,System.Net.IWebProxy)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (uriString As String, proxy As IWebProxy) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(System::String ^ uriString, System::Net::IWebProxy ^ proxy);" />
      <MemberSignature Language="F#" Value="static member FindServicePoint : string * System.Net.IWebProxy -&gt; System.Net.ServicePoint" Usage="System.Net.ServicePointManager.FindServicePoint (uriString, proxy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="proxy" Type="System.Net.IWebProxy" />
      </Parameters>
      <Docs>
        <param name="uriString">Identyfikator URI zasobu internetowego, kontakt.</param>
        <param name="proxy">Dane serwera proxy dla tego żądania.</param>
        <summary>Umożliwia znalezienie istniejące <see cref="T:System.Net.ServicePoint" /> obiektu lub tworzy nowy <see cref="T:System.Net.ServicePoint" /> obiekt do zarządzania komunikacją z określonego identyfikatora URI (Uniform Resource).</summary>
        <returns>
          <see cref="T:System.Net.ServicePoint" /> Obiekt, który zarządza komunikacji dla żądania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager.FindServicePoint%2A> Metoda zwraca <xref:System.Net.ServicePoint> obiekt skojarzony z określonej nazwy hosta w Internecie. Jeśli nie <xref:System.Net.ServicePoint> obiekt istnieje dla tego hosta <xref:System.Net.ServicePointManager> tworzy obiekt.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wywołanie tej metody, aby uzyskać dostęp do <xref:System.Net.ServicePoint> obiektu.  
  
 [!code-cpp[System.Net.ServicePoint#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#7)]
 [!code-csharp[System.Net.ServicePoint#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#7)]
 [!code-vb[System.Net.ServicePoint#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">Identyfikator URI określony w <paramref name="uriString" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Maksymalna liczba <see cref="T:System.Net.ServicePoint" /> obiektów zdefiniowanych w <see cref="P:System.Net.ServicePointManager.MaxServicePoints" /> został osiągnięty.</exception>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (Uri address, System.Net.IWebProxy proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(class System.Uri address, class System.Net.IWebProxy proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.Uri,System.Net.IWebProxy)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (address As Uri, proxy As IWebProxy) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(Uri ^ address, System::Net::IWebProxy ^ proxy);" />
      <MemberSignature Language="F#" Value="static member FindServicePoint : Uri * System.Net.IWebProxy -&gt; System.Net.ServicePoint" Usage="System.Net.ServicePointManager.FindServicePoint (address, proxy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Uri" />
        <Parameter Name="proxy" Type="System.Net.IWebProxy" />
      </Parameters>
      <Docs>
        <param name="address">A <see cref="T:System.Uri" /> obiekt, który zawiera adres zasobu internetowego, można skontaktować się z.</param>
        <param name="proxy">Dane serwera proxy dla tego żądania.</param>
        <summary>Umożliwia znalezienie istniejące <see cref="T:System.Net.ServicePoint" /> obiektu lub tworzy nowy <see cref="T:System.Net.ServicePoint" /> obiekt do zarządzania komunikacją z określonym <see cref="T:System.Uri" /> obiektu.</summary>
        <returns>
          <see cref="T:System.Net.ServicePoint" /> Obiekt, który zarządza komunikacji dla żądania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager.FindServicePoint%2A> Metoda zwraca <xref:System.Net.ServicePoint> obiekt skojarzony z określonej nazwy hosta w Internecie. Jeśli nie <xref:System.Net.ServicePoint> obiekt istnieje dla tego hosta <xref:System.Net.ServicePointManager> tworzy obiekt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Maksymalna liczba <see cref="T:System.Net.ServicePoint" /> obiektów zdefiniowanych w <see cref="P:System.Net.ServicePointManager.MaxServicePoints" /> został osiągnięty.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="MaxServicePointIdleTime">
      <MemberSignature Language="C#" Value="public static int MaxServicePointIdleTime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxServicePointIdleTime" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.MaxServicePointIdleTime" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MaxServicePointIdleTime As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxServicePointIdleTime { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxServicePointIdleTime : int with get, set" Usage="System.Net.ServicePointManager.MaxServicePointIdleTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalny czas bezczynności <see cref="T:System.Net.ServicePoint" /> obiektu.</summary>
        <value>Maksymalny czas bezczynności (w milisekundach), z <see cref="T:System.Net.ServicePoint" /> obiektu. Wartość domyślna to 100 000 milisekund (100 sekund).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager.MaxServicePointIdleTime%2A> Właściwość ustawia maksymalny czas bezczynności <xref:System.Net.ServicePointManager> obiektu przypisuje <xref:System.Net.ServicePoint.MaxIdleTime%2A> właściwości podczas tworzenia <xref:System.Net.ServicePoint> obiektów. Zmiana wartości tej wpływa na tylko <xref:System.Net.ServicePoint> obiektów, które są inicjowane po zmianie wartości.  
  
 Po <xref:System.Net.ServicePoint> obiekt był bezczynny przez czas określony w <xref:System.Net.ServicePoint.MaxIdleTime%2A>, jest uprawniona do wyrzucanie elementów bezużytecznych. A <xref:System.Net.ServicePoint> obiekt jest w stanie bezczynności listy połączeń powiązanych z <xref:System.Net.ServicePoint> obiekt jest pusty.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawienie dla tej właściwości.  
  
 [!code-cpp[System.Net.ServicePoint#8](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#8)]
 [!code-csharp[System.Net.ServicePoint#8](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#8)]
 [!code-vb[System.Net.ServicePoint#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Net.ServicePointManager.MaxServicePointIdleTime" /> jest mniejsza niż <see cref="F:System.Threading.Timeout.Infinite" /> lub większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Net.WebPermission">Aby uzyskać nieograniczony uprawnień sieci Web. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="MaxServicePoints">
      <MemberSignature Language="C#" Value="public static int MaxServicePoints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxServicePoints" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.MaxServicePoints" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MaxServicePoints As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxServicePoints { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxServicePoints : int with get, set" Usage="System.Net.ServicePointManager.MaxServicePoints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną liczbę <see cref="T:System.Net.ServicePoint" /> obiektów, aby zachować w dowolnym momencie.</summary>
        <value>Maksymalna liczba <see cref="T:System.Net.ServicePoint" /> obiekty do zachowania. Wartość domyślna to 0, co oznacza, że nie ma żadnego limitu liczby <see cref="T:System.Net.ServicePoint" /> obiektów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy zmniejszyć <xref:System.Net.ServicePointManager.MaxServicePoints%2A> właściwości poniżej numer <xref:System.Net.ServicePoint> obiektów istniejących, w obecnie <xref:System.Net.ServicePointManager> usuwa <xref:System.Net.ServicePoint> obiektów w czasie najdłuższy bezczynności. Jeśli liczba <xref:System.Net.ServicePoint> obiekty o aktywnych połączeń jest większa niż wartość <xref:System.Net.ServicePointManager.MaxServicePoints%2A>, <xref:System.Net.ServicePointManager> obiekt usuwa <xref:System.Net.ServicePoint> obiekty staną się one bezczynności.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawienie dla tej właściwości.  
  
 [!code-cpp[System.Net.ServicePoint#8](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#8)]
 [!code-csharp[System.Net.ServicePoint#8](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#8)]
 [!code-vb[System.Net.ServicePoint#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Net.ServicePointManager.MaxServicePoints" /> jest mniejsza niż 0 lub większą niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Net.WebPermission">Aby uzyskać nieograniczony uprawnień sieci Web. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="ReusePort">
      <MemberSignature Language="C#" Value="public static bool ReusePort { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool ReusePort" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ReusePort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ReusePort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool ReusePort { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReusePort : bool with get, set" Usage="System.Net.ServicePointManager.ReusePort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ustawienie wartości właściwości <see langword="true" /> powoduje, że wszystkie połączenia TCP wychodzące z HttpWebRequest, aby użyć opcji gniazda natywnego SO_REUSE_UNICASTPORT w gnieździe. Powoduje to podstawowy portów wychodzących do udostępnienia. Jest to przydatne w scenariuszach, w których są wykonane dużej liczby połączeń wychodzących w krótkim czasie i ryzyka aplikacji kończy się wolne porty.</summary>
        <value>Zwraca <see cref="T:System.Boolean" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość domyślna to `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SecurityProtocol">
      <MemberSignature Language="C#" Value="public static System.Net.SecurityProtocolType SecurityProtocol { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Net.SecurityProtocolType SecurityProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.SecurityProtocol" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SecurityProtocol As SecurityProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::SecurityProtocolType SecurityProtocol { System::Net::SecurityProtocolType get(); void set(System::Net::SecurityProtocolType value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityProtocol : System.Net.SecurityProtocolType with get, set" Usage="System.Net.ServicePointManager.SecurityProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.SecurityProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia protokół zabezpieczeń używane przez <see cref="T:System.Net.ServicePoint" /> obiekty zarządzane przez <see cref="T:System.Net.ServicePointManager" /> obiektu.</summary>
        <value>Jedna z wartości zdefiniowanych w <see cref="T:System.Net.SecurityProtocolType" /> wyliczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Ta właściwość wybiera wersji protokołu Secure Sockets Layer (SSL) lub zabezpieczeń TLS (Transport Layer) do użycia na nowe połączenia; istniejące połączenia nie ulegają zmianie.  
  
Począwszy od .NET Framework 4.7, wartość domyślna tej właściwości to <xref:System.Net.SecurityProtocolType.SystemDefault?displayProperty=nameWithType>. Dzięki temu .NET Framework sieci na podstawie interfejsów API <xref:System.Net.Security.SslStream> (na przykład FTP, HTTP i SMTP) dziedziczenia domyślnych protokołów zabezpieczeń z systemu operacyjnego lub wszystkie konfiguracje niestandardowe wykonana przez administratora systemu. Aby uzyskać informacje dotyczące protokołu SSL/TLS, które protokoły są włączone domyślnie na każdej wersji systemu operacyjnego Windows, zobacz [protokoły TLS/SSL (dostawca SSP Schannel)](https://msdn.microsoft.com/library/windows/desktop/mt808159.aspx).
 
Dla wersji programu .NET Framework za pomocą programu .NET Framework 4.6.2 znajduje się ma wartości domyślnej dla tej właściwości. Zmienia stale pozioma zabezpieczeń i domyślnie protokołów i poziomów ochrony są zmieniane w czasie, aby uniknąć znane słabe strony algorytmu. Wartości domyślne różnią się w zależności od konfiguracji poszczególnych maszyn, zainstalowanego oprogramowania i zastosowane poprawki.  
  
 Kod powinien nigdy niejawnie zależy od przy użyciu poziomu ochrony określonej, ani przy założeniu, że poziom zabezpieczeń jest używany domyślnie. Jeśli aplikacja zależy od stosowania poziom zabezpieczeń, należy jawnie określić tego poziomu, a następnie sprawdź upewnij się, że faktycznie jest używany w ustanowionym połączeniu. Co więcej należy tak zaprojektować za niezawodny zmiany, do których protokoły są obsługiwane w wypadku swój kod, tak często zmian z wyprzedzeniem małego ograniczy zagrożenia pojawiające się.  
  
 .NET Framework 4.6 obejmuje nowa funkcja zabezpieczeń, która blokuje niezabezpieczonych szyfrowania i tworzenia skrótów algorytmów dla połączenia. Aplikacji przy użyciu protokołu TLS/SSL za pośrednictwem interfejsów API, takich jak HttpClient, HttpWebRequest, FTPClient, SmtpClient, SslStream, itp. oraz przeznaczonych dla platformy .NET Framework 4.6 uzyskać bardziej bezpiecznych zachowanie domyślne.  
  
 Deweloperzy mogą chcesz zrezygnować z tego zachowania, aby zapewnić współdziałanie z ich istniejących SSL3 usług protokołu TLS lub z usługi szyfrowania RC4. [W tym artykule](https://support.microsoft.com/kb/3069494) wyjaśniono, jak zmodyfikować kod, tak aby nowe zachowanie jest wyłączona.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Podana wartość do ustawienia właściwości nie jest prawidłową <see cref="T:System.Net.SecurityProtocolType" /> wartości wyliczenia.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.SecurityProtocolType" />
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public static System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.ServicePointManager.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wywołanie zwrotne do weryfikacji certyfikatu serwera.</summary>
        <value>A <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" />. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Aplikacja może ustawić <xref:System.Net.ServicePointManager.ServerCertificateValidationCallback%2A> właściwości na metodę weryfikacji niestandardowej przez klienta certyfikatu serwera. Podczas wykonywania niestandardowego sprawdzania poprawności, `sender` parametr przekazany do <xref:System.Net.Security.RemoteCertificateValidationCallback> może być nazwą hosta ciąg lub obiekt pochodną <xref:System.Net.WebRequest> (<xref:System.Net.HttpWebRequest>, na przykład) w zależności od <xref:System.Net.ServicePointManager.CertificatePolicy%2A> właściwości.  
  
Jeśli niestandardowego sprawdzania poprawności nie jest używany, nazwa certyfikatu jest porównywana z nazwą hosta do utworzenia żądania. Na przykład jeśli <xref:System.Net.WebRequest.Create%28System.String%29> został przekazany parametr "https://www.contoso.com/default.html", to domyślne zachowanie dla klienta w celu sprawdzenia certyfikatu www.contoso.com.  

Mimo iż multiemisji delegata, tylko wartość zwracana z obsługi zdarzeń ostatnio wykonana jest uważana za. Innymi słowy, można dołączyć wielu obiektów delegowanych, a następnie otrzymują oni wszystkie wywołania zwrotnego z <xref:System.Net.ServicePointManager.ServerCertificateValidationCallback%2A>. Każdego wywołania zwrotnego zwraca wartość wskazującą, czy certyfikat jest akceptowany, czy nie; jednak wzięty pod uwagę tylko wartość z ostatniej delegata.
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby ustawić <see cref="P:System.Net.ServicePointManager.ServerCertificateValidationCallback" /> właściwości. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="ServerCipherSuitesCallback">
      <MemberSignature Language="C#" Value="public static System.Net.CipherSuitesCallback ServerCipherSuitesCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.CipherSuitesCallback ServerCipherSuitesCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ServerCipherSuitesCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ServerCipherSuitesCallback As CipherSuitesCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::CipherSuitesCallback ^ ServerCipherSuitesCallback { System::Net::CipherSuitesCallback ^ get(); void set(System::Net::CipherSuitesCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCipherSuitesCallback : System.Net.CipherSuitesCallback with get, set" Usage="System.Net.ServicePointManager.ServerCipherSuitesCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This API is no longer supported.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CipherSuitesCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTcpKeepAlive">
      <MemberSignature Language="C#" Value="public static void SetTcpKeepAlive (bool enabled, int keepAliveTime, int keepAliveInterval);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTcpKeepAlive(bool enabled, int32 keepAliveTime, int32 keepAliveInterval) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.SetTcpKeepAlive(System.Boolean,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTcpKeepAlive (enabled As Boolean, keepAliveTime As Integer, keepAliveInterval As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTcpKeepAlive(bool enabled, int keepAliveTime, int keepAliveInterval);" />
      <MemberSignature Language="F#" Value="static member SetTcpKeepAlive : bool * int * int -&gt; unit" Usage="System.Net.ServicePointManager.SetTcpKeepAlive (enabled, keepAliveTime, keepAliveInterval)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enabled" Type="System.Boolean" />
        <Parameter Name="keepAliveTime" Type="System.Int32" />
        <Parameter Name="keepAliveInterval" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="enabled">Jeśli wartość true, a następnie keep-alive opcji TCP za pośrednictwem połączenia TCP zostanie włączona przy użyciu określonego <c>keepAliveTime</c> i <c>keepAliveInterval</c> wartości.  Jeśli ma wartość false, a następnie opcję keep-alive TCP jest wyłączone, a pozostałe parametry są ignorowane.  Wartość domyślna to false.</param>
        <param name="keepAliveTime">Określa limit czasu w milisekundach, bez żadnych działań, dopóki wysłaniu pierwszego pakietu keep-alive.  Wartość musi być większa niż 0.  Jeśli została przekazana wartość mniejszą niż lub równa zero <see cref="T:System.ArgumentOutOfRangeException" /> jest generowany.</param>
        <param name="keepAliveInterval">Określa interwał w milisekundach między kolejnymi keep-alive pakiety są wysyłane w przypadku nieodebrania bez potwierdzenia.  Wartość musi być większa niż 0.  Jeśli została przekazana wartość mniejszą niż lub równa zero <see cref="T:System.ArgumentOutOfRangeException" /> jest generowany.</param>
        <summary>Włącza lub wyłącza opcję podtrzymania połączenia TCP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja może zażądać dostawcy TCP/IP korzystanie z pakietów podtrzymania połączenia TCP. Wartość domyślna to, że korzystanie z pakietów podtrzymania połączenia TCP jest wyłączone.  
  
 Domyślne ustawienia gniazda TCP jest zainicjowany limitu czasu zestawy keep-alive 2 godziny i keep-alive interwał na 1 sekundę. `keepAliveTime` Parametr określa limit czasu w milisekundach, bez żadnych działań, dopóki wysłaniu pierwszego pakietu keep-alive. `keepAliveInterval` Parametr określa interwał w milisekundach między podczas kolejnych keep-alive pakiety są wysyłane w przypadku nieodebrania bez potwierdzenia. Liczba keep-alive sond nie można zmienić i jest ustawiony na 10.  
  
 Jeśli połączenie TCP zostało przerwane w wyniku utrzymywania aktywności <xref:System.Net.Sockets.SocketError> z <xref:System.Net.Sockets.SocketError.NetworkReset> jest zwracana do żadnych wywołań w toku w gnieździe, i kolejnych wywołań zakończy się niepowodzeniem z <xref:System.Net.Sockets.SocketError> z <xref:System.Net.Sockets.SocketError.NotConnected>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość określona dla <paramref name="keepAliveTime" /> lub <paramref name="keepAliveInterval" /> parametr jest mniejsza niż lub równa 0.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="UseNagleAlgorithm">
      <MemberSignature Language="C#" Value="public static bool UseNagleAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseNagleAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.UseNagleAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseNagleAlgorithm As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseNagleAlgorithm { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseNagleAlgorithm : bool with get, set" Usage="System.Net.ServicePointManager.UseNagleAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy przez punkty usługi zarządzane przez ten jest używany algorytm Nagle'a <see cref="T:System.Net.ServicePointManager" /> obiektu.</summary>
        <value>
          <see langword="true" /> Aby używać algorytmu Nagle'a; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zmniejszyć ruch sieciowy przez buforowanie małych pakietów danych i przesyła je jako pojedynczy pakiet jest używany algorytm Nagle'a. Ten proces jest również nazywany "nagling"; jest powszechnie używane ponieważ redukuje liczbę pakietów wysłanych i zmniejsza narzut na pakiet.  
  
 Zmiana wartości tej właściwości nie wpływa na istniejące <xref:System.Net.ServicePoint> obiektów. Dotyczy tylko nowe usługi punkty utworzony po zmianie.  
  
 Algorytm Nagle'a szczegółowo opisano w IETF RFC 896.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawienie dla tej właściwości.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
  </Members>
</Type>
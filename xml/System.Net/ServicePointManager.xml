<Type Name="ServicePointManager" FullName="System.Net.ServicePointManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a922683c6ea0874d1646f736ba61deb1ce6b978d" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51890544" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ServicePointManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ServicePointManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.ServicePointManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ServicePointManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServicePointManager" />
  <TypeSignature Language="F#" Value="type ServicePointManager = class" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.ServicePoint</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zarządza zbiorem <see cref="T:System.Net.ServicePoint" /> obiektów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager> jest klasą statyczną, używany do tworzenia, obsługi i usuwania wystąpień <xref:System.Net.ServicePoint> klasy.  
  
 Gdy aplikacja żąda połączenia do zasobu internetowego identyfikator (URI) za pośrednictwem <xref:System.Net.ServicePointManager> obiektu <xref:System.Net.ServicePointManager> zwraca <xref:System.Net.ServicePoint> obiekt, który zawiera informacje o połączeniu dla hosta i zidentyfikować schematu według identyfikatora URI. W przypadku istniejącego <xref:System.Net.ServicePoint> obiektu dla tego hosta oraz system pod <xref:System.Net.ServicePointManager> zwraca istniejące <xref:System.Net.ServicePoint> obiektu; w przeciwnym razie <xref:System.Net.ServicePointManager> obiektu tworzy nowy <xref:System.Net.ServicePoint> obiektu.  
  
 .NET Framework 4.6 zawiera nową funkcję zabezpieczeń, która blokuje szyfrowania niezabezpieczone i algorytmy dla połączeń wyznaczania wartości skrótu. Aplikacje przy użyciu protokołu TLS/SSL za pośrednictwem interfejsów API, takich jak <xref:System.Net.Http.HttpClient>, <xref:System.Net.HttpWebRequest>, <xref:System.Net.FtpWebRequest>, <xref:System.Net.Mail.SmtpClient>, <xref:System.Net.Security.SslStream>itp. otrzymasz przeznaczonych dla platformy .NET Framework 4.6 bardziej bezpieczne zachowanie domyślne.  
  
 Deweloperzy mogą chcą zrezygnować z tego zachowania, aby zapewnić współdziałanie z ich istniejących usług SSL3 lub TLS z usług RC4. [W tym artykule](https://support.microsoft.com/kb/3069494) wyjaśnia, jak zmodyfikować kod, tak, aby nowe zachowanie jest wyłączona.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Net.ServicePoint> obiektu dla połączeń z www.contoso.com identyfikatora URI.  
  
 [!code-cpp[Classic ServicePoint Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic ServicePoint Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ServicePoint Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic ServicePoint Example/CS/source.cs#1)]
 [!code-vb[Classic ServicePoint Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic ServicePoint Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.ServicePoint" />
    <related type="Article" href="https://msdn.microsoft.com/library/6e5def51-3646-4ef6-a7bd-c69151321bec">ServicePointManager — Element (ustawienia sieci)</related>
  </Docs>
  <Members>
    <Member MemberName="CertificatePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.ICertificatePolicy CertificatePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.ICertificatePolicy CertificatePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.CertificatePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CertificatePolicy As ICertificatePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::ICertificatePolicy ^ CertificatePolicy { System::Net::ICertificatePolicy ^ get(); void set(System::Net::ICertificatePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CertificatePolicy : System.Net.ICertificatePolicy with get, set" Usage="System.Net.ServicePointManager.CertificatePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use ServerCertificateValidationCallback instead", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("CertificatePolicy is obsoleted for this type, please use ServerCertificateValidationCallback instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICertificatePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zasady dla certyfikatów serwera.</summary>
        <value>Obiekt, który implementuje <see cref="T:System.Net.ICertificatePolicy" /> interfejsu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Net.ServicePointManager.CertificatePolicy%2A> właściwość jest ustawiona na <xref:System.Net.ICertificatePolicy> obiektu interfejsu <xref:System.Net.ServicePointManager> obiekt używa zasady certyfikatów, zdefiniowane w tym wystąpieniu zamiast domyślnych zasad certyfikatów.  
  
 Domyślnych zasad certyfikatów umożliwia prawidłowe certyfikaty i prawidłowych certyfikatów, które wygasły.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano, jak zostać przechwycony wyjątek zasad certyfikatu dla zasad niestandardowego certyfikatu. Przyjęto założenie, zdefiniowany obiekt zasad certyfikatu, że identyfikator URI (Uniform Resource) dla zasobu sieci Web znajduje się w zmiennej `myUri`i że ma metodę o nazwie `ProcessResponse` który wykonuje pracę aplikacji.  
  
 [!code-cpp[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/CS/source.cs#1)]
 [!code-vb[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby ustawić <see cref="P:System.Net.ServicePointManager.CertificatePolicy" /> właściwości. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="CheckCertificateRevocationList">
      <MemberSignature Language="C#" Value="public static bool CheckCertificateRevocationList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CheckCertificateRevocationList" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.CheckCertificateRevocationList" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CheckCertificateRevocationList As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CheckCertificateRevocationList { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CheckCertificateRevocationList : bool with get, set" Usage="System.Net.ServicePointManager.CheckCertificateRevocationList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("CRL checks not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość, która wskazuje, czy certyfikat jest sprawdzana względem listy odwołania certyfikatów urzędu.</summary>
        <value>
          <see langword="true" /> Jeśli zaznaczono opcję listy odwołania certyfikatów; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Net.ServicePointManager.CheckCertificateRevocationList%2A> jest `true`, certyfikat jest sprawdzana względem listy odwołania certyfikatów urzędu jako część procesu weryfikacji certyfikatu. Jego wartość domyślna to `false`.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia tę właściwość.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby ustawić tę właściwość. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="ClientCipherSuitesCallback">
      <MemberSignature Language="C#" Value="public static System.Net.CipherSuitesCallback ClientCipherSuitesCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.CipherSuitesCallback ClientCipherSuitesCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ClientCipherSuitesCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ClientCipherSuitesCallback As CipherSuitesCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::CipherSuitesCallback ^ ClientCipherSuitesCallback { System::Net::CipherSuitesCallback ^ get(); void set(System::Net::CipherSuitesCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCipherSuitesCallback : System.Net.CipherSuitesCallback with get, set" Usage="System.Net.ServicePointManager.ClientCipherSuitesCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Obsolete("This API is no longer supported.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CipherSuitesCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultConnectionLimit">
      <MemberSignature Language="C#" Value="public static int DefaultConnectionLimit { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultConnectionLimit" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.DefaultConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultConnectionLimit As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultConnectionLimit { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultConnectionLimit : int with get, set" Usage="System.Net.ServicePointManager.DefaultConnectionLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną liczbę równoczesnych połączeń dozwolona przez <see cref="T:System.Net.ServicePoint" /> obiektu.</summary>
        <value>Maksymalna liczba równoczesnych połączeń dozwolona przez <see cref="T:System.Net.ServicePoint" /> obiektu. Domyślny limit połączeń jest 10 dla aplikacji ASP.NET hostowane i 2 dla wszystkich innych. Gdy aplikacja jest uruchomiona jako hosta programu ASP.NET, nie jest możliwe zmienić wartość tej właściwości przy użyciu pliku konfiguracji, jeśli ustawiono właściwość autokonfiguracji sieci <see langword="true" />. Jednak można zmienić wartość programowo, gdy właściwość autokonfiguracji sieci jest <see langword="true" />. Ustawia wartość preferowaną raz podczas ładowania elementu AppDomain.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> Właściwość ustawia maksymalną domyślną liczbę jednoczesnych połączeń <xref:System.Net.ServicePointManager> przypisuje obiekt <xref:System.Net.ServicePoint.ConnectionLimit%2A> właściwości podczas tworzenia <xref:System.Net.ServicePoint> obiektów.  
  
 Zmiana <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> właściwość nie ma wpływu na istniejące <xref:System.Net.ServicePoint> obiekty; dotyczy tylko <xref:System.Net.ServicePoint> obiektów, które są inicjowane po zmianie. Jeśli nie ustawiono wartość tej właściwości, bezpośrednio lub za pośrednictwem konfiguracji, ma domyślnie wartość tej stałej <xref:System.Net.ServicePointManager.DefaultPersistentConnectionLimit>.  
  
> [!NOTE]
>  Wszelkie zmiany <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> właściwość dotyczy połączeń HTTP 1.0 i 1.1 protokołu HTTP. Nie jest możliwe oddzielnie zmienić limit połączeń dla protokołów HTTP 1.0 i 1.1 protokołu HTTP.
  
   
  
## Examples  
 Poniższy przykład kodu ustawia tę właściwość.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" /> jest mniejsza niż lub równa 0.</exception>
        <permission cref="T:System.Net.WebPermission">dla nieograniczonych uprawnień w sieci Web. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="DefaultNonPersistentConnectionLimit">
      <MemberSignature Language="C#" Value="public const int DefaultNonPersistentConnectionLimit = 4;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 DefaultNonPersistentConnectionLimit = (4)" />
      <MemberSignature Language="DocId" Value="F:System.Net.ServicePointManager.DefaultNonPersistentConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultNonPersistentConnectionLimit As Integer  = 4" />
      <MemberSignature Language="C++ CLI" Value="public: int DefaultNonPersistentConnectionLimit = 4;" />
      <MemberSignature Language="F#" Value="val mutable DefaultNonPersistentConnectionLimit : int" Usage="System.Net.ServicePointManager.DefaultNonPersistentConnectionLimit" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>4</MemberValue>
      <Docs>
        <summary>Domyślna liczba dozwolonych na trwałe połączeń (4) <see cref="T:System.Net.ServicePoint" /> połączony obiekt HTTP/1.0 lub nowszy. To pole jest stałe, ale nie jest już używany w programie .NET Framework 2.0.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultPersistentConnectionLimit">
      <MemberSignature Language="C#" Value="public const int DefaultPersistentConnectionLimit = 2;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 DefaultPersistentConnectionLimit = (2)" />
      <MemberSignature Language="DocId" Value="F:System.Net.ServicePointManager.DefaultPersistentConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultPersistentConnectionLimit As Integer  = 2" />
      <MemberSignature Language="C++ CLI" Value="public: int DefaultPersistentConnectionLimit = 2;" />
      <MemberSignature Language="F#" Value="val mutable DefaultPersistentConnectionLimit : int" Usage="System.Net.ServicePointManager.DefaultPersistentConnectionLimit" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>Domyślna liczba połączeń trwałych (2) povolen <see cref="T:System.Net.ServicePoint" /> połączony obiekt HTTP/1.1 lub nowszy. To pole jest stałe i służy do inicjowania <see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" /> właściwość Jeśli wartość <see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" /> właściwości nie została ustawiona, bezpośrednio lub za pośrednictwem konfiguracji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod ustawia przykład <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> właściwości, za pomocą tego pola.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DnsRefreshTimeout">
      <MemberSignature Language="C#" Value="public static int DnsRefreshTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DnsRefreshTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.DnsRefreshTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DnsRefreshTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DnsRefreshTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DnsRefreshTimeout : int with get, set" Usage="System.Net.ServicePointManager.DnsRefreshTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, ile domeny nazwa usługi (DNS) rozwiązania jest uważany za ważny.</summary>
        <value>Wartość limitu czasu w milisekundach. Wartość -1 wskazuje nieskończony limit czasu. Wartość domyślna to 120 000 milisekund (dwie minuty).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu ustawia tę właściwość.  
  
 [!code-cpp[System.Net.ServicePointWhidbey#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/cpp/servicepoint.cpp#1)]
 [!code-csharp[System.Net.ServicePointWhidbey#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/CS/servicepoint.cs#1)]
 [!code-vb[System.Net.ServicePointWhidbey#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/VB/servicepoint.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="EnableDnsRoundRobin">
      <MemberSignature Language="C#" Value="public static bool EnableDnsRoundRobin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableDnsRoundRobin" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.EnableDnsRoundRobin" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableDnsRoundRobin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableDnsRoundRobin { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableDnsRoundRobin : bool with get, set" Usage="System.Net.ServicePointManager.EnableDnsRoundRobin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy rozwiązanie problemu dotyczącego usługi nazw domen (DNS, Domain Name System) obraca się między odpowiednie adresy protokołu internetowego (IP).</summary>
        <value>
          <see langword="false" /> Jeśli rozpoznawanie nazw DNS zawsze zwraca pierwszy adres IP dla określonego hosta; w przeciwnym razie <see langword="true" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy więcej niż jeden adres IP jest skojarzony z nazwą hosta, rozpoznawanie nazw DNS zwykle zwraca tylko pierwszy adres IP. Jeśli ta właściwość jest ustawiona na `true`, a następnie kolejne rozwiązania DNS będzie przechodzić przez wszystkie adresy IP dostępne dla danego hosta. Ta opcja jest przydatna, gdy usługa używa DNS jako mechanizm między serwerami lub klastrami serwerów z równoważeniem obciążenia.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia tę właściwość.  
  
 [!code-cpp[System.Net.ServicePointWhidbey#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/cpp/servicepoint.cpp#1)]
 [!code-csharp[System.Net.ServicePointWhidbey#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/CS/servicepoint.cs#1)]
 [!code-vb[System.Net.ServicePointWhidbey#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/VB/servicepoint.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionPolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Security.EncryptionPolicy EncryptionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Net.Security.EncryptionPolicy EncryptionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.EncryptionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EncryptionPolicy As EncryptionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Security::EncryptionPolicy EncryptionPolicy { System::Net::Security::EncryptionPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionPolicy : System.Net.Security.EncryptionPolicy" Usage="System.Net.ServicePointManager.EncryptionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Always returns EncryptionPolicy.RequireEncryption.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Security.EncryptionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Net.Security.EncryptionPolicy" /> tego <see cref="T:System.Net.ServicePointManager" /> wystąpienia.</summary>
        <value>Zasady szyfrowania, aby użyć tego <see cref="T:System.Net.ServicePointManager" /> wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość nie jest określona w pliku konfiguracyjnym <xref:System.Net.ServicePointManager.EncryptionPolicy%2A> właściwości wartość domyślna to <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType>. To jest stosowany do sesji SSL/TLS, w tym <xref:System.Net.ServicePointManager> wystąpienia.  
  
 Korzystanie z szyfrowania o wartości Null jest wymagane, jeśli ustawiono zasady szyfrowania <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="P:System.Net.Configuration.ServicePointManagerElement.EncryptionPolicy" />
        <altmember cref="T:System.Net.Security.EncryptionPolicy" />
        <related type="Article" href="https://msdn.microsoft.com/library/6e5def51-3646-4ef6-a7bd-c69151321bec">ServicePointManager — Element (ustawienia sieci)</related>
      </Docs>
    </Member>
    <Member MemberName="Expect100Continue">
      <MemberSignature Language="C#" Value="public static bool Expect100Continue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Expect100Continue" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.Expect100Continue" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Expect100Continue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Expect100Continue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Expect100Continue : bool with get, set" Usage="System.Net.ServicePointManager.Expect100Continue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość, która określa, czy 100 — Kontynuuj, zachowanie jest używany.</summary>
        <value>
          <see langword="true" /> Aby włączyć 100 — Kontynuuj zachowanie. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta właściwość jest równa `true`, 100 — Kontynuuj, zachowanie jest używany. Klient żąda używające `PUT` i `POST` metody spowoduje dodanie nagłówkiem Expect na żądanie, gdy <xref:System.Net.ServicePointManager.Expect100Continue%2A> właściwość `true` i <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwość jest większa od zera lub <xref:System.Net.HttpWebRequest.SendChunked%2A> właściwość ma wartość true. Klient będzie oczekiwać 100 — Kontynuuj odpowiedzi z serwera, aby wskazać, że klient powinien wysyłać dane do opublikowania. Ten mechanizm pozwala klientom unikanie wysyłania dużych ilości danych za pośrednictwem sieci, gdy zamierza odrzucenia żądania serwera, oparte na nagłówki żądania.  
  
 Załóżmy na przykład <xref:System.Net.ServicePointManager.Expect100Continue%2A> właściwość `false`. Gdy żądanie jest wysyłane do serwera, zawiera dane. Jeśli po odczytaniu nagłówków żądań, serwer wymaga uwierzytelnienia, a wysłanie odpowiedzi 401, klient musi ponownie wysłać danych przy użyciu nagłówków właściwe uwierzytelnienie.  
  
 Jeśli ta właściwość jest `true`, nagłówki żądania są wysyłane do serwera. Jeśli serwer nie zaakceptował żądania, wysyła 100 — Kontynuuj odpowiedzi sygnalizowania, że dane mogą być przesyłane. Jeśli, tak jak w poprzednim przykładzie serwer wymaga uwierzytelnienia, wysyłania odpowiedzi 401 i klient nie ma niepotrzebnie przesyłane dane.  
  
 Zmiana wartości tej właściwości nie ma wpływu na istniejące <xref:System.Net.ServicePoint> obiektów. Tylko nowe <xref:System.Net.ServicePoint> dotyczą obiektów utworzonych po zmianie.  
  
 100 — Kontynuuj zachowanie nie jest używany do żądania HTTP 1.0, nawet wtedy, gdy ta właściwość jest ustawiona `true`.  
  
 Expect 100 — Kontynuuj opisano szczegółowo w sekcji IETF RFC 2616 10.1.1 zachowanie.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia tę właściwość.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindServicePoint">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Umożliwia znalezienie istniejące <see cref="T:System.Net.ServicePoint" /> obiektu lub tworzy nowy <see cref="T:System.Net.ServicePoint" /> obiektów do zarządzania komunikacją dla tego żądania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (Uri address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(class System.Uri address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (address As Uri) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(Uri ^ address);" />
      <MemberSignature Language="F#" Value="static member FindServicePoint : Uri -&gt; System.Net.ServicePoint" Usage="System.Net.ServicePointManager.FindServicePoint address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="address">
          <see cref="T:System.Uri" /> Obiektu z zasobem internetowym nawiązać połączenie.</param>
        <summary>Umożliwia znalezienie istniejące <see cref="T:System.Net.ServicePoint" /> obiektu lub tworzy nowy <see cref="T:System.Net.ServicePoint" /> obiekt do zarządzania komunikacją z określonym <see cref="T:System.Uri" /> obiektu.</summary>
        <returns>
          <see cref="T:System.Net.ServicePoint" /> Obiektu, który zarządza komunikacją żądanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager.FindServicePoint%2A> Metoda zwraca <xref:System.Net.ServicePoint> obiekt skojarzony z określonej nazwy hosta w Internecie. Jeśli nie <xref:System.Net.ServicePoint> dla tego hosta istnieje obiekt <xref:System.Net.ServicePointManager> obiekt tworzony jest jeden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Maksymalna liczba <see cref="T:System.Net.ServicePoint" /> obiekty zdefiniowane w <see cref="P:System.Net.ServicePointManager.MaxServicePoints" /> został osiągnięty.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (string uriString, System.Net.IWebProxy proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(string uriString, class System.Net.IWebProxy proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.String,System.Net.IWebProxy)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (uriString As String, proxy As IWebProxy) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(System::String ^ uriString, System::Net::IWebProxy ^ proxy);" />
      <MemberSignature Language="F#" Value="static member FindServicePoint : string * System.Net.IWebProxy -&gt; System.Net.ServicePoint" Usage="System.Net.ServicePointManager.FindServicePoint (uriString, proxy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="proxy" Type="System.Net.IWebProxy" />
      </Parameters>
      <Docs>
        <param name="uriString">Identyfikator URI zasobu internetowego, należy kontaktować się.</param>
        <param name="proxy">Dane serwera proxy dla tego żądania.</param>
        <summary>Umożliwia znalezienie istniejące <see cref="T:System.Net.ServicePoint" /> obiektu lub tworzy nowy <see cref="T:System.Net.ServicePoint" /> obiekt do zarządzania komunikacją z określonego identyfikatora URI (Uniform Resource).</summary>
        <returns>
          <see cref="T:System.Net.ServicePoint" /> Obiektu, który zarządza komunikacją żądanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager.FindServicePoint%2A> Metoda zwraca <xref:System.Net.ServicePoint> obiekt skojarzony z określonej nazwy hosta w Internecie. Jeśli nie <xref:System.Net.ServicePoint> dla tego hosta istnieje obiekt <xref:System.Net.ServicePointManager> obiekt tworzony jest jeden.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje wywołanie tej metody, aby uzyskać dostęp do <xref:System.Net.ServicePoint> obiektu.  
  
 [!code-cpp[System.Net.ServicePoint#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#7)]
 [!code-csharp[System.Net.ServicePoint#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#7)]
 [!code-vb[System.Net.ServicePoint#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">Identyfikator URI określonego w <paramref name="uriString" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Maksymalna liczba <see cref="T:System.Net.ServicePoint" /> obiekty zdefiniowane w <see cref="P:System.Net.ServicePointManager.MaxServicePoints" /> został osiągnięty.</exception>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (Uri address, System.Net.IWebProxy proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(class System.Uri address, class System.Net.IWebProxy proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.Uri,System.Net.IWebProxy)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (address As Uri, proxy As IWebProxy) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(Uri ^ address, System::Net::IWebProxy ^ proxy);" />
      <MemberSignature Language="F#" Value="static member FindServicePoint : Uri * System.Net.IWebProxy -&gt; System.Net.ServicePoint" Usage="System.Net.ServicePointManager.FindServicePoint (address, proxy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Uri" />
        <Parameter Name="proxy" Type="System.Net.IWebProxy" />
      </Parameters>
      <Docs>
        <param name="address">A <see cref="T:System.Uri" /> obiekt, który zawiera adres zasobu internetowego nawiązać połączenie.</param>
        <param name="proxy">Dane serwera proxy dla tego żądania.</param>
        <summary>Umożliwia znalezienie istniejące <see cref="T:System.Net.ServicePoint" /> obiektu lub tworzy nowy <see cref="T:System.Net.ServicePoint" /> obiekt do zarządzania komunikacją z określonym <see cref="T:System.Uri" /> obiektu.</summary>
        <returns>
          <see cref="T:System.Net.ServicePoint" /> Obiektu, który zarządza komunikacją żądanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager.FindServicePoint%2A> Metoda zwraca <xref:System.Net.ServicePoint> obiekt skojarzony z określonej nazwy hosta w Internecie. Jeśli nie <xref:System.Net.ServicePoint> dla tego hosta istnieje obiekt <xref:System.Net.ServicePointManager> obiekt tworzony jest jeden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Maksymalna liczba <see cref="T:System.Net.ServicePoint" /> obiekty zdefiniowane w <see cref="P:System.Net.ServicePointManager.MaxServicePoints" /> został osiągnięty.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="MaxServicePointIdleTime">
      <MemberSignature Language="C#" Value="public static int MaxServicePointIdleTime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxServicePointIdleTime" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.MaxServicePointIdleTime" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MaxServicePointIdleTime As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxServicePointIdleTime { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxServicePointIdleTime : int with get, set" Usage="System.Net.ServicePointManager.MaxServicePointIdleTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalny czas bezczynności <see cref="T:System.Net.ServicePoint" /> obiektu.</summary>
        <value>Maksymalny czas bezczynności (w milisekundach), z <see cref="T:System.Net.ServicePoint" /> obiektu. Wartość domyślna to 100 000 milisekund (100 sekund).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager.MaxServicePointIdleTime%2A> Właściwość ustawia maksymalny czas bezczynności <xref:System.Net.ServicePointManager> przypisuje obiekt <xref:System.Net.ServicePoint.MaxIdleTime%2A> właściwości podczas tworzenia <xref:System.Net.ServicePoint> obiektów. Zmiany w tej wartości dotyczą tylko <xref:System.Net.ServicePoint> obiektów, które są inicjowane po zmianie wartości.  
  
 Po <xref:System.Net.ServicePoint> obiektu była bezczynna przez czas określony w <xref:System.Net.ServicePoint.MaxIdleTime%2A>, jest uprawniony do wyrzucania elementów bezużytecznych. A <xref:System.Net.ServicePoint> obiektu jest bezczynny, jeśli lista połączeń skojarzonych z <xref:System.Net.ServicePoint> obiekt jest pusty.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia tę właściwość.  
  
 [!code-cpp[System.Net.ServicePoint#8](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#8)]
 [!code-csharp[System.Net.ServicePoint#8](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#8)]
 [!code-vb[System.Net.ServicePoint#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Net.ServicePointManager.MaxServicePointIdleTime" /> jest mniejsza niż <see cref="F:System.Threading.Timeout.Infinite" /> lub większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Net.WebPermission">dla nieograniczonych uprawnień w sieci Web. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="MaxServicePoints">
      <MemberSignature Language="C#" Value="public static int MaxServicePoints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxServicePoints" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.MaxServicePoints" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MaxServicePoints As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxServicePoints { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxServicePoints : int with get, set" Usage="System.Net.ServicePointManager.MaxServicePoints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną liczbę <see cref="T:System.Net.ServicePoint" /> obiektów, aby zachować w dowolnym momencie.</summary>
        <value>Maksymalna liczba <see cref="T:System.Net.ServicePoint" /> obiektów w celu zachowania. Wartość domyślna to 0, co oznacza, że nie ma żadnego limitu liczby <see cref="T:System.Net.ServicePoint" /> obiektów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zmniejszyć <xref:System.Net.ServicePointManager.MaxServicePoints%2A> właściwość mniejszej niż liczba <xref:System.Net.ServicePoint> obiektów obecnie w przypadku istnienia, <xref:System.Net.ServicePointManager> usuwa <xref:System.Net.ServicePoint> obiektów w czasie bezczynności najdłużej. Jeśli liczba <xref:System.Net.ServicePoint> obiektów aktywnych połączeń jest większa niż wartość <xref:System.Net.ServicePointManager.MaxServicePoints%2A>, <xref:System.Net.ServicePointManager> obiektu usuwa <xref:System.Net.ServicePoint> obiektów ile przejdzie w stan bezczynności.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia tę właściwość.  
  
 [!code-cpp[System.Net.ServicePoint#8](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#8)]
 [!code-csharp[System.Net.ServicePoint#8](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#8)]
 [!code-vb[System.Net.ServicePoint#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Net.ServicePointManager.MaxServicePoints" /> jest mniejsza niż 0 lub większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Net.WebPermission">dla nieograniczonych uprawnień w sieci Web. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="ReusePort">
      <MemberSignature Language="C#" Value="public static bool ReusePort { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool ReusePort" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ReusePort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ReusePort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool ReusePort { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReusePort : bool with get, set" Usage="System.Net.ServicePointManager.ReusePort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ustawienie wartości właściwości <see langword="true" /> powoduje, że wszystkie wychodzące połączenia TCP z HttpWebRequest na korzystanie z opcji natywnych gniazda SO_REUSE_UNICASTPORT gniazda. Powoduje to podstawowy porty wychodzące do udostępnienia. Jest to przydatne w scenariuszach, gdzie dużą liczbę wychodzących połączeń są dokonywane w przez krótki czas i ryzyko aplikacji, kończy wolne porty.</summary>
        <value>Zwraca <see cref="T:System.Boolean" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość domyślna to `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SecurityProtocol">
      <MemberSignature Language="C#" Value="public static System.Net.SecurityProtocolType SecurityProtocol { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Net.SecurityProtocolType SecurityProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.SecurityProtocol" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SecurityProtocol As SecurityProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::SecurityProtocolType SecurityProtocol { System::Net::SecurityProtocolType get(); void set(System::Net::SecurityProtocolType value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityProtocol : System.Net.SecurityProtocolType with get, set" Usage="System.Net.ServicePointManager.SecurityProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.SecurityProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia protokół zabezpieczeń, używane przez <see cref="T:System.Net.ServicePoint" /> obiektów zarządzanych przez <see cref="T:System.Net.ServicePointManager" /> obiektu.</summary>
        <value>Jedna z wartości zdefiniowanych w <see cref="T:System.Net.SecurityProtocolType" /> wyliczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Ta właściwość wybiera wersję protokołu Secure Sockets Layer (SSL) lub zabezpieczeń TLS (Transport Layer) do użycia na nowe połączenia; istniejące połączenia nie ulegają zmianie.  
  
Począwszy od programu .NET Framework 4.7, wartość domyślna tej właściwości to <xref:System.Net.SecurityProtocolType.SystemDefault?displayProperty=nameWithType>. Dzięki temu .NET Framework, interfejsów API opartych na sieci <xref:System.Net.Security.SslStream> (na przykład FTP, HTTP i SMTP) dziedziczyć domyślnych protokołów zabezpieczeń, z systemu operacyjnego lub wszystkie konfiguracje niestandardowe, wykonywane przez administratora systemu. Aby uzyskać informacje dotyczące certyfikatu SSL/TLS, które protokoły są włączone domyślnie w każdej wersji systemu operacyjnego Windows, zobacz [protokołów TLS/SSL (dostawca SSP Schannel)](https://msdn.microsoft.com/library/windows/desktop/mt808159.aspx).
 
Dla wersji programu .NET Framework za pomocą programu .NET Framework 4.6.2 ma wartości domyślnej znajduje się w tej właściwości. Orientacja pozioma zabezpieczeń zmienia się stale i domyślne protokołów i poziomów ochrony zostaną zmienione wraz z upływem czasu, aby uniknąć znanych luk. Wartości domyślne różnią się w zależności od konfiguracji poszczególnych maszyn, zainstalowanego oprogramowania i zastosowane poprawki.  
  
 Kod nigdy niejawnie powinna zależeć na temat korzystania z poziomu określonego ochrony lub przy założeniu, że poziom zabezpieczeń jest używany domyślnie. Jeśli aplikacja jest zależna od użytkowania poziom zabezpieczeń, należy jawnie określić tego poziomu, a następnie sprawdź upewnij się, że faktycznie jest używany w ustanowionego połączenia. Ponadto kod powinny zostać tak zaprojektowane jako niezawodne w przypadku zmiany, do których obsługiwane są protokoły, jako takie zmiany często wprowadzone przy użyciu nieco wcześniejszego powiadomienia w celu złagodzenia pojawiających się zagrożeń.  
  
 .NET Framework 4.6 zawiera nową funkcję zabezpieczeń, która blokuje szyfrowania niezabezpieczone i algorytmy dla połączeń wyznaczania wartości skrótu. Aplikacje za pomocą protokołów TLS/SSL za pośrednictwem interfejsów API, takich jak HttpClient HttpWebRequest, FTPClient, SmtpClient, SslStream, itp. i przeznaczonych dla platformy .NET Framework 4.6 uzyskać bardziej bezpieczne zachowanie domyślne.  
  
 Deweloperzy mogą chcą zrezygnować z tego zachowania, aby zapewnić współdziałanie z ich istniejących SSL3 usług lub TLS z usług RC4. [W tym artykule](https://support.microsoft.com/kb/3069494) wyjaśnia, jak zmodyfikować kod, tak, aby nowe zachowanie jest wyłączona.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wartość określona do ustawienia właściwości nie jest prawidłową <see cref="T:System.Net.SecurityProtocolType" /> wartość wyliczenia.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.SecurityProtocolType" />
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public static System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.ServicePointManager.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wywołanie zwrotne w celu weryfikacji certyfikatu serwera.</summary>
        <value>A <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" />. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Aplikacja możne ustawić <xref:System.Net.ServicePointManager.ServerCertificateValidationCallback%2A> właściwości na metodę niestandardowego sprawdzania poprawności przez klienta certyfikatu serwera. Podczas wykonywania niestandardowego sprawdzania poprawności, `sender` parametr przekazany do <xref:System.Net.Security.RemoteCertificateValidationCallback> może być nazwą hosta ciąg lub obiekt pochodzi od <xref:System.Net.WebRequest> (<xref:System.Net.HttpWebRequest>, na przykład) w zależności od <xref:System.Net.ServicePointManager.CertificatePolicy%2A> właściwości.  
  
Jeśli niestandardowego sprawdzania poprawności nie jest używany, nazwa certyfikatu jest porównywana z nazwą hosta używany do utworzenia żądania. Na przykład jeśli <xref:System.Net.WebRequest.Create%28System.String%29> został przekazany parametr "https://www.contoso.com/default.html", domyślnym zachowaniem jest klient sprawdzał certyfikatu www.contoso.com.  

Mimo iż delegatów multiemisji, tylko wartości zwrócone przez program obsługi zdarzeń ostatnio wykonana jest uważana za. Innymi słowy, można dołączyć wiele obiektów delegowanych, a wszystkie staną się wywołanie zwrotne z <xref:System.Net.ServicePointManager.ServerCertificateValidationCallback%2A>. Każdego wywołania zwrotnego zwraca wartość wskazującą, czy certyfikat jest akceptowany, czy nie; jednak tylko wartość z ostatniej delegata jest zachowana.
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby ustawić <see cref="P:System.Net.ServicePointManager.ServerCertificateValidationCallback" /> właściwości. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="ServerCipherSuitesCallback">
      <MemberSignature Language="C#" Value="public static System.Net.CipherSuitesCallback ServerCipherSuitesCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.CipherSuitesCallback ServerCipherSuitesCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ServerCipherSuitesCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ServerCipherSuitesCallback As CipherSuitesCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::CipherSuitesCallback ^ ServerCipherSuitesCallback { System::Net::CipherSuitesCallback ^ get(); void set(System::Net::CipherSuitesCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCipherSuitesCallback : System.Net.CipherSuitesCallback with get, set" Usage="System.Net.ServicePointManager.ServerCipherSuitesCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Obsolete("This API is no longer supported.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CipherSuitesCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTcpKeepAlive">
      <MemberSignature Language="C#" Value="public static void SetTcpKeepAlive (bool enabled, int keepAliveTime, int keepAliveInterval);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTcpKeepAlive(bool enabled, int32 keepAliveTime, int32 keepAliveInterval) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.SetTcpKeepAlive(System.Boolean,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTcpKeepAlive (enabled As Boolean, keepAliveTime As Integer, keepAliveInterval As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTcpKeepAlive(bool enabled, int keepAliveTime, int keepAliveInterval);" />
      <MemberSignature Language="F#" Value="static member SetTcpKeepAlive : bool * int * int -&gt; unit" Usage="System.Net.ServicePointManager.SetTcpKeepAlive (enabled, keepAliveTime, keepAliveInterval)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enabled" Type="System.Boolean" />
        <Parameter Name="keepAliveTime" Type="System.Int32" />
        <Parameter Name="keepAliveInterval" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="enabled">Jeśli ustawiono wartość true, następnie keep-alive opcję TCP za pośrednictwem połączenia TCP zostaną włączone przy użyciu określonego <c>keepAliveTime</c> i <c>keepAliveInterval</c> wartości.  
  
Jeśli ma wartość false, następnie TCP keep-alive opcja jest wyłączona, a pozostałe parametry są ignorowane.  
  
Wartość domyślna to false.</param>
        <param name="keepAliveTime">Określa limit czasu w milisekundach, bez żadnych działań do momentu wysłania jest pierwszy pakiet keep-alive.  
  
Wartość musi być większa niż 0.  Jeśli zostanie przekazana wartość mniejszą niż lub równe zero <see cref="T:System.ArgumentOutOfRangeException" /> zgłaszany.</param>
        <param name="keepAliveInterval">Określa interwał w milisekundach między kolejnymi keep-alive pakiety są wysyłane, jeśli potwierdzenie nie zostanie odebrana.  
  
Wartość musi być większa niż 0.  Jeśli zostanie przekazana wartość mniejszą niż lub równe zero <see cref="T:System.ArgumentOutOfRangeException" /> zgłaszany.</param>
        <summary>Włącza lub wyłącza opcję podtrzymania połączenia TCP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja może zażądać dostawcy TCP/IP korzystanie z pakietów podtrzymania połączenia TCP. Wartość domyślna to wyłączenia użytkowania pakiety utrzymywania aktywności połączenia TCP.  
  
 Ustawienia domyślne, gdy gniazda TCP jest zainicjowany keep-alive ustawia limit czasu, do 2 godzin i keep-alive interwał na 1 sekundę. `keepAliveTime` Parametr określa limit czasu w milisekundach, bez żadnych działań do momentu wysłania jest pierwszy pakiet keep-alive. `keepAliveInterval` Parametr określa interwał w milisekundach między podczas kolejnych keep-alive pakiety są wysyłane, jeśli potwierdzenie nie zostanie odebrana. Liczba keep-alive sondy nie można zmienić i jest ustawiony na 10.  
  
 Jeśli połączenie TCP zostało przerwane w wyniku utrzymywania aktywności <xref:System.Net.Sockets.SocketError> z <xref:System.Net.Sockets.SocketError.NetworkReset> jest zwracany w żadnym wywołaniom w toku dla gniazda, a kolejnych wywołań zakończy się niepowodzeniem z <xref:System.Net.Sockets.SocketError> z <xref:System.Net.Sockets.SocketError.NotConnected>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość określona dla <paramref name="keepAliveTime" /> lub <paramref name="keepAliveInterval" /> parametr jest mniejsze niż lub równe 0.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="UseNagleAlgorithm">
      <MemberSignature Language="C#" Value="public static bool UseNagleAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseNagleAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.UseNagleAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseNagleAlgorithm As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseNagleAlgorithm { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseNagleAlgorithm : bool with get, set" Usage="System.Net.ServicePointManager.UseNagleAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy punkty usługi zarządzane przez ten jest używany algorytm Nagle'a <see cref="T:System.Net.ServicePointManager" /> obiektu.</summary>
        <value>
          <see langword="true" /> Aby używać algorytmu Nagle'a; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zmniejszyć ruch sieciowy przez buforowanie małe pakiety danych i przekazywania ich jako pojedynczy pakiet jest używany algorytm Nagle'a. Ten proces jest również określany jako "nagling"; ona jest powszechnie używana, ponieważ zmniejsza liczbę pakietów wysłanych i zmniejsza narzut na pakiet.  
  
 Zmiana wartości tej właściwości nie ma wpływu na istniejące <xref:System.Net.ServicePoint> obiektów. Dotyczy tylko nowych punktów usługi utworzone po zmianie.  
  
 Algorytm Nagle'a opisano szczegółowo w IETF RFC 896.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia tę właściwość.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
  </Members>
</Type>
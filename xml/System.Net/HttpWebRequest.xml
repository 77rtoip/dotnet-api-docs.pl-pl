<Type Name="HttpWebRequest" FullName="System.Net.HttpWebRequest">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5bbe9cc269ae6e48b62f5f9d27cac715c2e1ff8b" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69090934" /></Metadata><TypeSignature Language="C#" Value="public class HttpWebRequest : System.Net.WebRequest, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable HttpWebRequest extends System.Net.WebRequest implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpWebRequest" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpWebRequest&#xA;Inherits WebRequest&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpWebRequest : System::Net::WebRequest, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type HttpWebRequest = class&#xA;    inherit WebRequest&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.WebRequest</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.CompilerServices.FriendAccessAllowed</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zapewnia implementację <see cref="T:System.Net.WebRequest" /> specyficzną dla protokołu HTTP.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
>  Nie zalecamy korzystania `HttpWebRequest` z nowych rozwiązań programistycznych. Zamiast tego należy użyć <xref:System.Net.Http.HttpClient?displayProperty=nameWithType> klasy.

 Klasa zapewnia obsługę właściwości i metod zdefiniowanych w programie <xref:System.Net.WebRequest> oraz dla dodatkowych właściwości i metod, które umożliwiają użytkownikowi bezpośrednią pracę z serwerami przy użyciu protokołu HTTP. <xref:System.Net.HttpWebRequest>  
  
 Nie używaj <xref:System.Net.HttpWebRequest.%23ctor%2A> konstruktora. Użyj metody <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType> , aby zainicjować nowe <xref:System.Net.HttpWebRequest> obiekty. Jeśli schemat dla Uniform Resource Identifier (URI) `http://` to lub `https://`, <xref:System.Net.WebRequest.Create%2A> zwraca <xref:System.Net.HttpWebRequest> obiekt.  
  
 Metoda wysyła synchroniczne żądanie do zasobu określonego <xref:System.Net.HttpWebRequest.RequestUri%2A> we właściwości i zwraca element <xref:System.Net.HttpWebResponse> zawierający obiekt Response. <xref:System.Net.HttpWebRequest.GetResponse%2A> Dane odpowiedzi można odbierać przy użyciu strumienia zwróconego przez <xref:System.Net.HttpWebResponse.GetResponseStream%2A>. Jeśli obiekt odpowiedzi lub strumień odpowiedzi zostanie zamknięty, pozostałe dane zostaną utracone. Pozostałe dane zostaną opróżnione, a gniazdo zostanie ponownie użyte do kolejnych żądań podczas zamykania obiektu odpowiedzi lub strumienia w przypadku podania następujących warunków: jest to żądanie Keep-Alive lub potokowe, tylko niewielka ilość danych musi zostać odebrana lub Pozostałe dane są odbierane w niewielkim przedziale czasu. Jeśli żaden z wymienionych warunków nie jest wstrzymany lub czas opróżniania zostanie przekroczony, gniazdo zostanie zamknięte. W przypadku połączeń Keep-Alive i potokowe zdecydowanie zalecamy, aby aplikacja odczytuje strumienie do momentu zakończenia. Gwarantuje to, że gniazdo będzie ponownie używane na potrzeby kolejnych żądań, co zwiększa wydajność i mniej używane zasoby.  
  
 Gdy chcesz wysłać dane do zasobu, <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Metoda <xref:System.IO.Stream> zwraca obiekt, który zostanie użyty do wysłania danych. Metody <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> i<xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> zapewniają asynchroniczny dostęp do strumienia przesyłania danych.  
  
 W przypadku uwierzytelniania klienta <xref:System.Net.HttpWebRequest>w programie należy zainstalować certyfikat klienta w magazynie certyfikatów bieżącego użytkownika.  
  
 <xref:System.Net.HttpWebRequest> Klasa<xref:System.Net.WebException> zgłasza wystąpienie błędów podczas uzyskiwania dostępu do zasobu. <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> Właściwość<xref:System.Net.WebExceptionStatus> zawiera wartość, która wskazuje Źródło błędu. Gdy <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> ma <xref:System.Net.WebExceptionStatus.ProtocolError?displayProperty=nameWithType>wartość ,<xref:System.Net.WebException.Response%2A>Właściwość zawiera odebranezzasobu.<xref:System.Net.HttpWebResponse>  
  
 <xref:System.Net.HttpWebRequest>uwidacznia wspólne wartości nagłówka HTTP wysyłane do zasobu internetowego jako właściwości, ustawiane przez metody lub ustawiane przez system; Poniższa tabela zawiera pełną listę. Można ustawić inne nagłówki we <xref:System.Net.HttpWebRequest.Headers%2A> właściwości jako pary nazwa/wartość. Należy zauważyć, że serwery i pamięci podręczne mogą zmieniać lub dodawać nagłówki podczas żądania.  
  
 W poniższej tabeli wymieniono nagłówki HTTP, które są ustawiane przez właściwości lub metody lub system.  
  
|nagłówek|Ustawione przez|  
|------------|------------|  
|Odebrać|Ustawiony przez <xref:System.Net.HttpWebRequest.Accept%2A> właściwość.|  
|Połączenie|<xref:System.Net.HttpWebRequest.Connection%2A> Ustaw<xref:System.Net.HttpWebRequest.KeepAlive%2A> Właściwość właściwości.|  
|Długość zawartości|Ustawiony przez <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwość.|  
|Typ zawartości|Ustawiony przez <xref:System.Net.HttpWebRequest.ContentType%2A> właściwość.|  
|Puszczać|Ustawiony przez <xref:System.Net.HttpWebRequest.Expect%2A> właściwość.|  
|Data|Ustawiony przez system na bieżącą datę.|  
|Host|Ustawiane przez system na bieżące informacje o hoście.|  
|If-Modified-Since|Ustawiony przez <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> właściwość.|  
|Zakres|Ustawiane przez <xref:System.Net.HttpWebRequest.AddRange%2A> metodę.|  
|Referer|Ustawiony przez <xref:System.Net.HttpWebRequest.Referer%2A> właściwość.|  
|Transfer-Encoding|Ustawiony przez <xref:System.Net.HttpWebRequest.TransferEncoding%2A> Właściwość <xref:System.Net.HttpWebRequest.SendChunked%2A> (właściwość musi być `true`).|  
|User-Agent|Ustawiony przez <xref:System.Net.HttpWebRequest.UserAgent%2A> właściwość.|  
  
> [!NOTE]
>  <xref:System.Net.HttpWebRequest>jest automatycznie rejestrowany. Nie trzeba wywoływać <xref:System.Net.WebRequest.RegisterPrefix%2A> metody, aby zarejestrować <xref:System.Net.HttpWebRequest?displayProperty=nameWithType> się przed użyciem identyfikatorów URI zaczynających się `https://`od `http://` lub.  
  
 Plik konfiguracji komputera lokalnego lub aplikacji może określać, że zostanie użyty domyślny serwer proxy. Jeśli właściwość jest określona, ustawienia serwera proxy <xref:System.Net.HttpWebRequest.Proxy%2A> z właściwości przesłaniają plik konfiguracji komputera lokalnego lub <xref:System.Net.HttpWebRequest> aplikacji, a wystąpienie będzie używać określonych ustawień serwera proxy. <xref:System.Net.HttpWebRequest.Proxy%2A> Jeśli w pliku konfiguracji nie określono żadnego serwera proxy <xref:System.Net.HttpWebRequest.Proxy%2A> <xref:System.Net.HttpWebRequest> , a właściwość nie zostanie określona, Klasa używa ustawień serwera proxy dziedziczonych z programu Internet Explorer na komputerze lokalnym. Jeśli nie ma żadnych ustawień serwera proxy w programie Internet Explorer, żądanie jest wysyłane bezpośrednio na serwer.  
  
 <xref:System.Net.HttpWebRequest> Klasa analizuje listę pomijania proxy z symbolami wieloznacznymi dziedziczonymi z programu Internet Explorer inaczej niż Lista pomijania jest analizowana bezpośrednio przez program Internet Explorer. Na przykład <xref:System.Net.HttpWebRequest> Klasa przeanalizuje listę pomijania "NT *" z programu Internet Explorer jako wyrażenie regularne "NT. $". Różni się to od natywnych zachowań programu Internet Explorer. Dlatego adres URL "`http://intxxxxx`" spowoduje ominięcie serwera proxy <xref:System.Net.HttpWebRequest> przy użyciu klasy, ale nie spowoduje obejścia serwera proxy przy użyciu programu Internet Explorer.  
  
> [!NOTE]
>  Struktura buforuje sesje SSL w miarę ich tworzenia i próbuje ponownie użyć buforowanej sesji dla nowego żądania, jeśli jest to możliwe. Przy próbie ponownego użycia sesji SSL w strukturze jest używany pierwszy element <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (jeśli istnieje) lub próba ponownego użycia sesji anonimowych, jeśli <xref:System.Net.HttpWebRequest.ClientCertificates%2A> jest ona pusta.  
  
> [!NOTE]
>  Ze względów bezpieczeństwa pliki cookie są domyślnie wyłączone. Jeśli chcesz używać plików cookie, użyj <xref:System.Net.HttpWebRequest.CookieContainer%2A> właściwości, aby włączyć pliki cookie.  
  
 .NET Framework 4,6 obejmuje nową funkcję zabezpieczeń, która blokuje niebezpieczne algorytmy szyfrowania i wyznaczania wartości skrótu dla połączeń. Aplikacje korzystające z protokołu TLS/SSL za pośrednictwem interfejsów API, takich jak HttpClient, HttpWebRequest, FTPClient, SmtpClient, SslStream itp. i przeznaczonych dla .NET Framework 4,6, domyślnie uzyskają bezpieczniejsze zachowanie.  
  
 Deweloperzy mogą chcieć zrezygnować z tego zachowania, aby zachować współdziałanie z istniejącymi usługami SSL3 Services lub TLS/RC4. W [tym artykule](https://support.microsoft.com/kb/3069494) wyjaśniono, jak zmodyfikować kod w taki sposób, aby nowe zachowanie zostało wyłączone.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Net.HttpWebRequest> dla identyfikatora URI. `http://www.contoso.com/`  
  
 [!code-cpp[Classic HttpWebRequest Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.WebPermission">Aby uzyskać dostęp do żądanego identyfikatora URI lub dowolnego identyfikatora URI, do którego jest przekierowywane żądanie. Skojarzone Wyliczenie:<see cref="F:System.Net.NetworkAccess.Connect" /></permission>
    <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy, element (Ustawienia sieci)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/8bf0b428-5a21-4299-8d6e-bf8251fd978a">Zmiany w uwierzytelnianiu NTLM dla HTTPWebRequest w wersji 3,5 SP1</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.HttpWebRequest" /> klasy. Te konstruktory są przestarzałe; Zobacz sekcję Uwagi, aby uzyskać szczegółowe informacje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Oba <xref:System.Net.HttpWebRequest> konstruktory są przestarzałe i nie powinny być używane. Wywołaj <xref:System.Net.WebRequest.CreateHttp%2A?displayProperty=nameWithType> metodę, aby zainicjować <xref:System.Net.HttpWebRequest> nowe obiekty.     
  
      ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.HttpWebRequest" /> klasy. Ten konstruktor jest przestarzały.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : Uri -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest uri" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      </Parameters>
      <Docs>
        <param name="uri">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HttpWebRequest (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HttpWebRequest(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Obiekt, który zawiera informacje wymagane do serializacji nowego <see cref="T:System.Net.HttpWebRequest" /> obiektu. <see cref="T:System.Runtime.Serialization.SerializationInfo" /></param>
        <param name="streamingContext">Obiekt, który zawiera źródło i miejsce docelowe serializowanego strumienia skojarzonego z nowym <see cref="T:System.Net.HttpWebRequest" /> obiektem. <see cref="T:System.Runtime.Serialization.StreamingContext" /></param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Net.HttpWebRequest" /> klasy z określonych wystąpień <see cref="T:System.Runtime.Serialization.SerializationInfo" /> klas i <see cref="T:System.Runtime.Serialization.StreamingContext" /> . Ten konstruktor jest przestarzały.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku korzystania z serializacji aplikacja musi działać w trybie pełnego zaufania.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">w przypadku nieograniczonego dostępu do zasobów sieciowych. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">Serializacja XML i SOAP</related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public override void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Abort();" />
      <MemberSignature Language="F#" Value="override this.Abort : unit -&gt; unit" Usage="httpWebRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anuluje żądanie do zasobu internetowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Abort%2A> Metoda anuluje żądanie do zasobu. Po anulowaniu żądania wywołanie <xref:System.Net.HttpWebRequest.GetResponse%2A>metody, <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> <xref:System.Net.WebExceptionStatus.RequestCanceled>, <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> <xref:System.Net.HttpWebRequest.EndGetResponse%2A> <xref:System.Net.HttpWebRequest.GetRequestStream%2A> <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>,, lub wywołuje<xref:System.Net.WebException> metodę z<xref:System.Net.WebException.Status%2A> właściwością ustawioną na.  
  
 Metoda będzie synchronicznie wykonywała wywołanie zwrotne określone <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> dla lub <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metody, jeśli <xref:System.Net.HttpWebRequest.Abort%2A> Metoda jest wywoływana, podczas gdy każda z tych operacji jest zaległa. <xref:System.Net.HttpWebRequest.Abort%2A> Może to prowadzić do potencjalnych problemów zakleszczenia.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci](https://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 W przypadku żądań asynchronicznych jest odpowiedzialna aplikacja kliencka do wdrożenia własnego mechanizmu przekroczenia limitu czasu. Poniższy przykład kodu pokazuje, jak to zrobić.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public string Accept { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Accept" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Property Accept As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Accept { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Accept : string with get, set" Usage="System.Net.HttpWebRequest.Accept" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see langword="Accept" /> nagłówka HTTP.</summary>
        <value>Wartość <see langword="Accept" /> nagłówka HTTP. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby wyczyścić `Accept` nagłówek HTTP, <xref:System.Net.HttpWebRequest.Accept%2A> ustaw właściwość na `null`.  
  
> [!NOTE]
>  Wartość tej właściwości jest przechowywana w <xref:System.Net.WebHeaderCollection>. Jeśli jest ustawiona właściwość WebHeaderCollection, wartość właściwości zostanie utracona.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia <xref:System.Net.HttpWebRequest.Accept%2A> właściwość.  
  
 [!code-cpp[HttpWebRequest_Accept#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Accept/CPP/httpwebrequest_accept.cpp#1)]
 [!code-csharp[HttpWebRequest_Accept#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Accept/CS/httpwebrequest_accept.cs#1)]
 [!code-vb[HttpWebRequest_Accept#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Accept/VB/httpwebrequest_accept.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRange">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje nagłówek zakresu do żądania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ wszystkie jednostki HTTP są reprezentowane w komunikatach HTTP jako sekwencje bajtów, koncepcja zakresu bajtów jest istotna dla dowolnej jednostki HTTP. Nie wszyscy klienci i serwery muszą jednak obsługiwać operacje z zakresu bajtów.  
  
 Nagłówek Range w żądaniu umożliwia klientowi zażądanie, że tylko część określonego zakresu bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądań nagłówka zakresu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="range">Punkt początkowy lub końcowy zakresu.</param>
        <summary>Dodaje nagłówek zakresu bajtów do żądania dla określonego zakresu od początku lub na końcu żądanych danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Metoda dodaje nagłówek zakresu bajtów do żądania.  
  
 Jeśli `range` jest dodatnia `range` , parametr określa punkt początkowy zakresu. Serwer powinien rozpocząć wysyłanie danych z `range` parametru określonego na końcu danych w jednostce http.  
  
 Jeśli `range` jest ujemna `range` , parametr określa punkt końcowy zakresu. Serwer powinien rozpocząć wysyłanie danych od początku danych w jednostce HTTP do `range` określonego parametru.  
  
 Ponieważ wszystkie jednostki HTTP są reprezentowane w komunikatach HTTP jako sekwencje bajtów, koncepcja zakresu bajtów jest istotna dla dowolnej jednostki HTTP. Nie wszyscy klienci i serwery muszą jednak obsługiwać operacje z zakresu bajtów.  
  
 Nagłówek Range w żądaniu umożliwia klientowi zażądanie, że tylko część określonego zakresu bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądań nagłówka zakresu.  
  
 Przykład nagłówka zakresu w żądaniu protokołu HTTP, który żąda serwera wysyła pierwsze 100 bajtów (od początku do bajtowego położenia 99) byłyby następujące:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 W tym przykładzie `range` parametr będzie-99.  
  
 Serwer HTTP wskazuje obsługę nagłówków zakresów przy użyciu nagłówka Accept-Ranges. Przykład nagłówka Accept-Rangs z serwera, który obsługuje zakresy bajtów, zostałby następujący:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Jeśli nagłówek Accept-Ranges nie zostanie odebrany w nagłówku odpowiedzi z serwera, serwer nie obsługuje nagłówków zakresów. Przykład nagłówka Accept-Ranges z serwera, który nie obsługuje zakresów, ale rozpoznaje nagłówka Accept-Ranges:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Podczas otrzymywania odpowiedzi z żądania zakresu tylko nagłówki HTTP skojarzone z całym żądaniem są analizowane i udostępniane za pośrednictwem właściwości <xref:System.Net.HttpWebResponse> klasy. Nagłówki skojarzone z każdym zakresem są zwracane w odpowiedzi.  
  
   
  
## Examples  
 Poniższy przykład kodu dodaje nagłówek zakresu do żądania.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można dodać nagłówka zakresu.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="range">Punkt początkowy lub końcowy zakresu.</param>
        <summary>Dodaje nagłówek zakresu bajtów do żądania dla określonego zakresu od początku lub na końcu żądanych danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Metoda dodaje nagłówek zakresu bajtów do żądania.  
  
 Jeśli `range` jest dodatnia `range` , parametr określa punkt początkowy zakresu. Serwer powinien rozpocząć wysyłanie danych z `range` parametru określonego na końcu danych w jednostce http.  
  
 Jeśli `range` jest ujemna `range` , parametr określa punkt końcowy zakresu. Serwer powinien rozpocząć wysyłanie danych od początku danych w jednostce HTTP do `range` określonego parametru.  
  
 Ponieważ wszystkie jednostki HTTP są reprezentowane w komunikatach HTTP jako sekwencje bajtów, koncepcja zakresu bajtów jest istotna dla dowolnej jednostki HTTP. Nie wszyscy klienci i serwery muszą jednak obsługiwać operacje z zakresu bajtów.  
  
 Nagłówek Range w żądaniu umożliwia klientowi zażądanie, że tylko część określonego zakresu bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądań nagłówka zakresu.  
  
 Przykład nagłówka zakresu w żądaniu protokołu HTTP, który żąda serwera wysyła pierwsze 100 bajtów (od początku do bajtowego położenia 99) byłyby następujące:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 W tym przykładzie `range` parametr będzie-99.  
  
 Serwer HTTP wskazuje obsługę nagłówków zakresów przy użyciu nagłówka Accept-Ranges. Przykład nagłówka Accept-Rangs z serwera, który obsługuje zakresy bajtów, zostałby następujący:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Jeśli nagłówek Accept-Ranges nie zostanie odebrany w nagłówku odpowiedzi z serwera, serwer nie obsługuje nagłówków zakresów. Przykład nagłówka Accept-Ranges z serwera, który nie obsługuje zakresów, ale rozpoznaje nagłówka Accept-Ranges:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Podczas otrzymywania odpowiedzi z żądania zakresu tylko nagłówki HTTP skojarzone z całym żądaniem są analizowane i udostępniane za pośrednictwem właściwości <xref:System.Net.HttpWebResponse> klasy. Nagłówki skojarzone z każdym zakresem są zwracane w odpowiedzi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można dodać nagłówka zakresu.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int * int -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="to" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="from">Pozycja, w której ma zostać rozpoczęte wysyłanie danych.</param>
        <param name="to">Pozycja, w której ma zostać zatrzymane wysyłanie danych.</param>
        <summary>Dodaje nagłówek zakresu bajtów do żądania dla określonego zakresu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Metoda dodaje nagłówek zakresu bajtów do żądania.  
  
 Ponieważ wszystkie jednostki HTTP są reprezentowane w komunikatach HTTP jako sekwencje bajtów, koncepcja zakresu bajtów jest istotna dla dowolnej jednostki HTTP. Nie wszyscy klienci i serwery muszą jednak obsługiwać operacje z zakresu bajtów.  
  
 Nagłówek Range w żądaniu umożliwia klientowi zażądanie, że tylko część określonego zakresu bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądań nagłówka zakresu.  
  
 Przykładem nagłówka zakresu w żądaniu protokołu HTTP, który żąda pierwszych 100 bajtów byłby następujący:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 W tym przykładzie `from` parametr zostałby określony jako 0, `to` a parametr zostałby określony jako 99. Specyfikator zakresu jest automatycznie ustawiany jako "Bytes" w tej metodzie.  
  
 Serwer HTTP wskazuje obsługę nagłówków zakresów przy użyciu nagłówka Accept-Ranges. Przykład nagłówka Accept-Rangs z serwera, który obsługuje zakresy bajtów, zostałby następujący:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Jeśli nagłówek Accept-Ranges nie zostanie odebrany w nagłówku odpowiedzi z serwera, serwer nie obsługuje nagłówków zakresów. Przykład nagłówka Accept-Ranges z serwera, który nie obsługuje zakresów, ale rozpoznaje nagłówka Accept-Ranges:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Podczas otrzymywania odpowiedzi z żądania zakresu tylko nagłówki HTTP skojarzone z całym żądaniem są analizowane i udostępniane za pośrednictwem właściwości <xref:System.Net.HttpWebResponse> klasy. Nagłówki skojarzone z każdym zakresem są zwracane w odpowiedzi.  
  
   
  
## Examples  
 Poniższy przykład kodu dodaje nagłówek zakresu do żądania.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" />jest większe niż<paramref name="to" />  
  
—lub— 
 <paramref name="from" />lub <paramref name="to" /> jest mniejsza od 0.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można dodać nagłówka zakresu.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="to" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="from">Pozycja, w której ma zostać rozpoczęte wysyłanie danych.</param>
        <param name="to">Pozycja, w której ma zostać zatrzymane wysyłanie danych.</param>
        <summary>Dodaje nagłówek zakresu bajtów do żądania dla określonego zakresu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Metoda dodaje nagłówek zakresu bajtów do żądania.  
  
 Ponieważ wszystkie jednostki HTTP są reprezentowane w komunikatach HTTP jako sekwencje bajtów, koncepcja zakresu bajtów jest istotna dla dowolnej jednostki HTTP. Nie wszyscy klienci i serwery muszą jednak obsługiwać operacje z zakresu bajtów.  
  
 Nagłówek Range w żądaniu umożliwia klientowi zażądanie, że tylko część określonego zakresu bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądań nagłówka zakresu.  
  
 Przykładem nagłówka zakresu w żądaniu protokołu HTTP, który żąda pierwszych 100 bajtów byłby następujący:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 W tym przykładzie `from` parametr zostałby określony jako 0, `to` a parametr zostałby określony jako 99. Specyfikator zakresu jest automatycznie ustawiany jako "Bytes" w tej metodzie.  
  
 Serwer HTTP wskazuje obsługę nagłówków zakresów przy użyciu nagłówka Accept-Ranges. Przykład nagłówka Accept-Rangs z serwera, który obsługuje zakresy bajtów, zostałby następujący:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Jeśli nagłówek Accept-Ranges nie zostanie odebrany w nagłówku odpowiedzi z serwera, serwer nie obsługuje nagłówków zakresów. Przykład nagłówka Accept-Ranges z serwera, który nie obsługuje zakresów, ale rozpoznaje nagłówka Accept-Ranges:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Podczas otrzymywania odpowiedzi z żądania zakresu tylko nagłówki HTTP skojarzone z całym żądaniem są analizowane i udostępniane za pośrednictwem właściwości <xref:System.Net.HttpWebResponse> klasy. Nagłówki skojarzone z każdym zakresem są zwracane w odpowiedzi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" />jest większe niż<paramref name="to" />  
  
—lub— 
 <paramref name="from" />lub <paramref name="to" /> jest mniejsza od 0.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można dodać nagłówka zakresu.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="range" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Opis zakresu.</param>
        <param name="range">Punkt początkowy lub końcowy zakresu.</param>
        <summary>Dodaje nagłówek zakresu do żądania dla określonego zakresu od początku lub na końcu żądanych danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Metoda dodaje nagłówek zakresu do żądania.  
  
 Jeśli `range` jest dodatnia `range` , parametr określa punkt początkowy zakresu. Serwer powinien rozpocząć wysyłanie danych z `range` parametru określonego na końcu danych w jednostce http.  
  
 Jeśli `range` jest ujemna `range` , parametr określa punkt końcowy zakresu. Serwer powinien rozpocząć wysyłanie danych od początku danych w jednostce HTTP do `range` określonego parametru.  
  
 Ponieważ wszystkie jednostki HTTP są reprezentowane w komunikatach HTTP jako sekwencje bajtów, koncepcja zakresu bajtów jest istotna dla dowolnej jednostki HTTP. Nie wszyscy klienci i serwery muszą jednak obsługiwać operacje z zakresu bajtów.  
  
 Nagłówek Range w żądaniu umożliwia klientowi zażądanie, że tylko część określonego zakresu bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądań nagłówka zakresu.  
  
 `rangeSpecifier` Parametr jest zwykle określany jako "Bytes", ponieważ jest to jedyna specyfikator zakresu uznawany przez większość serwerów HTTP. `rangeSpecifier` Ustawienie parametru na inny ciąg umożliwia obsługę specyfikatorów zakresu niestandardowego inne niż bajty (specyfikator zakresu bajtów zdefiniowany w dokumencie RFC 2616 przez grupę IETF).  
  
 Przykładem nagłówka zakresu w żądaniu protokołu HTTP, który żąda pierwszych 100 bajtów byłby następujący:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 W tym przykładzie `rangeSpecifier` parametr zostałby określony jako "Bytes", `range` a parametr zostałby 99.  
  
 Serwer HTTP wskazuje obsługę nagłówków zakresów z nagłówkiem Accept-Ranges w odpowiedzi. Przykład nagłówka Accept-Rangs z serwera, który obsługuje zakresy bajtów, zostałby następujący:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Jeśli nagłówek Accept-Ranges nie zostanie odebrany w nagłówku odpowiedzi z serwera, serwer nie obsługuje nagłówków zakresów. Przykład nagłówka Accept-Ranges z serwera, który nie obsługuje zakresów, ale rozpoznaje nagłówka Accept-Ranges:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Podczas otrzymywania odpowiedzi z żądania zakresu tylko nagłówki HTTP skojarzone z całym żądaniem są analizowane i udostępniane za pośrednictwem właściwości <xref:System.Net.HttpWebResponse> klasy. Nagłówki skojarzone z każdym zakresem są zwracane w odpowiedzi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można dodać nagłówka zakresu.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="range" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Opis zakresu.</param>
        <param name="range">Punkt początkowy lub końcowy zakresu.</param>
        <summary>Dodaje nagłówek zakresu do żądania dla określonego zakresu od początku lub na końcu żądanych danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Metoda dodaje nagłówek zakresu do żądania.  
  
 Jeśli `range` jest dodatnia `range` , parametr określa punkt początkowy zakresu. Serwer powinien rozpocząć wysyłanie danych z `range` parametru określonego na końcu danych w jednostce http.  
  
 Jeśli `range` jest ujemna `range` , parametr określa punkt końcowy zakresu. Serwer powinien rozpocząć wysyłanie danych od początku danych w jednostce HTTP do `range` określonego parametru.  
  
 Ponieważ wszystkie jednostki HTTP są reprezentowane w komunikatach HTTP jako sekwencje bajtów, koncepcja zakresu bajtów jest istotna dla dowolnej jednostki HTTP. Nie wszyscy klienci i serwery muszą jednak obsługiwać operacje z zakresu bajtów.  
  
 Nagłówek Range w żądaniu umożliwia klientowi zażądanie, że tylko część określonego zakresu bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądań nagłówka zakresu.  
  
 `rangeSpecifier` Parametr jest zwykle określany jako "Bytes", ponieważ jest to jedyna specyfikator zakresu uznawany przez większość serwerów HTTP. `rangeSpecifier` Ustawienie parametru na inny ciąg umożliwia obsługę specyfikatorów zakresu niestandardowego inne niż bajty (specyfikator zakresu bajtów zdefiniowany w dokumencie RFC 2616 przez grupę IETF).  
  
 Przykładem nagłówka zakresu w żądaniu protokołu HTTP, który żąda pierwszych 100 bajtów byłby następujący:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 W tym przykładzie `rangeSpecifier` parametr zostałby określony jako "Bytes", `range` a parametr zostałby 99.  
  
 Serwer HTTP wskazuje obsługę nagłówków zakresów z nagłówkiem Accept-Ranges w odpowiedzi. Przykład nagłówka Accept-Rangs z serwera, który obsługuje zakresy bajtów, zostałby następujący:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Jeśli nagłówek Accept-Ranges nie zostanie odebrany w nagłówku odpowiedzi z serwera, serwer nie obsługuje nagłówków zakresów. Przykład nagłówka Accept-Ranges z serwera, który nie obsługuje zakresów, ale rozpoznaje nagłówka Accept-Ranges:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Podczas otrzymywania odpowiedzi z żądania zakresu tylko nagłówki HTTP skojarzone z całym żądaniem są analizowane i udostępniane za pośrednictwem właściwości <xref:System.Net.HttpWebResponse> klasy. Nagłówki skojarzone z każdym zakresem są zwracane w odpowiedzi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można dodać nagłówka zakresu.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="from" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="to" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Opis zakresu.</param>
        <param name="from">Pozycja, w której ma zostać rozpoczęte wysyłanie danych.</param>
        <param name="to">Pozycja, w której ma zostać zatrzymane wysyłanie danych.</param>
        <summary>Dodaje nagłówek zakresu do żądania dla określonego zakresu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Metoda dodaje nagłówek zakresu do żądania.  
  
 Ponieważ wszystkie jednostki HTTP są reprezentowane w komunikatach HTTP jako sekwencje bajtów, koncepcja zakresu bajtów jest istotna dla dowolnej jednostki HTTP. Nie wszyscy klienci i serwery muszą jednak obsługiwać operacje z zakresu bajtów.  
  
 Nagłówek Range w żądaniu umożliwia klientowi zażądanie, że tylko część określonego zakresu bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądań nagłówka zakresu.  
  
 `rangeSpecifier` Parametr jest zwykle określany jako "Bytes", ponieważ jest to jedyna specyfikator zakresu uznawany przez większość serwerów HTTP. `rangeSpecifier` Ustawienie parametru na inny ciąg umożliwia obsługę specyfikatorów zakresu niestandardowego inne niż bajty (specyfikator zakresu bajtów zdefiniowany w dokumencie RFC 2616 przez grupę IETF).  
  
 Przykładem nagłówka zakresu w żądaniu protokołu HTTP, który żąda pierwszych 100 bajtów byłby następujący:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 W tym przykładzie `rangeSpecifier` parametr zostałby określony jako "Bytes" `from` , parametr będzie równy 0, a `to` parametr zostałby 99.  
  
 Serwer HTTP wskazuje obsługę nagłówków zakresów z nagłówkiem Accept-Ranges w odpowiedzi. Przykład nagłówka Accept-Rangs z serwera, który obsługuje zakresy bajtów, zostałby następujący:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Ciąg określony w nagłówku Accept-Ranges jest specyfikatorem zakresu, który byłby określony w `rangeSpecifier` parametrze dla tej metody.  
  
 Jeśli nagłówek Accept-Ranges nie zostanie odebrany w nagłówku odpowiedzi z serwera, serwer nie obsługuje nagłówków zakresów. Przykład nagłówka Accept-Ranges z serwera, który nie obsługuje zakresów, ale rozpoznaje nagłówka Accept-Ranges:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Podczas otrzymywania odpowiedzi z żądania zakresu tylko nagłówki HTTP skojarzone z całym żądaniem są analizowane i udostępniane za pośrednictwem właściwości <xref:System.Net.HttpWebResponse> klasy. Nagłówki skojarzone z każdym zakresem są zwracane w odpowiedzi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" />jest większe niż<paramref name="to" />  
  
—lub— 
 <paramref name="from" />lub <paramref name="to" /> jest mniejsza od 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można dodać nagłówka zakresu.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="from" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="to" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Opis zakresu.</param>
        <param name="from">Pozycja, w której ma zostać rozpoczęte wysyłanie danych.</param>
        <param name="to">Pozycja, w której ma zostać zatrzymane wysyłanie danych.</param>
        <summary>Dodaje nagłówek zakresu do żądania dla określonego zakresu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Metoda dodaje nagłówek zakresu do żądania.  
  
 Ponieważ wszystkie jednostki HTTP są reprezentowane w komunikatach HTTP jako sekwencje bajtów, koncepcja zakresu bajtów jest istotna dla dowolnej jednostki HTTP. Nie wszyscy klienci i serwery muszą jednak obsługiwać operacje z zakresu bajtów.  
  
 Nagłówek Range w żądaniu umożliwia klientowi zażądanie, że tylko część określonego zakresu bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądań nagłówka zakresu.  
  
 `rangeSpecifier` Parametr jest zwykle określany jako "Bytes", ponieważ jest to jedyna specyfikator zakresu uznawany przez większość serwerów HTTP. `rangeSpecifier` Ustawienie parametru na inny ciąg umożliwia obsługę specyfikatorów zakresu niestandardowego inne niż bajty (specyfikator zakresu bajtów zdefiniowany w dokumencie RFC 2616 przez grupę IETF).  
  
 Przykładem nagłówka zakresu w żądaniu protokołu HTTP, który żąda pierwszych 100 bajtów byłby następujący:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 W tym przykładzie `rangeSpecifier` parametr zostałby określony jako "Bytes" `from` , parametr będzie równy 0, a `to` parametr zostałby 99.  
  
 Serwer HTTP wskazuje obsługę nagłówków zakresów z nagłówkiem Accept-Ranges w odpowiedzi. Przykład nagłówka Accept-Rangs z serwera, który obsługuje zakresy bajtów, zostałby następujący:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Ciąg określony w nagłówku Accept-Ranges jest specyfikatorem zakresu, który byłby określony w `rangeSpecifier` parametrze dla tej metody.  
  
 Jeśli nagłówek Accept-Ranges nie zostanie odebrany w nagłówku odpowiedzi z serwera, serwer nie obsługuje nagłówków zakresów. Przykład nagłówka Accept-Ranges z serwera, który nie obsługuje zakresów, ale rozpoznaje nagłówka Accept-Ranges:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Podczas otrzymywania odpowiedzi z żądania zakresu tylko nagłówki HTTP skojarzone z całym żądaniem są analizowane i udostępniane za pośrednictwem właściwości <xref:System.Net.HttpWebResponse> klasy. Nagłówki skojarzone z każdym zakresem są zwracane w odpowiedzi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" />jest większe niż<paramref name="to" />  
  
—lub— 
 <paramref name="from" />lub <paramref name="to" /> jest mniejsza od 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można dodać nagłówka zakresu.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public Uri Address { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Address" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Address As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Address { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Address : Uri" Usage="System.Net.HttpWebRequest.Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera Uniform Resource Identifier (URI) zasobu internetowego, który faktycznie odpowiada na żądanie.</summary>
        <value>A <see cref="T:System.Uri" /> , który identyfikuje zasób internetowy, który faktycznie odpowiada na żądanie. Wartość domyślna to identyfikator URI używany przez <see cref="M:System.Net.WebRequest.Create(System.String)" /> metodę w celu zainicjowania żądania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Address%2A> Właściwość jest ustawiana na identyfikator URI po dowolnych przekierowań, które zakończyły się w trakcie żądania.  
  
 Identyfikator URI oryginalnego żądania jest przechowywany we <xref:System.Net.HttpWebRequest.RequestUri%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu sprawdza, <xref:System.Net.HttpWebRequest> czy obiekt `req` został przekierowany do innej lokalizacji w celu spełnienia żądania, i `hasChanged` ustawia wartość zmiennej na `true` Jeśli żądanie zostało przekierowane; w przeciwnym razie `hasChanged`jest ustawiony na `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public virtual bool AllowAutoRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowAutoRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowAutoRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAutoRedirect : bool with get, set" Usage="System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy żądanie powinno być zgodne z odpowiedziami przekierowania.</summary>
        <value><see langword="true" />Jeśli żądanie powinno być automatycznie zgodne z odpowiedziami przekierowania z zasobu internetowego; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> na`true` , jeśli chcesz, aby żądanie automatycznie podążać za nagłówkami przekierowań HTTP do nowej lokalizacji zasobu. Maksymalna liczba przekierowań do wykonania jest ustawiana przez <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> właściwość.  
  
 Jeśli <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> jest ustawiona na `false`, wszystkie odpowiedzi z kodem stanu HTTP od 300 do 399 są zwracane do aplikacji.  
  
 Nagłówek autoryzacji jest wyczyszczony w obszarze Automatyczne przekierowania i <xref:System.Net.HttpWebRequest> automatycznie próbuje ponownie przeprowadzić uwierzytelnienie w przekierowanej lokalizacji. W rzeczywistości oznacza to, że aplikacja nie może umieścić niestandardowych informacji o uwierzytelnianiu w nagłówku autoryzacji, jeśli jest możliwe przeprowadzenie przekierowania. Zamiast tego aplikacja musi zaimplementować i zarejestrować niestandardowy moduł uwierzytelniania. Klasa <xref:System.Net.AuthenticationManager?displayProperty=nameWithType> i powiązane są używane do implementowania niestandardowego modułu uwierzytelniania. <xref:System.Net.AuthenticationManager.Register%2A?displayProperty=nameWithType> Metoda rejestruje niestandardowy moduł uwierzytelniania.  
  
   
  
## Examples  
 Poniższy przykład kodu używa właściwości, <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> aby umożliwić żądaniu śledzenie odpowiedzi przekierowania.  
  
 [!code-cpp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CPP/httpwebrequest_allowautoredirect.cpp#2)]
 [!code-csharp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CS/httpwebrequest_allowautoredirect.cs#2)]
 [!code-vb[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/VB/httpwebrequest_allowautoredirect.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowReadStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowReadStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowReadStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowReadStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowReadStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowReadStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy bufor otrzymany z zasobu internetowego ma być buforowany.</summary>
        <value><see langword="true" />Aby włączyć buforowanie danych otrzymanych z zasobu internetowego; <see langword="false" /> aby wyłączyć buforowanie. Wartość domyślna to <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowWriteStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowWriteStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowWriteStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowWriteStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowWriteStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowWriteStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy dane wysyłane do zasobu Internetu mają być buforowane.</summary>
        <value><see langword="true" />Aby włączyć buforowanie danych wysyłanych do zasobu internetowego; <see langword="false" /> aby wyłączyć buforowanie. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> tak `true`jest, dane są buforowane w pamięci, aby można je było ponownie wysłać w przypadku przekierowań lub żądań uwierzytelnienia.  
  
   
  
## Examples  
 Poniższy przykład kodu używa właściwości, <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> aby wyłączyć buforowanie danych.  
  
 [!code-cpp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CPP/httpwebrequest_allowwritestreambuffering.cpp#1)]
 [!code-csharp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CS/httpwebrequest_allowwritestreambuffering.cs#1)]
 [!code-vb[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/VB/httpwebrequest_allowwritestreambuffering.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ustawienie <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> może spowodować problemy z wydajnością podczas przekazywania dużych zestawów danych, ponieważ bufor może korzystać z całej dostępnej pamięci. <see langword="true" /></para></block>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDecompression">
      <MemberSignature Language="C#" Value="public System.Net.DecompressionMethods AutomaticDecompression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.DecompressionMethods AutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticDecompression As DecompressionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::DecompressionMethods AutomaticDecompression { System::Net::DecompressionMethods get(); void set(System::Net::DecompressionMethods value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticDecompression : System.Net.DecompressionMethods with get, set" Usage="System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.DecompressionMethods</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ używanej dekompresji.</summary>
        <value><see cref="T:System.Net.DecompressionMethods" /> Obiekt, który wskazuje typ używanej dekompresji.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący stan obiektu nie zezwala na ustawienie tej właściwości.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRequestStream">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetRequestStream(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetRequestStream (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetRequestStream(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetRequestStream : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetRequestStream (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegat.</param>
        <param name="state">Obiekt stanu dla tego żądania.</param>
        <summary>Rozpoczyna asynchroniczne żądanie dla <see cref="T:System.IO.Stream" /> obiektu, który ma być używany do zapisu danych.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Odwołanie do żądania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda uruchamia asynchroniczne żądanie dla strumienia użytego do wysłania danych <xref:System.Net.HttpWebRequest>dla. <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> Metoda asynchronicznego wywołania zwrotnego używa <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> metody do zwrócenia rzeczywistego strumienia.  
  
 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> Metoda wymaga wykonania synchronicznych zadań konfiguracyjnych (na przykład rozpoznawania nazw DNS, wykrywania serwera proxy i połączenia gniazda TCP) przed rozpoczęciem tej metody jako asynchronicznej. W związku z tym ta metoda nigdy nie powinna być wywoływana w wątku interfejsu użytkownika, ponieważ może to potrwać pewien czas (aż do kilku minut w zależności od ustawień sieciowych), aby wykonać wstępne zadania konfiguracji synchronicznej przed wystąpieniem błędu lub Metoda powiedzie się.  
  
 Aby dowiedzieć się więcej na temat puli wątków, zobacz [Zarządzana pula wątków](~/docs/standard/threading/the-managed-thread-pool.md).  
  
> [!NOTE]
>  Aplikacja nie może mieszać metod synchronicznych i asynchronicznych dla określonego żądania. W przypadku wywołania <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> metody należy <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> użyć metody do pobrania odpowiedzi.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu używa metody, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> aby wykonać asynchroniczne żądanie dla wystąpienia strumienia.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.HttpWebRequest.Method" /> Właściwość jest get lub głowy.  
  
—lub— 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" />is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is ,is<see cref="P:System.Net.HttpWebRequest.ContentLength" /> -1 ,<see cref="P:System.Net.HttpWebRequest.SendChunked" /> is<see langword="false" />i is<see cref="P:System.Net.HttpWebRequest.Method" />postlubPut. <see langword="false" /></exception>
        <exception cref="T:System.InvalidOperationException">Strumień jest używany przez poprzednie wywołanie do<see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />  
  
—lub— 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" />jest ustawiona na wartość i <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" />równa.  
  
—lub— 
Pula wątków działa poza wątkiem.</exception>
        <exception cref="T:System.NotSupportedException">Moduł sprawdzania poprawności pamięci podręcznej żądań wskazywał, że odpowiedź na to żądanie może być obsługiwana z pamięci podręcznej; Jednak żądania, które zapisują dane, nie mogą korzystać z pamięci podręcznej. Ten wyjątek może wystąpić, jeśli używasz niestandardowego modułu sprawdzania pamięci podręcznej, który jest niepoprawnie zaimplementowany.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" />została wcześniej wywołana.</exception>
        <exception cref="T:System.ObjectDisposedException">W aplikacji .NET Compact Framework strumień żądania o zerowej długości zawartości nie został pobrany i poprawnie zamknięty. Aby uzyskać więcej informacji na temat obsługi żądań o zerowej długości zawartości, zobacz [programowanie sieci w .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy, element (Ustawienia sieci)</related>
      </Docs>
    </Member>
    <Member MemberName="BeginGetResponse">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetResponse(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetResponse (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetResponse(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetResponse : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetResponse (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Obiekt delegowany</param>
        <param name="state">Obiekt stanu dla tego żądania.</param>
        <summary>Rozpoczyna asynchroniczne żądanie do zasobu internetowego.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Odwołanie do żądania asynchronicznego dla odpowiedzi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> Metoda uruchamia asynchroniczne żądanie odpowiedzi z zasobu internetowego. Metoda asynchronicznego wywołania zwrotnego używa <xref:System.Net.HttpWebRequest.EndGetResponse%2A> metody do zwrócenia wartości rzeczywistej. <xref:System.Net.WebResponse>  
  
 Występuje w kilku przypadkach, gdy właściwości ustawione <xref:System.Net.HttpWebRequest> w klasie są w konflikcie. <xref:System.Net.ProtocolViolationException> Ten wyjątek występuje, gdy aplikacja ustawia <xref:System.Net.HttpWebRequest.ContentLength%2A> Właściwość <xref:System.Net.HttpWebRequest.SendChunked%2A> i właściwość na `true`, a następnie wysyła żądanie HTTP GET. Ten wyjątek występuje, gdy aplikacja próbuje wysłać fragment do serwera, który obsługuje tylko protokół HTTP 1,0, gdzie nie jest to obsługiwane. Ten wyjątek występuje, gdy aplikacja próbuje wysłać dane bez ustawienia <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości <xref:System.Net.HttpWebRequest.SendChunked%2A> lub `false` gdy buforowanie jest <xref:System.Net.HttpWebRequest.KeepAlive%2A> wyłączone i połączenie z utrzymywaniem aktywności (właściwość jest `true`)`.`  
  
 Jeśli jest zgłaszany, <xref:System.Net.WebException.Response%2A> Użyj właściwości i <xref:System.Net.WebException.Status%2A> wyjątku, aby określić odpowiedź z serwera. <xref:System.Net.WebException>  
  
 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> Metoda wymaga wykonania synchronicznych zadań konfiguracyjnych (na przykład rozpoznawania nazw DNS, wykrywania serwera proxy i połączenia gniazda TCP) przed rozpoczęciem tej metody jako asynchronicznej. W związku z tym ta metoda nigdy nie powinna być wywoływana w wątku interfejsu użytkownika, ponieważ może to potrwać pewien czas (aż do kilku minut w zależności od ustawień sieciowych), aby wykonać wstępne zadania konfiguracji synchronicznej przed wystąpieniem błędu lub Metoda powiedzie się.  
  
 Aby dowiedzieć się więcej na temat puli wątków, zobacz [Zarządzana pula wątków](~/docs/standard/threading/the-managed-thread-pool.md).  
  
> [!NOTE]
>  Aplikacja nie może mieszać metod synchronicznych i asynchronicznych dla określonego żądania. W przypadku wywołania <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> metody należy <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> użyć metody do pobrania odpowiedzi.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu używa metody, <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> aby wykonać asynchroniczne żądanie dla zasobu internetowego.  
  
> [!NOTE]
>  W przypadku żądań asynchronicznych jest odpowiedzialna aplikacja kliencka do wdrożenia własnego mechanizmu przekroczenia limitu czasu. Poniższy przykład kodu pokazuje, jak to zrobić.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Strumień jest już używany przez poprzednie wywołanie elementu<see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />  
  
—lub— 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" />jest ustawiona na wartość i <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" />równa.  
  
—lub— 
Pula wątków działa poza wątkiem.</exception>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.HttpWebRequest.Method" />ma wartość get lub głowy, a <see cref="P:System.Net.HttpWebRequest.ContentLength" /> jest większa od zera lub <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="true" />.  
  
—lub— 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" />is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is iis<see cref="P:System.Net.HttpWebRequest.ContentLength" /> -1 ,<see cref="P:System.Net.HttpWebRequest.SendChunked" /> is<see langword="false" /> i is<see cref="P:System.Net.HttpWebRequest.Method" /> post lub Put. <see langword="false" />  
  
—lub— 
Ma <see cref="T:System.Net.HttpWebRequest" /> treść jednostki, <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> ale metoda <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> jest wywoływana bez wywoływania metody.  
  
—lub— 
Wartość <see cref="P:System.Net.HttpWebRequest.ContentLength" /> jest większa od zera, ale aplikacja nie zapisuje wszystkich przyrzeczonych danych.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" />została wcześniej wywołana.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy, element (Ustawienia sieci)</related>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); void set(System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection with get, set" Usage="System.Net.HttpWebRequest.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolekcję certyfikatów zabezpieczeń, które są skojarzone z tym żądaniem.</summary>
        <value><see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> Zawiera certyfikaty zabezpieczeń skojarzone z tym żądaniem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja może dodać certyfikat do kolekcji, ale może nie mieć do niego uprawnień dostępu. Aby użyć certyfikatu zawartego w kolekcji, aplikacja musi mieć takie same prawa dostępu jak jednostka, która wystawił certyfikat.  
  
> [!NOTE]
>  Struktura buforuje sesje SSL w miarę ich tworzenia i próbuje ponownie użyć buforowanej sesji dla nowego żądania, jeśli jest to możliwe. Przy próbie ponownego użycia sesji SSL w strukturze jest używany pierwszy element <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (jeśli istnieje) lub próba ponownego użycia sesji anonimowych, jeśli <xref:System.Net.HttpWebRequest.ClientCertificates%2A> jest ona pusta.  
  
> [!NOTE]
>  Ze względu na wydajność nie należy dodawać certyfikatu klienta do programu <xref:System.Net.HttpWebRequest> , chyba że wiadomo, że serwer będzie pytał o to.  
>   
>  Przykładowy kod ilustrujący sposób wyliczenia certyfikatów w magazynie certyfikatów klienta znajduje się <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> w klasie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość określona dla operacji zestawu to <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public string Connection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Connection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Connection" />
      <MemberSignature Language="VB.NET" Value="Public Property Connection As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Connection { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Connection : string with get, set" Usage="System.Net.HttpWebRequest.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see langword="Connection" /> nagłówka HTTP.</summary>
        <value>Wartość <see langword="Connection" /> nagłówka HTTP. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Żądanie wysyła <xref:System.Net.HttpWebRequest.Connection%2A> właściwość do zasobu internetowego `Connection` jako nagłówek HTTP. Jeśli wartość <xref:System.Net.HttpWebRequest.KeepAlive%2A> właściwości jest `true`równa, wartość "Keep-Alive" jest dołączana `Connection` na końcu nagłówka.  
  
 Aby wyczyścić `Connection` nagłówek HTTP, <xref:System.Net.HttpWebRequest.Connection%2A> ustaw właściwość na `null`.  
  
 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> Zmianawłaściwościpouruchomieniu<xref:System.InvalidOperationException>żądania przez <xref:System.Net.HttpWebRequest.GetRequestStream%2A>wywołanie metody,, <xref:System.Net.HttpWebRequest.GetResponse%2A>lub powoduje wyrzucanie. <xref:System.Net.HttpWebRequest.Connection%2A>  
  
> [!NOTE]
>  Wartość tej właściwości jest przechowywana w <xref:System.Net.WebHeaderCollection>. Jeśli jest ustawiona właściwość WebHeaderCollection, wartość właściwości zostanie utracona.  
  
   
  
## Examples  
 Poniższy przykład kodu używa właściwości, <xref:System.Net.HttpWebRequest.Connection%2A> aby ustawić wartość nagłówka HTTP połączenia.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość <see cref="P:System.Net.HttpWebRequest.Connection" /> jest ustawiona na Keep-Alive lub Close.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionGroupName">
      <MemberSignature Language="C#" Value="public override string ConnectionGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionGroupName : string with get, set" Usage="System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę grupy połączeń dla żądania.</summary>
        <value>Nazwa grupy połączeń dla tego żądania. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> Właściwość umożliwia skojarzenie żądania z grupą połączeń. Jest to przydatne, gdy aplikacja wysyła żądania do jednego serwera dla różnych użytkowników, takich jak witryna sieci Web, która pobiera informacje o klientach z serwera bazy danych.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak używać informacji o użytkowniku do tworzenia grupy połączeń przy założeniu, że `username`zmienne `password`, i `domain` są ustawiane przez aplikację przed wywołaniem tego kodu.  
  
 [!code-cpp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Każda grupa połączeń tworzy dodatkowe połączenia dla serwera. Może to spowodować przekroczenie liczby połączeń ustawionych przez <see cref="P:System.Net.ServicePoint.ConnectionLimit" /> Właściwość tego serwera.</para></block>
        <altmember cref="P:System.Net.Configuration.ConnectionManagementElement.MaxConnection" />
        <altmember cref="P:System.Net.WebRequest.ConnectionGroupName" />
        <related type="Article" href="~/docs/framework/network-programming/connection-grouping.md">Grupowanie połączeń</related>
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public override long ContentLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long ContentLength { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int64 with get, set" Usage="System.Net.HttpWebRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see langword="Content-length" /> nagłówek HTTP.</summary>
        <value>Liczba bajtów danych do wysłania do zasobu internetowego. Wartość domyślna to-1, co oznacza, że właściwość nie została ustawiona i nie ma żadnych danych żądania do wysłania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość zawiera wartość, która ma zostać wysłana `Content-length` jako nagłówek HTTP z żądaniem. <xref:System.Net.HttpWebRequest.ContentLength%2A>  
  
 Każda wartość inna niż-1 we <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości wskazuje, że żądanie przekazuje dane i że tylko metody, które przekazują dane, mogą być ustawiane <xref:System.Net.HttpWebRequest.Method%2A> we właściwości.  
  
 Po ustawieniu <xref:System.Net.HttpWebRequest.GetRequestStream%2A> <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> właściwości na wartość ta liczba bajtów musi być zapisywana w strumieniu żądania, który jest zwracany przez wywołanie metody lub zarówno metody, jak i. <xref:System.Net.HttpWebRequest.ContentLength%2A>  
  
> [!NOTE]
>  Wartość tej właściwości jest przechowywana w <xref:System.Net.WebHeaderCollection>. Jeśli jest ustawiona właściwość WebHeaderCollection, wartość właściwości zostanie utracona.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwość na długość ogłaszanego ciągu.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żądanie zostało <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />uruchomione przez wywołanie metody, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />lub <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> .</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nowa <see cref="P:System.Net.HttpWebRequest.ContentLength" /> wartość jest mniejsza niż 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public override string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Net.HttpWebRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see langword="Content-type" /> nagłówka HTTP.</summary>
        <value>Wartość <see langword="Content-type" /> nagłówka HTTP. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContentType%2A> Właściwość zawiera typ nośnika żądania. Wartości przypisane do <xref:System.Net.HttpWebRequest.ContentType%2A> właściwości zastępują wszelkie istniejące zawartość, `Content-type` gdy żądanie wyśle nagłówek HTTP.  
  
 Aby wyczyścić `Content-type` nagłówek HTTP, <xref:System.Net.HttpWebRequest.ContentType%2A> ustaw właściwość na `null`.  
  
> [!NOTE]
>  Wartość tej właściwości jest przechowywana w <xref:System.Net.WebHeaderCollection> . Jeśli <xref:System.Net.WebHeaderCollection> jest ustawiona, wartość właściwości zostanie utracona.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia <xref:System.Net.HttpWebRequest.ContentType%2A> właściwość.  
  
 [!code-cpp[HttpWebRequest_ContentLength#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#1)]
 [!code-csharp[HttpWebRequest_ContentLength#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#1)]
 [!code-vb[HttpWebRequest_ContentLength#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpContinueDelegate ContinueDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpContinueDelegate ContinueDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueDelegate As HttpContinueDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpContinueDelegate ^ ContinueDelegate { System::Net::HttpContinueDelegate ^ get(); void set(System::Net::HttpContinueDelegate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueDelegate : System.Net.HttpContinueDelegate with get, set" Usage="System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpContinueDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia metodę delegata, która jest wywoływana, gdy odebrana zostanie odpowiedź HTTP 100-Continue z zasobu internetowego.</summary>
        <value>Delegat implementujący metodę wywołania zwrotnego, która jest wykonywana w przypadku zwrócenia odpowiedzi HTTP Continue z zasobu internetowego. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> Właściwość określa metodę wywołania zwrotnego, która ma być wywoływana, gdy klient otrzymuje odpowiedź 100-Continue.  
  
 Gdy właściwość jest ustawiona, klient wywołuje delegata za każdym razem, gdy są odbierane odpowiedzi protokołu typu <xref:System.Net.HttpStatusCode.Continue?displayProperty=nameWithType> (100). <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> Jest to przydatne, jeśli chcesz, aby klient wyświetlał stan danych odbieranych z zasobu internetowego.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public int ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContinueTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia limit czasu (w milisekundach) oczekiwania na odebranie 100-kontynuacji z serwera.</summary>
        <value>Limit czasu (w milisekundach) oczekiwania na odebranie 100-Continue.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli odpowiedź 100-Continue zostanie odebrana przed upływem limitu czasu, treść jednostki może zostać wysłana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieContainer">
      <MemberSignature Language="C#" Value="public virtual System.Net.CookieContainer CookieContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer CookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.CookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CookieContainer As CookieContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CookieContainer : System.Net.CookieContainer with get, set" Usage="System.Net.HttpWebRequest.CookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia pliki cookie skojarzone z żądaniem.</summary>
        <value><see cref="T:System.Net.CookieContainer" /> Zawierający pliki cookie skojarzone z tym żądaniem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość zawiera wystąpienie <xref:System.Net.CookieContainer> klasy zawierającej pliki cookie skojarzone z tym żądaniem. <xref:System.Net.HttpWebRequest.CookieContainer%2A>  
  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A>jest `null` domyślnie. Należy przypisać <xref:System.Net.CookieContainer> obiekt do właściwości, aby pliki cookie zwracały się <xref:System.Net.HttpWebResponse.Cookies%2A> we właściwości <xref:System.Net.HttpWebResponse> zwracanej przez <xref:System.Net.HttpWebRequest.GetResponse%2A> metodę.  
  
> [!NOTE]
>  Ze względów bezpieczeństwa pliki cookie są domyślnie wyłączone. Jeśli chcesz używać plików cookie, użyj <xref:System.Net.HttpWebRequest.CookieContainer%2A> właściwości, aby włączyć pliki cookie.  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła żądanie do adresu URL i wyświetla pliki cookie zwrócone w odpowiedzi.  
  
 [!code-cpp[NCLCookies#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLCookies/CPP/cookiessnippets.cpp#1)]
 [!code-csharp[NCLCookies#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLCookies/CS/cookiessnippets.cs#1)]
 [!code-vb[NCLCookies#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLCookies/VB/cookiessnippets.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.CookieContainer" />
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials with get, set" Usage="System.Net.HttpWebRequest.Credentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje o uwierzytelnianiu dla żądania.</summary>
        <value><see cref="T:System.Net.ICredentials" /> Zawierający poświadczenia uwierzytelniania skojarzone z żądaniem. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Credentials%2A> Właściwość zawiera informacje o uwierzytelnianiu, które identyfikują twórcę żądania. Właściwość może być albo a <xref:System.Net.NetworkCredential>, w takim przypadku informacje o użytkowniku, haśle i <xref:System.Net.NetworkCredential> domenie zawarte w obiekcie są używane do uwierzytelniania żądania lub mogą być <xref:System.Net.CredentialCache>, w którym to przypadku, <xref:System.Net.HttpWebRequest.Credentials%2A> Identyfikator (URI) żądania służy do określenia informacji o użytkowniku, haśle i domenie, które mają być używane do uwierzytelniania żądania.  
  
 W większości scenariuszy klienta należy użyć <xref:System.Net.CredentialCache.DefaultCredentials%2A> właściwości, która zawiera poświadczenia aktualnie zalogowanego użytkownika. W tym celu należy ustawić <xref:System.Net.WebClient.UseDefaultCredentials%2A> właściwość na `true` zamiast ustawiania tej właściwości.  
  
 Jeśli klasa jest używana w aplikacji warstwy środkowej, takiej jak aplikacja ASP.NET, poświadczenia <xref:System.Net.CredentialCache.DefaultCredentials%2A> we właściwości należy do konta, na którym działa strona ASP (poświadczenia po stronie serwera). <xref:System.Net.HttpWebRequest> Zazwyczaj należy ustawić tę właściwość na poświadczenia klienta, w którym imieniu żądanie zostało wykonane.  
  
> [!NOTE]
>  Nie można użyć schematu uwierzytelniania NTLM do personifikacji innego użytkownika. Protokół Kerberos musi być specjalnie skonfigurowany do obsługi personifikacji.  
  
 Aby ograniczyć HttpWebRequest do co najmniej jednej metody uwierzytelniania, użyj <xref:System.Net.CredentialCache> klasy i powiąż poświadczenia z co najmniej jednym schematem uwierzytelniania  
  
 Obsługiwane schematy uwierzytelniania obejmują: Digest, Negotiate, Kerberos, NTLM i Basic.  
  
 Ze względów bezpieczeństwa w przypadku automatycznego przekierowania należy przechowywać poświadczenia, które mają być uwzględnione w przekierowaniu <xref:System.Net.CredentialCache> , a następnie przypisać je do tej właściwości. Ta właściwość zostanie automatycznie ustawiona na `null` po przekierowaniu, jeśli zawiera wszystko <xref:System.Net.CredentialCache>z wyjątkiem. Wartość tej właściwości jest ustawiana automatycznie w `null` taki sposób, aby zapobiec wysyłaniu poświadczeń do dowolnych nieplanowanych miejsc docelowych.
  
## Examples  
 Poniższy przykład kodu ustawia poświadczenia dla żądania.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Date" />
      <MemberSignature Language="VB.NET" Value="Public Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.Date : DateTime with get, set" Usage="System.Net.HttpWebRequest.Date" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see langword="Date" /> nagłówka HTTP, która ma być używana w żądaniu HTTP.</summary>
        <value>Wartość nagłówka daty w żądaniu HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nagłówek daty to `null`, wartość zwracana zostanie ustawiona na. <xref:System.DateTime.MinValue?displayProperty=nameWithType>  
  
 <xref:System.DateTime?displayProperty=nameWithType> <xref:System.DateTimeKind.Local?displayProperty=nameWithType> Właściwośćjest<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>obiektemstandardowym i może zawierać <xref:System.DateTimeKind.Utc?displayProperty=nameWithType> pole,,lub.<xref:System.DateTimeKind?displayProperty=nameWithType> <xref:System.Net.HttpWebRequest.Date%2A> Dowolny rodzaj czasu można ustawić przy użyciu <xref:System.Net.HttpWebRequest.Date%2A> właściwości. Jeśli <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> jest ustawiona lub pobierana <xref:System.Net.HttpWebRequest.Date%2A> , przyjmuje się, że właściwość <xref:System.DateTimeKind.Local?displayProperty=nameWithType> jest (czas lokalny).  
  
 Klasy w <xref:System.Net> przestrzeni nazw zawsze zapisują <xref:System.Net.HttpWebRequest.Date%2A> właściwość w sieci podczas transmisji w standardowym formacie, używając formatu GMT (UTC).  
  
 <xref:System.DateTime.MinValue?displayProperty=nameWithType> `Date` <xref:System.Net.HttpWebRequest.Headers%2A> Jeśli właściwość jest ustawiona na ,<xref:System.Net.WebHeaderCollection>nagłówek HTTP zostanie usunięty z właściwości i. <xref:System.Net.HttpWebRequest.Date%2A>  
  
 <xref:System.DateTime.MinValue?displayProperty=nameWithType> <xref:System.Net.HttpWebRequest.Headers%2A> Jeśliwłaściwośćjest`Date` , oznacza to, że nagłówek HTTP nie <xref:System.Net.WebHeaderCollection>jest uwzględniony we właściwości i. <xref:System.Net.HttpWebRequest.Date%2A>  
  
> [!NOTE]
>  Wartość tej właściwości jest przechowywana w <xref:System.Net.WebHeaderCollection>. Jeśli jest ustawiona właściwość WebHeaderCollection, wartość właściwości zostanie utracona.  
  
 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> <xref:System.Net.ProtocolViolationException?displayProperty=nameWithType> <xref:System.Net.HttpWebRequest> <xref:System.Net.HttpWebRequest.EndGetResponse%2A> Jeśli ustawiono i podjęto próbę wysłania bez treści, a następnie zostanie wygenerowany przez, <xref:System.Net.HttpWebRequest.GetResponse%2A>i metody. <xref:System.Net.HttpWebRequest.Date%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCachePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy DefaultCachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Cache.RequestCachePolicy DefaultCachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultCachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Cache::RequestCachePolicy ^ DefaultCachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCachePolicy : System.Net.Cache.RequestCachePolicy with get, set" Usage="System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia domyślne zasady pamięci podręcznej dla tego żądania.</summary>
        <value>A <see cref="T:System.Net.Cache.HttpRequestCachePolicy" /> określa zasady pamięci podręcznej stosowane dla tego żądania, gdy nie ma żadnych innych zasad.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie tej właściwości rejestruje określone zasady dla schematów HTTP i HTTPS. Te zasady są używane dla tego żądania, jeśli:  
  
 Nie <xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType> określono właściwości dla tego żądania.  
  
—lub—
  
 Pliki konfiguracji komputera i aplikacji nie określają zasad pamięci podręcznej, które mają zastosowanie do Uniform Resource Identifier (URI) użytego do utworzenia tego żądania.  
  
 Zasady pamięci podręcznej określają, czy żądany zasób można pobrać z pamięci podręcznej, zamiast wysyłać żądanie do komputera hosta zasobów.  
  
 Kopia zasobu jest dodawana tylko do pamięci podręcznej, jeśli strumień odpowiedzi dla zasobu jest pobierany i odczytywany na końcu strumienia. Dlatego inne żądanie dotyczące tego samego zasobu może korzystać z kopii w pamięci podręcznej, w zależności od poziomu zasad pamięci podręcznej dla tego żądania.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">w przypadku nieograniczonego dostępu do zasobów sieciowych. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.Cache.RequestCachePolicy" />
        <altmember cref="T:System.Net.Cache.HttpRequestCacheLevel" />
        <altmember cref="T:System.Net.Cache.RequestCacheLevel" />
        <altmember cref="P:System.Net.WebRequest.CachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumErrorResponseLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumErrorResponseLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumErrorResponseLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumErrorResponseLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumErrorResponseLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia domyślną maksymalną długość odpowiedzi HTTP o błędzie.</summary>
        <value>Domyślna maksymalna długość odpowiedzi HTTP o błędzie.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość jest mniejsza od 0 i nie jest równa-1.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość domyślną <see cref="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" /> właściwości.</summary>
        <value>Długość w kilobajtach (1024 bajtów) dla odebranych nagłówków odpowiedzi. Domyślny plik konfiguracji ustawia tę wartość na 64 kilobajtów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Długość nagłówka odpowiedzi otrzymała wiersz stanu odpowiedzi i wszelkie dodatkowe znaki kontrolne, które są odbierane jako część protokołu HTTP. Wartość-1 oznacza, że w otrzymanych nagłówkach odpowiedzi nie ma limitu. wartość 0 oznacza, że wszystkie żądania kończą się niepowodzeniem.  
  
 Tę wartość można również zmienić w pliku konfiguracji. Wpływ tej właściwości można przesłonić, ustawiając <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> właściwość w wystąpieniu <xref:System.Net.HttpWebRequest> klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość nie jest równa-1 i jest mniejsza od zera.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndGetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zamyka asynchroniczne żądanie dla <see cref="T:System.IO.Stream" /> obiektu, który ma być używany do zapisu danych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetRequestStream (asyncResult As IAsyncResult) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oczekujące żądanie strumienia.</param>
        <summary>Zamyka asynchroniczne żądanie dla <see cref="T:System.IO.Stream" /> obiektu, który ma być używany do zapisu danych.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> , aby użyć do zapisu danych żądania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wykonuje asynchroniczne żądanie dla strumienia, który został uruchomiony <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> przez metodę. <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> Po zwróceniu <xref:System.Net.HttpWebRequest> <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> obiektu można wysłać dane za pomocą metody. <xref:System.IO.Stream>  
  
> [!NOTE]
>  Przed zapisaniem danych w strumieniu należy ustawić wartość <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości.  
  
> [!CAUTION]
>  Należy wywołać <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> metodę w celu zamknięcia strumienia i zwolnienia połączenia do ponownego użycia. Niepowodzenie zamknięcia strumienia powoduje brak połączeń aplikacji.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu używa metody, <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> aby zakończyć asynchroniczne żądanie dla wystąpienia strumienia.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Żądanie nie zostało ukończone i strumień nie jest dostępny.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />nie został zwrócony przez bieżące wystąpienie z wywołania do <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ta metoda została wywołana wcześniej przy <paramref name="asyncResult" />użyciu.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" />została wcześniej wywołana.  
  
—lub— 
Wystąpił błąd podczas przetwarzania żądania.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; context) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef context As TransportContext) As Stream" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; transportContext) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef transportContext As TransportContext) As Stream" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult *  -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream (asyncResult, transportContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Net.TransportContext" RefType="out" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="transportContext" Type="System.Net.TransportContext" RefType="out" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oczekujące żądanie strumienia.</param>
        <param name="context"><see cref="T:System.Net.TransportContext" /> Dla<see cref="T:System.IO.Stream" />elementu.</param>
        <param name="transportContext"><see cref="T:System.Net.TransportContext" /> Dla<see cref="T:System.IO.Stream" />elementu.</param>
        <summary>Zamyka asynchroniczne żądanie dla <see cref="T:System.IO.Stream" /> obiektu, który ma być używany do zapisywania danych i <see cref="T:System.Net.TransportContext" /> wyprowadza skojarzone ze strumieniem.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> , aby użyć do zapisu danych żądania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wykonuje asynchroniczne żądanie dla strumienia, który został uruchomiony <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> przez metodę i wyprowadza <xref:System.Net.TransportContext> skojarzenie skojarzone ze strumieniem. <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> Po zwróceniu <xref:System.Net.HttpWebRequest> <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> obiektu można wysłać dane za pomocą metody. <xref:System.IO.Stream>  
  
 Niektóre aplikacje używające zintegrowanego uwierzytelniania systemu Windows z ochroną rozszerzoną mogą być w stanie wysyłać zapytania do warstwy <xref:System.Net.HttpWebRequest> transportowej używanej przez program w celu pobrania tokenu powiązania kanału (CBT) z bazowego kanału TLS. Metoda zapewnia dostęp do tych informacji dla metod http, które mają treść żądania (`POST` i `PUT` żądania). <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Jest to potrzebne tylko wtedy, gdy aplikacja implementuje własne uwierzytelnianie i wymaga dostępu do CBT.  
  
> [!NOTE]
>  Jeśli aplikacja wymaga ustawienia wartości <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości, należy to zrobić przed pobraniem strumienia i zapisem danych.  
  
> [!CAUTION]
>  Należy wywołać <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> metodę w celu zamknięcia strumienia i zwolnienia połączenia do ponownego użycia. Niepowodzenie zamknięcia strumienia powoduje brak połączeń aplikacji.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />nie został zwrócony przez bieżące wystąpienie z wywołania do <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ta metoda została wywołana wcześniej przy <paramref name="asyncResult" />użyciu.</exception>
        <exception cref="T:System.IO.IOException">Żądanie nie zostało ukończone i strumień nie jest dostępny.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" />została wcześniej wywołana.  
  
—lub— 
Wystąpił błąd podczas przetwarzania żądania.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Zintegrowane uwierzytelnianie systemu Windows z ochroną rozszerzoną</related>
      </Docs>
    </Member>
    <Member MemberName="EndGetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse EndGetResponse (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse EndGetResponse(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetResponse(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetResponse (asyncResult As IAsyncResult) As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ EndGetResponse(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetResponse : IAsyncResult -&gt; System.Net.WebResponse" Usage="httpWebRequest.EndGetResponse asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oczekujące żądanie odpowiedzi.</param>
        <summary>Zamyka asynchroniczne żądanie do zasobu internetowego.</summary>
        <returns>A <see cref="T:System.Net.WebResponse" /> , który zawiera odpowiedź z zasobu internetowego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wykonuje asynchroniczne żądanie dla zasobu internetowego, który został uruchomiony przez <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> wywołanie metody. <xref:System.Net.HttpWebRequest.EndGetResponse%2A>  
  
> [!CAUTION]
>  Musisz wywołać metodę, <xref:System.Net.HttpWebResponse.Close%2A> aby zamknąć strumień i zwolnić połączenie. Niewykonanie tej czynności może spowodować, że aplikacja nie będzie mogła uruchomić połączeń.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu używa metody, <xref:System.Net.HttpWebRequest.EndGetResponse%2A> aby zakończyć asynchroniczne żądanie dla zasobu internetowego.  
  
 [!code-cpp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CPP/httpwebrequest_begingetresponse.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CS/httpwebrequest_begingetresponse.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/VB/httpwebrequest_begingetresponse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ta metoda została wywołana wcześniej przy użyciu<paramref name="asyncResult." />  
  
—lub— 
<see cref="P:System.Net.HttpWebRequest.ContentLength" /> Właściwość jest większa niż 0, ale dane nie zostały zazapisywane w strumieniu żądania.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" />została wcześniej wywołana.  
  
—lub— 
Wystąpił błąd podczas przetwarzania żądania.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />nie został zwrócony przez bieżące wystąpienie z wywołania do <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expect">
      <MemberSignature Language="C#" Value="public string Expect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Expect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Expect" />
      <MemberSignature Language="VB.NET" Value="Public Property Expect As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Expect { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Expect : string with get, set" Usage="System.Net.HttpWebRequest.Expect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see langword="Expect" /> nagłówka HTTP.</summary>
        <value>Zawartość <see langword="Expect" /> nagłówka HTTP. Wartość domyślna to <see langword="null" />.  
  
 <block subset="none" type="note"><para>  
 Wartość tej właściwości jest przechowywana w <see cref="T:System.Net.WebHeaderCollection" />. Jeśli jest ustawiona właściwość WebHeaderCollection, wartość właściwości zostanie utracona.  
  
</para></block></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><see langword="Expect" />jest ustawiony na ciąg, który zawiera "100-Continue" jako podciąg.</exception>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy, element (Ustawienia sieci)</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="httpWebRequest.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla <see cref="T:System.Net.WebRequest" /> wystąpienia.</summary>
        <returns>Wartość skrótu liczb całkowitych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Metoda GetHashCode zwraca kod skrótu żądania sieci Web. Ta wartość może być używana jako klucz w tabelach skrótów.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected override void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="httpWebRequest.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="serializationInfo"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> Do wypełnienia danymi.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> określa miejsce docelowe dla tej serializacji.</param>
        <summary><see cref="T:System.Runtime.Serialization.SerializationInfo" /> Wypełnia dane wymagane do serializacji obiektu docelowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie obiekty zawarte w <xref:System.Runtime.Serialization.SerializationInfo> elemencie są automatycznie śledzone i serializowane przez program formatujący.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.IO.Stream" /> Pobiera obiekt, który ma być używany do zapisu danych żądania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetRequestStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetRequestStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRequestStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetRequestStream();" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream : unit -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.IO.Stream" /> Pobiera obiekt, który ma być używany do zapisu danych żądania.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> , aby użyć do zapisu danych żądania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zwraca strumień, który będzie używany do wysyłania danych <xref:System.Net.HttpWebRequest>dla. <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Po zwróceniu <xref:System.Net.HttpWebRequest> <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> obiektu można wysłać dane za pomocą metody. <xref:System.IO.Stream>  
  
 Jeśli aplikacja wymaga ustawienia wartości <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości, należy to zrobić przed pobraniem strumienia.  
  
 Należy wywołać <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> metodę w celu zamknięcia strumienia i zwolnienia połączenia do ponownego użycia. Niepowodzenie zamknięcia strumienia powoduje brak połączeń aplikacji.  
  
> [!NOTE]
>  Aplikacja nie może mieszać metod synchronicznych i asynchronicznych dla określonego żądania. W przypadku wywołania <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metody należy <xref:System.Net.HttpWebRequest.GetResponse%2A> użyć metody do pobrania odpowiedzi.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metody do zwrócenia wystąpienia strumienia.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.HttpWebRequest.Method" /> Właściwość jest get lub głowy.  
  
—lub— 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" />is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is ,is<see cref="P:System.Net.HttpWebRequest.ContentLength" /> -1 ,<see cref="P:System.Net.HttpWebRequest.SendChunked" /> is<see langword="false" />i is<see cref="P:System.Net.HttpWebRequest.Method" />postlubPut. <see langword="false" /></exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> Metoda jest wywoływana więcej niż raz.  
  
—lub— 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" />jest ustawiona na wartość i <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" />równa.</exception>
        <exception cref="T:System.NotSupportedException">Moduł sprawdzania poprawności pamięci podręcznej żądań wskazywał, że odpowiedź na to żądanie może być obsługiwana z pamięci podręcznej; Jednak żądania, które zapisują dane, nie mogą korzystać z pamięci podręcznej. Ten wyjątek może wystąpić, jeśli używasz niestandardowego modułu sprawdzania pamięci podręcznej, który jest niepoprawnie zaimplementowany.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" />została wcześniej wywołana.  
  
—lub— 
Limit czasu dla żądania wygasł.  
  
—lub— 
Wystąpił błąd podczas przetwarzania żądania.</exception>
        <exception cref="T:System.ObjectDisposedException">W aplikacji .NET Compact Framework strumień żądania o zerowej długości zawartości nie został pobrany i poprawnie zamknięty. Aby uzyskać więcej informacji na temat obsługi żądań o zerowej długości zawartości, zobacz [programowanie sieci w .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy, element (Ustawienia sieci)</related>
      </Docs>
    </Member>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetRequestStream (out System.Net.TransportContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetRequestStream([out] class System.Net.TransportContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream(System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRequestStream (ByRef context As TransportContext) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetRequestStream([Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream :  -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Net.TransportContext" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.Net.TransportContext" /> Dla<see cref="T:System.IO.Stream" />elementu.</param>
        <summary>Pobiera obiekt, który ma być używany do zapisu danych żądania i <see cref="T:System.Net.TransportContext" /> wyprowadza skojarzone ze strumieniem. <see cref="T:System.IO.Stream" /></summary>
        <returns>A <see cref="T:System.IO.Stream" /> , aby użyć do zapisu danych żądania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zwraca strumień, który służy do wysyłania danych <xref:System.Net.HttpWebRequest> dla i wyprowadza <xref:System.Net.TransportContext> skojarzone ze strumieniem. <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Po zwróceniu <xref:System.Net.HttpWebRequest> <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> obiektu można wysłać dane za pomocą metody. <xref:System.IO.Stream>  
  
 Niektóre aplikacje używające zintegrowanego uwierzytelniania systemu Windows z ochroną rozszerzoną mogą być w stanie wysyłać zapytania do warstwy <xref:System.Net.HttpWebRequest> transportowej używanej przez program w celu pobrania tokenu powiązania kanału (CBT) z bazowego kanału TLS. Metoda zapewnia dostęp do tych informacji dla metod http, które mają treść żądania (`POST` i `PUT` żądania). <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Jest to potrzebne tylko wtedy, gdy aplikacja implementuje własne uwierzytelnianie i wymaga dostępu do CBT.  
  
 Jeśli aplikacja wymaga ustawienia wartości <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości, należy to zrobić przed pobraniem strumienia.  
  
 Należy wywołać <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> metodę w celu zamknięcia strumienia i zwolnienia połączenia do ponownego użycia. Niepowodzenie zamknięcia strumienia powoduje brak połączeń aplikacji.  
  
> [!NOTE]
>  Aplikacja nie może mieszać metod synchronicznych i asynchronicznych dla określonego żądania. W przypadku wywołania <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metody należy <xref:System.Net.HttpWebRequest.GetResponse%2A> użyć metody do pobrania odpowiedzi.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Metoda nie mogła <see cref="T:System.IO.Stream" />uzyskać. <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /></exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> Metoda jest wywoływana więcej niż raz.  
  
—lub— 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" />jest ustawiona na wartość i <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" />równa.</exception>
        <exception cref="T:System.NotSupportedException">Moduł sprawdzania poprawności pamięci podręcznej żądań wskazywał, że odpowiedź na to żądanie może być obsługiwana z pamięci podręcznej; Jednak żądania, które zapisują dane, nie mogą korzystać z pamięci podręcznej. Ten wyjątek może wystąpić, jeśli używasz niestandardowego modułu sprawdzania pamięci podręcznej, który jest niepoprawnie zaimplementowany.</exception>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.HttpWebRequest.Method" /> Właściwość jest get lub głowy.  
  
—lub— 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" />is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is ,is<see cref="P:System.Net.HttpWebRequest.ContentLength" /> -1 ,<see cref="P:System.Net.HttpWebRequest.SendChunked" /> is<see langword="false" />i is<see cref="P:System.Net.HttpWebRequest.Method" />postlubPut. <see langword="false" /></exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" />została wcześniej wywołana.  
  
—lub— 
Limit czasu dla żądania wygasł.  
  
—lub— 
Wystąpił błąd podczas przetwarzania żądania.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Zintegrowane uwierzytelnianie systemu Windows z ochroną rozszerzoną</related>
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse GetResponse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse GetResponse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetResponse () As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ GetResponse();" />
      <MemberSignature Language="F#" Value="override this.GetResponse : unit -&gt; System.Net.WebResponse" Usage="httpWebRequest.GetResponse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca odpowiedź z zasobu internetowego.</summary>
        <returns>A <see cref="T:System.Net.WebResponse" /> , który zawiera odpowiedź z zasobu internetowego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetResponse%2A> Metoda<xref:System.Net.WebResponse> zwraca obiekt, który zawiera odpowiedź z zasobu internetowego. Zwracane wystąpienie jest <xref:System.Net.HttpWebResponse>i może być rzutowanie do tej klasy w celu uzyskania dostępu do właściwości specyficznych dla protokołu HTTP.  
  
 Występuje w kilku przypadkach, gdy właściwości ustawione <xref:System.Net.HttpWebRequest> w klasie są w konflikcie. <xref:System.Net.ProtocolViolationException> Ten wyjątek występuje, gdy aplikacja ustawia <xref:System.Net.HttpWebRequest.ContentLength%2A> Właściwość <xref:System.Net.HttpWebRequest.SendChunked%2A> i właściwość na `true`, a następnie wysyła żądanie HTTP GET. Ten wyjątek występuje, gdy aplikacja próbuje wysłać fragment do serwera, który obsługuje tylko protokół HTTP 1,0, gdzie nie jest to obsługiwane. Ten wyjątek występuje, gdy aplikacja próbuje wysłać dane bez ustawienia <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości <xref:System.Net.HttpWebRequest.SendChunked%2A> lub `false` gdy buforowanie jest <xref:System.Net.HttpWebRequest.KeepAlive%2A> wyłączone i połączenie z utrzymywaniem aktywności (właściwość jest `true`)`.`  
  
> [!CAUTION]
>  Musisz wywołać metodę, <xref:System.Net.HttpWebResponse.Close%2A> aby zamknąć strumień i zwolnić połączenie. Niewykonanie tej czynności może spowodować, że aplikacja nie będzie mogła uruchomić połączeń.  
  
 W przypadku korzystania z metody POST należy uzyskać strumień żądania, zapisać dane do opublikowania i zamknąć strumień. Ta metoda blokuje oczekiwanie na opublikowanie zawartości; Jeśli nie ma ustawionego limitu czasu i nie podasz zawartości, wątek wywołujący blokuje się nieskończonie.  
  
> [!NOTE]
>  Wiele wywołań <xref:System.Net.HttpWebRequest.GetResponse%2A> zwracających ten sam obiekt Response; żądanie nie jest ponownie wystawiane.  
  
> [!NOTE]
>  Aplikacja nie może mieszać metod synchronicznych i asynchronicznych dla określonego żądania. W przypadku wywołania <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metody należy <xref:System.Net.HttpWebRequest.GetResponse%2A> użyć metody do pobrania odpowiedzi.  
  
> [!NOTE]
>  Jeśli jest zgłaszany, <xref:System.Net.WebException.Response%2A> Użyj właściwości i <xref:System.Net.WebException.Status%2A> wyjątku, aby określić odpowiedź z serwera. <xref:System.Net.WebException>  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Ze względów bezpieczeństwa pliki cookie są domyślnie wyłączone. Jeśli chcesz używać plików cookie, użyj <xref:System.Net.HttpWebRequest.CookieContainer%2A> właściwości, aby włączyć pliki cookie.  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera odpowiedź na żądanie.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Strumień jest już używany przez poprzednie wywołanie metody <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.  
  
—lub— 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" />jest ustawiona na wartość i <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" />równa.</exception>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.HttpWebRequest.Method" />jest parametrem GET lub głowy i <see cref="P:System.Net.HttpWebRequest.ContentLength" /> jest większy lub równy zero lub <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="true" />.  
  
—lub— 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" />is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is ,is<see cref="P:System.Net.HttpWebRequest.ContentLength" /> -1 ,<see cref="P:System.Net.HttpWebRequest.SendChunked" /> is<see langword="false" />i is<see cref="P:System.Net.HttpWebRequest.Method" />postlubPut. <see langword="false" />  
  
—lub— 
Ma <see cref="T:System.Net.HttpWebRequest" /> treść jednostki, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> ale metoda <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> jest wywoływana bez wywoływania metody.  
  
—lub— 
Wartość <see cref="P:System.Net.HttpWebRequest.ContentLength" /> jest większa od zera, ale aplikacja nie zapisuje wszystkich przyrzeczonych danych.</exception>
        <exception cref="T:System.NotSupportedException">Moduł sprawdzania poprawności pamięci podręcznej żądań wskazywał, że odpowiedź na to żądanie może być obsługiwana z pamięci podręcznej; Jednak to żądanie zawiera dane do wysłania na serwer. Żądania, które wysyłają dane, nie mogą korzystać z pamięci podręcznej. Ten wyjątek może wystąpić, jeśli używasz niestandardowego modułu sprawdzania pamięci podręcznej, który jest niepoprawnie zaimplementowany.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" />została wcześniej wywołana.  
  
—lub— 
Limit czasu dla żądania wygasł.  
  
—lub— 
Wystąpił błąd podczas przetwarzania żądania.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy, element (Ustawienia sieci)</related>
      </Docs>
    </Member>
    <Member MemberName="HaveResponse">
      <MemberSignature Language="C#" Value="public virtual bool HaveResponse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HaveResponse" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.HaveResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HaveResponse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HaveResponse { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HaveResponse : bool" Usage="System.Net.HttpWebRequest.HaveResponse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy odebrano odpowiedź z zasobu internetowego.</summary>
        <value><see langword="true" />Jeśli odpowiedź została odebrana; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu sprawdza właściwość, <xref:System.Net.HttpWebRequest.HaveResponse%2A> aby określić, czy odebrano odpowiedź z zasobu internetowego.  
  
 [!code-cpp[Httpwebrequest_HaveResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CPP/httpwebrequest_haveresponse.cpp#1)]
 [!code-csharp[Httpwebrequest_HaveResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CS/httpwebrequest_haveresponse.cs#1)]
 [!code-vb[Httpwebrequest_HaveResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/VB/httpwebrequest_haveresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public override System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Headers As WebHeaderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::WebHeaderCollection ^ Headers { System::Net::WebHeaderCollection ^ get(); void set(System::Net::WebHeaderCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Net.WebHeaderCollection with get, set" Usage="System.Net.HttpWebRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa kolekcję par nazwa/wartość, które składają się na nagłówki HTTP.</summary>
        <value>A <see cref="T:System.Net.WebHeaderCollection" /> , który zawiera pary nazwa/wartość, które tworzą nagłówki dla żądania HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Headers%2A> Kolekcja zawiera nagłówki protokołu skojarzone z żądaniem. W poniższej tabeli wymieniono nagłówki HTTP, które nie są przechowywane w <xref:System.Net.HttpWebRequest.Headers%2A> kolekcji, ale są ustawiane przez system lub ustawione według właściwości lub metod.  
  
|nagłówek|Ustawione przez|  
|------------|------------|  
|Odebrać|Ustawiony przez <xref:System.Net.HttpWebRequest.Accept%2A> właściwość.|  
|Połączenie|Ustawiane przez <xref:System.Net.HttpWebRequest.Connection%2A> Właściwość i <xref:System.Net.HttpWebRequest.KeepAlive%2A> właściwość.|  
|Długość zawartości|Ustawiony przez <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwość.|  
|Typ zawartości|Ustawiony przez <xref:System.Net.HttpWebRequest.ContentType%2A> właściwość.|  
|Puszczać|Ustawiony przez <xref:System.Net.HttpWebRequest.Expect%2A> właściwość.|  
|Data|Ustawiony przez <xref:System.Net.HttpWebRequest.Date%2A> właściwość.|  
|Host|Ustawiony przez <xref:System.Net.HttpWebRequest.Host%2A> właściwość.|  
|If-Modified-Since|Ustawiony przez <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> właściwość.|  
|Zakres|Ustawiane przez <xref:System.Net.HttpWebRequest.AddRange%2A> metodę.|  
|Referer|Ustawiony przez <xref:System.Net.HttpWebRequest.Referer%2A> właściwość.|  
|Transfer-Encoding|Ustawiona przez <xref:System.Net.HttpWebRequest.TransferEncoding%2A> Właściwość <xref:System.Net.HttpWebRequest.SendChunked%2A> (właściwość musi mieć wartość true).|  
|User-Agent|Ustawiony przez <xref:System.Net.HttpWebRequest.UserAgent%2A> właściwość.|  
  
 Metoda zgłasza wyjątek, <xref:System.ArgumentException> Jeśli próbujesz ustawić jeden z tych chronionych nagłówków. <xref:System.Net.WebHeaderCollection.Add%2A>  
  
 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> <xref:System.Net.HttpWebRequest.GetRequestStream%2A> <xref:System.Net.HttpWebRequest.GetResponse%2A>Zmiana właściwości po uruchomieniu żądania przez wywołanie metody,, lub metoda zgłasza <xref:System.InvalidOperationException>. <xref:System.Net.HttpWebRequest.Headers%2A>  
  
 Nie należy zakładać, że wartości nagłówka pozostaną niezmienione, ponieważ serwery sieci Web i pamięci podręczne mogą zmieniać lub dodawać nagłówki do żądania sieci Web.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Net.HttpWebRequest.Headers%2A> właściwości do drukowania par nazwa/wartość nagłówka HTTP w konsoli programu.  
  
 [!code-cpp[HttpWebRequest_Headers#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Headers/CPP/httpwebrequest_headers.cpp#1)]
 [!code-csharp[HttpWebRequest_Headers#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Headers/CS/httpwebrequest_headers.cs#1)]
 [!code-vb[HttpWebRequest_Headers#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Headers/VB/httpwebrequest_headers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żądanie zostało <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />uruchomione przez wywołanie metody, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />lub <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> .</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Host" />
      <MemberSignature Language="VB.NET" Value="Public Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : string with get, set" Usage="System.Net.HttpWebRequest.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość nagłówka hosta, która będzie używana w żądaniu HTTP niezależnym od identyfikatora URI żądania.</summary>
        <value>Wartość nagłówka hosta w żądaniu HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Host%2A> Właściwość może służyć do ustawiania wartości nagłówka hosta do użycia w żądaniu HTTP niezależnym od identyfikatora URI żądania. <xref:System.Net.HttpWebRequest.Host%2A> Właściwość może składać się z nazwy hosta i opcjonalnego numeru portu. Nagłówek hosta bez informacji o porcie oznacza domyślny port dla żądanej usługi (na przykład port 80 dla adresu URL HTTP).  
  
 Format służący do określania hosta i portu musi być zgodny z regułami w sekcji 14,23 RFC2616 publikowanych przez grupę IETF. Przykład spełniający wymagania, które określają port 8080, będzie następująca wartość dla <xref:System.Net.HttpWebRequest.Host%2A> właściwości:  
  
 `www.contoso.com:8080`  
  
 <xref:System.Net.HttpWebRequest.Host%2A> Użycie właściwości w celu jawnego określenia wartości niestandardowego nagłówka hosta ma także wpływ na buforowanie obszarów, plików cookie i uwierzytelniania. Gdy aplikacja dostarcza poświadczenia dla określonego prefiksu identyfikatora URI, aplikacje muszą upewnić się, że użyto identyfikatora URI zawierającego wartość nagłówka hosta, a nie serwera docelowego w identyfikatorze URI. Klucz używany podczas buforowania zasobów przy użyciu wartości nagłówka hosta, a nie identyfikatora URI żądania. Pliki cookie są przechowywane w <xref:System.Net.CookieContainer> i logicznie pogrupowane według nazwy domeny serwera. Jeśli aplikacja określa nagłówek hosta, ta wartość zostanie użyta jako domena.  
  
 <xref:System.Net.HttpWebRequest.Host%2A> Jeśli właściwość nie jest ustawiona, wartość nagłówka hosta do użycia w żądaniu HTTP jest oparta na identyfikatorze URI żądania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Nie można ustawić nagłówka hosta na <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Dla nagłówka hosta nie można ustawić nieprawidłowej wartości.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można ustawić nagłówka hosta po tym, <see cref="T:System.Net.HttpWebRequest" /> jak już rozpoczęto wysyłanie.</exception>
      </Docs>
    </Member>
    <Member MemberName="IfModifiedSince">
      <MemberSignature Language="C#" Value="public DateTime IfModifiedSince { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime IfModifiedSince" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberSignature Language="VB.NET" Value="Public Property IfModifiedSince As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime IfModifiedSince { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.IfModifiedSince : DateTime with get, set" Usage="System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see langword="If-Modified-Since" /> nagłówka HTTP.</summary>
        <value>A <see cref="T:System.DateTime" /> , który zawiera zawartość <see langword="If-Modified-Since" /> nagłówka HTTP. Wartość domyślna to bieżąca data i godzina.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime?displayProperty=nameWithType> <xref:System.DateTimeKind.Local?displayProperty=nameWithType> Właściwośćjest<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>obiektemstandardowym i może zawierać <xref:System.DateTimeKind.Utc?displayProperty=nameWithType> pole,,lub.<xref:System.DateTimeKind?displayProperty=nameWithType> <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> Dowolny rodzaj czasu można ustawić przy użyciu <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> właściwości. Jeśli <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> jest ustawiona lub pobierana <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> , przyjmuje się, że właściwość <xref:System.DateTimeKind.Local?displayProperty=nameWithType> jest (czas lokalny).  
  
 Klasy w <xref:System.Net> przestrzeni nazw zawsze zapisują <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> właściwość w sieci podczas transmisji w standardowym formacie, używając formatu GMT (UTC).  
  
 <xref:System.DateTime.MinValue?displayProperty=nameWithType> `If-Modified-Since` <xref:System.Net.HttpWebRequest.Headers%2A> Jeśli właściwość jest ustawiona na ,<xref:System.Net.WebHeaderCollection>nagłówek HTTP zostanie usunięty z właściwości i. <xref:System.Net.HttpWebRequest.IfModifiedSince%2A>  
  
 <xref:System.DateTime.MinValue?displayProperty=nameWithType> <xref:System.Net.HttpWebRequest.Headers%2A> Jeśliwłaściwośćjest`If-Modified-Since` , oznacza to, że nagłówek HTTP nie <xref:System.Net.WebHeaderCollection>jest uwzględniony we właściwości i. <xref:System.Net.HttpWebRequest.IfModifiedSince%2A>  
  
> [!NOTE]
>  Wartość tej właściwości jest przechowywana w <xref:System.Net.WebHeaderCollection>. Jeśli jest ustawiona właściwość WebHeaderCollection, wartość właściwości zostanie utracona.  
  
   
  
## Examples  
 Poniższy przykład kodu sprawdza <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> właściwość.  
  
 [!code-cpp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CPP/httpwebrequest_ifmodifiedsince.cpp#1)]
 [!code-csharp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CS/httpwebrequest_ifmodifiedsince.cs#1)]
 [!code-vb[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/VB/httpwebrequest_ifmodifiedsince.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool with get, set" Usage="System.Net.HttpWebRequest.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy należy nawiązać trwałe połączenie z zasobem internetowym.</summary>
        <value><see langword="true" />Jeśli żądanie do zasobu internetowego powinno zawierać <see langword="Connection" /> nagłówek HTTP o wartości Keep-Alive; <see langword="false" />w przeciwnym razie. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw tę właściwość na `true` , aby `Connection` wysłać nagłówek HTTP o wartości Keep-Alive. Aplikacja używa <xref:System.Net.HttpWebRequest.KeepAlive%2A> programu, aby wskazać preferencję połączeń trwałych. Gdy właściwość ma `true`wartość, aplikacja wykonuje stałe połączenia z serwerami, które je obsługują. <xref:System.Net.HttpWebRequest.KeepAlive%2A>  
  
> [!NOTE]
>  W przypadku korzystania z protokołu HTTP/1.1 utrzymywanie aktywności jest domyślnie włączone. Ustawienie <xref:System.Net.HttpWebRequest.KeepAlive%2A> możespowodowaćwysłanienagłówkadoserwera.`false` `Connection: Close`  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia <xref:System.Net.HttpWebRequest.KeepAlive%2A> właściwość na `false` , aby uniknąć ustanowienia trwałego połączenia z zasobem internetowym.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumAutomaticRedirections">
      <MemberSignature Language="C#" Value="public int MaximumAutomaticRedirections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumAutomaticRedirections" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumAutomaticRedirections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumAutomaticRedirections { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumAutomaticRedirections : int with get, set" Usage="System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną liczbę przekierowań, która jest następująca dla żądania.</summary>
        <value>Maksymalna liczba odpowiedzi przekierowania, które są następujące po żądaniu. Wartość domyślna to 50.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość ustawia maksymalną liczbę przekierowań dla żądania, <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> Jeśli właściwość jest `true`. <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia wartość tej właściwości.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość jest równa 0 lub mniejsza.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną dozwoloną długość nagłówków odpowiedzi.</summary>
        <value>Długość nagłówków odpowiedzi wyrażona w kilobajtach (1024 bajtów).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Długość nagłówka odpowiedzi obejmuje wiersz stanu odpowiedzi i wszelkie dodatkowe znaki kontrolne, które są odbierane jako część protokołu HTTP. Wartość-1 oznacza, że w nagłówkach odpowiedzi nie nałożono limitu. wartość 0 oznacza, że wszystkie żądania kończą się niepowodzeniem.  
  
 Jeśli właściwość nie jest jawnie ustawiona, domyślnie przyjmuje wartość <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A> właściwości. <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A>  
  
 Jeśli Długość odebranego nagłówka odpowiedzi przekracza <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> wartość właściwości <xref:System.Net.HttpWebRequest.EndGetResponse%2A> , metody <xref:System.Net.WebException> lub <xref:System.Net.HttpWebRequest.GetResponse%2A> generują <xref:System.Net.WebException.Status%2A> właściwość z właściwością ustawioną na <xref:System.Net.WebExceptionStatus.MessageLengthLimitExceeded>.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia wartość tej właściwości.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Właściwość jest ustawiana po przesłaniu żądania.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość jest mniejsza od 0 i nie jest równa-1.</exception>
      </Docs>
    </Member>
    <Member MemberName="MediaType">
      <MemberSignature Language="C#" Value="public string MediaType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MediaType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MediaType" />
      <MemberSignature Language="VB.NET" Value="Public Property MediaType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MediaType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MediaType : string with get, set" Usage="System.Net.HttpWebRequest.MediaType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ nośnika żądania.</summary>
        <value>Typ nośnika żądania. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.Net.HttpWebRequest.MediaType%2A> właściwości ma wpływ na <xref:System.Net.HttpWebResponse.CharacterSet%2A> właściwość. Po ustawieniu <xref:System.Net.HttpWebRequest.MediaType%2A> w żądaniu odpowiedni typ nośnika jest wybierany z listy zestawów znaków zwracanych w nagłówku HTTP odpowiedzi `Content-type` .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public override string Method { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Method" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Method" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Method As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Method { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Method : string with get, set" Usage="System.Net.HttpWebRequest.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia metodę dla żądania.</summary>
        <value>Metoda żądania używana do kontaktowania się z zasobem internetowym. Wartość domyślna to GET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Method%2A> Właściwość można ustawić na dowolne zlecenia protokołu HTTP 1,1: GET, głowy, POST, PUT, DELETE, TRACE lub OPTIONS.  
  
 Jeśli właściwość jest ustawiona na dowolną wartość inną niż-1 <xref:System.Net.HttpWebRequest.Method%2A> , właściwość musi być ustawiona na Właściwość protokołu, która przekazuje dane. <xref:System.Net.HttpWebRequest.ContentLength%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia <xref:System.Net.HttpWebRequest.Method%2A> właściwość na wartość post.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie podano metody.  
  
 —lub—  
  
 Ciąg metody zawiera nieprawidłowe znaki.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pipelined">
      <MemberSignature Language="C#" Value="public bool Pipelined { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Pipelined" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Pipelined" />
      <MemberSignature Language="VB.NET" Value="Public Property Pipelined As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Pipelined { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Pipelined : bool with get, set" Usage="System.Net.HttpWebRequest.Pipelined" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy potoku żądanie do zasobu internetowego.</summary>
        <value><see langword="true" />Jeśli żądanie powinno być potoku; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja używa właściwości, <xref:System.Net.HttpWebRequest.Pipelined%2A> aby wskazać preferencję połączeń potokowych. Gdy <xref:System.Net.HttpWebRequest.Pipelined%2A> jest `true`to aplikacja, tworzy potokowe połączenia z serwerami, które je obsługują.  
  
 Połączenia potokowe są nawiązywane tylko wtedy <xref:System.Net.HttpWebRequest.KeepAlive%2A> , gdy właściwość `true`jest również.  
  
   
  
## Examples  
 Poniższy przykład kodu drukuje wartość <xref:System.Net.HttpWebRequest.Pipelined%2A> właściwości w konsoli programu.  
  
 [!code-cpp[HttpWebRequest_PipeLined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CPP/httpwebrequest_pipelined.cpp#1)]
 [!code-csharp[HttpWebRequest_PipeLined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CS/httpwebrequest_pipelined.cs#1)]
 [!code-vb[HttpWebRequest_PipeLined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_PipeLined/VB/httpwebrequest_pipelined.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public override bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreAuthenticate : bool with get, set" Usage="System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy ma być wysyłany nagłówek autoryzacji z żądaniem.</summary>
        <value><see langword="true" />do wysyłania nagłówka autoryzacji HTTP z żądaniami po przeprowadzeniu uwierzytelniania; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po pomyślnym uwierzytelnieniu żądania <xref:System.Uri> klienta do określonego elementu, <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> Jeśli `true` jest i są podane poświadczenia, nagłówek autoryzacji jest wysyłany do każdego żądania do <xref:System.Uri> dowolnych, które pasują do określonego <xref:System.Uri>do ostatniego ukośnika. Dlatego jeśli żądanie klienta zostało pomyślnie uwierzytelnione do określonego <xref:System.Uri> , który zawiera następujące elementy:  
  
 `http://www.contoso.com/firstpath/`  
  
 Następnie nagłówek autoryzacji dla wstępnego uwierzytelniania jest wysyłany wraz z każdym żądaniem do dowolnego z <xref:System.Uri> następujących wystąpień:  
  
 `http://www.contoso.com/firstpath/`  
  
 `http://www.contoso.com/firstpath/default`  
  
 `http://www.contoso.com/firstpath/default.html`  
  
 `http://www.contoso.com/firstpath/sample.html`  
  
 Jednak nagłówek autoryzacji nie jest wysyłany z żądaniami do żadnego z następujących <xref:System.Uri> wystąpień:  
  
 `http://www.contoso.com/`  
  
 `http://www.contoso.com/firstpath`  
  
 `http://www.contoso.com/secondpath/`  
  
 Jeśli żądanie klienta do określonego <xref:System.Uri> programu nie zostanie pomyślnie uwierzytelnione, żądanie używa standardowych procedur uwierzytelniania.  
  
 Z wyjątkiem pierwszego żądania <xref:System.Net.WebRequest.PreAuthenticate%2A> Właściwość wskazuje, czy wysyłać informacje o uwierzytelnianiu z kolejnymi żądaniami <xref:System.Uri> do obiektu, który jest zgodny z <xref:System.Uri> określoną do ostatniego ukośnika bez oczekiwania na zakwestionowana przez serwer.  
  
 Następujące okno dialogowe między klientem i serwerem ilustruje efekt tej właściwości. W oknie dialogowym założono, że uwierzytelnianie podstawowe jest w użyciu.  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A>jest `false`:  
  
 Klient: Pobierz someUrl  
  
 Server 401 WWW — uwierzytelnianie podstawowe  
  
 Klient: Pobierz z nagłówkami autoryzacji  
  
 Server 200 OK  
  
 Klient: Pobierz someUrl  
  
 Server 401 WWW — uwierzytelnianie podstawowe  
  
 Klient: Pobierz z nagłówkami autoryzacji  
  
 Server 200 OK  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A>jest `true`:  
  
 Klient: Pobierz someUrl  
  
 Server 401 WWW — uwierzytelnianie podstawowe  
  
 Klient: Pobierz z nagłówkami autoryzacji  
  
 Server 200 OK  
  
 Klient: Pobierz someUrl z nagłówkami autoryzacji  
  
 Jeśli schemat uwierzytelniania nie obsługuje wstępnego uwierzytelniania, wartość tej właściwości jest ignorowana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolVersion : Version with get, set" Usage="System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wersję protokołu HTTP, która ma być używana dla żądania.</summary>
        <value>Wersja protokołu HTTP do użycia w żądaniu. Wartość domyślna to <see cref="F:System.Net.HttpVersion.Version11" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest> Klasa obsługuje tylko wersje 1,0 i 1,1 protokołu HTTP. Ustawienie <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> innej wersji zgłasza wyjątek.  
  
> [!NOTE]
>  Aby ustawić wersję protokołu HTTP bieżącego żądania, użyj <xref:System.Net.HttpVersion.Version10> pól <xref:System.Net.HttpVersion> i <xref:System.Net.HttpVersion.Version11> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> właściwość.  
  
 [!code-cpp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CPP/httpwebrequest_protocolversion.cpp#1)]
 [!code-csharp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CS/httpwebrequest_protocolversion.cs#1)]
 [!code-vb[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/VB/httpwebrequest_protocolversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wersja protokołu HTTP jest ustawiona na wartość inną niż 1,0 lub 1,1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Proxy : System.Net.IWebProxy with get, set" Usage="System.Net.HttpWebRequest.Proxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje o serwerze proxy dla żądania.</summary>
        <value><see cref="T:System.Net.IWebProxy" /> Obiekt, który ma być używany do proxy żądania. Wartość domyślna jest ustawiana przez wywołanie <see cref="P:System.Net.GlobalProxySelection.Select" /> właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość identyfikuje obiekt, <xref:System.Net.WebProxy> który ma być używany do przetwarzania żądań do zasobów internetowych. <xref:System.Net.HttpWebRequest.Proxy%2A> Aby określić, że żaden serwer proxy nie powinien być używany <xref:System.Net.HttpWebRequest.Proxy%2A> , należy ustawić właściwość na wystąpienie serwera proxy <xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A?displayProperty=nameWithType> zwrócone przez metodę.  
  
 Plik konfiguracji komputera lokalnego lub aplikacji może określać, że zostanie użyty domyślny serwer proxy. Jeśli właściwość jest określona, ustawienia serwera proxy <xref:System.Net.HttpWebRequest.Proxy%2A> z właściwości przesłaniają plik konfiguracji komputera lokalnego lub <xref:System.Net.HttpWebRequest> aplikacji, a wystąpienie będzie używać określonych ustawień serwera proxy. <xref:System.Net.HttpWebRequest.Proxy%2A> Jeśli w pliku konfiguracji nie określono żadnego serwera proxy <xref:System.Net.HttpWebRequest.Proxy%2A> <xref:System.Net.HttpWebRequest> , a właściwość nie zostanie określona, Klasa używa ustawień serwera proxy dziedziczonych z programu Internet Explorer na komputerze lokalnym. Jeśli nie ma żadnych ustawień serwera proxy w programie Internet Explorer, żądanie jest wysyłane bezpośrednio na serwer.  
  
 <xref:System.Net.HttpWebRequest> Klasa analizuje listę pomijania proxy z symbolami wieloznacznymi dziedziczonymi z programu Internet Explorer tak samo, jak Lista pomijania jest analizowana bezpośrednio przez program Internet Explorer. Na przykład <xref:System.Net.HttpWebRequest> Klasa przeanalizuje listę pomijania "NT *" z programu Internet Explorer jako wyrażenie regularne "NT.\*". Dlatego adres URL "`http://nt.com`" spowoduje ominięcie serwera proxy <xref:System.Net.HttpWebRequest> przy użyciu klasy i programu Internet Explorer.  
  
 <xref:System.Net.HttpWebRequest> Klasa obsługuje obejście lokalnego serwera proxy. Klasa traktuje miejsce docelowe jako lokalne w przypadku spełnienia dowolnego z następujących warunków:  
  
-   Lokalizacja docelowa zawiera nazwę płaską (bez kropek w adresie URL).  
  
-   Lokalizacja docelowa zawiera adres sprzężenia <xref:System.Net.IPAddress.IPv6Loopback>zwrotnego (<xref:System.Net.IPAddress.Loopback> lub) <xref:System.Net.IPAddress> lub miejsce docelowe zawiera przypisane do komputera lokalnego.  
  
-   Sufiks domeny miejsca docelowego jest zgodny z sufiksem domeny komputera lokalnego (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>).  
  
 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> Zmianawłaściwościpouruchomieniu<xref:System.InvalidOperationException>żądania przez <xref:System.Net.HttpWebRequest.GetRequestStream%2A>wywołanie metody,, <xref:System.Net.HttpWebRequest.GetResponse%2A>lub powoduje wyrzucanie. <xref:System.Net.HttpWebRequest.Proxy%2A> Aby uzyskać informacje na temat elementu proxy, zobacz [ \&lt\&; defaultProxy gt; — Element (Ustawienia sieci)](~/docs/framework/configure-apps/file-schema/network/defaultproxy-element-network-settings.md).  
  
   
  
## Examples  
 Poniższy przykład kodu używa metody, <xref:System.Net.HttpWebRequest.Proxy%2A> Aby uzyskać informacje o serwerze proxy dla żądania.  
  
 [!code-cpp[Httpwebrequest_proxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_proxy/CPP/httpwebrequest_proxy.cpp#1)]
 [!code-csharp[Httpwebrequest_proxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_proxy/CS/httpwebrequest_proxy.cs#1)]
 [!code-vb[Httpwebrequest_proxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_proxy/VB/httpwebrequest_proxy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.HttpWebRequest.Proxy" />jest ustawiony na <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Żądanie zostało uruchomione przez <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />wywołanie, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, lub <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma uprawnienia do wymaganej operacji.</exception>
        <permission cref="T:System.Net.WebPermission">W celu uzyskania lub ustawienia <see cref="P:System.Net.HttpWebRequest.Proxy" /> właściwości. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy, element (Ustawienia sieci)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/bb707c72-eed2-4a82-8800-c9e68df2fd4f">Konfigurowanie aplikacji internetowych</related>
        <related type="Article" href="https://msdn.microsoft.com/library/353c0a8b-4cee-44f6-8e65-60e286743df9">Konfiguracja serwera proxy</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fcd9c3bd-93de-4c92-8ff3-837327ad18de">Automatyczne wykrywanie serwera proxy</related>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadWriteTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia limit czasu w milisekundach podczas zapisywania lub odczytywania ze strumienia.</summary>
        <value>Liczba milisekund przed upływem limitu czasu zapisu lub odczytu. Wartość domyślna to 300 000 milisekund (5 minut).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest używana podczas zapisywania do strumienia zwróconego <xref:System.Net.HttpWebRequest.GetRequestStream%2A> przez metodę lub odczytywania ze strumienia zwróconego przez <xref:System.Net.HttpWebResponse.GetResponseStream%2A> metodę. <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>  
  
 Właściwość określa limit czasu <xref:System.IO.Stream.Read%2A> dla metody, która jest używana do odczytu strumienia zwróconego przez <xref:System.Net.HttpWebResponse.GetResponseStream%2A> metodę i dla <xref:System.IO.Stream.Write%2A> metody, która jest używana do zapisu w strumieniu zwracanym przez <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> <xref:System.Net.HttpWebRequest.GetRequestStream%2A>Metoda.  
  
 Aby określić czas oczekiwania na zakończenie żądania, użyj <xref:System.Net.HttpWebRequest.Timeout%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> jak ustawić właściwość.  
  
 [!code-csharp[Classic HttpWebRequest Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żądanie zostało już wysłane.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość określona dla operacji zestawu jest mniejsza lub równa zero i nie jest równa<see cref="F:System.Threading.Timeout.Infinite" /></exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="Referer">
      <MemberSignature Language="C#" Value="public string Referer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Referer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Referer" />
      <MemberSignature Language="VB.NET" Value="Public Property Referer As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Referer { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Referer : string with get, set" Usage="System.Net.HttpWebRequest.Referer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see langword="Referer" /> nagłówka HTTP.</summary>
        <value>Wartość <see langword="Referer" /> nagłówka HTTP. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwość jest `true` ,<xref:System.Net.HttpWebRequest.Referer%2A> właściwość jest ustawiana automatycznie podczas przekierowywania żądania do innej lokacji. <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A>  
  
 Aby wyczyścić `Referer` nagłówek HTTP, <xref:System.Net.HttpWebRequest.Referer%2A> ustaw właściwość na `null`.  
  
> [!NOTE]
>  Wartość tej właściwości jest przechowywana w <xref:System.Net.WebHeaderCollection>. Jeśli jest ustawiona właściwość WebHeaderCollection, wartość właściwości zostanie utracona.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia <xref:System.Net.HttpWebRequest.Referer%2A> właściwość.  
  
 [!code-cpp[HttpWebRequest_Referer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Referer/CPP/httpwebrequest_referer.cpp#1)]
 [!code-csharp[HttpWebRequest_Referer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Referer/CS/httpwebrequest_referer.cs#1)]
 [!code-vb[HttpWebRequest_Referer#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Referer/VB/httpwebrequest_referer.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestUri">
      <MemberSignature Language="C#" Value="public override Uri RequestUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri RequestUri" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.RequestUri" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RequestUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Uri ^ RequestUri { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestUri : Uri" Usage="System.Net.HttpWebRequest.RequestUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera oryginalny Uniform Resource Identifier (URI) żądania.</summary>
        <value>A <see cref="T:System.Uri" /> , który zawiera identyfikator URI zasobu internetowego przesłanego <see cref="M:System.Net.WebRequest.Create(System.String)" /> do metody.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt przeszedł przez wywołanie metody <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>. <xref:System.Net.HttpWebRequest> <xref:System.Uri>  
  
 Następujący nagłówek przekierowania nie zmienia <xref:System.Net.HttpWebRequest.RequestUri%2A> właściwości. Aby uzyskać rzeczywisty identyfikator URI, który odpowiedział na żądanie, zapoznaj się <xref:System.Net.HttpWebRequest.Address%2A> z właściwością.  
  
   
  
## Examples  
 Poniższy przykład kodu sprawdza, <xref:System.Net.HttpWebRequest> czy obiekt `req` został przekierowany do innej lokalizacji w celu spełnienia żądania, i `hasChanged` ustawia wartość zmiennej na `true` Jeśli żądanie zostało przekierowane; w przeciwnym razie `hasChanged` jest ustawiony na `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendChunked">
      <MemberSignature Language="C#" Value="public bool SendChunked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SendChunked" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SendChunked" />
      <MemberSignature Language="VB.NET" Value="Public Property SendChunked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SendChunked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SendChunked : bool with get, set" Usage="System.Net.HttpWebRequest.SendChunked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy dane mają być wysyłane w ramach segmentów do zasobu internetowego.</summary>
        <value><see langword="true" />Aby wysłać dane do zasobu internetowego z segmentów; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W takim przypadku <xref:System.Net.HttpWebRequest.SendChunked%2A> żądanie wysyła dane do zasobu internetowego z segmentów. `true` Zasób internetowy musi obsługiwać otrzymywanie fragmentów danych.  
  
 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> Zmianawłaściwościpouruchomieniu<xref:System.InvalidOperationException>żądania przez <xref:System.Net.HttpWebRequest.GetRequestStream%2A>wywołanie metody,, <xref:System.Net.HttpWebRequest.GetResponse%2A>lub powoduje wyrzucanie. <xref:System.Net.HttpWebRequest.SendChunked%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia <xref:System.Net.HttpWebRequest.SendChunked%2A> właściwość na `true` tak, aby dane mogły być wysyłane w segmentach do zasobu internetowego.  
  
 [!code-cpp[HttpWebRequest_SendChunked#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CPP/httpwebrequest_sendchunked.cpp#2)]
 [!code-csharp[HttpWebRequest_SendChunked#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CS/httpwebrequest_sendchunked.cs#2)]
 [!code-vb[HttpWebRequest_SendChunked#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_SendChunked/VB/httpwebrequest_sendchunked.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żądanie zostało <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />uruchomione przez wywołanie metody, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />lub <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> .</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia funkcję wywołania zwrotnego w celu zweryfikowania certyfikatu serwera.</summary>
        <value>Funkcja wywołania zwrotnego służąca do weryfikowania certyfikatu serwera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartością domyślną jest to, że żadna funkcja wywołania zwrotnego <xref:System.Net.HttpWebRequest.ServerCertificateValidationCallback%2A> nie jest `null`ustawiona i właściwość jest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServicePoint">
      <MemberSignature Language="C#" Value="public System.Net.ServicePoint ServicePoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ServicePoint ServicePoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServicePoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServicePoint As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ServicePoint ^ ServicePoint { System::Net::ServicePoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServicePoint : System.Net.ServicePoint" Usage="System.Net.HttpWebRequest.ServicePoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera punkt usługi do użycia dla żądania.</summary>
        <value><see cref="T:System.Net.ServicePoint" /> Reprezentuje połączenie sieciowe z zasobem internetowym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość może się różnić od <xref:System.Net.HttpWebRequest.Address%2A?displayProperty=nameWithType> tego, czy żądanie jest przekierowywane. <xref:System.Net.ServicePoint.Address%2A?displayProperty=nameWithType>  
  
   
  
## Examples  
 [!code-cpp[System.Net.ServicePoint#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#6)]
 [!code-csharp[System.Net.ServicePoint#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#6)]
 [!code-vb[System.Net.ServicePoint#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsCookieContainer">
      <MemberSignature Language="C#" Value="public virtual bool SupportsCookieContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsCookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsCookieContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsCookieContainer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsCookieContainer : bool" Usage="System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy żądanie zapewnia pomoc techniczną dla elementu <see cref="T:System.Net.CookieContainer" />.</summary>
        <value><see langword="true" />Jeśli żądanie zapewnia pomoc techniczną dla <see cref="T:System.Net.CookieContainer" />a; <see langword="false" />w przeciwnym razie.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="serializationInfo"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> Do wypełnienia danymi.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> określa miejsce docelowe dla tej serializacji.</param>
        <summary><see cref="T:System.Runtime.Serialization.SerializationInfo" /> Wypełnia dane, które są konieczne do serializacji obiektu docelowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie obiekty zawarte w <xref:System.Runtime.Serialization.SerializationInfo> elemencie są automatycznie śledzone i serializowane przez program formatujący.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public override int Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Timeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Timeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Timeout : int with get, set" Usage="System.Net.HttpWebRequest.Timeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość limitu czasu w milisekundach dla <see cref="M:System.Net.HttpWebRequest.GetResponse" /> metod i. <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /></summary>
        <value>Liczba milisekund oczekiwania przed upływem limitu czasu żądania. Wartość domyślna to 100 000 milisekund (100 s).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Timeout%2A>jest to liczba milisekund, przez jaką kolejne żądanie synchroniczne wykonane z <xref:System.Net.HttpWebRequest.GetResponse%2A> metodą czeka na odpowiedź, <xref:System.Net.HttpWebRequest.GetRequestStream%2A> a metoda czeka na strumień. Dotyczy całego żądania i odpowiedzi, <xref:System.Net.HttpWebRequest.GetRequestStream%2A> a nie osobno dla wywołań metod i <xref:System.Net.HttpWebRequest.GetResponse%2A>. <xref:System.Net.HttpWebRequest.Timeout%2A> Jeśli zasób nie zostanie zwrócony w określonym limicie czasu, żądanie wygeneruje <xref:System.Net.WebException> <xref:System.Net.WebException.Status%2A> właściwość z ustawioną na <xref:System.Net.WebExceptionStatus.Timeout?displayProperty=nameWithType>.  
  
 Właściwość musi być ustawiona <xref:System.Net.HttpWebRequest.GetRequestStream%2A> przed wywołaniem metody <xref:System.Net.HttpWebRequest.GetResponse%2A>or. <xref:System.Net.HttpWebRequest.Timeout%2A> Zmiana właściwości po <xref:System.Net.HttpWebRequest.GetRequestStream%2A> wywołaniu metody lub <xref:System.Net.HttpWebRequest.GetResponse%2A> nie ma żadnego skutku <xref:System.Net.HttpWebRequest.Timeout%2A>  
  
 Właściwość nie ma wpływu na żądania asynchroniczne wykonane <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> przy użyciu metody or <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>. <xref:System.Net.HttpWebRequest.Timeout%2A>  
  
> [!CAUTION]
>  W przypadku żądań asynchronicznych aplikacja kliencka implementuje własny mechanizm przekroczenia limitu czasu. Zapoznaj się z przykładem <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> w metodzie.  
  
 Aby określić czas oczekiwania przed upływem limitu czasu operacji odczytu lub zapisu, użyj <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> właściwości.  
  
 Zwracanie lub przekroczenie limitu czasu zapytania systemu nazw domen (DNS) może potrwać do 15 sekund. Jeśli żądanie zawiera nazwę hosta, która wymaga rozwiązania i ma ustawioną <xref:System.Net.FileWebRequest.Timeout%2A> wartość mniejszą niż 15 sekund, może upłynąć 15 sekund lub więcej <xref:System.Net.WebException> zanim zostanie zgłoszony limit czasu żądania.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia <xref:System.Net.HttpWebRequest.Timeout%2A> Właściwość <xref:System.Net.HttpWebRequest> obiektu.  
  
 [!code-cpp[HttpWebRequest_Timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CPP/httpwebrequest_timeout.cpp#1)]
 [!code-csharp[HttpWebRequest_Timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CS/httpwebrequest_timeout.cs#1)]
 [!code-vb[HttpWebRequest_Timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Timeout/VB/httpwebrequest_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Określona wartość jest mniejsza od zera i nie <see cref="F:System.Threading.Timeout.Infinite" />jest.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransferEncoding">
      <MemberSignature Language="C#" Value="public string TransferEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransferEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.TransferEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransferEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransferEncoding : string with get, set" Usage="System.Net.HttpWebRequest.TransferEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see langword="Transfer-encoding" /> nagłówka HTTP.</summary>
        <value>Wartość <see langword="Transfer-encoding" /> nagłówka HTTP. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed ustawieniem <xref:System.Net.HttpWebRequest.TransferEncoding%2A> właściwości należy najpierw <xref:System.Net.HttpWebRequest.SendChunked%2A> ustawić właściwość na `true`. Czyszczenie <xref:System.Net.HttpWebRequest.TransferEncoding%2A> przez ustawienie go na `null` nie ma <xref:System.Net.HttpWebRequest.SendChunked%2A>wpływu na wartość.  
  
 Wartości przypisane do <xref:System.Net.HttpWebRequest.TransferEncoding%2A> właściwości zastępują wszystkie istniejące zawartość.  
  
> [!NOTE]
>  Wartość tej właściwości jest przechowywana w <xref:System.Net.WebHeaderCollection>. Jeśli jest ustawiona właściwość WebHeaderCollection, wartość właściwości zostanie utracona.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Net.HttpWebRequest.TransferEncoding" />jest ustawiony, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> gdy <see langword="false" />ma wartość.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Net.HttpWebRequest.TransferEncoding" />jest ustawiona na wartość "fragmentaryczne".</exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeAuthenticatedConnectionSharing : bool with get, set" Usage="System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy ma być dozwolone udostępnianie połączenia o dużej szybkości przez uwierzytelnianie NTLM.</summary>
        <value><see langword="true" />Aby można było otworzyć uwierzytelnione połączenie; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość domyślna tej właściwości to `false`, co powoduje zamknięcie bieżącego połączenia po zakończeniu żądania. Aplikacja musi przechodzić przez sekwencję uwierzytelniania za każdym razem, gdy wystawia nowe żądanie.  
  
 Jeśli ta właściwość jest ustawiona na `true`, połączenie używane do pobrania odpowiedzi pozostaje otwarte po przeprowadzeniu uwierzytelniania. W takim przypadku inne żądania, które mają tę właściwość ustawioną `true` , mogą używać połączenia bez ponownego uwierzytelniania. Innymi słowy, jeśli połączenie zostało uwierzytelnione dla użytkownika A, użytkownik B może ponownie użyć połączenia; żądanie użytkownika B jest spełnione na podstawie poświadczeń użytkownika A.  
  
> [!CAUTION]
>  Ze względu na to, że aplikacja może korzystać z połączenia bez uwierzytelniania, należy się upewnić, że w systemie nie ma żadnych luk w zabezpieczeniach podczas ustawiania tej właściwości `true`na. Jeśli aplikacja wysyła żądania dla wielu użytkowników (personifikuje wiele kont użytkowników) i korzysta z uwierzytelniania w celu ochrony zasobów, nie należy ustawiać tej właściwości `true` , chyba że używasz grup połączeń zgodnie z poniższym opisem.  
  
 Warto rozważyć włączenie tego mechanizmu, jeśli występują problemy z wydajnością, a aplikacja jest uruchomiona na serwerze sieci Web ze zintegrowanym uwierzytelnianiem systemu Windows.  
  
 Włączenie tego ustawienia powoduje otwarcie systemu pod kątem zagrożeń bezpieczeństwa. Jeśli ustawisz właściwość <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> , aby `true` zachować następujące środki ostrożności:  
  
-   Użyj właściwości <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> , aby zarządzać połączeniami dla różnych użytkowników. Pozwala to uniknąć potencjalnego użycia połączenia przez aplikacje nieuwierzytelnione. Na przykład użytkownik A powinien mieć unikatową nazwę grupy połączeń, która różni się od użytkownika B. Zapewnia to warstwę izolacji dla każdego konta użytkownika.  
  
-   Uruchom aplikację w chronionym środowisku, aby uniknąć możliwych luk w zabezpieczeniach.  
  
 Jeśli kontrolujesz serwer zaplecza, możesz rozważyć wyłączenie trwałości uwierzytelniania. Zwiększa to wydajność w mniejszym stopniu, ale jest bezpiecznie. Aby uzyskać więcej informacji, wyszukaj AuthPersistence w bibliotece MSDN pod adresem [http://msdn.microsoft.com/library](https://msdn.microsoft.com/library).  
  
> [!NOTE]
>  Jeśli obie <xref:System.Net.WebRequest.PreAuthenticate%2A> i <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> są ustawione na `true`, każde żądanie jest wysyłane przy użyciu połączenia z puli niebezpiecznej, ale z nagłówkiem autoryzacji.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Ustawienie tej właściwości wymaga nieograniczonego uprawnienia sieci Web.</permission>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public override bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDefaultCredentials : bool with get, set" Usage="System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określającą, czy domyślne poświadczenia są wysyłane z żądaniami.</summary>
        <value><see langword="true" />Jeśli są używane poświadczenia domyślne; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw tę właściwość na `true` , gdy żądania wysyłane przez <xref:System.Net.HttpWebRequest> ten obiekt powinny być uwierzytelniane przy użyciu poświadczeń aktualnie zalogowanego użytkownika. W przypadku aplikacji klienckich jest to odpowiednie zachowanie w większości scenariuszy. W przypadku aplikacji warstwy środkowej, takich jak aplikacje ASP.NET, zamiast używać tej właściwości, zazwyczaj <xref:System.Net.HttpWebRequest.Credentials%2A> właściwość jest ustawiana na poświadczenia klienta, na którym jest wykonywane żądanie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę ustawienia tej właściwości po wysłaniu żądania.</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string with get, set" Usage="System.Net.HttpWebRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see langword="User-agent" /> nagłówka HTTP.</summary>
        <value>Wartość <see langword="User-agent" /> nagłówka HTTP. Wartość domyślna to <see langword="null" />.  
  
 <block subset="none" type="note"><para>  
 Wartość tej właściwości jest przechowywana w <see cref="T:System.Net.WebHeaderCollection" />. Jeśli jest ustawiona właściwość WebHeaderCollection, wartość właściwości zostanie utracona.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu ustawia <xref:System.Net.HttpWebRequest.UserAgent%2A> właściwość.  
  
 [!code-cpp[HttpWebRequest_UserAgent#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CPP/httpwebrequest_useragent.cpp#1)]
 [!code-csharp[HttpWebRequest_UserAgent#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CS/httpwebrequest_useragent.cs#1)]
 [!code-vb[HttpWebRequest_UserAgent#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_UserAgent/VB/httpwebrequest_useragent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="HttpWebRequest" FullName="System.Net.HttpWebRequest">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6a8c953b532e2389d356fb8f2c978d8f6603a6dd" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39733119" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HttpWebRequest : System.Net.WebRequest, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable HttpWebRequest extends System.Net.WebRequest implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpWebRequest" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpWebRequest&#xA;Inherits WebRequest&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpWebRequest : System::Net::WebRequest, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type HttpWebRequest = class&#xA;    inherit WebRequest&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.WebRequest</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Runtime.CompilerServices.FriendAccessAllowed</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia implementację specyficzne dla protokołu HTTP z <see cref="T:System.Net.WebRequest" /> klasy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest> Klasy zapewnia obsługę właściwości i metody zdefiniowane w <xref:System.Net.WebRequest> oraz dodatkowe właściwości i metod, które umożliwiają użytkownikowi bezpośrednią interakcję z serwerami przy użyciu protokołu HTTP.  
  
 Nie używaj <xref:System.Net.HttpWebRequest.%23ctor%2A> konstruktora. Użyj <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType> metodę, aby zainicjować nowe <xref:System.Net.HttpWebRequest> obiektów. Jeśli schemat dla jednolity identyfikator zasobów (URI) jest `http://` lub `https://`, <xref:System.Net.WebRequest.Create%2A> zwraca <xref:System.Net.HttpWebRequest> obiektu.  
  
 <xref:System.Net.HttpWebRequest.GetResponse%2A> Metoda żąda synchroniczne do zasobu, określony w <xref:System.Net.HttpWebRequest.RequestUri%2A> właściwości i zwraca <xref:System.Net.HttpWebResponse> zawierającą obiekt odpowiedzi. Dane odpowiedzi mogą być odbierane za pomocą Strumień zwrócony przez <xref:System.Net.HttpWebResponse.GetResponseStream%2A>. Jeśli obiekt odpowiedzi lub w strumieniu odpowiedzi jest zamknięte, pozostałych danych zostanie utracona. Pozostałe dane zostaną opróżnione gniazda. zostanie ona ponownie używane dla kolejnych żądań przy zamykaniu obiekt odpowiedzi lub strumienia, jeśli mają następujące warunki: jest to żądanie keep-alive lub działających w trybie potokowym, tylko niewielką ilość danych musi zostać odebrana, lub pozostałych danych odbieranych w małych interwale. Jeśli żaden z warunków wymienionych przechowywania lub podczas opróżniania zostanie przekroczony, zostaną zamknięte gniazda. Połączenia keep-alive lub działających w trybie potokowym zaleca się że aplikacja odczytuje strumienie aż do końca pliku. Daje to gwarancję, że gniazdo będzie ponownie używane dla kolejnych żądań, co w lepszej wydajności, a zasoby używane.  
  
 Jeśli chcesz wysyłać dane do zasobu, <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metoda zwraca <xref:System.IO.Stream> obiekt ma być używany do przesyłania danych. <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> i <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> metody udostępnienia asynchronicznego wysyłania strumienia danych.  
  
 Do uwierzytelniania klientów za pomocą <xref:System.Net.HttpWebRequest>, musi być zainstalowany certyfikat klienta w mojej magazynu certyfikatów bieżącego użytkownika.  
  
 <xref:System.Net.HttpWebRequest> Klasy zgłasza <xref:System.Net.WebException> gdy wystąpi błąd podczas uzyskiwania dostępu do zasobu. <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> Właściwość zawiera <xref:System.Net.WebExceptionStatus> wartość, która wskazuje przyczynę błędu. Gdy <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> jest <xref:System.Net.WebExceptionStatus.ProtocolError?displayProperty=nameWithType>, <xref:System.Net.WebException.Response%2A> właściwość zawiera <xref:System.Net.HttpWebResponse> otrzymane od zasobu.  
  
 <xref:System.Net.HttpWebRequest> przedstawia typowe wartości nagłówka HTTP wysyłane do zasobu internetowego jako właściwości, ustawić, metody lub ustawiony przez system; Poniższa tabela zawiera pełną listę. Możesz ustawić innych nagłówków w <xref:System.Net.HttpWebRequest.Headers%2A> właściwość jako pary nazwa/wartość. Należy pamiętać, że serwery i pamięci podręczne mogą zmienić lub dodać nagłówków podczas żądania.  
  
 W poniższej tabeli wymieniono nagłówki HTTP, które są ustawiane przez właściwości lub metody lub systemu.  
  
|nagłówek|Ustawione przez|  
|------------|------------|  
|Zaakceptuj|Ustawione przez <xref:System.Net.HttpWebRequest.Accept%2A> właściwości.|  
|połączenia|Ustawione przez <xref:System.Net.HttpWebRequest.Connection%2A> właściwości <xref:System.Net.HttpWebRequest.KeepAlive%2A> właściwości.|  
|Długość zawartości|Ustawione przez <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości.|  
|Typ zawartości|Ustawione przez <xref:System.Net.HttpWebRequest.ContentType%2A> właściwości.|  
|Oczekiwane|Ustawione przez <xref:System.Net.HttpWebRequest.Expect%2A> właściwości.|  
|Data|Ustawiony przez system do bieżącej daty.|  
|Host|Ustawiony przez system do aktualnych informacji hosta.|  
|If-Modified-Since|Ustawione przez <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> właściwości.|  
|Zakres|Ustawione przez <xref:System.Net.HttpWebRequest.AddRange%2A> metody.|  
|Odnośnik|Ustawione przez <xref:System.Net.HttpWebRequest.Referer%2A> właściwości.|  
|Transfer-Encoding|Ustawione przez <xref:System.Net.HttpWebRequest.TransferEncoding%2A> właściwości ( <xref:System.Net.HttpWebRequest.SendChunked%2A> właściwość musi być `true`).|  
|Agent użytkownika|Ustawione przez <xref:System.Net.HttpWebRequest.UserAgent%2A> właściwości.|  
  
> [!NOTE]
>  <xref:System.Net.HttpWebRequest> automatycznie jest zarejestrowany. Nie trzeba wywoływać <xref:System.Net.WebRequest.RegisterPrefix%2A> metodę, aby zarejestrować <xref:System.Net.HttpWebRequest?displayProperty=nameWithType> przed rozpoczęciem korzystania z identyfikatorów URI począwszy od `http://` lub `https://`.  
  
 Komputer lokalny lub pliku konfiguracji aplikacji może określić, że używane domyślny serwer proxy. Jeśli <xref:System.Net.HttpWebRequest.Proxy%2A> właściwość zostanie określona, następnie ustawienia serwera proxy z <xref:System.Net.HttpWebRequest.Proxy%2A> właściwości zastąpienia komputera lokalnego lub pliku konfiguracji aplikacji i <xref:System.Net.HttpWebRequest> wystąpienia użyje określone ustawienia serwera proxy. Jeśli żaden serwer proxy jest określona w pliku konfiguracji i <xref:System.Net.HttpWebRequest.Proxy%2A> właściwość jest nieokreślony, <xref:System.Net.HttpWebRequest> klasa używa ustawień serwera proxy dziedziczone z programu Internet Explorer na komputerze lokalnym. Jeśli nie istnieją żadne ustawienia serwera proxy w programie Internet Explorer, żądanie jest wysyłane bezpośrednio do serwera.  
  
 <xref:System.Net.HttpWebRequest> Klasy analizuje listy obejścia serwera proxy z symbolami wieloznacznymi dziedziczone z programu Internet Explorer inaczej niż lista pomijania jest analizowany bezpośrednio przez program Internet Explorer. Na przykład <xref:System.Net.HttpWebRequest> klasy będzie analizować listę obejścia "nt *" w programie Internet Explorer jako wyrażenie regularne "nt. $". To różni się od natywnych zachowania programu Internet Explorer. Dlatego adres URL "`http://intxxxxx`" spowoduje obejścia serwera proxy przy użyciu <xref:System.Net.HttpWebRequest> klasy, ale nie spowoduje obejścia serwera proxy, za pomocą programu Internet Explorer.  
  
> [!NOTE]
>  Struktura buforuje sesji protokołu SSL, ponieważ są one tworzone i podejmie próbę ponownego użycia pamięci podręcznej sesji dla nowego żądania, jeśli jest to możliwe. Podczas próby ponownego użycia sesji SSL, struktura używa pierwszego elementu <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (jeśli istnieje), lub spróbuje ponownie użyć sesji anonimowe, jeśli <xref:System.Net.HttpWebRequest.ClientCertificates%2A> jest pusty.  
  
> [!NOTE]
>  Ze względów bezpieczeństwa pliki cookie są domyślnie wyłączone. Używanie plików cookie, należy użyć <xref:System.Net.HttpWebRequest.CookieContainer%2A> właściwość, aby włączyć obsługę plików cookie.  
  
 .NET Framework 4.6 zawiera nową funkcję zabezpieczeń, która blokuje szyfrowania niezabezpieczone i algorytmy dla połączeń wyznaczania wartości skrótu. Aplikacje za pomocą protokołów TLS/SSL za pośrednictwem interfejsów API, takich jak HttpClient HttpWebRequest, FTPClient, SmtpClient, SslStream, itp. i przeznaczonych dla platformy .NET Framework 4.6 uzyskać bardziej bezpieczne zachowanie domyślne.  
  
 Deweloperzy mogą chcą zrezygnować z tego zachowania, aby zapewnić współdziałanie z ich istniejących SSL3 usług lub TLS z usług RC4. [W tym artykule](https://support.microsoft.com/kb/3069494) wyjaśnia, jak zmodyfikować kod, tak, aby nowe zachowanie jest wyłączona.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Net.HttpWebRequest> dla identyfikatora URI http://www.contoso.com/.  
  
 [!code-cpp[Classic HttpWebRequest Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.WebPermission">Aby uzyskać dostęp do żądanego identyfikatora URI lub dowolny identyfikator URI, do którego kierowane jest żądanie. Wyliczenie skojarzone: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.HttpWebRequest" /> klasy. Te konstruktory są przestarzałe; zobacz sekcję Spostrzeżenia, aby uzyskać szczegółowe informacje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Zarówno <xref:System.Net.HttpWebRequest> konstruktory są przestarzałe i nie powinna być używana. Wywołaj <xref:System.Net.WebRequest.CreateHttp%2A?displayProperty=nameWithType> metodę, aby zainicjować nowe <xref:System.Net.HttpWebRequest> obiektów.     
  
      ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.HttpWebRequest" /> klasy. Ten konstruktor jest przestarzały.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : Uri -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest uri" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HttpWebRequest (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HttpWebRequest(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> obiekt, który zawiera informacje wymagane do serializacji nowej <see cref="T:System.Net.HttpWebRequest" /> obiektu.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> obiekt, który zawiera źródłowe i docelowe serializowanym strumieniu skojarzone z nowym <see cref="T:System.Net.HttpWebRequest" /> obiektu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.HttpWebRequest" /> klasy z określonego wystąpienia <see cref="T:System.Runtime.Serialization.SerializationInfo" /> i <see cref="T:System.Runtime.Serialization.StreamingContext" /> klasy. Ten konstruktor jest przestarzały.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikację należy uruchomić w trybie pełnego zaufania, korzystając z serializacji.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Aby uzyskać nieograniczony dostęp do zasobów sieciowych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public override void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Abort();" />
      <MemberSignature Language="F#" Value="override this.Abort : unit -&gt; unit" Usage="httpWebRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anuluje żądanie do zasobu internetowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Abort%2A> Metoda anuluje żądanie do zasobu. Po żądanie zostało anulowane, wywołanie <xref:System.Net.HttpWebRequest.GetResponse%2A>, <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.EndGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, lub <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> powoduje, że metoda <xref:System.Net.WebException> z <xref:System.Net.WebException.Status%2A> właściwością <xref:System.Net.WebExceptionStatus.RequestCanceled>.  
  
 <xref:System.Net.HttpWebRequest.Abort%2A> Metoda synchronicznie wykona wywołanie zwrotne, aby określić <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> lub <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metody Jeśli <xref:System.Net.HttpWebRequest.Abort%2A> metoda jest wywoływana, gdy dowolna z tych operacji istnieją zaległe. Może to prowadzić do potencjalnych problemów zakleszczenia.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci](http://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 W przypadku żądań asynchronicznych jest odpowiedzialny za aplikacja kliencka, aby zaimplementować własny mechanizm limitu czasu. Poniższy przykład kodu pokazuje, jak to zrobić.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public string Accept { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Accept" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Property Accept As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Accept { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Accept : string with get, set" Usage="System.Net.HttpWebRequest.Accept" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see langword="Accept" /> nagłówka HTTP.</summary>
        <value>Wartość <see langword="Accept" /> nagłówka HTTP. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby wyczyścić `Accept` Ustaw nagłówek HTTP <xref:System.Net.HttpWebRequest.Accept%2A> właściwość `null`.  
  
> [!NOTE]
>  Wartość tej właściwości jest przechowywana w <xref:System.Net.WebHeaderCollection>. Jeśli ustawiono WebHeaderCollection, wartość właściwości zostaną utracone.  
  
   
  
## Examples  
 Poniższy kod ustawia przykład <xref:System.Net.HttpWebRequest.Accept%2A> właściwości.  
  
 [!code-cpp[HttpWebRequest_Accept#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Accept/CPP/httpwebrequest_accept.cpp#1)]
 [!code-csharp[HttpWebRequest_Accept#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Accept/CS/httpwebrequest_accept.cs#1)]
 [!code-vb[HttpWebRequest_Accept#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Accept/VB/httpwebrequest_accept.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRange">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje nagłówek zakresu na żądanie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ wszystkie jednostki HTTP są reprezentowane w komunikatach protokołu HTTP jako sekwencje bajtów, koncepcji zakres bajtów ma znaczenie dla dowolnej jednostki HTTP. Jednak nie wszyscy klienci i serwery muszą obsługiwać operacje zakresu bajtów.  
  
 Nagłówek zakresu w żądaniu umożliwia klientowi żądania, tylko chce otrzymać część określony zakres bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądania w nagłówku zakresu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="range">Punktu początkowego i końcowego zakresu.</param>
        <summary>Dodaje nagłówek zakresu bajtów na prośbę o określonym zakresie z początku lub końcu dla żądanych danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Metoda dodaje nagłówek zakresu bajtów na żądanie.  
  
 Jeśli `range` jest dodatnia, `range` parametr określa punkt początkowy zakresu. Serwer powinien rozpocząć wysyłanie danych z `range` parametr określony w celu dane z jednostki HTTP.  
  
 Jeśli `range` jest ujemna, `range` parametr określa punkt końcowy zakresu. Serwer powinien uruchomić wysyłanie danych od czasu rozpoczęcia dane w jednostce HTTP do `range` określono parametr.  
  
 Ponieważ wszystkie jednostki HTTP są reprezentowane w komunikatach protokołu HTTP jako sekwencje bajtów, koncepcji zakres bajtów ma znaczenie dla dowolnej jednostki HTTP. Jednak nie wszyscy klienci i serwery muszą obsługiwać operacje zakresu bajtów.  
  
 Nagłówek zakresu w żądaniu umożliwia klientowi żądania, tylko chce otrzymać część określony zakres bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądania w nagłówku zakresu.  
  
 Przykład nagłówek zakresu w żądaniu protokołu HTTP, który żąda wysyłania serwera pierwsze 100 bajtów (od początku do położenia bajt 99) będą naliczane w następujący:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 W tym przykładzie `range` parametr będzie-99.  
  
 Serwer HTTP wskazuje Obsługa nagłówków zakresu przy użyciu nagłówka Accept-Ranges. Przykładem nagłówek Accept-Ranges z serwera, który obsługuje zakresów bajtów może być w następujący sposób:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Jeśli nie otrzymano nagłówka Accept-Ranges w nagłówku odpowiedzi z serwera, serwer nie obsługuje nagłówki zakresu. Przykład nagłówek Accept-Ranges z serwera, który nie obsługuje zakresów, ale rozpoznaje nagłówek Accept-Ranges będzie następujący:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Po otrzymaniu odpowiedzi od żądania zakresu, tylko nagłówki HTTP skojarzony z żądaniem całego są analizowane i udostępniane za pośrednictwem właściwości <xref:System.Net.HttpWebResponse> klasy. Nagłówki skojarzone z każdym zakresem są zwracane w odpowiedzi.  
  
   
  
## Examples  
 Poniższy przykład kodu dodaje nagłówek zakresu na żądanie.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można dodać nagłówek zakresu.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="range">Punktu początkowego i końcowego zakresu.</param>
        <summary>Dodaje nagłówek zakresu bajtów na prośbę o określonym zakresie z początku lub końcu dla żądanych danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Metoda dodaje nagłówek zakresu bajtów na żądanie.  
  
 Jeśli `range` jest dodatnia, `range` parametr określa punkt początkowy zakresu. Serwer powinien rozpocząć wysyłanie danych z `range` parametr określony w celu dane z jednostki HTTP.  
  
 Jeśli `range` jest ujemna, `range` parametr określa punkt końcowy zakresu. Serwer powinien uruchomić wysyłanie danych od czasu rozpoczęcia dane w jednostce HTTP do `range` określono parametr.  
  
 Ponieważ wszystkie jednostki HTTP są reprezentowane w komunikatach protokołu HTTP jako sekwencje bajtów, koncepcji zakres bajtów ma znaczenie dla dowolnej jednostki HTTP. Jednak nie wszyscy klienci i serwery muszą obsługiwać operacje zakresu bajtów.  
  
 Nagłówek zakresu w żądaniu umożliwia klientowi żądania, tylko chce otrzymać część określony zakres bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądania w nagłówku zakresu.  
  
 Przykład nagłówek zakresu w żądaniu protokołu HTTP, który żąda wysyłania serwera pierwsze 100 bajtów (od początku do położenia bajt 99) będą naliczane w następujący:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 W tym przykładzie `range` parametr będzie-99.  
  
 Serwer HTTP wskazuje Obsługa nagłówków zakresu przy użyciu nagłówka Accept-Ranges. Przykładem nagłówek Accept-Ranges z serwera, który obsługuje zakresów bajtów może być w następujący sposób:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Jeśli nie otrzymano nagłówka Accept-Ranges w nagłówku odpowiedzi z serwera, serwer nie obsługuje nagłówki zakresu. Przykład nagłówek Accept-Ranges z serwera, który nie obsługuje zakresów, ale rozpoznaje nagłówek Accept-Ranges będzie następujący:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Po otrzymaniu odpowiedzi od żądania zakresu, tylko nagłówki HTTP skojarzony z żądaniem całego są analizowane i udostępniane za pośrednictwem właściwości <xref:System.Net.HttpWebResponse> klasy. Nagłówki skojarzone z każdym zakresem są zwracane w odpowiedzi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można dodać nagłówek zakresu.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int * int -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="from">Pozycja, od którego należy rozpocząć wysyłanie danych.</param>
        <param name="to">Pozycja, od którego należy zatrzymać wysyłanie danych.</param>
        <summary>Dodaje nagłówek zakresu bajtów na wniosek o określonym zakresie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Metoda dodaje nagłówek zakresu bajtów na żądanie.  
  
 Ponieważ wszystkie jednostki HTTP są reprezentowane w komunikatach protokołu HTTP jako sekwencje bajtów, koncepcji zakres bajtów ma znaczenie dla dowolnej jednostki HTTP. Jednak nie wszyscy klienci i serwery muszą obsługiwać operacje zakresu bajtów.  
  
 Nagłówek zakresu w żądaniu umożliwia klientowi żądania, tylko chce otrzymać część określony zakres bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądania w nagłówku zakresu.  
  
 Przykład nagłówek zakresu w żądaniu protokołu HTTP, która byłaby żądań pierwsze 100 bajtów będzie następująca:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 W tym przykładzie `from` może zostać określony parametr jako 0 i `to` może zostać określony parametr jako 99. Specyfikator zakresu jest automatycznie ustawiana jako "b" przez tę metodę.  
  
 Serwer HTTP wskazuje Obsługa nagłówków zakresu przy użyciu nagłówka Accept-Ranges. Przykładem nagłówek Accept-Ranges z serwera, który obsługuje zakresów bajtów może być w następujący sposób:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Jeśli nie otrzymano nagłówka Accept-Ranges w nagłówku odpowiedzi z serwera, serwer nie obsługuje nagłówki zakresu. Przykład nagłówek Accept-Ranges z serwera, który nie obsługuje zakresów, ale rozpoznaje nagłówek Accept-Ranges będzie następujący:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Po otrzymaniu odpowiedzi od żądania zakresu, tylko nagłówki HTTP skojarzony z żądaniem całego są analizowane i udostępniane za pośrednictwem właściwości <xref:System.Net.HttpWebResponse> klasy. Nagłówki skojarzone z każdym zakresem są zwracane w odpowiedzi.  
  
   
  
## Examples  
 Poniższy przykład kodu dodaje nagłówek zakresu na żądanie.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> jest większa niż <paramref name="to" /> - lub - <paramref name="from" /> lub <paramref name="to" /> jest mniejszy niż 0.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można dodać nagłówek zakresu.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="from">Pozycja, od którego należy rozpocząć wysyłanie danych.</param>
        <param name="to">Pozycja, od którego należy zatrzymać wysyłanie danych.</param>
        <summary>Dodaje nagłówek zakresu bajtów na wniosek o określonym zakresie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Metoda dodaje nagłówek zakresu bajtów na żądanie.  
  
 Ponieważ wszystkie jednostki HTTP są reprezentowane w komunikatach protokołu HTTP jako sekwencje bajtów, koncepcji zakres bajtów ma znaczenie dla dowolnej jednostki HTTP. Jednak nie wszyscy klienci i serwery muszą obsługiwać operacje zakresu bajtów.  
  
 Nagłówek zakresu w żądaniu umożliwia klientowi żądania, tylko chce otrzymać część określony zakres bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądania w nagłówku zakresu.  
  
 Przykład nagłówek zakresu w żądaniu protokołu HTTP, która byłaby żądań pierwsze 100 bajtów będzie następująca:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 W tym przykładzie `from` może zostać określony parametr jako 0 i `to` może zostać określony parametr jako 99. Specyfikator zakresu jest automatycznie ustawiana jako "b" przez tę metodę.  
  
 Serwer HTTP wskazuje Obsługa nagłówków zakresu przy użyciu nagłówka Accept-Ranges. Przykładem nagłówek Accept-Ranges z serwera, który obsługuje zakresów bajtów może być w następujący sposób:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Jeśli nie otrzymano nagłówka Accept-Ranges w nagłówku odpowiedzi z serwera, serwer nie obsługuje nagłówki zakresu. Przykład nagłówek Accept-Ranges z serwera, który nie obsługuje zakresów, ale rozpoznaje nagłówek Accept-Ranges będzie następujący:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Po otrzymaniu odpowiedzi od żądania zakresu, tylko nagłówki HTTP skojarzony z żądaniem całego są analizowane i udostępniane za pośrednictwem właściwości <xref:System.Net.HttpWebResponse> klasy. Nagłówki skojarzone z każdym zakresem są zwracane w odpowiedzi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> jest większa niż <paramref name="to" /> - lub - <paramref name="from" /> lub <paramref name="to" /> jest mniejszy niż 0.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można dodać nagłówek zakresu.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Opis zakresu.</param>
        <param name="range">Punktu początkowego i końcowego zakresu.</param>
        <summary>Dodaje nagłówek zakresu na prośbę o określonym zakresie z początku lub końcu żądanych danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Metoda dodaje nagłówek zakresu na żądanie.  
  
 Jeśli `range` jest dodatnia, `range` parametr określa punkt początkowy zakresu. Serwer powinien rozpocząć wysyłanie danych z `range` parametr określony w celu dane z jednostki HTTP.  
  
 Jeśli `range` jest ujemna, `range` parametr określa punkt końcowy zakresu. Serwer powinien uruchomić wysyłanie danych od czasu rozpoczęcia dane w jednostce HTTP do `range` określono parametr.  
  
 Ponieważ wszystkie jednostki HTTP są reprezentowane w komunikatach protokołu HTTP jako sekwencje bajtów, koncepcji zakres bajtów ma znaczenie dla dowolnej jednostki HTTP. Jednak nie wszyscy klienci i serwery muszą obsługiwać operacje zakresu bajtów.  
  
 Nagłówek zakresu w żądaniu umożliwia klientowi żądania, tylko chce otrzymać część określony zakres bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądania w nagłówku zakresu.  
  
 `rangeSpecifier` Będzie zwykle zostać określony parametr jako "b", ponieważ jest tylko specyfikator zakresu rozpoznawane przez większość serwerów HTTP. Ustawienie `rangeSpecifier` parametr do jakiegokolwiek innego ciągu umożliwia pomocy technicznej dla niestandardowego zakresu specyfikatorów innych niż bajtów (w dokumencie RFC 2616 definicją IETF specyfikator zakresu bajtów).  
  
 Przykład nagłówek zakresu w żądaniu protokołu HTTP, która byłaby żądań pierwsze 100 bajtów będzie następująca:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 W tym przykładzie `rangeSpecifier` może zostać określony parametr jako "b" i `range` parametr będzie-99.  
  
 Serwer HTTP wskazuje Obsługa nagłówków zakresu przy użyciu nagłówka Accept-Ranges w odpowiedzi. Przykładem nagłówek Accept-Ranges z serwera, który obsługuje zakresów bajtów może być w następujący sposób:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Jeśli nie otrzymano nagłówka Accept-Ranges w nagłówku odpowiedzi z serwera, serwer nie obsługuje nagłówki zakresu. Przykład nagłówek Accept-Ranges z serwera, który nie obsługuje zakresów, ale rozpoznaje nagłówek Accept-Ranges będzie następujący:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Po otrzymaniu odpowiedzi od żądania zakresu, tylko nagłówki HTTP skojarzony z żądaniem całego są analizowane i udostępniane za pośrednictwem właściwości <xref:System.Net.HttpWebResponse> klasy. Nagłówki skojarzone z każdym zakresem są zwracane w odpowiedzi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można dodać nagłówek zakresu.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Opis zakresu.</param>
        <param name="range">Punktu początkowego i końcowego zakresu.</param>
        <summary>Dodaje nagłówek zakresu na prośbę o określonym zakresie z początku lub końcu żądanych danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Metoda dodaje nagłówek zakresu na żądanie.  
  
 Jeśli `range` jest dodatnia, `range` parametr określa punkt początkowy zakresu. Serwer powinien rozpocząć wysyłanie danych z `range` parametr określony w celu dane z jednostki HTTP.  
  
 Jeśli `range` jest ujemna, `range` parametr określa punkt końcowy zakresu. Serwer powinien uruchomić wysyłanie danych od czasu rozpoczęcia dane w jednostce HTTP do `range` określono parametr.  
  
 Ponieważ wszystkie jednostki HTTP są reprezentowane w komunikatach protokołu HTTP jako sekwencje bajtów, koncepcji zakres bajtów ma znaczenie dla dowolnej jednostki HTTP. Jednak nie wszyscy klienci i serwery muszą obsługiwać operacje zakresu bajtów.  
  
 Nagłówek zakresu w żądaniu umożliwia klientowi żądania, tylko chce otrzymać część określony zakres bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądania w nagłówku zakresu.  
  
 `rangeSpecifier` Będzie zwykle zostać określony parametr jako "b", ponieważ jest tylko specyfikator zakresu rozpoznawane przez większość serwerów HTTP. Ustawienie `rangeSpecifier` parametr do jakiegokolwiek innego ciągu umożliwia pomocy technicznej dla niestandardowego zakresu specyfikatorów innych niż bajtów (w dokumencie RFC 2616 definicją IETF specyfikator zakresu bajtów).  
  
 Przykład nagłówek zakresu w żądaniu protokołu HTTP, która byłaby żądań pierwsze 100 bajtów będzie następująca:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 W tym przykładzie `rangeSpecifier` może zostać określony parametr jako "b" i `range` parametr będzie-99.  
  
 Serwer HTTP wskazuje Obsługa nagłówków zakresu przy użyciu nagłówka Accept-Ranges w odpowiedzi. Przykładem nagłówek Accept-Ranges z serwera, który obsługuje zakresów bajtów może być w następujący sposób:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Jeśli nie otrzymano nagłówka Accept-Ranges w nagłówku odpowiedzi z serwera, serwer nie obsługuje nagłówki zakresu. Przykład nagłówek Accept-Ranges z serwera, który nie obsługuje zakresów, ale rozpoznaje nagłówek Accept-Ranges będzie następujący:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Po otrzymaniu odpowiedzi od żądania zakresu, tylko nagłówki HTTP skojarzony z żądaniem całego są analizowane i udostępniane za pośrednictwem właściwości <xref:System.Net.HttpWebResponse> klasy. Nagłówki skojarzone z każdym zakresem są zwracane w odpowiedzi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można dodać nagłówek zakresu.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Opis zakresu.</param>
        <param name="from">Pozycja, od którego należy rozpocząć wysyłanie danych.</param>
        <param name="to">Pozycja, od którego należy zatrzymać wysyłanie danych.</param>
        <summary>Dodaje nagłówek zakresu na prośbę o określonym zakresie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Metoda dodaje nagłówek zakresu na żądanie.  
  
 Ponieważ wszystkie jednostki HTTP są reprezentowane w komunikatach protokołu HTTP jako sekwencje bajtów, koncepcji zakres bajtów ma znaczenie dla dowolnej jednostki HTTP. Jednak nie wszyscy klienci i serwery muszą obsługiwać operacje zakresu bajtów.  
  
 Nagłówek zakresu w żądaniu umożliwia klientowi żądania, tylko chce otrzymać część określony zakres bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądania w nagłówku zakresu.  
  
 `rangeSpecifier` Będzie zwykle zostać określony parametr jako "b", ponieważ jest tylko specyfikator zakresu rozpoznawane przez większość serwerów HTTP. Ustawienie `rangeSpecifier` parametr do jakiegokolwiek innego ciągu umożliwia pomocy technicznej dla niestandardowego zakresu specyfikatorów innych niż bajtów (w dokumencie RFC 2616 definicją IETF specyfikator zakresu bajtów).  
  
 Przykład nagłówek zakresu w żądaniu protokołu HTTP, która byłaby żądań pierwsze 100 bajtów będzie następująca:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 W tym przykładzie `rangeSpecifier` może zostać określony parametr jako "b", `from` parametr będzie mieć wartość 0, a `to` parametr będzie 99.  
  
 Serwer HTTP wskazuje Obsługa nagłówków zakresu przy użyciu nagłówka Accept-Ranges w odpowiedzi. Przykładem nagłówek Accept-Ranges z serwera, który obsługuje zakresów bajtów może być w następujący sposób:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Ciąg określony w nagłówku Accept-Ranges jest określenie zakresu, dzięki przekazywanej w `rangeSpecifier` parametrem tej metody.  
  
 Jeśli nie otrzymano nagłówka Accept-Ranges w nagłówku odpowiedzi z serwera, serwer nie obsługuje nagłówki zakresu. Przykład nagłówek Accept-Ranges z serwera, który nie obsługuje zakresów, ale rozpoznaje nagłówek Accept-Ranges będzie następujący:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Po otrzymaniu odpowiedzi od żądania zakresu, tylko nagłówki HTTP skojarzony z żądaniem całego są analizowane i udostępniane za pośrednictwem właściwości <xref:System.Net.HttpWebResponse> klasy. Nagłówki skojarzone z każdym zakresem są zwracane w odpowiedzi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> jest większa niż <paramref name="to" /> - lub - <paramref name="from" /> lub <paramref name="to" /> jest mniejszy niż 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można dodać nagłówek zakresu.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Opis zakresu.</param>
        <param name="from">Pozycja, od którego należy rozpocząć wysyłanie danych.</param>
        <param name="to">Pozycja, od którego należy zatrzymać wysyłanie danych.</param>
        <summary>Dodaje nagłówek zakresu na prośbę o określonym zakresie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Metoda dodaje nagłówek zakresu na żądanie.  
  
 Ponieważ wszystkie jednostki HTTP są reprezentowane w komunikatach protokołu HTTP jako sekwencje bajtów, koncepcji zakres bajtów ma znaczenie dla dowolnej jednostki HTTP. Jednak nie wszyscy klienci i serwery muszą obsługiwać operacje zakresu bajtów.  
  
 Nagłówek zakresu w żądaniu umożliwia klientowi żądania, tylko chce otrzymać część określony zakres bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądania w nagłówku zakresu.  
  
 `rangeSpecifier` Będzie zwykle zostać określony parametr jako "b", ponieważ jest tylko specyfikator zakresu rozpoznawane przez większość serwerów HTTP. Ustawienie `rangeSpecifier` parametr do jakiegokolwiek innego ciągu umożliwia pomocy technicznej dla niestandardowego zakresu specyfikatorów innych niż bajtów (w dokumencie RFC 2616 definicją IETF specyfikator zakresu bajtów).  
  
 Przykład nagłówek zakresu w żądaniu protokołu HTTP, która byłaby żądań pierwsze 100 bajtów będzie następująca:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 W tym przykładzie `rangeSpecifier` może zostać określony parametr jako "b", `from` parametr będzie mieć wartość 0, a `to` parametr będzie 99.  
  
 Serwer HTTP wskazuje Obsługa nagłówków zakresu przy użyciu nagłówka Accept-Ranges w odpowiedzi. Przykładem nagłówek Accept-Ranges z serwera, który obsługuje zakresów bajtów może być w następujący sposób:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Ciąg określony w nagłówku Accept-Ranges jest określenie zakresu, dzięki przekazywanej w `rangeSpecifier` parametrem tej metody.  
  
 Jeśli nie otrzymano nagłówka Accept-Ranges w nagłówku odpowiedzi z serwera, serwer nie obsługuje nagłówki zakresu. Przykład nagłówek Accept-Ranges z serwera, który nie obsługuje zakresów, ale rozpoznaje nagłówek Accept-Ranges będzie następujący:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Po otrzymaniu odpowiedzi od żądania zakresu, tylko nagłówki HTTP skojarzony z żądaniem całego są analizowane i udostępniane za pośrednictwem właściwości <xref:System.Net.HttpWebResponse> klasy. Nagłówki skojarzone z każdym zakresem są zwracane w odpowiedzi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> jest większa niż <paramref name="to" /> - lub - <paramref name="from" /> lub <paramref name="to" /> jest mniejszy niż 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można dodać nagłówek zakresu.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public Uri Address { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Address" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Address As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Address { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Address : Uri" Usage="System.Net.HttpWebRequest.Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator URI (Uniform Resource) zasobu internetowego, który faktycznie odpowie na żądanie.</summary>
        <value>A <see cref="T:System.Uri" /> określający zasobu internetowego, który faktycznie odpowie na żądanie. Wartość domyślna to identyfikator URI używany przez <see cref="M:System.Net.WebRequest.Create(System.String)" /> metodę, aby zainicjować żądanie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Address%2A> Właściwość jest ustawiona na identyfikator URI, po zakończeniu wszelkich przekierowań, które występują podczas żądania.  
  
 Identyfikator URI oryginalne żądanie jest przechowywany w <xref:System.Net.HttpWebRequest.RequestUri%2A> właściwości.  
  
   
  
## Examples  
 Poniższy kod sprawdza przykład, jeśli <xref:System.Net.HttpWebRequest> obiektu `req` zostało przekierowane do innej lokalizacji w celu spełnienia żądania i ustawia wartość `hasChanged` zmienną `true` Jeśli żądanie zostało przekierowane; w przeciwnym razie `hasChanged`jest równa `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public virtual bool AllowAutoRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowAutoRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowAutoRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAutoRedirect : bool with get, set" Usage="System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy żądanie ma uwzględnić odpowiedzi przekierowania.</summary>
        <value>
          <see langword="true" /> Jeśli żądanie automatycznie ma uwzględnić odpowiedzi przekierowania, z zasobem internetowym; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> do `true` Jeśli chcesz, aby żądania, aby automatycznie wykonać nagłówki przekierowania HTTP do nowej lokalizacji zasobu. Ustawiono maksymalną liczbę przekierowań do wykonania <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> właściwości.  
  
 Jeśli <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> ustawiono `false`, wszystkie odpowiedzi z kodem stanu HTTP od 300 do 399 jest zwracana do aplikacji.  
  
 Nagłówek autoryzacji na automatyczne przekierowania jest zaznaczone i <xref:System.Net.HttpWebRequest> automatycznie podejmie próbę ponownego uwierzytelnienia do lokalizacji przekierowywanej. W praktyce oznacza to, aplikacji nie można umieścić informacji uwierzytelniania niestandardowego do nagłówka autoryzacji, jeśli istnieje możliwość wystąpi przekierowania. Zamiast tego aplikacja musi zaimplementować i Zarejestruj moduł uwierzytelniania niestandardowego. <xref:System.Net.AuthenticationManager?displayProperty=nameWithType> i pokrewne klasy są używane do implementowania moduł uwierzytelniania niestandardowego. <xref:System.Net.AuthenticationManager.Register%2A?displayProperty=nameWithType> Metoda rejestruje moduł uwierzytelniania niestandardowego.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> właściwości, aby zezwolić na żądanie uwzględnić odpowiedzi przekierowania.  
  
 [!code-cpp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CPP/httpwebrequest_allowautoredirect.cpp#2)]
 [!code-csharp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CS/httpwebrequest_allowautoredirect.cs#2)]
 [!code-vb[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/VB/httpwebrequest_allowautoredirect.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowReadStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowReadStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowReadStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowReadStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowReadStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowReadStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy do zbuforowania odebranych z zasobem internetowym.</summary>
        <value>
          <see langword="true" /> Aby włączyć buforowanie danych odebranych z zasobem internetowym; <see langword="false" /> wyłączenie buforowania. Wartość domyślna to <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowWriteStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowWriteStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowWriteStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowWriteStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowWriteStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowWriteStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy chcesz buforować dane wysyłane z zasobem internetowym.</summary>
        <value>
          <see langword="true" /> Aby włączyć buforowanie danych wysyłanych z zasobem internetowym; <see langword="false" /> wyłączenie buforowania. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> jest `true`, dane są buforowane w pamięci, aby był gotowy określoną w przypadku uwierzytelniania lub przekierowywanie żądań.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> właściwość, która wyłącza buforowanie danych.  
  
 [!code-cpp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CPP/httpwebrequest_allowwritestreambuffering.cpp#1)]
 [!code-csharp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CS/httpwebrequest_allowwritestreambuffering.cs#1)]
 [!code-vb[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/VB/httpwebrequest_allowwritestreambuffering.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ustawienie <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> do <see langword="true" /> może spowodować problemy z wydajnością podczas przekazywania dużych zestawów danych, ponieważ bufor danych może wykorzystać całą dostępną pamięć.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDecompression">
      <MemberSignature Language="C#" Value="public System.Net.DecompressionMethods AutomaticDecompression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.DecompressionMethods AutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticDecompression As DecompressionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::DecompressionMethods AutomaticDecompression { System::Net::DecompressionMethods get(); void set(System::Net::DecompressionMethods value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticDecompression : System.Net.DecompressionMethods with get, set" Usage="System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.DecompressionMethods</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ dekompresji, który jest używany.</summary>
        <value>A <see cref="T:System.Net.DecompressionMethods" /> obiekt, który wskazuje typ dekompresji, który jest używany.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący stan obiektu nie zezwala na tę właściwość należy ustawić.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRequestStream">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetRequestStream(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetRequestStream (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetRequestStream(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetRequestStream : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetRequestStream (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegować.</param>
        <param name="state">Obiekt stanu dla tego żądania.</param>
        <summary>Rozpoczyna się dla żądania asynchronicznego <see cref="T:System.IO.Stream" /> obiekt ma być używany do zapisywania danych.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odwołujący się żądania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> Metoda uruchamia asynchroniczne żądanie dla strumienia używane do przesyłania danych <xref:System.Net.HttpWebRequest>. Używa metody asynchroniczne wywołanie zwrotne <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> metodę, aby zwrócić strumień, do rzeczywistego.  
  
 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> Metoda wymaga kilka zadań synchroniczne Instalatora, aby wykonać (rozpoznawanie nazw DNS, wykrywanie serwera proxy i połączenia gniazda TCP, np.), zanim ta metoda staje się asynchronicznego. W wyniku tej metody należy nigdy nie zostaną wywołane w wątku interfejsu użytkownika ponieważ znaczną ilość czasu (nawet kilka minut w zależności od ustawienia sieci) może potrwać do ukończenia zadania konfiguracji początkowej synchroniczne przed wyjątek dla zostaje zgłoszony błąd lub Metoda się powiedzie.  
  
 Aby dowiedzieć się więcej na temat puli wątków, zobacz [puli wątków zarządzanych](~/docs/standard/threading/the-managed-thread-pool.md).  
  
> [!NOTE]
>  Aplikacja nie można mieszać synchroniczne i asynchroniczne metody dla określonego żądania. Jeśli wywołasz <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> metody, należy użyć <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metodę, aby pobrać odpowiedzi.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> metody asynchroniczne żądanie dla wystąpienia usługi stream.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> Właściwość jest GET lub HEAD.  - lub - <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> jest <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> jest <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> wynosi -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" />, i <see cref="P:System.Net.HttpWebRequest.Method" /> to POST lub PUT.</exception>
        <exception cref="T:System.InvalidOperationException">Strumień jest używany przez poprzednie wywołanie <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> - lub - <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> jest ustawiona na wartość i <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" />.  - lub - puli wątków nie kończy się wątków.</exception>
        <exception cref="T:System.NotSupportedException">Pamięci podręcznej żądań modułu sprawdzania poprawności wskazane, czy odpowiedzi na to żądanie mogą być udostępniane z pamięci podręcznej; jednak żądań, zapisywać dane, które nie mogą używać pamięci podręcznej. Ten wyjątek może wystąpić, jeśli używane są niepoprawnie zaimplementowano sprawdzania poprawności niestandardowych pamięci podręcznej.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> był wcześniej nazywany programem.</exception>
        <exception cref="T:System.ObjectDisposedException">W aplikacji platformy .NET Compact Framework strumienia żądania o zerowej długości zawartości nie zostały uzyskane a poprawnie zamknięty. Aby uzyskać więcej informacji na temat obsługi żądań zerowej długości zawartości, zobacz [sieci programowania na platformie .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetResponse">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetResponse(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetResponse (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetResponse(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetResponse : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetResponse (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegowanie</param>
        <param name="state">Obiekt stanu dla tego żądania.</param>
        <summary>Rozpoczyna się asynchroniczne żądanie do zasobu internetowego.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odwołujący się żądania asynchronicznego na odpowiedź.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> Metoda uruchamia asynchroniczne żądanie na odpowiedź z zasobem internetowym. Używa metody asynchroniczne wywołanie zwrotne <xref:System.Net.HttpWebRequest.EndGetResponse%2A> metodę, aby zwrócić rzeczywiste <xref:System.Net.WebResponse>.  
  
 A <xref:System.Net.ProtocolViolationException> jest zgłaszany w kilku przypadkach, gdy właściwości ustawione na <xref:System.Net.HttpWebRequest> klasy są w konflikcie. Ten wyjątek występuje, jeśli aplikacja ustawia <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości i <xref:System.Net.HttpWebRequest.SendChunked%2A> właściwości `true`, a następnie wysyła żądanie HTTP GET. Ten wyjątek występuje, gdy aplikacja próbuje wysłać podzielony na serwerze, który obsługuje tylko protokół HTTP 1.0, gdzie jest to nieobsługiwane. Ten wyjątek występuje, gdy aplikacja próbuje wysłać dane bez ustawienia <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości lub <xref:System.Net.HttpWebRequest.SendChunked%2A> jest `false` gdy buforowanie jest wyłączone i połączenia keepalive ( <xref:System.Net.HttpWebRequest.KeepAlive%2A> właściwość `true`)`.`  
  
 Jeśli <xref:System.Net.WebException> jest generowany, użyj <xref:System.Net.WebException.Response%2A> i <xref:System.Net.WebException.Status%2A> właściwości wyjątku, aby określić odpowiedź z serwera.  
  
 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> Metoda wymaga kilka zadań synchroniczne Instalatora, aby wykonać (rozpoznawanie nazw DNS, wykrywanie serwera proxy i połączenia gniazda TCP, np.), zanim ta metoda staje się asynchronicznego. W wyniku tej metody należy nigdy nie zostaną wywołane w wątku interfejsu użytkownika ponieważ znaczną ilość czasu (nawet kilka minut w zależności od ustawienia sieci) może potrwać do ukończenia zadania konfiguracji początkowej synchroniczne przed wyjątek dla zostaje zgłoszony błąd lub Metoda się powiedzie.  
  
 Aby dowiedzieć się więcej na temat puli wątków, zobacz [ &#91; \<topic://cpconthreadpooling >&#93;](http://msdn.microsoft.com/library/2be05b06-a42e-4c9d-a739-96c21d673927).  
  
> [!NOTE]
>  Aplikacja nie można mieszać synchroniczne i asynchroniczne metody dla określonego żądania. Jeśli wywołasz <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> metody, należy użyć <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metodę, aby pobrać odpowiedzi.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [ &#91; \<topic://conUsingNetworkTracing >&#93;](http://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metody asynchroniczne żądanie dla zasobu w Internecie.  
  
> [!NOTE]
>  W przypadku żądań asynchronicznych jest odpowiedzialny za aplikacja kliencka, aby zaimplementować własny mechanizm limitu czasu. W poniższym przykładzie kodu pokazano, jak to zrobić.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Strumień jest już używany przez poprzednie wywołanie <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> - lub - <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> jest ustawiona na wartość i <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" />.  - lub - puli wątków nie kończy się wątków.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> to GET lub HEAD, a następnie <see cref="P:System.Net.HttpWebRequest.ContentLength" /> jest większa od zera lub <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="true" />.  - lub - <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> jest <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> jest <see langword="false" />oraz <see cref="P:System.Net.HttpWebRequest.ContentLength" /> wynosi -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" /> i <see cref="P:System.Net.HttpWebRequest.Method" /> to POST lub PUT.  - lub - <see cref="T:System.Net.HttpWebRequest" /> zawiera treść jednostki, ale <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> metoda jest wywoływana bez wywoływania <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> metody.  - lub - <see cref="P:System.Net.HttpWebRequest.ContentLength" /> jest większa niż zero, ale aplikacja nie zapisuje wszystkie dane uzgodnionego.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> był wcześniej nazywany programem.</exception>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); void set(System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection with get, set" Usage="System.Net.HttpWebRequest.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolekcję certyfikatów zabezpieczeń, które są skojarzone z tym żądaniem.</summary>
        <value>
          <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> Zawierający certyfikaty zabezpieczeń skojarzony z tym żądaniem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikację można dodać certyfikatu do kolekcji, ale może nie mieć praw dostępu do niego. Aby użyć certyfikatu z znajdujących się w kolekcji, aplikacja musi mieć te same prawa dostępu jako obiekt, który wystawił certyfikat.  
  
> [!NOTE]
>  Struktura buforuje sesji protokołu SSL, ponieważ są one tworzone i podejmie próbę ponownego użycia pamięci podręcznej sesji dla nowego żądania, jeśli jest to możliwe. Podczas próby ponownego użycia sesji SSL, struktura używa pierwszego elementu <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (jeśli istnieje), lub spróbuje ponownie użyć sesji anonimowe, jeśli <xref:System.Net.HttpWebRequest.ClientCertificates%2A> jest pusty.  
  
> [!NOTE]
>  Ze względu na wydajność nie należy dodawać certyfikatu klienta w celu <xref:System.Net.HttpWebRequest> chyba że wiesz, że serwer będzie żądać go.  
>   
>  Aby uzyskać przykładowy kod pokazujący, jak wyliczyć certyfikaty w magazynie certyfikatów klienta, zobacz <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość określona dla operacji zestawu jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public string Connection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Connection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Connection" />
      <MemberSignature Language="VB.NET" Value="Public Property Connection As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Connection { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Connection : string with get, set" Usage="System.Net.HttpWebRequest.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see langword="Connection" /> nagłówka HTTP.</summary>
        <value>Wartość <see langword="Connection" /> nagłówka HTTP. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wysyła żądanie <xref:System.Net.HttpWebRequest.Connection%2A> właściwości z zasobem internetowym jako `Connection` nagłówka HTTP. Jeśli wartość <xref:System.Net.HttpWebRequest.KeepAlive%2A> właściwość `true`, wartość "Keep-alive" jest dołączany na końcu `Connection` nagłówka.  
  
 Aby wyczyścić `Connection` Ustaw nagłówek HTTP <xref:System.Net.HttpWebRequest.Connection%2A> właściwość `null`.  
  
 Zmiana <xref:System.Net.HttpWebRequest.Connection%2A> właściwości po rozpoczęciu żądania przez wywołanie metody <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, lub <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metoda zgłasza wyjątek <xref:System.InvalidOperationException>.  
  
> [!NOTE]
>  Wartość tej właściwości jest przechowywana w <xref:System.Net.WebHeaderCollection>. Jeśli ustawiono WebHeaderCollection, wartość właściwości zostaną utracone.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.HttpWebRequest.Connection%2A> właściwość umożliwiająca ustawienie wartości nagłówka HTTP połączenia.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość <see cref="P:System.Net.HttpWebRequest.Connection" /> Keep-alive lub Zamknij.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionGroupName">
      <MemberSignature Language="C#" Value="public override string ConnectionGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionGroupName : string with get, set" Usage="System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę grupy połączenia dla żądania.</summary>
        <value>Nazwa grupy połączeń dla tego żądania. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> Właściwość pozwala kojarzyć żądania z grupą połączenia. Jest to przydatne, gdy aplikacja wykonuje żądania do jednego serwera dla różnych użytkowników, takich jak witryny sieci Web, która pobiera informacje o kliencie z serwerem bazy danych.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazują sposób użycia informacji o użytkowniku w celu utworzenia grupy połączeń, przy założeniu, że zmienne `username`, `password`, i `domain` są ustawiane przez aplikację przed wywołaniem tego kodu.  
  
 [!code-cpp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Każda grupa połączenia tworzy dodatkowe połączenia dla serwera. Może to spowodować przekroczenie liczby połączeń ustawione przez <see cref="P:System.Net.ServicePoint.ConnectionLimit" /> właściwości dla tego serwera.</para>
        </block>
        <altmember cref="P:System.Net.Configuration.ConnectionManagementElement.MaxConnection" />
        <altmember cref="P:System.Net.WebRequest.ConnectionGroupName" />
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public override long ContentLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long ContentLength { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int64 with get, set" Usage="System.Net.HttpWebRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see langword="Content-length" /> nagłówka HTTP.</summary>
        <value>Liczba bajtów danych do wysłania do zasobu internetowego. Wartość domyślna to -1, która wskazuje, że właściwości nie została ustawiona i że nie ma żadnych danych na żądanie, do wysłania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContentLength%2A> Właściwość zawiera wartość do wysłania jako `Content-length` z żądaniem nagłówek HTTP.  
  
 Wartości innej niż -1 w <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwość wskazuje, że żądanie przekazuje dane i że tylko tych metod, które przekazują dane są dozwolone w <xref:System.Net.HttpWebRequest.Method%2A> właściwości.  
  
 Po <xref:System.Net.HttpWebRequest.ContentLength%2A> ustawioną na wartość podanej liczby bajtów musi być przystosowana do strumienia żądania, który jest zwracany przez wywołanie metody <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metody lub oba <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> i <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> metody.  
  
> [!NOTE]
>  Wartość tej właściwości jest przechowywana w <xref:System.Net.WebHeaderCollection>. Jeśli ustawiono WebHeaderCollection, wartość właściwości zostaną utracone.  
  
   
  
## Examples  
 Poniższy kod ustawia przykład <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwość długość ciągu jest opublikowane.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żądania został uruchomiony, wywołując <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, lub <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nowy <see cref="P:System.Net.HttpWebRequest.ContentLength" /> wartość jest mniejsza niż 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public override string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Net.HttpWebRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see langword="Content-type" /> nagłówka HTTP.</summary>
        <value>Wartość <see langword="Content-type" /> nagłówka HTTP. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContentType%2A> Właściwość zawiera typ nośnika żądania. Wartości przypisane do <xref:System.Net.HttpWebRequest.ContentType%2A> właściwość zastąpienie istniejącej zawartości, gdy wysyła żądanie `Content-type` nagłówka HTTP.  
  
 Aby wyczyścić `Content-type` Ustaw nagłówek HTTP <xref:System.Net.HttpWebRequest.ContentType%2A> właściwość `null`.  
  
> [!NOTE]
>  Wartość tej właściwości jest przechowywana w <xref:System.Net.WebHeaderCollection> . Jeśli <xref:System.Net.WebHeaderCollection> jest ustawiona, wartość właściwości zostaną utracone.  
  
   
  
## Examples  
 Poniższy kod ustawia przykład <xref:System.Net.HttpWebRequest.ContentType%2A> właściwości.  
  
 [!code-cpp[HttpWebRequest_ContentLength#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#1)]
 [!code-csharp[HttpWebRequest_ContentLength#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#1)]
 [!code-vb[HttpWebRequest_ContentLength#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpContinueDelegate ContinueDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpContinueDelegate ContinueDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueDelegate As HttpContinueDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpContinueDelegate ^ ContinueDelegate { System::Net::HttpContinueDelegate ^ get(); void set(System::Net::HttpContinueDelegate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueDelegate : System.Net.HttpContinueDelegate with get, set" Usage="System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpContinueDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia metodę delegata, wywoływana, gdy HTTP 100 — Kontynuuj Odebrano odpowiedź z zasobem internetowym.</summary>
        <value>Delegat, który implementuje metodę wywołania zwrotnego, który jest wykonywany, gdy odpowiedź HTTP nadal jest zwracany z zasobem internetowym. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> Właściwość określa metody wywołania zwrotnego wywoływana, gdy klient odbierze 100 — Kontynuuj odpowiedzi.  
  
 Gdy <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> właściwość jest ustawiona, gdy klient wywołuje delegata zawsze, gdy protokół odpowiedzi typu <xref:System.Net.HttpStatusCode.Continue?displayProperty=nameWithType> (100) są odbierane. Jest to przydatne, jeśli klient, aby wyświetlić stan danych wysyłanych z zasobem internetowym.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public int ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContinueTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia limit czasu (w milisekundach), poczekaj, aż do 100 — Kontynuuj jest otrzymany z serwera.</summary>
        <value>Limit czasu (w milisekundach), poczekaj, aż do 100 — Kontynuuj została odebrana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli 100 — Kontynuuj odpowiedzi przed upływem limitu czasu, można wysłać w treści jednostki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieContainer">
      <MemberSignature Language="C#" Value="public virtual System.Net.CookieContainer CookieContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer CookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.CookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CookieContainer As CookieContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CookieContainer : System.Net.CookieContainer with get, set" Usage="System.Net.HttpWebRequest.CookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia pliki cookie skojarzone z żądaniem.</summary>
        <value>Element <see cref="T:System.Net.CookieContainer" /> zawierający pliki cookie skojarzone z tym żądaniem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A> Właściwość udostępnia wystąpienie <xref:System.Net.CookieContainer> klasę, która zawiera pliki cookie skojarzone z tym żądaniem.  
  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A> jest `null` domyślnie. Należy przypisać <xref:System.Net.CookieContainer> obiekt do właściwości plików cookie zwracane w <xref:System.Net.HttpWebResponse.Cookies%2A> właściwość <xref:System.Net.HttpWebResponse> zwrócone przez <xref:System.Net.HttpWebRequest.GetResponse%2A> metody.  
  
> [!NOTE]
>  Ze względów bezpieczeństwa pliki cookie są domyślnie wyłączone. Używanie plików cookie, należy użyć <xref:System.Net.HttpWebRequest.CookieContainer%2A> właściwość, aby włączyć obsługę plików cookie.  
  
   
  
## Examples  
 Poniższy przykładowy kod wysyła żądanie do adresu URL i wyświetla pliki cookie, zwrócona w odpowiedzi.  
  
 [!code-cpp[NCLCookies#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLCookies/CPP/cookiessnippets.cpp#1)]
 [!code-csharp[NCLCookies#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLCookies/CS/cookiessnippets.cs#1)]
 [!code-vb[NCLCookies#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLCookies/VB/cookiessnippets.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.CookieContainer" />
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials with get, set" Usage="System.Net.HttpWebRequest.Credentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje dotyczące uwierzytelniania dla żądania.</summary>
        <value>
          <see cref="T:System.Net.ICredentials" /> Zawierający poświadczenia uwierzytelnienia skojarzone z żądaniem. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Credentials%2A> Właściwość zawiera informacje dotyczące uwierzytelniania, aby zidentyfikować twórcy żądania. <xref:System.Net.HttpWebRequest.Credentials%2A> Właściwość może być <xref:System.Net.NetworkCredential>, w których przypadku użytkownika, hasła i domeny informacji zawartych w <xref:System.Net.NetworkCredential> obiekt jest używany do uwierzytelniania żądania lub może być <xref:System.Net.CredentialCache>, w którym to przypadku Uniform Resource Identyfikator URI żądania jest używana do określenia użytkownika, hasło i informacje dotyczące domeny, można użyć do uwierzytelnienia żądania.  
  
 W większości przypadków klienta, należy użyć <xref:System.Net.CredentialCache.DefaultCredentials%2A> właściwość, która zawiera poświadczenia aktualnie zalogowanego użytkownika. Aby to zrobić, należy ustawić <xref:System.Net.WebClient.UseDefaultCredentials%2A> właściwości `true` zamiast ustawienie tej właściwości.  
  
 Jeśli <xref:System.Net.HttpWebRequest> klasy jest używany w aplikacji warstwy środkowej, np. aplikację ASP.NET poświadczenia w <xref:System.Net.CredentialCache.DefaultCredentials%2A> właściwość należy do konta, uruchamianie stron ASP (poświadczenia po stronie serwera). Zazwyczaj należy ustawić tę właściwość poświadczenia klienta, w którego imieniu żądanie jest wysyłane.  
  
> [!NOTE]
>  Schemat uwierzytelniania NTLM nie może służyć do podszycia się pod innego użytkownika. Protokół Kerberos musi być skonfigurowany specjalnie do obsługi personifikacji.  
  
 Aby ograniczyć HttpWebRequest do co najmniej jedną metodę uwierzytelniania, należy użyć <xref:System.Net.CredentialCache> klasy i powiązać poświadczenia z co najmniej jeden schemat uwierzytelniania  
  
 Schematy uwierzytelniania obsługiwanych obejmują Digest, Negotiate, Kerberos, NTLM i Basic.  
  
 Ze względów bezpieczeństwa po automatycznie przekierowuje, przechowywania poświadczeń, które mają zostać uwzględnione w przekierowania w <xref:System.Net.CredentialCache> i przypisz je do tej właściwości. Ta właściwość zostanie automatycznie ustawiony w pozycji `null` podczas przekierowania, jeśli zawiera on końcówką <xref:System.Net.CredentialCache>. Mających wartość tej właściwości zostanie ustawione automatyczne `null` w tych warunkach zapobiega poświadczenia są wysyłane do dowolnego niezamierzone miejsca docelowego.
  
## Examples  
 Poniższy przykład kodu Ustawia poświadczenia dla żądania.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Date" />
      <MemberSignature Language="VB.NET" Value="Public Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.Date : DateTime with get, set" Usage="System.Net.HttpWebRequest.Date" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobieranie lub ustawianie <see langword="Date" /> wartość nagłówka HTTP do użycia w żądaniu HTTP.</summary>
        <value>Wartość nagłówka daty w żądaniu HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nagłówek daty `null`, wówczas wartość zwracana będzie równa <xref:System.DateTime.MinValue?displayProperty=nameWithType>.  
  
 <xref:System.Net.HttpWebRequest.Date%2A> Właściwość jest standardem <xref:System.DateTime?displayProperty=nameWithType> obiektu i może zawierać <xref:System.DateTimeKind?displayProperty=nameWithType> pole <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, lub <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Dowolny rodzaj czasu można ustawić przy użyciu <xref:System.Net.HttpWebRequest.Date%2A> właściwości. Jeśli <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> zostaje ustawiona lub pobraniu <xref:System.Net.HttpWebRequest.Date%2A> właściwość zakłada się, że <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (czas lokalny).  
  
 Klasy w <xref:System.Net> przestrzeni nazw zawsze zapisać go <xref:System.Net.HttpWebRequest.Date%2A> właściwości na łączu podczas transmisji w postaci standardowych przy użyciu formatu GMT (czas Utc).  
  
 Jeśli <xref:System.Net.HttpWebRequest.Date%2A> właściwość jest ustawiona na <xref:System.DateTime.MinValue?displayProperty=nameWithType>, a następnie `Date` nagłówka HTTP jest usuwany z <xref:System.Net.HttpWebRequest.Headers%2A> właściwości i <xref:System.Net.WebHeaderCollection>.  
  
 Jeśli <xref:System.Net.HttpWebRequest.Date%2A> właściwość <xref:System.DateTime.MinValue?displayProperty=nameWithType>, oznacza to, że `Date` nagłówka HTTP nie jest uwzględniony w <xref:System.Net.HttpWebRequest.Headers%2A> właściwości i <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  Wartość tej właściwości jest przechowywana w <xref:System.Net.WebHeaderCollection>. Jeśli ustawiono WebHeaderCollection, wartość właściwości zostaną utracone.  
  
 Jeśli <xref:System.Net.HttpWebRequest.Date%2A> ustawiono i zostanie podjęta próba, aby wysłać <xref:System.Net.HttpWebRequest> nie jednostki, a następnie <xref:System.Net.ProtocolViolationException?displayProperty=nameWithType> zostaną zgłoszone przez <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, i <xref:System.Net.HttpWebRequest.EndGetResponse%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCachePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy DefaultCachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Cache.RequestCachePolicy DefaultCachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultCachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Cache::RequestCachePolicy ^ DefaultCachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCachePolicy : System.Net.Cache.RequestCachePolicy with get, set" Usage="System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia domyślne zasady pamięci podręcznej dla tego żądania.</summary>
        <value>A <see cref="T:System.Net.Cache.HttpRequestCachePolicy" /> określa zasady pamięci podręcznej dla tego żądania, gdy nie inne zasady są stosowane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie tej właściwości rejestruje określonych zasad dla systemów HTTP i HTTPS. Ta zasada jest używana dla tego żądania, jeśli:  
  
 Istnieje nie <xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType> właściwość określona dla tego żądania.  
  
 \- lub —  
  
 Konfiguracja maszyn i aplikacji, plików nie zostanie określony, zasady pamięci podręcznej, który ma zastosowanie do jednolity identyfikator zasobów (URI) użyty do utworzenia tego żądania.  
  
 Zasady pamięci podręcznej określa, czy żądany zasób może zostać pobrany z pamięci podręcznej, zamiast wysyłać żądania do zasobu hosta.  
  
 Kopię zasobu jest dodawana do pamięci podręcznej tylko, jeśli w strumieniu odpowiedzi dla zasobu są pobierane i Odczyt do końca strumienia. Dlatego kolejne żądanie dla tego samego zasobu, można użyć kopii w pamięci podręcznej, w zależności od poziomu zasad pamięci podręcznej dla tego żądania.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Aby uzyskać nieograniczony dostęp do zasobów sieciowych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.Cache.RequestCachePolicy" />
        <altmember cref="T:System.Net.Cache.HttpRequestCacheLevel" />
        <altmember cref="T:System.Net.Cache.RequestCacheLevel" />
        <altmember cref="P:System.Net.WebRequest.CachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumErrorResponseLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumErrorResponseLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumErrorResponseLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumErrorResponseLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumErrorResponseLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną długość domyślną odpowiedź o błędzie HTTP.</summary>
        <value>Domyślna maksymalna długość odpowiedzi błędu HTTP.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość jest mniejsza niż 0 i nie jest równy-1.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia domyślną <see cref="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" /> właściwości.</summary>
        <value>Długość w kilobajtach (1024 bajty), Domyślna maksymalna odebrane nagłówki odpowiedzi. Domyślny plik konfiguracji ustawi tę wartość na 64 kilobajtów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Długość nagłówka odpowiedzi odebrany wiersz stanu odpowiedzi i żadnych znaków kontrolnych dodatkowe, które są odbierane w ramach protokołu HTTP. Wartość-1 oznacza, że limit nie nakłada się na nagłówki odpowiedzi odebrany; wartość 0 oznacza, że wszystkie żądania się nie powieść.  
  
 Tę wartość można zmienić w taki sposób, w pliku konfiguracji. Wpływ ta właściwość może być zastąpiona przez ustawienie <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> właściwość w wystąpieniu <xref:System.Net.HttpWebRequest> klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość nie jest równy-1 i mniejsza niż zero.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndGetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kończy żądanie asynchroniczne dla <see cref="T:System.IO.Stream" /> obiekt ma być używany do zapisywania danych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetRequestStream (asyncResult As IAsyncResult) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oczekujące żądanie dla strumienia.</param>
        <summary>Kończy żądanie asynchroniczne dla <see cref="T:System.IO.Stream" /> obiekt ma być używany do zapisywania danych.</summary>
        <returns>Element <see cref="T:System.IO.Stream" /> używany do zapisania danych żądania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> Ukończeniu metody asynchroniczne żądanie dla strumienia, które zostało uruchomione przez <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> metody. Po <xref:System.IO.Stream> został zwrócony obiekt, możesz wysłać danych za pomocą <xref:System.Net.HttpWebRequest> przy użyciu <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> metody.  
  
> [!NOTE]
>  Należy ustawić wartość z <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości przed zapisaniem danych do strumienia.  
  
> [!CAUTION]
>  Należy wywołać <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> metodę, aby zamknąć strumień i wersji połączenia do ponownego wykorzystania. Nie można zamknąć strumień powoduje, że aplikacja całe wolne połączenia.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> metodę, aby zakończyć żądania asynchronicznego dla wystąpienia usługi stream.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Żądanie nie zostało ukończone, a nie usługa stream jest dostępna.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie został zwrócony przez bieżące wystąpienie z wywołania <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ta metoda została wywołana wcześniej przy użyciu <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> był wcześniej nazywany programem.  - lub - wystąpił błąd podczas przetwarzania żądania.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; context) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef context As TransportContext) As Stream" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; transportContext) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef transportContext As TransportContext) As Stream" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult *  -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream (asyncResult, transportContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" />
        <Parameter Name="context" Type="System.Net.TransportContext" RefType="out" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="transportContext" Type="System.Net.TransportContext" RefType="out" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oczekujące żądanie dla strumienia.</param>
        <param name="context">
          <see cref="T:System.Net.TransportContext" /> Dla <see cref="T:System.IO.Stream" />.</param>
        <param name="transportContext">
          <see cref="T:System.Net.TransportContext" /> Dla <see cref="T:System.IO.Stream" />.</param>
        <summary>Kończy żądanie asynchroniczne dla <see cref="T:System.IO.Stream" /> obiekt używany do zapisania danych i danych wyjściowych <see cref="T:System.Net.TransportContext" /> skojarzone ze strumienia.</summary>
        <returns>Element <see cref="T:System.IO.Stream" /> używany do zapisania danych żądania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> Ukończeniu metody asynchroniczne żądanie dla strumienia, które zostało uruchomione przez <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> metody i wyjścia <xref:System.Net.TransportContext> skojarzone ze strumienia. Po <xref:System.IO.Stream> został zwrócony obiekt, możesz wysłać danych za pomocą <xref:System.Net.HttpWebRequest> przy użyciu <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> metody.  
  
 Niektóre aplikacje, które używają zintegrowanego uwierzytelniania Windows przy użyciu mechanizmu rozszerzonej ochrony może być konieczne jest możliwość wykonywania zapytań warstwy transportowej posługują się <xref:System.Net.HttpWebRequest> aby można było pobrać token wiązania kanałów (CBT) z podstawowej kanał TLS. <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Metoda zapewnia dostęp do tych informacji w przypadku metod HTTP, które mają treść żądania (`POST` i `PUT` żądań). Jest to potrzebne tylko wtedy, jeśli aplikacja jest implementacja własnym uwierzytelnianiem i musi mieć dostęp do CBT.  
  
> [!NOTE]
>  Jeśli aplikacja musi ustawić wartość <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości, a następnie ten musi odbywać się przed pobieraniu strumienia i zapisywania danych.  
  
> [!CAUTION]
>  Należy wywołać <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> metodę, aby zamknąć strumień i wersji połączenia do ponownego wykorzystania. Nie można zamknąć strumień powoduje, że aplikacja całe wolne połączenia.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie został zwrócony przez bieżące wystąpienie z wywołania <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ta metoda została wywołana wcześniej przy użyciu <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.IO.IOException">Żądanie nie zostało ukończone, a nie usługa stream jest dostępna.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> był wcześniej nazywany programem.  - lub - wystąpił błąd podczas przetwarzania żądania.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Windows zintegrowane uwierzytelnianie przy użyciu mechanizmu rozszerzonej ochrony</related>
      </Docs>
    </Member>
    <Member MemberName="EndGetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse EndGetResponse (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse EndGetResponse(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetResponse(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetResponse (asyncResult As IAsyncResult) As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ EndGetResponse(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetResponse : IAsyncResult -&gt; System.Net.WebResponse" Usage="httpWebRequest.EndGetResponse asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oczekujące żądanie dla odpowiedzi.</param>
        <summary>Kończy się asynchroniczne żądanie do zasobu internetowego.</summary>
        <returns>Element <see cref="T:System.Net.WebResponse" /> zawierający odpowiedzi z zasobem internetowym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetResponse%2A> Ukończeniu metody asynchroniczne żądanie dla zasobu w Internecie, które zostało uruchomione przez wywołanie metody <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metody.  
  
> [!CAUTION]
>  Należy wywołać <xref:System.Net.HttpWebResponse.Close%2A> metodę, aby zamknąć strumień i wersji połączenia. Niewykonanie tej czynności może spowodować aplikację do uruchamiania z połączenia.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.HttpWebRequest.EndGetResponse%2A> metodę, aby zakończyć żądania asynchronicznego dla zasobu w Internecie.  
  
 [!code-cpp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CPP/httpwebrequest_begingetresponse.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CS/httpwebrequest_begingetresponse.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/VB/httpwebrequest_begingetresponse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ta metoda została wywołana wcześniej przy użyciu <paramref name="asyncResult." /> - lub - <see cref="P:System.Net.HttpWebRequest.ContentLength" /> właściwości jest większa niż 0, ale dane nie został zapisany do strumienia żądania.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> był wcześniej nazywany programem.  - lub - wystąpił błąd podczas przetwarzania żądania.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie został zwrócony przez bieżące wystąpienie z wywołania <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expect">
      <MemberSignature Language="C#" Value="public string Expect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Expect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Expect" />
      <MemberSignature Language="VB.NET" Value="Public Property Expect As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Expect { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Expect : string with get, set" Usage="System.Net.HttpWebRequest.Expect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see langword="Expect" /> nagłówka HTTP.</summary>
        <value>Zawartość <see langword="Expect" /> nagłówka HTTP. Wartość domyślna to <see langword="null" />.  
  
 <block subset="none" type="note"><para> Wartość tej właściwości jest przechowywana w <see cref="T:System.Net.WebHeaderCollection" />. Jeśli ustawiono WebHeaderCollection, wartość właściwości zostaną utracone.  </para></block></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <see langword="Expect" /> ustawiono ciąg, który zawiera "100 — Kontynuuj" jako podciąg.</exception>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="httpWebRequest.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected override void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="httpWebRequest.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> Do wypełniania danymi.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> Określa, że lokalizacja docelowa tej serializacji.</param>
        <summary>Wypełnia <see cref="T:System.Runtime.Serialization.SerializationInfo" /> przy użyciu danych wymaganych do zserializowania obiektu docelowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie obiekty zawarte w <xref:System.Runtime.Serialization.SerializationInfo> są automatycznie śledzone i serializowany przez program formatujący.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera <see cref="T:System.IO.Stream" /> obiekt ma być używany do zapisywania danych na żądanie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetRequestStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetRequestStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRequestStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetRequestStream();" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream : unit -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="T:System.IO.Stream" /> obiekt ma być używany do zapisywania danych na żądanie.</summary>
        <returns>Element <see cref="T:System.IO.Stream" /> używany do zapisania danych żądania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Metoda zwraca strumienia na potrzeby wysyłania danych <xref:System.Net.HttpWebRequest>. Po <xref:System.IO.Stream> został zwrócony obiekt, możesz wysłać danych za pomocą <xref:System.Net.HttpWebRequest> przy użyciu <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> metody.  
  
 Jeśli aplikacja musi ustawić wartość <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości, a następnie ten musi odbywać się przed pobraniem strumienia.  
  
 Należy wywołać <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> metodę, aby zamknąć strumień i wersji połączenia do ponownego wykorzystania. Nie można zamknąć strumień powoduje, że aplikacja całe wolne połączenia.  
  
> [!NOTE]
>  Aplikacja nie można mieszać synchroniczne i asynchroniczne metody dla określonego żądania. Jeśli wywołasz <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metody, należy użyć <xref:System.Net.HttpWebRequest.GetResponse%2A> metodę, aby pobrać odpowiedzi.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metodę, aby zwrócić wystąpienie strumienia.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> Właściwość jest GET lub HEAD.  - lub - <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> jest <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> jest <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> wynosi -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" />, i <see cref="P:System.Net.HttpWebRequest.Method" /> to POST lub PUT.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> Metoda jest wywoływana więcej niż jeden raz.  - lub - <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> jest ustawiona na wartość i <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Pamięci podręcznej żądań modułu sprawdzania poprawności wskazane, czy odpowiedzi na to żądanie mogą być udostępniane z pamięci podręcznej; jednak żądań, zapisywać dane, które nie mogą używać pamięci podręcznej. Ten wyjątek może wystąpić, jeśli używane są niepoprawnie zaimplementowano sprawdzania poprawności niestandardowych pamięci podręcznej.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> był wcześniej nazywany programem.  - lub - limitu czasu dla żądania.  - lub - wystąpił błąd podczas przetwarzania żądania.</exception>
        <exception cref="T:System.ObjectDisposedException">W aplikacji platformy .NET Compact Framework strumienia żądania o zerowej długości zawartości nie zostały uzyskane a poprawnie zamknięty. Aby uzyskać więcej informacji na temat obsługi żądań zerowej długości zawartości, zobacz [sieci programowania na platformie .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetRequestStream (out System.Net.TransportContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetRequestStream([out] class System.Net.TransportContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream(System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRequestStream (ByRef context As TransportContext) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetRequestStream([Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream :  -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Net.TransportContext" RefType="out" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Net.TransportContext" /> Dla <see cref="T:System.IO.Stream" />.</param>
        <summary>Pobiera <see cref="T:System.IO.Stream" /> obiekt używany do zapisania danych żądania i dane wyjściowe <see cref="T:System.Net.TransportContext" /> skojarzone ze strumienia.</summary>
        <returns>Element <see cref="T:System.IO.Stream" /> używany do zapisania danych żądania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Metoda zwraca strumienia na potrzeby wysyłania danych <xref:System.Net.HttpWebRequest> i generuje <xref:System.Net.TransportContext> skojarzone ze strumienia. Po <xref:System.IO.Stream> został zwrócony obiekt, możesz wysłać danych za pomocą <xref:System.Net.HttpWebRequest> przy użyciu <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> metody.  
  
 Niektóre aplikacje, które używają zintegrowanego uwierzytelniania Windows przy użyciu mechanizmu rozszerzonej ochrony może być konieczne jest możliwość wykonywania zapytań warstwy transportowej posługują się <xref:System.Net.HttpWebRequest> aby można było pobrać token wiązania kanałów (CBT) z podstawowej kanał TLS. <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Metoda zapewnia dostęp do tych informacji w przypadku metod HTTP, które mają treść żądania (`POST` i `PUT` żądań). Jest to potrzebne tylko wtedy, jeśli aplikacja jest implementacja własnym uwierzytelnianiem i musi mieć dostęp do CBT.  
  
 Jeśli aplikacja musi ustawić wartość <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości, a następnie ten musi odbywać się przed pobraniem strumienia.  
  
 Należy wywołać <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> metodę, aby zamknąć strumień i wersji połączenia do ponownego wykorzystania. Nie można zamknąć strumień powoduje, że aplikacja całe wolne połączenia.  
  
> [!NOTE]
>  Aplikacja nie można mieszać synchroniczne i asynchroniczne metody dla określonego żądania. Jeśli wywołasz <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metody, należy użyć <xref:System.Net.HttpWebRequest.GetResponse%2A> metodę, aby pobrać odpowiedzi.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">
          <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> Metoda nie może uzyskać <see cref="T:System.IO.Stream" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> Metoda jest wywoływana więcej niż jeden raz.  - lub - <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> jest ustawiona na wartość i <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Pamięci podręcznej żądań modułu sprawdzania poprawności wskazane, czy odpowiedzi na to żądanie mogą być udostępniane z pamięci podręcznej; jednak żądań, zapisywać dane, które nie mogą używać pamięci podręcznej. Ten wyjątek może wystąpić, jeśli używane są niepoprawnie zaimplementowano sprawdzania poprawności niestandardowych pamięci podręcznej.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> Właściwość jest GET lub HEAD.  - lub - <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> jest <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> jest <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> wynosi -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" />, i <see cref="P:System.Net.HttpWebRequest.Method" /> to POST lub PUT.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> był wcześniej nazywany programem.  - lub - limitu czasu dla żądania.  - lub - wystąpił błąd podczas przetwarzania żądania.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse GetResponse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse GetResponse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetResponse () As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ GetResponse();" />
      <MemberSignature Language="F#" Value="override this.GetResponse : unit -&gt; System.Net.WebResponse" Usage="httpWebRequest.GetResponse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca odpowiedź z zasobem internetowym.</summary>
        <returns>Element <see cref="T:System.Net.WebResponse" /> zawierający odpowiedzi z zasobem internetowym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetResponse%2A> Metoda zwraca <xref:System.Net.WebResponse> obiekt, który zawiera odpowiedź z zasobem internetowym. Zwrócony rzeczywistego wystąpienia <xref:System.Net.HttpWebResponse>i może być rzutowanie typu dla tej klasy do właściwości dostępu właściwe dla protokołu HTTP.  
  
 A <xref:System.Net.ProtocolViolationException> jest zgłaszany w kilku przypadkach, gdy właściwości ustawione na <xref:System.Net.HttpWebRequest> klasy są w konflikcie. Ten wyjątek występuje, jeśli aplikacja ustawia <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości i <xref:System.Net.HttpWebRequest.SendChunked%2A> właściwości `true`, a następnie wysyła żądanie HTTP GET. Ten wyjątek występuje, gdy aplikacja próbuje wysłać podzielony na serwerze, który obsługuje tylko protokół HTTP 1.0, gdzie jest to nieobsługiwane. Ten wyjątek występuje, gdy aplikacja próbuje wysłać dane bez ustawienia <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości lub <xref:System.Net.HttpWebRequest.SendChunked%2A> jest `false` gdy buforowanie jest wyłączone i połączenia keepalive ( <xref:System.Net.HttpWebRequest.KeepAlive%2A> właściwość `true`)`.`  
  
> [!CAUTION]
>  Należy wywołać <xref:System.Net.HttpWebResponse.Close%2A> metodę, aby zamknąć strumień i wersji połączenia. Niewykonanie tej czynności może spowodować aplikację do uruchamiania z połączenia.  
  
 Za pomocą metody POST, należy uzyskać strumienia żądania, zapisać danych do opublikowania, a następnie zamknij strumienia. Ta metoda blokuje oczekuje na zawartość do opublikowania; Jeśli nie ustawiono limit czasu, a nie są oferowane zawartość, wywołujący bloki wątku na czas nieokreślony.  
  
> [!NOTE]
>  Wiele wywołań <xref:System.Net.HttpWebRequest.GetResponse%2A> zwracać ten sam obiekt odpowiedzi; nie jest ponownie w żądaniu.  
  
> [!NOTE]
>  Aplikacja nie można mieszać synchroniczne i asynchroniczne metody dla określonego żądania. Jeśli wywołasz <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metody, należy użyć <xref:System.Net.HttpWebRequest.GetResponse%2A> metodę, aby pobrać odpowiedzi.  
  
> [!NOTE]
>  Jeśli <xref:System.Net.WebException> jest generowany, użyj <xref:System.Net.WebException.Response%2A> i <xref:System.Net.WebException.Status%2A> właściwości wyjątku, aby określić odpowiedź z serwera.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Ze względów bezpieczeństwa pliki cookie są domyślnie wyłączone. Jeśli chcesz używać plików cookie, należy użyć <xref:System.Net.HttpWebRequest.CookieContainer%2A> właściwość, aby włączyć obsługę plików cookie.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera odpowiedzi na żądanie.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Strumień jest już używany przez poprzednie wywołanie <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.  - lub - <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> jest ustawiona na wartość i <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" />.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> to GET lub HEAD, a następnie <see cref="P:System.Net.HttpWebRequest.ContentLength" /> jest większa lub równa zero lub <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="true" />.  - lub - <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> jest <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> jest <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> wynosi -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" />, i <see cref="P:System.Net.HttpWebRequest.Method" /> to POST lub PUT.  - lub - <see cref="T:System.Net.HttpWebRequest" /> zawiera treść jednostki, ale <see cref="M:System.Net.HttpWebRequest.GetResponse" /> metoda jest wywoływana bez wywoływania <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> metody.  - lub - <see cref="P:System.Net.HttpWebRequest.ContentLength" /> jest większa niż zero, ale aplikacja nie zapisuje wszystkie dane uzgodnionego.</exception>
        <exception cref="T:System.NotSupportedException">Pamięci podręcznej żądań modułu sprawdzania poprawności wskazane, czy odpowiedzi na to żądanie mogą być udostępniane z pamięci podręcznej; Jednak to żądanie zawiera dane mają być wysyłane do serwera. Żądania, które wysyłają dane nie mogą używać pamięci podręcznej. Ten wyjątek może wystąpić, jeśli używane są niepoprawnie zaimplementowano sprawdzania poprawności niestandardowych pamięci podręcznej.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> był wcześniej nazywany programem.  - lub - limitu czasu dla żądania.  - lub - wystąpił błąd podczas przetwarzania żądania.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="HaveResponse">
      <MemberSignature Language="C#" Value="public virtual bool HaveResponse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HaveResponse" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.HaveResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HaveResponse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HaveResponse { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HaveResponse : bool" Usage="System.Net.HttpWebRequest.HaveResponse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy odebrano odpowiedź z zasobem internetowym.</summary>
        <value>
          <see langword="true" /> Jeśli Odebrano odpowiedź; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod przykładowy kontroli <xref:System.Net.HttpWebRequest.HaveResponse%2A> właściwości w celu określenia, jeśli odebrano odpowiedź z zasobem internetowym.  
  
 [!code-cpp[Httpwebrequest_HaveResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CPP/httpwebrequest_haveresponse.cpp#1)]
 [!code-csharp[Httpwebrequest_HaveResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CS/httpwebrequest_haveresponse.cs#1)]
 [!code-vb[Httpwebrequest_HaveResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/VB/httpwebrequest_haveresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public override System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Headers As WebHeaderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::WebHeaderCollection ^ Headers { System::Net::WebHeaderCollection ^ get(); void set(System::Net::WebHeaderCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Net.WebHeaderCollection with get, set" Usage="System.Net.HttpWebRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa kolekcję par nazwa/wartość, które tworzą nagłówki HTTP.</summary>
        <value>Element <see cref="T:System.Net.WebHeaderCollection" /> zawierający pary nazwa/wartość, które tworzą nagłówki dla żądania HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Headers%2A> Kolekcja zawiera nagłówki protokołu skojarzony z tym żądaniem. Poniższa tabela zawiera listę nagłówków HTTP, które nie są przechowywane w <xref:System.Net.HttpWebRequest.Headers%2A> kolekcji, ale nie są ustawione przez system albo ustawić, właściwości lub metody.  
  
|nagłówek|Ustawione przez|  
|------------|------------|  
|Zaakceptuj|Ustawione przez <xref:System.Net.HttpWebRequest.Accept%2A> właściwości.|  
|połączenia|Ustawione przez <xref:System.Net.HttpWebRequest.Connection%2A> właściwości i <xref:System.Net.HttpWebRequest.KeepAlive%2A> właściwości.|  
|Długość zawartości|Ustawione przez <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości.|  
|Typ zawartości|Ustawione przez <xref:System.Net.HttpWebRequest.ContentType%2A> właściwości.|  
|Oczekiwane|Ustawione przez <xref:System.Net.HttpWebRequest.Expect%2A> właściwości.|  
|Data|Ustawione przez <xref:System.Net.HttpWebRequest.Date%2A> właściwości.|  
|Host|Ustawione przez <xref:System.Net.HttpWebRequest.Host%2A> właściwości.|  
|If-Modified-Since|Ustawione przez <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> właściwości.|  
|Zakres|Ustawione przez <xref:System.Net.HttpWebRequest.AddRange%2A> metody.|  
|Odnośnik|Ustawione przez <xref:System.Net.HttpWebRequest.Referer%2A> właściwości.|  
|Transfer-Encoding|Ustawione przez <xref:System.Net.HttpWebRequest.TransferEncoding%2A> właściwości ( <xref:System.Net.HttpWebRequest.SendChunked%2A> właściwości muszą być spełnione).|  
|Agent użytkownika|Ustawione przez <xref:System.Net.HttpWebRequest.UserAgent%2A> właściwości.|  
  
 <xref:System.Net.WebHeaderCollection.Add%2A> Metoda zgłasza wyjątek <xref:System.ArgumentException> Jeśli spróbujesz ustawić jedną z tych nagłówków chronionych.  
  
 Zmiana <xref:System.Net.HttpWebRequest.Headers%2A> właściwości po rozpoczęciu żądania przez wywołanie metody <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, lub <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metoda zgłasza wyjątek <xref:System.InvalidOperationException>.  
  
 Nie należy zakładać, że wartości nagłówka pozostaną niezmienione, ponieważ serwery sieci Web i pamięci podręczne mogą zmienić lub dodać nagłówków żądania sieci Web.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.HttpWebRequest.Headers%2A> właściwość do wydrukowania pary nazwa/wartość nagłówka HTTP do konsoli.  
  
 [!code-cpp[HttpWebRequest_Headers#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Headers/CPP/httpwebrequest_headers.cpp#1)]
 [!code-csharp[HttpWebRequest_Headers#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Headers/CS/httpwebrequest_headers.cs#1)]
 [!code-vb[HttpWebRequest_Headers#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Headers/VB/httpwebrequest_headers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żądania został uruchomiony, wywołując <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, lub <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> metody.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Host" />
      <MemberSignature Language="VB.NET" Value="Public Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : string with get, set" Usage="System.Net.HttpWebRequest.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobierz lub ustaw wartość nagłówka do użycia w żądaniu HTTP niezależnie od identyfikatora URI żądania hosta.</summary>
        <value>Wartość nagłówka hosta w żądaniu HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Host%2A> Właściwość można ustawić hostów wartość nagłówka do użycia w żądaniu HTTP niezależnie od identyfikatora URI żądania. <xref:System.Net.HttpWebRequest.Host%2A> Właściwość może składać się z nazwy hosta i numer portu opcjonalne. Nagłówek hosta, bez informacji o porcie oznacza domyślny port dla żądanej usługi (port 80 dla adresu URL HTTP, na przykład).  
  
 Format do określania nazwy hosta i portu, należy wykonać reguły w sekcji 14.23 specyfikacją RFC2616 opublikowane przez grupę IETF. Przykład spełniające te wymagania, który określa to port 8080 będzie następującą wartość dla <xref:System.Net.HttpWebRequest.Host%2A> właściwości:  
  
 `www.contoso.com:8080`  
  
 Za pomocą <xref:System.Net.HttpWebRequest.Host%2A> właściwość jawnie określić niestandardową wartość nagłówka hosta również ma wpływ na obszary pamięci podręcznej plików cookie i uwierzytelniania. W przypadku aplikacji zapewnia poświadczenia dla określonego prefiksu identyfikatora URI, aplikacje trzeba koniecznie Użyj identyfikatora URI zawierającego wartość nagłówka hosta, a nie na serwerze docelowym w identyfikatorze URI. Klucz używany podczas buforowania zasobów, używa wartość nagłówka hosta, a nie identyfikatora URI żądania. Pliki cookie są przechowywane w <xref:System.Net.CookieContainer> i logicznie pogrupowane według nazwy domeny serwera. Gdy aplikacja określa nagłówek hosta, ta wartość będzie używana jako domena.  
  
 Jeśli <xref:System.Net.HttpWebRequest.Host%2A> nie ustawiono właściwości, a następnie wartość nagłówka hosta do użycia w żądaniu HTTP zależy od identyfikatora URI żądania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Nie można ustawić nagłówek hosta <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nagłówek hosta nie można ustawić na nieprawidłową wartość.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można ustawić nagłówek hosta po <see cref="T:System.Net.HttpWebRequest" /> rozpoczął się już do wysłania.</exception>
      </Docs>
    </Member>
    <Member MemberName="IfModifiedSince">
      <MemberSignature Language="C#" Value="public DateTime IfModifiedSince { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime IfModifiedSince" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberSignature Language="VB.NET" Value="Public Property IfModifiedSince As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime IfModifiedSince { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.IfModifiedSince : DateTime with get, set" Usage="System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see langword="If-Modified-Since" /> nagłówka HTTP.</summary>
        <value>A <see cref="T:System.DateTime" /> zawierający zawartość <see langword="If-Modified-Since" /> nagłówka HTTP. Wartością domyślną jest bieżąca data i godzina.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> Właściwość jest standardem <xref:System.DateTime?displayProperty=nameWithType> obiektu i może zawierać <xref:System.DateTimeKind?displayProperty=nameWithType> pole <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, lub <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Dowolny rodzaj czasu można ustawić przy użyciu <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> właściwości. Jeśli <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> zostaje ustawiona lub pobraniu <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> właściwość zakłada się, że <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (czas lokalny).  
  
 Klasy w <xref:System.Net> przestrzeni nazw zawsze zapisać go <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> właściwości na łączu podczas transmisji w postaci standardowych przy użyciu formatu GMT (czas Utc).  
  
 Jeśli <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> właściwość jest ustawiona na <xref:System.DateTime.MinValue?displayProperty=nameWithType>, a następnie `If-Modified-Since` nagłówka HTTP jest usuwany z <xref:System.Net.HttpWebRequest.Headers%2A> właściwości i <xref:System.Net.WebHeaderCollection>.  
  
 Jeśli <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> właściwość <xref:System.DateTime.MinValue?displayProperty=nameWithType>, oznacza to, że `If-Modified-Since` nagłówka HTTP nie jest uwzględniony w <xref:System.Net.HttpWebRequest.Headers%2A> właściwości i <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  Wartość tej właściwości jest przechowywana w <xref:System.Net.WebHeaderCollection>. Jeśli ustawiono WebHeaderCollection, wartość właściwości zostaną utracone.  
  
   
  
## Examples  
 Poniższy kod przykładowy kontroli <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> właściwości.  
  
 [!code-cpp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CPP/httpwebrequest_ifmodifiedsince.cpp#1)]
 [!code-csharp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CS/httpwebrequest_ifmodifiedsince.cs#1)]
 [!code-vb[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/VB/httpwebrequest_ifmodifiedsince.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool with get, set" Usage="System.Net.HttpWebRequest.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy należy ustanowić trwałe połączenie z zasobem internetowym.</summary>
        <value>
          <see langword="true" /> Jeśli żądanie do zasobu internetowego powinna zawierać <see langword="Connection" /> nagłówka HTTP z wartością Keep-alive; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw tę właściwość na `true` wysyłać `Connection` nagłówka HTTP z wartością Keep-alive. Aplikacja używa <xref:System.Net.HttpWebRequest.KeepAlive%2A> do wskazania preferencji połączeń trwałych. Gdy <xref:System.Net.HttpWebRequest.KeepAlive%2A> właściwość `true`, aplikacja sprawia, że trwałe połączenia z serwerami, które je obsługują.  
  
> [!NOTE]
>  Korzystając z protokołu HTTP/1.1, Keep-Alive jest domyślnie włączone. Ustawienie <xref:System.Net.HttpWebRequest.KeepAlive%2A> do `false` może spowodować wysyłanie `Connection: Close` nagłówka do serwera.  
  
   
  
## Examples  
 Poniższy kod ustawia przykład <xref:System.Net.HttpWebRequest.KeepAlive%2A> właściwość `false` w celu uniknięcia ustanawiania trwałego połączenia z zasobem internetowym.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumAutomaticRedirections">
      <MemberSignature Language="C#" Value="public int MaximumAutomaticRedirections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumAutomaticRedirections" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumAutomaticRedirections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumAutomaticRedirections { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumAutomaticRedirections : int with get, set" Usage="System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną liczbę przekierowań, które następują żądania.</summary>
        <value>Maksymalna liczba odpowiedzi przekierowania, które następują żądania. Wartością domyślną jest 50.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> Właściwość ustawia maksymalną liczbę przekierowań dla żądania w przypadku <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> właściwość `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia wartość tej właściwości.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość jest ustawiona na 0 lub mniej.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną dozwoloną długość nagłówków odpowiedzi.</summary>
        <value>Długość w kilobajtach (1024 bajty), nagłówki odpowiedzi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Długość określonego nagłówka żądania zawiera wiersz stanu odpowiedzi i żadnych znaków kontrolnych dodatkowe, które są odbierane w ramach protokołu HTTP. Wartość-1 oznacza, że limit nie nakłada się na nagłówki odpowiedzi; wartość 0 oznacza, że wszystkie żądania się nie powieść.  
  
 Jeśli <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> właściwość nie została jawnie ustawiona, jego wartość domyślna to wartość <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A> właściwości.  
  
 Jeśli długość nagłówka odpowiedzi odebrany przekracza wartość <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> właściwości <xref:System.Net.HttpWebRequest.EndGetResponse%2A> lub <xref:System.Net.HttpWebRequest.GetResponse%2A> zgłosi metody <xref:System.Net.WebException> z <xref:System.Net.WebException.Status%2A> właściwością <xref:System.Net.WebExceptionStatus.MessageLengthLimitExceeded>.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia wartość tej właściwości.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Właściwość jest ustawiona, po żądanie zostało już przesłane.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość jest mniejsza niż 0 i nie jest równy-1.</exception>
      </Docs>
    </Member>
    <Member MemberName="MediaType">
      <MemberSignature Language="C#" Value="public string MediaType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MediaType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MediaType" />
      <MemberSignature Language="VB.NET" Value="Public Property MediaType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MediaType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MediaType : string with get, set" Usage="System.Net.HttpWebRequest.MediaType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ nośnika żądania.</summary>
        <value>Typ nośnika żądania. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.Net.HttpWebRequest.MediaType%2A> właściwość ma wpływ na <xref:System.Net.HttpWebResponse.CharacterSet%2A> właściwości. Po ustawieniu <xref:System.Net.HttpWebRequest.MediaType%2A> w żądaniu, wybrano odpowiedni typ nośnika, z listy zestawów znaków, zwrócona w odpowiedzi `Content-type` nagłówka HTTP.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public override string Method { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Method" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Method" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Method As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Method { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Method : string with get, set" Usage="System.Net.HttpWebRequest.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia metodę żądania.</summary>
        <value>Metoda żądania na potrzeby skontaktuj się z zasobem internetowym. Wartość domyślna to GET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Method%2A> Właściwość można ustawić do dowolnych poleceń protokołu HTTP 1.1: GET, HEAD, POST, PUT, Usuń śledzenia lub opcji.  
  
 Jeśli <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwość jest ustawiona na wartość inną niż -1, <xref:System.Net.HttpWebRequest.Method%2A> do właściwości protokołu, która przekazuje dane, można ustawić właściwości.  
  
   
  
## Examples  
 Poniższy kod ustawia przykład <xref:System.Net.HttpWebRequest.Method%2A> właściwości wpisu.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Brak metody jest dostarczany.  - lub - ciąg metody zawiera nieprawidłowe znaki.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pipelined">
      <MemberSignature Language="C#" Value="public bool Pipelined { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Pipelined" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Pipelined" />
      <MemberSignature Language="VB.NET" Value="Public Property Pipelined As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Pipelined { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Pipelined : bool with get, set" Usage="System.Net.HttpWebRequest.Pipelined" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy potok żądań z zasobem internetowym.</summary>
        <value>
          <see langword="true" /> Jeśli żądanie powinno być potokowe; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja używa <xref:System.Net.HttpWebRequest.Pipelined%2A> właściwości do wskazania preferencji dla połączeń w trybie potokowym. Gdy <xref:System.Net.HttpWebRequest.Pipelined%2A> jest `true`, aplikacja sprawia, że potokowej połączeń z serwerami, które je obsługują.  
  
 Potokowane połączenia są nawiązywane tylko wtedy, gdy <xref:System.Net.HttpWebRequest.KeepAlive%2A> właściwość jest również `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu drukuje wartość <xref:System.Net.HttpWebRequest.Pipelined%2A> właściwości do konsoli.  
  
 [!code-cpp[HttpWebRequest_PipeLined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CPP/httpwebrequest_pipelined.cpp#1)]
 [!code-csharp[HttpWebRequest_PipeLined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CS/httpwebrequest_pipelined.cs#1)]
 [!code-vb[HttpWebRequest_PipeLined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_PipeLined/VB/httpwebrequest_pipelined.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public override bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreAuthenticate : bool with get, set" Usage="System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy mają być wysyłane z żądaniem nagłówek autoryzacji.</summary>
        <value>
          <see langword="true" /> Aby wysłać nagłówka autoryzacji HTTP z żądaniami, po przeprowadzeniu uwierzytelniania; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wykonaniu żądania klienta, z konkretnym <xref:System.Uri> zostanie pomyślnie uwierzytelniony, jeśli <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> jest `true` i podano poświadczenia, nagłówek autoryzacji są wysyłane z każdym żądaniem do dowolnego <xref:System.Uri> odpowiadającej konkretnym <xref:System.Uri>do ostatniego ukośnikiem. Jeśli żądanie klienta pomyślnie uwierzytelniony z konkretnym <xref:System.Uri> zawiera następujące czynności:  
  
 `http://www.contoso.com/firstpath/`  
  
 Nagłówek autoryzacji do wstępnego uwierzytelniania są wysyłane z każdym żądaniem do żadnego z następujących czynności, a następnie <xref:System.Uri> wystąpień:  
  
 `http://www.contoso.com/firstpath/`  
  
 `http://www.contoso.com/firstpath/default`  
  
 `http://www.contoso.com/firstpath/default.html`  
  
 `http://www.contoso.com/firstpath/sample.html`  
  
 Jednak nagłówek autoryzacji nie są wysyłane z żądania do żadnego z następujących <xref:System.Uri> wystąpień:  
  
 `http://www.contoso.com/`  
  
 `http://www.contoso.com/firstpath`  
  
 `http://www.contoso.com/secondpath/`  
  
 Jeśli klient żądania z konkretnym <xref:System.Uri> to żądanie nie zostało pomyślnie uwierzytelniony, stosowane są standardowe uwierzytelnianie procedury.  
  
 Z wyjątkiem pierwszego żądania <xref:System.Net.WebRequest.PreAuthenticate%2A> właściwość wskazuje, czy wysłać informacje dotyczące uwierzytelniania z kolejnych żądań <xref:System.Uri> odpowiadającej konkretnym <xref:System.Uri> do ostatniego ukośnik bez konieczności oczekiwania jako zostaną zakwestionowane przez serwer.  
  
 Następujące okno dialogowe między klientem i serwerem przedstawia efekt tej właściwości. Okno dialogowe przyjęto założenie, że uwierzytelniania podstawowego jest w użyciu.  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> jest `false`:  
  
 Klienta: SomeUrl GET  
  
 Serwera: Basic 401 WWW-Authenticate  
  
 Klienta: Pobierz nagłówki autoryzacji  
  
 Serwer: 200 OK  
  
 Klienta: SomeUrl GET  
  
 Serwera: Basic 401 WWW-Authenticate  
  
 Klienta: Pobierz nagłówki autoryzacji  
  
 Serwer: 200 OK  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> jest `true`:  
  
 Klienta: SomeUrl GET  
  
 Serwera: Basic 401 WWW-Authenticate  
  
 Klienta: Pobierz nagłówki autoryzacji  
  
 Serwer: 200 OK  
  
 Klient: Uzyskaj someUrl nagłówki autoryzacji  
  
 Jeśli schemat uwierzytelniania nie obsługuje uwierzytelniania wstępnego, wartość tej właściwości jest ignorowana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolVersion : Version with get, set" Usage="System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wersję protokołu HTTP do użycia dla żądania.</summary>
        <value>Wersja protokołu HTTP do użycia dla żądania. Wartość domyślna to <see cref="F:System.Net.HttpVersion.Version11" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest> Klasy obsługuje tylko w wersjach 1.0 i 1.1 protokołu HTTP. Ustawienie <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> zgłasza wyjątek, do innej wersji.  
  
> [!NOTE]
>  Aby ustawić wersję bieżącego żądania HTTP, użyj <xref:System.Net.HttpVersion.Version10> i <xref:System.Net.HttpVersion.Version11> pola <xref:System.Net.HttpVersion> klasy.  
  
   
  
## Examples  
 Poniższy kod ustawia przykład <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> właściwości.  
  
 [!code-cpp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CPP/httpwebrequest_protocolversion.cpp#1)]
 [!code-csharp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CS/httpwebrequest_protocolversion.cs#1)]
 [!code-vb[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/VB/httpwebrequest_protocolversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wersja HTTP została ustawiona na wartość inną niż 1.0 i 1.1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Proxy : System.Net.IWebProxy with get, set" Usage="System.Net.HttpWebRequest.Proxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje o serwerze proxy dla żądania.</summary>
        <value>
          <see cref="T:System.Net.IWebProxy" /> Obiektu za pomocą serwera proxy żądania. Wartość domyślna jest ustawiana przez wywołanie metody <see cref="P:System.Net.GlobalProxySelection.Select" /> właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Proxy%2A> Właściwość identyfikuje <xref:System.Net.WebProxy> obiekt ma być używany do przetwarzania żądań z zasobami internetowymi. Aby określić, że powinny być używane bez serwera proxy, należy ustawić <xref:System.Net.HttpWebRequest.Proxy%2A> wystąpienie serwera proxy zwrócone przez właściwość <xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A?displayProperty=nameWithType> metody.  
  
 Komputer lokalny lub pliku konfiguracji aplikacji może określić, że używane domyślny serwer proxy. Jeśli <xref:System.Net.HttpWebRequest.Proxy%2A> właściwość zostanie określona, następnie ustawienia serwera proxy z <xref:System.Net.HttpWebRequest.Proxy%2A> właściwości zastąpienia komputera lokalnego lub pliku konfiguracji aplikacji i <xref:System.Net.HttpWebRequest> wystąpienia użyje określone ustawienia serwera proxy. Jeśli żaden serwer proxy jest określona w pliku konfiguracji i <xref:System.Net.HttpWebRequest.Proxy%2A> właściwość jest nieokreślony, <xref:System.Net.HttpWebRequest> klasa używa ustawień serwera proxy dziedziczone z programu Internet Explorer na komputerze lokalnym. Jeśli nie istnieją żadne ustawienia serwera proxy w programie Internet Explorer, żądanie jest wysyłane bezpośrednio do serwera.  
  
 <xref:System.Net.HttpWebRequest> Analizuje klasy listy obejścia serwera proxy, z symbolami wieloznacznymi dziedziczone z programu Internet Explorer taka sama jak lista pomijania jest analizowany bezpośrednio przez program Internet Explorer. Na przykład <xref:System.Net.HttpWebRequest> klasy będzie analizować listę obejścia "nt *" w programie Internet Explorer jako wyrażenie regularne "nt.\*". Dlatego adres URL "`http://nt.com`" spowoduje obejścia serwera proxy przy użyciu <xref:System.Net.HttpWebRequest> klasy i za pomocą programu Internet Explorer.  
  
 <xref:System.Net.HttpWebRequest> Klasa obsługuje obejście lokalnego serwera proxy. Klasa uwzględnia lokalizację docelową, aby określać elementy lokalne, jeśli spełnione są następujące warunki:  
  
-   Lokalizacja docelowa zawiera płaskiej nazwy (nie kropki w adresie URL).  
  
-   Lokalizacja docelowa zawiera adres sprzężenia zwrotnego (<xref:System.Net.IPAddress.Loopback> lub <xref:System.Net.IPAddress.IPv6Loopback>) lub lokalizacja docelowa zawiera <xref:System.Net.IPAddress> przypisanych do komputera lokalnego.  
  
-   Sufiks domeny docelowej pasuje sufiks domeny komputera lokalnego (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>).  
  
 Zmiana <xref:System.Net.HttpWebRequest.Proxy%2A> właściwości po rozpoczęciu żądania przez wywołanie metody <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, lub <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metoda zgłasza wyjątek <xref:System.InvalidOperationException>. Instrukcje dotyczące element serwera proxy, zobacz [ \&lt; defaultProxy\&gt; Element (ustawienia sieci)](~/docs/framework/configure-apps/file-schema/network/defaultproxy-element-network-settings.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.HttpWebRequest.Proxy%2A> metodę, aby uzyskać informacje o serwerze proxy dla żądania.  
  
 [!code-cpp[Httpwebrequest_proxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_proxy/CPP/httpwebrequest_proxy.cpp#1)]
 [!code-csharp[Httpwebrequest_proxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_proxy/CS/httpwebrequest_proxy.cs#1)]
 [!code-vb[Httpwebrequest_proxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_proxy/VB/httpwebrequest_proxy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.HttpWebRequest.Proxy" /> ustawiono <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Żądania został uruchomiony, wywołując <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, lub <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma uprawnienia dla żądanej operacji.</exception>
        <permission cref="T:System.Net.WebPermission">Do pobierania lub ustawiania <see cref="P:System.Net.HttpWebRequest.Proxy" /> właściwości. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadWriteTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia limit czasu w milisekundach, podczas zapisywania i odczytywania ze strumienia.</summary>
        <value>Liczba milisekund, zanim zapisu lub odczytu upłynie limit czasu. Wartość domyślna to 300 000 milisekund (5 minut).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> Właściwość jest używana podczas zapisywania Strumień zwrócony przez <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metody lub odczytu z Strumień zwrócony przez <xref:System.Net.HttpWebResponse.GetResponseStream%2A> metody.  
  
 W szczególności <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> właściwość określa limit czasu dla <xref:System.IO.Stream.Read%2A> metody, która jest używany do odczytu Strumień zwrócony przez <xref:System.Net.HttpWebResponse.GetResponseStream%2A> metody i <xref:System.IO.Stream.Write%2A> metody, która służy do zapisywania Strumień zwrócony przez <xref:System.Net.HttpWebRequest.GetRequestStream%2A>metody.  
  
 Aby określić ilość czasu oczekiwania na zakończenie żądania, użyj <xref:System.Net.HttpWebRequest.Timeout%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawić <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> właściwości.  
  
 [!code-csharp[Classic HttpWebRequest Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żądanie zostało wysłane.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość określona dla operacji zestawu jest mniejsza niż zero, a nie równa się <see cref="F:System.Threading.Timeout.Infinite" /></exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="Referer">
      <MemberSignature Language="C#" Value="public string Referer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Referer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Referer" />
      <MemberSignature Language="VB.NET" Value="Public Property Referer As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Referer { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Referer : string with get, set" Usage="System.Net.HttpWebRequest.Referer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see langword="Referer" /> nagłówka HTTP.</summary>
        <value>Wartość <see langword="Referer" /> nagłówka HTTP. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> właściwość `true`, <xref:System.Net.HttpWebRequest.Referer%2A> właściwość jest ustawiana automatycznie, gdy żądanie jest przekierowywane do innej lokacji.  
  
 Aby wyczyścić `Referer` Ustaw nagłówek HTTP <xref:System.Net.HttpWebRequest.Referer%2A> właściwość `null`.  
  
> [!NOTE]
>  Wartość tej właściwości jest przechowywana w <xref:System.Net.WebHeaderCollection>. Jeśli ustawiono WebHeaderCollection, wartość właściwości zostaną utracone.  
  
   
  
## Examples  
 Poniższy kod ustawia przykład <xref:System.Net.HttpWebRequest.Referer%2A> właściwości.  
  
 [!code-cpp[HttpWebRequest_Referer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Referer/CPP/httpwebrequest_referer.cpp#1)]
 [!code-csharp[HttpWebRequest_Referer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Referer/CS/httpwebrequest_referer.cs#1)]
 [!code-vb[HttpWebRequest_Referer#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Referer/VB/httpwebrequest_referer.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestUri">
      <MemberSignature Language="C#" Value="public override Uri RequestUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri RequestUri" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.RequestUri" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RequestUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Uri ^ RequestUri { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestUri : Uri" Usage="System.Net.HttpWebRequest.RequestUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera oryginalnego identyfikatora URI (Uniform Resource) żądania.</summary>
        <value>A <see cref="T:System.Uri" /> zawierający identyfikator URI zasobu internetowego przekazany do <see cref="M:System.Net.WebRequest.Create(System.String)" /> metody.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri> Obiekt przekazany do <xref:System.Net.HttpWebRequest> przez wywołanie <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>.  
  
 Nagłówek następujące przekierowanie nie zmienia się <xref:System.Net.HttpWebRequest.RequestUri%2A> właściwości. Aby uzyskać rzeczywisty identyfikator URI, który odpowiedział na żądanie, sprawdź <xref:System.Net.HttpWebRequest.Address%2A> właściwości.  
  
   
  
## Examples  
 Poniższy kod sprawdza przykład, jeśli <xref:System.Net.HttpWebRequest> obiektu `req` zostało przekierowane do innej lokalizacji w celu spełnienia żądania i ustawia wartość `hasChanged` zmienną `true` Jeśli żądanie zostało przekierowane; w przeciwnym razie `hasChanged` ustawiono `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendChunked">
      <MemberSignature Language="C#" Value="public bool SendChunked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SendChunked" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SendChunked" />
      <MemberSignature Language="VB.NET" Value="Public Property SendChunked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SendChunked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SendChunked : bool with get, set" Usage="System.Net.HttpWebRequest.SendChunked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy wysyłać dane w segmentach z zasobem internetowym.</summary>
        <value>
          <see langword="true" /> Aby wysyłać dane do zasobu internetowego w segmentach; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Net.HttpWebRequest.SendChunked%2A> jest `true`, żądanie wysyła dane do zasobu internetowego w segmentach. Z zasobem internetowym musi obsługiwać odbieranie danych podzielonego.  
  
 Zmiana <xref:System.Net.HttpWebRequest.SendChunked%2A> właściwości po rozpoczęciu żądania przez wywołanie metody <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, lub <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metoda zgłasza wyjątek <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 Poniższy kod ustawia przykład <xref:System.Net.HttpWebRequest.SendChunked%2A> właściwość `true` tak, aby dane mogą być wysyłane w segmentach z zasobem internetowym.  
  
 [!code-cpp[HttpWebRequest_SendChunked#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CPP/httpwebrequest_sendchunked.cpp#2)]
 [!code-csharp[HttpWebRequest_SendChunked#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CS/httpwebrequest_sendchunked.cs#2)]
 [!code-vb[HttpWebRequest_SendChunked#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_SendChunked/VB/httpwebrequest_sendchunked.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żądania został uruchomiony, wywołując <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, lub <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> metody.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia funkcję wywołania zwrotnego na potrzeby weryfikacji certyfikatu serwera.</summary>
        <value>Funkcja wywołania zwrotnego na potrzeby weryfikacji certyfikatu serwera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość domyślna to, że ustawiono żadnej funkcji wywołania zwrotnego i <xref:System.Net.HttpWebRequest.ServerCertificateValidationCallback%2A> właściwość `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServicePoint">
      <MemberSignature Language="C#" Value="public System.Net.ServicePoint ServicePoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ServicePoint ServicePoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServicePoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServicePoint As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ServicePoint ^ ServicePoint { System::Net::ServicePoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServicePoint : System.Net.ServicePoint" Usage="System.Net.HttpWebRequest.ServicePoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera punkt usługi do użycia dla żądania.</summary>
        <value>A <see cref="T:System.Net.ServicePoint" /> reprezentujący połączenie sieciowe z zasobem internetowym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePoint.Address%2A?displayProperty=nameWithType> Właściwości może się różnić od <xref:System.Net.HttpWebRequest.Address%2A?displayProperty=nameWithType> Jeśli żądanie jest przekierowywane.  
  
   
  
## Examples  
 [!code-cpp[System.Net.ServicePoint#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#6)]
 [!code-csharp[System.Net.ServicePoint#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#6)]
 [!code-vb[System.Net.ServicePoint#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsCookieContainer">
      <MemberSignature Language="C#" Value="public virtual bool SupportsCookieContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsCookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsCookieContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsCookieContainer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsCookieContainer : bool" Usage="System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy żądanie zapewnia obsługę <see cref="T:System.Net.CookieContainer" />.</summary>
        <value>
          <see langword="true" /> Jeśli żądanie zapewnia obsługę <see cref="T:System.Net.CookieContainer" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> Do wypełniania danymi.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> Określa, że lokalizacja docelowa tej serializacji.</param>
        <summary>Wypełnia <see cref="T:System.Runtime.Serialization.SerializationInfo" /> z dane potrzebne do zserializowania obiektu docelowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie obiekty zawarte w <xref:System.Runtime.Serialization.SerializationInfo> są automatycznie śledzone i serializowany przez program formatujący.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public override int Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Timeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Timeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Timeout : int with get, set" Usage="System.Net.HttpWebRequest.Timeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość limitu czasu w milisekundach dla <see cref="M:System.Net.HttpWebRequest.GetResponse" /> i <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> metody.</summary>
        <value>Liczba milisekund oczekiwania przed limit czasu żądania. Wartość domyślna to 100 000 milisekund (100 sekund).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Timeout%2A> jest to liczba milisekund, jaką kolejnych żądań synchronicznych wykonanej przy użyciu <xref:System.Net.HttpWebRequest.GetResponse%2A> metoda czeka na odpowiedź i <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metoda czeka na strumień. <xref:System.Net.HttpWebRequest.Timeout%2A> Ma zastosowanie do całej żądań i odpowiedzi, nie indywidualnie do <xref:System.Net.HttpWebRequest.GetRequestStream%2A> i <xref:System.Net.HttpWebRequest.GetResponse%2A> wywołania metody. Jeśli zasób nie jest zwracana przed upływem limitu czasu, zgłasza żądanie <xref:System.Net.WebException> z <xref:System.Net.WebException.Status%2A> właściwością <xref:System.Net.WebExceptionStatus.Timeout?displayProperty=nameWithType>.  
  
 <xref:System.Net.HttpWebRequest.Timeout%2A> Musi być ustawiona właściwość przed <xref:System.Net.HttpWebRequest.GetRequestStream%2A> lub <xref:System.Net.HttpWebRequest.GetResponse%2A> metoda jest wywoływana. Zmiana <xref:System.Net.HttpWebRequest.Timeout%2A> właściwości po wywołaniu <xref:System.Net.HttpWebRequest.GetRequestStream%2A> lub <xref:System.Net.HttpWebRequest.GetResponse%2A> metoda nie ma wpływu  
  
 <xref:System.Net.HttpWebRequest.Timeout%2A> Właściwość nie ma wpływu na żądań asynchronicznych za pomocą <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> lub <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> metody.  
  
> [!CAUTION]
>  W przypadku żądań asynchronicznych aplikacja kliencka implementuje własny mechanizm limitu czasu. Zobacz przykład w <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metody.  
  
 Aby określić ilość czasu oczekiwania przed odczytu lub zapisu limit czasu operacji, użyj <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> właściwości.  
  
 Kwerendy systemu nazw domen (DNS) może potrwać do 15 sekund, aby zwrócić lub przekraczają limit czasu. Jeśli żądanie zawiera nazwę hosta, który wymaga rozpoznawania i ustawisz <xref:System.Net.FileWebRequest.Timeout%2A> do wartości mniejszej niż 15 sekund może potrwać 15 sekund lub tylko przed <xref:System.Net.WebException> jest generowany, aby wskazać, przekroczenie limitu czasu na żądanie.  
  
   
  
## Examples  
 Poniższy kod ustawia przykład <xref:System.Net.HttpWebRequest.Timeout%2A> właściwość <xref:System.Net.HttpWebRequest> obiektu.  
  
 [!code-cpp[HttpWebRequest_Timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CPP/httpwebrequest_timeout.cpp#1)]
 [!code-csharp[HttpWebRequest_Timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CS/httpwebrequest_timeout.cs#1)]
 [!code-vb[HttpWebRequest_Timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Timeout/VB/httpwebrequest_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Określona wartość jest mniejsza od zera i nie <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransferEncoding">
      <MemberSignature Language="C#" Value="public string TransferEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransferEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.TransferEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransferEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransferEncoding : string with get, set" Usage="System.Net.HttpWebRequest.TransferEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see langword="Transfer-encoding" /> nagłówka HTTP.</summary>
        <value>Wartość <see langword="Transfer-encoding" /> nagłówka HTTP. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zanim będzie można skonfigurować <xref:System.Net.HttpWebRequest.TransferEncoding%2A> właściwość, należy najpierw ustawić <xref:System.Net.HttpWebRequest.SendChunked%2A> właściwość `true`. Czyszczenie <xref:System.Net.HttpWebRequest.TransferEncoding%2A> , ustawiając go na `null` nie ma wpływu na wartość <xref:System.Net.HttpWebRequest.SendChunked%2A>.  
  
 Wartości przypisane do <xref:System.Net.HttpWebRequest.TransferEncoding%2A> właściwość zastąpienie istniejącej zawartości.  
  
> [!NOTE]
>  Wartość tej właściwości jest przechowywana w <xref:System.Net.WebHeaderCollection>. Jeśli ustawiono WebHeaderCollection, wartość właściwości zostaną utracone.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> jest ustawiona, gdy <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> ma ustawioną wartość "Fragmentaryczne".</exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeAuthenticatedConnectionSharing : bool with get, set" Usage="System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy zezwolić na udostępnianie szybkiego połączenia z uwierzytelnianiem NTLM.</summary>
        <value>
          <see langword="true" /> Aby nie zamykaj uwierzytelnionego połączenia; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość domyślna tej właściwości to `false`, co powoduje, że bieżące połączenie zostanie zamknięty, po zakończeniu żądania. Aplikacja musi przejść przez sekwencję uwierzytelniania, za każdym razem, gdy wystawia nowe żądanie.  
  
 Jeśli ta właściwość jest ustawiona `true`, połączenia służy do pobierania odpowiedzi pozostaje otwarty, po przeprowadzeniu uwierzytelnienia. W tym przypadku żądań innych, które mają tę właściwość ustawioną na `true` mogą korzystać z połączenia bez ponownego uwierzytelniania. Innymi słowy, jeśli połączenie uwierzytelnieniu użytkownika, A użytkownik B może ponownie użyć A połączenia; żądanie przez użytkownika B jest spełniony, na podstawie poświadczeń użytkownika A.  
  
> [!CAUTION]
>  Ponieważ jest możliwe dla aplikacji, aby korzystać z połączenia bez uwierzytelniane, musisz mieć pewność, że nie administracyjne luk w zabezpieczeniach w systemie podczas ustawiania tej właściwości na `true`. Jeśli Twoja aplikacja przesyła żądania dla wielu użytkowników (personifikuje wiele kont użytkowników) i opiera się na uwierzytelnianie, aby chronić zasoby, nie należy ustawiać tę właściwość na `true` chyba że używasz grup połączeń, zgodnie z poniższym opisem.  
  
 Warto rozważyć włączenie tego mechanizmu, jeśli Twoja występują problemy z wydajnością i aplikacja jest uruchomiona na serwerze sieci Web przy użyciu zintegrowanego uwierzytelniania Windows.  
  
 Włączenie tego ustawienia spowoduje otwarcie system na zagrożenia bezpieczeństwa. Jeśli ustawisz <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> właściwość `true` należy wykonać następujące środki ostrożności:  
  
-   Użyj <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> właściwości, aby zarządzać połączeniami dla różnych użytkowników. Umożliwia to uniknięcie potencjalnych użycie połączenia przez aplikacje bez uwierzytelnienia. Na przykład użytkownik A powinny mieć nazwy grupy połączeń, która różni się od użytkownika B. Zapewnia warstwę izolacji dla każdego konta użytkownika.  
  
-   Uruchom aplikację w środowisku chronionego, aby zapobiec powstawaniu połączenia możliwe luki w zabezpieczeniach.  
  
 Jeśli dany serwer zaplecza jako alternatywę można rozważyć wyłączenie trwałości uwierzytelniania. Powoduje to zwiększenie wydajności w mniejszym stopniu, ale jest bezpieczniejsze. Aby uzyskać więcej informacji, wyszukaj AuthPersistence w bibliotece MSDN pod [ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library).  
  
> [!NOTE]
>  Jeśli oba <xref:System.Net.WebRequest.PreAuthenticate%2A> i <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> są ustawione na `true`, jest wysyłane każde żądanie przy użyciu połączenia z puli niebezpieczne, ale z nagłówka autoryzacji.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Nieograniczone uprawnienia sieci Web jest wymagany, aby ustawić tę właściwość.</permission>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public override bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDefaultCredentials : bool with get, set" Usage="System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość kontrolować, czy z żądaniami są wysyłane domyślne poświadczenia.</summary>
        <value>
          <see langword="true" /> Jeśli używane są domyślne poświadczenia; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw tę właściwość na `true` nawiązaniem żądań to <xref:System.Net.HttpWebRequest> obiektu Jeśli jest to wymagane przez serwer uwierzytelniania przy użyciu poświadczeń aktualnie zalogowanego użytkownika. Aplikacje klienckie to żądane zachowanie w większości scenariuszy. W przypadku aplikacji warstwy środkowej, takie jak aplikacje programu ASP.NET, zamiast tej właściwości należy zwykle ustawić <xref:System.Net.HttpWebRequest.Credentials%2A> właściwości poświadczeń klienta w imieniu którego zostanie wysłane żądanie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Próbowano ustawić tę właściwość, po żądanie zostało wysłane.</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string with get, set" Usage="System.Net.HttpWebRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see langword="User-agent" /> nagłówka HTTP.</summary>
        <value>Wartość <see langword="User-agent" /> nagłówka HTTP. Wartość domyślna to <see langword="null" />.  
  
 <block subset="none" type="note"><para> Wartość tej właściwości jest przechowywana w <see cref="T:System.Net.WebHeaderCollection" />. Jeśli ustawiono WebHeaderCollection, wartość właściwości zostaną utracone.  </para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod ustawia przykład <xref:System.Net.HttpWebRequest.UserAgent%2A> właściwości.  
  
 [!code-cpp[HttpWebRequest_UserAgent#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CPP/httpwebrequest_useragent.cpp#1)]
 [!code-csharp[HttpWebRequest_UserAgent#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CS/httpwebrequest_useragent.cs#1)]
 [!code-vb[HttpWebRequest_UserAgent#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_UserAgent/VB/httpwebrequest_useragent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
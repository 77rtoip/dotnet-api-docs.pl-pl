<Type Name="HttpWebRequest" FullName="System.Net.HttpWebRequest">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="758c8926acd455a9a955170a29f8a407e6816dae" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36473007" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HttpWebRequest : System.Net.WebRequest, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable HttpWebRequest extends System.Net.WebRequest implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpWebRequest" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpWebRequest&#xA;Inherits WebRequest&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpWebRequest : System::Net::WebRequest, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type HttpWebRequest = class&#xA;    inherit WebRequest&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.WebRequest</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Udostępnia implementację specyficzne dla protokołu HTTP <see cref="T:System.Net.WebRequest" /> klasy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest> Klasy zapewnia obsługę właściwości i metody zdefiniowane w <xref:System.Net.WebRequest> oraz dodatkowe właściwości i metody, które umożliwiają użytkownikowi na bezpośrednią interakcję z serwerów przy użyciu protokołu HTTP.  
  
 Nie używaj <xref:System.Net.HttpWebRequest.%23ctor%2A> konstruktora. Użyj <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType> metodę, aby zainicjować nowe <xref:System.Net.HttpWebRequest> obiektów. Jeśli schemat dla jednolity identyfikator zasobów (URI) jest `http://` lub `https://`, <xref:System.Net.WebRequest.Create%2A> zwraca <xref:System.Net.HttpWebRequest> obiektu.  
  
 <xref:System.Net.HttpWebRequest.GetResponse%2A> Metoda zgłasza żądanie synchroniczne zasobu określonego w <xref:System.Net.HttpWebRequest.RequestUri%2A> właściwości i zwraca <xref:System.Net.HttpWebResponse> zawiera obiekt odpowiedzi. Dane odpowiedzi mogą być odbierane za pomocą Strumień zwrócony przez <xref:System.Net.HttpWebResponse.GetResponseStream%2A>. Jeśli w strumieniu odpowiedzi lub obiektu odpowiedzi są zamknięte, pozostałych danych zostanie utracona. Pozostałe dane zostaną opróżnione i gniazda będzie można użyć ponownie dla kolejnych żądań podczas zamykania obiektu odpowiedzi lub strumienia, jeśli mają następujące warunki: jest to żądanie keep-alive lub w trybie potokowym, niewielką ilość danych musi zostać odebrana, lub pozostałych danych zostało odebrane w przedziale czasu mały. Jeśli żaden z wymienionych warunków przechowywania lub przekroczenia czasu opróżniania, gniazda zostanie zamknięte. Keep-alive lub potokowej połączeń zaleca się czy aplikacji odczytuje strumienie do EOF. Dzięki temu, że gniazda będą ponownie używane dla kolejnych żądań, co zapewnia lepszą wydajność i mniej zasoby używane.  
  
 Jeśli chcesz wysyłać dane do zasobu, <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metoda zwraca <xref:System.IO.Stream> obiekt ma być używany do przesyłania danych. <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> i <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> metody udostępniają asynchronicznego dostępu do wysyłania strumienia danych.  
  
 Do uwierzytelnienia klienta <xref:System.Net.HttpWebRequest>, musi być zainstalowany certyfikat klienta w mojej magazynu certyfikatów bieżącego użytkownika.  
  
 <xref:System.Net.HttpWebRequest> Klasy zgłasza <xref:System.Net.WebException> gdy występują błędy podczas uzyskiwania dostępu do zasobu. <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> Zawiera właściwość <xref:System.Net.WebExceptionStatus> wartość, która wskazuje przyczynę błędu. Gdy <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> jest <xref:System.Net.WebExceptionStatus.ProtocolError?displayProperty=nameWithType>, <xref:System.Net.WebException.Response%2A> zawiera właściwość <xref:System.Net.HttpWebResponse> otrzymanych od zasobu.  
  
 <xref:System.Net.HttpWebRequest> udostępnia typowe wartości nagłówka HTTP wysyłane do zasobu internetowego jako właściwości, ustawić za pomocą metod lub ustawiony przez system; Poniższa tabela zawiera pełną listę. Można ustawić innych nagłówków w <xref:System.Net.HttpWebRequest.Headers%2A> właściwość jako pary nazwa/wartość. Należy pamiętać, że serwery i pamięci podręczne może zmienić lub dodać nagłówków podczas żądania.  
  
 W poniższej tabeli wymieniono nagłówków HTTP, które są ustawiane przez właściwości lub metody lub systemu.  
  
|nagłówek|Ustawione przez|  
|------------|------------|  
|Zaakceptuj|Ustawione przez <xref:System.Net.HttpWebRequest.Accept%2A> właściwości.|  
|Połączenia|Ustawione przez <xref:System.Net.HttpWebRequest.Connection%2A> właściwość <xref:System.Net.HttpWebRequest.KeepAlive%2A> właściwości.|  
|Długość zawartości|Ustawione przez <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości.|  
|Typ zawartości|Ustawione przez <xref:System.Net.HttpWebRequest.ContentType%2A> właściwości.|  
|Oczekiwane|Ustawione przez <xref:System.Net.HttpWebRequest.Expect%2A> właściwości.|  
|Data|Ustawiony przez system do bieżącej daty.|  
|Host|Ustawiony przez system do informacji o bieżącym hoście.|  
|If-Modified-Since|Ustawione przez <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> właściwości.|  
|Zakres|Ustawione przez <xref:System.Net.HttpWebRequest.AddRange%2A> metody.|  
|Odnośnik|Ustawione przez <xref:System.Net.HttpWebRequest.Referer%2A> właściwości.|  
|Transfer-Encoding|Ustawione przez <xref:System.Net.HttpWebRequest.TransferEncoding%2A> właściwości ( <xref:System.Net.HttpWebRequest.SendChunked%2A> właściwość musi być `true`).|  
|Agent użytkownika|Ustawione przez <xref:System.Net.HttpWebRequest.UserAgent%2A> właściwości.|  
  
> [!NOTE]
>  <xref:System.Net.HttpWebRequest> automatycznie jest zarejestrowany. Nie należy wywołać <xref:System.Net.WebRequest.RegisterPrefix%2A> metodę, aby zarejestrować <xref:System.Net.HttpWebRequest?displayProperty=nameWithType> przed użyciem identyfikatorów URI rozpoczynające się od `http://` lub `https://`.  
  
 Komputer lokalny lub pliku konfiguracji aplikacji może określić, że używane domyślny serwer proxy. Jeśli <xref:System.Net.HttpWebRequest.Proxy%2A> właściwość jest określona, następnie ustawienia serwera proxy z <xref:System.Net.HttpWebRequest.Proxy%2A> zastąpienie właściwości komputera lokalnego lub pliku konfiguracyjnym aplikacji i <xref:System.Net.HttpWebRequest> wystąpienia użyje określić ustawienia serwera proxy. Jeśli w pliku konfiguracji określono żadnego serwera proxy i <xref:System.Net.HttpWebRequest.Proxy%2A> właściwość nie jest określona, <xref:System.Net.HttpWebRequest> klasa korzysta z ustawień serwera proxy dziedziczone z programu Internet Explorer na komputerze lokalnym. Jeśli nie ma żadnych ustawień serwera proxy w programie Internet Explorer, żądanie jest wysyłane bezpośrednio do serwera.  
  
 <xref:System.Net.HttpWebRequest> Klasy analizuje Lista obejść serwerów proxy z symbolami wieloznacznymi dziedziczone z programu Internet Explorer inaczej niż lista obejść jest analizowana bezpośrednio przez Internet Explorer. Na przykład <xref:System.Net.HttpWebRequest> klasy będzie analizować obejścia listę "nt *" w programie Internet Explorer jako wyrażenie regularne "nt. $". To różni się od natywnego zachowania programu Internet Explorer. Dlatego adresu URL "`http://intxxxxx`" czy pominąć serwer proxy przy użyciu <xref:System.Net.HttpWebRequest> klasy, ale nie będzie pominąć serwer proxy programu Internet Explorer.  
  
> [!NOTE]
>  Platformę buforuje sesji SSL, tworzonych i podejmie próbę ponownego użycia pamięci podręcznej sesji dla nowego żądania, jeśli to możliwe. Podczas próby ponownego użycia sesji SSL, platformę używa pierwszego elementu obiektu <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (jeśli istnieje), lub spróbuje ponownie użyć sesji anonimowe, jeśli <xref:System.Net.HttpWebRequest.ClientCertificates%2A> jest pusta.  
  
> [!NOTE]
>  Ze względów bezpieczeństwa pliki cookie są domyślnie wyłączone. Jeśli chcesz używać plików cookie, użyj <xref:System.Net.HttpWebRequest.CookieContainer%2A> właściwość, aby włączyć obsługę plików cookie.  
  
 .NET Framework 4.6 obejmuje nowa funkcja zabezpieczeń, która blokuje niezabezpieczonych szyfrowania i tworzenia skrótów algorytmów dla połączenia. Aplikacji przy użyciu protokołu TLS/SSL za pośrednictwem interfejsów API, takich jak HttpClient, HttpWebRequest, FTPClient, SmtpClient, SslStream, itp. oraz przeznaczonych dla platformy .NET Framework 4.6 uzyskać bardziej bezpiecznych zachowanie domyślne.  
  
 Deweloperzy mogą chcesz zrezygnować z tego zachowania, aby zapewnić współdziałanie z ich istniejących SSL3 usług protokołu TLS lub z usługi szyfrowania RC4. [W tym artykule](https://support.microsoft.com/kb/3069494) wyjaśniono, jak zmodyfikować kod, tak aby nowe zachowanie jest wyłączona.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Net.HttpWebRequest> dla identyfikatora URI http://www.contoso.com/.  
  
 [!code-cpp[Classic HttpWebRequest Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.WebPermission">Aby uzyskać dostęp do żądanego identyfikatora URI lub dowolny identyfikator URI, który żądanie jest przekierowywane do. Wyliczenie skojarzone: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.HttpWebRequest" /> klasy. Konstruktory te są przestarzałe; Zobacz szczegółowe informacje można znaleźć w sekcji uwag.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Zarówno <xref:System.Net.HttpWebRequest> konstruktory są przestarzałe i nie powinna być używana. Wywołanie <xref:System.Net.WebRequest.CreateHttp%2A?displayProperty=nameWithType> metodę, aby zainicjować nowe <xref:System.Net.HttpWebRequest> obiektów.     
  
      ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.HttpWebRequest" /> klasy. Ten konstruktor jest przestarzały.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : Uri -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest uri" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HttpWebRequest (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HttpWebRequest(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type", false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> obiekt, który zawiera informacje wymagane do serializacji nowej <see cref="T:System.Net.HttpWebRequest" /> obiektu.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> obiekt, który zawiera źródłowego i docelowego serializowanym strumieniu skojarzone z nowym <see cref="T:System.Net.HttpWebRequest" /> obiektu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.HttpWebRequest" /> klasy z wystąpienia określonego <see cref="T:System.Runtime.Serialization.SerializationInfo" /> i <see cref="T:System.Runtime.Serialization.StreamingContext" /> klasy. Ten konstruktor jest przestarzały.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja musi działać w trybie pełnego zaufania, po użyciu serializacji.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Aby uzyskać nieograniczony dostęp do zasobów sieciowych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public override void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Abort();" />
      <MemberSignature Language="F#" Value="override this.Abort : unit -&gt; unit" Usage="httpWebRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anuluje żądanie do zasobu internetowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Abort%2A> Metody anuluje żądanie do zasobu. Po anulowaniu żądanie wywoływania <xref:System.Net.HttpWebRequest.GetResponse%2A>, <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.EndGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, lub <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> metody powoduje, że <xref:System.Net.WebException> z <xref:System.Net.WebException.Status%2A> ustawioną właściwość <xref:System.Net.WebExceptionStatus.RequestCanceled>.  
  
 <xref:System.Net.HttpWebRequest.Abort%2A> Metody synchronicznie wykona wywołanie zwrotne, aby określić <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> lub <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metody Jeśli <xref:System.Net.HttpWebRequest.Abort%2A> metoda jest wywoływana, gdy są jedną z tych operacji oczekujących. Może to prowadzić do potencjalnych problemów zakleszczenia.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci](http://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 W przypadku żądań asynchronicznych jest odpowiedzialny za aplikacji klienckiej, aby zaimplementować mechanizm limitu czasu. Poniższy przykład kodu pokazuje, jak to zrobić.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public string Accept { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Accept" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Property Accept As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Accept { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Accept : string with get, set" Usage="System.Net.HttpWebRequest.Accept" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see langword="Accept" /> nagłówka HTTP.</summary>
        <value>Wartość <see langword="Accept" /> nagłówka HTTP. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby wyczyścić `Accept` nagłówka HTTP, ustaw <xref:System.Net.HttpWebRequest.Accept%2A> właściwości `null`.  
  
> [!NOTE]
>  Wartość tej właściwości jest przechowywana w <xref:System.Net.WebHeaderCollection>. Jeśli ustawiono WebHeaderCollection, wartość właściwości jest utracone.  
  
   
  
## Examples  
 Poniższy kod przykładzie <xref:System.Net.HttpWebRequest.Accept%2A> właściwości.  
  
 [!code-cpp[HttpWebRequest_Accept#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Accept/CPP/httpwebrequest_accept.cpp#1)]
 [!code-csharp[HttpWebRequest_Accept#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Accept/CS/httpwebrequest_accept.cs#1)]
 [!code-vb[HttpWebRequest_Accept#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Accept/VB/httpwebrequest_accept.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRange">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje nagłówek zakresu na żądanie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ wszystkie jednostki HTTP są prezentowane w wiadomości HTTP w postaci sekwencji bajtów, pojęcie zakres bajtów ma znaczenie dla dowolnej jednostki HTTP. Jednak nie wszystkie klienci i serwery muszą obsługiwać operacje zakresu bajtów.  
  
 Nagłówek zakresu żądania umożliwia klientowi żądania, że tylko chce otrzymywać część określony zakres bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądań nagłówka zakresu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="range">Punktu początkowego i końcowego zakresu.</param>
        <summary>Dodaje nagłówek zakresu bajtów na żądanie dla określonego zakresu od początku lub końca żądanych danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Metody dodaje nagłówek zakresu bajtów na żądanie.  
  
 Jeśli `range` jest dodatnia, `range` parametr określa punkt początkowy zakresu. Serwer powinien rozpocząć wysyłanie danych z `range` parametr do końca danych w obiekcie HTTP.  
  
 Jeśli `range` jest ujemna, `range` parametr określa punkt końcowy zakresu. Serwer powinien rozpocząć wysyłanie danych od początku danych w obiekcie HTTP do `range` określono parametr.  
  
 Ponieważ wszystkie jednostki HTTP są prezentowane w wiadomości HTTP w postaci sekwencji bajtów, pojęcie zakres bajtów ma znaczenie dla dowolnej jednostki HTTP. Jednak nie wszystkie klienci i serwery muszą obsługiwać operacje zakresu bajtów.  
  
 Nagłówek zakresu żądania umożliwia klientowi żądania, że tylko chce otrzymywać część określony zakres bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądań nagłówka zakresu.  
  
 Przykład zakresu nagłówka w żądaniu protokołu HTTP, żądań wysyłania serwera pierwszych 100 bajtów (od początku do położenia bajtów 99) będą następujące:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Na przykład `range` parametr będzie-99.  
  
 Serwer HTTP wskazuje obsługę nagłówków zakresu o nagłówka Accept-zakresów. Przykład nagłówka Accept-zakresów z serwera, który obsługuje zakresów bajtów będzie w następujący sposób:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Jeśli nagłówka Accept-zakresów nie została odebrana w nagłówku odpowiedzi z serwera, serwer nie obsługuje nagłówków zakresu. Przykład nagłówka Accept-zakresów z serwera, który nie obsługuje zakresów, ale rozpoznaje nagłówka Accept-zakresy będzie w następujący sposób:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Podczas odbierania odpowiedzi z żądania zakresu, skojarzony z żądaniem całego tylko nagłówki HTTP są przeanalizowany i dostępne za pośrednictwem właściwości <xref:System.Net.HttpWebResponse> klasy. Nagłówki skojarzone z każdym zakresem są zwracane w odpowiedzi.  
  
   
  
## Examples  
 Poniższy przykładowy kod dodaje nagłówek zakresu na żądanie.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można dodać nagłówka zakresu.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="range">Punktu początkowego i końcowego zakresu.</param>
        <summary>Dodaje nagłówek zakresu bajtów na żądanie dla określonego zakresu od początku lub końca żądanych danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Metody dodaje nagłówek zakresu bajtów na żądanie.  
  
 Jeśli `range` jest dodatnia, `range` parametr określa punkt początkowy zakresu. Serwer powinien rozpocząć wysyłanie danych z `range` parametr do końca danych w obiekcie HTTP.  
  
 Jeśli `range` jest ujemna, `range` parametr określa punkt końcowy zakresu. Serwer powinien rozpocząć wysyłanie danych od początku danych w obiekcie HTTP do `range` określono parametr.  
  
 Ponieważ wszystkie jednostki HTTP są prezentowane w wiadomości HTTP w postaci sekwencji bajtów, pojęcie zakres bajtów ma znaczenie dla dowolnej jednostki HTTP. Jednak nie wszystkie klienci i serwery muszą obsługiwać operacje zakresu bajtów.  
  
 Nagłówek zakresu żądania umożliwia klientowi żądania, że tylko chce otrzymywać część określony zakres bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądań nagłówka zakresu.  
  
 Przykład zakresu nagłówka w żądaniu protokołu HTTP, żądań wysyłania serwera pierwszych 100 bajtów (od początku do położenia bajtów 99) będą następujące:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Na przykład `range` parametr będzie-99.  
  
 Serwer HTTP wskazuje obsługę nagłówków zakresu o nagłówka Accept-zakresów. Przykład nagłówka Accept-zakresów z serwera, który obsługuje zakresów bajtów będzie w następujący sposób:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Jeśli nagłówka Accept-zakresów nie została odebrana w nagłówku odpowiedzi z serwera, serwer nie obsługuje nagłówków zakresu. Przykład nagłówka Accept-zakresów z serwera, który nie obsługuje zakresów, ale rozpoznaje nagłówka Accept-zakresy będzie w następujący sposób:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Podczas odbierania odpowiedzi z żądania zakresu, skojarzony z żądaniem całego tylko nagłówki HTTP są przeanalizowany i dostępne za pośrednictwem właściwości <xref:System.Net.HttpWebResponse> klasy. Nagłówki skojarzone z każdym zakresem są zwracane w odpowiedzi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można dodać nagłówka zakresu.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int * int -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="from">Pozycja, od którego należy rozpocząć wysyłanie danych.</param>
        <param name="to">Pozycja, w którym należy zatrzymać wysyłanie danych.</param>
        <summary>Dodaje nagłówek zakresu bajtów na żądanie dla określonego zakresu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Metody dodaje nagłówek zakresu bajtów na żądanie.  
  
 Ponieważ wszystkie jednostki HTTP są prezentowane w wiadomości HTTP w postaci sekwencji bajtów, pojęcie zakres bajtów ma znaczenie dla dowolnej jednostki HTTP. Jednak nie wszystkie klienci i serwery muszą obsługiwać operacje zakresu bajtów.  
  
 Nagłówek zakresu żądania umożliwia klientowi żądania, że tylko chce otrzymywać część określony zakres bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądań nagłówka zakresu.  
  
 Przykładem zakresu nagłówka w żądaniu protokołu HTTP, która byłaby żądań pierwszych 100 bajtów może być następujące:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Na przykład `from` może zostać określony parametr jako 0 i `to` może zostać określony parametr jako 99. Specyfikator zakresu jest automatycznie ustawiana jako "b" przez tę metodę.  
  
 Serwer HTTP wskazuje obsługę nagłówków zakresu o nagłówka Accept-zakresów. Przykład nagłówka Accept-zakresów z serwera, który obsługuje zakresów bajtów będzie w następujący sposób:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Jeśli nagłówka Accept-zakresów nie została odebrana w nagłówku odpowiedzi z serwera, serwer nie obsługuje nagłówków zakresu. Przykład nagłówka Accept-zakresów z serwera, który nie obsługuje zakresów, ale rozpoznaje nagłówka Accept-zakresy będzie w następujący sposób:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Podczas odbierania odpowiedzi z żądania zakresu, skojarzony z żądaniem całego tylko nagłówki HTTP są przeanalizowany i dostępne za pośrednictwem właściwości <xref:System.Net.HttpWebResponse> klasy. Nagłówki skojarzone z każdym zakresem są zwracane w odpowiedzi.  
  
   
  
## Examples  
 Poniższy przykładowy kod dodaje nagłówek zakresu na żądanie.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> jest większa niż <paramref name="to" /> - lub - <paramref name="from" /> lub <paramref name="to" /> jest mniejszy niż 0.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można dodać nagłówka zakresu.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="from">Pozycja, od którego należy rozpocząć wysyłanie danych.</param>
        <param name="to">Pozycja, w którym należy zatrzymać wysyłanie danych.</param>
        <summary>Dodaje nagłówek zakresu bajtów na żądanie dla określonego zakresu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Metody dodaje nagłówek zakresu bajtów na żądanie.  
  
 Ponieważ wszystkie jednostki HTTP są prezentowane w wiadomości HTTP w postaci sekwencji bajtów, pojęcie zakres bajtów ma znaczenie dla dowolnej jednostki HTTP. Jednak nie wszystkie klienci i serwery muszą obsługiwać operacje zakresu bajtów.  
  
 Nagłówek zakresu żądania umożliwia klientowi żądania, że tylko chce otrzymywać część określony zakres bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądań nagłówka zakresu.  
  
 Przykładem zakresu nagłówka w żądaniu protokołu HTTP, która byłaby żądań pierwszych 100 bajtów może być następujące:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Na przykład `from` może zostać określony parametr jako 0 i `to` może zostać określony parametr jako 99. Specyfikator zakresu jest automatycznie ustawiana jako "b" przez tę metodę.  
  
 Serwer HTTP wskazuje obsługę nagłówków zakresu o nagłówka Accept-zakresów. Przykład nagłówka Accept-zakresów z serwera, który obsługuje zakresów bajtów będzie w następujący sposób:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Jeśli nagłówka Accept-zakresów nie została odebrana w nagłówku odpowiedzi z serwera, serwer nie obsługuje nagłówków zakresu. Przykład nagłówka Accept-zakresów z serwera, który nie obsługuje zakresów, ale rozpoznaje nagłówka Accept-zakresy będzie w następujący sposób:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Podczas odbierania odpowiedzi z żądania zakresu, skojarzony z żądaniem całego tylko nagłówki HTTP są przeanalizowany i dostępne za pośrednictwem właściwości <xref:System.Net.HttpWebResponse> klasy. Nagłówki skojarzone z każdym zakresem są zwracane w odpowiedzi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> jest większa niż <paramref name="to" /> - lub - <paramref name="from" /> lub <paramref name="to" /> jest mniejszy niż 0.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można dodać nagłówka zakresu.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Opis zakresu.</param>
        <param name="range">Punktu początkowego i końcowego zakresu.</param>
        <summary>Dodaje nagłówek zakresu na żądanie dla określonego zakresu od początku lub końca żądanych danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Metody dodaje nagłówek zakresu na żądanie.  
  
 Jeśli `range` jest dodatnia, `range` parametr określa punkt początkowy zakresu. Serwer powinien rozpocząć wysyłanie danych z `range` parametr do końca danych w obiekcie HTTP.  
  
 Jeśli `range` jest ujemna, `range` parametr określa punkt końcowy zakresu. Serwer powinien rozpocząć wysyłanie danych od początku danych w obiekcie HTTP do `range` określono parametr.  
  
 Ponieważ wszystkie jednostki HTTP są prezentowane w wiadomości HTTP w postaci sekwencji bajtów, pojęcie zakres bajtów ma znaczenie dla dowolnej jednostki HTTP. Jednak nie wszystkie klienci i serwery muszą obsługiwać operacje zakresu bajtów.  
  
 Nagłówek zakresu żądania umożliwia klientowi żądania, że tylko chce otrzymywać część określony zakres bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądań nagłówka zakresu.  
  
 `rangeSpecifier` Będzie zwykle można określić parametru "bajtów", ponieważ jest tylko specyfikator zakresu rozpoznany przez większość serwerów HTTP. Ustawienie `rangeSpecifier` parametr niektóre inne ciąg umożliwia obsługę dla niestandardowego zakresu specyfikatory inne niż bajty (zdefiniowany w dokumencie RFC 2616 przez grupę roboczą IETF specyfikator zakresu bajtów).  
  
 Przykładem zakresu nagłówka w żądaniu protokołu HTTP, która byłaby żądań pierwszych 100 bajtów może być następujące:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 Na przykład `rangeSpecifier` może zostać określony parametr jako "b" i `range` parametr będzie-99.  
  
 Serwer HTTP wskazuje obsługę nagłówków zakresu o nagłówka Accept-zakresów w odpowiedzi. Przykład nagłówka Accept-zakresów z serwera, który obsługuje zakresów bajtów będzie w następujący sposób:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Jeśli nagłówka Accept-zakresów nie została odebrana w nagłówku odpowiedzi z serwera, serwer nie obsługuje nagłówków zakresu. Przykład nagłówka Accept-zakresów z serwera, który nie obsługuje zakresów, ale rozpoznaje nagłówka Accept-zakresy będzie w następujący sposób:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Podczas odbierania odpowiedzi z żądania zakresu, skojarzony z żądaniem całego tylko nagłówki HTTP są przeanalizowany i dostępne za pośrednictwem właściwości <xref:System.Net.HttpWebResponse> klasy. Nagłówki skojarzone z każdym zakresem są zwracane w odpowiedzi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można dodać nagłówka zakresu.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Opis zakresu.</param>
        <param name="range">Punktu początkowego i końcowego zakresu.</param>
        <summary>Dodaje nagłówek zakresu na żądanie dla określonego zakresu od początku lub końca żądanych danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Metody dodaje nagłówek zakresu na żądanie.  
  
 Jeśli `range` jest dodatnia, `range` parametr określa punkt początkowy zakresu. Serwer powinien rozpocząć wysyłanie danych z `range` parametr do końca danych w obiekcie HTTP.  
  
 Jeśli `range` jest ujemna, `range` parametr określa punkt końcowy zakresu. Serwer powinien rozpocząć wysyłanie danych od początku danych w obiekcie HTTP do `range` określono parametr.  
  
 Ponieważ wszystkie jednostki HTTP są prezentowane w wiadomości HTTP w postaci sekwencji bajtów, pojęcie zakres bajtów ma znaczenie dla dowolnej jednostki HTTP. Jednak nie wszystkie klienci i serwery muszą obsługiwać operacje zakresu bajtów.  
  
 Nagłówek zakresu żądania umożliwia klientowi żądania, że tylko chce otrzymywać część określony zakres bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądań nagłówka zakresu.  
  
 `rangeSpecifier` Będzie zwykle można określić parametru "bajtów", ponieważ jest tylko specyfikator zakresu rozpoznany przez większość serwerów HTTP. Ustawienie `rangeSpecifier` parametr niektóre inne ciąg umożliwia obsługę dla niestandardowego zakresu specyfikatory inne niż bajty (zdefiniowany w dokumencie RFC 2616 przez grupę roboczą IETF specyfikator zakresu bajtów).  
  
 Przykładem zakresu nagłówka w żądaniu protokołu HTTP, która byłaby żądań pierwszych 100 bajtów może być następujące:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 Na przykład `rangeSpecifier` może zostać określony parametr jako "b" i `range` parametr będzie-99.  
  
 Serwer HTTP wskazuje obsługę nagłówków zakresu o nagłówka Accept-zakresów w odpowiedzi. Przykład nagłówka Accept-zakresów z serwera, który obsługuje zakresów bajtów będzie w następujący sposób:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Jeśli nagłówka Accept-zakresów nie została odebrana w nagłówku odpowiedzi z serwera, serwer nie obsługuje nagłówków zakresu. Przykład nagłówka Accept-zakresów z serwera, który nie obsługuje zakresów, ale rozpoznaje nagłówka Accept-zakresy będzie w następujący sposób:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Podczas odbierania odpowiedzi z żądania zakresu, skojarzony z żądaniem całego tylko nagłówki HTTP są przeanalizowany i dostępne za pośrednictwem właściwości <xref:System.Net.HttpWebResponse> klasy. Nagłówki skojarzone z każdym zakresem są zwracane w odpowiedzi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można dodać nagłówka zakresu.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Opis zakresu.</param>
        <param name="from">Pozycja, od którego należy rozpocząć wysyłanie danych.</param>
        <param name="to">Pozycja, w którym należy zatrzymać wysyłanie danych.</param>
        <summary>Dodaje nagłówek zakresu na żądanie dla określonego zakresu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Metody dodaje nagłówek zakresu na żądanie.  
  
 Ponieważ wszystkie jednostki HTTP są prezentowane w wiadomości HTTP w postaci sekwencji bajtów, pojęcie zakres bajtów ma znaczenie dla dowolnej jednostki HTTP. Jednak nie wszystkie klienci i serwery muszą obsługiwać operacje zakresu bajtów.  
  
 Nagłówek zakresu żądania umożliwia klientowi żądania, że tylko chce otrzymywać część określony zakres bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądań nagłówka zakresu.  
  
 `rangeSpecifier` Będzie zwykle można określić parametru "bajtów", ponieważ jest tylko specyfikator zakresu rozpoznany przez większość serwerów HTTP. Ustawienie `rangeSpecifier` parametr niektóre inne ciąg umożliwia obsługę dla niestandardowego zakresu specyfikatory inne niż bajty (zdefiniowany w dokumencie RFC 2616 przez grupę roboczą IETF specyfikator zakresu bajtów).  
  
 Przykładem zakresu nagłówka w żądaniu protokołu HTTP, która byłaby żądań pierwszych 100 bajtów może być następujące:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Na przykład `rangeSpecifier` jako "b", może zostać określony parametr `from` parametr będzie mieć wartość 0 i `to` parametr będzie 99.  
  
 Serwer HTTP wskazuje obsługę nagłówków zakresu o nagłówka Accept-zakresów w odpowiedzi. Przykład nagłówka Accept-zakresów z serwera, który obsługuje zakresów bajtów będzie w następujący sposób:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Ciąg określony w nagłówku Accept-zakresów jest określenie zakresu, który będzie można określić w `rangeSpecifier` parametr tej metody.  
  
 Jeśli nagłówka Accept-zakresów nie została odebrana w nagłówku odpowiedzi z serwera, serwer nie obsługuje nagłówków zakresu. Przykład nagłówka Accept-zakresów z serwera, który nie obsługuje zakresów, ale rozpoznaje nagłówka Accept-zakresy będzie w następujący sposób:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Podczas odbierania odpowiedzi z żądania zakresu, skojarzony z żądaniem całego tylko nagłówki HTTP są przeanalizowany i dostępne za pośrednictwem właściwości <xref:System.Net.HttpWebResponse> klasy. Nagłówki skojarzone z każdym zakresem są zwracane w odpowiedzi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> jest większa niż <paramref name="to" /> - lub - <paramref name="from" /> lub <paramref name="to" /> jest mniejszy niż 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można dodać nagłówka zakresu.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Opis zakresu.</param>
        <param name="from">Pozycja, od którego należy rozpocząć wysyłanie danych.</param>
        <param name="to">Pozycja, w którym należy zatrzymać wysyłanie danych.</param>
        <summary>Dodaje nagłówek zakresu na żądanie dla określonego zakresu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Metody dodaje nagłówek zakresu na żądanie.  
  
 Ponieważ wszystkie jednostki HTTP są prezentowane w wiadomości HTTP w postaci sekwencji bajtów, pojęcie zakres bajtów ma znaczenie dla dowolnej jednostki HTTP. Jednak nie wszystkie klienci i serwery muszą obsługiwać operacje zakresu bajtów.  
  
 Nagłówek zakresu żądania umożliwia klientowi żądania, że tylko chce otrzymywać część określony zakres bajtów w jednostce HTTP. Serwery nie są wymagane do obsługi żądań nagłówka zakresu.  
  
 `rangeSpecifier` Będzie zwykle można określić parametru "bajtów", ponieważ jest tylko specyfikator zakresu rozpoznany przez większość serwerów HTTP. Ustawienie `rangeSpecifier` parametr niektóre inne ciąg umożliwia obsługę dla niestandardowego zakresu specyfikatory inne niż bajty (zdefiniowany w dokumencie RFC 2616 przez grupę roboczą IETF specyfikator zakresu bajtów).  
  
 Przykładem zakresu nagłówka w żądaniu protokołu HTTP, która byłaby żądań pierwszych 100 bajtów może być następujące:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Na przykład `rangeSpecifier` jako "b", może zostać określony parametr `from` parametr będzie mieć wartość 0 i `to` parametr będzie 99.  
  
 Serwer HTTP wskazuje obsługę nagłówków zakresu o nagłówka Accept-zakresów w odpowiedzi. Przykład nagłówka Accept-zakresów z serwera, który obsługuje zakresów bajtów będzie w następujący sposób:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Ciąg określony w nagłówku Accept-zakresów jest określenie zakresu, który będzie można określić w `rangeSpecifier` parametr tej metody.  
  
 Jeśli nagłówka Accept-zakresów nie została odebrana w nagłówku odpowiedzi z serwera, serwer nie obsługuje nagłówków zakresu. Przykład nagłówka Accept-zakresów z serwera, który nie obsługuje zakresów, ale rozpoznaje nagłówka Accept-zakresy będzie w następujący sposób:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Podczas odbierania odpowiedzi z żądania zakresu, skojarzony z żądaniem całego tylko nagłówki HTTP są przeanalizowany i dostępne za pośrednictwem właściwości <xref:System.Net.HttpWebResponse> klasy. Nagłówki skojarzone z każdym zakresem są zwracane w odpowiedzi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> jest większa niż <paramref name="to" /> - lub - <paramref name="from" /> lub <paramref name="to" /> jest mniejszy niż 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można dodać nagłówka zakresu.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public Uri Address { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Address" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Address As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Address { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Address : Uri" Usage="System.Net.HttpWebRequest.Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera jednolity identyfikator zasobów (URI) zasobu internetowego, który faktycznie odpowiada na żądanie.</summary>
        <value>A <see cref="T:System.Uri" /> identyfikującym rozszerzenie zasobu internetowego, który faktycznie odpowiada na żądanie. Wartość domyślna to identyfikator URI używany przez <see cref="M:System.Net.WebRequest.Create(System.String)" /> metodę, aby zainicjować żądania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Address%2A> Właściwość jest ustawiona na identyfikator URI, po zakończeniu żadnych przekierowań, które mają miejsce podczas żądania.  
  
 Identyfikator URI oryginalne żądanie jest przechowywane w <xref:System.Net.HttpWebRequest.RequestUri%2A> właściwości.  
  
   
  
## Examples  
 Poniższy kod sprawdza przykład, jeśli <xref:System.Net.HttpWebRequest> obiektu `req` zostało przekierowane do innej lokalizacji do spełnienia żądania i ustawia wartość `hasChanged` zmienną `true` Jeśli żądanie zostało przekierowane; w przeciwnym razie `hasChanged`ma ustawioną wartość `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public virtual bool AllowAutoRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowAutoRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowAutoRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAutoRedirect : bool with get, set" Usage="System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy żądanie ma uwzględnić odpowiedzi przekierowania.</summary>
        <value>
          <see langword="true" /> Jeśli żądanie ma automatycznie uwzględnić odpowiedzi przekierowania z zasobem internetowym; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> do `true` Jeśli chcesz, aby żądanie automatycznie wykonaj nagłówki przekierowania HTTP do nowej lokalizacji zasobu. Maksymalną liczbę przekierowań, które należy wykonać, jest ustawiony przez <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> właściwości.  
  
 Jeśli <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> ma ustawioną wartość `false`, wszystkie odpowiedzi z kodem stanu HTTP od 300 do 399 jest zwracana do aplikacji.  
  
 Nagłówek uwierzytelnienia jest wyczyszczone na automatycznych przekierowań i <xref:System.Net.HttpWebRequest> automatycznie podejmie próbę ponownego uwierzytelnienia do lokalizacji przekierowywanej. W praktyce oznacza to, że aplikacji, nie można ustawić informacji uwierzytelniania niestandardowego w nagłówku autoryzacji można napotkać przekierowania. Zamiast tego aplikacja musi implementować i zarejestrować moduł uwierzytelniania niestandardowego. <xref:System.Net.AuthenticationManager?displayProperty=nameWithType> i powiązanymi klasami są używane do implementowania moduł uwierzytelniania niestandardowego. <xref:System.Net.AuthenticationManager.Register%2A?displayProperty=nameWithType> Metoda rejestruje moduł uwierzytelniania niestandardowego.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> właściwości, aby umożliwić żądania uwzględnić odpowiedzi przekierowania.  
  
 [!code-cpp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CPP/httpwebrequest_allowautoredirect.cpp#2)]
 [!code-csharp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CS/httpwebrequest_allowautoredirect.cs#2)]
 [!code-vb[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/VB/httpwebrequest_allowautoredirect.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowReadStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowReadStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowReadStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowReadStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowReadStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowReadStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy bufor odebranych z zasobem internetowym.</summary>
        <value>
          <see langword="true" /> Aby włączyć buforowanie danych otrzymywanych z zasobem internetowym; <see langword="false" /> Aby wyłączyć buforowanie. Wartość domyślna to <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowWriteStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowWriteStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowWriteStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowWriteStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowWriteStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowWriteStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy można buforować dane wysłane do zasobu internetowego.</summary>
        <value>
          <see langword="true" /> Aby włączyć buforowanie dane wysłane do zasobu internetowego; <see langword="false" /> Aby wyłączyć buforowanie. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> jest `true`, dane są buforowane w pamięci gotowego płatność w przypadku uwierzytelniania lub przekierowywanie żądań.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> właściwość, aby wyłączyć buforowanie danych.  
  
 [!code-cpp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CPP/httpwebrequest_allowwritestreambuffering.cpp#1)]
 [!code-csharp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CS/httpwebrequest_allowwritestreambuffering.cs#1)]
 [!code-vb[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/VB/httpwebrequest_allowwritestreambuffering.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ustawienie <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> do <see langword="true" /> może spowodować problemy z wydajnością podczas przekazywania dużych zestawów danych, ponieważ bufor danych można używać wszystkich dostępnej pamięci.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDecompression">
      <MemberSignature Language="C#" Value="public System.Net.DecompressionMethods AutomaticDecompression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.DecompressionMethods AutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticDecompression As DecompressionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::DecompressionMethods AutomaticDecompression { System::Net::DecompressionMethods get(); void set(System::Net::DecompressionMethods value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticDecompression : System.Net.DecompressionMethods with get, set" Usage="System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.DecompressionMethods</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ dekompresji, który jest używany.</summary>
        <value>A <see cref="T:System.Net.DecompressionMethods" /> obiekt, który wskazuje typ dekompresji, który jest używany.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący stan obiektu nie zezwala na tę właściwość należy ustawić wartość.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRequestStream">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetRequestStream(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetRequestStream (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetRequestStream(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetRequestStream : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetRequestStream (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegowanie.</param>
        <param name="state">Obiekt stanu dla tego żądania.</param>
        <summary>Rozpoczyna żądanie asynchroniczne dla <see cref="T:System.IO.Stream" /> obiekt ma być używany do zapisywania danych.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się żądania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> Metoda uruchamia asynchroniczne żądanie dla strumienia używane do wysyłania danych <xref:System.Net.HttpWebRequest>. Metody asynchroniczne wywołanie zwrotne używa <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> metodę, aby zwrócić strumień, do rzeczywistych.  
  
 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> Metoda wymaga kilka zadań synchroniczne Instalatora, aby zakończyć (rozpoznawanie nazw DNS, wykrywanie serwera proxy i połączenia gniazda TCP, na przykład), zanim ta metoda staje się asynchronicznego. W związku z tym ta nigdy nie należy wywoływać metody w wątku interfejsu użytkownika ponieważ go może zająć wiele czasu (do kilku minut w zależności od ustawienia sieciowe) do ukończenia zadania początkowej konfiguracji synchroniczne przed wyjątek dla zostanie zgłoszony błąd lub Metoda zakończy się pomyślnie.  
  
 Aby dowiedzieć się więcej na temat puli wątków, zobacz [puli wątków zarządzanych](~/docs/standard/threading/the-managed-thread-pool.md).  
  
> [!NOTE]
>  Aplikacji nie można mieszać synchroniczne i asynchroniczne metody dla określonego żądania. Jeśli należy wywołać <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> metody, należy użyć <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metoda pobierania odpowiedzi.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> metody asynchronicznej żądania dla wystąpienia strumienia.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> Właściwość jest GET lub HEAD.  - lub - <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> jest <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> jest <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> wynosi -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" />, i <see cref="P:System.Net.HttpWebRequest.Method" /> jest POST i PUT.</exception>
        <exception cref="T:System.InvalidOperationException">Strumień jest używany przez poprzednie wywołanie <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> - lub - <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> ma ustawioną wartość i <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" />.  - lub - puli wątków nie kończy się wątków.</exception>
        <exception cref="T:System.NotSupportedException">Pamięci podręcznej żądania modułu sprawdzania poprawności wskazane, że odpowiedzi dla tego żądania mogą być przekazywane z pamięci podręcznej; jednak żądań zapisu danych nie może używać pamięci podręcznej. Ten wyjątek może wystąpić, jeśli używane jest niepoprawnie zaimplementowany sprawdzania poprawności niestandardowe pamięci podręcznej.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> wcześniej została wywołana.</exception>
        <exception cref="T:System.ObjectDisposedException">W aplikacji .NET Compact Framework strumienia o zerowej długości zawartości żądania nie został uzyskany i zamknięty poprawnie. Aby uzyskać więcej informacji o zerowej długości zawartości żądania obsługi, zobacz [sieci programowania .NET Compact Framework] (https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetResponse">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetResponse(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetResponse (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetResponse(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetResponse : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetResponse (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegowanie</param>
        <param name="state">Obiekt stanu dla tego żądania.</param>
        <summary>Rozpoczyna się asynchroniczne żądanie do zasobu internetowego.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się żądania asynchronicznego na odpowiedź.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> Metoda uruchamia żądania asynchronicznego na odpowiedź z zasobem internetowym. Metody asynchroniczne wywołanie zwrotne używa <xref:System.Net.HttpWebRequest.EndGetResponse%2A> metody do zwrócenia rzeczywistego <xref:System.Net.WebResponse>.  
  
 A <xref:System.Net.ProtocolViolationException> jest zgłaszany w kilku przypadkach, gdy wartość właściwości na <xref:System.Net.HttpWebRequest> klasy są w konflikcie. Ten wyjątek występuje, gdy aplikacja ustawia <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości i <xref:System.Net.HttpWebRequest.SendChunked%2A> właściwości `true`, a następnie wysyła żądanie HTTP GET. Ten wyjątek występuje, gdy aplikacja próbuje wysłać podzielony na serwerze obsługującym tylko protokół HTTP 1.0, gdzie jest to nieobsługiwane. Ten wyjątek występuje, gdy aplikacja próbuje wysłać dane bez ustawienia <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości lub <xref:System.Net.HttpWebRequest.SendChunked%2A> jest `false` gdy buforowanie jest wyłączone i połączenia keepalive ( <xref:System.Net.HttpWebRequest.KeepAlive%2A> właściwość jest `true`)`.`  
  
 Jeśli <xref:System.Net.WebException> jest zgłoszone, użyj <xref:System.Net.WebException.Response%2A> i <xref:System.Net.WebException.Status%2A> właściwości wyjątku, aby określić odpowiedzi z serwera.  
  
 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> Metoda wymaga kilka zadań synchroniczne Instalatora, aby zakończyć (rozpoznawanie nazw DNS, wykrywanie serwera proxy i połączenia gniazda TCP, na przykład), zanim ta metoda staje się asynchronicznego. W związku z tym ta nigdy nie należy wywoływać metody w wątku interfejsu użytkownika ponieważ go może zająć wiele czasu (do kilku minut w zależności od ustawienia sieciowe) do ukończenia zadania początkowej konfiguracji synchroniczne przed wyjątek dla zostanie zgłoszony błąd lub Metoda zakończy się pomyślnie.  
  
 Aby dowiedzieć się więcej na temat puli wątków, zobacz [ &#91; \<topic://cpconthreadpooling >&#93;](http://msdn.microsoft.com/library/2be05b06-a42e-4c9d-a739-96c21d673927).  
  
> [!NOTE]
>  Aplikacji nie można mieszać synchroniczne i asynchroniczne metody dla określonego żądania. Jeśli należy wywołać <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> metody, należy użyć <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metoda pobierania odpowiedzi.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [ &#91; \<topic://conUsingNetworkTracing >&#93;](http://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metody asynchronicznej żądania dla zasobu internetowego.  
  
> [!NOTE]
>  W przypadku żądań asynchronicznych jest odpowiedzialny za aplikacji klienckiej, aby zaimplementować mechanizm limitu czasu. Poniższy przykład kodu pokazuje, jak to zrobić.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Strumień jest już używany przez poprzednie wywołanie <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> - lub - <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> ma ustawioną wartość i <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" />.  - lub - puli wątków nie kończy się wątków.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> jest GET lub HEAD, a następnie <see cref="P:System.Net.HttpWebRequest.ContentLength" /> jest większa od zera lub <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="true" />.  - lub - <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> jest <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> jest <see langword="false" />oraz <see cref="P:System.Net.HttpWebRequest.ContentLength" /> wynosi -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" /> i <see cref="P:System.Net.HttpWebRequest.Method" /> jest POST i PUT.  - lub - <see cref="T:System.Net.HttpWebRequest" /> zawiera treść jednostki, ale <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> metoda jest wywoływana bez wywoływania elementu <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> metody.  - lub - <see cref="P:System.Net.HttpWebRequest.ContentLength" /> jest większa od zera, ale aplikacja nie zapisuje wszystkie dane uzgodnionej.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> wcześniej została wywołana.</exception>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); void set(System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection with get, set" Usage="System.Net.HttpWebRequest.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolekcję certyfikatów zabezpieczeń, które są skojarzone z tym żądaniem.</summary>
        <value>
          <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> Zawiera certyfikaty zabezpieczeń skojarzony z tym żądaniem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikację można dodać certyfikatu do kolekcji, ale może nie mieć praw dostępu do niego. Aby użyć certyfikatu zawartych w kolekcji, aplikacja musi mieć te same prawa dostępu jako jednostki, który wystawił certyfikat.  
  
> [!NOTE]
>  Platformę buforuje sesji SSL, tworzonych i podejmie próbę ponownego użycia pamięci podręcznej sesji dla nowego żądania, jeśli to możliwe. Podczas próby ponownego użycia sesji SSL, platformę używa pierwszego elementu obiektu <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (jeśli istnieje), lub spróbuje ponownie użyć sesji anonimowe, jeśli <xref:System.Net.HttpWebRequest.ClientCertificates%2A> jest pusta.  
  
> [!NOTE]
>  Ze względu na wydajność, nie należy dodawać certyfikatu klienta w celu <xref:System.Net.HttpWebRequest> Jeśli nie wiadomo, że serwer będzie żądać go.  
>   
>  Na przykład kodu, pokazujący sposób wyliczania certyfikaty w magazynie certyfikatów klienta, zobacz <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość określona dla operacji set jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public string Connection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Connection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Connection" />
      <MemberSignature Language="VB.NET" Value="Public Property Connection As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Connection { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Connection : string with get, set" Usage="System.Net.HttpWebRequest.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see langword="Connection" /> nagłówka HTTP.</summary>
        <value>Wartość <see langword="Connection" /> nagłówka HTTP. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wysyła żądanie <xref:System.Net.HttpWebRequest.Connection%2A> właściwości z zasobem internetowym jako `Connection` nagłówka HTTP. Jeśli wartość <xref:System.Net.HttpWebRequest.KeepAlive%2A> właściwość jest `true`, wartość "Keep-alive" jest dołączany na końcu `Connection` nagłówka.  
  
 Aby wyczyścić `Connection` nagłówka HTTP, ustaw <xref:System.Net.HttpWebRequest.Connection%2A> właściwości `null`.  
  
 Zmiana <xref:System.Net.HttpWebRequest.Connection%2A> właściwości po rozpoczęciu żądania przez wywołanie metody <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, lub <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metoda zgłasza <xref:System.InvalidOperationException>.  
  
> [!NOTE]
>  Wartość tej właściwości jest przechowywana w <xref:System.Net.WebHeaderCollection>. Jeśli ustawiono WebHeaderCollection, wartość właściwości jest utracone.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.HttpWebRequest.Connection%2A> właściwości można ustawić wartości nagłówka HTTP połączenia.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość <see cref="P:System.Net.HttpWebRequest.Connection" /> ustawiono Keep-alive ani Close.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionGroupName">
      <MemberSignature Language="C#" Value="public override string ConnectionGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionGroupName : string with get, set" Usage="System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę grupy połączenia dla żądania.</summary>
        <value>Nazwa grupy połączenia dla tego żądania. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> Właściwości umożliwia kojarzenie żądanie z grupą połączenia. Jest to przydatne, gdy aplikacja zgłasza żądania na jednym serwerze dla różnych użytkowników, takich jak witryny sieci Web, która pobiera informacje o kliencie z serwera bazy danych.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak użytkownika informacje służą do utworzenia grupy połączeń, przy założeniu, że zmienne `username`, `password`, i `domain` są ustawiane przez aplikację przed wywołaniem tego kodu.  
  
 [!code-cpp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Każda grupa połączenia tworzy dodatkowe połączenia dla serwera. Może to spowodować przekroczenie liczby połączeń ustawione przez <see cref="P:System.Net.ServicePoint.ConnectionLimit" /> właściwości dla tego serwera.</para>
        </block>
        <altmember cref="P:System.Net.Configuration.ConnectionManagementElement.MaxConnection" />
        <altmember cref="P:System.Net.WebRequest.ConnectionGroupName" />
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public override long ContentLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long ContentLength { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int64 with get, set" Usage="System.Net.HttpWebRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see langword="Content-length" /> nagłówka HTTP.</summary>
        <value>Liczba bajtów do wysłania dane do zasobu internetowego. Wartość domyślna to -1, która wskazuje, że właściwość nie została ustawiona i że nie ma żadnych danych żądania do wysłania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContentLength%2A> Właściwość zawiera wartość do wysłania jako `Content-length` z żądaniem nagłówek HTTP.  
  
 Wartości innej niż -1 w <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwość wskazuje, że żądanie operacji przekazywania danych i czy tylko metody, które przekazywanie danych są niedozwolone w <xref:System.Net.HttpWebRequest.Method%2A> właściwości.  
  
 Po <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwość jest ustawiona na wartość, podanej liczby bajtów musi być przystosowana do strumienia żądania zwróconą przez wywołanie metody <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metody lub obu tych <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> i <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> metody.  
  
> [!NOTE]
>  Wartość tej właściwości jest przechowywana w <xref:System.Net.WebHeaderCollection>. Jeśli ustawiono WebHeaderCollection, wartość właściwości jest utracone.  
  
   
  
## Examples  
 Poniższy kod przykładzie <xref:System.Net.HttpWebRequest.ContentLength%2A> długość ciągu ogłaszany dla właściwości.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żądanie został uruchomiony przez wywołanie metody <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, lub <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nowe <see cref="P:System.Net.HttpWebRequest.ContentLength" /> wartość jest mniejsza niż 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public override string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Net.HttpWebRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see langword="Content-type" /> nagłówka HTTP.</summary>
        <value>Wartość <see langword="Content-type" /> nagłówka HTTP. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContentType%2A> Właściwość zawiera typ nośnika żądania. Wartości przypisane do <xref:System.Net.HttpWebRequest.ContentType%2A> właściwości zastąpienie istniejącej zawartości, gdy wysyła żądanie `Content-type` nagłówka HTTP.  
  
 Aby wyczyścić `Content-type` nagłówka HTTP, ustaw <xref:System.Net.HttpWebRequest.ContentType%2A> właściwości `null`.  
  
> [!NOTE]
>  Wartość tej właściwości jest przechowywana w <xref:System.Net.WebHeaderCollection> . Jeśli <xref:System.Net.WebHeaderCollection> jest ustawiona wartość właściwości zostaną utracone.  
  
   
  
## Examples  
 Poniższy kod przykładzie <xref:System.Net.HttpWebRequest.ContentType%2A> właściwości.  
  
 [!code-cpp[HttpWebRequest_ContentLength#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#1)]
 [!code-csharp[HttpWebRequest_ContentLength#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#1)]
 [!code-vb[HttpWebRequest_ContentLength#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpContinueDelegate ContinueDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpContinueDelegate ContinueDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueDelegate As HttpContinueDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpContinueDelegate ^ ContinueDelegate { System::Net::HttpContinueDelegate ^ get(); void set(System::Net::HttpContinueDelegate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueDelegate : System.Net.HttpContinueDelegate with get, set" Usage="System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpContinueDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia metodę delegata wywoływane, gdy HTTP 100-kontynuować Odebrano odpowiedź z zasobem internetowym.</summary>
        <value>Delegat, który implementuje metodę wywołania zwrotnego, która wykonuje zwracanie odpowiedzi HTTP kontynuować z zasobem internetowym. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> Właściwość określa metodę wywołania zwrotnego wywoływana, gdy klient odbierze 100-kontynuować odpowiedzi.  
  
 Gdy <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> właściwość jest ustawiona, gdy klient wywołuje delegata po każdej zmianie protokołu odpowiedzi typu <xref:System.Net.HttpStatusCode.Continue?displayProperty=nameWithType> (100) są odbierane. Jest to przydatne, jeśli klient, aby wyświetlić stan danych z nich odbierane z zasobem internetowym.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public int ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContinueTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia limit czasu, w milisekundach, po upływie 100-nadal jest otrzymany z serwera.</summary>
        <value>Limit czasu w milisekundach, po upływie 100-kontynuować odebrania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli 100-kontynuować odpowiedzi przed upłynięciem limitu czasu, można wysłać treści jednostki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieContainer">
      <MemberSignature Language="C#" Value="public virtual System.Net.CookieContainer CookieContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer CookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.CookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CookieContainer As CookieContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CookieContainer : System.Net.CookieContainer with get, set" Usage="System.Net.HttpWebRequest.CookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia pliki cookie skojarzone z żądaniem.</summary>
        <value>A <see cref="T:System.Net.CookieContainer" /> zawierający pliki cookie skojarzone z tym żądaniem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A> Wystąpienie zawiera właściwość <xref:System.Net.CookieContainer> klasy, który zawiera pliki cookie skojarzone z tym żądaniem.  
  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A> jest `null` domyślnie. Należy przypisać <xref:System.Net.CookieContainer> obiektu do właściwości, aby pliki cookie zwrócony w <xref:System.Net.HttpWebResponse.Cookies%2A> właściwość <xref:System.Net.HttpWebResponse> zwrócony przez <xref:System.Net.HttpWebRequest.GetResponse%2A> metody.  
  
> [!NOTE]
>  Ze względów bezpieczeństwa pliki cookie są domyślnie wyłączone. Jeśli chcesz używać plików cookie, użyj <xref:System.Net.HttpWebRequest.CookieContainer%2A> właściwość, aby włączyć obsługę plików cookie.  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła żądanie do adresu URL i wyświetla zwrócił w odpowiedzi plików cookie.  
  
 [!code-cpp[NCLCookies#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLCookies/CPP/cookiessnippets.cpp#1)]
 [!code-csharp[NCLCookies#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLCookies/CS/cookiessnippets.cs#1)]
 [!code-vb[NCLCookies#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLCookies/VB/cookiessnippets.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.CookieContainer" />
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials with get, set" Usage="System.Net.HttpWebRequest.Credentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje dotyczące uwierzytelniania dla żądania.</summary>
        <value>
          <see cref="T:System.Net.ICredentials" /> Zawierający poświadczenia uwierzytelnienia skojarzone z żądaniem. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Credentials%2A> Właściwość zawiera informacje dotyczące uwierzytelniania, aby zidentyfikować maker żądania. <xref:System.Net.HttpWebRequest.Credentials%2A> Właściwości mogą być <xref:System.Net.NetworkCredential>, w których przypadku użytkownika, hasło i domeny informacje zawarte w <xref:System.Net.NetworkCredential> obiekt jest używany do uwierzytelniania żądania lub może być <xref:System.Net.CredentialCache>, w którym to przypadku Uniform Resource Identyfikator URI żądania jest używana do określenia użytkownika, hasło i informacje o domenie, na potrzeby uwierzytelniania żądania.  
  
 W większości przypadków klienta, należy użyć <xref:System.Net.CredentialCache.DefaultCredentials%2A> właściwości, która zawiera poświadczeń aktualnie zalogowanego użytkownika. Aby to zrobić, ustaw <xref:System.Net.WebClient.UseDefaultCredentials%2A> właściwości `true` zamiast ustawienie dla tej właściwości.  
  
 Jeśli <xref:System.Net.HttpWebRequest> klasy jest używany w aplikacji warstwy środkowej, takie jak aplikacja ASP.NET, poświadczenia w <xref:System.Net.CredentialCache.DefaultCredentials%2A> właściwość należy do konta, na którym działa strony ASP (poświadczeń po stronie serwera). Zazwyczaj ustawi tę właściwość do poświadczeń klienta w imieniu którego żądań.  
  
> [!NOTE]
>  Schemat uwierzytelniania NTLM nie można personifikować innego użytkownika. Kerberos musi być specjalnie skonfigurowany do obsługi personifikacji.  
  
 Aby ograniczyć HttpWebRequest do co najmniej jedną metodę uwierzytelniania, należy użyć <xref:System.Net.CredentialCache> klasy i ich powiązania poświadczeń do co najmniej jeden schemat uwierzytelniania  
  
 Schematy uwierzytelniania obsługiwanych obejmują Digest, Negotiate, protokołu Kerberos, NTLM i Basic.  
  
 Ze względów bezpieczeństwa po automatycznie przekierowania, przechowywane poświadczenia, które mają zostać uwzględnione w przekierowania w <xref:System.Net.CredentialCache> i przypisz je do tej właściwości. Ta właściwość zostanie automatycznie ustawiona do `null` na przekierowanie, jeśli zawiera więcej niż <xref:System.Net.CredentialCache>. Posiadające wartość tej właściwości jest automatycznie ustawiana `null` w tych warunkach uniemożliwia poświadczenia są wysyłane do dowolnego niezamierzone miejsca docelowego.
  
## Examples  
 Poniższy przykład kodu Ustawia poświadczenia dla żądania.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Date" />
      <MemberSignature Language="VB.NET" Value="Public Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.Date : DateTime with get, set" Usage="System.Net.HttpWebRequest.Date" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>GET lub set <see langword="Date" /> wartość nagłówka HTTP do użycia w żądaniu HTTP.</summary>
        <value>Wartość nagłówka Data w żądaniu HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku nagłówka Data `null`, a następnie zostanie ustawiona wartość zwracana do <xref:System.DateTime.MinValue?displayProperty=nameWithType>.  
  
 <xref:System.Net.HttpWebRequest.Date%2A> Właściwości jest standardem <xref:System.DateTime?displayProperty=nameWithType> obiektu i może zawierać <xref:System.DateTimeKind?displayProperty=nameWithType> pole <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, lub <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Dowolny rodzaj czasu można ustawić przy użyciu <xref:System.Net.HttpWebRequest.Date%2A> właściwości. Jeśli <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> jest ustawiona lub pobrana, <xref:System.Net.HttpWebRequest.Date%2A> właściwości zakłada się, że <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (czas lokalny).  
  
 Klasy w <xref:System.Net> przestrzeni nazw zawsze zapisać go <xref:System.Net.HttpWebRequest.Date%2A> właściwości umieszczonego podczas przesyłania w formie standardowej formacie GMT (czas Utc).  
  
 Jeśli <xref:System.Net.HttpWebRequest.Date%2A> właściwość jest ustawiona na <xref:System.DateTime.MinValue?displayProperty=nameWithType>, a następnie `Date` nagłówka HTTP jest usuwany z <xref:System.Net.HttpWebRequest.Headers%2A> właściwości i <xref:System.Net.WebHeaderCollection>.  
  
 Jeśli <xref:System.Net.HttpWebRequest.Date%2A> właściwość jest <xref:System.DateTime.MinValue?displayProperty=nameWithType>, oznacza to, że `Date` nagłówka HTTP nie jest uwzględniony w <xref:System.Net.HttpWebRequest.Headers%2A> właściwości i <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  Wartość tej właściwości jest przechowywana w <xref:System.Net.WebHeaderCollection>. Jeśli ustawiono WebHeaderCollection, wartość właściwości jest utracone.  
  
 Jeśli <xref:System.Net.HttpWebRequest.Date%2A> ustawiono i wysłać podejmowana jest próba <xref:System.Net.HttpWebRequest> nie jednostki, a następnie <xref:System.Net.ProtocolViolationException?displayProperty=nameWithType> zostanie zgłoszony przez <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, i <xref:System.Net.HttpWebRequest.EndGetResponse%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCachePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy DefaultCachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Cache.RequestCachePolicy DefaultCachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultCachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Cache::RequestCachePolicy ^ DefaultCachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCachePolicy : System.Net.Cache.RequestCachePolicy with get, set" Usage="System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia domyślne zasady pamięci podręcznej dla tego żądania.</summary>
        <value>A <see cref="T:System.Net.Cache.HttpRequestCachePolicy" /> określa zasady pamięci podręcznej dla tego żądania, gdy nie inne zasady są stosowane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie tej właściwości rejestruje określonych zasad dla schematy HTTP i HTTPS. Ta zasada jest używana dla tego żądania, jeśli:  
  
 Brak nie <xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType> właściwość określona dla tego żądania.  
  
 \- lub -  
  
 Konfiguracja komputera i aplikacji, plików nie określaj zasadę pamięci podręcznej, która ma zastosowanie do jednolity identyfikator zasobów (URI) używany do tworzenia tego żądania.  
  
 Zasady pamięci podręcznej określa, czy żądany zasób może zostać pobrany z pamięci podręcznej zamiast wysyłać żądania do zasobu hosta.  
  
 Kopię zasobu jest dodawane tylko do pamięci podręcznej, jeśli w strumieniu odpowiedzi dla zasobu jest pobierany i odczytu do końca strumienia. Aby inne żądanie dla tego samego zasobu można używać kopii w pamięci podręcznej, w zależności od poziomu zasad pamięci podręcznej dla tego żądania.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Aby uzyskać nieograniczony dostęp do zasobów sieciowych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.Cache.RequestCachePolicy" />
        <altmember cref="T:System.Net.Cache.HttpRequestCacheLevel" />
        <altmember cref="T:System.Net.Cache.RequestCacheLevel" />
        <altmember cref="P:System.Net.WebRequest.CachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumErrorResponseLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumErrorResponseLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumErrorResponseLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumErrorResponseLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumErrorResponseLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną dozwoloną długość odpowiedzi błędu HTTP.</summary>
        <value>Domyślna maksymalna długość odpowiedzi błędu HTTP.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość jest mniejsza niż 0 i nie jest równa -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość domyślna dla <see cref="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" /> właściwości.</summary>
        <value>Długość w kilobajtach (1024 bajty), Domyślna maksymalna odebrane nagłówki odpowiedzi. Domyślny plik konfiguracji ustawia tę wartość do 64 kilobajtów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Długość nagłówka odpowiedzi Odebrano wiersz stanu odpowiedzi oraz żadnych znaków kontrolnych dodatkowe, które są odbierane w ramach protokołu HTTP. Wartość-1 oznacza, że limit nie nakłada się na odebrane; nagłówki odpowiedzi wartość 0 oznacza, że wszystkie żądania zakończyć się niepowodzeniem.  
  
 Tę wartość można zmienić w taki sposób, w pliku konfiguracji. Wpływ ta właściwość może zostać zastąpione przez ustawienie <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> właściwość w wystąpieniu <xref:System.Net.HttpWebRequest> klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość nie jest równa -1 i mniejsza niż zero.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndGetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kończy żądanie asynchroniczne dla <see cref="T:System.IO.Stream" /> obiekt ma być używany do zapisywania danych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetRequestStream (asyncResult As IAsyncResult) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oczekujące żądania dla strumienia.</param>
        <summary>Kończy żądanie asynchroniczne dla <see cref="T:System.IO.Stream" /> obiekt ma być używany do zapisywania danych.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> na potrzeby zapisu danych żądania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> Ukończeniu metody asynchroniczne żądanie dla strumienia, które zostało uruchomione przez <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> metody. Po <xref:System.IO.Stream> został zwrócony obiekt, może wysyłać dane z <xref:System.Net.HttpWebRequest> przy użyciu <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> metody.  
  
> [!NOTE]
>  Należy ustawić wartość <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości przed zapisaniem danych w strumieniu.  
  
> [!CAUTION]
>  Należy wywołać <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> metody zamykać strumień i wersji połączenia do ponownego użycia. Nie można zamknąć strumienia powoduje, że aplikacja do działania bez połączenia.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> metody do zakończenia żądania asynchronicznego dla wystąpienia strumienia.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Żądanie nie zostało zrealizowane, a żaden strumień nie jest dostępna.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie został zwrócony przez bieżące wystąpienie po wywołaniu <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ta metoda została wywołana wcześniej przy użyciu <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> wcześniej została wywołana.  - lub - wystąpił błąd podczas przetwarzania żądania.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; context) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef context As TransportContext) As Stream" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; transportContext) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef transportContext As TransportContext) As Stream" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult *  -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream (asyncResult, transportContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" />
        <Parameter Name="context" Type="System.Net.TransportContext&amp;" RefType="out" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="transportContext" Type="System.Net.TransportContext&amp;" RefType="out" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oczekujące żądania dla strumienia.</param>
        <param name="context">To be added.</param>
        <param name="transportContext">To be added.</param>
        <summary>Kończy żądanie asynchroniczne dla <see cref="T:System.IO.Stream" /> obiekt ma być używany do zapisywania danych i dane wyjściowe <see cref="T:System.Net.TransportContext" /> skojarzone z strumienia.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> na potrzeby zapisu danych żądania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> Ukończeniu metody asynchroniczne żądanie dla strumienia, które zostało uruchomione przez <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> metody i wyjścia <xref:System.Net.TransportContext> skojarzone z strumienia. Po <xref:System.IO.Stream> został zwrócony obiekt, może wysyłać dane z <xref:System.Net.HttpWebRequest> przy użyciu <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> metody.  
  
 Niektóre aplikacje, które używają zintegrowanego uwierzytelniania systemu Windows z ochrony rozszerzonej może zaistnieć potrzeba może wykonać zapytania warstwy transportowej używany przez <xref:System.Net.HttpWebRequest> aby można było pobrać token wiązania kanałów (CBT) z podstawowej kanał TLS. <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Metoda zapewnia dostęp do tych informacji dla metod HTTP, których treść żądania (`POST` i `PUT` żądania). Jest to potrzebne tylko, jeśli aplikacja jest implementowanie uwierzytelniania i musi mieć dostęp do CBT.  
  
> [!NOTE]
>  Jeśli aplikacja musi ustawić wartość <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości, a następnie to należy wykonać przed pobierania strumienia i zapisywania danych.  
  
> [!CAUTION]
>  Należy wywołać <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> metody zamykać strumień i wersji połączenia do ponownego użycia. Nie można zamknąć strumienia powoduje, że aplikacja do działania bez połączenia.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie został zwrócony przez bieżące wystąpienie po wywołaniu <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ta metoda została wywołana wcześniej przy użyciu <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.IO.IOException">Żądanie nie zostało zrealizowane, a żaden strumień nie jest dostępna.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> wcześniej została wywołana.  - lub - wystąpił błąd podczas przetwarzania żądania.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="EndGetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse EndGetResponse (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse EndGetResponse(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetResponse(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetResponse (asyncResult As IAsyncResult) As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ EndGetResponse(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetResponse : IAsyncResult -&gt; System.Net.WebResponse" Usage="httpWebRequest.EndGetResponse asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oczekujące żądania dla odpowiedzi.</param>
        <summary>Kończy się asynchroniczne żądanie do zasobu internetowego.</summary>
        <returns>A <see cref="T:System.Net.WebResponse" /> zawierający odpowiedzi z zasobem internetowym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetResponse%2A> Ukończeniu metody asynchroniczne żądanie dla zasobu w Internecie, które zostało uruchomione przez wywołanie metody <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metody.  
  
> [!CAUTION]
>  Należy wywołać <xref:System.Net.HttpWebResponse.Close%2A> metodę, aby zamknąć strumienia i zwolnienia połączenia. Błąd w tym celu może spowodować aplikację do uruchamiania poza połączenia.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.HttpWebRequest.EndGetResponse%2A> metody do zakończenia żądania asynchronicznego dla zasobu internetowego.  
  
 [!code-cpp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CPP/httpwebrequest_begingetresponse.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CS/httpwebrequest_begingetresponse.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/VB/httpwebrequest_begingetresponse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ta metoda została wywołana wcześniej przy użyciu <paramref name="asyncResult." /> - lub - <see cref="P:System.Net.HttpWebRequest.ContentLength" /> właściwość jest większa niż 0, ale dane nie został zapisany do strumienia żądania.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> wcześniej została wywołana.  - lub - wystąpił błąd podczas przetwarzania żądania.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie został zwrócony przez bieżące wystąpienie po wywołaniu <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expect">
      <MemberSignature Language="C#" Value="public string Expect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Expect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Expect" />
      <MemberSignature Language="VB.NET" Value="Public Property Expect As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Expect { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Expect : string with get, set" Usage="System.Net.HttpWebRequest.Expect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see langword="Expect" /> nagłówka HTTP.</summary>
        <value>Zawartość <see langword="Expect" /> nagłówka HTTP. Wartość domyślna to <see langword="null" />.  
  
 <block subset="none" type="note"><para> Wartość tej właściwości jest przechowywana w <see cref="T:System.Net.WebHeaderCollection" />. Jeśli ustawiono WebHeaderCollection, wartość właściwości jest utracone.  </para></block></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <see langword="Expect" /> ustawiono na ciąg, który zawiera "100-kontynuować" jako podciąg.</exception>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected override void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="httpWebRequest.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> Do wypełniania danych.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> Określa, że lokalizacja docelowa tej serializacji.</param>
        <summary>Wypełnia <see cref="T:System.Runtime.Serialization.SerializationInfo" /> przy użyciu danych wymaganych do zserializowania obiektu docelowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie obiekty zawarte w <xref:System.Runtime.Serialization.SerializationInfo> automatycznie są śledzone i serializowany przez program formatujący.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera <see cref="T:System.IO.Stream" /> obiekt ma być używany do zapisywania danych żądania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetRequestStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetRequestStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRequestStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetRequestStream();" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream : unit -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="T:System.IO.Stream" /> obiekt ma być używany do zapisywania danych żądania.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> na potrzeby zapisu danych żądania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Metoda zwraca strumień do wysłania danych <xref:System.Net.HttpWebRequest>. Po <xref:System.IO.Stream> został zwrócony obiekt, może wysyłać dane z <xref:System.Net.HttpWebRequest> przy użyciu <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> metody.  
  
 Jeśli aplikacja musi ustawić wartość <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości, a następnie ta musi zostać wykonane przed pobraniem strumienia.  
  
 Należy wywołać <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> metody zamykać strumień i wersji połączenia do ponownego użycia. Nie można zamknąć strumienia powoduje, że aplikacja do działania bez połączenia.  
  
> [!NOTE]
>  Aplikacji nie można mieszać synchroniczne i asynchroniczne metody dla określonego żądania. Jeśli należy wywołać <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metody, należy użyć <xref:System.Net.HttpWebRequest.GetResponse%2A> metoda pobierania odpowiedzi.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metody można zwrócić wystąpienia strumienia.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> Właściwość jest GET lub HEAD.  - lub - <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> jest <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> jest <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> wynosi -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" />, i <see cref="P:System.Net.HttpWebRequest.Method" /> jest POST i PUT.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> Metoda jest wywoływana więcej niż raz.  - lub - <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> ma ustawioną wartość i <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Pamięci podręcznej żądania modułu sprawdzania poprawności wskazane, że odpowiedzi dla tego żądania mogą być przekazywane z pamięci podręcznej; jednak żądań zapisu danych nie może używać pamięci podręcznej. Ten wyjątek może wystąpić, jeśli używane jest niepoprawnie zaimplementowany sprawdzania poprawności niestandardowe pamięci podręcznej.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> wcześniej została wywołana.  - lub - limitu czasu dla żądania.  - lub - wystąpił błąd podczas przetwarzania żądania.</exception>
        <exception cref="T:System.ObjectDisposedException">W aplikacji .NET Compact Framework strumienia o zerowej długości zawartości żądania nie został uzyskany i zamknięty poprawnie. Aby uzyskać więcej informacji o zerowej długości zawartości żądania obsługi, zobacz [sieci programowania .NET Compact Framework] (https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetRequestStream (out System.Net.TransportContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetRequestStream([out] class System.Net.TransportContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream(System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRequestStream (ByRef context As TransportContext) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetRequestStream([Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream :  -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Net.TransportContext&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Net.TransportContext" /> Dla <see cref="T:System.IO.Stream" />.</param>
        <summary>Pobiera <see cref="T:System.IO.Stream" /> obiekt ma być używany do zapisywania danych żądania i danych wyjściowych <see cref="T:System.Net.TransportContext" /> skojarzone z strumienia.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> na potrzeby zapisu danych żądania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Metoda zwraca strumień do wysłania danych <xref:System.Net.HttpWebRequest> i wyprowadza <xref:System.Net.TransportContext> skojarzone z strumienia. Po <xref:System.IO.Stream> został zwrócony obiekt, może wysyłać dane z <xref:System.Net.HttpWebRequest> przy użyciu <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> metody.  
  
 Niektóre aplikacje, które używają zintegrowanego uwierzytelniania systemu Windows z ochrony rozszerzonej może zaistnieć potrzeba może wykonać zapytania warstwy transportowej używany przez <xref:System.Net.HttpWebRequest> aby można było pobrać token wiązania kanałów (CBT) z podstawowej kanał TLS. <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Metoda zapewnia dostęp do tych informacji dla metod HTTP, których treść żądania (`POST` i `PUT` żądania). Jest to potrzebne tylko, jeśli aplikacja jest implementowanie uwierzytelniania i musi mieć dostęp do CBT.  
  
 Jeśli aplikacja musi ustawić wartość <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości, a następnie ta musi zostać wykonane przed pobraniem strumienia.  
  
 Należy wywołać <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> metody zamykać strumień i wersji połączenia do ponownego użycia. Nie można zamknąć strumienia powoduje, że aplikacja do działania bez połączenia.  
  
> [!NOTE]
>  Aplikacji nie można mieszać synchroniczne i asynchroniczne metody dla określonego żądania. Jeśli należy wywołać <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metody, należy użyć <xref:System.Net.HttpWebRequest.GetResponse%2A> metoda pobierania odpowiedzi.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">
          <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> — Metoda nie może uzyskać <see cref="T:System.IO.Stream" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> Metoda jest wywoływana więcej niż raz.  - lub - <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> ma ustawioną wartość i <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Pamięci podręcznej żądania modułu sprawdzania poprawności wskazane, że odpowiedzi dla tego żądania mogą być przekazywane z pamięci podręcznej; jednak żądań zapisu danych nie może używać pamięci podręcznej. Ten wyjątek może wystąpić, jeśli używane jest niepoprawnie zaimplementowany sprawdzania poprawności niestandardowe pamięci podręcznej.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> Właściwość jest GET lub HEAD.  - lub - <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> jest <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> jest <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> wynosi -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" />, i <see cref="P:System.Net.HttpWebRequest.Method" /> jest POST i PUT.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> wcześniej została wywołana.  - lub - limitu czasu dla żądania.  - lub - wystąpił błąd podczas przetwarzania żądania.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse GetResponse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse GetResponse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetResponse () As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ GetResponse();" />
      <MemberSignature Language="F#" Value="override this.GetResponse : unit -&gt; System.Net.WebResponse" Usage="httpWebRequest.GetResponse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca odpowiedź z zasobem internetowym.</summary>
        <returns>A <see cref="T:System.Net.WebResponse" /> zawierający odpowiedzi z zasobem internetowym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetResponse%2A> Metoda zwraca <xref:System.Net.WebResponse> obiekt, który zawiera odpowiedzi z zasobem internetowym. Zwrócony rzeczywistego wystąpienia <xref:System.Net.HttpWebResponse>i być rzutowanie typu do tej klasy do właściwości dostępu specyficzne dla protokołu HTTP.  
  
 A <xref:System.Net.ProtocolViolationException> jest zgłaszany w kilku przypadkach, gdy wartość właściwości na <xref:System.Net.HttpWebRequest> klasy są w konflikcie. Ten wyjątek występuje, gdy aplikacja ustawia <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości i <xref:System.Net.HttpWebRequest.SendChunked%2A> właściwości `true`, a następnie wysyła żądanie HTTP GET. Ten wyjątek występuje, gdy aplikacja próbuje wysłać podzielony na serwerze obsługującym tylko protokół HTTP 1.0, gdzie jest to nieobsługiwane. Ten wyjątek występuje, gdy aplikacja próbuje wysłać dane bez ustawienia <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości lub <xref:System.Net.HttpWebRequest.SendChunked%2A> jest `false` gdy buforowanie jest wyłączone i połączenia keepalive ( <xref:System.Net.HttpWebRequest.KeepAlive%2A> właściwość jest `true`)`.`  
  
> [!CAUTION]
>  Należy wywołać <xref:System.Net.HttpWebResponse.Close%2A> metodę, aby zamknąć strumienia i zwolnienia połączenia. Błąd w tym celu może spowodować aplikację do uruchamiania poza połączenia.  
  
 Przy użyciu metody POST, należy uzyskać strumienia żądania, zapisywać danych można opublikować, a następnie zamknij strumienia. Ta metoda umożliwia blokowanie oczekiwanie na zawartość można opublikować; Jeśli nie ustawiono limit czasu, a nie podawaj zawartości, wywoływania bloki wątku w nieskończoność.  
  
> [!NOTE]
>  Wiele wywołań <xref:System.Net.HttpWebRequest.GetResponse%2A> powrócić do tego samego obiektu odpowiedzi; żądanie nie jest ponownie.  
  
> [!NOTE]
>  Aplikacji nie można mieszać synchroniczne i asynchroniczne metody dla określonego żądania. Jeśli należy wywołać <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metody, należy użyć <xref:System.Net.HttpWebRequest.GetResponse%2A> metoda pobierania odpowiedzi.  
  
> [!NOTE]
>  Jeśli <xref:System.Net.WebException> jest zgłoszone, użyj <xref:System.Net.WebException.Response%2A> i <xref:System.Net.WebException.Status%2A> właściwości wyjątku, aby określić odpowiedzi z serwera.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Ze względów bezpieczeństwa pliki cookie są domyślnie wyłączone. Jeśli chcesz używać plików cookie, użyj <xref:System.Net.HttpWebRequest.CookieContainer%2A> właściwość, aby włączyć obsługę plików cookie.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera odpowiedź na żądanie.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Strumień jest już używany przez poprzednie wywołanie <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.  - lub - <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> ma ustawioną wartość i <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" />.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> jest GET lub HEAD, a następnie <see cref="P:System.Net.HttpWebRequest.ContentLength" /> jest większa lub równa zero lub <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="true" />.  - lub - <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> jest <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> jest <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> wynosi -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" />, i <see cref="P:System.Net.HttpWebRequest.Method" /> jest POST i PUT.  - lub - <see cref="T:System.Net.HttpWebRequest" /> zawiera treść jednostki, ale <see cref="M:System.Net.HttpWebRequest.GetResponse" /> metoda jest wywoływana bez wywoływania elementu <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> metody.  - lub - <see cref="P:System.Net.HttpWebRequest.ContentLength" /> jest większa od zera, ale aplikacja nie zapisuje wszystkie dane uzgodnionej.</exception>
        <exception cref="T:System.NotSupportedException">Pamięci podręcznej żądania modułu sprawdzania poprawności wskazane, że odpowiedzi dla tego żądania mogą być przekazywane z pamięci podręcznej; Jednak to żądanie zawiera dane mają być wysyłane do serwera. Żądania, które wysyłają dane nie mogą używać pamięci podręcznej. Ten wyjątek może wystąpić, jeśli używane jest niepoprawnie zaimplementowany sprawdzania poprawności niestandardowe pamięci podręcznej.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> wcześniej została wywołana.  - lub - limitu czasu dla żądania.  - lub - wystąpił błąd podczas przetwarzania żądania.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="HaveResponse">
      <MemberSignature Language="C#" Value="public virtual bool HaveResponse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HaveResponse" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.HaveResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HaveResponse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HaveResponse { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HaveResponse : bool" Usage="System.Net.HttpWebRequest.HaveResponse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy odebrano odpowiedź z zasobem internetowym.</summary>
        <value>
          <see langword="true" /> Jeśli Odebrano odpowiedź; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod przykładowy kontroli <xref:System.Net.HttpWebRequest.HaveResponse%2A> właściwości w celu określenia, czy odebrano odpowiedź od zasobu internetowego.  
  
 [!code-cpp[Httpwebrequest_HaveResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CPP/httpwebrequest_haveresponse.cpp#1)]
 [!code-csharp[Httpwebrequest_HaveResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CS/httpwebrequest_haveresponse.cs#1)]
 [!code-vb[Httpwebrequest_HaveResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/VB/httpwebrequest_haveresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public override System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Headers As WebHeaderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::WebHeaderCollection ^ Headers { System::Net::WebHeaderCollection ^ get(); void set(System::Net::WebHeaderCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Net.WebHeaderCollection with get, set" Usage="System.Net.HttpWebRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa kolekcję par nazw i wartości, które tworzą nagłówków HTTP.</summary>
        <value>A <see cref="T:System.Net.WebHeaderCollection" /> zawierający pary nazwa/wartość, które tworzą nagłówki dla żądania HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Headers%2A> Kolekcja zawiera nagłówki protokołu skojarzone z żądaniem. W poniższej tabeli wymieniono nagłówków HTTP, które nie są przechowywane w <xref:System.Net.HttpWebRequest.Headers%2A> kolekcji, ale są ustawiane przez system lub ustawić właściwości lub metody.  
  
|nagłówek|Ustawione przez|  
|------------|------------|  
|Zaakceptuj|Ustawione przez <xref:System.Net.HttpWebRequest.Accept%2A> właściwości.|  
|Połączenia|Ustawione przez <xref:System.Net.HttpWebRequest.Connection%2A> właściwości i <xref:System.Net.HttpWebRequest.KeepAlive%2A> właściwości.|  
|Długość zawartości|Ustawione przez <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwości.|  
|Typ zawartości|Ustawione przez <xref:System.Net.HttpWebRequest.ContentType%2A> właściwości.|  
|Oczekiwane|Ustawione przez <xref:System.Net.HttpWebRequest.Expect%2A> właściwości.|  
|Data|Ustawione przez <xref:System.Net.HttpWebRequest.Date%2A> właściwości.|  
|Host|Ustawione przez <xref:System.Net.HttpWebRequest.Host%2A> właściwości.|  
|If-Modified-Since|Ustawione przez <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> właściwości.|  
|Zakres|Ustawione przez <xref:System.Net.HttpWebRequest.AddRange%2A> metody.|  
|Odnośnik|Ustawione przez <xref:System.Net.HttpWebRequest.Referer%2A> właściwości.|  
|Transfer-Encoding|Ustawione przez <xref:System.Net.HttpWebRequest.TransferEncoding%2A> właściwości ( <xref:System.Net.HttpWebRequest.SendChunked%2A> właściwość musi mieć wartość true).|  
|Agent użytkownika|Ustawione przez <xref:System.Net.HttpWebRequest.UserAgent%2A> właściwości.|  
  
 <xref:System.Net.WebHeaderCollection.Add%2A> Metoda zgłasza <xref:System.ArgumentException> Jeśli spróbujesz ustawić jedną z tych nagłówków chronionych.  
  
 Zmiana <xref:System.Net.HttpWebRequest.Headers%2A> właściwości po rozpoczęciu żądania przez wywołanie metody <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, lub <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metoda zgłasza <xref:System.InvalidOperationException>.  
  
 Nie należy zakładać, że wartości nagłówka pozostaną bez zmian, ponieważ serwery sieci Web i pamięci podręczne może zmienić lub dodać nagłówków żądania sieci Web.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.HttpWebRequest.Headers%2A> właściwości do drukowania pary nazwa/wartość nagłówka HTTP do konsoli.  
  
 [!code-cpp[HttpWebRequest_Headers#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Headers/CPP/httpwebrequest_headers.cpp#1)]
 [!code-csharp[HttpWebRequest_Headers#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Headers/CS/httpwebrequest_headers.cs#1)]
 [!code-vb[HttpWebRequest_Headers#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Headers/VB/httpwebrequest_headers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żądanie został uruchomiony przez wywołanie metody <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, lub <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> metody.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Host" />
      <MemberSignature Language="VB.NET" Value="Public Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : string with get, set" Usage="System.Net.HttpWebRequest.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>GET lub set hosta wartość nagłówka w żądaniu HTTP niezależnie od identyfikatora URI żądania.</summary>
        <value>Wartość nagłówka hosta w żądaniu HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Host%2A> Właściwości można ustawić hosta wartość nagłówka w żądaniu HTTP niezależnie od identyfikatora URI żądania. <xref:System.Net.HttpWebRequest.Host%2A> Właściwości może zawierać nazwy hosta i numer portu opcjonalne. Nagłówek hosta, bez informacji o porcie oznacza domyślny port dla żądanej usługi (port 80 dla adresu URL HTTP, na przykład).  
  
 Format służący do określania hosta i portu należy postępować zgodnie z regułami z sekcji 14.23 specyfikacją RFC2616 opublikowanych przez grupę roboczą IETF. Przykładem spełniające te wymagania określająca port 8080 może być następującą wartość dla <xref:System.Net.HttpWebRequest.Host%2A> właściwości:  
  
 `www.contoso.com:8080`  
  
 Przy użyciu <xref:System.Net.HttpWebRequest.Host%2A> właściwość, aby jawnie określić niestandardową wartość nagłówka hosta dotyczy również obszarów buforowanie plików cookie i uwierzytelniania. Gdy aplikacja udostępnia poświadczenia dla określonego identyfikatora URI prefiksu, aplikacje musi upewnij się, że Użyj identyfikatora URI zawierającego wartość nagłówka hosta, a nie na serwerze docelowym w identyfikatorze URI. Klucz używany podczas buforowania zasobów, używa wartość nagłówka hosta, a nie identyfikator URI żądania. Pliki cookie są przechowywane w <xref:System.Net.CookieContainer> i logicznie pogrupowane według nazwy domeny serwera. Jeśli aplikacja określa nagłówek hosta, jak domena używana jest ta wartość.  
  
 Jeśli <xref:System.Net.HttpWebRequest.Host%2A> nie ustawiono właściwości, a następnie wartość nagłówka hosta do użycia w żądaniu HTTP opiera się na identyfikator URI żądania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Nie można ustawić nagłówek hosta <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nagłówek hosta nie można ustawić na nieprawidłową wartość.</exception>
        <exception cref="T:System.InvalidOperationException">Nagłówek hosta nie można ustawić po <see cref="T:System.Net.HttpWebRequest" /> została już uruchomiona na wysłanie.</exception>
      </Docs>
    </Member>
    <Member MemberName="IfModifiedSince">
      <MemberSignature Language="C#" Value="public DateTime IfModifiedSince { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime IfModifiedSince" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberSignature Language="VB.NET" Value="Public Property IfModifiedSince As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime IfModifiedSince { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.IfModifiedSince : DateTime with get, set" Usage="System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see langword="If-Modified-Since" /> nagłówka HTTP.</summary>
        <value>A <see cref="T:System.DateTime" /> zawiera zawartość <see langword="If-Modified-Since" /> nagłówka HTTP. Wartość domyślna to bieżącą datę i godzinę.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> Właściwości jest standardem <xref:System.DateTime?displayProperty=nameWithType> obiektu i może zawierać <xref:System.DateTimeKind?displayProperty=nameWithType> pole <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, lub <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Dowolny rodzaj czasu można ustawić przy użyciu <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> właściwości. Jeśli <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> jest ustawiona lub pobrana, <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> właściwości zakłada się, że <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (czas lokalny).  
  
 Klasy w <xref:System.Net> przestrzeni nazw zawsze zapisać go <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> właściwości umieszczonego podczas przesyłania w formie standardowej formacie GMT (czas Utc).  
  
 Jeśli <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> właściwość jest ustawiona na <xref:System.DateTime.MinValue?displayProperty=nameWithType>, a następnie `If-Modified-Since` nagłówka HTTP jest usuwany z <xref:System.Net.HttpWebRequest.Headers%2A> właściwości i <xref:System.Net.WebHeaderCollection>.  
  
 Jeśli <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> właściwość jest <xref:System.DateTime.MinValue?displayProperty=nameWithType>, oznacza to, że `If-Modified-Since` nagłówka HTTP nie jest uwzględniony w <xref:System.Net.HttpWebRequest.Headers%2A> właściwości i <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  Wartość tej właściwości jest przechowywana w <xref:System.Net.WebHeaderCollection>. Jeśli ustawiono WebHeaderCollection, wartość właściwości jest utracone.  
  
   
  
## Examples  
 Poniższy kod przykładowy kontroli <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> właściwości.  
  
 [!code-cpp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CPP/httpwebrequest_ifmodifiedsince.cpp#1)]
 [!code-csharp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CS/httpwebrequest_ifmodifiedsince.cs#1)]
 [!code-vb[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/VB/httpwebrequest_ifmodifiedsince.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool with get, set" Usage="System.Net.HttpWebRequest.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy należy ustanowić trwałe połączenie z zasobem internetowym.</summary>
        <value>
          <see langword="true" /> Jeśli żądanie do zasobu internetowego powinien zawierać <see langword="Connection" /> nagłówka HTTP o wartości Keep-alive; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest ustawiana `true` do wysyłania `Connection` nagłówka HTTP o wartości Keep-alive. Aplikacja używa <xref:System.Net.HttpWebRequest.KeepAlive%2A> do wskazuje połączeń trwałych. Gdy <xref:System.Net.HttpWebRequest.KeepAlive%2A> właściwość jest `true`, aplikacji powoduje trwałe połączeń z serwerami, które je obsługują.  
  
> [!NOTE]
>  Podczas korzystania z protokołu HTTP/1.1, Keep-Alive jest domyślnie włączone. Ustawienie <xref:System.Net.HttpWebRequest.KeepAlive%2A> do `false` może spowodować wysyłanie `Connection: Close` nagłówka do serwera.  
  
   
  
## Examples  
 Poniższy kod przykładzie <xref:System.Net.HttpWebRequest.KeepAlive%2A> właściwości `false` w celu uniknięcia ustanowienia trwałego połączenia z zasobem internetowym.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumAutomaticRedirections">
      <MemberSignature Language="C#" Value="public int MaximumAutomaticRedirections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumAutomaticRedirections" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumAutomaticRedirections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumAutomaticRedirections { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumAutomaticRedirections : int with get, set" Usage="System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną liczbę przekierowań, które wykonuje żądanie.</summary>
        <value>Maksymalna liczba odpowiedzi przekierowania, które wykonuje żądanie. Wartością domyślną jest 50.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> Właściwość ustawia maksymalną liczbę przekierowań dla żądania, które należy wykonać, jeśli <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> jest właściwość `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu określa wartość tej właściwości.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość jest ustawiona na wartość 0 lub mniej.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną dopuszczalną długość nagłówków odpowiedzi.</summary>
        <value>Długość w kilobajtach (1024 bajty), nagłówki odpowiedzi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Długość nagłówka odpowiedzi zawiera wiersz stanu odpowiedzi i żadnych znaków kontrolnych dodatkowe, które są odbierane w ramach protokołu HTTP. Wartość-1 oznacza, że limit nie nakłada się na nagłówki odpowiedzi; wartość 0 oznacza, że wszystkie żądania zakończyć się niepowodzeniem.  
  
 Jeśli <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> właściwość nie jest jawnie ustawiona, domyślne wartości <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A> właściwości.  
  
 Jeśli długość nagłówka odpowiedzi otrzymanych przekracza wartość <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> właściwość <xref:System.Net.HttpWebRequest.EndGetResponse%2A> lub <xref:System.Net.HttpWebRequest.GetResponse%2A> metody spowoduje zgłoszenie <xref:System.Net.WebException> z <xref:System.Net.WebException.Status%2A> ustawioną właściwość <xref:System.Net.WebExceptionStatus.MessageLengthLimitExceeded>.  
  
   
  
## Examples  
 Poniższy przykład kodu określa wartość tej właściwości.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Właściwość jest ustawiana po już zostało przesłane żądanie.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość jest mniejsza niż 0 i nie jest równa -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="MediaType">
      <MemberSignature Language="C#" Value="public string MediaType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MediaType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MediaType" />
      <MemberSignature Language="VB.NET" Value="Public Property MediaType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MediaType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MediaType : string with get, set" Usage="System.Net.HttpWebRequest.MediaType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ nośnika żądania.</summary>
        <value>Typ nośnika żądania. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.Net.HttpWebRequest.MediaType%2A> właściwość ma wpływ na <xref:System.Net.HttpWebResponse.CharacterSet%2A> właściwości. Podczas ustawiania <xref:System.Net.HttpWebRequest.MediaType%2A> w żądaniu, odpowiedni typ nośnika jest wybrany z listy w odpowiedzi zwracany zestawów znaków `Content-type` nagłówka HTTP.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public override string Method { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Method" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Method" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Method As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Method { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Method : string with get, set" Usage="System.Net.HttpWebRequest.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia metodę dla żądania.</summary>
        <value>Metoda żądania służące do kontaktowania się z zasobem internetowym. Wartość domyślna to GET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Method%2A> Właściwość można ustawić dla każdego zlecenia protokołu HTTP 1.1: GET, HEAD, POST, PUT, Usuń śledzenia lub opcji.  
  
 Jeśli <xref:System.Net.HttpWebRequest.ContentLength%2A> właściwość ma ustawioną wartość inną niż -1, <xref:System.Net.HttpWebRequest.Method%2A> musi być ustawiona właściwość do właściwości protokołu, która przekazuje dane.  
  
   
  
## Examples  
 Poniższy kod przykładzie <xref:System.Net.HttpWebRequest.Method%2A> właściwości POST.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Brak metody są dostarczane.  - lub - metoda ciąg zawiera nieprawidłowe znaki.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pipelined">
      <MemberSignature Language="C#" Value="public bool Pipelined { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Pipelined" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Pipelined" />
      <MemberSignature Language="VB.NET" Value="Public Property Pipelined As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Pipelined { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Pipelined : bool with get, set" Usage="System.Net.HttpWebRequest.Pipelined" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy do potoku żądania z zasobem internetowym.</summary>
        <value>
          <see langword="true" /> Jeśli żądanie powinno być potokowe; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja używa <xref:System.Net.HttpWebRequest.Pipelined%2A> Właściwość wskazująca preferencji dla połączeń w trybie potokowym. Gdy <xref:System.Net.HttpWebRequest.Pipelined%2A> jest `true`, aplikacja zgłasza potokowej połączeń z serwerami, które je obsługują.  
  
 Potokowej połączenia są nawiązywane tylko wtedy, gdy <xref:System.Net.HttpWebRequest.KeepAlive%2A> właściwość jest również `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość <xref:System.Net.HttpWebRequest.Pipelined%2A> właściwości do konsoli.  
  
 [!code-cpp[HttpWebRequest_PipeLined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CPP/httpwebrequest_pipelined.cpp#1)]
 [!code-csharp[HttpWebRequest_PipeLined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CS/httpwebrequest_pipelined.cs#1)]
 [!code-vb[HttpWebRequest_PipeLined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_PipeLined/VB/httpwebrequest_pipelined.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public override bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreAuthenticate : bool with get, set" Usage="System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy mają być wysyłane z żądaniem nagłówek autoryzacji.</summary>
        <value>
          <see langword="true" /> Aby wysłać nagłówek uwierzytelnienia HTTP z żądaniami, po przeprowadzeniu uwierzytelniania; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po odebraniu żądania klienta do konkretnego <xref:System.Uri> zostanie pomyślnie uwierzytelniony, jeśli <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> jest `true` i podano poświadczenia, Nagłówek uwierzytelnienia są wysyłane z każdym żądaniem do dowolnego <xref:System.Uri> odpowiadającej konkretnym <xref:System.Uri>do ostatniego ukośnika. Tak, jeśli żądanie klienta pomyślnie uwierzytelniony do konkretnego <xref:System.Uri> zawiera następujące:  
  
 `http://www.contoso.com/firstpath/`  
  
 Następnie nagłówek autoryzacji do wstępnego uwierzytelniania są wysyłane z każdym żądaniem do następujących <xref:System.Uri> wystąpień:  
  
 `http://www.contoso.com/firstpath/`  
  
 `http://www.contoso.com/firstpath/default`  
  
 `http://www.contoso.com/firstpath/default.html`  
  
 `http://www.contoso.com/firstpath/sample.html`  
  
 Jednak nagłówek autoryzacji nie są wysyłane z żądania do następujących <xref:System.Uri> wystąpień:  
  
 `http://www.contoso.com/`  
  
 `http://www.contoso.com/firstpath`  
  
 `http://www.contoso.com/secondpath/`  
  
 Jeśli żądanie klienta do konkretnego <xref:System.Uri> to żądanie nie zostało pomyślnie uwierzytelniony, korzysta z uwierzytelniania standardowe procedury.  
  
 Z wyjątkiem pierwsze żądanie <xref:System.Net.WebRequest.PreAuthenticate%2A> właściwość wskazuje, czy chcą wysłać informacje o uwierzytelnianiu z kolejnych żądań wysyłanych do <xref:System.Uri> odpowiadającej konkretnym <xref:System.Uri> do ostatniego ukośnik bez oczekujących na przetworzenie wąskie przez serwer.  
  
 To okno dialogowe między klientem i serwerem ilustruje efekt tej właściwości. Okno dialogowe przyjęto założenie, że uwierzytelniania podstawowego jest w użyciu.  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> jest `false`:  
  
 Klienta: SomeUrl GET  
  
 Serwera: Basic 401 WWW-Authenticate  
  
 Klient: GET z nagłówkami autoryzacji  
  
 Serwer: 200 OK  
  
 Klienta: SomeUrl GET  
  
 Serwera: Basic 401 WWW-Authenticate  
  
 Klient: GET z nagłówkami autoryzacji  
  
 Serwer: 200 OK  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> jest `true`:  
  
 Klienta: SomeUrl GET  
  
 Serwera: Basic 401 WWW-Authenticate  
  
 Klient: GET z nagłówkami autoryzacji  
  
 Serwer: 200 OK  
  
 Klient: Pobierz someUrl z nagłówkami autoryzacji  
  
 Jeśli schemat uwierzytelniania nie obsługuje uwierzytelniania wstępnego, wartość ta właściwość jest ignorowana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolVersion : Version with get, set" Usage="System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wersję protokołu HTTP do użycia dla żądania.</summary>
        <value>Wersja protokołu HTTP do użycia dla żądania. Wartość domyślna to <see cref="F:System.Net.HttpVersion.Version11" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest> Klasa obsługuje tylko w wersjach 1.0 i 1.1 HTTP. Ustawienie <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> do innej wersji zgłasza wyjątek.  
  
> [!NOTE]
>  Aby ustawić wersję bieżącego żądania HTTP, użyj <xref:System.Net.HttpVersion.Version10> i <xref:System.Net.HttpVersion.Version11> pola <xref:System.Net.HttpVersion> klasy.  
  
   
  
## Examples  
 Poniższy kod przykładzie <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> właściwości.  
  
 [!code-cpp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CPP/httpwebrequest_protocolversion.cpp#1)]
 [!code-csharp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CS/httpwebrequest_protocolversion.cs#1)]
 [!code-vb[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/VB/httpwebrequest_protocolversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wersja protokołu HTTP jest ustawiona na wartość inną niż w wersji 1.0 lub 1.1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Proxy : System.Net.IWebProxy with get, set" Usage="System.Net.HttpWebRequest.Proxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje o serwerze proxy dla żądania.</summary>
        <value>
          <see cref="T:System.Net.IWebProxy" /> Obiektu na potrzeby serwera proxy żądania. Wartość domyślna jest ustawiana przez wywołanie metody <see cref="P:System.Net.GlobalProxySelection.Select" /> właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Proxy%2A> Właściwość identyfikuje <xref:System.Net.WebProxy> obiektu do przetwarzania żądań do zasobów Internetu. Aby określić, że należy używać żadnego serwera proxy, należy ustawić <xref:System.Net.HttpWebRequest.Proxy%2A> właściwość w wystąpieniu serwera proxy zwrócony przez <xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A?displayProperty=nameWithType> metody.  
  
 Komputer lokalny lub pliku konfiguracji aplikacji może określić, że używane domyślny serwer proxy. Jeśli <xref:System.Net.HttpWebRequest.Proxy%2A> właściwość jest określona, następnie ustawienia serwera proxy z <xref:System.Net.HttpWebRequest.Proxy%2A> zastąpienie właściwości komputera lokalnego lub pliku konfiguracyjnym aplikacji i <xref:System.Net.HttpWebRequest> wystąpienia użyje określić ustawienia serwera proxy. Jeśli w pliku konfiguracji określono żadnego serwera proxy i <xref:System.Net.HttpWebRequest.Proxy%2A> właściwość nie jest określona, <xref:System.Net.HttpWebRequest> klasa korzysta z ustawień serwera proxy dziedziczone z programu Internet Explorer na komputerze lokalnym. Jeśli nie ma żadnych ustawień serwera proxy w programie Internet Explorer, żądanie jest wysyłane bezpośrednio do serwera.  
  
 <xref:System.Net.HttpWebRequest> Analizuje klasy Lista obejść serwerów proxy, z symbolami wieloznacznymi dziedziczone z programu Internet Explorer taka sama jak lista obejść jest analizowana bezpośrednio przez Internet Explorer. Na przykład <xref:System.Net.HttpWebRequest> klasy będzie analizować obejścia listę "nt *" w programie Internet Explorer jako wyrażenie regularne "nt.\*". Dlatego adresu URL "`http://nt.com`" czy pominąć serwer proxy przy użyciu <xref:System.Net.HttpWebRequest> klasy i przy użyciu programu Internet Explorer.  
  
 <xref:System.Net.HttpWebRequest> Klasa obsługuje obejście lokalnego serwera proxy. Klasa uwzględnia lokalizację docelową, aby być kontem lokalnym, jeśli spełnione są następujące warunki:  
  
-   Lokalizacja docelowa zawiera płaskiej nazwy (nie kropki w adresie URL).  
  
-   Lokalizacja docelowa zawiera adres sprzężenia zwrotnego (<xref:System.Net.IPAddress.Loopback> lub <xref:System.Net.IPAddress.IPv6Loopback>) lub lokalizacja docelowa zawiera <xref:System.Net.IPAddress> przypisane do komputera lokalnego.  
  
-   Sufiks domeny docelowego odpowiada sufiks domeny komputera lokalnego (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>).  
  
 Zmiana <xref:System.Net.HttpWebRequest.Proxy%2A> właściwości po rozpoczęciu żądania przez wywołanie metody <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, lub <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metoda zgłasza <xref:System.InvalidOperationException>. Informacje dotyczące serwera proxy elementu sekcji [ \&lt; defaultProxy —\&gt; Element (ustawienia sieciowe)](~/docs/framework/configure-apps/file-schema/network/defaultproxy-element-network-settings.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.HttpWebRequest.Proxy%2A> metody, aby uzyskać informacje o serwerze proxy dla żądania.  
  
 [!code-cpp[Httpwebrequest_proxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_proxy/CPP/httpwebrequest_proxy.cpp#1)]
 [!code-csharp[Httpwebrequest_proxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_proxy/CS/httpwebrequest_proxy.cs#1)]
 [!code-vb[Httpwebrequest_proxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_proxy/VB/httpwebrequest_proxy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.HttpWebRequest.Proxy" /> ustawiono <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Żądanie został uruchomiony przez wywołanie metody <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, lub <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma uprawnienia dla żądanej operacji.</exception>
        <permission cref="T:System.Net.WebPermission">Można pobrać lub ustawić <see cref="P:System.Net.HttpWebRequest.Proxy" /> właściwości. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadWriteTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia limit czasu w milisekundach zapisywania lub odczytywania ze strumienia.</summary>
        <value>Wyrażony w milisekundach czas, zanim limit czasu zapisu lub odczytu. Wartość domyślna to 300 000 milisekund (5 minut).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> Właściwość jest używana podczas zapisywania do strumienia zwrócone przez <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metody lub Odczyt ze strumienia zwrócone przez <xref:System.Net.HttpWebResponse.GetResponseStream%2A> metody.  
  
 W szczególności <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> właściwość określa limit czasu dla <xref:System.IO.Stream.Read%2A> metodę, która jest używana do odczytu Strumień zwrócony przez <xref:System.Net.HttpWebResponse.GetResponseStream%2A> metody i <xref:System.IO.Stream.Write%2A> metodę, która jest używana podczas zapisu do strumienia zwrócone przez <xref:System.Net.HttpWebRequest.GetRequestStream%2A>metody.  
  
 Aby określić ilość czasu oczekiwania na zakończenie żądania, użyj <xref:System.Net.HttpWebRequest.Timeout%2A> właściwości.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono sposób ustawiania <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> właściwości.  
  
 [!code-csharp[Classic HttpWebRequest Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żądanie zostało wysłane.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość określona dla operacji ustawienia jest mniejsza niż lub równa zero i nie jest równy <see cref="F:System.Threading.Timeout.Infinite" /></exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="Referer">
      <MemberSignature Language="C#" Value="public string Referer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Referer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Referer" />
      <MemberSignature Language="VB.NET" Value="Public Property Referer As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Referer { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Referer : string with get, set" Usage="System.Net.HttpWebRequest.Referer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see langword="Referer" /> nagłówka HTTP.</summary>
        <value>Wartość <see langword="Referer" /> nagłówka HTTP. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> właściwość jest `true`, <xref:System.Net.HttpWebRequest.Referer%2A> właściwości jest ustawiany automatycznie, gdy żądanie jest przekierowywane do innej lokacji.  
  
 Aby wyczyścić `Referer` nagłówka HTTP, ustaw <xref:System.Net.HttpWebRequest.Referer%2A> właściwości `null`.  
  
> [!NOTE]
>  Wartość tej właściwości jest przechowywana w <xref:System.Net.WebHeaderCollection>. Jeśli ustawiono WebHeaderCollection, wartość właściwości jest utracone.  
  
   
  
## Examples  
 Poniższy kod przykładzie <xref:System.Net.HttpWebRequest.Referer%2A> właściwości.  
  
 [!code-cpp[HttpWebRequest_Referer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Referer/CPP/httpwebrequest_referer.cpp#1)]
 [!code-csharp[HttpWebRequest_Referer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Referer/CS/httpwebrequest_referer.cs#1)]
 [!code-vb[HttpWebRequest_Referer#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Referer/VB/httpwebrequest_referer.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestUri">
      <MemberSignature Language="C#" Value="public override Uri RequestUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri RequestUri" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.RequestUri" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RequestUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Uri ^ RequestUri { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestUri : Uri" Usage="System.Net.HttpWebRequest.RequestUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera oryginalnego URI Uniform Resource Identifier () żądania.</summary>
        <value>A <see cref="T:System.Uri" /> zawiera identyfikator URI zasobu internetowego przekazany do <see cref="M:System.Net.WebRequest.Create(System.String)" /> metody.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri> Obiekt przekazywany do <xref:System.Net.HttpWebRequest> przez wywołanie <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>.  
  
 Następujące przekierowania nie zmienia nagłówka <xref:System.Net.HttpWebRequest.RequestUri%2A> właściwości. Aby uzyskać rzeczywiste identyfikator URI, który odpowiedział na żądanie, zapoznaj się <xref:System.Net.HttpWebRequest.Address%2A> właściwości.  
  
   
  
## Examples  
 Poniższy kod sprawdza przykład, jeśli <xref:System.Net.HttpWebRequest> obiektu `req` zostało przekierowane do innej lokalizacji do spełnienia żądania i ustawia wartość `hasChanged` zmienną `true` Jeśli żądanie zostało przekierowane; w przeciwnym razie `hasChanged` ma ustawioną wartość `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendChunked">
      <MemberSignature Language="C#" Value="public bool SendChunked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SendChunked" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SendChunked" />
      <MemberSignature Language="VB.NET" Value="Public Property SendChunked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SendChunked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SendChunked : bool with get, set" Usage="System.Net.HttpWebRequest.SendChunked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy wysyłać dane w segmentach z zasobem internetowym.</summary>
        <value>
          <see langword="true" /> Aby wysyłać dane do zasobu internetowego w segmentach; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Net.HttpWebRequest.SendChunked%2A> jest `true`, żądanie wysyła dane do zasobu internetowego w segmentach. Zasobu internetowego musi obsługiwać odbieranie podzielony danych.  
  
 Zmiana <xref:System.Net.HttpWebRequest.SendChunked%2A> właściwości po rozpoczęciu żądania przez wywołanie metody <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, lub <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metoda zgłasza <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 Poniższy kod przykładzie <xref:System.Net.HttpWebRequest.SendChunked%2A> właściwości `true` , dzięki czemu można wysyłać dane w segmentach z zasobem internetowym.  
  
 [!code-cpp[HttpWebRequest_SendChunked#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CPP/httpwebrequest_sendchunked.cpp#2)]
 [!code-csharp[HttpWebRequest_SendChunked#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CS/httpwebrequest_sendchunked.cs#2)]
 [!code-vb[HttpWebRequest_SendChunked#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_SendChunked/VB/httpwebrequest_sendchunked.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żądanie został uruchomiony przez wywołanie metody <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, lub <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> metody.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia funkcję wywołania zwrotnego można sprawdzić poprawności certyfikatu serwera.</summary>
        <value>Funkcja wywołania zwrotnego można sprawdzić poprawności certyfikatu serwera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość domyślna to, że jest ustawiona żadna funkcja wywołania zwrotnego i <xref:System.Net.HttpWebRequest.ServerCertificateValidationCallback%2A> jest właściwość `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServicePoint">
      <MemberSignature Language="C#" Value="public System.Net.ServicePoint ServicePoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ServicePoint ServicePoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServicePoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServicePoint As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ServicePoint ^ ServicePoint { System::Net::ServicePoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServicePoint : System.Net.ServicePoint" Usage="System.Net.HttpWebRequest.ServicePoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera punkt usługi do użycia dla żądania.</summary>
        <value>A <see cref="T:System.Net.ServicePoint" /> reprezentujący połączenie sieciowe z zasobem internetowym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePoint.Address%2A?displayProperty=nameWithType> Właściwości może się różnić od <xref:System.Net.HttpWebRequest.Address%2A?displayProperty=nameWithType> Jeśli żądanie jest przekierowywane.  
  
   
  
## Examples  
 [!code-cpp[System.Net.ServicePoint#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#6)]
 [!code-csharp[System.Net.ServicePoint#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#6)]
 [!code-vb[System.Net.ServicePoint#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsCookieContainer">
      <MemberSignature Language="C#" Value="public virtual bool SupportsCookieContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsCookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsCookieContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsCookieContainer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsCookieContainer : bool" Usage="System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy żądanie zapewnia obsługę <see cref="T:System.Net.CookieContainer" />.</summary>
        <value>
          <see langword="true" /> Jeśli żądanie zapewnia obsługę <see cref="T:System.Net.CookieContainer" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> Do wypełniania danych.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> Określa, że lokalizacja docelowa tej serializacji.</param>
        <summary>Wypełnia <see cref="T:System.Runtime.Serialization.SerializationInfo" /> z dane potrzebne do zserializowania obiektu docelowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie obiekty zawarte w <xref:System.Runtime.Serialization.SerializationInfo> automatycznie są śledzone i serializowany przez program formatujący.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public override int Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Timeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Timeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Timeout : int with get, set" Usage="System.Net.HttpWebRequest.Timeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość limitu czasu w milisekundach <see cref="M:System.Net.HttpWebRequest.GetResponse" /> i <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> metody.</summary>
        <value>Wyrażony w milisekundach czas oczekiwania, zanim żądanie upłynie limit czasu. Wartość domyślna to 100 000 milisekund (100 sekund).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Timeout%2A> jest to liczba milisekund, jaką kolejnych żądań synchronicznych wprowadzone w <xref:System.Net.HttpWebRequest.GetResponse%2A> metody czeka na odpowiedź i <xref:System.Net.HttpWebRequest.GetRequestStream%2A> metoda oczekuje dla strumienia. <xref:System.Net.HttpWebRequest.Timeout%2A> Ma zastosowanie do całego żądania i odpowiedzi, nie indywidualnie do <xref:System.Net.HttpWebRequest.GetRequestStream%2A> i <xref:System.Net.HttpWebRequest.GetResponse%2A> wywołania metody. Jeśli zasobu nie są zwracane w ramach limitu czasu, zgłasza żądanie <xref:System.Net.WebException> z <xref:System.Net.WebException.Status%2A> ustawioną właściwość <xref:System.Net.WebExceptionStatus.Timeout?displayProperty=nameWithType>.  
  
 <xref:System.Net.HttpWebRequest.Timeout%2A> Musi być ustawiona właściwość przed <xref:System.Net.HttpWebRequest.GetRequestStream%2A> lub <xref:System.Net.HttpWebRequest.GetResponse%2A> metoda jest wywoływana. Zmiana <xref:System.Net.HttpWebRequest.Timeout%2A> właściwości po wywołaniu <xref:System.Net.HttpWebRequest.GetRequestStream%2A> lub <xref:System.Net.HttpWebRequest.GetResponse%2A> — metoda nie ma wpływu  
  
 <xref:System.Net.HttpWebRequest.Timeout%2A> Właściwość nie ma wpływu na żądania asynchroniczne z <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> lub <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> metody.  
  
> [!CAUTION]
>  W przypadku żądań asynchronicznych aplikacja kliencka implementuje mechanizm limitu czasu. Zobacz przykład <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> metody.  
  
 Aby określić ilość czasu oczekiwania przed odczytu lub zapisu czasu operacji wychodzących, użyj <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> właściwości.  
  
 Zapytanie systemu nazw domen (DNS, Domain Name System) może potrwać do 15 sekund do zwrócenia lub upłynął limit czasu. Jeśli żądanie zawiera nazwę hosta, która wymaga rozpoznawania i ustawisz <xref:System.Net.FileWebRequest.Timeout%2A> do wartości mniejszej niż 15 sekund może zająć 15 sekund lub więcej przed <xref:System.Net.WebException> jest generowany, aby wskazać limitu czasu na żądanie.  
  
   
  
## Examples  
 Poniższy kod przykładzie <xref:System.Net.HttpWebRequest.Timeout%2A> właściwość <xref:System.Net.HttpWebRequest> obiektu.  
  
 [!code-cpp[HttpWebRequest_Timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CPP/httpwebrequest_timeout.cpp#1)]
 [!code-csharp[HttpWebRequest_Timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CS/httpwebrequest_timeout.cs#1)]
 [!code-vb[HttpWebRequest_Timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Timeout/VB/httpwebrequest_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Określona wartość jest mniejsza od zera i nie jest <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransferEncoding">
      <MemberSignature Language="C#" Value="public string TransferEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransferEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.TransferEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransferEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransferEncoding : string with get, set" Usage="System.Net.HttpWebRequest.TransferEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see langword="Transfer-encoding" /> nagłówka HTTP.</summary>
        <value>Wartość <see langword="Transfer-encoding" /> nagłówka HTTP. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed skonfigurowaniem <xref:System.Net.HttpWebRequest.TransferEncoding%2A> właściwości, należy najpierw ustawić <xref:System.Net.HttpWebRequest.SendChunked%2A> właściwości `true`. Wyczyszczenie <xref:System.Net.HttpWebRequest.TransferEncoding%2A> przez ustawienie jej na `null` nie ma wpływu na wartość <xref:System.Net.HttpWebRequest.SendChunked%2A>.  
  
 Wartości przypisane do <xref:System.Net.HttpWebRequest.TransferEncoding%2A> właściwości zastąpienie istniejącej zawartości.  
  
> [!NOTE]
>  Wartość tej właściwości jest przechowywana w <xref:System.Net.WebHeaderCollection>. Jeśli ustawiono WebHeaderCollection, wartość właściwości jest utracone.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> jest włączone, gdy <see cref="P:System.Net.HttpWebRequest.SendChunked" /> jest <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> ma ustawioną wartość "Fragmentaryczne".</exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeAuthenticatedConnectionSharing : bool with get, set" Usage="System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy zezwolić na udostępnianie szybkiego połączenia z uwierzytelnianiem NTLM.</summary>
        <value>
          <see langword="true" /> Aby utrzymać otwarte; uwierzytelnionego połączenia w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość domyślna dla tej właściwości to `false`, co powoduje, że bieżące połączenie zostanie zamknięty, zakończenia żądania. Aplikacja musi przechodzić przez sekwencji uwierzytelniania za każdym razem, gdy wystawia nowe żądanie.  
  
 Jeśli ta właściwość jest ustawiona na `true`, połączenie używane do pobierania odpowiedzi pozostaje otwarty po przeprowadzeniu uwierzytelniania. W takim przypadku żądań innych, że ta właściwość ma wartość `true` może korzystać z połączenia bez ponownego uwierzytelniania. Innymi słowy, jeśli została ona uwierzytelniona połączenia dla użytkownika A, użytkownik B mogą ponownie wykorzystać A połączenia; żądanie użytkownika B spełniony jest przeprowadzane przy użyciu poświadczeń użytkownika A.  
  
> [!CAUTION]
>  Ponieważ jest możliwe do użycia przez połączenie bez uwierzytelnianego aplikacji, należy upewnić się, że nie administracyjne luki w zabezpieczeniach w systemie, gdy ustawienie dla tej właściwości `true`. Jeśli aplikacja wysyła żądania przez wielu użytkowników (personifikuje wiele kont użytkowników) i opiera się na uwierzytelnianiu w celu ochrony zasobów, nie należy ustawiać tej właściwości `true` chyba że są używane grupy połączeń, zgodnie z poniższym opisem.  
  
 Warto rozważyć włączenie ten mechanizm, jeśli Twoje występują problemy z wydajnością i aplikacja jest uruchomiona na serwerze sieci Web przy użyciu zintegrowanego uwierzytelniania systemu Windows.  
  
 Włączenie tego ustawienia otwiera system na zagrożenia bezpieczeństwa. Jeśli ustawisz <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> właściwości `true` podejmij następujące środki ostrożności:  
  
-   Użyj <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> właściwości do zarządzania połączeniami dla różnych użytkowników. Dzięki temu można uniknąć potencjalnego Użyj połączenia przez aplikacje bez uwierzytelnienia. Na przykład użytkownik A powinien mieć nazwę grupy połączeń, która różni się od użytkownika B. To zapewnia warstwę izolacji dla każdego konta użytkownika.  
  
-   Uruchom aplikację w chronionym środowisku w celu uniknięcia połączenia możliwe luki w zabezpieczeniach.  
  
 Jeśli dany serwer zaplecza jako alternatywę można rozważyć wyłączenie uwierzytelniania trwałości. Powoduje to zwiększenie wydajności w mniejszym stopniu, ale jest bezpieczniejsze. Aby uzyskać więcej informacji, wyszukaj AuthPersistence w bibliotece MSDN pod [ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library).  
  
> [!NOTE]
>  Jeśli oba <xref:System.Net.WebRequest.PreAuthenticate%2A> i <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> ustawiono `true`, każdego żądania są wysyłane przy użyciu połączenia z puli unsafe, ale z nagłówkiem autoryzacji.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Aby ustawić tę właściwość, wymagane jest nieograniczony uprawnienie sieci Web.</permission>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public override bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDefaultCredentials : bool with get, set" Usage="System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość kontroli tego, czy z żądaniami są wysyłane domyślne poświadczenia.</summary>
        <value>
          <see langword="true" /> Jeśli są używane domyślne poświadczenia; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest ustawiana `true` nawiązaniem żądań to <xref:System.Net.HttpWebRequest> obiektu Jeśli jest to wymagane przez serwer, uwierzytelniania przy użyciu poświadczeń aktualnie zalogowanego użytkownika. Aplikacje klienckie jest to zachowanie w większości przypadków. Dla aplikacji warstwy środkowej, takich jak aplikacje ASP.NET, zamiast używać tej właściwości można zwykle ustawić <xref:System.Net.HttpWebRequest.Credentials%2A> właściwości do poświadczeń w imieniu którego żądań klienta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Próbowano ustawić tę właściwość, po żądanie zostało wysłane.</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string with get, set" Usage="System.Net.HttpWebRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see langword="User-agent" /> nagłówka HTTP.</summary>
        <value>Wartość <see langword="User-agent" /> nagłówka HTTP. Wartość domyślna to <see langword="null" />.  
  
 <block subset="none" type="note"><para> Wartość tej właściwości jest przechowywana w <see cref="T:System.Net.WebHeaderCollection" />. Jeśli ustawiono WebHeaderCollection, wartość właściwości jest utracone.  </para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod przykładzie <xref:System.Net.HttpWebRequest.UserAgent%2A> właściwości.  
  
 [!code-cpp[HttpWebRequest_UserAgent#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CPP/httpwebrequest_useragent.cpp#1)]
 [!code-csharp[HttpWebRequest_UserAgent#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CS/httpwebrequest_useragent.cs#1)]
 [!code-vb[HttpWebRequest_UserAgent#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_UserAgent/VB/httpwebrequest_useragent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
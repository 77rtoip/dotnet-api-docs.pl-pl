<Type Name="HttpListener" FullName="System.Net.HttpListener">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d840bbfb4a4e8c7a4ed7c9f79ccb004a20508643" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69091089" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpListener : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpListener extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpListener" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpListener&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpListener sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type HttpListener = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.HttpListener</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Zapewnia prosty, programowo sterowany odbiornik protokołu HTTP. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystając z <xref:System.Net.HttpListener> klasy, można utworzyć prosty odbiornik protokołu HTTP, który odpowiada na żądania HTTP. Odbiornik jest aktywny przez okres istnienia <xref:System.Net.HttpListener> obiektu i działa w aplikacji z uprawnieniami.
   
 Aby użyć <xref:System.Net.HttpListener>, Utwórz nowe wystąpienie klasy <xref:System.Net.HttpListener> przy użyciu konstruktora i Użyj <xref:System.Net.HttpListener.Prefixes%2A> właściwości, aby uzyskać dostęp do kolekcji zawierającej ciągi określające, które Uniform Resource Identifier (URI) prefiks <xref:System.Net.HttpListener>powinien być przetwarzany.
  
 Ciąg prefiksu identyfikatora URI składa się ze schematu (http lub https), hosta, opcjonalnego portu i opcjonalnej ścieżki. Przykładem kompletnego ciągu prefiksu jest *http://www.contoso.com:8080/customerData/*. Prefiksy muszą kończyć się ukośnikiem ("/"). <xref:System.Net.HttpListener> Obiekt z prefiksem, który najlepiej pasuje do żądanego identyfikatora URI odpowiada na żądanie. Wiele <xref:System.Net.HttpListener> obiektów nie może dodać tego samego prefiksu <xref:System.ComponentModel.Win32Exception> ; <xref:System.Net.HttpListener> wyjątek jest zgłaszany w przypadku dodania prefiksu, który jest już używany.
  
 Gdy port jest określony, element hosta można zastąpić "\*", aby wskazać <xref:System.Net.HttpListener> , że akceptowane żądania wysyłane do portu, jeśli żądany identyfikator URI nie jest zgodny z żadnym innym prefiksem. Na przykład, aby otrzymywać wszystkie żądania wysyłane do portu 8080, gdy żądany identyfikator URI nie jest obsługiwany przez <xref:System.Net.HttpListener>żaden, prefiks jest *http://\*: 8080/*. Analogicznie, aby określić, <xref:System.Net.HttpListener> że akceptowane są wszystkie żądania wysyłane do portu, Zastąp element hosta znakiem "+". Na przykład *https://+:8080*. Znaki "\*" i "+" mogą występować w prefiksach, które zawierają ścieżki.
  
 Począwszy od platformy .NET Core 2,0 lub .NET Framework 4,6 w systemie Windows 10, symbole wieloznaczne są obsługiwane w prefiksach URI, które są zarządzane <xref:System.Net.HttpListener> przez obiekt. Aby określić poddomenę z symbolami wieloznacznymi, użyj znaku "\*" jako części nazwy hosta w prefiksie identyfikatora URI. Na przykład *\*http://. foo.com/*. Przekaż jako argument do <xref:System.Net.HttpListenerPrefixCollection.Add%2A> metody. Działa to w przypadku platformy .NET Core 2,0 lub .NET Framework 4,6 w systemie Windows 10. w poprzednich wersjach spowoduje to wygenerowanie <xref:System.Net.HttpListenerException>.

 > [!WARNING]
 > **Nie** należy używać powiązań z symbolami wieloznacznymi najwyższego poziomu (*http://\*: 8080/* i *http://+:8080*). Powiązania najwyższego poziomu symboli wieloznacznych otworzyć aplikację w celu luk w zabezpieczeniach. Dotyczy to silnych i słabych symboli wieloznacznych. Użyj nazwy hostów jawne, a nie symboli wieloznacznych. Powiązanie symbol wieloznaczny domeny podrzędnej (na przykład `*.mysub.com`) nie ma to zagrożenie bezpieczeństwa, jeśli możesz kontrolować domenę nadrzędną całego (w przeciwieństwie do `*.com`, który jest narażony). Zobacz [rfc7230 sekcji-5.4](https://tools.ietf.org/html/rfc7230#section-5.4) Aby uzyskać więcej informacji.
  
 Aby rozpocząć nasłuchiwanie żądań od klientów, Dodaj prefiksy URI do kolekcji i Wywołaj <xref:System.Net.HttpListener.Start%2A> metodę. <xref:System.Net.HttpListener>oferuje modele synchroniczne i asynchroniczne do przetwarzania żądań klientów. Do żądań i skojarzonych z nimi odpowiedzi uzyskuje <xref:System.Net.HttpListenerContext> się dostęp przy użyciu <xref:System.Net.HttpListener.GetContext%2A> obiektu zwróconego przez metodę lub jego odpowiedników <xref:System.Net.HttpListener.EndGetContext%2A> <xref:System.Net.HttpListener.BeginGetContext%2A> asynchronicznych, metod i.
  
 Model synchroniczny jest odpowiedni, jeśli aplikacja powinna blokować się podczas oczekiwania na żądanie klienta i jeśli chcesz przetworzyć tylko jedno żądanie w danym momencie. Korzystając z modelu synchronicznego, wywołaj <xref:System.Net.HttpListener.GetContext%2A> metodę, która czeka na wysłanie żądania przez klienta. Metoda zwraca <xref:System.Net.HttpListenerContext> obiekt do przetworzenia, gdy wystąpi.
  
 W bardziej skomplikowanym modelu asynchronicznym aplikacja nie blokuje się podczas oczekiwania na żądania, a każde żądanie jest przetwarzane we własnym wątku wykonywania. Użyj metody <xref:System.Net.HttpListener.BeginGetContext%2A> , aby określić metodę zdefiniowaną przez aplikację do wywołania dla każdego żądania przychodzącego. W ramach tej metody Wywołaj <xref:System.Net.HttpListener.EndGetContext%2A> metodę, aby uzyskać żądanie, przetworzyć je i odpowiedzieć.
  
 W każdym modelu żądania przychodzące są uzyskiwane przy użyciu <xref:System.Net.HttpListenerContext.Request%2A?displayProperty=nameWithType> właściwości i są reprezentowane przez <xref:System.Net.HttpListenerRequest> obiekty. Podobnie dostęp do odpowiedzi odbywa się przy <xref:System.Net.HttpListenerContext.Response%2A?displayProperty=nameWithType> użyciu właściwości i są reprezentowane <xref:System.Net.HttpListenerResponse> przez obiekty. Te obiekty współużytkują niektóre funkcje <xref:System.Net.HttpWebRequest> z <xref:System.Net.HttpWebResponse> obiektami i, ale nie można używać tych obiektów w połączeniu z <xref:System.Net.HttpListener> programem, ponieważ implementują one klienta, a nie serwer, zachowania.
  
 <xref:System.Net.HttpListener> Może wymagać uwierzytelnienia klienta. Można określić konkretny schemat do użycia podczas uwierzytelniania lub określić delegata, który określa schemat do użycia. Aby uzyskać informacje o tożsamości klienta, należy wymagać pewnej formy uwierzytelniania. Aby uzyskać dodatkowe informacje, zobacz <xref:System.Net.HttpListenerContext.User%2A>właściwości <xref:System.Net.HttpListener.AuthenticationSchemes%2A>, i <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> .
  
> [!NOTE]
> Jeśli tworzysz <xref:System.Net.HttpListener> przy użyciu protokołu HTTPS, musisz wybrać certyfikat serwera dla tego odbiornika. W przeciwnym razie <xref:System.Net.HttpListener>zapytanienie powiedzie się z powodu nieoczekiwanego zamknięcia połączenia. <xref:System.Net.HttpWebRequest>
  
> [!NOTE]
> Można skonfigurować certyfikaty serwera i inne opcje odbiornika przy użyciu powłoki sieciowej (netsh. exe). Aby uzyskać więcej informacji, zobacz [powłoka sieciowa (netsh)](/windows-server/networking/technologies/netsh/netsh) . Plik wykonywalny rozpoczął wysyłkę z systemem Windows Server 2008 i Windows Vista.
  
> [!NOTE]
> W przypadku określenia wielu schematów uwierzytelniania dla programu <xref:System.Net.HttpListener>odbiornik będzie wzywać klientów w następującej kolejności: `Negotiate`, `NTLM`, `Digest`, a następnie `Basic`.
  
   
  
## Examples
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.HttpListener>.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
 [!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/8bf0b428-5a21-4299-8d6e-bf8251fd978a">Zmiany w uwierzytelnianiu NTLM dla HTTPWebRequest w wersji 3,5 SP1</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpListener ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpListener();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.HttpListener" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed użyciem wystąpienia zwróconego przez ten konstruktor należy wywołać jego <xref:System.Net.HttpListener.Start%2A> metodę.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.HttpListener> konstruktora do utworzenia nowego <xref:System.Net.HttpListener> obiektu. Pełny przykład można znaleźć w <xref:System.Net.HttpListener> temacie dotyczącym klas.  
  
 [!code-csharp[Net_listener_Basic#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#9)]  
 [!code-vb[Net_Listener_Basic#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Tej klasy nie można używać w bieżącym systemie operacyjnym. Aby można było używać wystąpień tej klasy, wymagany jest system Windows Server 2003 lub Windows XP z dodatkiem SP2.</exception>
        <block subset="none" type="usage"><para>Uwaga: Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="httpListener.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Natychmiast zamyka <see cref="T:System.Net.HttpListener" /> obiekt, odrzucając wszystkie żądania znajdujące się w kolejce.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda usuwa wszystkie zasoby przechowywane przez ten odbiornik. Nie można ukończyć wszystkich oczekujących żądań.  
  
 Po wywołaniu tej metody zostanie wyświetlony komunikat o <xref:System.ObjectDisposedException> próbie <xref:System.Net.HttpListener>użycia.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje wywołanie tej metody.  
  
 [!code-csharp[Net_Listener_Basic#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#11)]  
 [!code-vb[Net_Listener_Basic#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#11)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationSchemes">
      <MemberSignature Language="C#" Value="public System.Net.AuthenticationSchemes AuthenticationSchemes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.AuthenticationSchemes AuthenticationSchemes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.AuthenticationSchemes" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationSchemes As AuthenticationSchemes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::AuthenticationSchemes AuthenticationSchemes { System::Net::AuthenticationSchemes get(); void set(System::Net::AuthenticationSchemes value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationSchemes : System.Net.AuthenticationSchemes with get, set" Usage="System.Net.HttpListener.AuthenticationSchemes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.AuthenticationSchemes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia Schemat używany do uwierzytelniania klientów.</summary>
        <value>Bitowa kombinacja <see cref="T:System.Net.AuthenticationSchemes" /> wartości wyliczenia wskazująca sposób uwierzytelniania klientów. Wartość domyślna to <see cref="F:System.Net.AuthenticationSchemes.Anonymous" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Program <xref:System.Net.HttpListener> używa określonego schematu do uwierzytelniania wszystkich żądań przychodzących. Metody <xref:System.Net.HttpListener.GetContext%2A> <xref:System.Net.HttpListener> i <xref:System.Net.HttpListener.EndGetContext%2A> zwracają żądanie klienta przychodzącego tylko wtedy, gdy pomyślnie uwierzytelniają żądanie.  
  
 Można przejrzeć tożsamość pomyślnie uwierzytelnionego klienta przy użyciu <xref:System.Net.HttpListenerContext.User%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli chcesz <xref:System.Net.HttpListener> , aby obiekt korzystał z różnych mechanizmów uwierzytelniania na podstawie charakterystyki odbieranych żądań (na przykład <xref:System.Net.HttpListenerRequest.Url%2A> żądanie lub <xref:System.Net.HttpListenerRequest.UserHostName%2A> Właściwość), należy zaimplementować metodę, która wybiera schemat uwierzytelniania. Aby uzyskać instrukcje, jak to zrobić, zobacz <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> dokumentację właściwości.  
  
> [!NOTE]
>  Aby ustawić tę właściwość, aby włączyć szyfrowanie, NTLM lub Negotiate wymaga <xref:System.Security.Permissions.SecurityPermission>,. <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie właściwości, <xref:System.Net.HttpListener.AuthenticationSchemes%2A> aby określić schemat uwierzytelniania.  
  
 [!code-csharp[Net_listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
 [!code-vb[Net_Listener_Basic#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationSchemeSelectorDelegate">
      <MemberSignature Language="C#" Value="public System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationSchemeSelectorDelegate As AuthenticationSchemeSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::AuthenticationSchemeSelector ^ AuthenticationSchemeSelectorDelegate { System::Net::AuthenticationSchemeSelector ^ get(); void set(System::Net::AuthenticationSchemeSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationSchemeSelectorDelegate : System.Net.AuthenticationSchemeSelector with get, set" Usage="System.Net.HttpListener.AuthenticationSchemeSelectorDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.AuthenticationSchemeSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia delegata, aby określić protokół używany do uwierzytelniania klientów.</summary>
        <value><see cref="T:System.Net.AuthenticationSchemeSelector" /> Delegat, który wywołuje metodę użytą do wybrania protokołu uwierzytelniania. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Jeśli chcesz, aby ten sam protokół uwierzytelniania był używany dla wszystkich żądań obsłużonych przez określone wystąpienie <xref:System.Net.HttpListener>, nie musisz ustawiać tej właściwości. Aby określić protokół, który ma być używany dla wszystkich żądań klientów, użyj <xref:System.Net.HttpListener.AuthenticationSchemes%2A> właściwości.  
  
 Jeśli klient nie określił informacji o uwierzytelnianiu w jego nagłówkach, <xref:System.Net.HttpListener> wywołuje określonego delegata dla każdego nieuwierzytelnionego żądania przychodzącego, aby określić, który (Jeśli dowolny) protokół ma być używany do uwierzytelniania klienta. Metody <xref:System.Net.HttpListener.GetContext%2A> <xref:System.Net.HttpListener> i <xref:System.Net.HttpListener.EndGetContext%2A> zwracają żądanie przychodzące tylko wtedy, gdy pomyślnie uwierzytelniono żądanie. Jeśli żądanie nie może zostać uwierzytelnione, <xref:System.Net.HttpListener> automatycznie wysyła odpowiedź 401. Tożsamość uwierzytelnionego klienta można uzyskać przy użyciu <xref:System.Web.HttpRequest.LogonUserIdentity%2A?displayProperty=nameWithType> właściwości.  
  
 Możliwość delegowania wyboru protokołu uwierzytelniania do metody specyficznej dla aplikacji jest przydatna, jeśli chcesz, <xref:System.Net.HttpListener> aby wystąpienie używało różnych protokołów uwierzytelniania w zależności od charakterystyki odbieranych żądań (dla przykład, żądanie <xref:System.Net.HttpListenerRequest.Url%2A> lub <xref:System.Net.HttpListenerRequest.UserHostAddress%2A> Właściwość).  
  
> [!NOTE]
>  Aby ustawić tę właściwość, aby włączyć szyfrowanie, NTLM lub Negotiate wymaga <xref:System.Security.Permissions.SecurityPermission>,. <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal>  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia wartość tej właściwości.  
  
 [!code-csharp[NclListener#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#2)]
 [!code-vb[NclListener#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#2)]  
  
 Poniższy przykład kodu zawiera implementację metody wywoływanej przez <xref:System.Net.AuthenticationSchemeSelector> delegata.  
  
 [!code-csharp[NclListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#1)]
 [!code-vb[NclListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetContext">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginGetContext (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginGetContext(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginGetContext (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginGetContext(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginGetContext : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpListener.BeginGetContext (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegat, który odwołuje się do metody do wywołania, gdy żądanie klienta jest dostępne.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji. Ten obiekt jest przesyłany do <paramref name="callback" /> delegata po zakończeniu operacji.</param>
        <summary>Rozpoczyna asynchroniczne pobieranie żądania przychodzącego.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt, który wskazuje stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListener.BeginGetContext%2A> Metoda rozpoczyna asynchroniczne (bez blokowania) wywołanie do odbierania przychodzących żądań klientów. Przed wywołaniem tej metody należy wywołać <xref:System.Net.HttpListener.Start%2A> metodę i dodać co najmniej jeden prefiks Uniform Resource Identifier (URI) do nasłuchiwania przez dodanie ciągów identyfikatorów URI <xref:System.Net.HttpListenerPrefixCollection> do zwracanych przez <xref:System.Net.HttpListener.Prefixes%2A> właściwość.  
  
 Operacja asynchroniczna musi być zakończona przez wywołanie <xref:System.Net.HttpListener.EndGetContext%2A> metody. Zazwyczaj Metoda jest wywoływana przez `callback` delegata.  
  
 Ta metoda nie jest blokowana, gdy operacja zostanie ukończona. Aby uzyskać przychodzące żądanie i zablokować do momentu ukończenia operacji, wywołaj <xref:System.Net.HttpListener.GetContext%2A> metodę.  
  
 Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [wywoływanie metod synchronicznych asynchronicznie](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.HttpListener.BeginGetContext%2A> metody, aby określić metodę wywołania zwrotnego, która będzie obsługiwać przychodzące żądania klientów.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
 [!code-vb[Net_Listener_Basic#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#12)]  
  
 Poniższy przykład kodu implementuje metodę wywołania zwrotnego.  
  
 [!code-csharp[Net_Listener_Basic#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#13)]  
 [!code-vb[Net_Listener_Basic#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Wywołanie funkcji Win32 nie powiodło się. Sprawdź <see cref="P:System.Net.HttpListenerException.ErrorCode" /> Właściwość wyjątku, aby określić przyczynę wyjątku.</exception>
        <exception cref="T:System.InvalidOperationException">Ten obiekt nie został uruchomiony lub jest obecnie zatrzymany.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt jest zamknięty.</exception>
        <block subset="none" type="usage"><para>Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="httpListener.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka system <see cref="T:System.Net.HttpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu tej metody nie można już używać <xref:System.Net.HttpListener> obiektu. Aby tymczasowo wstrzymać <xref:System.Net.HttpListener> obiekt, <xref:System.Net.HttpListener.Stop%2A> Użyj metody.  
  
 Ta metoda zamyka <xref:System.Net.HttpListener> obiekt bez przetwarzania żądań umieszczonych w kolejce. Nie można ukończyć wszystkich oczekujących żądań.  
  
## Examples  

Poniższy przykład kodu demonstruje wywołanie `Close` metody:
  
[!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
[!code-vb[Net_Listener_Basic#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#12)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DefaultServiceNames">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.DefaultServiceNames" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultServiceNames As ServiceNameCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ServiceNameCollection ^ DefaultServiceNames { System::Security::Authentication::ExtendedProtection::ServiceNameCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultServiceNames : System.Security.Authentication.ExtendedProtection.ServiceNameCollection" Usage="System.Net.HttpListener.DefaultServiceNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ServiceNameCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślną listę nazw dostawców usług (SPN) zgodnie z zastrzeżonymi prefiksami.</summary>
        <value>A <see cref="T:System.Security.Authentication.ExtendedProtection.ServiceNameCollection" /> , który zawiera listę nazw SPN.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta <xref:System.Net.HttpListener.DefaultServiceNames%2A> właściwość jest używana w połączeniu ze zintegrowanym uwierzytelnianiem systemu Windows w celu zapewnienia ochrony rozszerzonej. Lista nazw SPN jest inicjowana z <xref:System.Net.HttpListener.Prefixes%2A> właściwości w przypadku uzyskiwania dostępu do właściwości i wyczyszczonych podczas dodawania do niej <xref:System.Net.HttpListener.Prefixes%2A> nowych prefiksów.  
  
 Ta <xref:System.Net.HttpListener.DefaultServiceNames%2A> właściwość jest używana, jeśli aplikacja nie <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames%2A> ustawi właściwości w ramach zasad ochrony rozszerzonej.  
  
 Pobierana <xref:System.Net.HttpListener.DefaultServiceNames%2A> z właściwością jest tworzona na podstawie właściwościzgodnieznastępującymiregułami:<xref:System.Net.HttpListener.Prefixes%2A> <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection>  
  
1.  Jeśli nazwa hosta to "+", "*" lub literał IPv4 lub IPv6 (odpowiednik "\*", ale jest ograniczony do określonego interfejsu lokalnego), dodawana jest następująca Nazwa SPN:  
  
 `"HTTP/"`oraz w pełni kwalifikowana nazwa domeny komputera.  
  
1.  Jeśli nazwa hosta nie zawiera kropek (brak domen lub poddomen), podejmowana jest próba rozpoznania w pełni kwalifikowanej nazwy domeny przy użyciu systemu DNS (takie samo zachowanie jest <xref:System.Net.HttpWebRequest>używane przez program). Jeśli można rozpoznać w pełni kwalifikowaną nazwę domeny, dodawane są następujące nazwy SPN:  
  
 `"HTTP/"`oraz nazwa hosta (krótka nazwa).  
  
 `"HTTP/"`oraz w pełni kwalifikowana nazwa domeny dla nazwy hosta.  
  
1.  Jeśli nazwa hosta nie zawiera kropek (domeny lub poddomeny) i nie można rozpoznać w pełni kwalifikowanej nazwy domeny, zostanie dodana następująca Nazwa SPN:  
  
 `"HTTP/"`Plus nazwa hosta.  
  
1.  Jeśli nazwa hosta zawiera kropki (domeny lub poddomeny), dodawana jest następująca Nazwa SPN:  
  
 `"HTTP/"`Plus nazwa hosta.  
  
 Ta <xref:System.Net.HttpListener.DefaultServiceNames%2A> właściwość może być używana przez aplikację do przeglądania listy domyślnych nazw SPN, które będą używane do uwierzytelniania, jeśli nie podano listy niestandardowej. Jeśli potrzebne są inne nazwy SPN, aplikacja może je dodać przy użyciu jednej z <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection.Merge%2A> metod.  
  
 Korzystanie z ochrony rozszerzonej w celu podejmowania decyzji dotyczących zasad na podstawie żądanego adresu URL nie jest bezpieczne, ponieważ może to być sfałszowane. Zamiast tego aplikacje powinny polegać na <xref:System.Net.HttpListenerRequest.LocalEndPoint%2A> właściwościach lub <xref:System.Net.HttpListenerRequest.RemoteEndPoint%2A> , aby podjąć takie decyzje dotyczące zasad.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Zintegrowane uwierzytelnianie systemu Windows z ochroną rozszerzoną</related>
      </Docs>
    </Member>
    <Member MemberName="EndGetContext">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerContext EndGetContext (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.HttpListenerContext EndGetContext(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.EndGetContext(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetContext (asyncResult As IAsyncResult) As HttpListenerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::HttpListenerContext ^ EndGetContext(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndGetContext : IAsyncResult -&gt; System.Net.HttpListenerContext" Usage="httpListener.EndGetContext asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> Obiekt, który został uzyskany podczas uruchamiania operacji asynchronicznej.</param>
        <summary>Kończy operację asynchroniczną w celu pobrania przychodzącego żądania klienta.</summary>
        <returns><see cref="T:System.Net.HttpListenerContext" /> Obiekt, który reprezentuje żądanie klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest wywoływana, zazwyczaj w ramach zdefiniowanej przez aplikację metody wywołania zwrotnego wywoływanej przez delegata, <xref:System.Net.HttpListenerContext> Aby uzyskać obiekt zawierający przychodzące żądanie klienta i skojarzoną z nim odpowiedź. <xref:System.Net.HttpListener.EndGetContext%2A> Ta metoda wykonuje operację wcześniej rozpoczętą przez wywołanie <xref:System.Net.HttpListener.BeginGetContext%2A> metody. Jeśli operacja nie została ukończona, ta metoda jest blokowana, dopóki nie zostanie wykonana.  
  
 Ponieważ wywołanie <xref:System.Net.HttpListener.EndGetContext%2A> metody <xref:System.Net.HttpListener> wymaga obiektu, ten obiekt jest zazwyczaj przesyłany do metody wywołania zwrotnego przy użyciu obiektu <xref:System.Net.HttpListener.BeginGetContext%2A> stanu przekazaną do metody. Ten obiekt stanu można uzyskać za pomocą <xref:System.IAsyncResult.AsyncState%2A> właściwości `asyncResult` obiektu.  
  
 Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [wywoływanie metod synchronicznych asynchronicznie](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje implementację metody wywołania zwrotnego, która wywołuje <xref:System.Net.HttpListener.EndGetContext%2A> metodę.  
  
 [!code-csharp[Net_Listener_Basic#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#13)]  
 [!code-vb[Net_Listener_Basic#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />nie został uzyskany przez wywołanie <see cref="M:System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.HttpListenerException">Wywołanie funkcji Win32 nie powiodło się. Sprawdź <see cref="P:System.Net.HttpListenerException.ErrorCode" /> Właściwość wyjątku, aby określić przyczynę wyjątku.</exception>
        <exception cref="T:System.InvalidOperationException">Metoda została już wywołana dla określonego <paramref name="asyncResult" /> obiektu. <see cref="M:System.Net.HttpListener.EndGetContext(System.IAsyncResult)" /></exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt jest zamknięty.</exception>
        <block subset="none" type="usage"><para>Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProtectionPolicy">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property ExtendedProtectionPolicy As ExtendedProtectionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ ExtendedProtectionPolicy { System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ get(); void set(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProtectionPolicy : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy with get, set" Usage="System.Net.HttpListener.ExtendedProtectionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("not used anywhere in the implementation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> do użycia w celu przedłużonej ochrony sesji.</summary>
        <value>A <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> określa zasady, które mają być używane do ochrony rozszerzonej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> właściwość jest używana w połączeniu ze zintegrowanym uwierzytelnianiem systemu Windows w celu zapewnienia ochrony rozszerzonej. Właściwość umożliwia konfigurację zasad ochrony rozszerzonej dla całej <xref:System.Net.HttpListener> sesji. <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A> Właściwość umożliwia konfigurację zasad ochrony rozszerzonej dla każdego żądania.  
  
 Właściwość <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> musi mieć `null`wartość. <xref:System.Net.HttpListener> Wystąpienie pobiera token powiązania kanału (CBT) bezpośrednio z własnej sesji TLS, jeśli istnieje.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Podjęto próbę ustawienia <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" /> właściwości, <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> ale właściwość nie <see langword="null" />została.</exception>
        <exception cref="T:System.ArgumentNullException">Podjęto próbę ustawienia <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" /> właściwości na <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę ustawienia <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" /> właściwości <see cref="M:System.Net.HttpListener.Start" /> po wywołaniu metody.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt jest zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement" /> Właściwość została <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> ustawiona na na platformie, która nie obsługuje rozszerzonej ochrony.</exception>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Zintegrowane uwierzytelnianie systemu Windows z ochroną rozszerzoną</related>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProtectionSelectorDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpListener.ExtendedProtectionSelector ExtendedProtectionSelectorDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListener/ExtendedProtectionSelector ExtendedProtectionSelectorDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ExtendedProtectionSelectorDelegate As HttpListener.ExtendedProtectionSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListener::ExtendedProtectionSelector ^ ExtendedProtectionSelectorDelegate { System::Net::HttpListener::ExtendedProtectionSelector ^ get(); void set(System::Net::HttpListener::ExtendedProtectionSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProtectionSelectorDelegate : System.Net.HttpListener.ExtendedProtectionSelector with get, set" Usage="System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpListener+ExtendedProtectionSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt delegowany, aby określić <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> , który ma być używany dla każdego żądania.</summary>
        <value>A <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> określa zasady, które mają być używane do ochrony rozszerzonej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> właściwość jest używana w połączeniu ze zintegrowanym uwierzytelnianiem systemu Windows w celu zapewnienia ochrony rozszerzonej. Właściwość umożliwia konfigurację zasad ochrony rozszerzonej dla całej <xref:System.Net.HttpListener> sesji. <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A> Właściwość umożliwia konfigurację zasad ochrony rozszerzonej na poszczególne żądania.  
  
 Właściwość <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> musi mieć `null`wartość. <xref:System.Net.HttpListener> Wystąpienie pobiera token powiązania kanału (CBT) bezpośrednio z własnej sesji TLS, jeśli istnieje.  
  
 Dla każdego żądania delegat może wybrać ustawienia, które będą używane przez <xref:System.Net.HttpListener> wystąpienie w celu zapewnienia rozszerzonej ochrony.  
  
 Jeśli delegat zwraca `null` dla tej właściwości, <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy> reprezentuje <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> Właściwość ustawioną na <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Podjęto próbę ustawienia <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> właściwości, <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> ale właściwość musi być <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Podjęto próbę ustawienia <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> właściwości na <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę ustawienia <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> właściwości <see cref="M:System.Net.HttpListener.Start" /> po wywołaniu metody.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt jest zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Podjęto próbę ustawienia <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> właściwości na platformie, która nie obsługuje ochrony rozszerzonej.</exception>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Zintegrowane uwierzytelnianie systemu Windows z ochroną rozszerzoną</related>
      </Docs>
    </Member>
    <Member MemberName="GetContext">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerContext GetContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.HttpListenerContext GetContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.GetContext" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContext () As HttpListenerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::HttpListenerContext ^ GetContext();" />
      <MemberSignature Language="F#" Value="member this.GetContext : unit -&gt; System.Net.HttpListenerContext" Usage="httpListener.GetContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czeka na żądanie przychodzące i zwraca po odebraniu.</summary>
        <returns><see cref="T:System.Net.HttpListenerContext" /> Obiekt, który reprezentuje żądanie klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed wywołaniem tej metody należy wywołać <xref:System.Net.HttpListener.Start%2A> metodę i dodać co najmniej jeden prefiks identyfikatora URI, aby nasłuchiwać przez dodanie ciągów identyfikatorów URI <xref:System.Net.HttpListenerPrefixCollection> do zwracanych przez <xref:System.Net.HttpListener.Prefixes%2A> właściwość. Aby uzyskać szczegółowy opis prefiksów, zobacz <xref:System.Net.HttpListener> Omówienie klasy.  
  
 Ta metoda jest blokowana podczas oczekiwania na żądanie przychodzące. Jeśli chcesz, aby żądania przychodzące były przetwarzane asynchronicznie (w oddzielnych wątkach), aby aplikacja nie blokowała, użyj <xref:System.Net.HttpListener.BeginGetContext%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje wywołanie tej metody.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
 [!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Wywołanie funkcji Win32 nie powiodło się. Sprawdź <see cref="P:System.Net.HttpListenerException.ErrorCode" /> Właściwość wyjątku, aby określić przyczynę wyjątku.</exception>
        <exception cref="T:System.InvalidOperationException">Ten obiekt nie został uruchomiony lub jest obecnie zatrzymany.  
  
—lub— 
<see cref="T:System.Net.HttpListener" /> Nie ma żadnych prefiksów Uniform Resource Identifier (URI), na które należy odpowiedzieć.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt jest zamknięty.</exception>
        <block subset="none" type="usage"><para>Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetContextAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt; GetContextAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.HttpListenerContext&gt; GetContextAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.GetContextAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContextAsync () As Task(Of HttpListenerContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::HttpListenerContext ^&gt; ^ GetContextAsync();" />
      <MemberSignature Language="F#" Value="member this.GetContextAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt;" Usage="httpListener.GetContextAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czeka na żądanie przychodzące jako operację asynchroniczną.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną. Właściwość obiektu Task <see cref="T:System.Net.HttpListenerContext" /> zwraca obiekt, który reprezentuje żądanie klienta. <see cref="P:System.Threading.Tasks.Task`1.Result" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja nie będzie blokować. Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odebraniu żądania przychodzącego.  
  
 Przed wywołaniem tej metody należy wywołać <xref:System.Net.HttpListener.Start%2A> metodę i dodać co najmniej jeden prefiks identyfikatora URI, aby nasłuchiwać przez dodanie ciągów identyfikatorów URI <xref:System.Net.HttpListenerPrefixCollection> do zwracanych przez <xref:System.Net.HttpListener.Prefixes%2A> właściwość. Aby uzyskać szczegółowy opis prefiksów, zobacz <xref:System.Net.HttpListener> Omówienie klasy.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListenerContext" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreWriteExceptions">
      <MemberSignature Language="C#" Value="public bool IgnoreWriteExceptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreWriteExceptions" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IgnoreWriteExceptions" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreWriteExceptions As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreWriteExceptions { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreWriteExceptions : bool with get, set" Usage="System.Net.HttpListener.IgnoreWriteExceptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określającą, czy aplikacja otrzymuje Wyjątki występujące <see cref="T:System.Net.HttpListener" /> podczas wysyłania odpowiedzi do klienta.</summary>
        <value><see langword="true" />Jeśli nie <see cref="T:System.Net.HttpListener" /> powinno to zwracać wyjątków występujących podczas wysyłania odpowiedzi do klienta; <see langword="false" />w przeciwnym razie. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw tę właściwość na `true` , jeśli aplikacja nie wymaga, aby odpowiedź została pomyślnie wysłana do każdego klienta.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje ustawienie tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
 [!code-vb[Net_Listener_Basic#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsListening">
      <MemberSignature Language="C#" Value="public bool IsListening { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsListening" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IsListening" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsListening As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsListening { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsListening : bool" Usage="System.Net.HttpListener.IsListening" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Net.HttpListener" /> została uruchomiona.</summary>
        <value><see langword="true" />Jeśli zostało uruchomione; w przeciwnym razie <see langword="false" />,. <see cref="T:System.Net.HttpListener" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby rozpocząć <xref:System.Net.HttpListener>, <xref:System.Net.HttpListener.Start%2A> Wywołaj metodę.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tej właściwości w celu określenia stanu nasłuchiwania wystąpienia.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
 [!code-vb[Net_Listener_Basic#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSupported">
      <MemberSignature Language="C#" Value="public static bool IsSupported { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsSupported" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IsSupported" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsSupported As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsSupported { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSupported : bool" Usage="System.Net.HttpListener.IsSupported" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Net.HttpListener" /> mogą być używane z bieżącym systemem operacyjnym.</summary>
        <value><see langword="true" />Jeśli <see cref="T:System.Net.HttpListener" /> jest obsługiwana; <see langword="false" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa jest dostępna tylko na komputerach z systemem operacyjnym Windows XP z dodatkiem SP2 lub Windows Server 2003.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.HttpListener.IsSupported%2A> właściwości w celu wykrycia, <xref:System.Net.HttpListener> czy obiekt może być używany z bieżącym systemem operacyjnym.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
 [!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixes">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerPrefixCollection Prefixes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListenerPrefixCollection Prefixes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.Prefixes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Prefixes As HttpListenerPrefixCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListenerPrefixCollection ^ Prefixes { System::Net::HttpListenerPrefixCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Prefixes : System.Net.HttpListenerPrefixCollection" Usage="System.Net.HttpListener.Prefixes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerPrefixCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera prefiksy Uniform Resource Identifier (URI) obsługiwane przez ten <see cref="T:System.Net.HttpListener" /> obiekt.</summary>
        <value>Zawiera prefiksy URI, które są skonfigurowane do <see cref="T:System.Net.HttpListener" /> obsługi tego obiektu. <see cref="T:System.Net.HttpListenerPrefixCollection" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prefiksy są w postaci kanonicznej. Aby uzyskać szczegółowy opis prefiksów, zobacz <xref:System.Net.HttpListener> Omówienie klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.HttpListener.Prefixes%2A> właściwości w celu uzyskania i wydrukowania prefiksów URI, które są obsługiwane.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
 [!code-vb[Net_Listener_Basic#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Realm">
      <MemberSignature Language="C#" Value="public string Realm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Realm" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.Realm" />
      <MemberSignature Language="VB.NET" Value="Public Property Realm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Realm { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Realm : string with get, set" Usage="System.Net.HttpListener.Realm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obszar lub partycję zasobów skojarzoną z tym <see cref="T:System.Net.HttpListener" /> obiektem.</summary>
        <value>Wartość, która zawiera nazwę obszaru skojarzonego <see cref="T:System.Net.HttpListener" /> z obiektem. <see cref="T:System.String" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Serwery używają obszarów do partycjonowania chronionych zasobów; Każda partycja może mieć własny schemat uwierzytelniania i/lub bazę danych autoryzacji. Obszary są używane tylko do uwierzytelniania podstawowego i szyfrowanego. Po pomyślnym uwierzytelnieniu klienta uwierzytelnianie jest prawidłowe dla wszystkich zasobów w danym obszarze. Aby uzyskać szczegółowy opis obszarów, zobacz RFC 2617 o [https://www.ietf.org/](https://www.ietf.org/).  
  
 Wystąpienie <xref:System.Net.HttpListener> ma tylko jeden skojarzony obszar.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje ustawienie <xref:System.Net.HttpListener.Realm%2A> właściwości.  
  
 [!code-csharp[Net_Listener_Basic#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#10)]  
 [!code-vb[Net_Listener_Basic#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="httpListener.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zezwala temu wystąpieniu na odbieranie żądań przychodzących.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda musi być wywoływana przed wywołaniem <xref:System.Net.HttpListener.GetContext%2A> metody lub. <xref:System.Net.HttpListener.BeginGetContext%2A>  
  
 Po rozpoczęciu <xref:System.Net.HttpListener> obiektu można go zatrzymać za <xref:System.Net.HttpListener.Stop%2A> pomocą metody.  
  
> [!NOTE]
>  Jeśli to wystąpienie odbiornika korzysta z protokołu HTTPS, należy zainstalować i wybrać certyfikat serwera. W przeciwnym razie <xref:System.Net.HttpListener>zapytanienie powiedzie się z powodu nieoczekiwanego zamknięcia połączenia. <xref:System.Net.HttpWebRequest> Można skonfigurować certyfikaty serwera i inne opcje odbiornika przy użyciu programu HttpCfg. exe. Aby [http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp](https://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp) uzyskać więcej informacji, zobacz.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.HttpListener.Start%2A> metody do rozpoczęcia przetwarzania żądań przychodzących.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
 [!code-vb[Net_Listener_Basic#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Wywołanie funkcji Win32 nie powiodło się. Sprawdź <see cref="P:System.Net.HttpListenerException.ErrorCode" /> Właściwość wyjątku, aby określić przyczynę wyjątku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt jest zamknięty.</exception>
        <block subset="none" type="usage"><para>Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="httpListener.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że to wystąpienie przestanie odbierać żądania przychodzące.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli to wystąpienie jest już zatrzymane, wywołanie tej metody nie ma żadnego wpływu.  
  
 Po zatrzymaniu <xref:System.Net.HttpListener> obiektu można <xref:System.Net.HttpListener.Start%2A> użyć metody, aby uruchomić ją ponownie.  
  
   
  
## Examples  
 
Poniższy przykład kodu demonstruje użycie <xref:System.Net.HttpListener.Stop%2A> metody do zatrzymania przetwarzania żądań przychodzących.  
 
[!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
[!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <block subset="none" type="usage"><para>Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby przechowywane przez ten <see cref="T:System.Net.HttpListener" /> obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacje powinny używać <xref:System.Net.HttpListener.Close%2A> metody zamiast wywołania tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimeoutManager">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerTimeoutManager TimeoutManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListenerTimeoutManager TimeoutManager" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.TimeoutManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimeoutManager As HttpListenerTimeoutManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListenerTimeoutManager ^ TimeoutManager { System::Net::HttpListenerTimeoutManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TimeoutManager : System.Net.HttpListenerTimeoutManager" Usage="System.Net.HttpListener.TimeoutManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerTimeoutManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Menedżer limitu czasu dla tego <see cref="T:System.Net.HttpListener" /> wystąpienia.</summary>
        <value>Menedżer limitu czasu dla tego <see cref="T:System.Net.HttpListener" /> wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Menedżer limitu czasu definiuje limity limitu czasu połączenia dla tego <xref:System.Net.HttpListener> wystąpienia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeConnectionNtlmAuthentication">
      <MemberSignature Language="C#" Value="public bool UnsafeConnectionNtlmAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeConnectionNtlmAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.UnsafeConnectionNtlmAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeConnectionNtlmAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeConnectionNtlmAuthentication { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeConnectionNtlmAuthentication : bool with get, set" Usage="System.Net.HttpListener.UnsafeConnectionNtlmAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Support for NTLM needs some loving.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określającą, czy w przypadku użycia protokołu NTLM do uwierzytelniania wymagane są dodatkowe żądania korzystające z tego samego połączenia Transmission Control Protocol (TCP).</summary>
        <value><see langword="true" />Jeśli pierwsze żądanie będzie używane dla kolejnych żądań w ramach tego samego połączenia, <see langword="false" />w przeciwnym razie. <see cref="T:System.Security.Principal.IIdentity" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta właściwość jest ustawiona na `true` , a pierwsze żądanie za pośrednictwem określonego połączenia TCP jest uwierzytelniane przy użyciu protokołu NTLM, kolejne żądania przez to samo połączenie TCP są przetwarzane przy<xref:System.Security.Principal.IIdentity>użyciu informacji o uwierzytelnianiu () początkowego żądając.  
  
 Ta właściwość nie ma wpływu, gdy uwierzytelnianie NTLM nie jest protokołem uwierzytelniania. Gdy negocjowane jest określenie protokołu uwierzytelniania, ta właściwość ma wpływ tylko wtedy, gdy protokół NTLM jest rzeczywistym protokołem używanym do uwierzytelniania.  
  
> [!NOTE]
>  Podczas ustawiania tej właściwości w `true` celu zwiększenia wydajności, <xref:System.Net.HttpListener> ponieważ nie wysyła dodatkowych wyzwań związanych z uwierzytelnianiem NTLM, istnieje ryzyko związane z bezpieczeństwem, które nie wymaga podania informacji o uwierzytelnianiu. Należy określić, czy zwiększenie wydajności jest cennym zagrożeniem.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje ustawienie tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
 [!code-vb[Net_Listener_Basic#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
  </Members>
</Type>

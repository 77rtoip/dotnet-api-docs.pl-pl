<Type Name="HttpListener" FullName="System.Net.HttpListener">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0e02270f5e712436e72d273e8fd86520bf841422" /><Meta Name="ms.sourcegitcommit" Value="a47b87b664d20090dc34412ab430dec69af9c3f8" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="01/04/2019" /><Meta Name="ms.locfileid" Value="54030711" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpListener : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpListener extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpListener" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpListener&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpListener sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type HttpListener = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.HttpListener</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Zapewnia prostą, programowo kontrolowanego odbiornika protokołu HTTP. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą <xref:System.Net.HttpListener> klasy, można utworzyć proste odbiornika protokołu HTTP, który odpowiada na żądania HTTP. Odbiornik jest aktywna przez okres istnienia <xref:System.Net.HttpListener> obiektu i jest uruchamiana w ramach aplikacji za pomocą jego uprawnień.
   
 Aby użyć <xref:System.Net.HttpListener>, Utwórz nowe wystąpienie klasy za pomocą <xref:System.Net.HttpListener> Konstruktor i użyj <xref:System.Net.HttpListener.Prefixes%2A> właściwości w celu uzyskania dostępu do kolekcji, która zawiera ciągi, które określają, które identyfikator (URI) prefiksy <xref:System.Net.HttpListener>należy przetworzyć.
  
 Schemat (http lub https), hosta, opcjonalnego portu oraz opcjonalna ścieżka składa się z ciągu prefiks identyfikatora URI. Na przykład ciąg prefiksu pełną *http://www.contoso.com:8080/customerData/*. Prefiksy muszą kończyć się ukośnikiem ("/"). <xref:System.Net.HttpListener> Obiektu o prefiks, który najlepiej pasuje do żądanego identyfikatora URI odpowie na żądanie. Wiele <xref:System.Net.HttpListener> obiektów nie można dodać ten sam prefiks; <xref:System.ComponentModel.Win32Exception> wyjątek jest generowany, jeśli <xref:System.Net.HttpListener> dodaje prefiks, który jest już używać.
  
 Jeśli nie określono portu, element hosta można zastąpić wartością "\*" z informacją, że <xref:System.Net.HttpListener> akceptuje żądania wysyłane do portu żądanego identyfikatora URI jest niezgodny z innymi prefiks. Na przykład otrzymywać wszystkie żądania wysyłane do portu 8080, kiedy żądanego identyfikatora URI nie jest obsługiwany przez żaden <xref:System.Net.HttpListener>, prefiks jest *http://\*: 8080 /*. Podobnie Aby określić, że <xref:System.Net.HttpListener> akceptuje wszystkie żądania wysyłane do portu, Zastąp element hosta ze znakiem "+". Na przykład *https://+:8080*. "\*" I "+" znaki mogą być obecne w prefiksy, które zawierają ścieżki.
  
 Począwszy od programu .NET Core 2.0 lub .NET Framework 4.6 w systemie Windows 10, poddomen symboli wieloznacznych są obsługiwane w prefiksów identyfikatorów URI, które są zarządzane przez <xref:System.Net.HttpListener> obiektu. Aby określić poddomeny symboli wieloznacznych, należy użyć "\*" znak jako część nazwy hosta w prefiks identyfikatora URI. Na przykład *http://\*.foo.com/*. Przekazać go jako argument <xref:System.Net.HttpListenerPrefixCollection.Add%2A> metody. To działa, począwszy od programu .NET Core 2.0 lub .NET Framework 4.6 w systemie Windows 10; we wcześniejszych wersjach, spowoduje to wygenerowanie <xref:System.Net.HttpListenerException>.

 > [!WARNING]
 > Powiązania najwyższego poziomu symbolu wieloznacznego (*http://\*: 8080 /* i *http://+:8080*) powinien **nie** można użyć. Powiązania najwyższego poziomu symboli wieloznacznych otworzyć aplikację w celu luk w zabezpieczeniach. Dotyczy to silnych i słabych symboli wieloznacznych. Użyj nazwy hostów jawne, a nie symboli wieloznacznych. Powiązanie symbol wieloznaczny domeny podrzędnej (na przykład `*.mysub.com`) nie ma to zagrożenie bezpieczeństwa, jeśli możesz kontrolować domenę nadrzędną całego (w przeciwieństwie do `*.com`, który jest narażony). Zobacz [rfc7230 sekcji-5.4](https://tools.ietf.org/html/rfc7230#section-5.4) Aby uzyskać więcej informacji.
  
 Aby rozpocząć, nasłuchiwać żądań od klientów, Dodaj prefiksy identyfikatora URI do kolekcji i wywołania <xref:System.Net.HttpListener.Start%2A> metody. <xref:System.Net.HttpListener> oferuje synchroniczne i asynchroniczne modeli do przetwarzania żądań klientów. Żądania i ich skojarzone odpowiedzi są dostępne przy użyciu <xref:System.Net.HttpListenerContext> obiektu zwróconego przez <xref:System.Net.HttpListener.GetContext%2A> metody lub jego odpowiedników asynchronicznego, <xref:System.Net.HttpListener.BeginGetContext%2A> i <xref:System.Net.HttpListener.EndGetContext%2A> metody.
  
 Synchroniczne model jest odpowiednie, czy aplikacja powinna blokować podczas oczekiwania na żądanie klienta oraz czy ma być przetwarzana tylko jedno żądanie w danym momencie. Przy użyciu modelu synchroniczne, wywołaj <xref:System.Net.HttpListener.GetContext%2A> metody, która czeka na klienta wysłać żądanie. Metoda ta zwraca <xref:System.Net.HttpListenerContext> obiekt dla przetwarzania, gdy dla jednego wystąpienia.
  
 W bardziej złożonych model asynchronicznego aplikacji nie są blokowane podczas oczekiwania na żądania i każdego żądania są przetwarzane w jego własnym wątku wykonywania. Użyj <xref:System.Net.HttpListener.BeginGetContext%2A> metodę, aby określić metodę zdefiniowanych przez aplikację, będzie wywoływana dla każdego żądania przychodzącego. W ramach tej metody należy wywołać <xref:System.Net.HttpListener.EndGetContext%2A> metodę, aby uzyskać żądania, przetwarzanie i reagować.
  
 W obu modelu żądania przychodzące są dostępne przy użyciu <xref:System.Net.HttpListenerContext.Request%2A?displayProperty=nameWithType> właściwości i są reprezentowane przez <xref:System.Net.HttpListenerRequest> obiektów. Podobnie, odpowiedzi są dostępne przy użyciu <xref:System.Net.HttpListenerContext.Response%2A?displayProperty=nameWithType> właściwości i są reprezentowane przez <xref:System.Net.HttpListenerResponse> obiektów. Te obiekty współużytkują pewne funkcje za pomocą <xref:System.Net.HttpWebRequest> i <xref:System.Net.HttpWebResponse> obiektów, ale jego obiektów nie można używać w połączeniu z <xref:System.Net.HttpListener> ponieważ implementują klienta, a nie serwera, zachowań.
  
 <xref:System.Net.HttpListener> Może być wymagane uwierzytelnienie klienta. Można określić określonego schematu na potrzeby uwierzytelniania lub można określić obiekt delegowany, który określa schemat do użycia. Może wymagać jakąś formę uwierzytelniania, aby uzyskać informacje o tożsamości klienta. Aby uzyskać więcej informacji, zobacz <xref:System.Net.HttpListenerContext.User%2A>, <xref:System.Net.HttpListener.AuthenticationSchemes%2A>, i <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> właściwości.
  
> [!NOTE]
> Jeśli tworzysz <xref:System.Net.HttpListener> przy użyciu protokołu https, należy wybrać certyfikat serwera dla tego odbiornika. W przeciwnym razie <xref:System.Net.HttpWebRequest> zapytania to <xref:System.Net.HttpListener> zakończy się niepowodzeniem z nieoczekiwane zamknięcie połączenia.
  
> [!NOTE]
> Za pomocą powłoki sieciowej (netsh.exe) można skonfigurować certyfikaty serwera oraz inne opcje odbiornika. Zobacz [powłoki sieciowej (Netsh)](/windows-server/networking/technologies/netsh/netsh) Aby uzyskać więcej informacji. Plik wykonywalny rozpoczęcia wysyłania za pomocą systemu Windows Server 2008 i Windows Vista.
  
> [!NOTE]
> W przypadku określenia wielu schematów uwierzytelniania dla <xref:System.Net.HttpListener>, odbiornik zażąda klientów w następującej kolejności: `Negotiate`, `NTLM`, `Digest`, a następnie `Basic`.
  
   
  
## Examples
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Net.HttpListener>.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/8bf0b428-5a21-4299-8d6e-bf8251fd978a">Zmiany w uwierzytelnianiu NTLM dla HTTPWebRequest w wersji 3.5 z dodatkiem SP1</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpListener ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpListener();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.HttpListener" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed użyciem wystąpienie zwrócone przez ten konstruktor, należy wywołać jej <xref:System.Net.HttpListener.Start%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Net.HttpListener> Konstruktor do tworzenia nowego <xref:System.Net.HttpListener> obiektu. Aby uzyskać kompletny przykład, zobacz <xref:System.Net.HttpListener> temat poświęcony klasie.  
  
 [!code-csharp[Net_listener_Basic#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Nie można użyć tej klasy w bieżącym systemie operacyjnym. Windows Server 2003 lub Windows XP z dodatkiem SP2 jest wymagana do użycia wystąpienia tej klasy.</exception>
        <block subset="none" type="usage"><para>Uwaga: Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="httpListener.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka <see cref="T:System.Net.HttpListener" /> natychmiast, obiektu, odrzucając wszystkie aktualnie w kolejce żądań.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda usuwa wszystkie zasoby zajmowane przez ten odbiornik. Nie można ukończyć są żadnych oczekujących żądań.  
  
 Po wywołaniu tej metody, zostanie wyświetlony <xref:System.ObjectDisposedException> Jeśli spróbujesz użyć tej funkcji <xref:System.Net.HttpListener>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje wywołanie tej metody.  
  
 [!code-csharp[Net_Listener_Basic#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#11)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationSchemes">
      <MemberSignature Language="C#" Value="public System.Net.AuthenticationSchemes AuthenticationSchemes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.AuthenticationSchemes AuthenticationSchemes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.AuthenticationSchemes" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationSchemes As AuthenticationSchemes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::AuthenticationSchemes AuthenticationSchemes { System::Net::AuthenticationSchemes get(); void set(System::Net::AuthenticationSchemes value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationSchemes : System.Net.AuthenticationSchemes with get, set" Usage="System.Net.HttpListener.AuthenticationSchemes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.AuthenticationSchemes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia Schemat używany do uwierzytelniania klientów.</summary>
        <value>Bitowa kombinacja <see cref="T:System.Net.AuthenticationSchemes" /> wartości wyliczenia wskazująca na to, jak klienci znajdują się w celu uwierzytelnienia. Wartość domyślna to <see cref="F:System.Net.AuthenticationSchemes.Anonymous" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListener> Korzysta określony schemat do uwierzytelniania wszystkich żądań przychodzących. <xref:System.Net.HttpListener.GetContext%2A> i <xref:System.Net.HttpListener.EndGetContext%2A> metody zwracają przychodzącego żądania klienta, tylko wtedy, gdy <xref:System.Net.HttpListener> pomyślnie uwierzytelnia żądanie.  
  
 Tożsamość pomyślnie uwierzytelniany klient może interrogate przy użyciu <xref:System.Net.HttpListenerContext.User%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli chcesz <xref:System.Net.HttpListener> obiekt ma być używany z różnych mechanizmów uwierzytelniania na podstawie charakterystyki żądań odbierze (na przykład żądania <xref:System.Net.HttpListenerRequest.Url%2A> lub <xref:System.Net.HttpListenerRequest.UserHostName%2A> właściwości), należy zaimplementować metodę, która wybiera schemat uwierzytelniania. Aby dowiedzieć się, jak to zrobić, zobacz <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> dokumentacji właściwości.  
  
> [!NOTE]
>  Aby ustawić tę właściwość, aby włączyć Digest, NTLM i Negotiate wymaga <xref:System.Security.Permissions.SecurityPermission>, <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Net.HttpListener.AuthenticationSchemes%2A> właściwości w celu określenia schematu uwierzytelniania.  
  
 [!code-csharp[Net_listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationSchemeSelectorDelegate">
      <MemberSignature Language="C#" Value="public System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationSchemeSelectorDelegate As AuthenticationSchemeSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::AuthenticationSchemeSelector ^ AuthenticationSchemeSelectorDelegate { System::Net::AuthenticationSchemeSelector ^ get(); void set(System::Net::AuthenticationSchemeSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationSchemeSelectorDelegate : System.Net.AuthenticationSchemeSelector with get, set" Usage="System.Net.HttpListener.AuthenticationSchemeSelectorDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.AuthenticationSchemeSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia delegata, wywoływana w celu określenia protokół używany do uwierzytelniania klientów.</summary>
        <value><see cref="T:System.Net.AuthenticationSchemeSelector" /> Delegat, który wywołuje metodę używaną do wybierania protokołu uwierzytelniania. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Jeśli chcesz, aby ten sam protokół uwierzytelniania do użycia dla wszystkich żądań obsługiwanych przez konkretne wystąpienie <xref:System.Net.HttpListener>, nie należy ustawić tę właściwość. Aby określić protokół do użycia dla wszystkich żądań klientów, należy użyć <xref:System.Net.HttpListener.AuthenticationSchemes%2A> właściwości.  
  
 Jeśli klient nie określił informacje dotyczące uwierzytelniania w jego nagłówkach <xref:System.Net.HttpListener> wywołuje określonego delegata dla każdego nieuwierzytelnione żądania przychodzącego określić, jeśli istnieje, protokołu używanego na potrzeby uwierzytelniania klienta. <xref:System.Net.HttpListener.GetContext%2A> i <xref:System.Net.HttpListener.EndGetContext%2A> metody zwracają przychodzące żądania tylko wtedy, gdy <xref:System.Net.HttpListener> pomyślnym uwierzytelnieniu żądanie. Jeśli nie można uwierzytelnić żądania, <xref:System.Net.HttpListener> automatycznie wyśle z powrotem odpowiedzi 401. Można uzyskać tożsamości klienta pomyślnie uwierzytelnione przy użyciu <xref:System.Web.HttpRequest.LogonUserIdentity%2A?displayProperty=nameWithType> właściwości.  
  
 Możliwość delegowania wybór protokołu uwierzytelniania metodą specyficzne dla aplikacji jest przydatne w przypadku wystąpienia <xref:System.Net.HttpListener> do różnych protokołów uwierzytelniania w zależności od charakterystyki żądań odbierze (w przypadku użycia przykład żądania <xref:System.Net.HttpListenerRequest.Url%2A> lub <xref:System.Net.HttpListenerRequest.UserHostAddress%2A> właściwości).  
  
> [!NOTE]
>  Aby ustawić tę właściwość, aby włączyć Digest, NTLM i Negotiate wymaga <xref:System.Security.Permissions.SecurityPermission>, <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal>.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia wartość tej właściwości.  
  
 [!code-csharp[NclListener#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#2)]
 [!code-vb[NclListener#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#2)]  
  
 W poniższym przykładzie kodu przedstawiono implementację metody wywoływane przez <xref:System.Net.AuthenticationSchemeSelector> delegować.  
  
 [!code-csharp[NclListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#1)]
 [!code-vb[NclListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetContext">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginGetContext (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginGetContext(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginGetContext (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginGetContext(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginGetContext : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpListener.BeginGetContext (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania, gdy żądanie klienta jest dostępny.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje na temat operacji. Ten obiekt jest przekazywany do <paramref name="callback" /> po zakończeniu operacji.</param>
        <summary>Rozpocznie się pobieranie asynchronicznie żądanie przychodzące.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt, który wskazuje stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListener.BeginGetContext%2A> Metoda rozpoczyna (bez blokowania) wywołanie asynchroniczne do odbierania przychodzących żądań klientów. Przed wywołaniem tej metody, należy wywołać <xref:System.Net.HttpListener.Start%2A> metody i Dodaj co najmniej jeden prefiks identyfikatora URI (Uniform Resource) do nasłuchiwania, dodając parametry identyfikatora URI do <xref:System.Net.HttpListenerPrefixCollection> zwrócone przez <xref:System.Net.HttpListener.Prefixes%2A> właściwości.  
  
 Operacja asynchroniczna musi wykonać wywołanie <xref:System.Net.HttpListener.EndGetContext%2A> metody. Zazwyczaj metoda jest wywoływana przez `callback` delegować.  
  
 Ta metoda nie są blokowane podczas kończenia operacji. Aby uzyskać przychodzących żądań i bloku do momentu ukończenia operacji, należy wywołać <xref:System.Net.HttpListener.GetContext%2A> metody.  
  
 Aby uzyskać szczegółowe informacje dotyczące korzystania z modelu programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Net.HttpListener.BeginGetContext%2A> metodę, aby określić metodę wywołania zwrotnego, która będzie obsługiwać przychodzące żądania klientów.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
  
 Poniższy przykładowy kod implementuje metodą wywołania zwrotnego.  
  
 [!code-csharp[Net_Listener_Basic#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Wywołanie funkcji Win32 nie powiodło się. Sprawdzanie wyjątku <see cref="P:System.Net.HttpListenerException.ErrorCode" /> właściwości, aby ustalić przyczynę wyjątku.</exception>
        <exception cref="T:System.InvalidOperationException">Ten obiekt nie została uruchomiona lub jest obecnie zatrzymana.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt jest zamknięty.</exception>
        <block subset="none" type="usage"><para>Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="httpListener.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka <see cref="T:System.Net.HttpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu tej metody, której już nie używasz <xref:System.Net.HttpListener> obiektu. Aby tymczasowo wstrzymać <xref:System.Net.HttpListener> obiektu, należy użyć <xref:System.Net.HttpListener.Stop%2A> metody.  
  
 Ta metoda zamykanie szczegółu <xref:System.Net.HttpListener> obiektu bez przetwarzania żądań w kolejce. Nie można ukończyć są żadnych oczekujących żądań.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje wywołanie tej metody.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DefaultServiceNames">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.DefaultServiceNames" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultServiceNames As ServiceNameCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ServiceNameCollection ^ DefaultServiceNames { System::Security::Authentication::ExtendedProtection::ServiceNameCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultServiceNames : System.Security.Authentication.ExtendedProtection.ServiceNameCollection" Usage="System.Net.HttpListener.DefaultServiceNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ServiceNameCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślną listę nazw dostawcy usługi (SPN), zgodnie z ustaleniami zarejestrowanych prefiksy.</summary>
        <value>Element <see cref="T:System.Security.Authentication.ExtendedProtection.ServiceNameCollection" /> zawierający listę nazw SPN.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListener.DefaultServiceNames%2A> Właściwość jest używana przy użyciu zintegrowanego uwierzytelniania Windows w celu zapewnienia ochrony rozszerzonej. Lista nazw SPN jest inicjowany z <xref:System.Net.HttpListener.Prefixes%2A> właściwości dostępne i wyczyszczone po dodaniu do nowego prefiksy <xref:System.Net.HttpListener.Prefixes%2A> właściwości.  
  
 <xref:System.Net.HttpListener.DefaultServiceNames%2A> Właściwość jest używana, jeśli aplikacja nie został ustawiony <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames%2A> właściwość jej zasady ochrony rozszerzonej.  
  
 <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection> Który jest pobierany za pomocą <xref:System.Net.HttpListener.DefaultServiceNames%2A> właściwość została stworzona od <xref:System.Net.HttpListener.Prefixes%2A> właściwości zgodnie z następującymi zasadami:  
  
1.  Jeśli nazwa hosta jest "+", "*", lub literału IPv4 lub IPv6 (odpowiednikiem "\*" ale jest ograniczony do określonego interfejsu lokalnego), następujące nazwy SPN zostanie dodany:  
  
 `"HTTP/"` Ponadto w pełni kwalifikowana nazwa domeny komputera.  
  
1.  Jeśli nazwa hosta nie zawiera kropek (nie domeny lub poddomeny), podejmowana jest próba rozpoznać w pełni kwalifikowana nazwa domeny przy użyciu systemu DNS (takie samo zachowanie, które są używane przez <xref:System.Net.HttpWebRequest>). Jeśli w pełni kwalifikowana nazwa domeny może być rozpoznana, zostaną dodane następujące nazwy SPN:  
  
 `"HTTP/"` Ponadto nazwa hosta (krótka nazwa).  
  
 `"HTTP/"` Ponadto w pełni kwalifikowana nazwa domeny dla nazwy hosta.  
  
1.  Jeśli w pełni kwalifikowaną nazwą domeny nie można rozpoznać nazwy hosta zawiera nie kropki (nie domeny lub poddomeny), następujące nazwy SPN zostanie dodana:  
  
 `"HTTP/"` Ponadto nazwa hosta.  
  
1.  Jeśli nazwa hosta zawiera kropki (domeny lub poddomeny), następujące nazwy SPN zostanie dodana:  
  
 `"HTTP/"` Ponadto nazwa hosta.  
  
 <xref:System.Net.HttpListener.DefaultServiceNames%2A> Właściwość może służyć przez aplikację, aby zapoznać się z nazwy SPN domyślnego, które będzie używany do uwierzytelniania, jeśli nie dostarczono żadnych listy niestandardowej. Jeśli potrzebne są inne nazwy SPN, aplikacja je dodać przy użyciu jednej z <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection.Merge%2A> metody.  
  
 Nie jest bezpieczne podczas korzystania z rozszerzonej ochrony w celu podejmowania decyzji dotyczących zasad w oparciu o żądany adres URL, ponieważ może to być sfałszowane. Przeciwnie, aplikacje będą miały <xref:System.Net.HttpListenerRequest.LocalEndPoint%2A> lub <xref:System.Net.HttpListenerRequest.RemoteEndPoint%2A> właściwości podjąć decyzje dotyczące tych zasad.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Windows zintegrowane uwierzytelnianie przy użyciu mechanizmu rozszerzonej ochrony</related>
      </Docs>
    </Member>
    <Member MemberName="EndGetContext">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerContext EndGetContext (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.HttpListenerContext EndGetContext(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.EndGetContext(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetContext (asyncResult As IAsyncResult) As HttpListenerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::HttpListenerContext ^ EndGetContext(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndGetContext : IAsyncResult -&gt; System.Net.HttpListenerContext" Usage="httpListener.EndGetContext asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> Obiekt, który uzyskano, gdy operacja asynchroniczna została uruchomiona.</param>
        <summary>Kończy operację asynchroniczną do pobrania przychodzącego żądania klienta.</summary>
        <returns><see cref="T:System.Net.HttpListenerContext" /> Obiekt reprezentujący żądanie klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListener.EndGetContext%2A> Wywoływana jest metoda, zazwyczaj zdefiniowanych przez aplikację metody wywołania zwrotnego wywoływana przez obiekt delegowany, aby uzyskać <xref:System.Net.HttpListenerContext> obiekt, który zawiera przychodzącego żądania klienta i jego skojarzone odpowiedzi. Ta metoda wykona operację wcześniej uruchomione przez wywołanie metody <xref:System.Net.HttpListener.BeginGetContext%2A> metody. Jeśli operacja nie została ukończona, ta metoda blokuje, dopóki nie robi.  
  
 Ponieważ wywołanie <xref:System.Net.HttpListener.EndGetContext%2A> metoda wymaga <xref:System.Net.HttpListener> obiektu, ten obiekt jest zwykle przekazywany do metody wywołania zwrotnego, za pomocą obiektu stanu do <xref:System.Net.HttpListener.BeginGetContext%2A> metody. Obiekt stanu można uzyskać za pomocą <xref:System.IAsyncResult.AsyncState%2A> właściwość `asyncResult` obiektu.  
  
 Aby uzyskać szczegółowe informacje dotyczące korzystania z modelu programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje implementację metody wywołania zwrotnego, która wywołuje <xref:System.Net.HttpListener.EndGetContext%2A> metody.  
  
 [!code-csharp[Net_Listener_Basic#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> nie uzyskano przez wywołanie metody <see cref="M:System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.HttpListenerException">Wywołanie funkcji Win32 nie powiodło się. Sprawdzanie wyjątku <see cref="P:System.Net.HttpListenerException.ErrorCode" /> właściwości, aby ustalić przyczynę wyjątku.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.HttpListener.EndGetContext(System.IAsyncResult)" /> Metoda została już wywołana dla określonego <paramref name="asyncResult" /> obiektu.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt jest zamknięty.</exception>
        <block subset="none" type="usage"><para>Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProtectionPolicy">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property ExtendedProtectionPolicy As ExtendedProtectionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ ExtendedProtectionPolicy { System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ get(); void set(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProtectionPolicy : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy with get, set" Usage="System.Net.HttpListener.ExtendedProtectionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("not used anywhere in the implementation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> na potrzeby ochrona rozszerzona na potrzeby sesji.</summary>
        <value>A <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> określający zasad do użycia dla ochrony rozszerzonej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> Właściwość jest używana przy użyciu zintegrowanego uwierzytelniania Windows w celu zapewnienia ochrony rozszerzonej. <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> Właściwość umożliwia konfigurację zasady ochrony rozszerzonej w całym <xref:System.Net.HttpListener> sesji. <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A> Właściwość umożliwia konfigurację zasady ochrony rozszerzonej dla każdego pojedynczego żądania.  
  
 <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> Właściwość musi być `null`. <xref:System.Net.HttpListener> Wystąpienie zyskuje kanału powiązanie Token (CBT) bezpośrednio z własnej sesji protokołu TLS, jeśli taka istnieje.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Próbowano ustawić <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" /> właściwości, ale <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> właściwość nie była <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Próbowano ustawić <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" /> właściwość <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Próbowano ustawić <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" /> właściwości po <see cref="M:System.Net.HttpListener.Start" /> metoda została już wywołana.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt jest zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement" /> Właściwość <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> na platformie, która nie obsługuje ochrony rozszerzonej.</exception>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Windows zintegrowane uwierzytelnianie przy użyciu mechanizmu rozszerzonej ochrony</related>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProtectionSelectorDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpListener.ExtendedProtectionSelector ExtendedProtectionSelectorDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListener/ExtendedProtectionSelector ExtendedProtectionSelectorDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ExtendedProtectionSelectorDelegate As HttpListener.ExtendedProtectionSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListener::ExtendedProtectionSelector ^ ExtendedProtectionSelectorDelegate { System::Net::HttpListener::ExtendedProtectionSelector ^ get(); void set(System::Net::HttpListener::ExtendedProtectionSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProtectionSelectorDelegate : System.Net.HttpListener.ExtendedProtectionSelector with get, set" Usage="System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpListener+ExtendedProtectionSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia delegata, wywoływana w celu określenia <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> do użycia dla każdego żądania.</summary>
        <value>A <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> określający zasad do użycia dla ochrony rozszerzonej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> Właściwość jest używana przy użyciu zintegrowanego uwierzytelniania Windows w celu zapewnienia ochrony rozszerzonej. <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> Właściwość umożliwia konfigurację zasady ochrony rozszerzonej w całym <xref:System.Net.HttpListener> sesji. <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A> Właściwość umożliwia konfigurację zasad ochrona rozszerzona na oddzielne żądanie.  
  
 <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> Właściwość musi być `null`. <xref:System.Net.HttpListener> Wystąpienie zyskuje kanału powiązanie Token (CBT) bezpośrednio z własnej sesji protokołu TLS, jeśli taka istnieje.  
  
 Dla każdego żądania delegata można wybrać ustawienia <xref:System.Net.HttpListener> wystąpienia użyje w celu zapewnienia ochrony rozszerzonej.  
  
 Jeśli funkcja zwraca obiekt delegowany `null` dla tej właściwości to reprezentuje <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy> który <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> właściwością <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Próbowano ustawić <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> właściwości, ale <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> właściwość musi być <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Próbowano ustawić <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> właściwość <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Próbowano ustawić <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> właściwości po <see cref="M:System.Net.HttpListener.Start" /> metoda została już wywołana.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt jest zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Próbowano ustawić <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> właściwości na platformie, która nie obsługuje ochrony rozszerzonej.</exception>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Windows zintegrowane uwierzytelnianie przy użyciu mechanizmu rozszerzonej ochrony</related>
      </Docs>
    </Member>
    <Member MemberName="GetContext">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerContext GetContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.HttpListenerContext GetContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.GetContext" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContext () As HttpListenerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::HttpListenerContext ^ GetContext();" />
      <MemberSignature Language="F#" Value="member this.GetContext : unit -&gt; System.Net.HttpListenerContext" Usage="httpListener.GetContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czeka na żądanie przychodzące i zwraca po odebraniu przez jeden.</summary>
        <returns><see cref="T:System.Net.HttpListenerContext" /> Obiekt reprezentujący żądanie klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed wywołaniem tej metody, należy wywołać <xref:System.Net.HttpListener.Start%2A> metody i Dodaj co najmniej jeden prefiks identyfikatora URI do nasłuchiwania, dodając parametry identyfikatora URI do <xref:System.Net.HttpListenerPrefixCollection> zwrócone przez <xref:System.Net.HttpListener.Prefixes%2A> właściwości. Aby uzyskać szczegółowy opis prefiksów, zobacz <xref:System.Net.HttpListener> klasa — Przegląd.  
  
 Blokuje tej metody, podczas oczekiwania na żądanie przychodzące. Przychodzące żądania, które mają być przetwarzane asynchronicznie (w oddzielnych wątkach), tak aby nie są blokowane w aplikacji, użyć <xref:System.Net.HttpListener.BeginGetContext%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje wywołanie tej metody.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Wywołanie funkcji Win32 nie powiodło się. Sprawdzanie wyjątku <see cref="P:System.Net.HttpListenerException.ErrorCode" /> właściwości, aby ustalić przyczynę wyjątku.</exception>
        <exception cref="T:System.InvalidOperationException">Ten obiekt nie została uruchomiona lub jest obecnie zatrzymana.  
  
—lub— 
<see cref="T:System.Net.HttpListener" /> Nie ma wszelkie prefiksy identyfikator (URI), aby odpowiedzieć na.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt jest zamknięty.</exception>
        <block subset="none" type="usage"><para>Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetContextAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt; GetContextAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.HttpListenerContext&gt; GetContextAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.GetContextAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContextAsync () As Task(Of HttpListenerContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::HttpListenerContext ^&gt; ^ GetContextAsync();" />
      <MemberSignature Language="F#" Value="member this.GetContextAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt;" Usage="httpListener.GetContextAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czeka na żądanie przychodzące jako operację asynchroniczną.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną. <see cref="P:System.Threading.Tasks.Task`1.Result" /> Zwraca właściwości dla obiektu task <see cref="T:System.Net.HttpListenerContext" /> obiekt reprezentujący żądanie klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja nie będzie blokować. Zwrócony <xref:System.Threading.Tasks.Task%601> obiektu zostanie ukończone, gdy otrzymano żądanie przychodzące.  
  
 Przed wywołaniem tej metody, należy wywołać <xref:System.Net.HttpListener.Start%2A> metody i Dodaj co najmniej jeden prefiks identyfikatora URI do nasłuchiwania, dodając parametry identyfikatora URI do <xref:System.Net.HttpListenerPrefixCollection> zwrócone przez <xref:System.Net.HttpListener.Prefixes%2A> właściwości. Aby uzyskać szczegółowy opis prefiksów, zobacz <xref:System.Net.HttpListener> klasa — Przegląd.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListenerContext" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreWriteExceptions">
      <MemberSignature Language="C#" Value="public bool IgnoreWriteExceptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreWriteExceptions" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IgnoreWriteExceptions" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreWriteExceptions As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreWriteExceptions { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreWriteExceptions : bool with get, set" Usage="System.Net.HttpListener.IgnoreWriteExceptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określająca, czy Twoja aplikacja otrzyma wyjątków, które występują, gdy <see cref="T:System.Net.HttpListener" /> wysyła odpowiedź do klienta.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.Net.HttpListener" /> nie powinny zwracać wyjątków, które występują podczas wysyłania odpowiedzi do klienta; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw tę właściwość na `true` Jeśli aplikacja nie wymaga, czy odpowiedź jest pomyślnie wysyłana do każdego klienta.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, ustawienie tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsListening">
      <MemberSignature Language="C#" Value="public bool IsListening { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsListening" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IsListening" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsListening As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsListening { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsListening : bool" Usage="System.Net.HttpListener.IsListening" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Net.HttpListener" /> została uruchomiona.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Net.HttpListener" /> został uruchomiony; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby rozpocząć <xref:System.Net.HttpListener>, wywołaj <xref:System.Net.HttpListener.Start%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, przy użyciu tej właściwości, aby określić stanie nasłuchiwania wystąpienia.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSupported">
      <MemberSignature Language="C#" Value="public static bool IsSupported { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsSupported" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IsSupported" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsSupported As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsSupported { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSupported : bool" Usage="System.Net.HttpListener.IsSupported" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Net.HttpListener" /> mogą być używane z bieżącym systemem operacyjnym.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Net.HttpListener" /> jest obsługiwana; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa jest dostępny tylko na komputerach z systemami operacyjnymi Windows XP z dodatkiem SP2 lub Windows Server 2003.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.HttpListener.IsSupported%2A> właściwości, aby wykryć czy <xref:System.Net.HttpListener> obiekt może być używany z bieżącym systemem operacyjnym.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixes">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerPrefixCollection Prefixes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListenerPrefixCollection Prefixes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.Prefixes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Prefixes As HttpListenerPrefixCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListenerPrefixCollection ^ Prefixes { System::Net::HttpListenerPrefixCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Prefixes : System.Net.HttpListenerPrefixCollection" Usage="System.Net.HttpListener.Prefixes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerPrefixCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera prefiksy identyfikator (URI), obsługiwane przez to <see cref="T:System.Net.HttpListener" /> obiektu.</summary>
        <value><see cref="T:System.Net.HttpListenerPrefixCollection" /> Zawierający identyfikator URI prefiksów, że <see cref="T:System.Net.HttpListener" /> obiektu jest skonfigurowany do obsługi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prefiksy są w formie kanonicznej. Aby uzyskać szczegółowy opis prefiksów, zobacz <xref:System.Net.HttpListener> klasa — Przegląd.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Net.HttpListener.Prefixes%2A> właściwości do drukowania prefiksów identyfikatorów URI, które są obsługiwane.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Realm">
      <MemberSignature Language="C#" Value="public string Realm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Realm" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.Realm" />
      <MemberSignature Language="VB.NET" Value="Public Property Realm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Realm { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Realm : string with get, set" Usage="System.Net.HttpListener.Realm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obszar lub partycji zasobów skojarzonych z tym <see cref="T:System.Net.HttpListener" /> obiektu.</summary>
        <value>A <see cref="T:System.String" /> wartość, która zawiera nazwę obszaru skojarzony <see cref="T:System.Net.HttpListener" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Serwery używają obszary do partycjonowania chronionych zasobów. Każda partycja może mieć własny schemat i/lub autoryzacji bazy danych uwierzytelniania. Obszarów są używane tylko w przypadku podstawowe i uwierzytelnianie szyfrowane. Po klient pomyślnie uwierzytelnia, uwierzytelniania jest prawidłowy dla wszystkich zasobów w danego obszaru. Aby uzyskać szczegółowy opis obszarów, zobacz RFC 2617 na [ https://www.ietf.org/ ](https://www.ietf.org/).  
  
 Wystąpienie <xref:System.Net.HttpListener> ma tylko jeden obszar skojarzone.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje ustawienie <xref:System.Net.HttpListener.Realm%2A> właściwości.  
  
 [!code-csharp[Net_Listener_Basic#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="httpListener.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia to wystąpienie do odbierania żądań przychodzących.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda musi być wywoływana przed wywołaniem <xref:System.Net.HttpListener.GetContext%2A> lub <xref:System.Net.HttpListener.BeginGetContext%2A> metody.  
  
 Po uruchomieniu <xref:System.Net.HttpListener> obiektu, możesz użyć <xref:System.Net.HttpListener.Stop%2A> metody, aby ją wyłączyć.  
  
> [!NOTE]
>  Jeśli to wystąpienie odbiornika korzysta z protokołu https, należy zainstalować i wybierz certyfikat serwera. W przeciwnym razie <xref:System.Net.HttpWebRequest> zapytania to <xref:System.Net.HttpListener> zakończy się niepowodzeniem z nieoczekiwane zamknięcie połączenia. Za pomocą HttpCfg.exe można skonfigurować certyfikaty serwera oraz inne opcje odbiornika. Zobacz [ http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp ](https://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp) Aby uzyskać więcej informacji.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Net.HttpListener.Start%2A> metodę, aby rozpocząć przetwarzanie żądań przychodzących.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Wywołanie funkcji Win32 nie powiodło się. Sprawdzanie wyjątku <see cref="P:System.Net.HttpListenerException.ErrorCode" /> właściwości, aby ustalić przyczynę wyjątku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt jest zamknięty.</exception>
        <block subset="none" type="usage"><para>Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="httpListener.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że to wystąpienie przestać otrzymywać żądań przychodzących.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli to wystąpienie jest już zatrzymana, wywołanie tej metody nie ma znaczenia.  
  
 Po zatrzymaniu <xref:System.Net.HttpListener> obiektu, możesz użyć <xref:System.Net.HttpListener.Start%2A> metodę, aby uruchomić go ponownie.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Net.HttpListener.Stop%2A> metodę, aby zatrzymać przetwarzanie żądań przychodzących.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <block subset="none" type="usage"><para>Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby blokowane przez to <see cref="T:System.Net.HttpListener" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacje powinny używać <xref:System.Net.HttpListener.Close%2A> metody zamiast wywołanie tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimeoutManager">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerTimeoutManager TimeoutManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListenerTimeoutManager TimeoutManager" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.TimeoutManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimeoutManager As HttpListenerTimeoutManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListenerTimeoutManager ^ TimeoutManager { System::Net::HttpListenerTimeoutManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TimeoutManager : System.Net.HttpListenerTimeoutManager" Usage="System.Net.HttpListener.TimeoutManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerTimeoutManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Menedżer limitu czasu, w tym <see cref="T:System.Net.HttpListener" /> wystąpienia.</summary>
        <value>Menedżer limitu czasu, w tym <see cref="T:System.Net.HttpListener" /> wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Menedżer limitu czasu definiuje ograniczenia limitu czasu połączenia dla tego <xref:System.Net.HttpListener> wystąpienia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeConnectionNtlmAuthentication">
      <MemberSignature Language="C#" Value="public bool UnsafeConnectionNtlmAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeConnectionNtlmAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.UnsafeConnectionNtlmAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeConnectionNtlmAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeConnectionNtlmAuthentication { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeConnectionNtlmAuthentication : bool with get, set" Usage="System.Net.HttpListener.UnsafeConnectionNtlmAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Support for NTLM needs some loving.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość, która kontroluje, czy, gdy jest używany protokół NTLM, dodatkowe żądania przy użyciu tego samego połączenia Transmission Control Protocol (TCP) są wymagane w celu uwierzytelnienia.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Security.Principal.IIdentity" /> pierwsze żądanie będzie używana do obsługi kolejnych żądań w ramach tego samego połączenia; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta właściwość jest równa `true` i pierwsze żądanie za pośrednictwem określonego połączenia TCP jest uwierzytelniany przy użyciu metod NTLM, kolejne żądania za pośrednictwem tego samego połączenia TCP są przetwarzane przy użyciu informacji o uwierzytelnianiu (<xref:System.Security.Principal.IIdentity>) początkowej żądanie.  
  
 Ta właściwość nie ma znaczenia podczas uwierzytelniania NTLM nie jest protokołem uwierzytelniania. Gdy Negotiate jest określony jako protokół uwierzytelniania, ta właściwość ma wpływ tylko wtedy, gdy rzeczywista protokół używany do uwierzytelniania NTLM.  
  
> [!NOTE]
>  Podczas ustawiania tej właściwości `true` zwiększa wydajność, ponieważ <xref:System.Net.HttpListener> nie wysyłaj dodatkowe NTLM wezwań do uwierzytelnienia, jest to zagrożenie bezpieczeństwa w niewymagające wszystkie żądania, aby podać informacje uwierzytelniające. Należy określić, czy wzrost wydajności jest wart to zagrożenie.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, ustawienie tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="HttpListener" FullName="System.Net.HttpListener">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="82573ef12ea9f2297019f9e271a52a13621c873d" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33682639" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpListener : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpListener extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpListener" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpListener&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpListener sealed : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.HttpListener</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Udostępnia prostą, programowo kontrolowane odbiornika protokołu HTTP. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przy użyciu <xref:System.Net.HttpListener> klasy, można utworzyć prosty odbiornika protokołu HTTP, która odpowiada na żądania HTTP. Odbiornik jest aktywne przez czas ich istnienia <xref:System.Net.HttpListener> obiektu i działa w ramach aplikacji o jego uprawnienia.
   
 Aby użyć <xref:System.Net.HttpListener>, Utwórz nowe wystąpienie klasy przy użyciu <xref:System.Net.HttpListener> Konstruktor i użyj <xref:System.Net.HttpListener.Prefixes%2A> właściwości w celu uzyskania dostępu do kolekcji, która przechowuje Ciągi określające, które jednolity identyfikator zasobów (URI) prefiksy <xref:System.Net.HttpListener>ma być przetwarzane.
  
 Ciąg prefiksu URI składa się z schemat (http lub https), hosta, opcjonalnego portu oraz opcjonalnej ścieżki. Na przykład ciąg prefiksu pełną * http://www.contoso.com:8080/customerData/ *. Prefiksy musi kończyć się kreską ukośną ("/"). <xref:System.Net.HttpListener> Obiektu o prefiks, który najlepiej pasuje do żądanego identyfikatora URI odpowiada na żądanie. Wiele <xref:System.Net.HttpListener> obiektów nie można dodać tego samego prefiksu; <xref:System.ComponentModel.Win32Exception> jest zgłaszany wyjątek, jeśli <xref:System.Net.HttpListener> dodaje prefiks, który jest już używać.
  
 Jeśli port jest określony, można zastąpić host element "\*" z informacją, że <xref:System.Net.HttpListener> akceptuje żądania wysyłane do portu, jeśli żądanego identyfikatora URI nie jest zgodny z innymi prefiks. Na przykład, aby odbierać wszystkie żądania wysyłane do portu 8080, gdy żądanego identyfikatora URI nie jest obsługiwana przez żaden <xref:System.Net.HttpListener>, prefiks jest *http://\*: 8080 /*. Podobnie Aby określić, że <xref:System.Net.HttpListener> akceptuje wszystkie żądania wysyłane do portu, Zastąp host element znak "+". Na przykład * https://+:8080 *. "\*" I "+" znaki mogą być obecne w prefiksów, które zawierają ścieżki.
  
 Począwszy od platformy .NET Core w wersji 2.0 lub .NET Framework 4.6 w systemie Windows 10, poddomen symboli wieloznacznych są obsługiwane w prefiksy URI, które są zarządzane przez <xref:System.Net.HttpListener> obiektu. Aby określić poddomeny symboli wieloznacznych, użyj "\*" znak jako część nazwy hosta w prefiks identyfikatora URI. Na przykład *http://\*.foo.com/*. Przekazany jako argument <xref:System.Net.HttpListenerPrefixCollection.Add%2A> metody. Działa to od .NET Core w wersji 2.0 lub .NET Framework 4.6 w systemie Windows 10; w starszych wersjach, spowoduje to wygenerowanie <xref:System.Net.HttpListenerException>.

 > [!WARNING]
 > Powiązania najwyższego poziomu symbolu wieloznacznego (*http://\*: 8080 /* i * http://+:8080 *) powinien **nie** można użyć. Powiązania wieloznaczny najwyższego poziomu można otwarcie luk w zabezpieczeniach aplikacji. Dotyczy to zarówno silne i słabe symboli wieloznacznych. Użyj nazwy hostów jawne zamiast symboli wieloznacznych. Powiązanie symbolu wieloznacznego domeny podrzędnej (na przykład `*.mysub.com`) nie ma to zagrożenie bezpieczeństwa, jeśli kontrolować domeny nadrzędnej całego (w przeciwieństwie do `*.com`, której występuje). Zobacz [rfc7230 sekcji-5.4](https://tools.ietf.org/html/rfc7230#section-5.4) Aby uzyskać więcej informacji.
  
 Aby rozpocząć nasłuchiwanie żądań od klientów, należy dodać prefiksy URI do zbierania i wywołanie <xref:System.Net.HttpListener.Start%2A> metody. <xref:System.Net.HttpListener> oferuje synchroniczne i asynchroniczne modeli do przetwarzania żądań klientów. Żądań i odpowiedzi skojarzone są dostępne przy użyciu <xref:System.Net.HttpListenerContext> obiektu zwróconego przez <xref:System.Net.HttpListener.GetContext%2A> metody lub jego odpowiedników asynchroniczne, <xref:System.Net.HttpListener.BeginGetContext%2A> i <xref:System.Net.HttpListener.EndGetContext%2A> metody.
  
 Synchroniczne model jest odpowiednie, jeśli aplikacja powinna zablokować podczas oczekiwania na żądanie klienta i chcesz przetworzyć jednocześnie tylko jedno żądanie. Przy użyciu modelu synchroniczne, wywołaj <xref:System.Net.HttpListener.GetContext%2A> metodę, która oczekuje na klienta wysłać żądanie. Metoda zwraca <xref:System.Net.HttpListenerContext> object dla przetwarzania, gdy dla jednego wystąpienia.
  
 W bardziej złożonych asynchroniczne modelu aplikacji nie są blokowane podczas oczekiwania na żądania i każde żądanie jest przetwarzane we własnym wątku wykonywania. Użyj <xref:System.Net.HttpListener.BeginGetContext%2A> metodę, aby określić metodę zdefiniowanym przez aplikację, aby być wywoływane dla każdego żądania przychodzącego. W ramach tej metody należy wywołać <xref:System.Net.HttpListener.EndGetContext%2A> metody w celu uzyskania żądania, go przetworzyć i odpowiedzi.
  
 W obu modelu żądania przychodzące są dostępne przy użyciu <xref:System.Net.HttpListenerContext.Request%2A?displayProperty=nameWithType> właściwości i są reprezentowane przez <xref:System.Net.HttpListenerRequest> obiektów. Podobnie odpowiedzi są dostępne przy użyciu <xref:System.Net.HttpListenerContext.Response%2A?displayProperty=nameWithType> właściwości i są reprezentowane przez <xref:System.Net.HttpListenerResponse> obiektów. Te obiekty współużytkują niektóre funkcje z <xref:System.Net.HttpWebRequest> i <xref:System.Net.HttpWebResponse> obiektów, ale ostatnie obiektów nie można używać w połączeniu z <xref:System.Net.HttpListener> ponieważ wdrażania klienta, a nie serwera, zachowania.
  
 <xref:System.Net.HttpListener> Może być wymagane uwierzytelnienie klienta. Można określić określonego schematu na potrzeby uwierzytelniania, lub możesz określić delegata, który określa schemat do użycia. Może wymagać pewnej formy uwierzytelniania w celu uzyskania informacji o tożsamości klienta. Aby uzyskać dodatkowe informacje, zobacz <xref:System.Net.HttpListenerContext.User%2A>, <xref:System.Net.HttpListener.AuthenticationSchemes%2A>, i <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> właściwości.
  
> [!NOTE]
> W przypadku utworzenia <xref:System.Net.HttpListener> przy użyciu protokołu https, należy wybrać certyfikat serwera dla tego odbiornika. W przeciwnym razie <xref:System.Net.HttpWebRequest> zapytania tego <xref:System.Net.HttpListener> zakończy się niepowodzeniem z nieoczekiwane zamknięcie połączenia.
  
> [!NOTE]
> Certyfikaty serwera oraz inne opcje odbiornika można skonfigurować przy użyciu powłoki sieciowej (netsh.exe). Zobacz [powłoki sieciowej (Netsh)](/windows-server/networking/technologies/netsh/netsh) więcej szczegółów. Plik wykonywalny rozpoczęcia wysyłki z systemem Windows Server 2008 i Windows Vista.
  
> [!NOTE]
> Jeśli określisz wielu schematów uwierzytelniania dla <xref:System.Net.HttpListener>, odbiornika zażąda klientów w następującej kolejności: `Negotiate`, `NTLM`, `Digest`, a następnie `Basic`.
  
   
  
## Examples
 Poniższy przykład kodu pokazuje, przy użyciu <xref:System.Net.HttpListener>.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpListener ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpListener();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.HttpListener" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed rozpoczęciem korzystania z wystąpienia zwróconych przez ten konstruktor, należy wywołać jej <xref:System.Net.HttpListener.Start%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, za pomocą <xref:System.Net.HttpListener> konstruktora, aby utworzyć nową <xref:System.Net.HttpListener> obiektu. Aby uzyskać pełny przykład, zobacz <xref:System.Net.HttpListener> klasy tematu.  
  
 [!code-csharp[Net_listener_Basic#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Ta klasa nie można używać w bieżącym systemie operacyjnym. Windows Server 2003 lub Windows XP z dodatkiem SP2 jest wymagany, aby użyć wystąpienia tej klasy.</exception>
        <block subset="none" type="usage">
          <para>Uwaga: Ten element członkowski generuje informacje o śledzeniu, gdy włączone śledzenie sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka <see cref="T:System.Net.HttpListener" /> obiekt natychmiast, odrzucenie wszystkich aktualnie w kolejce żądań.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda usuwa wszystkie zasoby zajmowane przez tego odbiornika. Nie można ukończyć są wszystkie oczekujące żądania.  
  
 Po wywołaniu tej metody, zostanie wyświetlony <xref:System.ObjectDisposedException> Jeśli spróbujesz użyć <xref:System.Net.HttpListener>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wywołanie tej metody.  
  
 [!code-csharp[Net_Listener_Basic#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#11)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationSchemes">
      <MemberSignature Language="C#" Value="public System.Net.AuthenticationSchemes AuthenticationSchemes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.AuthenticationSchemes AuthenticationSchemes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.AuthenticationSchemes" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationSchemes As AuthenticationSchemes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::AuthenticationSchemes AuthenticationSchemes { System::Net::AuthenticationSchemes get(); void set(System::Net::AuthenticationSchemes value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.AuthenticationSchemes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia Schemat używany do uwierzytelniania klientów.</summary>
        <value>Bitowe połączenie <see cref="T:System.Net.AuthenticationSchemes" /> wartości wyliczenia, które określa, jak klienci mają uwierzytelnienia. Wartość domyślna to <see cref="F:System.Net.AuthenticationSchemes.Anonymous" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListener> Używa określony schemat uwierzytelniania wszystkie żądania przychodzące. <xref:System.Net.HttpListener.GetContext%2A> i <xref:System.Net.HttpListener.EndGetContext%2A> metody zwracają przychodzącego żądania klienta tylko wtedy, gdy <xref:System.Net.HttpListener> pomyślnie uwierzytelnia żądanie.  
  
 Można przejrzeć tożsamości pomyślnie uwierzytelnionego klienta przy użyciu <xref:System.Net.HttpListenerContext.User%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli chcesz <xref:System.Net.HttpListener> obiektem można używać różnych mechanizmów uwierzytelniania na podstawie charakterystyk żądań odbierze (na przykład żądania <xref:System.Net.HttpListenerRequest.Url%2A> lub <xref:System.Net.HttpListenerRequest.UserHostName%2A> właściwości), musi implementować metodę, która wybiera schemat uwierzytelniania. Aby dowiedzieć się, jak to zrobić, zobacz <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> dokumentacji właściwości.  
  
> [!NOTE]
>  Aby ustawić tę właściwość, aby włączyć Digest, NTLM lub Negotiate wymaga <xref:System.Security.Permissions.SecurityPermission>, <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, przy użyciu <xref:System.Net.HttpListener.AuthenticationSchemes%2A> właściwości w celu określenia schematu uwierzytelniania.  
  
 [!code-csharp[Net_listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationSchemeSelectorDelegate">
      <MemberSignature Language="C#" Value="public System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationSchemeSelectorDelegate As AuthenticationSchemeSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::AuthenticationSchemeSelector ^ AuthenticationSchemeSelectorDelegate { System::Net::AuthenticationSchemeSelector ^ get(); void set(System::Net::AuthenticationSchemeSelector ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.AuthenticationSchemeSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia delegat wywoływany w celu określenia protokół używany do uwierzytelniania klientów.</summary>
        <value>
          <see cref="T:System.Net.AuthenticationSchemeSelector" /> Delegata, który wywołuje metodę, aby wybrać protokół uwierzytelniania. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Jeśli chcesz, aby ten sam protokół uwierzytelniania do użycia dla wszystkich żądań obsługiwanych przez konkretne wystąpienie <xref:System.Net.HttpListener>, nie trzeba ustawić tę właściwość. Aby określić protokołu używanego do wszystkich żądań klientów, należy użyć <xref:System.Net.HttpListener.AuthenticationSchemes%2A> właściwości.  
  
 Jeśli klient nie określił informacji o uwierzytelnianiu w jego nagłówki <xref:System.Net.HttpListener> wywołuje określony obiekt delegowany dla każdego nieuwierzytelnione żądania przychodzącego określić, ile, protokołu używanego na potrzeby uwierzytelniania klienta. <xref:System.Net.HttpListener.GetContext%2A> i <xref:System.Net.HttpListener.EndGetContext%2A> metody zwracają przychodzącego żądania tylko wtedy, gdy <xref:System.Net.HttpListener> pomyślnie uwierzytelnić żądania. Jeśli nie można uwierzytelnić żądania, <xref:System.Net.HttpListener> automatycznie wyśle z powrotem odpowiedzi 401. Można uzyskać tożsamości z pomyślnie uwierzytelnionego klienta przy użyciu <xref:System.Web.HttpRequest.LogonUserIdentity%2A?displayProperty=nameWithType> właściwości.  
  
 Możliwość delegowania wybór protokół uwierzytelniania do metody specyficzne dla aplikacji jest przydatne w przypadku wystąpienia <xref:System.Net.HttpListener> do używania różnych protokołów uwierzytelniania w zależności od właściwości żądania otrzymania (dla przykład, żądania <xref:System.Net.HttpListenerRequest.Url%2A> lub <xref:System.Net.HttpListenerRequest.UserHostAddress%2A> właściwości).  
  
> [!NOTE]
>  Aby ustawić tę właściwość, aby włączyć Digest, NTLM lub Negotiate wymaga <xref:System.Security.Permissions.SecurityPermission>, <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal>.  
  
   
  
## Examples  
 Poniższy przykład kodu określa wartość tej właściwości.  
  
 [!code-csharp[NclListener#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#2)]
 [!code-vb[NclListener#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#2)]  
  
 Poniższy przykładowy kod zawiera metody wywoływane przez implementację <xref:System.Net.AuthenticationSchemeSelector> delegowanie.  
  
 [!code-csharp[NclListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#1)]
 [!code-vb[NclListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetContext">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginGetContext (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginGetContext(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginGetContext (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginGetContext(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania, gdy żądanie klienta nie jest dostępny.</param>
        <param name="state">Obiekt użytkownika, który zawiera informacje na temat operacji. Ten obiekt jest przekazywany do <c>wywołania zwrotnego</c> delegować po zakończeniu operacji.</param>
        <summary>Rozpoczyna asynchronicznie pobierania przychodzącego żądania.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiekt, który wskazuje stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListener.BeginGetContext%2A> Metoda rozpoczyna (bez blokowania) wywołanie asynchroniczne do odbierania przychodzących żądań klientów. Przed wywołaniem tej metody, należy wywołać <xref:System.Net.HttpListener.Start%2A> — metoda i Dodaj co najmniej jeden identyfikator URI (Uniform Resource) prefiksu do nasłuchiwania przez dodanie ciągi identyfikatora URI, aby <xref:System.Net.HttpListenerPrefixCollection> zwrócony przez <xref:System.Net.HttpListener.Prefixes%2A> właściwości.  
  
 Należy ukończyć operację asynchroniczną przez wywołanie metody <xref:System.Net.HttpListener.EndGetContext%2A> metody. Zazwyczaj metoda jest wywoływana przez `callback` delegowanie.  
  
 Ta metoda nie są blokowane podczas operacji. Aby uzyskać przychodzące żądanie i blok przed zakończeniem operacji, należy wywołać <xref:System.Net.HttpListener.GetContext%2A> metody.  
  
 Aby uzyskać szczegółowe informacje o korzystaniu z modelem programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, przy użyciu <xref:System.Net.HttpListener.BeginGetContext%2A> metodę, aby określić metodę wywołania zwrotnego, która będzie obsługiwać żądania przychodzące klienta.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
  
 Poniższy przykład kodu implementuje metody wywołania zwrotnego.  
  
 [!code-csharp[Net_Listener_Basic#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Nie można wywołać funkcji Win32. Sprawdź wyjątek <see cref="P:System.Net.HttpListenerException.ErrorCode" /> właściwość, aby ustalić przyczynę tego wyjątku.</exception>
        <exception cref="T:System.InvalidOperationException">Ten obiekt nie został uruchomiony lub jest obecnie zatrzymana.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt jest zamknięty.</exception>
        <block subset="none" type="usage">
          <para>Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka <see cref="T:System.Net.HttpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu tej metody, nie można korzystać <xref:System.Net.HttpListener> obiektu. Aby tymczasowo wstrzymać <xref:System.Net.HttpListener> obiektów, użyj <xref:System.Net.HttpListener.Stop%2A> metody.  
  
 Zamknij tę metodę szczegółu <xref:System.Net.HttpListener> obiektu bez przetwarzania żądań w kolejce. Nie można ukończyć są wszystkie oczekujące żądania.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wywołanie tej metody.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DefaultServiceNames">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.DefaultServiceNames" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultServiceNames As ServiceNameCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ServiceNameCollection ^ DefaultServiceNames { System::Security::Authentication::ExtendedProtection::ServiceNameCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ServiceNameCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera listę domyślnej nazwy dostawcy usługi (SPN), zgodnie z ustaleniami zarejestrowanych prefiksów.</summary>
        <value>A <see cref="T:System.Security.Authentication.ExtendedProtection.ServiceNameCollection" /> zawierający listę nazw SPN.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListener.DefaultServiceNames%2A> Właściwość jest używana przy użyciu zintegrowanego uwierzytelniania systemu Windows w celu zapewnienia ochrony rozszerzonej. Lista nazw SPN jest zainicjowany z <xref:System.Net.HttpListener.Prefixes%2A> właściwość podczas dostępne i wyczyszczone po dodaniu do nowego prefiksy <xref:System.Net.HttpListener.Prefixes%2A> właściwości.  
  
 <xref:System.Net.HttpListener.DefaultServiceNames%2A> Właściwość jest używana, jeśli aplikacja nie ustawić <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames%2A> właściwości na jego zasady ochrony rozszerzonej.  
  
 <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection> Które są pobierane z <xref:System.Net.HttpListener.DefaultServiceNames%2A> właściwości składa się z <xref:System.Net.HttpListener.Prefixes%2A> właściwości zgodnie z następującymi zasadami:  
  
1.  Jeśli nazwa hosta jest "+", "*", ani literał IPv4 lub IPv6 (odpowiednikiem "\*" ale ograniczone do określonego interfejsu lokalnego), poniższe nazwy SPN zostanie dodany:  
  
 `"HTTP/"` oraz w pełni kwalifikowaną nazwę komputera.  
  
1.  Jeśli nazwa hosta nie zawiera kropek (nie domeny lub poddomeny), próby rozwiązania w pełni kwalifikowaną nazwą domeny przy użyciu systemu DNS (takie samo zachowanie używane przez <xref:System.Net.HttpWebRequest>). Jeśli w pełni kwalifikowaną nazwę domeny można rozwiązać, zostaną dodane następujące nazwy SPN:  
  
 `"HTTP/"` Oprócz nazwy hosta (krótka nazwa).  
  
 `"HTTP/"` oraz w pełni kwalifikowaną nazwę domeny dla nazwy hosta.  
  
1.  Jeśli nie kropki (nie domeny lub poddomeny) zawiera nazwę hosta, w pełni kwalifikowanej nazwy domeny nie można rozpoznać następujące nazwy SPN został dodany:  
  
 `"HTTP/"` Oprócz nazwy hosta.  
  
1.  Jeśli nazwa hosta zawiera kropki (domen i poddomen), poniższe nazwy SPN został dodany:  
  
 `"HTTP/"` Oprócz nazwy hosta.  
  
 <xref:System.Net.HttpListener.DefaultServiceNames%2A> Właściwości można używany przez aplikację, aby przejrzeć listę nazw SPN domyślnego, które będą używane do uwierzytelniania, jeśli nie listy niestandardowej nie jest dostarczony. Jeśli potrzebne są inne nazwy SPN, aplikację można dodać je przy użyciu jednej z <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection.Merge%2A> metody.  
  
 Nie jest bezpieczne podczas wprowadzać zasady podejmować decyzje na podstawie żądanego adresu URL, ponieważ może to być sfałszowane przy użyciu ochrony rozszerzonej. Zamiast aplikacji będą miały <xref:System.Net.HttpListenerRequest.LocalEndPoint%2A> lub <xref:System.Net.HttpListenerRequest.RemoteEndPoint%2A> właściwości, aby podjąć decyzje dotyczące tych zasad.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="EndGetContext">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerContext EndGetContext (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.HttpListenerContext EndGetContext(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.EndGetContext(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetContext (asyncResult As IAsyncResult) As HttpListenerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::HttpListenerContext ^ EndGetContext(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Obiekt, który uzyskano, gdy operacja asynchroniczna została uruchomiona.</param>
        <summary>Kończy operację asynchroniczną można pobrać przychodzącego żądania klienta.</summary>
        <returns>
          <see cref="T:System.Net.HttpListenerContext" /> Obiekt, który reprezentuje żądania klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListener.EndGetContext%2A> Metoda jest wywoływana, zwykle wewnątrz metody zdefiniowane przez aplikację wywołanie zwrotne wywoływane przez pełnomocnika, aby uzyskać <xref:System.Net.HttpListenerContext> obiekt, który zawiera przychodzącego żądania klienta i jego skojarzone odpowiedzi. Ta metoda wykona operację wcześniej uruchomione przez wywołanie metody <xref:System.Net.HttpListener.BeginGetContext%2A> metody. Jeśli działanie nie zostało ukończone, ta metoda blokuje, dopóki nie robi.  
  
 Ponieważ wywoływanie <xref:System.Net.HttpListener.EndGetContext%2A> metoda wymaga <xref:System.Net.HttpListener> obiektu, ten obiekt jest zwykle przekazany do metody wywołania zwrotnego przez przy użyciu obiektu stan przekazany do <xref:System.Net.HttpListener.BeginGetContext%2A> metody. Ten obiekt stanu można uzyskać za pomocą <xref:System.IAsyncResult.AsyncState%2A> właściwość `asyncResult` obiektu.  
  
 Aby uzyskać szczegółowe informacje o korzystaniu z modelem programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia implementację metody wywołania zwrotnego, która wywołuje <xref:System.Net.HttpListener.EndGetContext%2A> metody.  
  
 [!code-csharp[Net_Listener_Basic#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie uzyskano przez wywołanie metody <see cref="M:System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.HttpListener.EndGetContext(System.IAsyncResult)" /> Metoda została już wywołana dla określonego <paramref name="asyncResult" /> obiektu.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt jest zamknięty.</exception>
        <block subset="none" type="usage">
          <para>Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProtectionPolicy">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property ExtendedProtectionPolicy As ExtendedProtectionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ ExtendedProtectionPolicy { System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ get(); void set(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("not used anywhere in the implementation")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>GET lub set <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> do użycia na potrzeby ochrona rozszerzona na potrzeby sesji.</summary>
        <value>A <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> , który określa zasady, które mają być używane do ochrony rozszerzonej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> Właściwość jest używana przy użyciu zintegrowanego uwierzytelniania systemu Windows w celu zapewnienia ochrony rozszerzonej. <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> Właściwość umożliwia konfigurację zasad ochrony rozszerzonej dla całej <xref:System.Net.HttpListener> sesji. <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A> Właściwość umożliwia konfigurację zasad ochrony rozszerzonej dla poszczególnych żądań.  
  
 <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> Właściwość musi być `null`. <xref:System.Net.HttpListener> Wystąpienia pobiera kanału powiązanie Token (CBT) bezpośrednio z własnej sesji protokołu TLS, jeśli istnieje.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Próbowano ustawić <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" /> właściwości, ale <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> nie odnaleziono <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Próbowano ustawić <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" /> właściwości <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Próbowano ustawić <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" /> właściwości po <see cref="M:System.Net.HttpListener.Start" /> metoda została już wywołana.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt jest zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement" /> Ustawiono właściwość <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> na platformie, która nie obsługuje ochrony rozszerzonej.</exception>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="ExtendedProtectionSelectorDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpListener.ExtendedProtectionSelector ExtendedProtectionSelectorDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListener/ExtendedProtectionSelector ExtendedProtectionSelectorDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ExtendedProtectionSelectorDelegate As HttpListener.ExtendedProtectionSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListener::ExtendedProtectionSelector ^ ExtendedProtectionSelectorDelegate { System::Net::HttpListener::ExtendedProtectionSelector ^ get(); void set(System::Net::HttpListener::ExtendedProtectionSelector ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListener+ExtendedProtectionSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>GET lub set delegat wywoływany w celu określenia <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> dla każdego żądania.</summary>
        <value>A <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> , który określa zasady, które mają być używane do ochrony rozszerzonej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> Właściwość jest używana przy użyciu zintegrowanego uwierzytelniania systemu Windows w celu zapewnienia ochrony rozszerzonej. <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> Właściwość umożliwia konfigurację zasad ochrony rozszerzonej dla całej <xref:System.Net.HttpListener> sesji. <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A> Właściwość umożliwia konfigurację zasad ochrona rozszerzona na oddzielne żądanie.  
  
 <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> Właściwość musi być `null`. <xref:System.Net.HttpListener> Wystąpienia pobiera kanału powiązanie Token (CBT) bezpośrednio z własnej sesji protokołu TLS, jeśli istnieje.  
  
 Dla każdego żądania delegata można wybrać ustawienia <xref:System.Net.HttpListener> wystąpienie będzie używać w celu zapewnienia ochrony rozszerzonej.  
  
 Jeśli zwraca delegata `null` dla tej właściwości, ta pozycja reprezentuje <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy> którego <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> ustawioną właściwość <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Próbowano ustawić <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> właściwości, ale <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> właściwość musi być <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Próbowano ustawić <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> właściwości <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Próbowano ustawić <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> właściwości po <see cref="M:System.Net.HttpListener.Start" /> metoda została już wywołana.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt jest zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Próbowano ustawić <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> właściwości na platformie, która nie obsługuje ochrony rozszerzonej.</exception>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="GetContext">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerContext GetContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.HttpListenerContext GetContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.GetContext" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContext () As HttpListenerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::HttpListenerContext ^ GetContext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czeka na przychodzące żądania i zwraca po odebraniu jeden.</summary>
        <returns>
          <see cref="T:System.Net.HttpListenerContext" /> Obiekt, który reprezentuje żądania klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed wywołaniem tej metody, należy wywołać <xref:System.Net.HttpListener.Start%2A> — metoda i Dodaj co najmniej jeden prefiks URI do nasłuchiwania przez dodanie ciągi identyfikatora URI, aby <xref:System.Net.HttpListenerPrefixCollection> zwrócony przez <xref:System.Net.HttpListener.Prefixes%2A> właściwości. Aby uzyskać szczegółowy opis prefiksy, zobacz <xref:System.Net.HttpListener> Przegląd klasy.  
  
 Tej metody bloki podczas oczekiwania na żądanie przychodzące. Żądania przychodzące do przetwarzania asynchronicznego (w oddzielnych wątkach), które nie są blokowane przez aplikację, należy użyć <xref:System.Net.HttpListener.BeginGetContext%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wywołanie tej metody.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Nie można wywołać funkcji Win32. Sprawdź wyjątek <see cref="P:System.Net.HttpListenerException.ErrorCode" /> właściwość, aby ustalić przyczynę tego wyjątku.</exception>
        <exception cref="T:System.InvalidOperationException">Ten obiekt nie został uruchomiony lub jest obecnie zatrzymana.  
  
 —lub—  
  
 <see cref="T:System.Net.HttpListener" /> Nie ma żadnych prefiksów identyfikator URI (Uniform Resource) odpowiedzieć na.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt jest zamknięty.</exception>
        <block subset="none" type="usage">
          <para>Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetContextAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt; GetContextAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.HttpListenerContext&gt; GetContextAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.GetContextAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContextAsync () As Task(Of HttpListenerContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::HttpListenerContext ^&gt; ^ GetContextAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czeka na przychodzące żądania jako operację asynchroniczną.</summary>
        <returns>Zwraca <see cref="T:System.Threading.Tasks.Task`1" />.  
  
 Obiekt zadania reprezentujący operację asynchroniczną. <see cref="P:System.Threading.Tasks.Task`1.Result" /> Zwraca właściwości dla obiektu task <see cref="T:System.Net.HttpListenerContext" /> obiekt, który reprezentuje żądania klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja nie będzie blokować. Zwrócona <xref:System.Threading.Tasks.Task%601> obiektu ukończy po otrzymaniu żądania przychodzącego.  
  
 Przed wywołaniem tej metody, należy wywołać <xref:System.Net.HttpListener.Start%2A> — metoda i Dodaj co najmniej jeden prefiks URI do nasłuchiwania przez dodanie ciągi identyfikatora URI, aby <xref:System.Net.HttpListenerPrefixCollection> zwrócony przez <xref:System.Net.HttpListener.Prefixes%2A> właściwości. Aby uzyskać szczegółowy opis prefiksy, zobacz <xref:System.Net.HttpListener> Przegląd klasy.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListenerContext" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreWriteExceptions">
      <MemberSignature Language="C#" Value="public bool IgnoreWriteExceptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreWriteExceptions" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IgnoreWriteExceptions" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreWriteExceptions As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreWriteExceptions { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość, która określa, czy aplikacja odbiera wyjątków, które występują po <see cref="T:System.Net.HttpListener" /> wysyła odpowiedź do klienta.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.HttpListener" /> nie może zwracać wyjątków występujących podczas wysyłania odpowiedzi do klienta; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest ustawiana `true` Jeśli aplikacja nie wymaga, czy odpowiedź jest pomyślnie wysłane do każdego klienta.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje ustawienie dla tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsListening">
      <MemberSignature Language="C#" Value="public bool IsListening { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsListening" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IsListening" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsListening As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsListening { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Net.HttpListener" /> została uruchomiona.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.HttpListener" /> została rozpoczęta, a w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uruchomić <xref:System.Net.HttpListener>, wywołaj <xref:System.Net.HttpListener.Start%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, za pomocą tej właściwości można określić stanu nasłuchiwania wystąpienia.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSupported">
      <MemberSignature Language="C#" Value="public static bool IsSupported { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsSupported" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IsSupported" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsSupported As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsSupported { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Net.HttpListener" /> może być używany z bieżącym systemem operacyjnym.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.HttpListener" /> jest obsługiwany; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa jest dostępna tylko na komputerach z systemem operacyjnym Windows XP z dodatkiem SP2 lub Windows Server 2003.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Net.HttpListener.IsSupported%2A> właściwość, aby wykryć czy <xref:System.Net.HttpListener> obiektu może być używany z bieżącym systemem operacyjnym.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixes">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerPrefixCollection Prefixes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListenerPrefixCollection Prefixes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.Prefixes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Prefixes As HttpListenerPrefixCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListenerPrefixCollection ^ Prefixes { System::Net::HttpListenerPrefixCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerPrefixCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera prefiksy jednolity identyfikator zasobów (URI), obsługiwane przez to <see cref="T:System.Net.HttpListener" /> obiektu.</summary>
        <value>
          <see cref="T:System.Net.HttpListenerPrefixCollection" /> Zawiera identyfikator URI tego prefiksy <see cref="T:System.Net.HttpListener" /> obiektu jest skonfigurowane do obsługi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prefiksy są w formie kanonicznej. Aby uzyskać szczegółowy opis prefiksy, zobacz <xref:System.Net.HttpListener> Przegląd klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, przy użyciu <xref:System.Net.HttpListener.Prefixes%2A> właściwości do drukowania prefiksy URI, które są obsługiwane.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Realm">
      <MemberSignature Language="C#" Value="public string Realm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Realm" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.Realm" />
      <MemberSignature Language="VB.NET" Value="Public Property Realm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Realm { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obszar lub partycję zasobu, skojarzone z tym <see cref="T:System.Net.HttpListener" /> obiektu.</summary>
        <value>A <see cref="T:System.String" /> wartości, która zawiera nazwę obszaru skojarzone z <see cref="T:System.Net.HttpListener" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Serwery używają obszarów do partycjonowania chronionych zasobów; Każda partycja może mieć własną schematu i/lub autoryzacji bazy danych uwierzytelniania. Obszarów są używane tylko w przypadku basic i uwierzytelniania szyfrowanego. Po pomyślnym uwierzytelnieniu klient, uwierzytelnianie jest prawidłowa dla wszystkich zasobów w danym obszarze. Szczegółowy opis obszarów, zobacz dokument RFC 2617 na [ https://www.ietf.org/ ](https://www.ietf.org/).  
  
 Wystąpienie <xref:System.Net.HttpListener> ma tylko jeden obszar skojarzone.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje ustawienie <xref:System.Net.HttpListener.Realm%2A> właściwości.  
  
 [!code-csharp[Net_Listener_Basic#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia to wystąpienie do odbierania żądań przychodzących.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda musi zostać wywołana przed wywołaniem <xref:System.Net.HttpListener.GetContext%2A> lub <xref:System.Net.HttpListener.BeginGetContext%2A> metody.  
  
 Po uruchomieniu <xref:System.Net.HttpListener> obiektu, można użyć <xref:System.Net.HttpListener.Stop%2A> metody, zatrzymaj ją.  
  
> [!NOTE]
>  Jeśli to wystąpienie odbiornika używa protokołu https, należy zainstalować i wybrać certyfikat serwera. W przeciwnym razie <xref:System.Net.HttpWebRequest> zapytania tego <xref:System.Net.HttpListener> zakończy się niepowodzeniem z nieoczekiwane zamknięcie połączenia. Certyfikaty serwera oraz inne opcje odbiornika można skonfigurować przy użyciu HttpCfg.exe. Zobacz [ http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp ](http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp) więcej szczegółów.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, przy użyciu <xref:System.Net.HttpListener.Start%2A> metodę, aby rozpocząć przetwarzanie żądań przychodzących.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Nie można wywołać funkcji Win32. Sprawdź wyjątek <see cref="P:System.Net.HttpListenerException.ErrorCode" /> właściwość, aby ustalić przyczynę tego wyjątku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt jest zamknięty.</exception>
        <block subset="none" type="usage">
          <para>Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje to wystąpienie zrezygnować z otrzymywania żądań przychodzących.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli to wystąpienie jest już zatrzymana, wywołanie tej metody nie ma znaczenia.  
  
 Po zatrzymaniu <xref:System.Net.HttpListener> obiektu, można użyć <xref:System.Net.HttpListener.Start%2A> metodę, aby uruchomić go ponownie.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, przy użyciu <xref:System.Net.HttpListener.Stop%2A> metodę, aby zatrzymać przetwarzania przychodzących żądań.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <block subset="none" type="usage">
          <para>Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby posiadanych przez to <see cref="T:System.Net.HttpListener" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacje powinny używać <xref:System.Net.HttpListener.Close%2A> metody zamiast wywołaniem tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimeoutManager">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerTimeoutManager TimeoutManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListenerTimeoutManager TimeoutManager" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.TimeoutManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimeoutManager As HttpListenerTimeoutManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListenerTimeoutManager ^ TimeoutManager { System::Net::HttpListenerTimeoutManager ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerTimeoutManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Menedżer limitu czasu dla tego <see cref="T:System.Net.HttpListener" /> wystąpienia.</summary>
        <value>Zwraca <see cref="T:System.Net.HttpListenerTimeoutManager" />.  
  
 Menedżer limitu czasu dla tego <see cref="T:System.Net.HttpListener" /> wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Menedżer limitu czasu definiuje granicach limitu czasu połączenia dla tego <xref:System.Net.HttpListener> wystąpienia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeConnectionNtlmAuthentication">
      <MemberSignature Language="C#" Value="public bool UnsafeConnectionNtlmAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeConnectionNtlmAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.UnsafeConnectionNtlmAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeConnectionNtlmAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeConnectionNtlmAuthentication { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Support for NTLM needs some loving.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość, która kontroluje, czy, gdy jest używany protokół NTLM, dodatkowe żądania przy użyciu tego samego połączenia protokołu Transmission Control Protocol (TCP) są wymagane do uwierzytelniania.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Security.Principal.IIdentity" /> pierwszego żądanie zostanie użyty dla kolejnych żądań w ramach tego samego połączenia; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta właściwość jest skonfigurowana `true` i pierwsze żądanie przy użyciu określonego połączenia TCP jest uwierzytelniany przy użyciu protokołu NTLM, kolejne żądania za pośrednictwem tego samego połączenia TCP są przetwarzane przy użyciu informacji o uwierzytelnianiu (<xref:System.Security.Principal.IIdentity>) wstępnego żądanie.  
  
 Ta właściwość nie ma znaczenia podczas uwierzytelniania NTLM nie jest protokołem uwierzytelniania. Gdy Negotiate jest określony jako protokół uwierzytelniania, ta właściwość ma wpływ tylko wtedy, gdy rzeczywista protokół używany do uwierzytelniania NTLM.  
  
> [!NOTE]
>  Podczas ustawiania tej właściwości `true` zwiększa wydajność, ponieważ <xref:System.Net.HttpListener> nie nie wysyłaj dodatkowe NTLM wezwań do uwierzytelnienia, w niewymagające wszystkich żądań, aby podać informacje uwierzytelniania jest zagrożenie bezpieczeństwa. Należy określić, czy zwiększenia wydajności warto to ryzyko.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje ustawienie dla tej właściwości.  
  
 [!code-csharp[Net_Listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="Vector" FullName="System.Numerics.Vector">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="95e1267a9f59f96ee76094302da88cdb96a63f2e" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Vector" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Vector extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Vector" />
  <TypeSignature Language="VB.NET" Value="Public Class Vector" />
  <TypeSignature Language="C++ CLI" Value="public ref class Vector abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Numerics.Vectors</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>4.1.3.0</AssemblyVersion>
    <AssemblyVersion>4.1.4.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="82bfe-101">Udostępnia kolekcję podręczne statycznej metody tworzenia, manipulowanie, łączenie i konwertowanie wektory ogólnego.</span>
      <span class="sxs-lookup">
        <span data-stu-id="82bfe-101">Provides a collection of static convenience methods for creating, manipulating, combining, and converting generic vectors.</span>
      </span>
    </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Abs&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; Abs&lt;T&gt; (System.Numerics.Vector&lt;T&gt; value) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;!!T&gt; Abs&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Abs``1(System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs(Of T As Structure) (value As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;T&gt; Abs(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-102">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-102">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-103">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-103">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="value">
          <span data-ttu-id="82bfe-104">Wektorze źródłowym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-104">The source vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-105">Zwraca nowy wektor, której elementy są wartości bezwzględne elementów wektora danego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-105">Returns a new vector whose elements are the absolute values of the given vector's elements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-106">Wektor wartość bezwzględna.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-106">The absolute value vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; Add&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;!!T&gt; Add&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Add``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add(Of T As Structure) (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;T&gt; Add(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-107">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-107">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-108">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-108">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-109">Pierwszy wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-109">The first vector.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-110">Drugi wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-110">The second vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-111">Zwraca nowy wektor, których wartości są sumę każda para elementy z dwoma wektorami danego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-111">Returns a new vector whose values are the sum of each pair of elements from two given vectors.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-112">Równy określonemu procentowi wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-112">The summed vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndNot&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; AndNot&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;!!T&gt; AndNot&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.AndNot``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndNot(Of T As Structure) (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;T&gt; AndNot(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-113">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-113">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-114">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-114">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-115">Pierwszy wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-115">The first vector.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-116">Drugi wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-116">The second vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-117">Zwraca nowy wektor za pomocą operacji bitowe, a nie na każdej pary odpowiednie elementy w dwóch wektorów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-117">Returns a new vector by performing a bitwise And Not operation on each pair of corresponding elements in two vectors.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-118">Wynikowa wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-118">The resulting vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsVectorByte&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;byte&gt; AsVectorByte&lt;T&gt; (System.Numerics.Vector&lt;T&gt; value) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;unsigned int8&gt; AsVectorByte&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.AsVectorByte``1(System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsVectorByte(Of T As Structure) (value As Vector(Of T)) As Vector(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;System::Byte&gt; AsVectorByte(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-119">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-119">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-120">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-120">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="value">
          <span data-ttu-id="82bfe-121">Wektorze źródłowym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-121">The source vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-122">Reinterprets bity określony wektor do tych wektora bajtów bez znaku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-122">Reinterprets the bits of a specified vector into those of a vector of unsigned bytes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-123">Reinterpreted wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-123">The reinterpreted vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsVectorDouble&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;double&gt; AsVectorDouble&lt;T&gt; (System.Numerics.Vector&lt;T&gt; value) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;float64&gt; AsVectorDouble&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.AsVectorDouble``1(System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsVectorDouble(Of T As Structure) (value As Vector(Of T)) As Vector(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;double&gt; AsVectorDouble(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-124">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-124">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-125">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-125">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="value">
          <span data-ttu-id="82bfe-126">Wektorze źródłowym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-126">The source vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-127">Reinterprets bity określony wektor do tych wektora zmiennoprzecinkowe podwójnej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-127">Reinterprets the bits of a specified vector into those of a double-precision floating-point vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-128">Reinterpreted wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-128">The reinterpreted vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsVectorInt16&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;short&gt; AsVectorInt16&lt;T&gt; (System.Numerics.Vector&lt;T&gt; value) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int16&gt; AsVectorInt16&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.AsVectorInt16``1(System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsVectorInt16(Of T As Structure) (value As Vector(Of T)) As Vector(Of Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;short&gt; AsVectorInt16(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int16&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-129">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-129">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-130">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-130">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="value">
          <span data-ttu-id="82bfe-131">Wektorze źródłowym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-131">The source vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-132">Reinterprets bity określony wektor do tych wektor 16-bitowych liczb całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-132">Reinterprets the bits of a specified vector into those of a vector of 16-bit integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-133">Reinterpreted wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-133">The reinterpreted vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsVectorInt32&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;int&gt; AsVectorInt32&lt;T&gt; (System.Numerics.Vector&lt;T&gt; value) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int32&gt; AsVectorInt32&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.AsVectorInt32``1(System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsVectorInt32(Of T As Structure) (value As Vector(Of T)) As Vector(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;int&gt; AsVectorInt32(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-134">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-134">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-135">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-135">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="value">
          <span data-ttu-id="82bfe-136">Wektorze źródłowym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-136">The source vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-137">Reinterprets bity określony wektor do tych wektorem liczb całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-137">Reinterprets the bits of a specified vector into those of a vector of integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-138">Reinterpreted wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-138">The reinterpreted vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsVectorInt64&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;long&gt; AsVectorInt64&lt;T&gt; (System.Numerics.Vector&lt;T&gt; value) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int64&gt; AsVectorInt64&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.AsVectorInt64``1(System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsVectorInt64(Of T As Structure) (value As Vector(Of T)) As Vector(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;long&gt; AsVectorInt64(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-139">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-139">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-140">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-140">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="value">
          <span data-ttu-id="82bfe-141">Wektorze źródłowym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-141">The source vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-142">Reinterprets bity określony wektor do tych wektora długich liczb całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-142">Reinterprets the bits of a specified vector into those of a vector of long integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-143">Reinterpreted wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-143">The reinterpreted vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsVectorSByte&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;sbyte&gt; AsVectorSByte&lt;T&gt; (System.Numerics.Vector&lt;T&gt; value) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int8&gt; AsVectorSByte&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.AsVectorSByte``1(System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsVectorSByte(Of T As Structure) (value As Vector(Of T)) As Vector(Of SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;System::SByte&gt; AsVectorSByte(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.SByte&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-144">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-144">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-145">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-145">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="value">
          <span data-ttu-id="82bfe-146">Wektorze źródłowym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-146">The source vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-147">Reinterprets bity określony wektor do tych wektora podpisem bajtów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-147">Reinterprets the bits of a specified vector into those of a vector of signed bytes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-148">Reinterpreted wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-148">The reinterpreted vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsVectorSingle&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;float&gt; AsVectorSingle&lt;T&gt; (System.Numerics.Vector&lt;T&gt; value) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;float32&gt; AsVectorSingle&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.AsVectorSingle``1(System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsVectorSingle(Of T As Structure) (value As Vector(Of T)) As Vector(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;float&gt; AsVectorSingle(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-149">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-149">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-150">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-150">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="value">
          <span data-ttu-id="82bfe-151">Wektorze źródłowym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-151">The source vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-152">Reinterprets bity określony wektor do tych wektorem liczb zmiennoprzecinkowych pojedynczej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-152">Reinterprets the bits of a specified vector into those of a single-precision floating-point vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-153">Reinterpreted wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-153">The reinterpreted vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsVectorUInt16&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;ushort&gt; AsVectorUInt16&lt;T&gt; (System.Numerics.Vector&lt;T&gt; value) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;unsigned int16&gt; AsVectorUInt16&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.AsVectorUInt16``1(System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsVectorUInt16(Of T As Structure) (value As Vector(Of T)) As Vector(Of UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;System::UInt16&gt; AsVectorUInt16(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.UInt16&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-154">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-154">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-155">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-155">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="value">
          <span data-ttu-id="82bfe-156">Wektorze źródłowym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-156">The source vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-157">Reinterprets bity określony wektor do tych wektorem liczb całkowitych bez znaku 16-bitowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-157">Reinterprets the bits of a specified vector into those of a vector of unsigned 16-bit integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-158">Reinterpreted wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-158">The reinterpreted vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsVectorUInt32&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;uint&gt; AsVectorUInt32&lt;T&gt; (System.Numerics.Vector&lt;T&gt; value) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;unsigned int32&gt; AsVectorUInt32&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.AsVectorUInt32``1(System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsVectorUInt32(Of T As Structure) (value As Vector(Of T)) As Vector(Of UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;System::UInt32&gt; AsVectorUInt32(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.UInt32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-159">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-159">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-160">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-160">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="value">
          <span data-ttu-id="82bfe-161">Wektorze źródłowym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-161">The source vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-162">Reinterprets bity określony wektor do tych wektorem liczb całkowitych bez znaku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-162">Reinterprets the bits of a specified vector into those of a vector of unsigned integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-163">Reinterpreted wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-163">The reinterpreted vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsVectorUInt64&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;ulong&gt; AsVectorUInt64&lt;T&gt; (System.Numerics.Vector&lt;T&gt; value) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;unsigned int64&gt; AsVectorUInt64&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.AsVectorUInt64``1(System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsVectorUInt64(Of T As Structure) (value As Vector(Of T)) As Vector(Of ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;System::UInt64&gt; AsVectorUInt64(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.UInt64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-164">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-164">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-165">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-165">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="value">
          <span data-ttu-id="82bfe-166">Wektorze źródłowym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-166">The source vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-167">Reinterprets bity określony wektor do tych wektor długich liczb całkowitych bez znaku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-167">Reinterprets the bits of a specified vector into those of a vector of unsigned long integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-168">Reinterpreted wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-168">The reinterpreted vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitwiseAnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; BitwiseAnd&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;!!T&gt; BitwiseAnd&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.BitwiseAnd``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BitwiseAnd(Of T As Structure) (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;T&gt; BitwiseAnd(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-169">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-169">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-170">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-170">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-171">Pierwszy wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-171">The first vector.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-172">Drugi wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-172">The second vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-173">Zwraca nowy wektor, wykonując bitowej <see langword="And" /> operacji dla każdej pary elementów w dwóch wektorów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-173">Returns a new vector by performing a bitwise <see langword="And" /> operation on each pair of elements in two vectors.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-174">Wynikowa wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-174">The resulting vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitwiseOr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; BitwiseOr&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;!!T&gt; BitwiseOr&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.BitwiseOr``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BitwiseOr(Of T As Structure) (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;T&gt; BitwiseOr(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-175">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-175">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-176">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-176">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-177">Pierwszy wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-177">The first vector.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-178">Drugi wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-178">The second vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-179">Zwraca nowy wektor, wykonując bitowej <see langword="Or" /> operacji dla każdej pary elementów w dwóch wektorów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-179">Returns a new vector by performing a bitwise <see langword="Or" /> operation on each pair of elements in two vectors.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-180">Wynikowa wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-180">The resulting vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConditionalSelect">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;float&gt; ConditionalSelect (System.Numerics.Vector&lt;int&gt; condition, System.Numerics.Vector&lt;float&gt; left, System.Numerics.Vector&lt;float&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;float32&gt; ConditionalSelect(valuetype System.Numerics.Vector`1&lt;int32&gt; condition, valuetype System.Numerics.Vector`1&lt;float32&gt; left, valuetype System.Numerics.Vector`1&lt;float32&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.ConditionalSelect(System.Numerics.Vector{System.Int32},System.Numerics.Vector{System.Single},System.Numerics.Vector{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConditionalSelect (condition As Vector(Of Integer), left As Vector(Of Single), right As Vector(Of Single)) As Vector(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;float&gt; ConditionalSelect(System::Numerics::Vector&lt;int&gt; condition, System::Numerics::Vector&lt;float&gt; left, System::Numerics::Vector&lt;float&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Numerics.Vector&lt;System.Int32&gt;" />
        <Parameter Name="left" Type="System.Numerics.Vector&lt;System.Single&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="82bfe-181">Wektor integralną maski, używany do wyboru dysku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-181">The integral mask vector used to drive selection.</span>
          </span>
        </param>
        <param name="left">
          <span data-ttu-id="82bfe-182">Pierwszy wektorze źródłowym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-182">The first source vector.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-183">Drugi wektorze źródłowym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-183">The second source vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-184">Tworzy nowy wektor pojedynczej precyzji z elementami wybrane między dwoma wektorami określonego źródła pojedynczej precyzji oparte na wektor integralną maski.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-184">Creates a new single-precision vector with elements selected between two specified single-precision source vectors based on an integral mask vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-185">Nowy wektor z wybrane elementy na podstawie maski.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-185">The new vector with elements selected based on the mask.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConditionalSelect">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;double&gt; ConditionalSelect (System.Numerics.Vector&lt;long&gt; condition, System.Numerics.Vector&lt;double&gt; left, System.Numerics.Vector&lt;double&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;float64&gt; ConditionalSelect(valuetype System.Numerics.Vector`1&lt;int64&gt; condition, valuetype System.Numerics.Vector`1&lt;float64&gt; left, valuetype System.Numerics.Vector`1&lt;float64&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.ConditionalSelect(System.Numerics.Vector{System.Int64},System.Numerics.Vector{System.Double},System.Numerics.Vector{System.Double})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConditionalSelect (condition As Vector(Of Long), left As Vector(Of Double), right As Vector(Of Double)) As Vector(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;double&gt; ConditionalSelect(System::Numerics::Vector&lt;long&gt; condition, System::Numerics::Vector&lt;double&gt; left, System::Numerics::Vector&lt;double&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Numerics.Vector&lt;System.Int64&gt;" />
        <Parameter Name="left" Type="System.Numerics.Vector&lt;System.Double&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;System.Double&gt;" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="82bfe-186">Wektor integralną maski, używany do wyboru dysku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-186">The integral mask vector used to drive selection.</span>
          </span>
        </param>
        <param name="left">
          <span data-ttu-id="82bfe-187">Pierwszy wektorze źródłowym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-187">The first source vector.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-188">Drugi wektorze źródłowym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-188">The second source vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-189">Tworzy nowy wektor podwójnej precyzji z elementami wybrane między dwoma wektorami określonego źródła podwójnej precyzji oparte na wektor integralną maski.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-189">Creates a new double-precision vector with elements selected between two specified double-precision source vectors based on an integral mask vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-190">Nowy wektor z wybrane elementy na podstawie maski.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-190">The new vector with elements selected based on the mask.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConditionalSelect&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; ConditionalSelect&lt;T&gt; (System.Numerics.Vector&lt;T&gt; condition, System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;!!T&gt; ConditionalSelect&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; condition, valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.ConditionalSelect``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConditionalSelect(Of T As Structure) (condition As Vector(Of T), left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;T&gt; ConditionalSelect(System::Numerics::Vector&lt;T&gt; condition, System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-191">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-191">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-192">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-192">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="condition">
          <span data-ttu-id="82bfe-193">Wektor integralną maski, używany do wyboru dysku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-193">The integral mask vector used to drive selection.</span>
          </span>
        </param>
        <param name="left">
          <span data-ttu-id="82bfe-194">Pierwszy wektorze źródłowym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-194">The first source vector.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-195">Drugi wektorze źródłowym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-195">The second source vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-196">Tworzy nowy wektor określonego typu z elementami wybrane między dwoma wektorami określone źródło tego samego typu oparte na wektor integralną maski.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-196">Creates a new vector of a specified type with elements selected between two specified source vectors of the same type based on an integral mask vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-197">Nowy wektor z wybrane elementy na podstawie maski.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-197">The new vector with elements selected based on the mask.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertToDouble">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;double&gt; ConvertToDouble (System.Numerics.Vector&lt;long&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;float64&gt; ConvertToDouble(valuetype System.Numerics.Vector`1&lt;int64&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.ConvertToDouble(System.Numerics.Vector{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertToDouble (value As Vector(Of Long)) As Vector(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;double&gt; ConvertToDouble(System::Numerics::Vector&lt;long&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertToDouble">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;double&gt; ConvertToDouble (System.Numerics.Vector&lt;ulong&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;float64&gt; ConvertToDouble(valuetype System.Numerics.Vector`1&lt;unsigned int64&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.ConvertToDouble(System.Numerics.Vector{System.UInt64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertToDouble (value As Vector(Of ULong)) As Vector(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;double&gt; ConvertToDouble(System::Numerics::Vector&lt;System::UInt64&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;System.UInt64&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertToInt32">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;int&gt; ConvertToInt32 (System.Numerics.Vector&lt;float&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int32&gt; ConvertToInt32(valuetype System.Numerics.Vector`1&lt;float32&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.ConvertToInt32(System.Numerics.Vector{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertToInt32 (value As Vector(Of Single)) As Vector(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;int&gt; ConvertToInt32(System::Numerics::Vector&lt;float&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertToInt64">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;long&gt; ConvertToInt64 (System.Numerics.Vector&lt;double&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int64&gt; ConvertToInt64(valuetype System.Numerics.Vector`1&lt;float64&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.ConvertToInt64(System.Numerics.Vector{System.Double})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertToInt64 (value As Vector(Of Double)) As Vector(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;long&gt; ConvertToInt64(System::Numerics::Vector&lt;double&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;System.Double&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertToSingle">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;float&gt; ConvertToSingle (System.Numerics.Vector&lt;int&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;float32&gt; ConvertToSingle(valuetype System.Numerics.Vector`1&lt;int32&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.ConvertToSingle(System.Numerics.Vector{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertToSingle (value As Vector(Of Integer)) As Vector(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;float&gt; ConvertToSingle(System::Numerics::Vector&lt;int&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertToSingle">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;float&gt; ConvertToSingle (System.Numerics.Vector&lt;uint&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;float32&gt; ConvertToSingle(valuetype System.Numerics.Vector`1&lt;unsigned int32&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.ConvertToSingle(System.Numerics.Vector{System.UInt32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertToSingle (value As Vector(Of UInteger)) As Vector(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;float&gt; ConvertToSingle(System::Numerics::Vector&lt;System::UInt32&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;System.UInt32&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertToUInt32">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;uint&gt; ConvertToUInt32 (System.Numerics.Vector&lt;float&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;unsigned int32&gt; ConvertToUInt32(valuetype System.Numerics.Vector`1&lt;float32&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.ConvertToUInt32(System.Numerics.Vector{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertToUInt32 (value As Vector(Of Single)) As Vector(Of UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;System::UInt32&gt; ConvertToUInt32(System::Numerics::Vector&lt;float&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.UInt32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertToUInt64">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;ulong&gt; ConvertToUInt64 (System.Numerics.Vector&lt;double&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;unsigned int64&gt; ConvertToUInt64(valuetype System.Numerics.Vector`1&lt;float64&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.ConvertToUInt64(System.Numerics.Vector{System.Double})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertToUInt64 (value As Vector(Of Double)) As Vector(Of ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;System::UInt64&gt; ConvertToUInt64(System::Numerics::Vector&lt;double&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.UInt64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;System.Double&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; Divide&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;!!T&gt; Divide&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Divide``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide(Of T As Structure) (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;T&gt; Divide(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-198">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-198">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-199">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-199">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-200">Pierwszy wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-200">The first vector.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-201">Drugi wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-201">The second vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-202">Zwraca nowy wektor, których wartości są wynik dzielenia elementów wektora pierwszy przez odpowiednie elementy w drugim wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-202">Returns a new vector whose values are the result of dividing the first vector's elements by the corresponding elements in the second vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-203">Podzielony wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-203">The divided vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dot&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Dot&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Dot&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Dot``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dot(Of T As Structure) (left As Vector(Of T), right As Vector(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static T Dot(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-204">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-204">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-205">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-205">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-206">Pierwszy wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-206">The first vector.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-207">Drugi wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-207">The second vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-208">Zwraca iloczyn dwóch wektorów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-208">Returns the dot product of two vectors.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-209">Skalarnego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-209">The dot product.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;long&gt; Equals (System.Numerics.Vector&lt;double&gt; left, System.Numerics.Vector&lt;double&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int64&gt; Equals(valuetype System.Numerics.Vector`1&lt;float64&gt; left, valuetype System.Numerics.Vector`1&lt;float64&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Equals(System.Numerics.Vector{System.Double},System.Numerics.Vector{System.Double})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (left As Vector(Of Double), right As Vector(Of Double)) As Vector(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;long&gt; Equals(System::Numerics::Vector&lt;double&gt; left, System::Numerics::Vector&lt;double&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;System.Double&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;System.Double&gt;" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="82bfe-210">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-210">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-211">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-211">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-212">Zwraca nowy wektor całkowite, której elementy sygnału, czy elementy w dwóch wektorów o podwójnej precyzji określonego są takie same.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-212">Returns a new integral vector whose elements signal whether the elements in two specified double-precision vectors are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-213">Wynikowa wektor wartości całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-213">The resulting integral vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;int&gt; Equals (System.Numerics.Vector&lt;int&gt; left, System.Numerics.Vector&lt;int&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int32&gt; Equals(valuetype System.Numerics.Vector`1&lt;int32&gt; left, valuetype System.Numerics.Vector`1&lt;int32&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Equals(System.Numerics.Vector{System.Int32},System.Numerics.Vector{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (left As Vector(Of Integer), right As Vector(Of Integer)) As Vector(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;int&gt; Equals(System::Numerics::Vector&lt;int&gt; left, System::Numerics::Vector&lt;int&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;System.Int32&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="82bfe-214">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-214">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-215">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-215">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-216">Zwraca nowy wektor całkowite, której elementy sygnału, czy elementy w dwóch wektorów integralną określonego są takie same.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-216">Returns a new integral vector whose elements signal whether the elements in two specified integral vectors are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-217">Wynikowa wektor wartości całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-217">The resulting integral vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;long&gt; Equals (System.Numerics.Vector&lt;long&gt; left, System.Numerics.Vector&lt;long&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int64&gt; Equals(valuetype System.Numerics.Vector`1&lt;int64&gt; left, valuetype System.Numerics.Vector`1&lt;int64&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Equals(System.Numerics.Vector{System.Int64},System.Numerics.Vector{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (left As Vector(Of Long), right As Vector(Of Long)) As Vector(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;long&gt; Equals(System::Numerics::Vector&lt;long&gt; left, System::Numerics::Vector&lt;long&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;System.Int64&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="82bfe-218">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-218">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-219">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-219">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-220">Zwraca nowy wektor, której elementy sygnału, czy elementy w dwóch wektorów określonego długich liczb całkowitych są takie same.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-220">Returns a new vector whose elements signal whether the elements in two specified long integer vectors are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-221">Wynikowa wektor długich liczb całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-221">The resulting long integer vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;int&gt; Equals (System.Numerics.Vector&lt;float&gt; left, System.Numerics.Vector&lt;float&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int32&gt; Equals(valuetype System.Numerics.Vector`1&lt;float32&gt; left, valuetype System.Numerics.Vector`1&lt;float32&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Equals(System.Numerics.Vector{System.Single},System.Numerics.Vector{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (left As Vector(Of Single), right As Vector(Of Single)) As Vector(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;int&gt; Equals(System::Numerics::Vector&lt;float&gt; left, System::Numerics::Vector&lt;float&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;System.Single&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="82bfe-222">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-222">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-223">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-223">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-224">Zwraca nowy wektor całkowite, której elementy sygnału, czy elementy w dwóch wektorów o pojedynczej precyzji określonego są takie same.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-224">Returns a new integral vector whose elements signal whether the elements in two specified single-precision vectors are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-225">Wynikowa wektor wartości całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-225">The resulting integral vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; Equals&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;!!T&gt; Equals&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Equals``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals(Of T As Structure) (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;T&gt; Equals(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-226">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-226">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-227">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-227">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-228">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-228">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-229">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-229">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-230">Zwraca nowy wektor o określonym typie, której elementy sygnału, czy elementy w dwóch wektorów określonego tego samego typu są takie same.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-230">Returns a new vector of a specified type whose elements signal whether the elements in two specified vectors of the same type are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-231">Wynikowa wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-231">The resulting vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EqualsAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool EqualsAll&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EqualsAll&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.EqualsAll``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EqualsAll(Of T As Structure) (left As Vector(Of T), right As Vector(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static bool EqualsAll(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-232">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-232">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-233">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-233">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-234">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-234">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-235">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-235">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-236">Zwraca wartość wskazującą, czy każda para elementów w danym wektory jest taki sam.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-236">Returns a value that indicates whether each pair of elements in the given vectors is equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-237">
            <see langword="true" /> Jeśli wszystkie elementy w <paramref name="left" /> i <paramref name="right" /> są równe; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-237">
              <see langword="true" /> if all elements in <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EqualsAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool EqualsAny&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EqualsAny&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.EqualsAny``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EqualsAny(Of T As Structure) (left As Vector(Of T), right As Vector(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static bool EqualsAny(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-238">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-238">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-239">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-239">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-240">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-240">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-241">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-241">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-242">Zwraca wartość wskazującą, czy jakiejkolwiek parze pojedynczego elementów w danym wektory jest taki sam.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-242">Returns a value that indicates whether any single pair of elements in the given vectors is equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-243">
            <see langword="true" /> Jeśli dowolny element pary w <paramref name="left" /> i <paramref name="right" /> jest taki sam, a w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-243">
              <see langword="true" /> if any element pair in <paramref name="left" /> and <paramref name="right" /> is equal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;long&gt; GreaterThan (System.Numerics.Vector&lt;double&gt; left, System.Numerics.Vector&lt;double&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int64&gt; GreaterThan(valuetype System.Numerics.Vector`1&lt;float64&gt; left, valuetype System.Numerics.Vector`1&lt;float64&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.GreaterThan(System.Numerics.Vector{System.Double},System.Numerics.Vector{System.Double})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Vector(Of Double), right As Vector(Of Double)) As Vector(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;long&gt; GreaterThan(System::Numerics::Vector&lt;double&gt; left, System::Numerics::Vector&lt;double&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;System.Double&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;System.Double&gt;" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="82bfe-244">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-244">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-245">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-245">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-246">Zwraca nowy wektor całkowite, której elementy sygnału, czy elementy w jeden wektor zmiennoprzecinkowe podwójnej precyzji są większe niż ich odpowiednich elementów w drugim wektor zmiennoprzecinkowe podwójnej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-246">Returns a new integral vector whose elements signal whether the elements in one double-precision floating-point vector are greater than their corresponding elements in a second double-precision floating-point vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-247">Wynikowa wektor wartości całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-247">The resulting integral vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;int&gt; GreaterThan (System.Numerics.Vector&lt;int&gt; left, System.Numerics.Vector&lt;int&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int32&gt; GreaterThan(valuetype System.Numerics.Vector`1&lt;int32&gt; left, valuetype System.Numerics.Vector`1&lt;int32&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.GreaterThan(System.Numerics.Vector{System.Int32},System.Numerics.Vector{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Vector(Of Integer), right As Vector(Of Integer)) As Vector(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;int&gt; GreaterThan(System::Numerics::Vector&lt;int&gt; left, System::Numerics::Vector&lt;int&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;System.Int32&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="82bfe-248">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-248">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-249">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-249">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-250">Zwraca nowy wektor integralną, której elementy sygnału, czy elementy w jeden wektor integralną są większe niż ich odpowiednich elementów w drugi wektor wartości całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-250">Returns a new integral vector whose elements signal whether the elements in one integral vector are greater than their corresponding elements in a second integral vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-251">Wynikowa wektor wartości całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-251">The resulting integral vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;long&gt; GreaterThan (System.Numerics.Vector&lt;long&gt; left, System.Numerics.Vector&lt;long&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int64&gt; GreaterThan(valuetype System.Numerics.Vector`1&lt;int64&gt; left, valuetype System.Numerics.Vector`1&lt;int64&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.GreaterThan(System.Numerics.Vector{System.Int64},System.Numerics.Vector{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Vector(Of Long), right As Vector(Of Long)) As Vector(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;long&gt; GreaterThan(System::Numerics::Vector&lt;long&gt; left, System::Numerics::Vector&lt;long&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;System.Int64&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="82bfe-252">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-252">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-253">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-253">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-254">Zwraca nowy wektor długich liczb całkowitych, której elementy sygnału, czy elementy w jeden wektor długich liczb całkowitych są większe niż ich odpowiednich elementów w drugim wektor długich liczb całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-254">Returns a new long integer vector whose elements signal whether the elements in one long integer vector are greater than their corresponding elements in a second long integer vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-255">Wynikowa wektor długich liczb całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-255">The resulting long integer vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;int&gt; GreaterThan (System.Numerics.Vector&lt;float&gt; left, System.Numerics.Vector&lt;float&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int32&gt; GreaterThan(valuetype System.Numerics.Vector`1&lt;float32&gt; left, valuetype System.Numerics.Vector`1&lt;float32&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.GreaterThan(System.Numerics.Vector{System.Single},System.Numerics.Vector{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Vector(Of Single), right As Vector(Of Single)) As Vector(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;int&gt; GreaterThan(System::Numerics::Vector&lt;float&gt; left, System::Numerics::Vector&lt;float&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;System.Single&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="82bfe-256">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-256">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-257">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-257">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-258">Zwraca nowy wektor całkowite, której elementy sygnału, czy elementy w jeden wektor zmiennoprzecinkowych pojedynczej precyzji są większe niż ich odpowiednich elementów w drugiej wektorem liczb zmiennoprzecinkowych pojedynczej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-258">Returns a new integral vector whose elements signal whether the elements in one single-precision floating-point vector are greater than their corresponding elements in a second single-precision floating-point vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-259">Wynikowa wektor wartości całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-259">The resulting integral vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; GreaterThan&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;!!T&gt; GreaterThan&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.GreaterThan``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan(Of T As Structure) (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;T&gt; GreaterThan(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-260">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-260">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-261">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-261">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-262">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-262">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-263">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-263">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-264">Zwraca nowy wektor, której elementy sygnału, czy elementy w jeden wektor o określonym typie są większe niż ich odpowiednich elementów w drugim wektorów o tym samym czasie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-264">Returns a new vector whose elements signal whether the elements in one vector of a specified type are greater than their corresponding elements in the second vector of the same time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-265">Wynikowa wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-265">The resulting vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool GreaterThanAll&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GreaterThanAll&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.GreaterThanAll``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanAll(Of T As Structure) (left As Vector(Of T), right As Vector(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static bool GreaterThanAll(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-266">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-266">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-267">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-267">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-268">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-268">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-269">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-269">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-270">Zwraca wartość wskazującą, czy wszystkie elementy w pierwszym wektorze są większe niż odpowiednie elementy w drugim wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-270">Returns a value that indicates whether all elements in the first vector are greater than the corresponding elements in the second vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-271">
            <see langword="true" /> Jeśli wszystkie elementy w <paramref name="left" /> są większe niż odpowiednie elementy w <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-271">
              <see langword="true" /> if all elements in <paramref name="left" /> are greater than the corresponding elements in <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool GreaterThanAny&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GreaterThanAny&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.GreaterThanAny``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanAny(Of T As Structure) (left As Vector(Of T), right As Vector(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static bool GreaterThanAny(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-272">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-272">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-273">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-273">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-274">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-274">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-275">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-275">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-276">Zwraca wartość wskazującą, czy dowolny element w pierwszym wektorze jest większy niż odpowiadający mu element w drugim wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-276">Returns a value that indicates whether any element in the first vector is greater than the corresponding element in the second vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-277">
            <see langword="true" /> Jeśli dowolny element w <paramref name="left" /> jest większa niż odpowiadający mu element w <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-277">
              <see langword="true" /> if any element in <paramref name="left" /> is greater than the corresponding element in <paramref name="right" />; otherwise,  <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;long&gt; GreaterThanOrEqual (System.Numerics.Vector&lt;double&gt; left, System.Numerics.Vector&lt;double&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int64&gt; GreaterThanOrEqual(valuetype System.Numerics.Vector`1&lt;float64&gt; left, valuetype System.Numerics.Vector`1&lt;float64&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.GreaterThanOrEqual(System.Numerics.Vector{System.Double},System.Numerics.Vector{System.Double})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Vector(Of Double), right As Vector(Of Double)) As Vector(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;long&gt; GreaterThanOrEqual(System::Numerics::Vector&lt;double&gt; left, System::Numerics::Vector&lt;double&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;System.Double&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;System.Double&gt;" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="82bfe-278">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-278">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-279">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-279">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-280">Zwraca nowy wektor całkowite, której elementy sygnału, czy elementy w jeden z wektorów są większe niż lub równa ich odpowiednich elementów w drugim wektor zmiennoprzecinkowe podwójnej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-280">Returns a new integral vector whose elements signal whether the elements in one vector are greater than or equal to their corresponding elements in the second double-precision floating-point vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-281">Wynikowa wektor wartości całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-281">The resulting integral vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;int&gt; GreaterThanOrEqual (System.Numerics.Vector&lt;int&gt; left, System.Numerics.Vector&lt;int&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int32&gt; GreaterThanOrEqual(valuetype System.Numerics.Vector`1&lt;int32&gt; left, valuetype System.Numerics.Vector`1&lt;int32&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.GreaterThanOrEqual(System.Numerics.Vector{System.Int32},System.Numerics.Vector{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Vector(Of Integer), right As Vector(Of Integer)) As Vector(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;int&gt; GreaterThanOrEqual(System::Numerics::Vector&lt;int&gt; left, System::Numerics::Vector&lt;int&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;System.Int32&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="82bfe-282">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-282">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-283">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-283">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-284">Zwraca nowy wektor całkowite, której elementy sygnału, czy elementy w jeden wektor integralną są większe niż lub równa ich odpowiednich elementów drugi wektor integralną.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-284">Returns a new integral vector whose elements signal whether the elements in one integral vector are greater than or equal to their corresponding elements in the second integral vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-285">Wynikowa wektor wartości całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-285">The resulting integral vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;long&gt; GreaterThanOrEqual (System.Numerics.Vector&lt;long&gt; left, System.Numerics.Vector&lt;long&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int64&gt; GreaterThanOrEqual(valuetype System.Numerics.Vector`1&lt;int64&gt; left, valuetype System.Numerics.Vector`1&lt;int64&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.GreaterThanOrEqual(System.Numerics.Vector{System.Int64},System.Numerics.Vector{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Vector(Of Long), right As Vector(Of Long)) As Vector(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;long&gt; GreaterThanOrEqual(System::Numerics::Vector&lt;long&gt; left, System::Numerics::Vector&lt;long&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;System.Int64&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="82bfe-286">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-286">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-287">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-287">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-288">Zwraca nowy wektor długich liczb całkowitych, której elementy sygnału, czy elementy w jeden wektor długich liczb całkowitych są większe niż lub równa ich odpowiednich elementów w drugim wektor długich liczb całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-288">Returns a new long integer vector whose elements signal whether the elements in one long integer vector are greater than or equal to their corresponding elements in the second long integer vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-289">Wynikowa wektor długich liczb całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-289">The resulting long integer vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;int&gt; GreaterThanOrEqual (System.Numerics.Vector&lt;float&gt; left, System.Numerics.Vector&lt;float&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int32&gt; GreaterThanOrEqual(valuetype System.Numerics.Vector`1&lt;float32&gt; left, valuetype System.Numerics.Vector`1&lt;float32&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.GreaterThanOrEqual(System.Numerics.Vector{System.Single},System.Numerics.Vector{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Vector(Of Single), right As Vector(Of Single)) As Vector(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;int&gt; GreaterThanOrEqual(System::Numerics::Vector&lt;float&gt; left, System::Numerics::Vector&lt;float&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;System.Single&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="82bfe-290">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-290">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-291">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-291">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-292">Zwraca nowy wektor całkowite, której elementy sygnału, czy elementy w jeden z wektorów są większe niż lub równa ich odpowiednich elementów w wektorze drugi zmiennoprzecinkowych pojedynczej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-292">Returns a new integral vector whose elements signal whether the elements in one vector are greater than or equal to their corresponding elements in the single-precision floating-point second vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-293">Wynikowa wektor wartości całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-293">The resulting integral vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; GreaterThanOrEqual&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;!!T&gt; GreaterThanOrEqual&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.GreaterThanOrEqual``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual(Of T As Structure) (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;T&gt; GreaterThanOrEqual(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-294">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-294">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-295">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-295">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-296">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-296">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-297">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-297">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-298">Zwraca nowy wektor, której elementy sygnału, czy elementy w jeden wektor o określonym typie są większe niż lub równa ich odpowiednich elementów w wektorze drugi tego samego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-298">Returns a new vector whose elements signal whether the elements in one vector of a specified type are greater than or equal to their corresponding elements in the second vector of the same type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-299">Wynikowa wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-299">The resulting vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqualAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool GreaterThanOrEqualAll&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GreaterThanOrEqualAll&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.GreaterThanOrEqualAll``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqualAll(Of T As Structure) (left As Vector(Of T), right As Vector(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static bool GreaterThanOrEqualAll(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-300">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-300">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-301">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-301">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-302">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-302">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-303">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-303">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-304">Zwraca wartość wskazującą, czy wszystkie elementy w pierwszym wektorze są większe niż lub równa odpowiednie elementy drugi wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-304">Returns a value that indicates whether all elements in the first vector are greater than or equal to all the corresponding elements in the second vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-305">
            <see langword="true" /> Jeśli wszystkie elementy w <paramref name="left" /> są większe niż lub równe odpowiednie elementy w <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-305">
              <see langword="true" /> if all elements in <paramref name="left" /> are greater than or equal to the corresponding elements in <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqualAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool GreaterThanOrEqualAny&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GreaterThanOrEqualAny&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.GreaterThanOrEqualAny``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqualAny(Of T As Structure) (left As Vector(Of T), right As Vector(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static bool GreaterThanOrEqualAny(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-306">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-306">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-307">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-307">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-308">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-308">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-309">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-309">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-310">Zwraca wartość wskazującą, czy dowolny element w pierwszym wektorze jest większa lub równa odpowiadający mu element w drugim wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-310">Returns a value that indicates whether any element in the first vector is greater than or equal to the corresponding element in the second vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-311">
            <see langword="true" /> Jeśli dowolny element w <paramref name="left" /> jest większa niż lub równa odpowiadający mu element w <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-311">
              <see langword="true" /> if any element in <paramref name="left" /> is greater than or equal to the corresponding element in <paramref name="right" />; otherwise,  <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHardwareAccelerated">
      <MemberSignature Language="C#" Value="public static bool IsHardwareAccelerated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsHardwareAccelerated" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Vector.IsHardwareAccelerated" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsHardwareAccelerated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsHardwareAccelerated { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="82bfe-312">Pobiera wartość wskazującą, czy operacje wektor podlegają przyspieszanie sprzętowe za pośrednictwem JIT wewnętrznej pomocy technicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-312">Gets a value that indicates whether vector operations are subject to hardware acceleration through JIT intrinsic support.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="82bfe-313">
            <see langword="true" /> Jeśli operacje wektor podlegają przyspieszanie sprzętowe; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-313">
              <see langword="true" /> if vector operations are subject to hardware acceleration; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="82bfe-314">Operacje wektor podlegają przyspieszanie sprzętowe w systemach, które obsługują pojedynczej instrukcji, instrukcje wielu danych (SIMD) i kompilatora just in time RyiJIT jest używana do kompilowania kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="82bfe-314">Vector operations are subject to hardware acceleration on systems that support Single Instruction, Multiple Data (SIMD) instructions and the RyiJIT just-in-time compiler is used to compile managed code.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;long&gt; LessThan (System.Numerics.Vector&lt;double&gt; left, System.Numerics.Vector&lt;double&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int64&gt; LessThan(valuetype System.Numerics.Vector`1&lt;float64&gt; left, valuetype System.Numerics.Vector`1&lt;float64&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.LessThan(System.Numerics.Vector{System.Double},System.Numerics.Vector{System.Double})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Vector(Of Double), right As Vector(Of Double)) As Vector(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;long&gt; LessThan(System::Numerics::Vector&lt;double&gt; left, System::Numerics::Vector&lt;double&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;System.Double&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;System.Double&gt;" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="82bfe-315">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-315">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-316">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-316">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-317">Zwraca nowy wektor całkowite, której elementy sygnału, czy elementy w jeden wektor zmiennoprzecinkowe podwójnej precyzji są mniejsze niż ich odpowiednich elementów w drugim wektor zmiennoprzecinkowe podwójnej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-317">Returns a new integral vector whose elements signal whether the elements in one double-precision floating-point vector are less than their corresponding elements in a second double-precision floating-point vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-318">Wynikowa wektor wartości całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-318">The resulting integral vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;int&gt; LessThan (System.Numerics.Vector&lt;int&gt; left, System.Numerics.Vector&lt;int&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int32&gt; LessThan(valuetype System.Numerics.Vector`1&lt;int32&gt; left, valuetype System.Numerics.Vector`1&lt;int32&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.LessThan(System.Numerics.Vector{System.Int32},System.Numerics.Vector{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Vector(Of Integer), right As Vector(Of Integer)) As Vector(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;int&gt; LessThan(System::Numerics::Vector&lt;int&gt; left, System::Numerics::Vector&lt;int&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;System.Int32&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="82bfe-319">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-319">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-320">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-320">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-321">Zwraca nowy wektor integralną, której elementy sygnału, czy elementy w jeden wektor integralną są mniejsze niż ich odpowiednich elementów w drugi wektor wartości całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-321">Returns a new integral vector whose elements signal whether the elements in one integral vector are less than their corresponding elements in a second integral vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-322">Wynikowa wektor wartości całkowitych</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-322">The resulting integral vector</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;long&gt; LessThan (System.Numerics.Vector&lt;long&gt; left, System.Numerics.Vector&lt;long&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int64&gt; LessThan(valuetype System.Numerics.Vector`1&lt;int64&gt; left, valuetype System.Numerics.Vector`1&lt;int64&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.LessThan(System.Numerics.Vector{System.Int64},System.Numerics.Vector{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Vector(Of Long), right As Vector(Of Long)) As Vector(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;long&gt; LessThan(System::Numerics::Vector&lt;long&gt; left, System::Numerics::Vector&lt;long&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;System.Int64&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="82bfe-323">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-323">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-324">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-324">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-325">Zwraca nowy wektor długich liczb całkowitych, której elementy sygnału, czy elementów w wektorze jeden długich liczb całkowitych jest mniejsza niż ich odpowiednich elementów w drugim wektor długich liczb całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-325">Returns a new long integer vector whose elements signal whether the elements in one long integer vector are less than their corresponding elements in a second long integer vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-326">Wynikowa wektor długich liczb całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-326">The resulting long integer vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;int&gt; LessThan (System.Numerics.Vector&lt;float&gt; left, System.Numerics.Vector&lt;float&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int32&gt; LessThan(valuetype System.Numerics.Vector`1&lt;float32&gt; left, valuetype System.Numerics.Vector`1&lt;float32&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.LessThan(System.Numerics.Vector{System.Single},System.Numerics.Vector{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Vector(Of Single), right As Vector(Of Single)) As Vector(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;int&gt; LessThan(System::Numerics::Vector&lt;float&gt; left, System::Numerics::Vector&lt;float&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;System.Single&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="82bfe-327">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-327">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-328">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-328">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-329">Zwraca nowy wektor całkowite, której elementy sygnału, czy elementy w jeden wektor pojedynczej precyzji są mniejsze niż ich odpowiednich elementów w drugim wektor pojedynczej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-329">Returns a new integral vector whose elements signal whether the elements in one single-precision vector are less than their corresponding elements in a second single-precision vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-330">Wynikowa wektor wartości całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-330">The resulting integral vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; LessThan&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;!!T&gt; LessThan&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.LessThan``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan(Of T As Structure) (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;T&gt; LessThan(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-331">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-331">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-332">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-332">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-333">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-333">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-334">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-334">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-335">Zwraca nowy wektor o określonym typie, której elementy sygnału, czy elementy w jeden z wektorów są mniejsze niż ich odpowiednich elementów w wektorze drugi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-335">Returns a new vector of a specified type whose elements signal whether the elements in one vector are less than their corresponding elements in the second vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-336">Wynikowa wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-336">The resulting vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool LessThanAll&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool LessThanAll&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.LessThanAll``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanAll(Of T As Structure) (left As Vector(Of T), right As Vector(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static bool LessThanAll(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-337">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-337">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-338">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-338">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-339">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-339">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-340">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-340">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-341">Zwraca wartość wskazującą, czy wszystkie elementy w pierwszym wektorze są mniejsze niż ich odpowiednich elementów w wektorze drugi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-341">Returns a value that indicates whether all of the elements in the first vector are less than their corresponding elements in the second vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-342">
            <see langword="true" /> Jeśli wszystkie elementy w <paramref name="left" /> są mniejsze niż odpowiednie elementy w <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-342">
              <see langword="true" /> if all of the elements in <paramref name="left" /> are less than the corresponding elements in <paramref name="right" />; otherwise,  <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool LessThanAny&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool LessThanAny&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.LessThanAny``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanAny(Of T As Structure) (left As Vector(Of T), right As Vector(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static bool LessThanAny(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-343">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-343">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-344">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-344">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-345">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-345">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-346">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-346">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-347">Zwraca wartość wskazującą, czy dowolny element w pierwszym wektorze jest mniejsza niż odpowiadający mu element w drugim wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-347">Returns a value that indicates whether any element in the first vector is less than the corresponding element in the second vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-348">
            <see langword="true" /> Jeśli dowolny element w <paramref name="left" /> jest mniejsza niż odpowiadający mu element w <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-348">
              <see langword="true" /> if any element in <paramref name="left" /> is less than the corresponding element in <paramref name="right" />; otherwise,  <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;long&gt; LessThanOrEqual (System.Numerics.Vector&lt;double&gt; left, System.Numerics.Vector&lt;double&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int64&gt; LessThanOrEqual(valuetype System.Numerics.Vector`1&lt;float64&gt; left, valuetype System.Numerics.Vector`1&lt;float64&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.LessThanOrEqual(System.Numerics.Vector{System.Double},System.Numerics.Vector{System.Double})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Vector(Of Double), right As Vector(Of Double)) As Vector(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;long&gt; LessThanOrEqual(System::Numerics::Vector&lt;double&gt; left, System::Numerics::Vector&lt;double&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;System.Double&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;System.Double&gt;" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="82bfe-349">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-349">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-350">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-350">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-351">Zwraca nowy wektor całkowite, której elementy sygnału, czy elementy w jeden wektor zmiennoprzecinkowe podwójnej precyzji są mniejsze lub równe ich odpowiednich elementów w wektorze zmiennoprzecinkowe drugi podwójnej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-351">Returns a new integral vector whose elements signal whether the elements in one double-precision floating-point vector are less than or equal to their corresponding elements in a second double-precision floating-point vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-352">Wynikowa wektor wartości całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-352">The resulting integral vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;int&gt; LessThanOrEqual (System.Numerics.Vector&lt;int&gt; left, System.Numerics.Vector&lt;int&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int32&gt; LessThanOrEqual(valuetype System.Numerics.Vector`1&lt;int32&gt; left, valuetype System.Numerics.Vector`1&lt;int32&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.LessThanOrEqual(System.Numerics.Vector{System.Int32},System.Numerics.Vector{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Vector(Of Integer), right As Vector(Of Integer)) As Vector(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;int&gt; LessThanOrEqual(System::Numerics::Vector&lt;int&gt; left, System::Numerics::Vector&lt;int&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;System.Int32&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="82bfe-353">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-353">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-354">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-354">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-355">Zwraca nowy wektor całkowite, której elementy sygnału, czy elementy w jeden wektor integralną są mniejsze lub równe ich odpowiednich elementów w drugim wektorze całkowite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-355">Returns a new integral vector whose elements signal whether the elements in one integral vector are less than or equal to their corresponding elements in a second integral vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-356">Wynikowa wektor wartości całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-356">The resulting integral vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;long&gt; LessThanOrEqual (System.Numerics.Vector&lt;long&gt; left, System.Numerics.Vector&lt;long&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int64&gt; LessThanOrEqual(valuetype System.Numerics.Vector`1&lt;int64&gt; left, valuetype System.Numerics.Vector`1&lt;int64&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.LessThanOrEqual(System.Numerics.Vector{System.Int64},System.Numerics.Vector{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Vector(Of Long), right As Vector(Of Long)) As Vector(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;long&gt; LessThanOrEqual(System::Numerics::Vector&lt;long&gt; left, System::Numerics::Vector&lt;long&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;System.Int64&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="82bfe-357">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-357">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-358">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-358">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-359">Zwraca nowy wektor długich liczb całkowitych, której elementy sygnału, czy elementy w jeden długich liczb całkowitych wektora jest mniejsza lub równa ich odpowiednich elementów w wektorze drugi długich liczb całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-359">Returns a new long integer vector whose elements signal whether the elements in one long integer vector are less or equal to their corresponding elements in a second long integer vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-360">Wynikowa wektor długich liczb całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-360">The resulting long integer vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;int&gt; LessThanOrEqual (System.Numerics.Vector&lt;float&gt; left, System.Numerics.Vector&lt;float&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int32&gt; LessThanOrEqual(valuetype System.Numerics.Vector`1&lt;float32&gt; left, valuetype System.Numerics.Vector`1&lt;float32&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.LessThanOrEqual(System.Numerics.Vector{System.Single},System.Numerics.Vector{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Vector(Of Single), right As Vector(Of Single)) As Vector(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;int&gt; LessThanOrEqual(System::Numerics::Vector&lt;float&gt; left, System::Numerics::Vector&lt;float&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;System.Single&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="82bfe-361">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-361">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-362">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-362">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-363">Zwraca nowy wektor całkowite, której elementy sygnału, czy elementy w jeden wektor zmiennoprzecinkowych pojedynczej precyzji są mniejsze lub równe ich odpowiednich elementów w wektorze zmiennoprzecinkowe drugi pojedynczej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-363">Returns a new integral vector whose elements signal whether the elements in one single-precision floating-point vector are less than or equal to their corresponding elements in a second single-precision floating-point vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-364">Wynikowa wektor wartości całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-364">The resulting integral vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; LessThanOrEqual&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;!!T&gt; LessThanOrEqual&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.LessThanOrEqual``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual(Of T As Structure) (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;T&gt; LessThanOrEqual(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-365">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-365">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-366">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-366">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-367">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-367">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-368">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-368">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-369">Zwraca nowy wektor, której elementy sygnału, czy elementy w jeden z wektorów są mniejsze lub równe ich odpowiednich elementów w wektorze drugiego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-369">Returns a new vector whose elements signal whether the elements in one vector are less than or equal to their corresponding elements in the second vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-370">Wynikowa wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-370">The resulting vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqualAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool LessThanOrEqualAll&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool LessThanOrEqualAll&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.LessThanOrEqualAll``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqualAll(Of T As Structure) (left As Vector(Of T), right As Vector(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static bool LessThanOrEqualAll(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-371">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-371">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-372">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-372">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-373">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-373">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-374">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-374">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-375">Zwraca wartość wskazującą, czy wszystkie elementy w pierwszym wektorze są mniejsze lub równe ich odpowiednich elementów w wektorze drugiego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-375">Returns a value that indicates whether all elements in the first vector are less than or equal to their corresponding elements in the second vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-376">
            <see langword="true" /> Jeśli wszystkie elementy w <paramref name="left" /> są mniejsze niż odpowiednie elementy w <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-376">
              <see langword="true" /> if all of the elements in <paramref name="left" /> are less than or equal to the corresponding elements in <paramref name="right" />; otherwise,  <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqualAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool LessThanOrEqualAny&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool LessThanOrEqualAny&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.LessThanOrEqualAny``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqualAny(Of T As Structure) (left As Vector(Of T), right As Vector(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static bool LessThanOrEqualAny(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-377">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-377">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-378">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-378">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-379">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-379">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-380">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-380">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-381">Zwraca wartość wskazującą, czy dowolny element w pierwszym wektorze jest mniejsza lub równa odpowiadający mu element w drugim wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-381">Returns a value that indicates whether any element in the first vector is less than or equal to the corresponding element in the second vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-382">
            <see langword="true" /> Jeśli dowolny element w <paramref name="left" /> jest mniejsza niż odpowiadający mu element w <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-382">
              <see langword="true" /> if any element in <paramref name="left" /> is less than or equal to the corresponding element in <paramref name="right" />; otherwise,  <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; Max&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;!!T&gt; Max&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Max``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max(Of T As Structure) (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;T&gt; Max(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-383">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-383">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-384">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-384">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-385">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-385">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-386">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-386">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-387">Zwraca nowy wektor, której elementy są maksymalną liczbę elementów w dwóch wektorów danego każda para.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-387">Returns a new vector whose elements are the maximum of each pair of elements in the two given vectors.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-388">Wektor maksymalny.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-388">The maximum vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; Min&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;!!T&gt; Min&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Min``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min(Of T As Structure) (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;T&gt; Min(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-389">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-389">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-390">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-390">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-391">Pierwszy wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-391">The first vector to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-392">Drugi wektorów do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-392">The second vector to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-393">Zwraca nowy wektor, której elementy są co najmniej każda para elementów w dwóch wektorów danego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-393">Returns a new vector whose elements are the minimum of each pair of elements in the two given vectors.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-394">Wektor minimalny.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-394">The minimum vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; Multiply&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;!!T&gt; Multiply&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Multiply``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply(Of T As Structure) (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;T&gt; Multiply(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-395">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-395">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-396">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-396">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-397">Pierwszy wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-397">The first vector.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-398">Drugi wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-398">The second vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-399">Zwraca nowy wektor, których wartości są produktu każda para elementów w dwóch wektorów określony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-399">Returns a new vector whose values are the product of each pair of elements in two specified vectors.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-400">Wektor produktu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-400">The product vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; Multiply&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, T right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;!!T&gt; Multiply&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, !!T right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Multiply``1(System.Numerics.Vector{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply(Of T As Structure) (left As Vector(Of T), right As T) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;T&gt; Multiply(System::Numerics::Vector&lt;T&gt; left, T right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-401">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-401">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-402">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-402">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-403">Wektor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-403">The vector.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-404">Wartość skalarną.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-404">The scalar value.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-405">Zwraca nowy wektor, których wartości są wartościami określony wektor, który każdego pomnożona przez wartość skalarną.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-405">Returns a new vector whose values are the values of a specified vector each multiplied by a scalar value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-406">Skalowanie wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-406">The scaled vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; Multiply&lt;T&gt; (T left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;!!T&gt; Multiply&lt;struct .ctor (class System.ValueType) T&gt;(!!T left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Multiply``1(``0,System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply(Of T As Structure) (left As T, right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;T&gt; Multiply(T left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="T" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-407">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-407">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-408">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-408">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-409">Wartość skalarną.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-409">The scalar value.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-410">Wektor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-410">The vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-411">Zwraca nowy wektora, których wartości są mnożenia wartości określony wektor wartość skalarną.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-411">Returns a new vector whose values are a scalar value multiplied by each of the values of a specified vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-412">Skalowanie wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-412">The scaled vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Narrow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;float&gt; Narrow (System.Numerics.Vector&lt;double&gt; source1, System.Numerics.Vector&lt;double&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;float32&gt; Narrow(valuetype System.Numerics.Vector`1&lt;float64&gt; source1, valuetype System.Numerics.Vector`1&lt;float64&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Narrow(System.Numerics.Vector{System.Double},System.Numerics.Vector{System.Double})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Narrow (source1 As Vector(Of Double), source2 As Vector(Of Double)) As Vector(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;float&gt; Narrow(System::Numerics::Vector&lt;double&gt; source1, System::Numerics::Vector&lt;double&gt; source2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source1" Type="System.Numerics.Vector&lt;System.Double&gt;" />
        <Parameter Name="source2" Type="System.Numerics.Vector&lt;System.Double&gt;" />
      </Parameters>
      <Docs>
        <param name="source1">To be added.</param>
        <param name="source2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Narrow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;sbyte&gt; Narrow (System.Numerics.Vector&lt;short&gt; source1, System.Numerics.Vector&lt;short&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int8&gt; Narrow(valuetype System.Numerics.Vector`1&lt;int16&gt; source1, valuetype System.Numerics.Vector`1&lt;int16&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Narrow(System.Numerics.Vector{System.Int16},System.Numerics.Vector{System.Int16})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Narrow (source1 As Vector(Of Short), source2 As Vector(Of Short)) As Vector(Of SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;System::SByte&gt; Narrow(System::Numerics::Vector&lt;short&gt; source1, System::Numerics::Vector&lt;short&gt; source2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.SByte&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source1" Type="System.Numerics.Vector&lt;System.Int16&gt;" />
        <Parameter Name="source2" Type="System.Numerics.Vector&lt;System.Int16&gt;" />
      </Parameters>
      <Docs>
        <param name="source1">To be added.</param>
        <param name="source2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Narrow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;short&gt; Narrow (System.Numerics.Vector&lt;int&gt; source1, System.Numerics.Vector&lt;int&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int16&gt; Narrow(valuetype System.Numerics.Vector`1&lt;int32&gt; source1, valuetype System.Numerics.Vector`1&lt;int32&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Narrow(System.Numerics.Vector{System.Int32},System.Numerics.Vector{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Narrow (source1 As Vector(Of Integer), source2 As Vector(Of Integer)) As Vector(Of Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;short&gt; Narrow(System::Numerics::Vector&lt;int&gt; source1, System::Numerics::Vector&lt;int&gt; source2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int16&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source1" Type="System.Numerics.Vector&lt;System.Int32&gt;" />
        <Parameter Name="source2" Type="System.Numerics.Vector&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="source1">To be added.</param>
        <param name="source2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Narrow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;int&gt; Narrow (System.Numerics.Vector&lt;long&gt; source1, System.Numerics.Vector&lt;long&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;int32&gt; Narrow(valuetype System.Numerics.Vector`1&lt;int64&gt; source1, valuetype System.Numerics.Vector`1&lt;int64&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Narrow(System.Numerics.Vector{System.Int64},System.Numerics.Vector{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Narrow (source1 As Vector(Of Long), source2 As Vector(Of Long)) As Vector(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;int&gt; Narrow(System::Numerics::Vector&lt;long&gt; source1, System::Numerics::Vector&lt;long&gt; source2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source1" Type="System.Numerics.Vector&lt;System.Int64&gt;" />
        <Parameter Name="source2" Type="System.Numerics.Vector&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="source1">To be added.</param>
        <param name="source2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Narrow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;byte&gt; Narrow (System.Numerics.Vector&lt;ushort&gt; source1, System.Numerics.Vector&lt;ushort&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;unsigned int8&gt; Narrow(valuetype System.Numerics.Vector`1&lt;unsigned int16&gt; source1, valuetype System.Numerics.Vector`1&lt;unsigned int16&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Narrow(System.Numerics.Vector{System.UInt16},System.Numerics.Vector{System.UInt16})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Narrow (source1 As Vector(Of UShort), source2 As Vector(Of UShort)) As Vector(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;System::Byte&gt; Narrow(System::Numerics::Vector&lt;System::UInt16&gt; source1, System::Numerics::Vector&lt;System::UInt16&gt; source2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source1" Type="System.Numerics.Vector&lt;System.UInt16&gt;" />
        <Parameter Name="source2" Type="System.Numerics.Vector&lt;System.UInt16&gt;" />
      </Parameters>
      <Docs>
        <param name="source1">To be added.</param>
        <param name="source2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Narrow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;ushort&gt; Narrow (System.Numerics.Vector&lt;uint&gt; source1, System.Numerics.Vector&lt;uint&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;unsigned int16&gt; Narrow(valuetype System.Numerics.Vector`1&lt;unsigned int32&gt; source1, valuetype System.Numerics.Vector`1&lt;unsigned int32&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Narrow(System.Numerics.Vector{System.UInt32},System.Numerics.Vector{System.UInt32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Narrow (source1 As Vector(Of UInteger), source2 As Vector(Of UInteger)) As Vector(Of UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;System::UInt16&gt; Narrow(System::Numerics::Vector&lt;System::UInt32&gt; source1, System::Numerics::Vector&lt;System::UInt32&gt; source2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.UInt16&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source1" Type="System.Numerics.Vector&lt;System.UInt32&gt;" />
        <Parameter Name="source2" Type="System.Numerics.Vector&lt;System.UInt32&gt;" />
      </Parameters>
      <Docs>
        <param name="source1">To be added.</param>
        <param name="source2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Narrow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;uint&gt; Narrow (System.Numerics.Vector&lt;ulong&gt; source1, System.Numerics.Vector&lt;ulong&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;unsigned int32&gt; Narrow(valuetype System.Numerics.Vector`1&lt;unsigned int64&gt; source1, valuetype System.Numerics.Vector`1&lt;unsigned int64&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Narrow(System.Numerics.Vector{System.UInt64},System.Numerics.Vector{System.UInt64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Narrow (source1 As Vector(Of ULong), source2 As Vector(Of ULong)) As Vector(Of UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;System::UInt32&gt; Narrow(System::Numerics::Vector&lt;System::UInt64&gt; source1, System::Numerics::Vector&lt;System::UInt64&gt; source2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.UInt32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source1" Type="System.Numerics.Vector&lt;System.UInt64&gt;" />
        <Parameter Name="source2" Type="System.Numerics.Vector&lt;System.UInt64&gt;" />
      </Parameters>
      <Docs>
        <param name="source1">To be added.</param>
        <param name="source2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Negate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; Negate&lt;T&gt; (System.Numerics.Vector&lt;T&gt; value) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;!!T&gt; Negate&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Negate``1(System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate(Of T As Structure) (value As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;T&gt; Negate(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-413">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-413">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-414">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-414">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="value">
          <span data-ttu-id="82bfe-415">Wektorze źródłowym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-415">The source vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-416">Zwraca nowy wektor, której elementy są Negacja odpowiadający mu element w określonym wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-416">Returns a new vector whose elements are the negation of the corresponding element in the specified vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-417">Zanegowaną wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-417">The negated vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; OnesComplement&lt;T&gt; (System.Numerics.Vector&lt;T&gt; value) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;!!T&gt; OnesComplement&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.OnesComplement``1(System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OnesComplement(Of T As Structure) (value As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;T&gt; OnesComplement(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-418">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-418">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-419">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-419">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="value">
          <span data-ttu-id="82bfe-420">Wektorze źródłowym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-420">The source vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-421">Zwraca nowy wektor, której elementy są uzyskiwane przez podejmowanie dopełnienia swoich elementów określony wektor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-421">Returns a new vector whose elements are obtained by taking the one's complement of a specified vector's elements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-422">Wynikowa wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-422">The resulting vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SquareRoot&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; SquareRoot&lt;T&gt; (System.Numerics.Vector&lt;T&gt; value) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;!!T&gt; SquareRoot&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.SquareRoot``1(System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SquareRoot(Of T As Structure) (value As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;T&gt; SquareRoot(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-423">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-423">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-424">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-424">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="value">
          <span data-ttu-id="82bfe-425">Wektorze źródłowym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-425">The source vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-426">Zwraca nowy wektor, której elementy są pierwiastków kwadratowych określony wektor elementów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-426">Returns a new vector whose elements are the square roots of a specified vector's elements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-427">Wektor pierwiastek kwadratowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-427">The square root vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; Subtract&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;!!T&gt; Subtract&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Subtract``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract(Of T As Structure) (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;T&gt; Subtract(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-428">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-428">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-429">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-429">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-430">Pierwszy wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-430">The first vector.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-431">Drugi wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-431">The second vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-432">Zwraca nowy wektor, których wartości są różnica między elementów w wektorze drugi i ich odpowiednich elementów w pierwszym wektorze.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-432">Returns a new vector whose values are the difference between the elements in the second vector and their corresponding elements in the first vector.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-433">Wektor różnicy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-433">The difference vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public static void Widen (System.Numerics.Vector&lt;byte&gt; source, out System.Numerics.Vector&lt;ushort&gt; dest1, out System.Numerics.Vector&lt;ushort&gt; dest2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Widen(valuetype System.Numerics.Vector`1&lt;unsigned int8&gt; source, [out] valuetype System.Numerics.Vector`1&lt;unsigned int16&gt;&amp; dest1, [out] valuetype System.Numerics.Vector`1&lt;unsigned int16&gt;&amp; dest2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Widen(System.Numerics.Vector{System.Byte},System.Numerics.Vector{System.UInt16}@,System.Numerics.Vector{System.UInt16}@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Widen (source As Vector(Of Byte), ByRef dest1 As Vector(Of UShort), ByRef dest2 As Vector(Of UShort))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Widen(System::Numerics::Vector&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::Numerics::Vector&lt;System::UInt16&gt; % dest1, [Runtime::InteropServices::Out] System::Numerics::Vector&lt;System::UInt16&gt; % dest2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Vector&lt;System.Byte&gt;" />
        <Parameter Name="dest1" Type="System.Numerics.Vector&lt;System.UInt16&gt;&amp;" RefType="out" />
        <Parameter Name="dest2" Type="System.Numerics.Vector&lt;System.UInt16&gt;&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="dest1">To be added.</param>
        <param name="dest2">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public static void Widen (System.Numerics.Vector&lt;short&gt; source, out System.Numerics.Vector&lt;int&gt; dest1, out System.Numerics.Vector&lt;int&gt; dest2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Widen(valuetype System.Numerics.Vector`1&lt;int16&gt; source, [out] valuetype System.Numerics.Vector`1&lt;int32&gt;&amp; dest1, [out] valuetype System.Numerics.Vector`1&lt;int32&gt;&amp; dest2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Widen(System.Numerics.Vector{System.Int16},System.Numerics.Vector{System.Int32}@,System.Numerics.Vector{System.Int32}@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Widen (source As Vector(Of Short), ByRef dest1 As Vector(Of Integer), ByRef dest2 As Vector(Of Integer))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Widen(System::Numerics::Vector&lt;short&gt; source, [Runtime::InteropServices::Out] System::Numerics::Vector&lt;int&gt; % dest1, [Runtime::InteropServices::Out] System::Numerics::Vector&lt;int&gt; % dest2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Vector&lt;System.Int16&gt;" />
        <Parameter Name="dest1" Type="System.Numerics.Vector&lt;System.Int32&gt;&amp;" RefType="out" />
        <Parameter Name="dest2" Type="System.Numerics.Vector&lt;System.Int32&gt;&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="dest1">To be added.</param>
        <param name="dest2">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public static void Widen (System.Numerics.Vector&lt;int&gt; source, out System.Numerics.Vector&lt;long&gt; dest1, out System.Numerics.Vector&lt;long&gt; dest2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Widen(valuetype System.Numerics.Vector`1&lt;int32&gt; source, [out] valuetype System.Numerics.Vector`1&lt;int64&gt;&amp; dest1, [out] valuetype System.Numerics.Vector`1&lt;int64&gt;&amp; dest2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Widen(System.Numerics.Vector{System.Int32},System.Numerics.Vector{System.Int64}@,System.Numerics.Vector{System.Int64}@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Widen (source As Vector(Of Integer), ByRef dest1 As Vector(Of Long), ByRef dest2 As Vector(Of Long))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Widen(System::Numerics::Vector&lt;int&gt; source, [Runtime::InteropServices::Out] System::Numerics::Vector&lt;long&gt; % dest1, [Runtime::InteropServices::Out] System::Numerics::Vector&lt;long&gt; % dest2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Vector&lt;System.Int32&gt;" />
        <Parameter Name="dest1" Type="System.Numerics.Vector&lt;System.Int64&gt;&amp;" RefType="out" />
        <Parameter Name="dest2" Type="System.Numerics.Vector&lt;System.Int64&gt;&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="dest1">To be added.</param>
        <param name="dest2">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public static void Widen (System.Numerics.Vector&lt;sbyte&gt; source, out System.Numerics.Vector&lt;short&gt; dest1, out System.Numerics.Vector&lt;short&gt; dest2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Widen(valuetype System.Numerics.Vector`1&lt;int8&gt; source, [out] valuetype System.Numerics.Vector`1&lt;int16&gt;&amp; dest1, [out] valuetype System.Numerics.Vector`1&lt;int16&gt;&amp; dest2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Widen(System.Numerics.Vector{System.SByte},System.Numerics.Vector{System.Int16}@,System.Numerics.Vector{System.Int16}@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Widen (source As Vector(Of SByte), ByRef dest1 As Vector(Of Short), ByRef dest2 As Vector(Of Short))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Widen(System::Numerics::Vector&lt;System::SByte&gt; source, [Runtime::InteropServices::Out] System::Numerics::Vector&lt;short&gt; % dest1, [Runtime::InteropServices::Out] System::Numerics::Vector&lt;short&gt; % dest2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Vector&lt;System.SByte&gt;" />
        <Parameter Name="dest1" Type="System.Numerics.Vector&lt;System.Int16&gt;&amp;" RefType="out" />
        <Parameter Name="dest2" Type="System.Numerics.Vector&lt;System.Int16&gt;&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="dest1">To be added.</param>
        <param name="dest2">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public static void Widen (System.Numerics.Vector&lt;float&gt; source, out System.Numerics.Vector&lt;double&gt; dest1, out System.Numerics.Vector&lt;double&gt; dest2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Widen(valuetype System.Numerics.Vector`1&lt;float32&gt; source, [out] valuetype System.Numerics.Vector`1&lt;float64&gt;&amp; dest1, [out] valuetype System.Numerics.Vector`1&lt;float64&gt;&amp; dest2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Widen(System.Numerics.Vector{System.Single},System.Numerics.Vector{System.Double}@,System.Numerics.Vector{System.Double}@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Widen (source As Vector(Of Single), ByRef dest1 As Vector(Of Double), ByRef dest2 As Vector(Of Double))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Widen(System::Numerics::Vector&lt;float&gt; source, [Runtime::InteropServices::Out] System::Numerics::Vector&lt;double&gt; % dest1, [Runtime::InteropServices::Out] System::Numerics::Vector&lt;double&gt; % dest2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Vector&lt;System.Single&gt;" />
        <Parameter Name="dest1" Type="System.Numerics.Vector&lt;System.Double&gt;&amp;" RefType="out" />
        <Parameter Name="dest2" Type="System.Numerics.Vector&lt;System.Double&gt;&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="dest1">To be added.</param>
        <param name="dest2">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public static void Widen (System.Numerics.Vector&lt;ushort&gt; source, out System.Numerics.Vector&lt;uint&gt; dest1, out System.Numerics.Vector&lt;uint&gt; dest2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Widen(valuetype System.Numerics.Vector`1&lt;unsigned int16&gt; source, [out] valuetype System.Numerics.Vector`1&lt;unsigned int32&gt;&amp; dest1, [out] valuetype System.Numerics.Vector`1&lt;unsigned int32&gt;&amp; dest2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Widen(System.Numerics.Vector{System.UInt16},System.Numerics.Vector{System.UInt32}@,System.Numerics.Vector{System.UInt32}@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Widen (source As Vector(Of UShort), ByRef dest1 As Vector(Of UInteger), ByRef dest2 As Vector(Of UInteger))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Widen(System::Numerics::Vector&lt;System::UInt16&gt; source, [Runtime::InteropServices::Out] System::Numerics::Vector&lt;System::UInt32&gt; % dest1, [Runtime::InteropServices::Out] System::Numerics::Vector&lt;System::UInt32&gt; % dest2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Vector&lt;System.UInt16&gt;" />
        <Parameter Name="dest1" Type="System.Numerics.Vector&lt;System.UInt32&gt;&amp;" RefType="out" />
        <Parameter Name="dest2" Type="System.Numerics.Vector&lt;System.UInt32&gt;&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="dest1">To be added.</param>
        <param name="dest2">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public static void Widen (System.Numerics.Vector&lt;uint&gt; source, out System.Numerics.Vector&lt;ulong&gt; dest1, out System.Numerics.Vector&lt;ulong&gt; dest2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Widen(valuetype System.Numerics.Vector`1&lt;unsigned int32&gt; source, [out] valuetype System.Numerics.Vector`1&lt;unsigned int64&gt;&amp; dest1, [out] valuetype System.Numerics.Vector`1&lt;unsigned int64&gt;&amp; dest2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Widen(System.Numerics.Vector{System.UInt32},System.Numerics.Vector{System.UInt64}@,System.Numerics.Vector{System.UInt64}@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Widen (source As Vector(Of UInteger), ByRef dest1 As Vector(Of ULong), ByRef dest2 As Vector(Of ULong))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Widen(System::Numerics::Vector&lt;System::UInt32&gt; source, [Runtime::InteropServices::Out] System::Numerics::Vector&lt;System::UInt64&gt; % dest1, [Runtime::InteropServices::Out] System::Numerics::Vector&lt;System::UInt64&gt; % dest2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Vector&lt;System.UInt32&gt;" />
        <Parameter Name="dest1" Type="System.Numerics.Vector&lt;System.UInt64&gt;&amp;" RefType="out" />
        <Parameter Name="dest2" Type="System.Numerics.Vector&lt;System.UInt64&gt;&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="dest1">To be added.</param>
        <param name="dest2">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; Xor&lt;T&gt; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Vector`1&lt;!!T&gt; Xor&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Numerics.Vector`1&lt;!!T&gt; left, valuetype System.Numerics.Vector`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector.Xor``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Xor(Of T As Structure) (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Numerics::Vector&lt;T&gt; Xor(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="82bfe-434">Typ wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-434">The vector type.</span>
          </span>
          <span data-ttu-id="82bfe-435">
            <c>T</c> może być dowolnym pierwotny typ liczbowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-435">
              <c>T</c> can be any primitive numeric type.</span>
          </span>
        </typeparam>
        <param name="left">
          <span data-ttu-id="82bfe-436">Pierwszy wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-436">The first vector.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="82bfe-437">Drugi wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-437">The second vector.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="82bfe-438">Zwraca nowy wektor, wykonując operator wyłączny lub (<see langword="XOr" />) operacji dla każdej pary elementów w dwóch wektorów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-438">Returns a new vector by performing a bitwise exclusive Or (<see langword="XOr" />) operation on each pair of elements in two vectors.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="82bfe-439">Wynikowa wektora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="82bfe-439">The resulting vector.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
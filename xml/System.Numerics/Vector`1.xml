<Type Name="Vector&lt;T&gt;" FullName="System.Numerics.Vector&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="87d5037830e011766c4b7782aa848b984ae5c804" />
    <Meta Name="ms.sourcegitcommit" Value="c676032167b46499b0f3fd5e8509680bd4764c44" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/22/2018" />
    <Meta Name="ms.locfileid" Value="40452214" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Vector&lt;T&gt; : IEquatable&lt;System.Numerics.Vector&lt;T&gt;&gt;, IFormattable where T : struct" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Vector`1&lt;struct .ctor (class System.ValueType) T&gt; extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Vector`1&lt;!T&gt;&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Vector`1" />
  <TypeSignature Language="VB.NET" Value="Public Structure Vector(Of T)&#xA;Implements IEquatable(Of Vector(Of T)), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA; where T : value classpublic value class Vector : IEquatable&lt;System::Numerics::Vector&lt;T&gt;&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type Vector&lt;'T (requires 'T : struct)&gt; = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Numerics.Vectors</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>4.1.3.0</AssemblyVersion>
    <AssemblyVersion>4.1.4.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T">
      <Constraints>
        <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
        <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
        <BaseTypeName>System.ValueType</BaseTypeName>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.Vector&lt;T&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="T">Typ wektora. <c>T</c> mogą być dowolnego pierwotnego typu liczbowego.</typeparam>
    <summary>Reprezentuje wektor pojedynczego określonego typu liczbowego, który jest odpowiedni dla niskiego poziomu optymalizacji algorytmów równoległych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Vector%601> jest strukturą niezmienne, która reprezentuje wektor pojedynczego określonego typu liczbowego. Liczba <xref:System.Numerics.Vector%601> wystąpienia jest stała, ale jego górny limit jest rejestru dla procesora CPU zależnych. Jest on przeznaczony do służyć jako blok konstrukcyjny oraz dodaliśmy pełniejszą obsługę dużych algorytmów.  
  
 <xref:System.Numerics.Vector%601> Struktura zapewnia obsługę przyspieszanie sprzętowe.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Vector (Span&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Span`1&lt;!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.#ctor(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (values As Span(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Vector(Span&lt;T&gt; values);" />
      <MemberSignature Language="F#" Value="new System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; : Span&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="new System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; values" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="values" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Vector (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.#ctor(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Vector(T value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; : 'T -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="new System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Typu liczbowego, który definiuje typ elementów w wektorze.</param>
        <summary>Tworzy wektor, w których elementy są określonego typu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` może być dowolnego pierwotnego typu liczbowego (liczbowa type którego <xref:System.Type.IsPrimitive%2A?displayProperty=nameWithType> właściwość zwraca `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Vector (T[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.#ctor(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (values As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Vector(cli::array &lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="new System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; : 'T[] -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="new System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; values" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="values" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="values">Tablicy liczbowej.</param>
        <summary>Tworzy wektor z określonej tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `values` musi zawierać co najmniej <xref:System.Numerics.Vector%601.Count%2A> elementów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Vector (T[] values, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] values, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.#ctor(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (values As T(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Vector(cli::array &lt;T&gt; ^ values, int index);" />
      <MemberSignature Language="F#" Value="new System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; : 'T[] * int -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="new System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; (values, index)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="values" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="values">Tablicy liczbowej.</param>
        <param name="index">Pozycja początkowa indeksu służący do utworzenia wektora.</param>
        <summary>Tworzy wektor z określonej tablicy, zaczynając od pozycji określonym indeksie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tablica musi zawierać co najmniej [konstruktor Vector(T) (T\<xref:System.Numerics.Vector%601.Count%2A?displayProperty=nameWithType > elementy z określonym indeksem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż zero.  
  
—lub— 
Długość <paramref name="values" /> minus <paramref name="index" /> jest mniejsza niż <see cref="P:System.Numerics.Vector`1.Count" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ destination);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] -&gt; unit" Usage="vector.CopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="destination">Tablica, aby otrzymać kopię wartości wektora.</param>
        <summary>Kopiuje wystąpienie wektorów do określonej lokalizacji docelowej tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacja kopiowania rozpocznie się pod indeksem 0 z `destination`. Tablica docelowa musi mieć co najmniej <xref:System.Numerics.Vector%601.Count%2A?displayProperty=nameWithType> elementów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Liczba elementów w bieżącym wektora jest większa niż liczba elementów, które są dostępne w <paramref name="destination" /> tablicy.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] destination, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] destination, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As T(), startIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ destination, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] * int -&gt; unit" Usage="vector.CopyTo (destination, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination">Tablica, aby otrzymać kopię wartości wektora.</param>
        <param name="startIndex">Indeks początkowy w <c>docelowy</c> od którego należy rozpocząć operację kopiowania.</param>
        <summary>Kopiuje wystąpienie wektorów do określonej lokalizacji docelowej tablicy, zaczynając od pozycji określonym indeksie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacja kopiowania rozpocznie się pod indeksem `startIndex` z `destination`. Tablica docelowa musi mieć co najmniej `startIndex` + [CopyTo — metoda (T\<xref:System.Numerics.Vector%601.Count%2A > – 1 elementów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Liczba elementów w ramach bieżącego wystąpienia jest większa niż liczba elementów, które są dostępne z <paramref name="startIndex" /> na końcu <paramref name="destination" /> tablicy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa niż ostatni indeks w <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public static int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Vector`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca liczbę elementów przechowywanych w wektorze.</summary>
        <value>Liczba elementów przechowywanych w wektorze.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Dostęp do metody pobierającej przy użyciu odbicia nie jest obsługiwana.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.Vector&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.Vector`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.Equals(System.Numerics.Vector{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Vector(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::Vector&lt;T&gt; other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; bool" Usage="vector.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Wektor do porównania z tym wystąpieniem.</param>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie jest równe określonej wektora.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżące wystąpienie i <paramref name="other" /> są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa wektory są takie same jeśli są tego samego typu, ma taką samą liczbę wartości, a każda wartość w bieżącym wystąpieniu jest równa odpowiadająca wartość w `other`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="vector.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, który ma zostać porównany z tym wystąpieniem.</param>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie jest równe podanemu obiektowi.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżące wystąpienie i <paramref name="obj" /> są równe; w przeciwnym razie <see langword="false" />. Metoda ta zwraca <see langword="false" /> Jeśli <paramref name="obj" /> ma wartość null, lub jeśli <paramref name="obj" /> jest wektorem innego typu niż bieżące wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa wektory są takie same jeśli są tego samego typu, ma taką samą liczbę wartości, a każda wartość w bieżącym wystąpieniu jest równa odpowiadająca wartość w `other`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="vector.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla tego wystąpienia.</summary>
        <returns>Kod skrótu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Vector`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T default[int] { T get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : 'T" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks elementu do zwrócenia.</param>
        <summary>Pobiera element z określonym indeksem.</summary>
        <value>Element o indeksie <paramref name="index" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="index" /> jest większa niż lub równa <see cref="P:System.Numerics.Vector`1.Count" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.Vector`1&lt;!T&gt; One" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Vector`1.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property One As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::Vector&lt;T&gt; One { System::Numerics::Vector&lt;T&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.One : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.One" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca wektor zawierający wszystkie z nich.</summary>
        <value>Wektor, zawierający wszystkie z nich.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; operator + (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;!T&gt; op_Addition(valuetype System.Numerics.Vector`1&lt;!T&gt; left, valuetype System.Numerics.Vector`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Addition(System.Numerics.Vector{`0},System.Numerics.Vector{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;T&gt; operator +(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; * System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Aby dodać pierwszego wektora.</param>
        <param name="right">Drugi wektor do dodania.</param>
        <summary>Dodaje dwa wektory ze sobą.</summary>
        <returns>Wektor sumowany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Vector%601.op_Addition%2A> Metoda definiuje operacja dodawania dla <xref:System.Numerics.Vector%601> obiektów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseAnd">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; operator &amp; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;!T&gt; op_BitwiseAnd(valuetype System.Numerics.Vector`1&lt;!T&gt; left, valuetype System.Numerics.Vector`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_BitwiseAnd(System.Numerics.Vector{`0},System.Numerics.Vector{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator And (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;T&gt; operator &amp;(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member ( &amp;&amp;&amp; ) : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; * System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="left &amp;&amp;&amp; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszego wektora.</param>
        <param name="right">Drugi wektora.</param>
        <summary>Zwraca nowy wektor, wykonując bitowej <see langword="And" /> operację na wszystkich elementów w dwa wektory.</summary>
        <returns>Wektor, który jest wynikiem operatora testu koniunkcji <see langword="And" /> z <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Vector%601.op_BitwiseAnd%2A> Metoda określa operatora testu koniunkcji `And` operacji <xref:System.Numerics.Vector%601> obiektów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; operator | (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;!T&gt; op_BitwiseOr(valuetype System.Numerics.Vector`1&lt;!T&gt; left, valuetype System.Numerics.Vector`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_BitwiseOr(System.Numerics.Vector{`0},System.Numerics.Vector{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Or (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;T&gt; operator |(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member ( ||| ) : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; * System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="left ||| right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszego wektora.</param>
        <param name="right">Drugi wektora.</param>
        <summary>Zwraca nowy wektor, wykonując bitowej <see langword="Or" /> operację na wszystkich elementów w dwa wektory.</summary>
        <returns>Wektor, który jest wynikiem operatora testu koniunkcji <see langword="Or" /> elementów w <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Vector%601.op_BitwiseOr%2A> Metoda określa operatora testu koniunkcji `Or` operacji <xref:System.Numerics.Vector%601> obiektów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; operator / (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;!T&gt; op_Division(valuetype System.Numerics.Vector`1&lt;!T&gt; left, valuetype System.Numerics.Vector`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Division(System.Numerics.Vector{`0},System.Numerics.Vector{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;T&gt; operator /(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; * System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszego wektora.</param>
        <param name="right">Drugi wektora.</param>
        <summary>Dzieli pierwszego wektora przez drugi.</summary>
        <returns>Vector, która wynika z podziału <paramref name="left" /> przez <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Vector%601.op_Division%2A> Metoda definiuje operacji dzielenia dla <xref:System.Numerics.Vector%601> obiektów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.Vector`1&lt;!T&gt; left, valuetype System.Numerics.Vector`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Equality(System.Numerics.Vector{`0},System.Numerics.Vector{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Vector(Of T), right As Vector(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; * System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszego wektora do porównania.</param>
        <param name="right">Drugi wektor do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy każda para elementów w dwa wektory określonego są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa wektory są takie same, jeśli są tego samego typu, ma taką samą liczbę wartości, a każda wartość w `left` jest taki sam, jak odpowiadająca wartość w `right`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; operator ^ (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;!T&gt; op_ExclusiveOr(valuetype System.Numerics.Vector`1&lt;!T&gt; left, valuetype System.Numerics.Vector`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_ExclusiveOr(System.Numerics.Vector{`0},System.Numerics.Vector{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Xor (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;T&gt; operator ^(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member ( ^^^ ) : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; * System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="left ^^^ right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszego wektora.</param>
        <param name="right">Drugi wektora.</param>
        <summary>Zwraca nowy wektor, wykonując bitowej <see langword="XOr" /> operację na wszystkich elementów w dwa wektory.</summary>
        <returns>Wektor, który jest wynikiem operatora testu koniunkcji <see langword="XOr" /> elementów w <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Vector%601.op_ExclusiveOr%2A> Metoda określa operatora testu koniunkcji `XOr` operacji <xref:System.Numerics.Vector%601> obiektów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Vector&lt;byte&gt; (System.Numerics.Vector&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;unsigned int8&gt; op_Explicit(valuetype System.Numerics.Vector`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.Byte}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Vector(Of T)) As Vector(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Vector&lt;System::Byte&gt;(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;byte&gt;" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Wektor do reinterpret.</param>
        <summary>Reinterpretuje obiekt bity określony wektor do wektora typu <see cref="T:System.Byte" />.</summary>
        <returns>Wektor przez zamianę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Vector%601.op_Explicit%2A> Operator definiuje konwersji zawężającej; wymaga operatora rzutowania (w języku C#) lub metodę konwersji (w języku Visual Basic).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Vector&lt;double&gt; (System.Numerics.Vector&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;float64&gt; op_Explicit(valuetype System.Numerics.Vector`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.Double}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Vector(Of T)) As Vector(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Vector&lt;double&gt;(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;double&gt;" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Wektor do reinterpret.</param>
        <summary>Reinterpretuje obiekt bity określony wektor do wektora typu <see cref="T:System.Double" />.</summary>
        <returns>Wektor przez zamianę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Vector%601.op_Explicit%2A> Operator definiuje konwersji zawężającej; wymaga operatora rzutowania (w języku C#) lub metodę konwersji (w języku Visual Basic).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Vector&lt;short&gt; (System.Numerics.Vector&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;int16&gt; op_Explicit(valuetype System.Numerics.Vector`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.Int16}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Vector(Of T)) As Vector(Of Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Vector&lt;short&gt;(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;int16&gt;" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int16&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Wektor do reinterpret.</param>
        <summary>Reinterpretuje obiekt bity określony wektor do wektora typu <see cref="T:System.Int16" />.</summary>
        <returns>Wektor przez zamianę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Vector%601.op_Explicit%2A> Operator definiuje konwersji zawężającej; wymaga operatora rzutowania (w języku C#) lub metodę konwersji (w języku Visual Basic).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Vector&lt;int&gt; (System.Numerics.Vector&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;int32&gt; op_Explicit(valuetype System.Numerics.Vector`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.Int32}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Vector(Of T)) As Vector(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Vector&lt;int&gt;(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;int&gt;" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Wektor do reinterpret.</param>
        <summary>Reinterpretuje obiekt bity określony wektor do wektora typu <see cref="T:System.Int32" />.</summary>
        <returns>Wektor przez zamianę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Vector%601.op_Explicit%2A> Operator definiuje konwersji zawężającej; wymaga operatora rzutowania (w języku C#) lub metodę konwersji (w języku Visual Basic).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Vector&lt;long&gt; (System.Numerics.Vector&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;int64&gt; op_Explicit(valuetype System.Numerics.Vector`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.Int64}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Vector(Of T)) As Vector(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Vector&lt;long&gt;(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;int64&gt;" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Wektor do reinterpret.</param>
        <summary>Reinterpretuje obiekt bity określony wektor do wektora typu <see cref="T:System.Int64" />.</summary>
        <returns>Wektor przez zamianę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Vector%601.op_Explicit%2A> Operator definiuje konwersji zawężającej; wymaga operatora rzutowania (w języku C#) lub metodę konwersji (w języku Visual Basic).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Vector&lt;sbyte&gt; (System.Numerics.Vector&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;int8&gt; op_Explicit(valuetype System.Numerics.Vector`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.SByte}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Vector(Of T)) As Vector(Of SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Vector&lt;System::SByte&gt;(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;sbyte&gt;" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.SByte&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Wektor do reinterpret.</param>
        <summary>Reinterpretuje obiekt bity określony wektor do wektora typu <see cref="T:System.SByte" />.</summary>
        <returns>Wektor przez zamianę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Vector%601.op_Explicit%2A> Operator definiuje konwersji zawężającej; wymaga operatora rzutowania (w języku C#) lub metodę konwersji (w języku Visual Basic).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Vector&lt;float&gt; (System.Numerics.Vector&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;float32&gt; op_Explicit(valuetype System.Numerics.Vector`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.Single}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Vector(Of T)) As Vector(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Vector&lt;float&gt;(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;single&gt;" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Wektor do reinterpret.</param>
        <summary>Reinterpretuje obiekt bity określony wektor do wektora typu <see cref="T:System.Single" />.</summary>
        <returns>Wektor przez zamianę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Vector%601.op_Explicit%2A> Operator definiuje konwersji zawężającej; wymaga operatora rzutowania (w języku C#) lub metodę konwersji (w języku Visual Basic).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Vector&lt;ushort&gt; (System.Numerics.Vector&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;unsigned int16&gt; op_Explicit(valuetype System.Numerics.Vector`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.UInt16}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Vector(Of T)) As Vector(Of UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Vector&lt;System::UInt16&gt;(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;uint16&gt;" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.UInt16&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Wektor do reinterpret.</param>
        <summary>Reinterpretuje obiekt bity określony wektor do wektora typu <see cref="T:System.UInt16" />.</summary>
        <returns>Wektor przez zamianę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Vector%601.op_Explicit%2A> Operator definiuje konwersji zawężającej; wymaga operatora rzutowania (w języku C#) lub metodę konwersji (w języku Visual Basic).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Vector&lt;uint&gt; (System.Numerics.Vector&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;unsigned int32&gt; op_Explicit(valuetype System.Numerics.Vector`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.UInt32}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Vector(Of T)) As Vector(Of UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Vector&lt;System::UInt32&gt;(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;uint32&gt;" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.UInt32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Wektor do reinterpret.</param>
        <summary>Reinterpretuje obiekt bity określony wektor do wektora typu <see cref="T:System.UInt32" />.</summary>
        <returns>Wektor przez zamianę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Vector%601.op_Explicit%2A> Operator definiuje konwersji zawężającej; wymaga operatora rzutowania (w języku C#) lub metodę konwersji (w języku Visual Basic).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Vector&lt;ulong&gt; (System.Numerics.Vector&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;unsigned int64&gt; op_Explicit(valuetype System.Numerics.Vector`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.UInt64}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Vector(Of T)) As Vector(Of ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Vector&lt;System::UInt64&gt;(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;uint64&gt;" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.UInt64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Wektor do reinterpret.</param>
        <summary>Reinterpretuje obiekt bity określony wektor do wektora typu <see cref="T:System.UInt64" />.</summary>
        <returns>Wektor przez zamianę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Vector%601.op_Explicit%2A> Operator definiuje konwersji zawężającej; wymaga operatora rzutowania (w języku C#) lub metodę konwersji (w języku Visual Basic).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.Vector`1&lt;!T&gt; left, valuetype System.Numerics.Vector`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Inequality(System.Numerics.Vector{`0},System.Numerics.Vector{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Vector(Of T), right As Vector(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; * System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; bool" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszego wektora do porównania.</param>
        <param name="right">Drugi wektor do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy wszystkie jedna para elementów w określonym wektorów jest taki sam.</summary>
        <returns>
          <see langword="true" /> Jeśli wszystkie pary element w lewy i prawy są równe. <see langword="false" /> Jeśli nie pary elementów są równe.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; operator * (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;!T&gt; op_Multiply(valuetype System.Numerics.Vector`1&lt;!T&gt; left, valuetype System.Numerics.Vector`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Multiply(System.Numerics.Vector{`0},System.Numerics.Vector{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;T&gt; operator *(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; * System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszego wektora.</param>
        <param name="right">Drugi wektora.</param>
        <summary>Zwraca nowy wektor, których wartości są produktu każda para elementów w dwa wektory określony.</summary>
        <returns>Wektor mnożenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Vector%601.op_Multiply%2A> Metoda definiuje operacja mnożenia dla <xref:System.Numerics.Vector%601> obiektów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; operator * (System.Numerics.Vector&lt;T&gt; value, T factor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;!T&gt; op_Multiply(valuetype System.Numerics.Vector`1&lt;!T&gt; value, !T factor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Multiply(System.Numerics.Vector{`0},`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (value As Vector(Of T), factor As T) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;T&gt; operator *(System::Numerics::Vector&lt;T&gt; value, T factor);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; * 'T -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="value * factor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="factor" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Wektor źródła.</param>
        <param name="factor">Wartość skalarna.</param>
        <summary>Mnoży wektora przez określoną wartość skalarną.</summary>
        <returns>Wektor skalowany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Vector%601.op_Multiply%2A> Metoda definiuje operacja mnożenia dla <xref:System.Numerics.Vector%601> obiektów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; operator * (T factor, System.Numerics.Vector&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;!T&gt; op_Multiply(!T factor, valuetype System.Numerics.Vector`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Multiply(`0,System.Numerics.Vector{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (factor As T, value As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;T&gt; operator *(T factor, System::Numerics::Vector&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member ( * ) : 'T * System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="factor * value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="T" />
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="factor">Wartość skalarna.</param>
        <param name="value">Wektor źródła.</param>
        <summary>Mnoży wektora przez określoną wartość skalarną.</summary>
        <returns>Wektor skalowany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Vector%601.op_Multiply%2A> Metoda definiuje operacja mnożenia dla <xref:System.Numerics.Vector%601> obiektów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; operator ~ (System.Numerics.Vector&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;!T&gt; op_OnesComplement(valuetype System.Numerics.Vector`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_OnesComplement(System.Numerics.Vector{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Not (value As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;T&gt; operator ~(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member op_OnesComplement : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.op_OnesComplement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Wektor źródła.</param>
        <summary>Zwraca nowy wektor, w której elementy są pobierane, wykonując uzupełnienie jedynkowe elementów określony wektor.</summary>
        <returns>Ten firmy uzupełnienie wektora.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; operator - (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;!T&gt; op_Subtraction(valuetype System.Numerics.Vector`1&lt;!T&gt; left, valuetype System.Numerics.Vector`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Subtraction(System.Numerics.Vector{`0},System.Numerics.Vector{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;T&gt; operator -(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; * System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszego wektora.</param>
        <param name="right">Drugi wektora.</param>
        <summary>Odejmuje drugi wektora z pierwszego.</summary>
        <returns>Wektor, który jest wynikiem odejmowania <paramref name="right" /> z <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Vector%601.op_Subtraction%2A> Metoda określa operację odejmowania <xref:System.Numerics.Vector%601> obiektów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; operator - (System.Numerics.Vector&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;!T&gt; op_UnaryNegation(valuetype System.Numerics.Vector`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_UnaryNegation(System.Numerics.Vector{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;T&gt; operator -(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Wektor do zanegowania.</param>
        <summary>Neguje danego wektora.</summary>
        <returns>Wektor zanegowanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Vector%601.op_UnaryNegation%2A> Metoda określa operację negacji jednoargumentowe <xref:System.Numerics.Vector%601> obiektów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="vector.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca reprezentację ciągu tego wektora za pomocą domyślnego formatowania.</summary>
        <returns>Reprezentacja ciągu tego wektora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca ciąg, w której każdy element wektora jest formatowana przy użyciu ciągu (Ogólne) formatu "G" i konwencje formatowania bieżącej kultury wątku. Bieżąca kultura <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A?displayProperty=nameWithType> następuje spacja jest używana do oddzielania każdego elementu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="vector.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Element lub który definiuje format poszczególne elementy.</param>
        <summary>Zwraca reprezentację ciągu tego wektora za pomocą określonego ciągu formatu do sformatowania poszczególne elementy.</summary>
        <returns>Ciąg reprezentujący bieżące wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca ciąg, w której każdy element wektora jest formatowana przy użyciu `format` i formatowanie Konwencji bieżącej kultury. Bieżąca kultura <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A?displayProperty=nameWithType> następuje spacja jest używana do oddzielania każdego elementu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider formatProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider formatProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, formatProvider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ formatProvider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="vector.ToString (format, formatProvider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="formatProvider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Element lub który definiuje format poszczególne elementy.</param>
        <param name="formatProvider">Dostawca formatu, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Zwraca reprezentację ciągu tego wektora za pomocą określonego ciągu formatu, aby sformatować poszczególnych elementów i dostawcy określonego formatu, aby zdefiniować formatowanie specyficzne dla kultury.</summary>
        <returns>Ciąg reprezentujący bieżące wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca ciąg, w której każdy element wektora jest formatowana przy użyciu `format` i `formatProvider`, dostawca formatu i <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A?displayProperty=nameWithType> następuje spacja jest używana do oddzielania każdego elementu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.Vector`1&lt;!T&gt; Zero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Vector`1.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Zero As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::Vector&lt;T&gt; Zero { System::Numerics::Vector&lt;T&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Zero : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.Zero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca wektor zawierający zer.</summary>
        <value>Wektor, zawierający zer.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
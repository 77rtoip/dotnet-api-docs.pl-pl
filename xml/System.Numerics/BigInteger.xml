<Type Name="BigInteger" FullName="System.Numerics.BigInteger">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7d0dcda34bb31112c320daec112f3dd4b818dc43" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30561877" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct BigInteger : IComparable, IComparable&lt;System.Numerics.BigInteger&gt;, IEquatable&lt;System.Numerics.BigInteger&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit BigInteger extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IEquatable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.BigInteger" />
  <TypeSignature Language="VB.NET" Value="Public Structure BigInteger&#xA;Implements IComparable, IComparable(Of BigInteger), IEquatable(Of BigInteger), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class BigInteger : IComparable, IComparable&lt;System::Numerics::BigInteger&gt;, IEquatable&lt;System::Numerics::BigInteger&gt;, IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje dowolnie dużą liczbę całkowitą ze znakiem.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger> Typ jest niezmiennego typu, który reprezentuje dowolnie dużą liczbą całkowitą, którego wartość teoretycznie nie ma żadnych granic górnej i dolnej. Elementy członkowskie <xref:System.Numerics.BigInteger> typu ściśle równoległe tych innych typów całkowitych ( <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, i <xref:System.UInt64> typy). Ten typ różni się od innych typów całkowitych w [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], które mają zakres wskazywany przez ich `MinValue` i `MaxValue` właściwości.  
  
> [!NOTE]
>  Ponieważ <xref:System.Numerics.BigInteger> typu nie można modyfikować (zobacz [zmienność i struktura BigInteger](#mutability)) i dlatego nie ma ona żadnych granic górnego i dolnego <xref:System.OutOfMemoryException> może zostać zgłoszony do żadnej operacji, która powoduje występowanie <xref:System.Numerics.BigInteger> wartość do zwiększenia zbyt duża.  
  
## <a name="instantiating-a-biginteger-object"></a>Utworzenie wystąpienia obiektu BigInteger  
 Można utworzyć wystąpienia <xref:System.Numerics.BigInteger> obiekt na kilka sposobów:  
  
-   Można użyć `new` — słowo kluczowe i podaj wartości całkowitych i zmiennoprzecinkowych jako parametr <xref:System.Numerics.BigInteger> konstruktora. (Wartości zmiennoprzecinkowe są obcinane przed są przypisane do <xref:System.Numerics.BigInteger>.) Poniższy przykład przedstawia sposób użycia `new` — słowo kluczowe można utworzyć wystąpienia <xref:System.Numerics.BigInteger> wartości.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#1)]
     [!code-vb[System.Numerics.BigInteger.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#1)]  
  
-   Można zadeklarować <xref:System.Numerics.BigInteger> zmienną i przypisz wartości podobnie jak miałoby to dowolnego typu liczbowego, dopóki ta wartość jest typem całkowitym. W poniższym przykładzie użyto przypisania, aby utworzyć <xref:System.Numerics.BigInteger> wartość z <xref:System.Int64>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#2)]
     [!code-vb[System.Numerics.BigInteger.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#2)]  
  
-   Można przypisać wartość dziesiętną lub zmiennoprzecinkowe <xref:System.Numerics.BigInteger> obiekt można rzutować wartości lub przekonwertować ją najpierw. Poniższy przykład jawnie rzutuje (w języku C#) lub konwertuje (w języku Visual Basic) <xref:System.Double> i <xref:System.Decimal> do wartości <xref:System.Numerics.BigInteger>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#3)]
     [!code-vb[System.Numerics.BigInteger.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#3)]  
  
 Te metody umożliwiają utworzenie wystąpienia <xref:System.Numerics.BigInteger> obiektu, którego wartość jest w zakresie istniejących liczbowe tylko typy. Można utworzyć wystąpienia <xref:System.Numerics.BigInteger> obiektu, którego wartość może przekroczyć istniejących typów numerycznych w jeden z trzech sposobów:  
  
-   Można użyć `new` — słowo kluczowe i podaj tablica bajtów o dowolnym rozmiarze <xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=nameWithType> konstruktora. Na przykład:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#4)]
     [!code-vb[System.Numerics.BigInteger.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#4)]  
  
-   Możesz wywołać <xref:System.Numerics.BigInteger.Parse%2A> lub <xref:System.Numerics.BigInteger.TryParse%2A> metod do konwertowania reprezentację liczby <xref:System.Numerics.BigInteger>. Na przykład:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#5)]
     [!code-vb[System.Numerics.BigInteger.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#5)]  
  
-   Możesz wywołać `static` (`Shared` w języku Visual Basic) <xref:System.Numerics.BigInteger> metodę, która wykonuje pewne operacje na wyrażenia liczbowego i zwraca obliczeniowego <xref:System.Numerics.BigInteger> wynik. Poniższy przykład robi to przez cubing <xref:System.UInt64.MaxValue?displayProperty=nameWithType> i przypisywanie wynik, który ma <xref:System.Numerics.BigInteger>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#6)]
     [!code-vb[System.Numerics.BigInteger.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#6)]  
  
 Wartość niezainicjowanej <xref:System.Numerics.BigInteger> jest <xref:System.Numerics.BigInteger.Zero%2A>.  
  
## <a name="performing-operations-on-biginteger-values"></a>Wykonywanie operacji na wartościach typu BigInteger  
 Można użyć <xref:System.Numerics.BigInteger> wystąpienie, jak w przypadku innych typ całkowity. <xref:System.Numerics.BigInteger> Overloads standardowych operatorów liczbowych i umożliwiają wykonywanie podstawowych operacji matematycznych, takich jak dodawanie, odejmowania, dzielenia, mnożenia, odejmowania, negacji i negacji jednoargumentowy. Umożliwia także standardowych operatorów liczbowe do porównania dwóch <xref:System.Numerics.BigInteger> wartości ze sobą. Inne typy całkowite, takich jak <xref:System.Numerics.BigInteger> obsługuje również operatora testu koniunkcji `And`, `Or`, `XOr`, lewego shift i operatory przesunięcia w prawo. Dla języków, które nie obsługują niestandardowych operatory <xref:System.Numerics.BigInteger> struktury udostępnia również równoważne metody służące do wykonywania operacji matematycznych. Obejmują one <xref:System.Numerics.BigInteger.Add%2A>, <xref:System.Numerics.BigInteger.Divide%2A>, <xref:System.Numerics.BigInteger.Multiply%2A>, <xref:System.Numerics.BigInteger.Negate%2A>, <xref:System.Numerics.BigInteger.Subtract%2A>i kilka innych.  
  
 Wiele elementów członkowskich z <xref:System.Numerics.BigInteger> struktury odpowiada bezpośrednio do elementów członkowskich innych typów całkowitych. Ponadto <xref:System.Numerics.BigInteger> dodaje elementy członkowskie, takie jak następujące:  
  
-   <xref:System.Numerics.BigInteger.Sign%2A>, która zwraca wartość wskazującą znak <xref:System.Numerics.BigInteger> wartość.  
  
-   <xref:System.Numerics.BigInteger.Abs%2A>, która zwraca wartość bezwzględną liczby <xref:System.Numerics.BigInteger> wartość.  
  
-   <xref:System.Numerics.BigInteger.DivRem%2A>, która zwraca iloraz i pozostałej części operacji dzielenia.  
  
-   <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>, która zwraca największy wspólny dzielnik dwóch <xref:System.Numerics.BigInteger> wartości.  
  
 Wiele z tych dodatkowych elementów członkowskich odpowiadają członków <xref:System.Math> klasy, która udostępnia funkcje do pracy z liczbowych typów pierwotnych.  
  
<a name="mutability"></a>   
## <a name="mutability-and-the-biginteger-structure"></a>Zmienność i struktura BigInteger  
 Poniższy przykład tworzy <xref:System.Numerics.BigInteger> obiektu i następnie zwiększa jedną wartość.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#1)]  
  
 Aby zmodyfikować wartość istniejący obiekt jest wyświetlany w tym przykładzie, ale nie jest to to. <xref:System.Numerics.BigInteger> obiekty są niezmienne, co oznacza, że wewnętrznie, środowisko uruchomieniowe języka wspólnego faktycznie tworzy nową <xref:System.Numerics.BigInteger> obiektów i przypisuje jej wartość jeden większa niż poprzednia wartość. Ten nowy obiekt jest następnie zwracany do obiektu wywołującego.  
  
> [!NOTE]
>  Inne typy liczbowe w programie .NET Framework również są niezmienne. Jednak ponieważ <xref:System.Numerics.BigInteger> typ nie ma żadnych granic górny lub niższy, jego wartości można zwiększyć bardzo duże lub ma zauważalnego wpływu na wydajność.  
  
 Mimo że ten proces jest niewidoczny dla obiekt wywołujący, jego pociągnąć za sobą zmniejszenie wydajności. W niektórych przypadkach, szczególnie gdy powtarzane operacje są wykonywane w pętli na bardzo dużych <xref:System.Numerics.BigInteger> wartości, może być znaczny wpływ na wydajność. Na przykład w poniższym przykładzie jest wykonywane kilkukrotnie do milionów razy, a <xref:System.Numerics.BigInteger> wartość jest zwiększany o jeden za każdym razem operacja się powiodła.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#12)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#12)]  
  
 W takim przypadku można poprawić wydajność, wykonując wszystkie pośrednie przypisania do <xref:System.Int32> zmiennej. Następnie można przypisać końcowa wartość zmiennej do <xref:System.Numerics.BigInteger> obiektu, gdy kończy pętli. Poniższy przykład stanowi ilustrację.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#3)]  
  
## <a name="working-with-byte-arrays-and-hexadecimal-strings"></a>Praca z tablicami bajtowymi i ciągami znaków szesnastkowych  
 W przypadku przekonwertowania <xref:System.Numerics.BigInteger> wartości tablice typu byte, lub jeśli Konwertuj tablice typu byte do <xref:System.Numerics.BigInteger> wartości, należy rozważyć kolejności bajtów. <xref:System.Numerics.BigInteger> Struktury oczekuje poszczególnych bajtów w tablicy bajtowej pojawią się w kolejności little endian (czyli kolejność małą liczbę bajtów wartość poprzedzać bajtów wyższego rzędu). Można wyrównana <xref:System.Numerics.BigInteger> wartość wywołując <xref:System.Numerics.BigInteger.ToByteArray%2A> metody, a następnie przekazywanie wynikowy bajtów tablicy do <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> konstruktora, jak przedstawiono na poniższym przykładzie.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#1)]  
  
 Można utworzyć wystąpienia <xref:System.Numerics.BigInteger> wartości z tablicy bajtów reprezentujący wartość całkowitą typu, można przekazać wartości całkowite <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> metody, a następnie przekaż tablica wynikowa bajtów do <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> konstruktora. Poniższy przykład tworzy <xref:System.Numerics.BigInteger> wartości z tablicy bajtów reprezentujący <xref:System.Int16> wartość.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#2)]  
  
 <xref:System.Numerics.BigInteger> Struktury przyjęto założenie, że wartości ujemne są przechowywane przy użyciu dwóch jego reprezentacja dopełnienia. Ponieważ <xref:System.Numerics.BigInteger> struktury reprezentuje wartość numeryczną z brak stałej długości <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> Konstruktor zawsze interpretuje najbardziej znaczącego bitu ostatniego bajtu w tablicy jako bitem znaku. Aby zapobiec <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> konstruktora z skomplikowana dwie firmy dopełnienia reprezentacja wartości ujemnej z logowania i wielkości reprezentację dodatnią wartość dodatnią wartości w którym najbardziej znaczącego bitu ostatniego bajtu w tablicy bajtów normalnie jest zestaw powinny zawierać dodatkowe bajt, którego wartość jest równa 0. Na przykład 0xC0 0xBD 0xF0 0xFF jest szesnastkową reprezentację little endian-1,000,000 lub 4,293,967,296. Ponieważ najbardziej znaczącego bitu w tej macierzy ostatniego bajtu na wartość tablicy bajtów może zostać zinterpretowany przez <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> Konstruktor jako-1,000,000. Można utworzyć wystąpienia <xref:System.Numerics.BigInteger> którego wartość jest dodatnia, której elementy są 0xC0 tablicy bajtów 0xBD 0xF0 0xFF 0x00 musi zostać przekazany do konstruktora. Ilustruje to poniższy przykład.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#3)]  
  
 Tablice typu byte utworzone przez <xref:System.Numerics.BigInteger.ToByteArray%2A> metody z wartości dodatnie obejmują bajt bardzo wartość zero. W związku z tym <xref:System.Numerics.BigInteger> struktury może pomyślnie obustronne wartości przez przypisywanie ich do i przywracania ich z tablice typu byte, jak przedstawiono na poniższym przykładzie.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#4)]  
  
 Może jednak może być konieczne dodanie dodatkowych bajt wartość zero do tablice typu byte, które są tworzone dynamicznie przez dewelopera lub który są zwracane przez metody, które przekonwertować tablic bajtowych liczb całkowitych bez znaku (takie jak <xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=nameWithType>, <xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=nameWithType>, i <xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=nameWithType>).  
  
 Podczas analizowania ciągiem szesnastkowym <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> i <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metod przyjęto założenie, że jeśli ustawiono najbardziej znaczącego bitu pierwszego bajtu w ciągu lub jeśli cyfry szesnastkowe ciąg reprezentuje niższe cztery bity wartość bajtu, wartość to przedstawić przy użyciu dwóch jego reprezentacja dopełnienia. Na przykład zarówno "FF01" i "F01" reprezentują-255 wartości dziesiętnych. Rozróżnianie dodatnią z wartości ujemnych, liczbę wartości dodatnich powinna zawierać zerem. Odpowiednie przeciążeń <xref:System.Numerics.BigInteger.ToString%2A> metody, gdy są one przekazywane ciąg formatu "X", dodać zera do zwracany ciąg szesnastkowy dla wartości dodatnie. Dzięki temu przesyłania danych <xref:System.Numerics.BigInteger> wartości przy użyciu <xref:System.Numerics.BigInteger.ToString%2A> i <xref:System.Numerics.BigInteger.Parse%2A> metody, jak przedstawiono w następującym przykładzie.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#5)]  
  
 Jednak ciągów szesnastkowych utworzona przez wywołanie metody `ToString` metod innych typów całkowitych lub przeciążeń <xref:System.Convert.ToString%2A> — metoda, która zawiera `toBase` parametr wskazuje znak wartość lub źródłowego typu danych, z którego ciąg szesnastkowy został uzyskany. Pomyślnie tworzenia wystąpienia <xref:System.Numerics.BigInteger> dodatkowe logikę wymaga wartości z tych parametrów. W poniższym przykładzie przedstawiono jeden wdrażanych.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples2.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">Tablica wartości bajtu w kolejności little endian.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury, używając wartości z tablicy bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poszczególne bajty `value` tablicy powinna być w kolejności little endian z najniższą kolejności bajtów do najwyższej kolejności bajtów. Na przykład wartość liczbowa 1,000,000,000,000 odpowiada, jak pokazano w poniższej tabeli:  
  
|||  
|-|-|  
|Ciąg szesnastkowy|E8D4A51000|  
|Tablica bajtów (najniższy indeksu najpierw)|00 10 A5 D4 E8 00|  
  
 Większości metod, które Konwertuj wartości liczbowych na tablice typu byte, takich jak <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> i <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>, zwraca tablice typu byte w kolejności little endian.  
  
 Konstruktor oczekuje wartości dodatnie w tablicy bajtów na potrzeby użyj dwóch jego reprezentacja dopełnienia reprezentacja logowania i wielkości i wartości ujemnych. Innymi słowy Jeśli najwyższej kolejności bit bajtu najwyższej kolejności w `value` ustawiono powstałe w ten sposób <xref:System.Numerics.BigInteger> wartość jest liczbą ujemną. W zależności od źródła tablicy bajtów może to spowodować wartość dodatnią zostać błędnie zinterpretowane jako wartość ujemną. Tablice typu byte są zwykle generowane w następujący sposób:  
  
-   Wywołując <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> metody. Ta metoda zwraca tablicę bajtów z bitowego najwyższej kolejności o najwyższej kolejności bajtów w zestawie tablicy równą zero dla wartości dodatnie, nie istnieje wystąpienia misinterpreting dodatnią jako ujemne. Niezmodyfikowane tablice typu byte utworzone przez <xref:System.Numerics.BigInteger.ToByteArray%2A> zawsze pomyślnie wykonywać Rundy, gdy są one przekazywane do metody <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> konstruktora.  
  
-   Wywołując <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> — metoda i przekazaniem go całkowita jako parametr. Liczb całkowitych ze znakiem obsługiwać reprezentacja logowania i wielkości i dwa jego reprezentacja dopełnienia, nie istnieje wystąpienia misinterpreting dodatnią jako ujemne.  
  
-   Wywołując <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> — metoda i przekazaniem go całkowitą bez znaku jako parametr. Ponieważ liczb całkowitych bez znaku są reprezentowane przez ich znaczenie tylko, liczbę wartości dodatnich może być błędnie zinterpretowana jako wartości ujemnych. Aby uniknąć tego błędnej interpretacji, można dodać zera bajtową wartość do końca tablicy. W przykładzie w następnej sekcji przedstawiono ilustracji.  
  
-   Tworząc tablicę bajtów albo dynamicznie lub statycznie bez niekoniecznie wywoływanie jednego z poprzednich metod lub przez zmodyfikowanie istniejącej tablicy bajtów. Aby zapobiec jest nieprawidłowo interpretowane jako wartości ujemnych wartości dodatnie, można dodać zera bajtową wartość do końca tablicy.  
  
 Jeśli `value` jest pusta <xref:System.Byte> tablicy, nowa <xref:System.Numerics.BigInteger> obiektu jest ustawiana na wartość <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>. Jeśli `value` jest `null`, zgłasza konstruktora <xref:System.ArgumentNullException>.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Numerics.BigInteger> obiektu z tablicą bajtów elementu 5, którego wartość wynosi {5, 4, 3, 2, 1}. Następnie wyświetla <xref:System.Numerics.BigInteger> reprezentowaną jako zarówno dziesiętną, a szesnastkową liczby, w konsoli. Porównanie wartości tablicy wejściowej z tekst wyjściowy ułatwia wyczyść dlaczego tego przeciążenia <xref:System.Numerics.BigInteger> tworzy konstruktora klasy <xref:System.Numerics.BigInteger> obiektu, którego wartość jest 4328719365 (lub 0x102030405). Pierwszy element tablicy bajtów, którego wartość to 5, definiuje wartość bajtu najniższy kolejności <xref:System.Numerics.BigInteger> obiektu, który jest 0x05. Drugi element tablicy bajtów, którego wartość wynosi 4, definiuje wartość bajtu drugi <xref:System.Numerics.BigInteger> obiektu, który jest 0x04 i tak dalej.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ctors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#1)]  
  
 Poniższy przykład tworzy dodatnie i ujemne <xref:System.Numerics.BigInteger> wartość, przekazuje je do <xref:System.Numerics.BigInteger.ToByteArray%2A> metody, a następnie przywrócenie oryginalnej <xref:System.Numerics.BigInteger> wartości wynikowej tablicy bajtów. Należy pamiętać, że te dwie wartości są reprezentowane przez tablice typu byte identyczne. Jedyną różnicą między nimi jest najbardziej znaczącego bitu ostatniego elementu w tablicy bajtów. Ten bit jest ustawiony (wartość bajtu to 0xFF), jeśli tablicy jest tworzona na podstawie ujemny <xref:System.Numerics.BigInteger> wartość. Bit nie zdefiniowano (wartość bajtu wynosi zero), jeśli tablica jest tworzona na podstawie dodatnią <xref:System.Numerics.BigInteger> wartość.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.ctors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#2)]  
  
 Poniższy przykład przedstawia sposób upewnić się, że wartość dodatnią jest nie niepoprawnie wystąpienia jako wartość ujemną, dodając którego wartość wynosi zero do końca tablicy typu byte.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ctors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToByteArray" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::Decimal value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Liczba dziesiętna.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury, za pomocą <see cref="T:System.Decimal" /> wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wynikiem wywołania tego konstruktora jest taki sam jak przypisywanie jawnie <xref:System.Decimal> do wartości <xref:System.Numerics.BigInteger> zmiennej.  
  
 Wywołanie konstruktora może spowodować utratę danych; wszystkie części ułamkowej `value` zostały obcięte podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> Konstruktor do tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu. Definiuje tablicę <xref:System.Decimal> wartości, a następnie przekazuje każdej wartości <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> konstruktora. Należy pamiętać, że <xref:System.Decimal> wartość zostanie obcięta zamiast zaokrąglona, gdy jest przypisany do <xref:System.Numerics.BigInteger> obiektu.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ctors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(double value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Wartość zmiennoprzecinkową podwójnej precyzji.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury przy użyciu wartości zmiennoprzecinkowej podwójnej precyzji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie części ułamkowej `value` parametru zostały obcięte podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu.  
  
 Ze względu na brak dokładności <xref:System.Double> typu danych, wywoływania ten konstruktor może spowodować utratę danych.  
  
 <xref:System.Numerics.BigInteger> Wartość będącą wynikiem wywołania tego konstruktora jest taka sama jak wartość będącą wynikiem jawnie przypisywanie <xref:System.Double> do wartości <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29> Konstruktor do tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu. Również dwie utratę dokładności, który może wystąpić, gdy używasz <xref:System.Double> — typ danych. A <xref:System.Double> przypisano duża wartość, która jest następnie przypisana do <xref:System.Numerics.BigInteger> obiektu. Jak pokazano na dane wyjściowe, to przypisanie pociąga za sobą zmniejszenie precyzji. Obie wartości są następnie zwiększany o jeden. Dane wyjściowe wskazuje, że <xref:System.Numerics.BigInteger> obiektu odzwierciedla zmieniona wartość, podczas gdy <xref:System.Double> obiektu nie.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#5)]
 [!code-vb[System.Numerics.BigInteger.ctors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość <paramref name="value" /> jest <see cref="F:System.Double.NaN" />.  
  
 —lub—  
  
 Wartość <paramref name="value" /> jest <see cref="F:System.Double.NegativeInfinity" />.  
  
 —lub—  
  
 Wartość <paramref name="value" /> jest <see cref="F:System.Double.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(int value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Całkowita 32-bitowych.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury przy użyciu wartości 32-bitowej liczby całkowitej ze znakiem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie są tracone dokładności podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu za pomocą tego konstruktora.  
  
 <xref:System.Numerics.BigInteger> Wartość będącą wynikiem wywołania tego konstruktora jest taka sama jak wartość będącą wynikiem przypisywanie <xref:System.Int32> do wartości <xref:System.Numerics.BigInteger>.  
  
 <xref:System.Numerics.BigInteger> Struktury nie ma konstruktorów z parametrem typu <xref:System.Byte>, <xref:System.Int16>, <xref:System.SByte>, lub <xref:System.UInt16>. Jednak <xref:System.Int32> typu obsługuje niejawnej konwersji wartości 8-bitowych i 16-bitowych znakiem i bez znaku liczb całkowitych liczb całkowitych ze znakiem 32-bitowych. W związku z tym ten konstruktor jest wywoływana, gdy `value` jest jednym z tych czterech typów całkowitych.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29> Konstruktor do tworzenia wystąpienia <xref:System.Numerics.BigInteger> wartości z tablicy 32-bitowych liczb całkowitych. Niejawna konwersja go używa również przypisać każdej wartości 32-bitową liczbę całkowitą <xref:System.Numerics.BigInteger> zmiennej. Następnie porównuje dwie wartości ustalenie, czy powstałe w ten sposób <xref:System.Numerics.BigInteger> wartości są takie same.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.ctors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(long value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Całkowita 64-bitowych.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury przy użyciu wartości 64-bitowej podpisanej liczby całkowitej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie są tracone dokładności podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu za pomocą tego konstruktora.  
  
 <xref:System.Numerics.BigInteger> Wartość będącą wynikiem wywołania tego konstruktora jest taka sama jak wartość będącą wynikiem przypisywanie <xref:System.Int64> do wartości <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29> Konstruktor do tworzenia wystąpienia <xref:System.Numerics.BigInteger> wartości z tablicy 64-bitowych liczb całkowitych. Niejawna konwersja go używa również przypisać każdej wartości 64-bitową liczbę całkowitą <xref:System.Numerics.BigInteger> zmiennej. Następnie porównuje dwie wartości ustalenie, czy powstałe w ten sposób <xref:System.Numerics.BigInteger> wartości są takie same.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#7)]
 [!code-vb[System.Numerics.BigInteger.ctors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(float value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Wartość zmiennoprzecinkową o pojedynczej dokładności.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury przy użyciu wartości zmiennoprzecinkowej pojedynczej precyzji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie części ułamkowej `value` parametru zostały obcięte podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu.  
  
 Ze względu na brak dokładności <xref:System.Single> typu danych, wywoływania ten konstruktor może spowodować utratę danych.  
  
 <xref:System.Numerics.BigInteger> Wartość będącą wynikiem wywołania tego konstruktora jest taka sama jak wartość będącą wynikiem jawnie przypisywanie <xref:System.Single> do wartości <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29> Konstruktor do tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu. Również dwie utratę dokładności, który może wystąpić, gdy używasz <xref:System.Single> — typ danych. A <xref:System.Single> przypisano duża wartość ujemną, która jest następnie przypisana do <xref:System.Numerics.BigInteger> obiektu. Jak pokazano na dane wyjściowe, to przypisanie pociąga za sobą zmniejszenie precyzji. Obie wartości są następnie zwiększany o jeden. Dane wyjściowe wskazuje, że <xref:System.Numerics.BigInteger> obiektu odzwierciedla zmieniona wartość, podczas gdy <xref:System.Single> obiektu nie.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#8)]
 [!code-vb[System.Numerics.BigInteger.ctors#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość <paramref name="value" /> jest <see cref="F:System.Single.NaN" />.  
  
 —lub—  
  
 Wartość <paramref name="value" /> jest <see cref="F:System.Single.NegativeInfinity" />.  
  
 —lub—  
  
 Wartość <paramref name="value" /> jest <see cref="F:System.Single.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt32 value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość liczby całkowitej bez znaku 32-bitowych.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury przy użyciu wartości bez znaku 32-bitowej liczby całkowitej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie są tracone dokładności podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> za pomocą tego konstruktora.  
  
 <xref:System.Numerics.BigInteger> Wartość będącą wynikiem wywołania tego konstruktora jest taka sama jak wartość będącą wynikiem przypisywanie <xref:System.UInt32> do wartości <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29> Konstruktor i instrukcji przypisania, aby zainicjować <xref:System.Numerics.BigInteger> wartości z tablicy liczb całkowitych bez znaku 32-bitowych. Następnie porównuje dwie wartości i Wykaż, że te dwie metody inicjowania <xref:System.Numerics.BigInteger> wartość tworzy identycznych wyników.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#9)]
 [!code-vb[System.Numerics.BigInteger.ctors#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#9)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt64 value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">64-bitowa liczba całkowita bez znaku.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury z wartością całkowitą 64-bitowych unsigned.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie są tracone dokładności podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> za pomocą tego konstruktora.  
  
 <xref:System.Numerics.BigInteger> Wartość będącą wynikiem wywołania tego konstruktora jest taka sama jak wartość będącą wynikiem przypisywanie <xref:System.UInt64> do wartości <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29> Konstruktor do tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu, którego wartość jest równa <xref:System.UInt64.MaxValue>.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#10)]
 [!code-vb[System.Numerics.BigInteger.ctors#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#10)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ReadOnlySpan&lt;byte&gt; value, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; value, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.ReadOnlySpan{System.Byte},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Byte), Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Abs (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Abs(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Abs(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Liczba.</param>
        <summary>Pobiera wartość bezwzględną liczby <see cref="T:System.Numerics.BigInteger" /> obiektu.</summary>
        <returns>Wartość bezwzględna <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość bezwzględna liczby jest ten numer bez znaku, jak pokazano w poniższej tabeli.  
  
|`value` Parametr|Wartość zwracana|  
|-----------------------|------------------|  
|`value` >= 0|`value`|  
|`value` < 0|`value` * -1|  
  
 <xref:System.Numerics.BigInteger.Abs%2A> Metoda jest odpowiednikiem <xref:System.Math.Abs%2A?displayProperty=nameWithType> metody dla typów pierwotnych liczbowych.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.Abs%2A> metodę, aby przekonwertować <xref:System.Numerics.BigInteger> wartość z reprezentacji dopełnienia dwóch w reprezentacji logowania i wielkości przed szeregując go do pliku. Dane w pliku jest następnie zdeserializować i przypisana do nowej <xref:System.Numerics.BigInteger> obiektu.  
  
 [!code-csharp[System.Numerics.BigInteger.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Abs(System.SByte)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Add (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Add(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Add(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do dodania.</param>
        <param name="right">Druga wartość do dodania.</param>
        <summary>Dodaje dwa <see cref="T:System.Numerics.BigInteger" /> wartości i zwraca wynik.</summary>
        <returns>Suma <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Języki, które nie obsługują przeładowania operatora lub operatory niestandardowych można używać <xref:System.Numerics.BigInteger.Add%2A> metodę w celu dodania przy użyciu <xref:System.Numerics.BigInteger> wartości.  
  
 <xref:System.Numerics.BigInteger.Add%2A> Metoda jest przydatna zamiast operatora dodawania podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> zmiennej przypisać sum, będące wynikiem dodania, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (left As BigInteger, right As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Porównuje dwa <see cref="T:System.Numerics.BigInteger" /> wartości i zwraca liczbę całkowitą, która wskazuje, czy pierwsza wartość jest mniejsza niż równa lub większa od drugiej wartości.</summary>
        <returns>Całkowita wskazująca wartości <paramref name="left" /> i <paramref name="right" />, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość  
  
 </term><description> Warunek  
  
 </description></listheader><item><term> Mniejsza od zera.  
  
 </term><description><paramref name="left" /> jest mniejsza niż <paramref name="right" />.  
  
 </description></item><item><term> Zero  
  
 </term><description><paramref name="left" /> Equals <paramref name="right" />.  
  
 </description></item><item><term> Większa niż zero  
  
 </term><description><paramref name="left" /> jest większa niż <paramref name="right" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że <xref:System.Numerics.BigInteger> typ ma zakres stałej nie porównania <xref:System.Numerics.BigInteger> wartości nie charakteryzują się brak dokładności, która charakteryzuje porównanie liczb zmiennoprzecinkowych. Poniższy przykład porównuje dwa <xref:System.Numerics.BigInteger> wartości, które różnią się jeden i że każdy ma 1,896 cyfr. <xref:System.Numerics.BigInteger.Compare%2A> — Metoda prawidłowo informuje, czy dwie wartości nie są takie same.  
  
 [!code-csharp[System.Numerics.BigInteger.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/cs/Compare1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/vb/Compare1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.CompareTo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Porównuje wartość tego wystąpienia z inną wartość i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejszy, równy lub większy niż inne wartości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As Long) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(long other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">Całkowita 64-bitowa do porównania.</param>
        <summary>Porównuje tego wystąpienia całkowita 64-bitowa i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejsza niż, równa lub większa niż wartość całkowita 64-bitowa.</summary>
        <returns>Wartość całkowita, która wskazuje relacji tego wystąpienia <paramref name="other" />, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość zwracana  
  
 </term><description> Opis elementu  
  
 </description></listheader><item><term> Mniejsza od zera.  
  
 </term><description> Bieżące wystąpienie jest mniejsza niż <paramref name="other" />.  
  
 </description></item><item><term> Zero  
  
 </term><description> Bieżące wystąpienie jest równe <paramref name="other" />.  
  
 </description></item><item><term> Większa niż zero  
  
 </term><description> Bieżące wystąpienie jest większa niż <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `other` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartość przy <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> metoda jest wywoływana.  
  
   
  
## Examples  
 Poniższy przykład przedstawia wyniku wywołania metody <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> metody o wartości całkowitej.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#3)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Numerics::BigInteger other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt do porównania.</param>
        <summary>Porównuje to wystąpienie do drugiej <see cref="T:System.Numerics.BigInteger" /> i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejszy, równa lub większa niż wartość określonego obiektu.</summary>
        <returns>Wartość całkowita, która wskazuje relacji tego wystąpienia <paramref name="other" />, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość zwracana  
  
 </term><description> Opis elementu  
  
 </description></listheader><item><term> Mniejsza od zera.  
  
 </term><description> Bieżące wystąpienie jest mniejsza niż <paramref name="other" />.  
  
 </description></item><item><term> Zero  
  
 </term><description> Bieżące wystąpienie jest równe <paramref name="other" />.  
  
 </description></item><item><term> Większa niż zero  
  
 </term><description> Bieżące wystąpienie jest większa niż <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie metody <xref:System.Numerics.BigInteger.CompareTo%2A> implementuje metody <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> metody. Jest używany przez obiekty kolekcji ogólnej porządkowania elementów w kolekcji.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29> metody, aby uporządkować listę `StarInfo` obiektów. Każdy `StarInfo` obiektu zawiera informacje o nazwie gwiazdy i jego odległości od Earth w milach. `StarInfo` implementuje <xref:System.IComparable%601> interfejsu, które umożliwia `StarInfo` obiektów, które mają być sortowane według klasy rodzajowej kolekcji. Jego <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> implementacji opakowuje tylko wywołania <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#1)]  
  
 Poniższy kod tworzy następnie cztery `StarInfo` obiekty i przechowuje je w ogólnej metodzie <xref:System.Collections.Generic.List%601> obiektu. Po <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> metoda jest wywoływana, `StarInfo` obiekty są wyświetlane w kolejności ich odległość od ziemi.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania.</param>
        <summary>Porównuje tego wystąpienia określonego obiektu i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejszy, równa lub większa niż wartość określonego obiektu.</summary>
        <returns>Całkowita wskazująca relacji do bieżącego wystąpienia <paramref name="obj" /> parametru, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość zwracana  
  
 </term><description> Opis elementu  
  
 </description></listheader><item><term> Mniejsza od zera.  
  
 </term><description> Bieżące wystąpienie jest mniejsza niż <paramref name="obj" />.  
  
 </description></item><item><term> Zero  
  
 </term><description> Bieżące wystąpienie jest równe <paramref name="obj" />.  
  
 </description></item><item><term> Większa niż zero  
  
 </term><description> Bieżące wystąpienie jest większa niż <paramref name="obj" />, lub <paramref name="obj" /> parametr jest <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie metody <xref:System.Numerics.BigInteger.CompareTo%2A> implementuje metody <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType> metody. Jest używany przez obiekty kolekcja nierodzajową porządkowania elementów w kolekcji.  
  
 `obj` Parametr musi mieć jedną z następujących czynności:  
  
-   Obiekt o typie środowiska wykonawczego <xref:System.Numerics.BigInteger>.  
  
-   <xref:System.Object> Zmiennej, którego wartość jest `null`. Jeśli wartość `obj` parametr jest `null`, metoda zwraca wartość 1, która wskazuje, czy bieżące wystąpienie jest większa niż `obj`.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> metody do porównania <xref:System.Numerics.BigInteger> wartości z każdego elementu w tablicy obiektów  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="obj" /> nie jest <see cref="T:System.Numerics.BigInteger" />.</exception>
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As ULong) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::UInt64 other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">64-bitowa liczba całkowita bez znaku do porównania.</param>
        <summary>Porównuje tego wystąpienia na liczbę całkowitą bez znaku 64-bitowe i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejszy, równa lub większa niż wartość liczby całkowitej bez znaku 64-bitowych.</summary>
        <returns>Całkowita wskazująca względna wartość tego wystąpienia i <paramref name="other" />, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość zwracana  
  
 </term><description> Opis elementu  
  
 </description></listheader><item><term> Mniejsza od zera.  
  
 </term><description> Bieżące wystąpienie jest mniejsza niż <paramref name="other" />.  
  
 </description></item><item><term> Zero  
  
 </term><description> Bieżące wystąpienie jest równe <paramref name="other" />.  
  
 </description></item><item><term> Większa niż zero  
  
 </term><description> Bieżące wystąpienie jest większa niż <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Divide (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Divide(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Divide(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Wartość podział.</param>
        <param name="divisor">Wartość do dzielenia przez.</param>
        <summary>Dzieli jedną <see cref="T:System.Numerics.BigInteger" /> przez inną wartość i zwraca wynik.</summary>
        <returns>Iloraz z dzielenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Divide%2A> Metoda przeprowadza dzielenie liczby całkowitej; reszta będącą wynikiem podziału zostaną odrzucone. Aby wykonać dzielenie liczby całkowitej przy zachowaniu pozostałą, należy wywołać <xref:System.Numerics.BigInteger.DivRem%2A> metody. Aby pobrać tylko resztę, należy wywołać <xref:System.Numerics.BigInteger.Remainder%2A> metody.  
  
 <xref:System.Numerics.BigInteger.Divide%2A> Metody mogą być używane przez języki, które nie obsługują przeładowania operatora. Jego zachowanie jest identyczne dzielenia przy użyciu operatora dzielenia.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę <xref:System.Numerics.BigInteger> wartości. Następnie używa każdy element jako iloraz w operacji dzielenia, która używa <xref:System.Numerics.BigInteger.Divide%2A> — metoda, operator dzielenia (/) i <xref:System.Numerics.BigInteger.DivRem%2A> metody.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> to 0 (zero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger DivRem (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor, out System.Numerics.BigInteger remainder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger DivRem(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor, [out] valuetype System.Numerics.BigInteger&amp; remainder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (dividend As BigInteger, divisor As BigInteger, ByRef remainder As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger DivRem(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor, [Runtime::InteropServices::Out] System::Numerics::BigInteger % remainder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
        <Parameter Name="remainder" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="dividend">Wartość podział.</param>
        <param name="divisor">Wartość do dzielenia przez.</param>
        <param name="remainder">Po powrocie z tej metody zawiera <see cref="T:System.Numerics.BigInteger" /> wartość, która reprezentuje resztę z dzielenia. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Dzieli jedną <see cref="T:System.Numerics.BigInteger" /> wartości i zwraca wynik i zwraca resztę do parametru output.</summary>
        <returns>Iloraz z dzielenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia zachowanie zarówno iloraz i pozostałej, będącą wynikiem dzielenie liczby całkowitej. Jeśli nie jest konieczne w pozostałej, użyj <xref:System.Numerics.BigInteger.Divide%2A> metody lub operator dzielenia; w przypadku jedynie zainteresowani pozostałą, użyć <xref:System.Numerics.BigInteger.Remainder%2A> metody.  
  
 Znak zwracana `remainder` wartość jest taka sama jak znak `dividend` parametru.  
  
 Zachowanie <xref:System.Numerics.BigInteger.DivRem%2A> metoda jest identyczna ze <xref:System.Math.DivRem%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę <xref:System.Numerics.BigInteger> wartości. Następnie używa każdy element jako iloraz w operacji dzielenia, która używa <xref:System.Numerics.BigInteger.Divide%2A> — metoda, operator dzielenia (/) i <xref:System.Numerics.BigInteger.DivRem%2A> metody.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> to 0 (zero).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy dwie wartości liczbowe są takie same.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(long other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">Całkowita 64-bitowa wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy bieżące wystąpienie i całkowita 64-bitowa mają taką samą wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli całkowita 64-bitowa i bieżącego wystąpienia mają taką samą wartość; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `other` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartości podczas wywoływania metody.  
  
 Aby określić relacji między tymi dwoma obiektami, a nie tylko testowanie pod kątem równości, należy wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Numerics.BigInteger> obiektu z każdego typu całkowitego, z wyjątkiem <xref:System.UInt64>. Następnie wywołuje <xref:System.Numerics.BigInteger.Equals%28System.Int64%29> metody do porównania <xref:System.Numerics.BigInteger> wartości z oryginalnej wartości całkowitej, który został przekazany do <xref:System.Numerics.BigInteger> konstruktora. Jak pokazano na dane wyjściowe, wartości są równe, w każdym przypadku.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals.cpp#1)]
 [!code-csharp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::BigInteger other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy bieżące wystąpienie i określonej <see cref="T:System.Numerics.BigInteger" /> obiektu mają taką samą wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Numerics.BigInteger" /> obiektu i <paramref name="other" /> mają taką samą wartość; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda implementuje <xref:System.IEquatable%601> interfejsu i wykonuje nieco większą niż <xref:System.Numerics.BigInteger.Equals%28System.Object%29> , ponieważ nie muszą być konwertowane `other` parametr <xref:System.Numerics.BigInteger> obiektu.  
  
 Można określić relacji między tymi dwoma <xref:System.Numerics.BigInteger> obiektów, a nie tylko testowanie pod kątem równości, wywołaj <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład porównuje przybliżonej odległość kilka gwiazdy z ziemi z odległość Wskazywan Epsilon z ziemi, aby sprawdzić, czy są równe. W przykładzie użyto każdego przeciążenia <xref:System.Numerics.BigInteger.Equals%2A> metody do testowania pod kątem równości.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy bieżące wystąpienie oraz określony obiekt mają taką samą wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="obj" /> argument jest <see cref="T:System.Numerics.BigInteger" /> obiekt i jego wartość jest równa wartości bieżącego <see cref="T:System.Numerics.BigInteger" /> wystąpienia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `obj` argument nie jest <xref:System.Numerics.BigInteger> wartości, metoda zwraca `false`. Metoda zwraca `true` tylko wtedy, gdy `obj` jest <xref:System.Numerics.BigInteger> wystąpienie, którego wartość jest równa bieżącego wystąpienia.  
  
 Aby określić relacji między tymi dwoma obiektami, a nie tylko testowanie pod kątem równości, należy wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> metody.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano równoległe <xref:System.Object> i <xref:System.Numerics.BigInteger> tablic. Każdy element tablicy ma taką samą wartość jak odpowiadający mu element w tablicy drugiego. Jako dane wyjściowe w przykładzie pokazano, wystąpienie w <xref:System.Numerics.BigInteger> tablicy jest uznawany za taki sam jak wystąpienie w <xref:System.Object> tablicy tylko wtedy, gdy jest on <xref:System.Numerics.BigInteger> i ich wartości są równe.  
  
 [!code-csharp[System.Numerics.BigInteger.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/Equals_Obj1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/Equals_Obj1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::UInt64 other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">64-bitowa liczba całkowita bez znaku do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy bieżące wystąpienie i całkowitą bez znaku 64-bitowych mają taką samą wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżące wystąpienie i liczbę całkowitą bez znaku 64-bitowych mają taką samą wartość; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić relacji między tymi dwoma obiektami, a nie tylko testowanie pod kątem równości, należy wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład porównuje przybliżonej odległość kilka gwiazdy z ziemi z odległość Wskazywan Epsilon z ziemi, aby sprawdzić, czy są równe. W przykładzie użyto każdego przeciążenia <xref:System.Numerics.BigInteger.Equals%2A> metody do testowania pod kątem równości.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (bool isUnsigned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(bool isUnsigned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetByteCount(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (Optional isUnsigned As Boolean = false) As Integer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreatestCommonDivisor">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger GreatestCommonDivisor (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger GreatestCommonDivisor(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreatestCommonDivisor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger GreatestCommonDivisor(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość.</param>
        <param name="right">Druga wartość.</param>
        <summary>Wyszukuje największy wspólny dzielnik dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Największy wspólny dzielnik <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Największy wspólny dzielnik jest największą liczbę, do którego dwa <xref:System.Numerics.BigInteger> wartości można podzielić bez reszty powrotu.  
  
 Jeśli `left` i `right` parametry są liczbami zera, metoda zawsze zwraca co najmniej wartość 1, ponieważ wszystkie numery można podzielić się o 1. Jeśli albo parametr ma wartość zero, metoda zwraca wartość bezwzględną liczby parametrów inną niż zero. Jeśli obie wartości zero, metoda zwraca wartość zero.  
  
> [!NOTE]
>  Obliczanie największy wspólny dzielnik bardzo dużej wartości `left` i `right` może być bardzo czasochłonna operacja.  
  
 Wartość zwrócona przez <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> metody zawsze jest dodatnia, niezależnie od jej znaku `left` i `right` parametrów.  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywołanie <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> metody i obsługi konieczne dostarczające przydatnych informacji na temat wyjątków <xref:System.ArgumentOutOfRangeException>. Wynik wskazuje, że te dwie liczb największy wspólny dzielnik jest 1.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#10)]
 [!code-vb[System.Numeric.BigInteger.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEven">
      <MemberSignature Language="C#" Value="public bool IsEven { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEven" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsEven" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEven As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEven { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy wartość bieżącej klasy <see cref="T:System.Numerics.BigInteger" /> obiektu jest liczbą parzystą.</summary>
        <value>
          <see langword="true" /> Jeśli wartość <see cref="T:System.Numerics.BigInteger" /> obiektu jest liczbą parzystą; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest wygody, która wskazuje, czy <xref:System.Numerics.BigInteger> wartość jest podzielna przez dwa. Jest odpowiednikiem następującego wyrażenia:  
  
```csharp   
value % 2 == 0;  
```  
  
```vb  
value Mod 2 = 0  
```  
  
 Jeśli wartość bieżącej klasy <xref:System.Numerics.BigInteger> obiekt jest <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>, zwraca właściwość `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOne">
      <MemberSignature Language="C#" Value="public bool IsOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsOne" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOne As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOne { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy wartość bieżącej klasy <see cref="T:System.Numerics.BigInteger" /> obiekt jest <see cref="P:System.Numerics.BigInteger.One" />.</summary>
        <value>
          <see langword="true" /> Jeśli wartość <see cref="T:System.Numerics.BigInteger" /> obiekt jest <see cref="P:System.Numerics.BigInteger.One" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość oferuje znacznie większą wydajność niż pozostałych porównań z jednym, takich jak `thisBigInteger.Equals(BigInteger.One)`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
      </Docs>
    </Member>
    <Member MemberName="IsPowerOfTwo">
      <MemberSignature Language="C#" Value="public bool IsPowerOfTwo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPowerOfTwo" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPowerOfTwo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPowerOfTwo { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy wartość bieżącej klasy <see cref="T:System.Numerics.BigInteger" /> obiekt jest potęgą liczby dwa.</summary>
        <value>
          <see langword="true" /> Jeśli wartość <see cref="T:System.Numerics.BigInteger" /> obiekt jest potęgą liczby dwa; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość określa, czy <xref:System.Numerics.BigInteger> wartość ma jeden bit niezerową wartość. Oznacza to, że zwraca `true` Jeśli wartość bieżącej klasy <xref:System.Numerics.BigInteger> obiekt jest 1 (czyli 2<sup>0</sup>) lub dowolnego większa potęgą liczby dwa. Zwraca `false` Jeśli wartość bieżącej klasy <xref:System.Numerics.BigInteger> obiektu wynosi 0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsZero">
      <MemberSignature Language="C#" Value="public bool IsZero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsZero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsZero" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsZero As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsZero { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy wartość bieżącej klasy <see cref="T:System.Numerics.BigInteger" /> obiekt jest <see cref="P:System.Numerics.BigInteger.Zero" />.</summary>
        <value>
          <see langword="true" /> Jeśli wartość <see cref="T:System.Numerics.BigInteger" /> obiekt jest <see cref="P:System.Numerics.BigInteger.Zero" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zapewnia znacznie większą wydajność niż `BigInteger.Equals(BigInteger.Zero)`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość logarytmu określonej liczby.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Liczba, której logarytm ma zostać znaleziona.</param>
        <summary>Zwraca fizyczna (podstawowy <see langword="e" />) logarytm o podstawie określonej liczby.</summary>
        <returns>Fizyczna (podstawowy <see langword="e" />) logarytm <paramref name="value" />, jak pokazano w tabeli w sekcji uwag.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` Parametr jest określony jako podstawowy numer 10.  
  
 Dokładne zwrócić wartość ta metoda zależy od jej znaku `value`, jak pokazano w poniższej tabeli.  
  
|Zaloguj się z `value` parametru|Wartość zwracana|  
|-------------------------------|------------------|  
|Dodatnie|Logarytm naturalny `value`; oznacza to, ln `value`, lub dziennika e`value`.|  
|Zero|<xref:System.Double.NegativeInfinity>.|  
|Ujemne|<xref:System.Double.NaN>.|  
  
 Aby obliczyć logarytm 10 z <xref:System.Numerics.BigInteger> wartości, należy wywołać <xref:System.Numerics.BigInteger.Log10%2A> metody. Aby obliczyć logarytm liczby w innej bazie, należy wywołać <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29> metody.  
  
 Pierwiastek kwadratowy liczby można znaleźć wywołując <xref:System.Numerics.BigInteger.Log%2A> metody wraz z programem <xref:System.Math.Exp%2A?displayProperty=nameWithType> metody. Należy zauważyć, że wynik <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> Jeśli wynik jest większa niż <xref:System.Double.MaxValue?displayProperty=nameWithType>. W poniższym przykładzie oblicza pierwiastek kwadratowy każdego elementu w tablicy <xref:System.Numerics.BigInteger> wartości.  
  
 [!code-csharp[System.Numerics.BigInteger.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.biginteger.log/cs/log1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.biginteger.log/vb/log1.vb#1)]
  
 Ta metoda odpowiada <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> metody dla typów pierwotnych liczbowych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Logarytm naturalny z <paramref name="value" /> jest poza zakresem <see cref="T:System.Double" /> — typ danych.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger, baseValue As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value, double baseValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Liczba, której logarytm ma zostać znaleziona.</param>
        <param name="baseValue">Podstawa logarytmu.</param>
        <summary>Zwraca logarytm o określonej liczby w określonej podstawy.</summary>
        <returns>Podstawowym <paramref name="baseValue" /> logarytm <paramref name="value" />, jak pokazano w tabeli w sekcji uwag.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` i `baseValue` parametry są określane jako podstawowa 10 cyfr.  
  
 Dokładne zwrócić wartość metody zależy od jej znaku `value` logowania i wartość `baseValue`, jak pokazano w poniższej tabeli.  
  
|`value` Parametr|`baseValue` Parametr|Wartość zwracana|  
|-----------------------|---------------------------|------------------|  
|`value` > 0|(0 < `baseValue` < 1) - lub -(`baseValue` > 1)|logbaseValue (`value`)|  
|`value` < 0|(dowolna wartość)|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(dowolna wartość)|`baseValue` < 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(dowolna wartość)|`baseValue` = <xref:System.Double.NaN?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(dowolna wartość)|`baseValue` = 1|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` = 0|0 < `baseValue` < 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 0|`baseValue` > 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 1|`baseValue` = 0|0|  
|`value` = 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|0|  
  
 Aby obliczyć logarytm 10 z <xref:System.Numerics.BigInteger> wartości, należy wywołać <xref:System.Numerics.BigInteger.Log10%2A> metody. Aby obliczyć logarytm naturalny liczby, należy wywołać <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29> metody.  
  
 Ta metoda odpowiada <xref:System.Math.Log%2A?displayProperty=nameWithType> metody dla typów pierwotnych liczbowych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Dziennik <paramref name="value" /> jest poza zakresem <see cref="T:System.Double" /> — typ danych.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log10(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Liczba, której logarytm ma zostać znaleziona.</param>
        <summary>Zwraca logarytm 10 podanej liczby.</summary>
        <returns>Logarytm 10 z <paramref name="value" />, jak pokazano w tabeli w sekcji uwag.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` Parametr jest określony jako podstawowy numer 10.  
  
 Dokładne zwrócić wartość metody zależy od jej znaku `value`, jak pokazano w poniższej tabeli.  
  
|Znak, wartość parametru|Wartość zwracana|  
|-----------------------------|------------------|  
|Dodatnie|Dziennik podstawowej 10 `value`; oznacza to, że log10`value`.|  
|Zero|<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.|  
|Ujemne|<xref:System.Double.NaN?displayProperty=nameWithType>.|  
  
 Aby obliczyć logarytm naturalny <xref:System.Numerics.BigInteger> wartości, należy wywołać <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metody. Aby obliczyć logarytm liczby w innej bazie, należy wywołać <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=nameWithType> metody.  
  
 Ta metoda odpowiada <xref:System.Math.Log10%2A?displayProperty=nameWithType> metody dla typów pierwotnych liczbowych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Dziennik podstawowej 10 <paramref name="value" /> jest poza zakresem <see cref="T:System.Double" /> — typ danych.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Max (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Max(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Max(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca większej liczby dwa <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>
          <paramref name="left" /> Lub <paramref name="right" /> parametru, w zależności od jest większy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odpowiada <xref:System.Math.Max%2A?displayProperty=nameWithType> metody dla typów pierwotnych liczbowych.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.Max%2A> metoda, aby wybrać największa liczba w tablicy <xref:System.Numerics.BigInteger> wartości.  
  
 [!code-csharp[System.Numerics.BigInteger.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/cs/Max1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/vb/Max1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Min (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Min(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Min(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca mniejszy z dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>
          <paramref name="left" /> Lub <paramref name="right" /> parametru, w zależności od jest mniejsza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odpowiada <xref:System.Math.Min%2A?displayProperty=nameWithType> metody dla typów pierwotnych liczbowych.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.Min%2A> metoda, aby wybrać najmniejszą wartość w tablicy <xref:System.Numerics.BigInteger> wartości.  
  
 [!code-csharp[System.Numerics.BigInteger.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/cs/Min1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/vb/Min1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="MinusOne">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger MinusOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger MinusOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.MinusOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MinusOne As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger MinusOne { System::Numerics::BigInteger get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość reprezentującą liczbę minus (-1).</summary>
        <value>Liczba całkowita, którego wartość jest ujemna (-1).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.MinusOne%2A> Właściwość jest używana do porównania <xref:System.Numerics.BigInteger> wartość -1 lub -1, aby przypisać <xref:System.Numerics.BigInteger> obiektu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
      </Docs>
    </Member>
    <Member MemberName="ModPow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger ModPow (System.Numerics.BigInteger value, System.Numerics.BigInteger exponent, System.Numerics.BigInteger modulus);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger ModPow(valuetype System.Numerics.BigInteger value, valuetype System.Numerics.BigInteger exponent, valuetype System.Numerics.BigInteger modulus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModPow (value As BigInteger, exponent As BigInteger, modulus As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger ModPow(System::Numerics::BigInteger value, System::Numerics::BigInteger exponent, System::Numerics::BigInteger modulus);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Numerics.BigInteger" />
        <Parameter Name="modulus" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Numer, do której zostaną podniesione <c>wykładnik</c> zasilania.</param>
        <param name="exponent">Wykładnik, aby podnieść <c>wartość</c> przez.</param>
        <param name="modulus">Liczbę, przez którą chcesz podzielić <c>wartość</c> do <c>wykładnik</c> zasilania.</param>
        <summary>Wykonuje dzielenie modulo na liczbę podniesioną do potęgi równej innej liczbie.</summary>
        <returns>Resztę po podzieleniu <paramref name="value" /><sup>wykładnik</sup> przez <paramref name="modulus" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ModPow%2A> Metody oblicza wyrażenie następujące:  
  
 (baseValue ^ wykładnik) Mod modulo  
  
 Do przeprowadzenia potęgowania na <xref:System.Numerics.BigInteger> Użyj wartości bez dzielenie modulo <xref:System.Numerics.BigInteger.Pow%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono prosty ilustracji wywołania metody <xref:System.Numerics.BigInteger.ModPow%2A> metody.  
  
 [!code-csharp[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/cs/ModPow1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/vb/ModPow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="modulus" /> wynosi zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="exponent" /> jest ujemna.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Multiply (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Multiply(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy liczbę Aby pomnożyć.</param>
        <param name="right">Druga liczba do wielokrotnie.</param>
        <summary>Zwraca iloczyn dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Iloczyn <paramref name="left" /> i <paramref name="right" /> parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Multiply%2A> Metoda została zaimplementowana dla języków, które nie obsługują przeładowania operatora. Jego zachowanie jest identyczne mnożenia przy użyciu operatora mnożenia. Ponadto <xref:System.Numerics.BigInteger.Multiply%2A> metoda jest przydatna zastępuje operator mnożenia podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> zmiennej przypisać produkt, który jest wynikiem mnożenia, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#1)]  
  
 Jeśli to konieczne, ta metoda automatycznie wykonuje niejawna konwersja z innych typów całkowitych do <xref:System.Numerics.BigInteger> obiektów. Jest to zilustrowane w przykładzie w następnej sekcji, gdzie <xref:System.Numerics.BigInteger.Multiply%2A> metody jest przekazywany dwa <xref:System.Int64> wartości.  
  
   
  
## Examples  
 Poniższy przykład próbuje wykonać mnożenia z dwóch długich liczb całkowitych. Ponieważ wynik przekracza zakres długich liczb całkowitych <xref:System.OverflowException> jest zgłaszany i <xref:System.Numerics.BigInteger.Multiply%2A> wywoływana jest metoda obsługi mnożenia. Należy pamiętać, że C# wymaga użycia albo `checked` — słowo kluczowe (jak w poniższym przykładzie) lub `/checked+` opcję kompilatora, aby upewnić się na przepełnienie liczbowe jest zgłaszany wyjątek.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#7)]
 [!code-vb[System.Numeric.BigInteger.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Negate (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Negate(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Negate(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do wskazania ujemnej.</param>
        <summary>Negacja określonej <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>Wynik <paramref name="value" /> parametru pomnożona przez wartość ujemną (-1).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Negacja uzyskuje odwrotność dodatku dla danej liczby. Odwrotność dodatku liczby jest liczba, która tworzy wartość zero, gdy jest ona dodawana do liczby.  
  
 <xref:System.Numerics.BigInteger.Negate%2A> Metoda została zaimplementowana dla języków, które nie obsługują niestandardowych operatorów. Jego zachowanie jest identyczne negacji przy użyciu Jednoargumentowy operator negacji. Ponadto <xref:System.Numerics.BigInteger.Negate%2A> metoda jest przydatna zastępuje operator negacji podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> zmiennej, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#4)]  
  
   
  
## Examples  
 Poniższy przykład przedstawia trzy sposoby negate — wartość <xref:System.Numerics.BigInteger> obiektu.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger One" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property One As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger One { System::Numerics::BigInteger get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która reprezentuje liczby jeden (1).</summary>
        <value>Obiekt, którego wartość jest jeden (1).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.One%2A> Jest zwykle używana do porównania <xref:System.Numerics.BigInteger> wartość 1 lub 1, aby przypisać <xref:System.Numerics.BigInteger> obiektu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
        <altmember cref="P:System.Numerics.BigInteger.MinusOne" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Addition(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do dodania.</param>
        <param name="right">Druga wartość do dodania.</param>
        <summary>Dodaje dwa określone wartości <see cref="T:System.Numerics.BigInteger" /> obiektów.</summary>
        <returns>Suma <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Addition%2A> Metoda definiuje operacji dodawania dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#12)]
 [!code-vb[System.Numeric.BigInteger.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#12)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Add%2A> metody zamiast tego.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseAnd">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &amp; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseAnd(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator And (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &amp;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość.</param>
        <param name="right">Druga wartość.</param>
        <summary>Wykonuje bitowej <see langword="And" /> operacji na dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Wynik operatora testu koniunkcji <see langword="And" /> operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> Metoda definiuje operatora testu koniunkcji `And` operacji <xref:System.Numerics.BigInteger> wartości. Bitowe `And` operacji Ustawia wynik bit tylko wtedy, gdy odpowiednich bitów w `left` i `right` również są ustawione, jak pokazano w poniższej tabeli.  
  
|Bit w `left`|Bit w `right`|Bit w wyniku|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|0|  
|1|1|1|  
|0|1|0|  
  
 <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> Metoda umożliwia następującego kodu:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#1)]  
  
 <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> Metoda wykonuje logiczną `And` operacji na dwóch <xref:System.Numerics.BigInteger> wartości, tak jakby były to zarówno w dwóch jego dopełnienia reprezentacji z rozszerzeniem wirtualnego logowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator | (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Or (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator |(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość.</param>
        <param name="right">Druga wartość.</param>
        <summary>Wykonuje bitowej <see langword="Or" /> operacji na dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Wynik operatora testu koniunkcji <see langword="Or" /> operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> Metoda definiuje operatora testu koniunkcji `Or` operacji <xref:System.Numerics.BigInteger> wartości. Bitowe `Or` operacji Ustawia wynik bit tylko wtedy, gdy jednego lub obu odpowiednich bitów w `left` i `right` są ustawione, jak pokazano w poniższej tabeli.  
  
|Bit w `left`|Bit w `right`|Bit w wyniku|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|1|  
|1|1|1|  
|0|1|1|  
  
 <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> Metoda umożliwia następującego kodu:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#2)]  
  
 <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> Metoda wykonuje logiczną `Or` operacji na dwóch <xref:System.Numerics.BigInteger> wartości, tak jakby były to zarówno w dwóch jego dopełnienia reprezentacji z rozszerzeniem wirtualnego logowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator -- (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Decrement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Decrement (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator --(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość, aby zmniejszyć.</param>
        <summary>Zmniejsza <see cref="T:System.Numerics.BigInteger" /> wartość 1.</summary>
        <returns>Wartość <paramref name="value" /> parametru zmniejszana o 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Decrement%2A> Metoda definiuje operacji dekrementacji dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#17)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Subtract%2A> metody zamiast tego. Na przykład:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Operators#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#3)]  
  
 Ponieważ <xref:System.Numerics.BigInteger> obiekty są niezmienne, <xref:System.Numerics.BigInteger.op_Decrement%2A> tworzy nowy operator <xref:System.Numerics.BigInteger> obiektu, którego wartość jest jeden mniejszej niż <xref:System.Numerics.BigInteger> obiektu reprezentowanego przez `value`. Oznacza to, że powtarzane wywołania <xref:System.Numerics.BigInteger.op_Decrement%2A> może być kosztowne.  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator / (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Division(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator /(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Wartość podział.</param>
        <param name="divisor">Wartość do dzielenia przez.</param>
        <summary>Dzieli określonej <see cref="T:System.Numerics.BigInteger" /> wartości przez inny określony <see cref="T:System.Numerics.BigInteger" /> wartość przy użyciu dzielenie liczby całkowitej.</summary>
        <returns>Całkowite wyniku podziału.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Division%2A> Metoda definiuje operacji dzielenia dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#13)]
 [!code-vb[System.Numeric.BigInteger.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#13)]  
  
 Języki, które nie obsługują niestandardowych operatory i przeładowania operatora można wywołać <xref:System.Numerics.BigInteger.Divide%2A> metody zamiast tego.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy przykład tworzy tablicę <xref:System.Numerics.BigInteger> wartości. Następnie używa każdy element jako iloraz w operacji dzielenia, która używa <xref:System.Numerics.BigInteger.Divide%2A> — metoda, operator dzielenia (/) i <xref:System.Numerics.BigInteger.DivRem%2A> metody.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> to 0 (zero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Equality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy dwie wartości są równe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(long left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy wartość całkowita długie i a <see cref="T:System.Numerics.BigInteger" /> wartości są równe.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> parametry mają taką samą wartość; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29> Metoda definiuje operacji porównania równości dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Operators#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#4)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> zamiast tego wystąpienia metody.  
  
 Jeśli `left` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartości podczas wykonywania operacji.  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, long right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartości i podpisem długich liczb całkowitych są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> parametry mają taką samą wartość; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29> Metoda definiuje operacji porównania równości dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Operators#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#5)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> zamiast tego wystąpienia metody.  
  
 Jeśli `right` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartości podczas wykonywania operacji.  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy wartości dwu <see cref="T:System.Numerics.BigInteger" /> obiekty są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> parametry mają taką samą wartość; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> Metoda definiuje operacji operatora równości dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#19)]
 [!code-vb[System.Numeric.BigInteger.Class#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#19)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> zamiast tego wystąpienia metody.  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.Equals" />
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartości i wartości bez znaku długich liczb całkowitych są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> parametry mają taką samą wartość; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29> Metoda definiuje operacji porównania równości dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Operators#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#6)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> zamiast tego wystąpienia metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy wartość bez znaku długich liczb całkowitych i a <see cref="T:System.Numerics.BigInteger" /> wartości są równe.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> parametry mają taką samą wartość; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29> Metoda definiuje operacji porównania równości dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#7)]
 [!code-vb[System.Numerics.BigInteger.Operators#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#7)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> zamiast tego wystąpienia metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ^ (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_ExclusiveOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Xor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ^(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość.</param>
        <param name="right">Druga wartość.</param>
        <summary>Operator wyłączny wykonuje <see langword="Or" /> (<see langword="XOr" />) operacji na dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Wynik operatora testu koniunkcji <see langword="Or" /> operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wynik operator wyłączny `Or` operacji `true` w przypadku różnych; w przeciwnym razie wartości dwa bity jest `false`. W poniższej tabeli przedstawiono wyłączne `Or` operacji.  
  
|Bit x `left`|Bit x `right`|Wartość zwracana|  
|---------------------|----------------------|------------------|  
|0|0|0|  
|0|1|1|  
|1|0|1|  
|1|1|0|  
  
 <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> Metoda umożliwia następującego kodu:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#8)]
 [!code-vb[System.Numerics.BigInteger.Operators#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#8)]  
  
 <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> Metoda przeprowadza operator wyłączny `Or` operacji na dwóch <xref:System.Numerics.BigInteger> wartości, tak jakby były to zarówno w dwóch jego dopełnienia reprezentacji z rozszerzeniem wirtualnego logowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiuje jawnej konwersji między <see cref="T:System.Numerics.BigInteger" /> obiektu i innego typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Decimal" /> do obiektu <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie części ułamkowej `value` parametr został obcięty przed konwersją.

 Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu. Ponieważ konwersja z <xref:System.Decimal> do <xref:System.Numerics.BigInteger> może pociągać za sobą żadnych części ułamkowej obcinanie `value`, Kompilatory języka nie wykonaj tę konwersję automatycznie. Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` w języku Visual Basic) jest używany. W przeciwnym razie wystąpi błąd kompilatora wyświetlane.   

 Dla języków, które nie obsługują niestandardowych operatory alternatywną metodą jest <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29?displayProperty=nameWithType>.


## Examples
 Poniższy przykład konwertuje poszczególnych elementów w tablicy <xref:System.Decimal> wartości do <xref:System.Numerics.BigInteger> obiektów, a następnie wyświetla wynik każdego konwersji. Należy pamiętać, że jakaś ułamkową część <xref:System.Decimal> wartość zostanie obcięta podczas konwersji.   

 [!code-csharp[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#1)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Double) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Double" /> do wartości <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie części ułamkowej `value` parametr został obcięty przed konwersją.

 Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu. Ponieważ konwersja z <xref:System.Double> do <xref:System.Numerics.BigInteger> może pociągać za sobą żadnych części ułamkowej obcinanie `value`, Kompilatory języka nie wykonaj tę konwersję automatycznie. Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` w języku Visual Basic) jest używany. W przeciwnym razie wystąpi błąd kompilatora wyświetlane.

 Dla języków, które nie obsługują niestandardowych operatory alternatywną metodą jest <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29?displayProperty=nameWithType>.


## Examples
 Poniższy przykład konwertuje poszczególnych elementów w tablicy <xref:System.Double> wartości do <xref:System.Numerics.BigInteger> obiektów, a następnie wyświetla wynik każdego konwersji. Należy pamiętać, że jakaś ułamkową część <xref:System.Double> wartość zostanie obcięta podczas konwersji.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#2)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#2)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość <paramref name="value" /> jest <see cref="F:System.Double.NaN" />.  
  
 —lub—  
  
 Wartość <paramref name="value" /> jest <see cref="F:System.Double.PositiveInfinity" />.
  
 —lub—  
  
 Wartość <paramref name="value" /> jest <see cref="F:System.Double.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator byte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Byte(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Byte" />.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu do wartości bajtu bez znaku.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu. Kompilatory języka nie wykonaj tę konwersję automatycznie, ponieważ może obejmować utraty danych. Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CByte` w języku Visual Basic) jest używany. W przeciwnym razie wystąpi błąd kompilatora wyświetlane.   

 Ponieważ ta operacja definiuje konwersji zawężającej, może zgłosić <xref:System.OverflowException> na czas wykonywania Jeśli <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Byte> — typ danych. Nie są tracone dokładności powstałe w ten sposób <xref:System.Byte> wartość, jeśli konwersja zakończy się pomyślnie.

## Examples
 Poniższy przykład przedstawia konwersji <xref:System.Numerics.BigInteger> do <xref:System.Byte> wartości. Umożliwia on również obsługę <xref:System.OverflowException> który jest generowany, gdy <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Byte> — typ danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#1)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.Byte.MinValue" />.  
  
 —lub—  
  
 Wartość <paramref name="value" /> jest większa niż <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Decimal" />.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> do obiektu <see cref="T:System.Decimal" /> wartość.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu. Kompilatory języka nie wykonaj tę konwersję automatycznie, ponieważ może obejmować utraty danych. Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CDec` w języku Visual Basic) jest używany.   

 Ponieważ ta operacja definiuje konwersji zawężającej, może zgłosić <xref:System.OverflowException> na czas wykonywania Jeśli <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Decimal> — typ danych. 

## Examples
 Poniższy przykład przedstawia konwersji <xref:System.Numerics.BigInteger> do <xref:System.Decimal> wartości. Umożliwia on również obsługę <xref:System.OverflowException> który jest generowany, gdy <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Decimal> — typ danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.Decimal.MinValue" />.  
  
 —lub—  
  
 Wartość <paramref name="value" /> jest większa niż <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator double(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Double" />.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> do obiektu <see cref="T:System.Double" /> wartość.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu. Kompilatory języka nie wykonaj tę konwersję automatycznie, ponieważ może obejmować utraty danych. Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CDbl` w języku Visual Basic) jest używany.   

 Ponieważ <xref:System.Numerics.BigInteger> możliwe wartości spoza zakresu <xref:System.Double> typ danych, ta operacja jest konwersji zawężającej. Jeśli konwersja zakończy się niepowodzeniem, nie generują <xref:System.OverflowException>. Zamiast tego Jeśli <xref:System.Numerics.BigInteger> wartość jest mniejsza niż <xref:System.Double.MinValue?displayProperty=nameWithType>, powstałe w ten sposób <xref:System.Double> wartość jest <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>. Jeśli <xref:System.Numerics.BigInteger> wartość jest większa niż <xref:System.Double.MaxValue?displayProperty=nameWithType>, powstałe w ten sposób <xref:System.Double> wartość jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.
 
 Konwersja typu <xref:System.Numerics.BigInteger> do <xref:System.Double> może pociągać za sobą zmniejszenie precyzji. W niektórych przypadkach utratę dokładności może spowodować powodzenie operacji rzutowania lub konwersji nawet wtedy, gdy <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Double> — typ danych. Poniższy przykład stanowi ilustrację. Przypisuje wartość maksymalna <xref:System.Double> do dwóch <xref:System.Numerics.BigInteger> zmiennych, co zwiększa <xref:System.Numerics.BigInteger> zmiennej 9.999e291, a testy dwie zmienne pod kątem równości. Zgodnie z oczekiwaniami, wywołanie <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metody pokazuje, czy są one nierówne. Jednak konwersji większy <xref:System.Numerics.BigInteger> wartości z powrotem do <xref:System.Double> zakończy się powodzeniem, mimo że <xref:System.Numerics.BigInteger> teraz przekracza wartość <xref:System.Double.MaxValue?displayProperty=nameWithType>.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#4)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#4)]   



## Examples
 Poniższy przykład przedstawia konwersji <xref:System.Numerics.BigInteger> do <xref:System.Double> wartości.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator short (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator short(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na 16-bitową liczbę całkowitą ze znakiem.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu na wartość 16-bitową liczbę całkowitą ze znakiem.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu. Kompilatory języka nie wykonaj tę konwersję automatycznie, ponieważ może obejmować utraty danych. Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CShort` w języku Visual Basic) jest używany. W przeciwnym razie wystąpi błąd kompilatora wyświetlane.   

 Ponieważ ta operacja definiuje konwersji zawężającej, może zgłosić <xref:System.OverflowException> na czas wykonywania Jeśli <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Int16> — typ danych. Nie są tracone dokładności powstałe w ten sposób <xref:System.Int16> wartość, jeśli konwersja zakończy się pomyślnie.

## Examples
 Poniższy przykład przedstawia konwersji <xref:System.Numerics.BigInteger> do <xref:System.Int16> wartości. Umożliwia on również obsługę <xref:System.OverflowException> który jest generowany, gdy <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Int16> — typ danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#4)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.Int16.MinValue" />.  
  
 —lub—  
  
 Wartość <paramref name="value" /> jest większa niż <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na 32-bitowej podpisanej liczby całkowitej.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu wartości 32-bitowej liczby całkowitej ze znakiem.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu. Kompilatory języka nie wykonaj tę konwersję automatycznie, ponieważ może obejmować utraty danych. Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CInt` w języku Visual Basic) jest używany. W przeciwnym razie wystąpi błąd kompilatora wyświetlane.   

 Ponieważ ta operacja definiuje konwersji zawężającej, może zgłosić <xref:System.OverflowException> na czas wykonywania Jeśli <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Int32> — typ danych. Nie są tracone dokładności powstałe w ten sposób <xref:System.Int16> wartość, jeśli konwersja zakończy się pomyślnie.

## Examples
 Poniższy przykład przedstawia konwersji <xref:System.Numerics.BigInteger> do <xref:System.Int32> wartości. Umożliwia on również obsługę <xref:System.OverflowException> który jest generowany, gdy <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Int32> — typ danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#5)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.Int32.MinValue" />.  
  
 —lub—  
  
 Wartość <paramref name="value" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na 64-bitowej podpisanej liczby całkowitej.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu na wartość 64-bitowej podpisanej liczby całkowitej.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu. Kompilatory języka nie wykonaj tę konwersję automatycznie, ponieważ może obejmować utraty danych. Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CLng` w języku Visual Basic) jest używany. W przeciwnym razie wystąpi błąd kompilatora wyświetlane.  

 Ponieważ ta operacja definiuje konwersji zawężającej, może zgłosić <xref:System.OverflowException> na czas wykonywania Jeśli <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Int64> — typ danych. 

## Examples
 Poniższy przykład przedstawia konwersji <xref:System.Numerics.BigInteger> do <xref:System.Int64> wartości. Umożliwia on również obsługę <xref:System.OverflowException> który jest generowany, gdy <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Int64> — typ danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#6)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.Int64.MinValue" />.  
  
 —lub—  
  
 Wartość <paramref name="value" /> jest większa niż <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator sbyte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::SByte(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na podpisem 8-bitową wartość.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu podpisem wartości 8-bitowych.  
  
 Ten interfejs API nie jest zgodny ze specyfikacją CLS. Alternatywa zgodna ze standardem jest <see cref="T:System.Int16" />.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu. Kompilatory języka nie wykonaj tę konwersję automatycznie, ponieważ może obejmować utraty danych. Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CSByte` w języku Visual Basic) jest używany. W przeciwnym razie wystąpi błąd kompilatora wyświetlane.  

 Ponieważ ta operacja definiuje konwersji zawężającej, może zgłosić <xref:System.OverflowException> na czas wykonywania Jeśli <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.SByte> — typ danych. Nie są tracone dokładności powstałe w ten sposób <xref:System.SByte> wartość, jeśli konwersja zakończy się pomyślnie.

## Examples
 Poniższy przykład przedstawia konwersji <xref:System.Numerics.BigInteger> do <xref:System.SByte> wartości. Umożliwia on również obsługę <xref:System.OverflowException> który jest generowany, gdy <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.SByte> — typ danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#7)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.SByte.MinValue" />.  
  
 —lub—  
  
 Wartość <paramref name="value" /> jest większa niż <see cref="F:System.SByte.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator float(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na wartość zmiennoprzecinkową o pojedynczej dokładności.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu do wartości zmiennoprzecinkowych pojedynczej precyzji.</summary>
        <returns>Obiekt zawierający najbliższego reprezentacja możliwe <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu. Kompilatory języka nie wykonaj tę konwersję automatycznie, ponieważ może obejmować, utrata danych lub utratę dokładności. Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CSng` w języku Visual Basic) jest używany. W przeciwnym razie wystąpi błąd kompilatora wyświetlane.    

 Ponieważ <xref:System.Numerics.BigInteger> możliwe wartości spoza zakresu <xref:System.Single> typ danych, ta operacja jest konwersji zawężającej. Jeśli konwersja zakończy się niepowodzeniem, nie generują <xref:System.OverflowException>. Zamiast tego Jeśli <xref:System.Numerics.BigInteger> wartość jest mniejsza niż <xref:System.Single.MinValue?displayProperty=nameWithType>, powstałe w ten sposób <xref:System.Single> wartość jest <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>. Jeśli <xref:System.Numerics.BigInteger> wartość jest większa niż <xref:System.Single.MaxValue?displayProperty=nameWithType>, powstałe w ten sposób <xref:System.Single> wartość jest <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>.

 Konwersja typu <xref:System.Numerics.BigInteger> do <xref:System.Single> może pociągać za sobą zmniejszenie precyzji. W niektórych przypadkach utratę dokładności może spowodować powodzenie operacji rzutowania lub konwersji nawet wtedy, gdy <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Single> — typ danych. Poniższy przykład stanowi ilustrację. Przypisuje wartość maksymalna <xref:System.Single> do dwóch <xref:System.Numerics.BigInteger> zmiennych, co zwiększa <xref:System.Numerics.BigInteger> zmiennej 9.999e291, a testy dwie zmienne pod kątem równości. Zgodnie z oczekiwaniami, wywołanie <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metody pokazuje, czy są one nierówne. Jednak konwersji większy <xref:System.Numerics.BigInteger> wartości z powrotem do <xref:System.Single> zakończy się powodzeniem, mimo że <xref:System.Numerics.BigInteger> teraz przekracza wartość <xref:System.Single.MaxValue?displayProperty=nameWithType>.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#5)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#5)]   



## Examples
 Poniższy przykład przedstawia konwersji <xref:System.Numerics.BigInteger> do <xref:System.Single> wartości.   
     
 [!code-csharp[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ushort (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt16(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę całkowitą bez znaku 16-bitowych.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu niepodpisane 16-bitową liczbę całkowitą.  
  
 Ten interfejs API nie jest zgodny ze specyfikacją CLS. Alternatywa zgodna ze standardem jest <see cref="T:System.Int32" />.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu. Kompilatory języka nie wykonaj tę konwersję automatycznie, ponieważ może obejmować utraty danych. Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CUShort` w języku Visual Basic) jest używany. W przeciwnym razie wystąpi błąd kompilatora wyświetlane.    

 Ponieważ ta operacja definiuje konwersji zawężającej, może zgłosić <xref:System.OverflowException> na czas wykonywania Jeśli <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.UInt16> — typ danych. Nie są tracone dokładności powstałe w ten sposób <xref:System.UInt16> wartość, jeśli konwersja zakończy się pomyślnie.

## Examples
 Poniższy przykład przedstawia konwersji <xref:System.Numerics.BigInteger> do <xref:System.UInt16> wartości. Umożliwia on również obsługę <xref:System.OverflowException> który jest generowany, gdy <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.UInt16> — typ danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#9)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#9)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.UInt16.MinValue" />.  
  
 —lub—  
  
 Wartość <paramref name="value" /> jest większa niż <see cref="F:System.UInt16.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt32(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę całkowitą bez znaku 32-bitowych.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu wartości bez znaku 32-bitowej liczby całkowitej.  
  
 Ten interfejs API nie jest zgodny ze specyfikacją CLS. Alternatywa zgodna ze standardem jest <see cref="T:System.Int64" />.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu. Kompilatory języka nie wykonaj tę konwersję automatycznie, ponieważ może obejmować utraty danych. Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CUInt` w języku Visual Basic) jest używany. W przeciwnym razie wystąpi błąd kompilatora wyświetlane.    

 Ponieważ ta operacja definiuje konwersji zawężającej, może zgłosić <xref:System.OverflowException> na czas wykonywania Jeśli <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.UInt32> — typ danych. Nie są tracone dokładności powstałe w ten sposób <xref:System.UInt32> wartość, jeśli konwersja zakończy się pomyślnie.

## Examples
 Poniższy przykład przedstawia konwersji <xref:System.Numerics.BigInteger> do <xref:System.UInt32> wartości. Umożliwia on również obsługę <xref:System.OverflowException> który jest generowany, gdy <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.UInt32> — typ danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#10)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#10)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.UInt32.MinValue" />.  
  
 —lub—  
  
 Wartość <paramref name="value" /> jest większa niż <see cref="F:System.UInt32.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt64(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę całkowitą bez znaku 64-bitowych.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu na wartość całkowitą 64-bitowych unsigned.  
  
 Ten interfejs API nie jest zgodny ze specyfikacją CLS. Alternatywa zgodna ze standardem jest <see cref="T:System.Double" />.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu. Kompilatory języka nie wykonaj tę konwersję automatycznie, ponieważ może obejmować utraty danych. Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CULng` w języku Visual Basic) jest używany. W przeciwnym razie wystąpi błąd kompilatora wyświetlane.    

 Ponieważ ta operacja definiuje konwersji zawężającej, może zgłosić <xref:System.OverflowException> na czas wykonywania Jeśli <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.UInt64> — typ danych. Nie są tracone dokładności powstałe w ten sposób <xref:System.UInt64> wartość, jeśli konwersja zakończy się pomyślnie.

## Examples
 Poniższy przykład przedstawia konwersji <xref:System.Numerics.BigInteger> do <xref:System.UInt64> wartości. Umożliwia on również obsługę <xref:System.OverflowException> który jest generowany, gdy <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.UInt64> — typ danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#11)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#11)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.UInt64.MinValue" />.  
  
 —lub—  
  
 Wartość <paramref name="value" /> jest większa niż <see cref="F:System.UInt64.MaxValue" />.</exception>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Single) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Single" /> do wartości <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie części ułamkowej `value` parametr został obcięty przed konwersją.
 
 Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu. Ponieważ konwersja z <xref:System.Single> do <xref:System.Numerics.BigInteger> może pociągać za sobą żadnych części ułamkowej obcinanie `value`, Kompilatory języka nie wykonaj tę konwersję automatycznie. Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` w języku Visual Basic) jest używany. W przeciwnym razie wystąpi błąd kompilatora wyświetlane.

 Dla języków, które nie obsługują niestandardowych operatory alternatywną metodą jest <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29?displayProperty=nameWithType>.


## Examples
 Poniższy przykład konwertuje poszczególnych elementów w tablicy <xref:System.Single> wartości do <xref:System.Numerics.BigInteger> obiektów, a następnie wyświetla wynik każdego konwersji. Należy pamiętać, że jakaś ułamkową część <xref:System.Single> wartość zostanie obcięta podczas konwersji.
 
 [!code-csharp[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#3)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#3)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość <paramref name="value" /> jest <see cref="F:System.Single.NaN" />.  
  
 —lub—  
  
 Wartość <paramref name="value" /> jest <see cref="F:System.Single.PositiveInfinity" />.
  
 —lub—  
  
 Wartość <paramref name="value" /> jest <see cref="F:System.Single.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy określona wartość jest większa niż innego określona wartość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(long left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy całkowita 64-bitowego jest większy niż <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Metoda definiuje operację większym niż operator <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#9)]
 [!code-vb[System.Numerics.BigInteger.Operators#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#9)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> zamiast tego wystąpienia metody. W przypadku niektórych języków może także wywołać <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#10)]  
  
 Jeśli `left` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartości podczas wykonywania operacji.  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, long right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> jest większa niż wartość 64-bitowej podpisanej liczby całkowitej.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Metoda definiuje operację większym niż operator <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#11)]
 [!code-vb[System.Numerics.BigInteger.Operators#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#11)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego. W przypadku niektórych języków może także wywołać <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#12)]  
  
 Jeśli `right` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartości podczas wykonywania operacji.  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa niż innego <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Metoda definiuje operację większym niż operator <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#20)]
 [!code-vb[System.Numeric.BigInteger.Class#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#20)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType> metody zamiast tego. Można również wywołać <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.  
  
 [!code-vb[System.Numeric.BigInteger.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#21)]  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa niż 64-bitowej liczby całkowitej bez znaku.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Metoda definiuje operację większym niż operator <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#13)]
 [!code-vb[System.Numerics.BigInteger.Operators#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#13)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego. W przypadku niektórych języków może także wywołać <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa niż 64-bitowej liczby całkowitej bez znaku.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Metoda definiuje operację większym niż operator <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#15)]
 [!code-vb[System.Numerics.BigInteger.Operators#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#15)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego. W przypadku niektórych języków może także wywołać <xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy określona wartość jest większa niż lub równe innego określona wartość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(long left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy 64-bitowych całkowita jest większa niż lub równa <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Metoda definiuje operację większa niż lub równa operatora dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#17)]
 [!code-vb[System.Numerics.BigInteger.Operators#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#17)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego. W przypadku niektórych języków może także wywołać <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#18)]  
  
 Jeśli `left` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartości podczas wykonywania operacji.  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, long right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa lub równa wartości 64-bitowej podpisanej liczby całkowitej.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Metoda definiuje operację większa niż lub równa operatora dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#19)]
 [!code-vb[System.Numerics.BigInteger.Operators#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#19)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego. W przypadku niektórych języków może także wywołać <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#20)]  
  
 Jeśli `right` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartości podczas wykonywania operacji.  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa niż lub równa innej <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Metoda definiuje operację większa niż lub równa operatora dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#22)]
 [!code-vb[System.Numeric.BigInteger.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#22)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> metody zamiast tego. W przypadku niektórych języków może także wywołać <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.  
  
 [!code-vb[System.Numeric.BigInteger.Class#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#23)]  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa lub równa wartości 64-bitowej liczby całkowitej bez znaku.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Metoda definiuje operację większa niż lub równa operatora dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#21)]
 [!code-vb[System.Numerics.BigInteger.Operators#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#21)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego. W przypadku niektórych języków może także wywołać <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#22)]  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy 64-bitowej liczby całkowitej bez znaku jest większa niż lub równa <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Metoda definiuje operację większa niż lub równa operatora dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#23)]
 [!code-vb[System.Numerics.BigInteger.Operators#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#23)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego. W przypadku niektórych języków może także wywołać <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#24)]  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiuje niejawna konwersja między <see cref="T:System.Numerics.BigInteger" /> obiektu i innego typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje niejawnej konwersji wartości bajtu bez znaku do <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie części ułamkowej `value` parametr został obcięty przed konwersją.

 W przypadku języków, które nie obsługują operatory niejawnej alternatywną metodą jest <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Przeciążeń <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego kompilatora może automatycznie przekonwertować <xref:System.Numerics.BigInteger> wartość bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic). Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>. To przeciążenie umożliwia kompilatora obsługiwać konwersję z <xref:System.Byte> do wartości <xref:System.Numerics.BigInteger> wartość, jak przedstawiono w następującym przykładzie.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje niejawnej konwersji wartości 16-bitową liczbę całkowitą ze znakiem do <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku języków, które nie obsługują operatory niejawnej alternatywną metodą jest <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Przeciążeń <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego kompilatora może automatycznie przekonwertować <xref:System.Numerics.BigInteger> wartość bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic). Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>. To przeciążenie umożliwia kompilatora obsługiwać konwersję z <xref:System.Int16> do wartości <xref:System.Numerics.BigInteger> wartość, jak przedstawiono w następującym przykładzie.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#2)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje niejawna konwersja całkowita 32-bitowa do <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku języków, które nie obsługują operatory niejawnej alternatywną metodą jest <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.  

 Przeciążeń <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego kompilatora może automatycznie przekonwertować <xref:System.Numerics.BigInteger> wartość bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic). Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>. To przeciążenie umożliwia kompilatora obsługiwać konwersję z <xref:System.Int32> do wartości <xref:System.Numerics.BigInteger> wartość, jak przedstawiono w następującym przykładzie.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje niejawna konwersja całkowita 64-bitowa do <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku języków, które nie obsługują operatory niejawnej alternatywną metodą jest <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29?displayProperty=nameWithType>.   
 
 Przeciążeń <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego kompilatora może automatycznie przekonwertować <xref:System.Numerics.BigInteger> wartość bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic). Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>. To przeciążenie umożliwia kompilatora obsługiwać konwersję z <xref:System.Int64> do wartości <xref:System.Numerics.BigInteger> wartość, jak przedstawiono w następującym przykładzie.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje niejawnej konwersji wartości 8-bitową liczbę całkowitą ze znakiem do <see cref="T:System.Numerics.BigInteger" /> wartości.  
  
 Ten interfejs API nie jest zgodny ze specyfikacją CLS. Alternatywa zgodna ze standardem jest <see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku języków, które nie obsługują operatory niejawnej alternatywną metodą jest <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Przeciążeń <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego kompilatora może automatycznie przekonwertować <xref:System.Numerics.BigInteger> wartość bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic). Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>. To przeciążenie umożliwia kompilatora obsługiwać konwersję z <xref:System.SByte> do wartości <xref:System.Numerics.BigInteger> wartość, jak przedstawiono w następującym przykładzie.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#5)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt16 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje niejawnej konwersji wartości 16-bitową liczbę całkowitą bez znaku do <see cref="T:System.Numerics.BigInteger" /> wartości.  
  
 Ten interfejs API nie jest zgodny ze specyfikacją CLS. Alternatywa zgodna ze standardem jest <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku języków, które nie obsługują operatory niejawnej alternatywną metodą jest <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.   

 Przeciążeń <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego kompilatora może automatycznie przekonwertować <xref:System.Numerics.BigInteger> wartość bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic). Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>. To przeciążenie umożliwia kompilatora obsługiwać konwersję z <xref:System.UInt16> do wartości <xref:System.Numerics.BigInteger> wartość, jak przedstawiono w następującym przykładzie.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#6)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje niejawna konwersja z 32-bitowa liczba całkowita bez znaku do <see cref="T:System.Numerics.BigInteger" /> wartości.  
  
 Ten interfejs API nie jest zgodny ze specyfikacją CLS. Alternatywa zgodna ze standardem jest <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku języków, które nie obsługują operatory niejawnej alternatywną metodą jest <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.   

 Przeciążeń <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego kompilatora może automatycznie przekonwertować <xref:System.Numerics.BigInteger> wartość bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic). Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>. To przeciążenie umożliwia kompilatora obsługiwać konwersję z <xref:System.UInt32> do wartości <xref:System.Numerics.BigInteger> wartość, jak przedstawiono w następującym przykładzie.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#7)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje niejawna konwersja 64-bitową nieznakowaną liczbą całkowitą do <see cref="T:System.Numerics.BigInteger" /> wartości.  
  
 Ten interfejs API nie jest zgodny ze specyfikacją CLS. Alternatywa zgodna ze standardem jest <see cref="T:System.Double" />.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku języków, które nie obsługują operatory niejawnej alternatywną metodą jest <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29?displayProperty=nameWithType>.   

 Przeciążeń <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego kompilatora może automatycznie przekonwertować <xref:System.Numerics.BigInteger> wartość bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic). Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>. To przeciążenie umożliwia kompilatora obsługiwać konwersję z <xref:System.UInt64> do wartości <xref:System.Numerics.BigInteger> wartość, jak przedstawiono w następującym przykładzie.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#8)]   

 ]]></format>
        </remarks>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ++ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Increment(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Increment (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ++(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zwiększenia.</param>
        <summary>Zwiększa <see cref="T:System.Numerics.BigInteger" /> wartość 1.</summary>
        <returns>Wartość <paramref name="value" /> parametru zwiększana o 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Increment%2A> Metoda definiuje operacji przyrostu <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#24)]  
  
 Niektóre języki (na przykład w języku Visual Basic), które mają operatora inkrementacji lub nie obsługują przeładowanie operatora można wywołać <xref:System.Numerics.BigInteger.op_Increment%2A> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.  
  
 [!code-vb[System.Numeric.BigInteger.Class#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#25)]  
  
 Ponieważ <xref:System.Numerics.BigInteger> obiekty są niezmienne, <xref:System.Numerics.BigInteger.op_Increment%2A> tworzy nowy operator <xref:System.Numerics.BigInteger> obiektu, którego wartość jest jeden więcej niż <xref:System.Numerics.BigInteger> obiektu reprezentowanego przez `value`. W związku z tym powtarzane wywołania <xref:System.Numerics.BigInteger.op_Increment%2A> może być kosztowne.  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Inequality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy dwie wartości liczbowe nie są takie same.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(long left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy 64-bitowej podpisanej liczby całkowitej i a <see cref="T:System.Numerics.BigInteger" /> wartości nie są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> nie są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A> Metoda definiuje operacji operator nierówności <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#25)]
 [!code-vb[System.Numerics.BigInteger.Operators#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#25)]  
  
 Języki, które nie obsługują niestandardowych operatory można sprawdzić pod kątem nierówności przy użyciu jednej z następujących metod:  
  
-   Wywoływanie <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> wystąpienia metody, która wskazuje relację między <xref:System.Numerics.BigInteger> i wartość podpisem długich liczb całkowitych.  
  
-   Wywoływanie <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> wystąpienia metody i cofania jej wartość.  
  
 Jeśli `left` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartości podczas wykonywania operacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, long right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość i całkowita 64-bitowe nie są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> nie są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A> Metoda definiuje operacji operator nierówności <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#26)]
 [!code-vb[System.Numerics.BigInteger.Operators#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#26)]  
  
 Języki, które nie obsługują niestandardowych operatory można sprawdzić pod kątem nierówności przy użyciu jednej z następujących metod:  
  
-   Wywoływanie <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodę, która wskazuje relację między <xref:System.Numerics.BigInteger> i wartość podpisem długich liczb całkowitych.  
  
-   Wywoływanie <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> — metoda i jego wartość cofania.  
  
 Jeśli `right` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartości podczas wykonywania operacji.  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy dwa <see cref="T:System.Numerics.BigInteger" /> obiekty mają różne wartości.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> nie są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A> Metoda definiuje operacji operator nierówności <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#26)]
 [!code-vb[System.Numeric.BigInteger.Class#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#26)]  
  
 Języki, które nie obsługują niestandardowych operatory można sprawdzić pod kątem nierówności przy użyciu jednej z następujących metod:  
  
-   Wywoływanie <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> metodę, która wskazuje relację między dwiema <xref:System.Numerics.BigInteger> obiektów.  
  
-   Wywoływanie <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> — metoda i jego wartość cofania.  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> nie są takie same wartości i 64-bitowej liczby całkowitej bez znaku.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> nie są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A> Metoda definiuje operacji operator nierówności <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#27)]
 [!code-vb[System.Numerics.BigInteger.Operators#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#27)]  
  
 Języki, które nie obsługują niestandardowych operatory można sprawdzić pod kątem nierówności przy użyciu jednej z następujących metod:  
  
-   Wywoływanie <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodę, która wskazuje relację między <xref:System.Numerics.BigInteger> i wartości bez znaku długich liczb całkowitych.  
  
-   Wywoływanie <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> — metoda i jego wartość cofania.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy 64-bitowej liczby całkowitej bez znaku i a <see cref="T:System.Numerics.BigInteger" /> wartości nie są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> nie są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A> Metoda definiuje operacji operator nierówności <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#28)]
 [!code-vb[System.Numerics.BigInteger.Operators#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#28)]  
  
 Języki, które nie obsługują niestandardowych operatory można sprawdzić pod kątem nierówności przy użyciu jednej z następujących metod:  
  
-   Wywoływanie <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodę, która wskazuje relację między <xref:System.Numerics.BigInteger> i wartości bez znaku długich liczb całkowitych.  
  
-   Wywoływanie <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> — metoda i jego wartość cofania.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_LeftShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &lt;&lt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_LeftShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;&lt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &lt;&lt;(System::Numerics::BigInteger value, int shift);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość, której bity są lekkie.</param>
        <param name="shift">Liczba bitów, które mają zostać przesunięte <c>wartość</c> po lewej stronie.</param>
        <summary>Zmiany <see cref="T:System.Numerics.BigInteger" /> wartość określoną liczbę bitów w lewo.</summary>
        <returns>Wartość, która ma zostać przesunięty w lewo przez określoną liczbę bitów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LeftShift%2A> Metoda definiuje operację z bitowego operator przesunięcia w lewo <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#29)]
 [!code-vb[System.Numerics.BigInteger.Operators#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#29)]  
  
> [!NOTE]
>  W przeciwieństwie do operacji przesunięcia w lewo z podstawowych całkowitą <xref:System.Numerics.BigInteger.op_LeftShift%2A> metody zachowuje znak oryginalnej <xref:System.Numerics.BigInteger> wartość.  
  
 Języki, które nie obsługują niestandardowych operatory można wykonać operacji przesunięcia w lewo przez pomnożenie `value` przez `BigInteger.Pow(2, shift)`. W poniższym przykładzie pokazano, że wyniki są takie same jak wyniki za pomocą tego operatora.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#30)]
 [!code-vb[System.Numerics.BigInteger.Operators#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#30)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy określona wartość jest mniejsza niż drugi określoną wartość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(long left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy 64-bitowych całkowita jest mniej niż a <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A> Metoda definiuje operację mniejszej niż operator <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#31)]
 [!code-vb[System.Numerics.BigInteger.Operators#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#31)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego. W przypadku niektórych języków może także wywołać <xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#32)]  
  
 Jeśli `left` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartości podczas wykonywania operacji.  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, long right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż całkowita 64-bitowych.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A> Metoda definiuje operację mniejszej niż operator <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#33)]
 [!code-vb[System.Numerics.BigInteger.Operators#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#33)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego. W przypadku niektórych języków może także wywołać <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#34)]  
  
 Jeśli `right` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartości podczas wykonywania operacji.  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż innego <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A> Metoda definiuje operację mniejszej niż operator <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#27)]
 [!code-vb[System.Numeric.BigInteger.Class#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#27)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> metody zamiast tego. W przypadku niektórych języków może także wywołać <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.  
  
 [!code-vb[System.Numeric.BigInteger.Class#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#28)]  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż 64-bitowej liczby całkowitej bez znaku.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A> Metoda definiuje operację mniejszej niż operator <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#35)]
 [!code-vb[System.Numerics.BigInteger.Operators#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#35)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego. Można również wywołać <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#36)]  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy 64-bitowej liczby całkowitej bez znaku jest mniej niż a <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A> Metoda definiuje operację mniejszej niż operator <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#37)]
 [!code-vb[System.Numerics.BigInteger.Operators#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#37)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego. Można również wywołać <xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#38)]  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy określona wartość jest mniejsza niż lub równe inną określoną wartość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(long left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy całkowita 64-bitowych jest mniejsza niż lub równe <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż lub równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Metoda definiuje działania mniejsze niż lub równe operatora dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#39)]
 [!code-vb[System.Numerics.BigInteger.Operators#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#39)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego. Można również wywołać <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#40)]  
  
 Jeśli `left` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartości podczas wykonywania operacji.  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, long right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż całkowita 64-bitowych.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż lub równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Metoda definiuje działania mniejsze niż lub równe operatora dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#41)]
 [!code-vb[System.Numerics.BigInteger.Operators#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#41)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego. Można również wywołać <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#42)]  
  
 Jeśli `right` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartości podczas wykonywania operacji.  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż lub równa do innego <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż lub równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Metoda definiuje działania mniejsze niż lub równe operatora dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#29)]
 [!code-vb[System.Numeric.BigInteger.Class#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#29)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Compare%2A> metody zamiast tego. Można również wywołać <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.  
  
 [!code-vb[System.Numeric.BigInteger.Class#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#30)]  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż 64-bitowej liczby całkowitej bez znaku.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż lub równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Metoda definiuje działania mniejsze niż lub równe operatora dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#43)]
 [!code-vb[System.Numerics.BigInteger.Operators#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#43)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego. Można również wywołać <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#44)]  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy 64-bitowej liczby całkowitej bez znaku jest mniejsza lub równa <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż lub równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Metoda definiuje działania mniejsze niż lub równe operatora dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#45)]
 [!code-vb[System.Numerics.BigInteger.Operators#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#45)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego. Można również wywołać <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#46)]  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_Modulus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator % (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Modulus(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Mod (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator %(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Wartość podział.</param>
        <param name="divisor">Wartość do dzielenia przez.</param>
        <summary>Zwraca resztę, będącą wynikiem dzielenia przy użyciu dwóch określony <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Pozostałe będącą wynikiem podziału.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Modulus%2A> Metoda definiuje operacji operator modulo <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#31)]
 [!code-vb[System.Numeric.BigInteger.Class#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#31)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=nameWithType> metody zamiast tego.  
  
 Znak wartości zwróconej przez operację modulo zależy od jej znaku `dividend`: Jeśli `dividend` jest dodatnia, Operacja modulo zwraca wyników pozytywnych; Jeśli jest ujemna, Operacja modulo zwraca wynik ujemny. Zachowanie działania modulo z <xref:System.Numerics.BigInteger> wartości jest taka sama jak operację modulo z innych typów całkowitych.  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> to 0 (zero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator * (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator *(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość wielokrotnie.</param>
        <param name="right">Druga wartość używana w wielokrotnie.</param>
        <summary>Mnoży dwie określone <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Iloczyn <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Multiply%2A> Metoda definiuje operacji operator mnożenia <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#11)]
 [!code-vb[System.Numeric.BigInteger.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#11)]  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ~ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_OnesComplement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Not (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ~(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość całkowita.</param>
        <summary>Zwraca operatora testu koniunkcji, jeden dla uzupełnienia z <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Bitowe co do uzupełnienia z <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_OnesComplement%2A> Metoda definiuje operację z bitowego przez jeden operator dopełnienia jednostkowego dla <xref:System.Numerics.BigInteger> wartości. Bitowe odwraca operatorem dopełnienia osoby, każdy bit w wartość liczbową. Oznacza to, że usługa bits w `value` , które są 0 są ustawione na 1, w wyniku i bitów, które są 1 są ustawione na 0 w wyniku. <xref:System.Numerics.BigInteger.op_OnesComplement%2A> Metoda umożliwia następującego kodu:  
  
 [!code-csharp[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/cs/OnesComplement1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/OnesComplement1.vb#1)]  
  
 Języki, które nie obsługują niestandardowych operatory może być możliwe do wywołania <xref:System.Numerics.BigInteger.op_OnesComplement%2A> metody bezpośrednio do wykonania bitowej, osoby uzupełniają operacji. Na przykład:  
  
 [!code-vb[System.Numerics.BigInteger.OnesComplement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/onescomplement2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_RightShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &gt;&gt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_RightShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;&gt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &gt;&gt;(System::Numerics::BigInteger value, int shift);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość, której bity są lekkie.</param>
        <param name="shift">Liczba bitów, które mają zostać przesunięte <c>wartość</c> z prawej strony.</param>
        <summary>Zmiany <see cref="T:System.Numerics.BigInteger" /> wartość określoną liczbę bitów w prawo.</summary>
        <returns>Wartość przesunięcia w prawo o określoną liczbę bitów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_RightShift%2A> Metoda definiuje operację z bitowego operator przesunięcia w prawo <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#47)]
 [!code-vb[System.Numerics.BigInteger.Operators#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#47)]  
  
 Języki, które nie obsługują niestandardowych operatory można wykonać operacji przesunięcia w prawo, dzieląc `value` przez `BigInteger.Pow(2, shift)` i odejmowanie 1 godziny `shift` dla wartości ujemnych. W poniższym przykładzie pokazano, że wyniki są takie same jak wyniki za pomocą tego operatora.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#48)]
 [!code-vb[System.Numerics.BigInteger.Operators#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#48)]  
  
 Jeśli `shift` jest większa lub równa liczbie bitów dodatnią <xref:System.Numerics.BigInteger> wartość, wynik operacji przesunięcia w prawo jest <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>. Jeśli `shift` jest większa niż liczba bitów ujemny <xref:System.Numerics.BigInteger> wartość, wynik operacji przesunięcia w prawo jest <xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Subtraction(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Wartość, którą chcesz odjąć od (minuend).</param>
        <param name="right">Wartość do odejmowania (subtrahend).</param>
        <summary>Odejmuje <see cref="T:System.Numerics.BigInteger" /> wartości z innej <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>Wynik odejmowania <paramref name="right" /> z <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Subtraction%2A> Metoda definiuje operacji operator odejmowania <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#14)]
 [!code-vb[System.Numeric.BigInteger.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#14)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=nameWithType> metody zamiast tego.  
  
 Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryNegation(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do wskazania ujemnej.</param>
        <summary>Negacja określoną wartość BigInteger.</summary>
        <returns>Wynik <paramref name="value" /> parametru pomnożona przez wartość ujemną (-1).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_UnaryNegation%2A> Metoda definiuje operację Jednoargumentowy operator negacji (lub operator odwrotność dodatku) <xref:System.Numerics.BigInteger> wartości. Operacja daje wartość, która powoduje 0 (zero), gdy jest ona dodawana do liczby. Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Negate%2A> metody zamiast tego.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy przykład przedstawia trzy różne sposoby, aby odwrócić wartość <xref:System.Numerics.BigInteger> obiektu.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryPlus(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość całkowita.</param>
        <summary>Zwraca wartość <see cref="T:System.Numerics.BigInteger" /> argument. (Znak operand jest bez zmian).</summary>
        <returns>Wartość <paramref name="value" /> argument.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_UnaryPlus%2A> Metoda definiuje operacji jednoargumentowej dodatnią dla <xref:System.Numerics.BigInteger> wartości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje liczbę reprezentację ciągu jego <see cref="T:System.Numerics.BigInteger" /> równoważne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg zawierający liczbę, którą należy przekształcić.</param>
        <summary>Konwertuje liczbę reprezentację ciągu jego <see cref="T:System.Numerics.BigInteger" /> równoważne.</summary>
        <returns>Wartość odpowiadającą liczbie określonej w <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` Parametr powinien być reprezentację liczby w następującym formacie.  
  
 [*ws*] [*znak*]*cyfr*[*ws*]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Opcjonalny odstęp.|  
|*sign*|Opcjonalny znak. Nieprawidłowy znak znaki są określane przez <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> i <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> właściwości bieżącej kultury.|  
|*cyfr*|Sekwencja cyfr od 0 do 9. Wszystkie zera wiodące są ignorowane.|  
  
> [!NOTE]
>  Ciąg określony przez `value` parametr jest interpretowany za pomocą <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> stylu. Nie może zawierać żadnych separatorów grup ani separatorów dziesiętnych, a także mieć części dziesiętnej.  
  
 `value` Parametru jest analizowana, korzystając z informacji formatowania w <xref:System.Globalization.NumberFormatInfo?displayProperty=nameWithType> obiekt, który został zainicjowany dla bieżącego ustawienia kulturowego systemu. Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Aby przeanalizować ciągu przy użyciu formatowania informacji określoną kulturę, użyj <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> metody.  
  
> [!IMPORTANT]
>  Jeśli używasz <xref:System.Numerics.BigInteger.Parse%2A> metody przesyłania danych reprezentację ciągu z <xref:System.Numerics.BigInteger> wartość, która została danych wyjściowych przez <xref:System.Numerics.BigInteger.ToString%2A> metody, należy użyć <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metody z specyfikator formatu "R", aby wygenerować reprezentację ciągu <xref:System.Numerics.BigInteger> wartość. W przeciwnym razie reprezentację ciągu <xref:System.Numerics.BigInteger> zachowuje tylko 50 cyfr znaczących większość oryginalnej wartości i dane mogą zostać utracone, korzystając z <xref:System.Numerics.BigInteger.Parse%2A> metoda przywracania <xref:System.Numerics.BigInteger> wartość.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.Parse%28System.String%29> metodę, aby utworzyć dwa wystąpienia <xref:System.Numerics.BigInteger> obiektów. Mnoży każdego obiektu przez inny numer, a następnie wywołuje <xref:System.Numerics.BigInteger.Compare%2A> metodę, aby określić relacji między dwiema wartościami.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> nie jest w nieprawidłowym formacie.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg zawierający liczbę, którą należy przekształcić.</param>
        <param name="style">Bitowe połączenie wartości wyliczenia, które określają format dozwolonych <c>wartość</c>.</param>
        <summary>Konwertuje reprezentacja ciągu liczb w stylu określony do jego <see cref="T:System.Numerics.BigInteger" /> równoważne.</summary>
        <returns>Wartość odpowiadającą liczbie określonej w <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `style` Parametru definiuje elementy stylu (na przykład biały znak, symbol znaku dodatnie lub ujemne, symbol separatora grupy lub symbol punktu dziesiętnego), które są dozwolone w `value` parametr powodzenie operacji analizy. `styles` musi być kombinacją flag bitowych z <xref:System.Globalization.NumberStyles> wyliczenia. `style` Parametru sprawia, że ta metoda przeciążenia przydatne, gdy `value` zawiera wartość szesnastkową reprezentację ciągu, gdy system numer (dziesiętną lub szesnastkową) reprezentowany przez `value` jest znany tylko w czasie wykonywania, lub gdy użytkownik Aby uniemożliwić biały znak lub znak symbolu w `value`.  
  
 W zależności od wartości `style`, `value` parametr może zawierać następujące elementy:  
  
 [*ws*][*$*][*sign*][*digits*,]*digits*[.*fractional_digits*][E[*sign*]*exponential_digits*][*ws*]  
  
 Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, `value` parametr może zawierać następujące elementy:  
  
 [*ws*]*hexdigits*[*ws*]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Opcjonalny odstęp. Biały znak, może występować na początku `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flagę która może występować na końcu `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flagi.|  
|*$*|Symbol waluty specyficzny dla kultury. Jej położenie w ciągu jest definiowana za pomocą <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> i <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> właściwości bieżącej kultury. Symbol waluty bieżącej kultury może występować w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flagi.|  
|*sign*|Opcjonalny znak. Logowania może wystąpić na początku `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flagę która może występować na końcu `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flagi. Użycie nawiasów w `value` wskaż wartość ujemną, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flagi.|  
|*cyfr*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Sekwencja cyfr od 0 do 9. Aby uzyskać *fractional_digits*tylko cyfry 0 jest prawidłowy.|  
|*,*|Symbol separatora grupy specyficzny dla kultury. Separator grupy bieżącej kultury może występować w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flagi.|  
|*.*|Symbol dziesiętny specyficzny dla kultury. Symbol punktu dziesiętnego bieżącej kultury może występować w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flagi. Tylko cyfry 0 może występować jako cyfrę ułamkowych analizy operacja powiodła się; Jeśli *fractional_digits* zawiera dowolną cyfrę <xref:System.FormatException> jest generowany.|  
|E|Znak „e” lub „E”, który wskazuje, że wartość jest reprezentowana w zapisie wykładniczym (naukowym). `value` Parametr może reprezentować liczbę w notacji wykładniczej, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flagi.|  
|*hexdigits*|Sekwencja cyfr szesnastkowych od 0 do f lub od 0 do F.|  
  
 Ciąg zawierający tylko cyfry (które odpowiada <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> styl) zawsze przeanalizowany pomyślnie. Większość pozostałych <xref:System.Globalization.NumberStyles> członkowie sterować elementy, które mogą być obecne, ale nie muszą znajdować się w ciągu wejściowym. W poniższej tabeli przedstawiono poszczególne <xref:System.Globalization.NumberStyles> elementów członkowskich mają wpływ na elementy, które mogą być obecne w `value`.  
  
|`NumberStyles` Wartość|Elementy dozwolone w `value` oprócz cyfr|  
|--------------------------|---------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*Cyfr* tylko element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Decimal (.) i *cyfr ułamkowych* elementów.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E" lub litery "E", która wskazuje notacji wykładniczej, wraz z *exponential_digits*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws* element na początku `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws* element na końcu `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*Znak* element na początku `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*Znak* element na końcu `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*Znak* elementu w postaci nawiasów otaczającej wartość liczbową.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Element separatora grupy (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Element określający walutę ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Wszystkie elementy. Jednak `value` nie może reprezentować liczbę szesnastkową lub numer w notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws* elementu na początek lub koniec `value`, *znak* na początku `value`i dziesiętnego (*.*) symbolu. `value` Parametr można również użyć notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`, `sign`, Grupy separatora (*,*), a separatorem dziesiętnym (*.*) elementów.|  
|<xref:System.Globalization.NumberStyles.Any>|Wszystkie elementy. Jednak `value` nie może reprezentować liczbę szesnastkową.|  
  
> [!IMPORTANT]
>  Jeśli używasz <xref:System.Numerics.BigInteger.Parse%2A> metody przesyłania danych reprezentację ciągu z <xref:System.Numerics.BigInteger> wartość, która została danych wyjściowych przez <xref:System.Numerics.BigInteger.ToString%2A> metody, należy użyć <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metody z specyfikator formatu "R", aby wygenerować reprezentację ciągu <xref:System.Numerics.BigInteger> wartość. W przeciwnym razie reprezentację ciągu <xref:System.Numerics.BigInteger> zachowuje tylko 50 cyfr znaczących większość oryginalnej wartości i dane mogą zostać utracone, korzystając z <xref:System.Numerics.BigInteger.Parse%2A> metoda przywracania <xref:System.Numerics.BigInteger> wartość.  
  
 W odróżnieniu od innych <xref:System.Globalization.NumberStyles> wartości, które umożliwiają, ale nie wymagają obecności określonego stylu elementów w `value`, <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> styl wartość oznacza, że poszczególne znaki numeryczne w `value` zawsze będą interpretowane jako znaki szesnastkowe. Prawidłowe znaki szesnastkowe to 0-9, A-F i a-f. Tylko innych flagi, które można łączyć z `style` są parametru <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> i <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. ( <xref:System.Globalization.NumberStyles> Wyliczenie zawiera styl numer złożone, <xref:System.Globalization.NumberStyles.HexNumber>, zawierająca zarówno flagi biały znak.)  
  
> [!NOTE]
>  Jeśli `value` reprezentacja ciągu z liczbą szesnastkową nie może być poprzedzone żadnych decoration (takich jak `0x` lub `&h`) który odróżnia go jako liczbę szesnastkową. To powoduje niepowodzenie konwersji.  
  
 Jeśli `value` jest ciągiem szesnastkowym <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> interpretuje metody `value` jako wartość ujemną przechowywane za pomocą dwóch jego reprezentacja dopełnienia, jeśli jego pierwsze dwie cyfry szesnastkowe są większe niż lub równe `0x80`. Innymi słowy, metoda interpretuje bit najwyższej kolejności pierwszego bajtu w `value` jako bitem. Aby upewnić się, że ciąg szesnastkowy poprawnie jest interpretowana jako wartość dodatnią, cyfry, w `value` musi mieć wartość zero. Na przykład metoda interpretuje `0x80` zgodnie z wartością ujemną, ale interpretuje albo `0x080` lub `0x0080` jako wartość dodatnią. Poniższy przykład przedstawia różnice między ciągów szesnastkowych, które reprezentują wartości ujemnych i dodatnich.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 `value` Parametru jest analizowana, korzystając z informacji formatowania w <xref:System.Globalization.NumberFormatInfo> obiekt, który został zainicjowany dla bieżącego ustawienia kulturowego systemu. Aby określić kulturę, którego formatowania informacje są używane dla operacji analizy, należy wywołać <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> przeciążenia.  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywołań <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> metody z kilku wartości dla `style` parametru. Przedstawia go zinterpretować ciąg jako wartość szesnastkowa oraz sposobu nie zezwalaj na spacje i podpisz symboli.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#5)]
 [!code-vb[System.Numeric.BigInteger.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> nie jest <see cref="T:System.Globalization.NumberStyles" /> wartość.  
  
 —lub—  
  
 <paramref name="style" /> obejmuje <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> lub <see cref="F:System.Globalization.NumberStyles.HexNumber" /> flagi wraz z inną wartość.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> nie jest zgodne z wejściowych wzorca określonego przez <see cref="T:System.Globalization.NumberStyles" />.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg zawierający liczbę, którą należy przekształcić.</param>
        <param name="provider">Obiekt, który zawiera informacje dotyczące formatowania specyficzne dla kultury o <c>wartość</c>.</param>
        <summary>Konwertuje reprezentację liczby w określonym formacie specyficzne dla kultury do jego <see cref="T:System.Numerics.BigInteger" /> równoważne.</summary>
        <returns>Wartość odpowiadającą liczbie określonej w <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` Parametr powinien być reprezentację liczby w następującym formacie:  
  
 [*ws*] [*znak*]*cyfr*[*ws*]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Opcjonalny odstęp.|  
|*sign*|Opcjonalny znak. Nieprawidłowy znak znaki są określane przez <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> i <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> właściwości <xref:System.Globalization.NumberFormatInfo> obiektu, który jest zwracany przez `provider` obiektu <xref:System.IFormatProvider.GetFormat%2A> metody.|  
|*cyfr*|Sekwencja cyfr od 0 do 9. Wszystkie zera wiodące są ignorowane.|  
  
> [!NOTE]
>  Ciąg określony przez `value` parametr jest interpretowany za pomocą <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> stylu. Nie może zawierać żadnych separatorów grup ani separatorów dziesiętnych, a także mieć części dziesiętnej.  
  
> [!IMPORTANT]
>  Jeśli używasz <xref:System.Numerics.BigInteger.Parse%2A> metody przesyłania danych reprezentację ciągu z <xref:System.Numerics.BigInteger> wartość, która została danych wyjściowych przez <xref:System.Numerics.BigInteger.ToString%2A> metody, należy użyć <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metody z specyfikator formatu "R", aby wygenerować reprezentację ciągu <xref:System.Numerics.BigInteger> wartość. W przeciwnym razie reprezentację ciągu <xref:System.Numerics.BigInteger> zachowuje tylko 50 cyfr znaczących większość oryginalnej wartości i dane mogą zostać utracone, korzystając z <xref:System.Numerics.BigInteger.Parse%2A> metoda przywracania <xref:System.Numerics.BigInteger> wartość.  
  
 `provider` Parametr jest <xref:System.IFormatProvider> implementacji których <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje dotyczące formatowania specyficzne dla kultury. Gdy <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> wywołania metody, wywołuje `provider` parametru <xref:System.IFormatProvider.GetFormat%2A> — metoda i przekazuje je <xref:System.Type> obiekt, który reprezentuje <xref:System.Globalization.NumberFormatInfo> typu. <xref:System.IFormatProvider.GetFormat%2A> Następnie metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który zawiera informacje o formacie `value` parametru. Istnieją trzy sposoby używania `provider` parametr, aby podać informacje dotyczące formatowania niestandardowych operacji analizy:  
  
-   Można przekazać <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury, który dostarcza informacje dotyczące formatowania. Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje numeryczne formatowania dla tej kultury.  
  
-   Można przekazać rzeczywiste <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje numeryczne formatowania. (Jej implementacja <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> zwraca siebie, po prostu.)  
  
-   Można przekazać niestandardowego obiektu, który implementuje <xref:System.IFormatProvider>. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda tworzy i zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje dotyczące formatowania.  
  
 Jeśli `provider` jest `null`, formatowanie `value` jest interpretowana w oparciu o <xref:System.Globalization.NumberFormatInfo> obiektu bieżącej kultury.  
  
   
  
## Examples  
 W poniższych przykładach pokazano dwa sposoby definiowania tyldy (~) jako znaku minus formatowania <xref:System.Numerics.BigInteger> wartości. Należy pamiętać, że do wyświetlenia <xref:System.Numerics.BigInteger> wartości w tym samym formacie co oryginalna ciągów, kod musi wywoływać <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> — metoda i przekaż go <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje dotyczące formatowania.  
  
 Pierwszym przykładzie zdefiniowano klasę implementującą <xref:System.IFormatProvider> i używa <xref:System.IFormatProvider.GetFormat%2A> metodę, aby zwrócić <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje dotyczące formatowania.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#2)]  
  
 A <xref:System.Numerics.BigInteger> następnie wystąpienie obiektu z następującym kodem:  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#3)]
 [!code-vb[System.Numeric.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#3)]  
  
 Drugi przykład jest więcej prosta. Przekazuje ono <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje dotyczące formatowania do `provider` parametru.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#4)]
 [!code-vb[System.Numeric.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> nie jest w nieprawidłowym formacie.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As BigInteger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg zawierający liczbę, którą należy przekształcić.</param>
        <param name="style">Bitowe połączenie wartości wyliczenia, które określają format dozwolonych <c>wartość</c>.</param>
        <param name="provider">Obiekt, który zawiera informacje dotyczące formatowania specyficzne dla kultury o <c>wartość</c>.</param>
        <summary>Konwertuje reprezentację ciągu liczbą określony styl i specyficzne dla kultury formatu w celu jego <see cref="T:System.Numerics.BigInteger" /> równoważne.</summary>
        <returns>Wartość odpowiadającą liczbie określonej w <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `style` Parametru definiuje elementy stylu (na przykład biały znak, symbol znaku dodatnie lub ujemne, symbol separatora grupy lub symbol punktu dziesiętnego), które są dozwolone w `value` parametr powodzenie operacji analizy. `styles` musi być kombinacją flag bitowych z <xref:System.Globalization.NumberStyles> wyliczenia. `style` Parametru sprawia, że ta metoda przeciążenia przydatne, gdy `value` zawiera wartość szesnastkową reprezentację ciągu, gdy system numer (dziesiętną lub szesnastkową) reprezentowany przez `value` jest znany tylko w czasie wykonywania, lub gdy użytkownik Aby uniemożliwić biały znak lub znak symbolu w `value`.  
  
 W zależności od wartości `style`, `value` parametr może zawierać następujące elementy:  
  
 [*ws*][*$*][*sign*][*digits*,]*digits*[*.fractional_digits*][E[*sign*]*exponential_digits*][*ws*]  
  
 Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, `value` parametr może zawierać następujące elementy:  
  
 [*ws*]*hexdigits*[*ws*]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Opcjonalny odstęp. Biały znak, może występować na początku `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flagę która może występować na końcu `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flagi.|  
|*$*|Symbol waluty specyficzny dla kultury. Jej położenie w ciągu jest definiowana za pomocą <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> i <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> właściwości kultury wskazywanym przez `provider` parametru. Symbol waluty bieżącej kultury może występować w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flagi.|  
|*sign*|Opcjonalny znak. Logowania może wystąpić na początku `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flagę która może występować na końcu `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flagi. Użycie nawiasów w `value` wskaż wartość ujemną, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flagi.|  
|*cyfr*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Sekwencja cyfr od 0 do 9. Aby uzyskać *fractional_digits*tylko cyfry 0 jest prawidłowy.|  
|*,*|Symbol separatora grupy specyficzny dla kultury. Symbol separatora grupy kultury określonej przez `provider` może występować w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flagi.|  
|*.*|Symbol dziesiętny specyficzny dla kultury. Symbol punktu dziesiętnego kultury wskazywany przez `provider` może występować w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flagi. Tylko cyfry 0 może występować jako cyfrę ułamkowych analizy operacja powiodła się; Jeśli *fractional_digits* zawiera dowolną cyfrę <xref:System.FormatException> jest generowany.|  
|E|Znak „e” lub „E”, który wskazuje, że wartość jest reprezentowana w zapisie wykładniczym (naukowym). `value` Parametr może reprezentować liczbę w notacji wykładniczej, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flagi.|  
|*hexdigits*|Sekwencja cyfr szesnastkowych od 0 do f lub od 0 do F.|  
  
 Ciąg zawierający tylko cyfry (które odpowiada <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> styl) zawsze przeanalizowany pomyślnie. Większość pozostałych <xref:System.Globalization.NumberStyles> członkowie sterować elementy, które mogą być obecne, ale nie muszą znajdować się w ciągu wejściowym. W poniższej tabeli przedstawiono poszczególne <xref:System.Globalization.NumberStyles> elementów członkowskich mają wpływ na elementy, które mogą być obecne w `value`.  
  
|Wartość wyliczenia NumberStyles|Dodatkowe (poza cyframi) elementy dozwolone w wartości|  
|------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*Cyfr* tylko element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Decimal (.) i *cyfr ułamkowych* elementów.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Znak „e” lub znak „E”, co oznacza zapis wykładniczy. wraz z programem *exponential_digits*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws* element na początku `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws* element na końcu `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*Znak* element na początku `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*Znak* element na końcu `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*Znak* elementu w postaci nawiasów otaczającej wartość liczbową.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Element separatora grupy (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Element określający walutę ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Wszystkie elementy. Jednak `value` nie może reprezentować liczbę szesnastkową lub numer w notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws* elementu na początek lub koniec `value`, *znak* na początku `value`oraz symbol punktu dziesiętnego (.). `value` Parametr można również użyć notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`, `sign`, Grupy separatora (,), a elementy dziesiętnym (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Wszystkie elementy. Jednak `value` nie może reprezentować liczbę szesnastkową.|  
  
> [!IMPORTANT]
>  Jeśli używasz <xref:System.Numerics.BigInteger.Parse%2A> metody przesyłania danych reprezentację ciągu z <xref:System.Numerics.BigInteger> wartość, która została danych wyjściowych przez <xref:System.Numerics.BigInteger.ToString%2A> metody, należy użyć <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metody z specyfikator formatu "R", aby wygenerować reprezentację ciągu <xref:System.Numerics.BigInteger> wartość. W przeciwnym razie reprezentację ciągu <xref:System.Numerics.BigInteger> zachowuje tylko 50 cyfr znaczących większość oryginalnej wartości i dane mogą zostać utracone, korzystając z <xref:System.Numerics.BigInteger.Parse%2A> metoda przywracania <xref:System.Numerics.BigInteger> wartość.  
  
 W odróżnieniu od innych <xref:System.Globalization.NumberStyles> wartości, które umożliwiają, ale nie wymagają obecności określonego stylu elementów w `value`, <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> styl wartość oznacza, że poszczególne znaki numeryczne w `value` zawsze będą interpretowane jako znaki szesnastkowe. Prawidłowe znaki szesnastkowe to 0-9, A-F i a-f. Tylko innych flagi, które można łączyć z `style` są parametru <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> i <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. ( <xref:System.Globalization.NumberStyles> Wyliczenie zawiera styl numer złożone, <xref:System.Globalization.NumberStyles.HexNumber>, zawierająca zarówno flagi biały znak.)  
  
> [!NOTE]
>  Jeśli `value` reprezentacja ciągu z liczbą szesnastkową nie może być poprzedzone żadnych decoration (takich jak `0x` lub `&h`) który odróżnia go jako liczbę szesnastkową. To powoduje niepowodzenie konwersji.  
  
 Jeśli `value` jest ciągiem szesnastkowym <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> interpretuje metody `value` jako wartość ujemną przechowywane za pomocą dwóch jego reprezentacja dopełnienia, jeśli jego pierwsze dwie cyfry szesnastkowe są większe niż lub równe `0x80`. Innymi słowy, metoda interpretuje bit najwyższej kolejności pierwszego bajtu w `value` jako bitem. Aby upewnić się, że ciąg szesnastkowy poprawnie jest interpretowana jako wartość dodatnią, cyfry, w `value` musi mieć wartość zero. Na przykład metoda interpretuje `0x80` zgodnie z wartością ujemną, ale interpretuje albo `0x080` lub `0x0080` jako wartość dodatnią. Poniższy przykład przedstawia różnice między ciągów szesnastkowych, które reprezentują wartości ujemnych i dodatnich.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 `provider` Parametr jest <xref:System.IFormatProvider> implementacji. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który zawiera informacje specyficzne dla kultury o format `value`. Zazwyczaj `provider` może być jednym z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultura, która zawiera dane liczbowe formatowania. Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje numeryczne formatowania.  
  
-   A <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje dotyczące formatowania. (Jej implementacja <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> zwraca siebie, po prostu.)  
  
-   Niestandardowy obiekt, który implementuje <xref:System.IFormatProvider> i używa <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> metody w celu utworzenia wystąpienia i zwracać <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje dotyczące formatowania.  
  
 Jeśli `provider` jest `null`, <xref:System.Globalization.NumberFormatInfo> obiektu dla bieżącej kultury jest używany.  
  
   
  
## Examples  
 Poniższy przykład powoduje, że wiele wywołań <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> metodę przy użyciu różnych kombinacji wartości `style` i `provider` parametrów.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#2)]  
  
 Liczba wywołań poszczególnych <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> metody Przekaż wystąpienie następujących `BigIntegerFormatProvider` klasy, która definiuje tyldy (~) jako znaku minus.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> nie jest <see cref="T:System.Globalization.NumberStyles" /> wartość.  
  
 —lub—  
  
 <paramref name="style" /> obejmuje <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> lub <see cref="F:System.Globalization.NumberStyles.HexNumber" /> flagi wraz z inną wartość.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> nie jest zgodne z wejściowych wzorca określonego przez <paramref name="style" />.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Pow (System.Numerics.BigInteger value, int exponent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Pow(valuetype System.Numerics.BigInteger value, int32 exponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As BigInteger, exponent As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Pow(System::Numerics::BigInteger value, int exponent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Numer, do której zostaną podniesione <c>wykładnik</c> zasilania.</param>
        <param name="exponent">Wykładnik, aby podnieść <c>wartość</c> przez.</param>
        <summary>Zgłasza <see cref="T:System.Numerics.BigInteger" /> wartości do potęgi określonej wartości.</summary>
        <returns>Wynik podniesienia liczby <paramref name="value" /> do <paramref name="exponent" /> zasilania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Pow%2A> Metoda zwraca wartość 1, jeśli wartość parametru wykładnika to 0 lub wartości obu `value` i `exponent` parametry są równe 0. Jeśli `exponent` 1, <xref:System.Numerics.BigInteger.Pow%2A> metoda zwraca `value`. Jeśli `value` jest ujemna, metoda zwraca wynik ujemny.  
  
 Ta metoda odpowiada <xref:System.Math.Pow%2A?displayProperty=nameWithType> metody dla typów pierwotnych liczbowych.  
  
   
  
## Examples  
 Poniższy przykład przedstawia potęgowania przy użyciu <xref:System.Numerics.BigInteger> wartość i wykładnik, którego wartość należy do zakresu od 0 do 10.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#32)]
 [!code-vb[System.Numeric.BigInteger.Class#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="exponent" /> parametru jest ujemna.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remainder">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Remainder (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Remainder(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remainder (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Remainder(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Wartość podział.</param>
        <param name="divisor">Wartość do dzielenia przez.</param>
        <summary>Wykonuje dzielenie liczby całkowitej na dwóch <see cref="T:System.Numerics.BigInteger" /> wartości i zwraca resztę.</summary>
        <returns>Resztę po podzieleniu <paramref name="dividend" /> przez <paramref name="divisor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znak pozostałej jest znak `dividend` parametru.  
  
 <xref:System.Numerics.BigInteger.Remainder%2A> Metoda została zaimplementowana dla języków, które nie obsługują niestandardowych operatorów. Jego zachowanie jest identyczne dzielenia przy użyciu operatora modulo.  
  
 Jeśli to konieczne, metoda automatycznie wykonuje niejawna konwersja z innych typów całkowitych do <xref:System.Numerics.BigInteger> obiekty przed przesłaniem operacji modułu.  
  
   
  
## Examples  
 Poniższy przykład porównuje pozostała z <xref:System.Numerics.BigInteger.DivRem%2A> metody pozostałych zwrócony przez <xref:System.Numerics.BigInteger.Remainder%2A> metodę określenia, że te dwie metody obliczanie reszt identyczne.  
  
 [!code-csharp[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/cs/Remainder1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/vb/Remainder1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> to 0 (zero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public int Sign { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Sign" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Sign" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Sign As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Sign { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera numer, który wskazuje znak (negatywną dodatnie, lub zero) bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu.</summary>
        <value>Liczba, która określa znak <see cref="T:System.Numerics.BigInteger" /> obiektów, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Numer  
  
 </term><description> Opis elementu  
  
 </description></listheader><item><term> -1  
  
 </term><description> Wartość tego obiektu jest ujemna.  
  
 </description></item><item><term> 0  
  
 </term><description> Wartość tego obiektu jest 0 (zero).  
  
 </description></item><item><term> 1  
  
 </term><description> Wartość tego obiektu jest dodatnia.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Sign%2A> Właściwości jest odpowiednikiem <xref:System.Math.Sign%2A?displayProperty=nameWithType> metody dla typów pierwotnych liczbowych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Subtract (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Subtract(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Subtract(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Wartość, którą chcesz odjąć od (minuend).</param>
        <param name="right">Wartość do odejmowania (subtrahend).</param>
        <summary>Odejmuje jedną <see cref="T:System.Numerics.BigInteger" /> wartość z innej i zwraca wynik.</summary>
        <returns>Wynik odejmowania <paramref name="right" /> z <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można używać języków, które nie obsługują niestandardowych operatory <xref:System.Numerics.BigInteger.Subtract%2A> metodę w celu za pomocą odejmowania <xref:System.Numerics.BigInteger> wartości.  
  
 <xref:System.Numerics.BigInteger.Subtract%2A> Metoda jest przydatna zastępuje operator odejmowania podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> zmiennej przypisać tą różnicą, że wyniki z odejmowania, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ToByteArray();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje <see cref="T:System.Numerics.BigInteger" /> wartość na tablicę bajtów.</summary>
        <returns>Wartość bieżącego <see cref="T:System.Numerics.BigInteger" /> przekonwertować obiektu na tablicę bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poszczególne bajty w tablicy zwracanej przez tę metodę są wyświetlane w kolejności little endian. Oznacza to, że kolejność małą liczbę bajtów wartość poprzedzać bajtów wyższego rzędu. Pierwszy bajt tablicy odzwierciedla pierwszych 8 bitów <xref:System.Numerics.BigInteger> wartość, drugie bajtów odzwierciedla dalej osiem bitów i tak dalej. Na przykład wartość 1024 lub 0x0400, są przechowywane jako tablica następujące dwa bajty:  
  
|Element|Wartość bajtu|  
|-------------|----------------|  
|0|0x00|  
|1|0x04|  
  
 Wartości ujemne są zapisywane do tablicy przy użyciu dwóch jego reprezentacja dopełnienia w najbardziej kompaktową możliwe formularza. Na przykład wartość -1 jest reprezentowany jako pojedynczy bajt, którego wartość jest `0xFF` zamiast jako tablicy zawierającej wiele elementów, takich jak `0xFF`, `0xFF` lub `0xFF`, `0xFF`, `0xFF`, `0xFF`.  
  
 Ponieważ w dwóch uzupełniają reprezentacja zawsze interpretuje bit najwyższej kolejności ostatniego bajtu w tablicy (bajtów w pozycji <xref:System.Array.Length%2A?displayProperty=nameWithType> `- 1`) jako bitem, metoda zwraca tablicę bajtów z dodatkowy element, którego wartość wynosi zero do odróżniania wartości dodatnie, które w przeciwnym razie można zinterpretować jako o ich bitów logowania. Na przykład wartość 120 lub `0x78` jest reprezentowany jako tablica jednobajtowe: `0x78`. Jednakże, 128, lub `0x80`, jest reprezentowany jako tablicę bajtów dwa: `0x80`, `0x00`.  
  
 Można wyrównana <xref:System.Numerics.BigInteger> wartości przez zapisanie jej na tablicę bajtów, a następnie przywróceniu go za pomocą <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> konstruktora.  
  
> [!CAUTION]
>  Kod zmienia wartość poszczególnych bajtów w tablicy zwracanej przez tę metodę, przed jego przywraca wartość, należy się upewnić, że nie przypadkowo zmienisz bitu znaku. Na przykład jeśli modyfikacje zwiększyć wartość dodatnią, dzięki czemu najwyższej kolejności bitu w ostatnim elemencie tablicy bajtów staje się ustawić, można dodać nowego typu byte, którego wartość wynosi zero do końca tablicy.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób niektóre <xref:System.Numerics.BigInteger> wartości są reprezentowane w tablice typu byte.  
  
 [!code-csharp[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/cs/ToByteArray1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/vb/ToByteArray1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray (bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray(bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray (Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Byte()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość liczbową bieżącego <see cref="T:System.Numerics.BigInteger" /> obiekt do reprezentacji ciągu równoważne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość liczbową bieżącego <see cref="T:System.Numerics.BigInteger" /> obiekt do reprezentacji ciągu równoważne.</summary>
        <returns>Reprezentacja ciągu bieżącego <see cref="T:System.Numerics.BigInteger" /> wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ToString> Formatów metody <xref:System.Numerics.BigInteger> wartość "R" lub przesyłania danych, w formacie bieżącej kultury. Jeśli chcesz określić inny format lub kultury, użyj innego przeciążenia metody <xref:System.Numerics.BigInteger.ToString%2A> metody, w następujący sposób:  
  
|Aby użyć formatu|Dla kultury|Użyj przeciążenia|  
|-------------------|-----------------|----------------------|  
|Round-trip ("R") format|Określoną kulturę|<xref:System.Numerics.BigInteger.ToString%2A>|  
|Określony format|Domyślną kulturę (bieżącego)|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Określony format|Określoną kulturę|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Reprezentacja ciągu <xref:System.Numerics.BigInteger> wartość obejmuje znaku minus, jeśli jego wartość jest ujemna i sekwencję cyfr od 0 do 9 bez zerami. Znakiem minus jest definiowana za pomocą <xref:System.Globalization.NumberFormatInfo> obiektu dla bieżącej kultury.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono <xref:System.Numerics.BigInteger> wartość przy użyciu domyślnej <xref:System.Numerics.BigInteger.ToString> metody. Wyświetla również reprezentacji ciągu <xref:System.Numerics.BigInteger> wartość będącą wynikiem używanie niektórych specyfikatorów formatu standardowych. W przykładach jest używana konwencja formatowania kultury en-US.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość liczbową bieżącego <see cref="T:System.Numerics.BigInteger" /> obiekt do reprezentacji ciągu równoważne przy użyciu określonego formatowania informacje specyficzne dla kultury.</summary>
        <returns>Reprezentacja ciągu bieżącego <see cref="T:System.Numerics.BigInteger" /> wartość w formacie określonym przez <paramref name="provider" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> Formatów metody <xref:System.Numerics.BigInteger> wartość "R" lub przesłanie sformatować przy użyciu <xref:System.Globalization.NumberFormatInfo> obiektu określonej kultury. Jeśli chcesz określić inny format lub bieżącej kultury, użyj innego przeciążenia metody <xref:System.Numerics.BigInteger.ToString%2A> metody, w następujący sposób:  
  
|Aby użyć formatu|Dla kultury|Użyj przeciążenia|  
|-------------------|-----------------|----------------------|  
|Round-trip ("R") format|Domyślną kulturę (bieżącego)|<xref:System.Numerics.BigInteger.ToString>|  
|Określony format|Domyślną kulturę (bieżącego)|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Określony format|Określoną kulturę|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 `provider` Parametr jest <xref:System.IFormatProvider> implementacji. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje specyficzne dla kultury o formacie ciągu zwracane przez tę metodę. Jeśli `provider` jest `null`, <xref:System.Numerics.BigInteger> wartość jest sformatowany przy użyciu <xref:System.Globalization.NumberFormatInfo> obiektu bieżącej kultury. Tylko właściwości <xref:System.Globalization.NumberFormatInfo> obiekt, który kontroluje reprezentację ciągu <xref:System.Numerics.BigInteger> jest wartość przy użyciu specyfikatora formatu Ogólne <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, który definiuje znak, który reprezentuje znakiem minus.  
  
 `provider` Parametr może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury, który dostarcza informacje dotyczące formatowania.  
  
-   <xref:System.Globalization.NumberFormatInfo> Obiektu, który dostarcza informacje dotyczące formatowania.  
  
-   Niestandardowy obiekt, który implementuje <xref:System.IFormatProvider>. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje dotyczące formatowania.  
  
   
  
## Examples  
 Poniższy przykład tworzy niestandardowy <xref:System.Globalization.NumberFormatInfo> obiektu, który definiuje tyldy (~) jako symbolu wartości ujemnej. <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> Metoda używa niestandardowego <xref:System.Globalization.NumberFormatInfo> obiektu do wyświetlenia ujemny <xref:System.Numerics.BigInteger> wartość.  
  
 [!code-csharp[System.Numeric.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/cs/System.Numeric.BigInteger.ToString.cs#1)]
 [!code-vb[System.Numeric.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/vb/System.Numeric.BigInteger.ToString.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Standardowy lub niestandardowy ciąg formatu liczbowego.</param>
        <summary>Konwertuje wartość liczbową bieżącego <see cref="T:System.Numerics.BigInteger" /> obiekt do reprezentacji ciągu równoważne przy użyciu określonego formatu.</summary>
        <returns>Reprezentacja ciągu bieżącego <see cref="T:System.Numerics.BigInteger" /> wartość w formacie określonym przez <paramref name="format" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ToString%28System.String%29> Formatów metody <xref:System.Numerics.BigInteger> wartości w określonym formacie za pomocą <xref:System.Globalization.NumberFormatInfo> obiekt, który reprezentuje konwencje bieżącej kultury. Jeśli chcesz użyć "R" lub przesyłania danych, formatu lub określić inną kulturę, użyj innego przeciążenia metody <xref:System.Numerics.BigInteger.ToString%2A> metody, w następujący sposób:  
  
|Aby użyć formatu|Dla kultury|Użyj przeciążenia|  
|-------------------|-----------------|----------------------|  
|Round-trip ("R") format|Domyślną kulturę (bieżącego)|<xref:System.Numerics.BigInteger.ToString>|  
|Round-trip ("R") format|Określoną kulturę|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Określony format|Określoną kulturę|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 `format` Parametr może być dowolny prawidłowy [standardowy ciąg numeryczny](~/docs/standard/base-types/standard-numeric-format-strings.md), lub dowolną kombinację [niestandardowe ciągi formatujące liczby](~/docs/standard/base-types/custom-numeric-format-strings.md). Jeśli `format` jest równa <xref:System.String.Empty?displayProperty=nameWithType> lub `null`, zwracana wartość bieżącej <xref:System.Numerics.BigInteger> obiektu jest sformatowany w systemie specyfikator formatu obustronne ("R"). Jeśli `format` jest wszelkie inne wartości, metoda zgłasza <xref:System.FormatException>.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat obsługi formatowania w programie .NET Framework, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 Format zwrócony ciąg jest określany przez <xref:System.Globalization.NumberFormatInfo> obiektu dla bieżącej kultury. W zależności od `format` parametr, ten obiekt określa symbole, takie jak znaku minus, separatora grupy i symbol punktu dziesiętnego w ciągu wyjściowego. Aby podać informacje dotyczące formatowania dla kultury niż bieżącej kultury, wywołaj <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> przeciążenia.  
  
   
  
## Examples  
 W poniższym przykładzie inicjowane <xref:System.Numerics.BigInteger> wartości i wyświetla je przy użyciu każdego ciągu standardowym formacie i niektórych niestandardowych ciągów formatu.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> nie jest prawidłowym ciągiem formatu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Standardowy lub niestandardowy ciąg formatu liczbowego.</param>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość liczbową bieżącego <see cref="T:System.Numerics.BigInteger" /> obiekt do reprezentacji ciągu równoważne przy użyciu określonego formatu i informacji o formacie specyficzne dla kultury.</summary>
        <returns>Reprezentacja ciągu bieżącego <see cref="T:System.Numerics.BigInteger" /> wartość określoną przez <paramref name="format" /> i <paramref name="provider" /> parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> Formatów metody <xref:System.Numerics.BigInteger> wartości w określonym formacie za pomocą <xref:System.Globalization.NumberFormatInfo> obiektu określonej kultury. Jeśli chcesz użyć formatu obustronne lub domyślne ustawienia kultury, użyj innego przeciążenia metody <xref:System.Numerics.BigInteger.ToString%2A> metody, w następujący sposób:  
  
|Aby użyć formatu|Dla kultury|Użyj przeciążenia|  
|-------------------|-----------------|----------------------|  
|Round-trip ("R") format|Domyślną kulturę (bieżącego)|<xref:System.Numerics.BigInteger.ToString>|  
|Round-trip ("R") format|Określoną kulturę|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Określony format|Domyślną kulturę (bieżącego)|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
  
 `format` Parametr może być dowolny prawidłowy [standardowy ciąg numeryczny](~/docs/standard/base-types/standard-numeric-format-strings.md), lub dowolną kombinację [niestandardowe ciągi formatujące liczby](~/docs/standard/base-types/custom-numeric-format-strings.md). Jeśli `format` jest równa <xref:System.String.Empty?displayProperty=nameWithType> lub `null`, zwracana wartość bieżącej <xref:System.Numerics.BigInteger> obiektu jest sformatowany w systemie specyfikator formatu obustronne ("R"). Jeśli `format` jest wszelkie inne wartości, metoda zgłasza <xref:System.FormatException>.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat obsługi formatowania w programie .NET Framework, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 `provider` Parametr jest <xref:System.IFormatProvider> implementacji. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje specyficzne dla kultury o formacie ciągu zwracane przez tę metodę. Gdy <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> wywołania metody, wywołuje `provider` parametru <xref:System.IFormatProvider.GetFormat%2A> — metoda i przekazuje je <xref:System.Type> obiekt, który reprezentuje <xref:System.Globalization.NumberFormatInfo> typu. <xref:System.IFormatProvider.GetFormat%2A> Następnie metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje dotyczące formatowania `value` parametrów, takich jak symbolu wartości ujemnej, symbol separatora grupy lub symbol punktu dziesiętnego. Istnieją trzy sposoby używania `provider` parametr, aby podać informacje dotyczące formatowania do <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> metody:  
  
-   Można przekazać <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury, który dostarcza informacje dotyczące formatowania. Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje numeryczne formatowania dla tej kultury.  
  
-   Można przekazać rzeczywiste <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje numeryczne formatowania. (Jej implementacja <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> zwraca siebie, po prostu.)  
  
-   Można przekazać niestandardowego obiektu, który implementuje <xref:System.IFormatProvider>. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda tworzy i zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje dotyczące formatowania.  
  
 Jeśli `provider` jest `null`, formatowanie zwrócony ciąg jest oparta na <xref:System.Globalization.NumberFormatInfo> obiektu bieżącej kultury.  
  
   
  
## Examples  
 W poniższym przykładzie inicjowane <xref:System.Numerics.BigInteger> wartości i wyświetla je w konsoli przy użyciu ciągu standardowym formacie i <xref:System.Globalization.NumberFormatInfo> obiektu, który definiuje tyldy (~) jako symbolu wartości ujemnej.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> nie jest prawidłowym ciągiem formatu.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Podejmuje próbę przekonwertowania reprezentację ciągu numer w celu jego <see cref="T:System.Numerics.BigInteger" /> równoważnej i zwraca wartość wskazującą, czy konwersja powiodła się.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Reprezentacja ciągu dla danej liczby.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.Numerics.BigInteger" /> odpowiednikiem liczba, która jest zawarta w <c>wartość</c>, lub zero (0), jeśli konwersja nie powiedzie się. Konwersja nie powiedzie się, jeśli <c>wartość</c> parametr jest <see langword="null" /> lub nie ma poprawnego formatu. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Podejmuje próbę przekonwertowania reprezentację ciągu numer w celu jego <see cref="T:System.Numerics.BigInteger" /> równoważnej i zwraca wartość wskazującą, czy konwersja powiodła się.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> został przekonwertowany pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> Przypomina metody <xref:System.Numerics.BigInteger.Parse%28System.String%29> metody, z wyjątkiem, że nie zgłosić wyjątek, jeśli konwersja nie powiedzie się. Ta metoda eliminuje potrzebę Użyj obsługi wyjątków w celu zbadania <xref:System.FormatException> Jeśli `value` jest nieprawidłowy i nie może zostać przeanalizowany pomyślnie.  
  
 `value` Parametr powinien być reprezentację liczby dziesiętnej w następującym formacie:  
  
 [*ws*] [*znak*]*cyfr*[*ws*]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Opcjonalny odstęp.|  
|*sign*|Opcjonalny znak. Nieprawidłowy znak znaki są określane przez <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> i <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> właściwości bieżącej kultury.|  
|*cyfr*|Sekwencja cyfr dziesiętnych od 0 do 9.|  
  
> [!NOTE]
>  Ciąg określony przez `value` parametr nie może zawierać żadnych separatorów grup lub separatora dziesiętnego i nie może mieć części dziesiętnych.  
  
 `value` Parametr jest interpretowany za pomocą <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> stylu. Poza cyframi dziesiętnymi dopuszcza się tylko spacje początkowe i końcowe z wiodącym znakiem. Aby oznaczyć elementy style formatowania informacje specyficzne dla kultury, które mogą być obecne w `value`, wywołaj <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> metody.  
  
 `value` Parametru jest analizowana, korzystając z informacji formatowania w <xref:System.Globalization.NumberFormatInfo> obiektu dla bieżącej kultury. Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>.  
  
 Cyfr wszystkich zinterpretuje tego przeciążenia `value` parametr jako cyfr dziesiętnych. Aby przeanalizować liczbę szesnastkową reprezentację ciągu, należy wywołać <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> zamiast tego przeciążenia.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> metodę, aby utworzyć dwa wystąpienia <xref:System.Numerics.BigInteger> obiektów. W przypadku konwersji, mnoży każdego obiektu przez inny numer, a następnie wywołuje <xref:System.Numerics.BigInteger.Compare%2A> metodę, aby określić relacji między tymi dwoma obiektami.  
  
 [!code-csharp[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/cs/System.Numeric.BigInteger.TryParse.cs#1)]
 [!code-vb[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/vb/System.Numeric.BigInteger.TryParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Reprezentacja ciągu dla danej liczby. Ten ciąg jest interpretowany przy użyciu stylu określony przez <c>styl</c>.</param>
        <param name="style">Bitowe połączenie wartości wyliczenia wskazująca elementy style, które mogą być obecne w <c>wartość</c>. Jest Typowa wartość do określenia <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">Obiekt, który dostarcza specyficzne dla kultury formatowania informacji na temat <c>wartość</c>.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.Numerics.BigInteger" /> odpowiednikiem liczba, która jest zawarta w <c>wartość</c>, lub <see cref="P:System.Numerics.BigInteger.Zero" /> Jeśli konwersja nie powiodła się. Konwersja nie powiedzie się, jeśli <c>wartość</c> parametr jest <see langword="null" /> lub nie jest w formacie, który jest zgodny ze <c>styl</c>. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Podejmuje próbę przekonwertowania reprezentację ciągu liczbą określony styl i specyficzne dla kultury formatu w celu jego <see cref="T:System.Numerics.BigInteger" /> równoważnej i zwraca wartość wskazującą, czy konwersja powiodła się.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> parametr został przekonwertowany pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> Przypomina metody <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> metody, z wyjątkiem, że nie zgłosić wyjątek, jeśli konwersja nie powiedzie się. Ta metoda eliminuje potrzebę Użyj obsługi wyjątków w celu zbadania <xref:System.FormatException> Jeśli `value` jest nieprawidłowy i nie może zostać przeanalizowany pomyślnie.  
  
 `style` Parametru definiuje elementy stylu (na przykład biały znak lub znak dodatnie lub ujemne), które są dozwolone w `value` parametr powodzenie operacji analizy. Musi być kombinacją flag bitowych z <xref:System.Globalization.NumberStyles> wyliczenia. W zależności od wartości `style`, `value` parametr może zawierać następujące elementy:  
  
 [*ws*][*$*][*sign*][*digits*,]*digits*[.*fractional_digits*][E[*sign*]*exponential_digits*][*ws*]  
  
 Jeśli `style` zawiera parametr <xref:System.Globalization.NumberStyles.AllowHexSpecifier>, `value` parametr może zawierać następujące elementy:  
  
 [*ws*]*hexdigits*[*ws*]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Opcjonalny odstęp. Biały znak, może występować na początku `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flagi, lub na końcu `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flagi.|  
|*$*|Symbol waluty specyficzny dla kultury. Jej położenie w ciągu jest definiowana za pomocą <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A> właściwość <xref:System.Globalization.NumberFormatInfo> obiektu zwróconego przez <xref:System.IFormatProvider.GetFormat%2A> metody `provider` parametru. Symbol waluty może występować w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flagi.|  
|*sign*|Opcjonalny znak. Logowania może wystąpić na początku `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flagę która może występować na końcu `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flagi. Użycie nawiasów w `value` wskaż wartość ujemną, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flagi.|  
|*cyfr*|Sekwencja cyfr od 0 do 9.|  
|*,*|Separator grupy specyficzny dla kultury. Separator grupy kultury określonej przez `provider` może występować w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flagi.|  
|*.*|Symbol dziesiętny specyficzny dla kultury. Symbol punktu dziesiętnego kultury określonej przez `provider` może występować w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flagi.|  
|*fractional_digits*|Jedno lub więcej wystąpień cyfry 0. Cyfr ułamkowych może występować w `value` tylko wtedy, gdy `style` obejmuje <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flagi.|  
|E|Znak „e” lub „E”, który wskazuje, że wartość jest reprezentowana w zapisie wykładniczym (naukowym). `value` Parametr może reprezentować liczbę w notacji wykładniczej, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flagi.|  
|*exponential_digits*|Sekwencja cyfr od 0 do 9. `value` Parametr może reprezentować liczbę w notacji wykładniczej, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flagi.|  
|*hexdigits*|Sekwencja cyfr szesnastkowych od 0 do f lub od 0 do F.|  
  
 Ciąg zawierający tylko cyfry dziesiętne (które odpowiada <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> flagi) zawsze przeanalizowany pomyślnie. Większość pozostałych <xref:System.Globalization.NumberStyles> członkowie sterować elementy, które mogą być obecne, ale nie muszą znajdować się w tym ciągu wejściowego. W poniższej tabeli przedstawiono poszczególne <xref:System.Globalization.NumberStyles> elementów członkowskich mają wpływ na elementy, które mogą być obecne w `value`.  
  
|Inne niż złożone `NumberStyles` wartości|Dodatkowe (poza cyframi) elementy dozwolone w wartości|  
|------------------------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Tylko cyfry dziesiętne.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Dziesiętnego (*.*) i *fractional_digits* elementów. Jednak *fractional_digits* musi składać się z jednego lub więcej cyfry 0 lub metoda zwraca `false`.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E" lub litery "E", która wskazuje notacji wykładniczej, wraz z *exponential_digits*. Jeśli `value` reprezentuje liczbę w notacji wykładniczej, nie może mieć inną niż zero, ułamkowych składnika.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws* element na początku `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws* element na końcu `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*Znak* element przed *cyfr*.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*Znak* elementu po *cyfr*.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*Znak* elementu w postaci nawiasów otaczającej wartość liczbową.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Separator grupy (*,*) elementu.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Waluta (*$*) elementu.|  
|<xref:System.Globalization.NumberStyles.Currency>|Wszystkie elementy. Jednak `value` nie może reprezentować liczbę szesnastkową lub numer w notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws* elementu na początek lub koniec `value`, *znak* na początku `value`i dziesiętnego (*.*) symbolu. `value` Parametr można również użyć notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Number>|*Ws*, *znak*, grupy separatora (*,*), a separatorem dziesiętnym (*.*) elementów.|  
|<xref:System.Globalization.NumberStyles.Any>|Wszystkie elementy. Jednak `value` nie może reprezentować liczbę szesnastkową.|  
  
> [!IMPORTANT]
>  Jeśli używasz <xref:System.Numerics.BigInteger.TryParse%2A> metody przesyłania danych reprezentację ciągu z <xref:System.Numerics.BigInteger> wartość, która została danych wyjściowych przez <xref:System.Numerics.BigInteger.ToString%2A> metody, należy użyć <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metody z specyfikator formatu "R", aby wygenerować reprezentację ciągu <xref:System.Numerics.BigInteger> wartość. W przeciwnym razie reprezentację ciągu <xref:System.Numerics.BigInteger> zachowuje tylko 50 cyfr znaczących większość oryginalnej wartości i dane mogą zostać utracone, korzystając z <xref:System.Numerics.BigInteger.TryParse%2A> metoda przywracania <xref:System.Numerics.BigInteger> wartość.  
  
 Jeśli <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> flaga jest wykorzystywana, `value` musi mieć wartość szesnastkową. Tylko innych flagi, które mogą być obecne w `style` są <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> i <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. ( <xref:System.Globalization.NumberStyles> Wyliczenie ma stylu złożonego <xref:System.Globalization.NumberStyles.HexNumber>, zawierająca zarówno flagi biały znak.)  
  
> [!NOTE]
>  Jeśli `value` reprezentacja ciągu z liczbą szesnastkową nie może być poprzedzone żadnych decoration (takich jak `0x` lub `&h`) który odróżnia go jako liczbę szesnastkową. To powoduje niepowodzenie konwersji.  
  
 Jeśli `value` jest ciągiem szesnastkowym <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> interpretuje metody `value` jako wartość ujemną przechowywane za pomocą dwóch jego reprezentacja dopełnienia, jeśli jego pierwsze dwie cyfry szesnastkowe są większe niż lub równe `0x80`. Innymi słowy, metoda interpretuje bit najwyższej kolejności pierwszego bajtu w `value` jako bitem. Aby upewnić się, że ciąg szesnastkowy poprawnie jest interpretowana jako wartość dodatnią, cyfry, w `value` musi mieć wartość zero. Na przykład metoda interpretuje `0x80` zgodnie z wartością ujemną, ale interpretuje albo `0x080` lub `0x0080` jako wartość dodatnią. Poniższy przykład przedstawia różnice między ciągów szesnastkowych, które reprezentują wartości ujemnych i dodatnich.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParseHex1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParseHex1.vb#1)]  
  
 `provider` Parametr jest <xref:System.IFormatProvider> implementacji. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który zawiera informacje specyficzne dla kultury o format `value`. `provider` Parametru może być jednym z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury, który dostarcza informacje dotyczące formatowania. Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje numeryczne formatowania dla tej kultury.  
  
-   A <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje numeryczne formatowania. (Jej implementacja <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> zwraca siebie, po prostu.)  
  
-   Niestandardowy obiekt, który implementuje <xref:System.IFormatProvider>. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda tworzy i zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje dotyczące formatowania.  
  
 Jeśli `provider` jest `null`, <xref:System.Globalization.NumberFormatInfo> obiektu dla bieżącej kultury jest używany.  
  
   
  
## Examples  
 Poniższy przykład powoduje, że niektóre wywołania <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> metodę przy użyciu różnych kombinacji wartości `style` i `provider` parametrów.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#2)]  
  
 Liczba wywołań poszczególnych <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> metody Przekaż wystąpienie następujących `BigIntegerFormatProvider` klasy, która definiuje tyldy (~) jako znaku minus.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> nie jest <see cref="T:System.Globalization.NumberStyles" /> wartość.  
  
 —lub—  
  
 <paramref name="style" /> obejmuje <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> lub <see cref="F:System.Globalization.NumberStyles.HexNumber" /> flagi wraz z inną wartość.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryWriteBytes(System.Span{System.Byte},System.Int32@,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer, Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Boolean" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger Zero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Zero As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger Zero { System::Numerics::BigInteger get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość reprezentującą liczbę 0 (zero).</summary>
        <value>Liczba całkowita, którego wartość wynosi 0 (zero).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger> Obiektu zwróconego przez tę właściwość stanowi wygodny źródło wartość zerową dla przypisania i porównania.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsZero" />
      </Docs>
    </Member>
  </Members>
</Type>
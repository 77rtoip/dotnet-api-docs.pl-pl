<Type Name="BigInteger" FullName="System.Numerics.BigInteger">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e1cc88ecbcca23616e88b5a9a8dc83caae6a32e3" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39913981" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct BigInteger : IComparable, IComparable&lt;System.Numerics.BigInteger&gt;, IEquatable&lt;System.Numerics.BigInteger&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit BigInteger extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IEquatable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.BigInteger" />
  <TypeSignature Language="VB.NET" Value="Public Structure BigInteger&#xA;Implements IComparable, IComparable(Of BigInteger), IEquatable(Of BigInteger), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class BigInteger : IComparable, IComparable&lt;System::Numerics::BigInteger&gt;, IEquatable&lt;System::Numerics::BigInteger&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type BigInteger = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.1">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje liczbę całkowitą dowolnie dużą podpisem.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger> Typ jest typem niezmienne, który reprezentuje liczbę całkowitą dowolnie dużą, którego wartość teoretycznie nie ma żadnych granic górny lub niższą. Elementy członkowskie <xref:System.Numerics.BigInteger> typu ściśle równoległe udostępnianych przez inne typy całkowitoliczbowe ( <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, i <xref:System.UInt64> typy). Ten typ, który różni się od innych typów całkowitych w [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], które mają zakres wskazywany przez ich `MinValue` i `MaxValue` właściwości.  
  
> [!NOTE]
>  Ponieważ <xref:System.Numerics.BigInteger> typ jest niezmienny (zobacz [zmienność i struktura BigInteger](#mutability)) i ma on żadnych granic górnej i dolnej <xref:System.OutOfMemoryException> może zostać wygenerowany dla każdej operacji, która powoduje, że <xref:System.Numerics.BigInteger> wartość zbyt rozwijania duże.  
  
## <a name="instantiating-a-biginteger-object"></a>Utworzenie wystąpienia obiektu BigInteger  
 Można utworzyć wystąpienie <xref:System.Numerics.BigInteger> obiekt na kilka sposobów:  
  
-   Możesz użyć `new` — słowo kluczowe i podaj wartości całkowitych lub zmiennoprzecinkowych jako parametr do <xref:System.Numerics.BigInteger> konstruktora. (Różne wartości zmiennoprzecinkowe są obcinane przed przypisaniem do <xref:System.Numerics.BigInteger>.) Poniższy przykład ilustruje sposób używania `new` — słowo kluczowe do utworzenia wystąpienia <xref:System.Numerics.BigInteger> wartości.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#1)]
     [!code-vb[System.Numerics.BigInteger.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#1)]  
  
-   Można zadeklarować <xref:System.Numerics.BigInteger> zmienną i przypisz wartości, tak jak miałoby to dowolnego typu liczbowego, tak długo, jak ta wartość jest typu całkowitego. W poniższym przykładzie użyto przypisania, aby utworzyć <xref:System.Numerics.BigInteger> wartość z <xref:System.Int64>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#2)]
     [!code-vb[System.Numerics.BigInteger.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#2)]  
  
-   Można przypisać wartość dziesiętną lub zmiennoprzecinkową do <xref:System.Numerics.BigInteger> obiekt można rzutować wartości lub przekonwertować go najpierw. Poniższy przykład jawnie rzutuje (w języku C#) lub konwertuje (w języku Visual Basic) <xref:System.Double> i <xref:System.Decimal> wartość <xref:System.Numerics.BigInteger>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#3)]
     [!code-vb[System.Numerics.BigInteger.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#3)]  
  
 Te metody umożliwiają utworzenia wystąpienia <xref:System.Numerics.BigInteger> tylko typy obiektów, których wartość znajduje się w zakresie jednej z istniejących numeryczne. Można utworzyć wystąpienie <xref:System.Numerics.BigInteger> obiektu, którego wartość może przekroczyć zakres istniejące typy liczbowe w jeden z trzech sposobów:  
  
-   Możesz użyć `new` — słowo kluczowe i podaj tablica bajtów o dowolnym rozmiarze <xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=nameWithType> konstruktora. Na przykład:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#4)]
     [!code-vb[System.Numerics.BigInteger.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#4)]  
  
-   Możesz wywołać <xref:System.Numerics.BigInteger.Parse%2A> lub <xref:System.Numerics.BigInteger.TryParse%2A> metody konwersji ciąg reprezentujący liczbę na <xref:System.Numerics.BigInteger>. Na przykład:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#5)]
     [!code-vb[System.Numerics.BigInteger.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#5)]  
  
-   Możesz wywołać `static` (`Shared` w języku Visual Basic) <xref:System.Numerics.BigInteger> metodę, która wykonuje niektóre operacje na wyrażenie liczbowe i zwraca obliczeniowego <xref:System.Numerics.BigInteger> wynik. Poniższy przykład robi to przez cubing <xref:System.UInt64.MaxValue?displayProperty=nameWithType> i przypisz wynik do <xref:System.Numerics.BigInteger>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#6)]
     [!code-vb[System.Numerics.BigInteger.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#6)]  
  
 Wartość niezainicjowanej <xref:System.Numerics.BigInteger> jest <xref:System.Numerics.BigInteger.Zero%2A>.  
  
## <a name="performing-operations-on-biginteger-values"></a>Wykonywanie operacji na wartościach typu BigInteger  
 Możesz użyć <xref:System.Numerics.BigInteger> wystąpienia tak, jak możesz użyć dowolnego typu całkowitoliczbowego. <xref:System.Numerics.BigInteger> Overloads standardowe operatory numeryczne umożliwiające wykonywanie podstawowych operacji matematycznych, takich jak dodawanie, odejmowanie, dzielenie, mnożenie, odejmowanie, negacji i Negacja Jednoargumentowa. Standardowe operatory numeryczne również służy do porównywania dwóch <xref:System.Numerics.BigInteger> wartości ze sobą. Inne typy całkowitoliczbowe, takich jak <xref:System.Numerics.BigInteger> obsługuje również operatora testu koniunkcji `And`, `Or`, `XOr`, pozostanie shift i operatory przesunięcia w prawo. W przypadku języków, które nie obsługują operatorów niestandardowych <xref:System.Numerics.BigInteger> struktura zapewnia również równoważne metody służące do wykonywania operacji matematycznych. Obejmują one <xref:System.Numerics.BigInteger.Add%2A>, <xref:System.Numerics.BigInteger.Divide%2A>, <xref:System.Numerics.BigInteger.Multiply%2A>, <xref:System.Numerics.BigInteger.Negate%2A>, <xref:System.Numerics.BigInteger.Subtract%2A>oraz kilka innych.  
  
 Wiele elementów członkowskich z <xref:System.Numerics.BigInteger> struktury odpowiadają bezpośrednio do elementów członkowskich inne typy całkowitoliczbowe. Ponadto <xref:System.Numerics.BigInteger> dodaje elementy członkowskie podobny do następującego:  
  
-   <xref:System.Numerics.BigInteger.Sign%2A>, która zwraca wartość, która określa znak <xref:System.Numerics.BigInteger> wartość.  
  
-   <xref:System.Numerics.BigInteger.Abs%2A>, która zwraca wartość bezwzględną liczby <xref:System.Numerics.BigInteger> wartość.  
  
-   <xref:System.Numerics.BigInteger.DivRem%2A>, która zwraca iloraz i resztę z operacji dzielenia.  
  
-   <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>, która zwraca największy wspólny dzielnik dwóch <xref:System.Numerics.BigInteger> wartości.  
  
 Wiele z tych dodatkowych członków odnoszą się do elementów członkowskich <xref:System.Math> klasy, która oferuje funkcje do pracy z pierwotnych typów liczbowych.  
  
<a name="mutability"></a>   
## <a name="mutability-and-the-biginteger-structure"></a>Zmienność i struktura BigInteger  
 Poniższy przykład tworzy wystąpienie <xref:System.Numerics.BigInteger> obiektu, a następnie zwiększa jego wartości przez jeden.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#1)]  
  
 Do modyfikowania wartości istniejący obiekt jest wyświetlana w tym przykładzie, ale nie jest to przypadek. <xref:System.Numerics.BigInteger> obiekty są niezmienne, co oznacza, że wewnętrznie, środowisko uruchomieniowe języka wspólnego tworzy nową <xref:System.Numerics.BigInteger> obiektu i przypisuje jej wartość większa o jeden od poprzedniej wartości. Ten nowy obiekt jest następnie zwracany do obiektu wywołującego.  
  
> [!NOTE]
>  Inne typy liczbowe w programie .NET Framework, również są niezmienne. Jednak ponieważ <xref:System.Numerics.BigInteger> typ nie ma żadnych granic górnej i dolnej, jego wartości można powiększać bardzo dużych i ma zauważalnego wpływu na wydajność.  
  
 Mimo że ten proces jest niewidoczny dla obiektu wywołującego, ona spowodować zmniejszenie wydajności. W niektórych przypadkach, szczególnie gdy powtarzanych operacje są wykonywane w pętli na bardzo dużych <xref:System.Numerics.BigInteger> wartości, że spadek wydajności mogą być znaczące. Na przykład w poniższym przykładzie jest wykonywane kilkukrotnie do milionów razy, a <xref:System.Numerics.BigInteger> wartość jest zwiększany o jeden, za każdym razem, gdy operacja powiedzie się.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#12)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#12)]  
  
 W takim przypadku może poprawić wydajność, wykonując wszystkie pośrednie przypisania do <xref:System.Int32> zmiennej. Końcowa wartość zmiennej można przypisać do <xref:System.Numerics.BigInteger> obiektu, kiedy kończy pętli. Poniższy przykład stanowi ilustrację.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#3)]  
  
## <a name="working-with-byte-arrays-and-hexadecimal-strings"></a>Praca z tablicami bajtowymi i ciągami znaków szesnastkowych  
 Po skonwertowaniu <xref:System.Numerics.BigInteger> wartości, które mają tablice typu byte, lub jeśli skonwertujesz tablice typu byte do <xref:System.Numerics.BigInteger> wartości, należy rozważyć kolejności bajtów. <xref:System.Numerics.BigInteger> Struktury oczekuje pojedynczych bajtów w tablicy typu byte do są wyświetlane w kolejności little-endian (oznacza to, że wartość w bajtach niższego rzędu poprzedzać wyższego rzędu w bajtach). Możesz Rundy <xref:System.Numerics.BigInteger> wartość przez wywołanie metody <xref:System.Numerics.BigInteger.ToByteArray%2A> metody, a następnie przekazywanie wynikowy byte array do <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> konstruktora, co ilustruje poniższy przykład.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#1)]  
  
 Aby utworzyć wystąpienie <xref:System.Numerics.BigInteger> wartości z tablicy bajtowej, która reprezentuje wartość całkowitą typu, można przekazać traktowanie wartości całkowitej <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> metody, a następnie przekaż wynikowy byte array do <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> konstruktora. Poniższy przykład tworzy wystąpienie <xref:System.Numerics.BigInteger> wartości z tablicy bajtowej, który reprezentuje <xref:System.Int16> wartość.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#2)]  
  
 <xref:System.Numerics.BigInteger> Struktury przyjęto założenie, że wartości ujemne są przechowywane przy użyciu reprezentacji uzupełnieniem do dwóch. Ponieważ <xref:System.Numerics.BigInteger> struktury reprezentuje wartość numeryczną z brak stałej długości <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> Konstruktor interpretuje parametry zawsze najbardziej znaczący bit ostatniego bajtu w tablicy, jako bitu znaku. Aby zapobiec <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> konstruktora z mylące dwójki uzupełnienie reprezentacja wartości ujemnej ze znakiem i wartość reprezentacja wartości dodatniej dodatnią wartości w którym najbardziej znaczący bit ostatniego bajtu w tablicy bajtowej normalnie jest zestaw powinny zawierać dodatkowe bajtów, którego wartość jest równa 0. Na przykład 0xC0 0xBD 0xF0 0xFF jest reprezentacji szesnastkowej little-endian-1,000,000 lub 4,293,967,296. Ponieważ najbardziej znaczący bit ostatniego bajtu w tej tablicy na wartość tablica bajtów może być interpretowany przez <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> Konstruktor jako-1,000,000. Aby utworzyć wystąpienie <xref:System.Numerics.BigInteger> którego wartość jest dodatnia, tablica bajtów, której elementy są 0xC0 0xBD 0xF0 0xFF 0x00 muszą być przekazywane do konstruktora. Ilustruje to poniższy przykład.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#3)]  
  
 Tablice typu byte utworzone przez <xref:System.Numerics.BigInteger.ToByteArray%2A> metody z wartości dodatnich obejmują bajt dodatkowych wartości zero. W związku z tym <xref:System.Numerics.BigInteger> struktura może pomyślnie obustronne wartości przez przypisywanie ich do i przywracania ich z tablic bajtowych, co ilustruje poniższy przykład.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#4)]  
  
 Może jednak może być konieczne dodanie dodatkowych bajt wartości zero do tablic bajtowych, które są tworzone dynamicznie przez dewelopera lub które są zwracane przez metody, które konwertują liczb całkowitych bez znaku do tablic bajtów (takie jak <xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=nameWithType>, <xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=nameWithType>, i <xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=nameWithType>).  
  
 Podczas analizowania ciąg szesnastkowy <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> i <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metod przyjęto założenie, że jeśli ustawiono najbardziej znaczący bit pierwszego bajtu w ciągu lub jeżeli pierwsza cyfra szesnastkowa ciągu reprezentuje niższe cztery bity w wartości typu bajtowego, wartość to reprezentowane przy użyciu reprezentacji uzupełnieniem do dwóch. Na przykład "FF01" i "F01" reprezentuje wartość dziesiętną-255. Do odróżnienia dodatnie, ujemne wartości, wartości dodatnich powinno obejmować zerem wiodącym. Odpowiednie przeciążenia <xref:System.Numerics.BigInteger.ToString%2A> metody, gdy są przekazywane na ciąg formatu "X", Dodaj zera do zwracanego ciągu szesnastkowego dla wartości dodatnich. Dzięki temu przesyłania danych <xref:System.Numerics.BigInteger> wartości przy użyciu <xref:System.Numerics.BigInteger.ToString%2A> i <xref:System.Numerics.BigInteger.Parse%2A> metod, co ilustruje poniższy przykład.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#5)]  
  
 Jednak ciągów szesnastkowych utworzonych przez wywoływanie `ToString` metod inne typy całkowitoliczbowe lub przeciążeń <xref:System.Convert.ToString%2A> metody, które obejmują `toBase` parametr wskazuje znak wartość lub typ źródła danych, z którego ciąg szesnastkowy został uzyskany. Pomyślnie wystąpienia <xref:System.Numerics.BigInteger> wartości z ciągu znaków wymaga pewnych dodatkowej logiki. W poniższym przykładzie przedstawiono jedną możliwą implementację.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples2.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : byte[] -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">Tablica wartości bajtów w kolejności little-endian.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury, używając wartości z tablicy bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poszczególne bajty `value` tablicy powinien znajdować się w kolejności little-endian, od najniższej kolejności bajtów do najwyższej kolejności bajtów. Na przykład wartość liczbowa 1,000,000,000,000 jest reprezentowane, jak pokazano w poniższej tabeli:  
  
|||  
|-|-|  
|Ciąg szesnastkowy|E8D4A51000|  
|Tablica bajtów (najniższy indeks najpierw)|00 10 A5 D4 E8 00|  
  
 Większość metod, które konwertują wartości liczbowych na tablice bajtów, takich jak <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> i <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>, zwracają tablice bajtów w kolejności little-endian.  
  
 Konstruktor oczekuje wartości dodatnich w tablicy bajtów na potrzeby użycia reprezentacji uzupełnieniem do dwóch reprezentacja logowania i wielkości i wartości ujemnych. Innymi słowy Jeśli najwyższego rzędu trochę bajt najwyższego rzędu w `value` ustawiono wartość wynikowa <xref:System.Numerics.BigInteger> wartość jest liczbą ujemną. W zależności od źródła tablicy bajtowej może to spowodować wartość dodatnią zostać błędnie zinterpretowane jako wartość ujemną. Tablice typu byte zwykle są generowane w następujący sposób:  
  
-   Przez wywołanie metody <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> metody. Ponieważ metoda ta zwraca tablicę bajtów od bitu najwyższego rzędu bajtu najwyższego rzędu w zestawie tablicy od zera dla wartości dodatnich, istnieje prawdopodobieństwo rozdzielnie wartości dodatniej jako ujemny. Tablice typu byte utworzone przez w niezmienionej postaci <xref:System.Numerics.BigInteger.ToByteArray%2A> zawsze pomyślnie Rundy, gdy są przekazywane do metody <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> konstruktora.  
  
-   Przez wywołanie metody <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> metody i przekazanie do niej oznaczoną liczbę całkowitą jako parametr. Liczby całkowite ze znakiem obsługiwać reprezentacji logowania i wielkości i reprezentacji uzupełnieniem do dwóch, nie istnieje prawdopodobieństwo rozdzielnie wartości dodatniej jako ujemny.  
  
-   Przez wywołanie metody <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> metody i przekazanie do niej liczbę całkowitą bez znaku jako parametr. Ponieważ liczb całkowitych bez znaku są reprezentowane przez ich znaczenie tylko, wartości dodatnich może być błędnie zinterpretowana jako wartości ujemnych. Aby uniknąć tego błędnej interpretacji, można dodać wartość zero bajtów do końca tablicy. W przykładzie w następnej sekcji stanowi ilustrację.  
  
-   Tworząc tablicę bajtów albo dynamicznie lub statycznie bez niekoniecznie wywoływanie jednego z poprzednich metod lub przez zmodyfikowanie istniejącej tablicy bajtów. Aby zapobiec jest błędnie zinterpretowana jako wartości ujemnych wartości dodatnich, można dodać wartość zero bajtów do końca tablicy.  
  
 Jeśli `value` jest pustym <xref:System.Byte> tablicy, nowa <xref:System.Numerics.BigInteger> obiekt jest inicjowany do wartości <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>. Jeśli `value` jest `null`, Konstruktor wyrzuca <xref:System.ArgumentNullException>.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Numerics.BigInteger> obiektu z tablicy bajtowej 5-elementowej, w których wartość jest {5, 4, 3, 2, 1}. Następnie wyświetla <xref:System.Numerics.BigInteger> reprezentowaną jako liczby dziesiętnej i szesnastkowa, w konsoli. Porównanie wartości tablicy wejściowej z tekstu wyjściowego sprawia, że jasne, dlaczego to przeciążenie <xref:System.Numerics.BigInteger> tworzy konstruktora klasy <xref:System.Numerics.BigInteger> obiektu, którego wartość jest 4328719365 (lub 0x102030405). Pierwszy element tablicy bajtowej, którego wartość to 5, określa wartość bajtu najniższego rzędu <xref:System.Numerics.BigInteger> obiektu, który jest 0x05. Drugi element tablicy bajtowej, którego wartość to 4, określa wartość drugi bajt <xref:System.Numerics.BigInteger> obiektu, który jest 0x04 i tak dalej.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ctors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#1)]  
  
 Poniższy przykład tworzy pozytywnych i negatywnych <xref:System.Numerics.BigInteger> wartość, przekazuje je do <xref:System.Numerics.BigInteger.ToByteArray%2A> metody, a następnie przywraca oryginalną <xref:System.Numerics.BigInteger> wartości z tablicą wynikową bajtów. Należy pamiętać, że te dwie wartości są reprezentowane przez tablice bajtowe identyczne. Jedyną różnicą między nimi jest najbardziej znaczącego bitu po ostatnim elemencie w tablicy bajtów. Ten bit jest ustawiona, (wartość bajtu to 0xFF), jeśli tablica jest tworzona z ujemnych <xref:System.Numerics.BigInteger> wartość. Bit nie jest ustawiona, (wartość bajtu wynosi zero,), jeśli tablica jest tworzona z dodatnią <xref:System.Numerics.BigInteger> wartość.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.ctors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#2)]  
  
 Poniższy przykład ilustruje jak upewnić się, że wartość dodatnią nie niepoprawnie konkretyzacji jako wartość ujemną, dodając bajtów, którego wartość jest równa zero do końca tablicy.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ctors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToByteArray" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : decimal -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Liczba dziesiętna.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury za pomocą <see cref="T:System.Decimal" /> wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wynik wywołania tego konstruktora jest taka sama jak przypisywanie jawnie <xref:System.Decimal> wartość <xref:System.Numerics.BigInteger> zmiennej.  
  
 Podczas wywoływania tego konstruktora może spowodować utratę danych; wszystkie części ułamkowej `value` zostały obcięte podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> Konstruktor do tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu. Definiuje on tablicę <xref:System.Decimal> wartości, a następnie przekazuje każdą wartość w celu <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> konstruktora. Należy pamiętać, że <xref:System.Decimal> wartość zostanie obcięta zamiast zaokrąglane, gdy jest przypisany do <xref:System.Numerics.BigInteger> obiektu.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ctors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(double value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : double -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Wartość zmiennoprzecinkowa podwójnej precyzji.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury przy użyciu wartości zmiennoprzecinkowe podwójnej precyzji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie części ułamkowej `value` parametru zostały obcięte podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu.  
  
 Ze względu na brak dokładność <xref:System.Double> typu danych, wywoływania tego konstruktora może spowodować utratę danych.  
  
 <xref:System.Numerics.BigInteger> Wartość będącą wynikiem wywołania tego konstruktora jest taka sama jak wartość, która wynika z jawnie przypisywanie <xref:System.Double> wartość <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29> Konstruktor do tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu. Ilustruje także utratę dokładności, który może wystąpić, gdy używasz <xref:System.Double> typu danych. A <xref:System.Double> przypisano dużą wartość, która jest przypisywany do <xref:System.Numerics.BigInteger> obiektu. Dane wyjściowe pokazują, to przypisanie pociąga za sobą utratę dokładności. Obie wartości są następnie zwiększany o jeden. Dane wyjściowe pokazują, że <xref:System.Numerics.BigInteger> obiektu odzwierciedla zmieniona wartość, natomiast <xref:System.Double> nie obsługuje obiektu.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#5)]
 [!code-vb[System.Numerics.BigInteger.ctors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość <paramref name="value" /> jest <see cref="F:System.Double.NaN" />.  - lub - wartość <paramref name="value" /> jest <see cref="F:System.Double.NegativeInfinity" />.  - lub - wartość <paramref name="value" /> jest <see cref="F:System.Double.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(int value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Całkowita 32-bitowych.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury przy użyciu wartości 32-bitową.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istnieje bez utraty dokładności, podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu za pomocą tego konstruktora.  
  
 <xref:System.Numerics.BigInteger> Wartość będącą wynikiem wywołania tego konstruktora jest taka sama jak wartość, która wynika z przypisaniem <xref:System.Int32> wartość <xref:System.Numerics.BigInteger>.  
  
 <xref:System.Numerics.BigInteger> Struktury nie ma konstruktorów z parametrem typu <xref:System.Byte>, <xref:System.Int16>, <xref:System.SByte>, lub <xref:System.UInt16>. Jednak <xref:System.Int32> typ obsługuje niejawną konwersję 8-bitowych i 16-bitowe podpisane lub niepodpisane liczby całkowite na liczby całkowite ze znakiem 32-bitowych. W wyniku tego konstruktora jest wywoływana, gdy `value` jest jednym z tych czterech typów całkowitych.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29> Konstruktor do tworzenia wystąpienia <xref:System.Numerics.BigInteger> wartości z tablicy 32-bitowych liczb całkowitych. Korzysta również niejawna konwersja można przypisać każdą wartość 32-bitowej liczby całkowitej w celu <xref:System.Numerics.BigInteger> zmiennej. Następnie porównuje dwie wartości ustalenie, czy wynikowy <xref:System.Numerics.BigInteger> wartości są takie same.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.ctors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(long value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Całkowita 64-bitowych.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury przy użyciu wartości liczby całkowitej ze znakiem 64-bitowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istnieje bez utraty dokładności, podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu za pomocą tego konstruktora.  
  
 <xref:System.Numerics.BigInteger> Wartość będącą wynikiem wywołania tego konstruktora jest taka sama jak wartość, która wynika z przypisaniem <xref:System.Int64> wartość <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29> Konstruktor do tworzenia wystąpienia <xref:System.Numerics.BigInteger> wartości z tablicy, 64-bitowych liczb całkowitych. Korzysta również niejawna konwersja można przypisać każdą wartość 64-bitowej liczby całkowitej w celu <xref:System.Numerics.BigInteger> zmiennej. Następnie porównuje dwie wartości ustalenie, czy wynikowy <xref:System.Numerics.BigInteger> wartości są takie same.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#7)]
 [!code-vb[System.Numerics.BigInteger.ctors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(float value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : single -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Wartość zmiennoprzecinkowa pojedynczej precyzji.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury przy użyciu wartości zmiennoprzecinkowych pojedynczej precyzji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie części ułamkowej `value` parametru zostały obcięte podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu.  
  
 Ze względu na brak dokładność <xref:System.Single> typu danych, wywoływania tego konstruktora może spowodować utratę danych.  
  
 <xref:System.Numerics.BigInteger> Wartość będącą wynikiem wywołania tego konstruktora jest taka sama jak wartość, która wynika z jawnie przypisywanie <xref:System.Single> wartość <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29> Konstruktor do tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu. Ilustruje także utratę dokładności, który może wystąpić, gdy używasz <xref:System.Single> typu danych. A <xref:System.Single> przypisano dużą wartość ujemną, który jest przypisywany do <xref:System.Numerics.BigInteger> obiektu. Dane wyjściowe pokazują, to przypisanie pociąga za sobą utratę dokładności. Obie wartości są następnie zwiększany o jeden. Dane wyjściowe pokazują, że <xref:System.Numerics.BigInteger> obiektu odzwierciedla zmieniona wartość, natomiast <xref:System.Single> nie obsługuje obiektu.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#8)]
 [!code-vb[System.Numerics.BigInteger.ctors#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość <paramref name="value" /> jest <see cref="F:System.Single.NaN" />.  - lub - wartość <paramref name="value" /> jest <see cref="F:System.Single.NegativeInfinity" />.  - lub - wartość <paramref name="value" /> jest <see cref="F:System.Single.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint32 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Liczba całkowita bez znaku 32-bitowa wartość.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury przy użyciu wartości bez znaku 32-bitowa liczba całkowita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istnieje bez utraty dokładności, podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> za pomocą tego konstruktora.  
  
 <xref:System.Numerics.BigInteger> Wartość będącą wynikiem wywołania tego konstruktora jest taka sama jak wartość, która wynika z przypisaniem <xref:System.UInt32> wartość <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29> Konstruktor i instrukcji przypisania, można zainicjować <xref:System.Numerics.BigInteger> wartości z tablicy liczb całkowitych bez znaku 32-bitowych. Następnie porównuje dwie wartości i Wykaż, że te dwie metody inicjowania <xref:System.Numerics.BigInteger> wartość utworzyć takie same wyniki.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#9)]
 [!code-vb[System.Numerics.BigInteger.ctors#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#9)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">64-bitowa liczba całkowita bez znaku.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> strukturę nieoznaczoną 64-bitowych wartość całkowitą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istnieje bez utraty dokładności, podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> za pomocą tego konstruktora.  
  
 <xref:System.Numerics.BigInteger> Wartość będącą wynikiem wywołania tego konstruktora jest taka sama jak wartość, która wynika z przypisaniem <xref:System.UInt64> wartość <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29> Konstruktor do tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu, którego wartość jest równa <xref:System.UInt64.MaxValue>.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#10)]
 [!code-vb[System.Numerics.BigInteger.ctors#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#10)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ReadOnlySpan&lt;byte&gt; value, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; value, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.ReadOnlySpan{System.Byte},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Byte), Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false)" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : ReadOnlySpan&lt;byte&gt; * bool * bool -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger (value, isUnsigned, isBigEndian)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Abs (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Abs(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Abs(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Liczba z przedziału.</param>
        <summary>Pobiera wartość bezwzględną liczby <see cref="T:System.Numerics.BigInteger" /> obiektu.</summary>
        <returns>Wartość bezwzględna <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość bezwzględna liczby jest tę liczbę bez znaku, jak pokazano w poniższej tabeli.  
  
|`value` Parametr|Wartość zwracana|  
|-----------------------|------------------|  
|`value` >= 0|`value`|  
|`value` < 0|`value` * -1|  
  
 <xref:System.Numerics.BigInteger.Abs%2A> Metoda jest równoważna <xref:System.Math.Abs%2A?displayProperty=nameWithType> metodę pierwotnych typów liczbowych.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.Abs%2A> metodę, aby przekonwertować <xref:System.Numerics.BigInteger> wartości z reprezentacji uzupełnieniem do dwóch na reprezentację w postaci znaku i wielkości przed serializacji go do pliku. Dane w pliku jest następnie deserializacji i przypisane do nowego <xref:System.Numerics.BigInteger> obiektu.  
  
 [!code-csharp[System.Numerics.BigInteger.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Abs(System.SByte)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Add (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Add(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Add(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do dodania.</param>
        <param name="right">Druga wartość do dodania.</param>
        <summary>Dodaje dwa <see cref="T:System.Numerics.BigInteger" /> wartości i zwraca wynik.</summary>
        <returns>Suma <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można używać języków, które nie obsługują przeciążanie operatora lub niestandardowych operatorów <xref:System.Numerics.BigInteger.Add%2A> metodę w celu dodania przy użyciu <xref:System.Numerics.BigInteger> wartości.  
  
 <xref:System.Numerics.BigInteger.Add%2A> Metoda jest przydatna zastępują operator dodawania podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> zmiennej, przypisując go sum, który jest wynikiem dodawania, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (left As BigInteger, right As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Compare : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.Compare (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Porównuje dwa <see cref="T:System.Numerics.BigInteger" /> wartości i zwraca liczbę całkowitą, która wskazuje, czy pierwsza wartość jest mniejsza, równa lub większa niż wartość drugiego.</summary>
        <returns>Liczba całkowita wskazująca wartości względne <paramref name="left" /> i <paramref name="right" />, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość </term><description> warunek </description></listheader><item><term> mniejsza niż zero </term><description><paramref name="left" /> jest mniejsza niż <paramref name="right" />.  </description></item><item><term> Zero </term><description><paramref name="left" /> jest równa <paramref name="right" />.  </description></item><item><term> Większa od zera </term><description><paramref name="left" /> jest większa niż <paramref name="right" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że <xref:System.Numerics.BigInteger> typ ma zakres stałych nie porównania <xref:System.Numerics.BigInteger> wartości nie charakteryzują się brak dokładności, który charakteryzuje porównanie liczb zmiennoprzecinkowych. W poniższym przykładzie porównano dwa <xref:System.Numerics.BigInteger> wartości, które różnią się jednym i że każdy ma 1,896 cyfr. <xref:System.Numerics.BigInteger.Compare%2A> Metoda zgłasza poprawnie, dwie wartości nie są równe.  
  
 [!code-csharp[System.Numerics.BigInteger.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/cs/Compare1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/vb/Compare1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.CompareTo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Porównuje wartość tego wystąpienia przy użyciu innej wartości i zwraca wartość całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejsza, równa lub większa od innych wartości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As Long) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(long other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : int64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">64-bitowej liczby całkowitej ze znakiem do porównania.</param>
        <summary>Porównuje to wystąpienie całkowita 64-bitowa i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejsza, równa lub większa niż wartość całkowita 64-bitowa.</summary>
        <returns>Wartość liczby całkowitej ze znakiem, która określa relację tego wystąpienia <paramref name="other" />, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość zwracana </term><description> opis </description></listheader><item><term> mniejsza niż zero </term><description> bieżące wystąpienie jest mniejsza niż <paramref name="other" />.  </description></item><item><term> Zero </term><description> bieżące wystąpienie jest równe <paramref name="other" />.  </description></item><item><term> Większa od zera </term><description> bieżącego wystąpienia jest większy niż <paramref name="other" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `other` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość przy <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> metoda jest wywoływana.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wyniku wywołania metody <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> metody za pomocą wartości całkowitych.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#3)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : System.Numerics.BigInteger -&gt; int&#xA;override this.CompareTo : System.Numerics.BigInteger -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt do porównania.</param>
        <summary>Porównuje to wystąpienie sekundy <see cref="T:System.Numerics.BigInteger" /> i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejsza, równa lub większa niż wartość określonego obiektu.</summary>
        <returns>Wartość liczby całkowitej ze znakiem, która określa relację tego wystąpienia <paramref name="other" />, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość zwracana </term><description> opis </description></listheader><item><term> mniejsza niż zero </term><description> bieżące wystąpienie jest mniejsza niż <paramref name="other" />.  </description></item><item><term> Zero </term><description> bieżące wystąpienie jest równe <paramref name="other" />.  </description></item><item><term> Większa od zera </term><description> bieżącego wystąpienia jest większy niż <paramref name="other" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie <xref:System.Numerics.BigInteger.CompareTo%2A> implementuje metodę <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> metody. Jest używana przez obiekty kolekcji ogólnej w celu uporządkowania elementów w kolekcji.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29> metody, aby uporządkować listę `StarInfo` obiektów. Każdy `StarInfo` obiektu zawiera informacje dotyczące Star oraz jego odległości od ziemi w milach. `StarInfo` implementuje <xref:System.IComparable%601> interfejsu, co pozwoli `StarInfo` obiekty, które mają być sortowane według klasy kolekcji rodzajowej. Jego <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> implementacji jest po prostu zawija wywołanie do <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#1)]  
  
 Poniższy kod tworzy następnie cztery `StarInfo` obiekty i przechowuje je w ogólnej metodzie <xref:System.Collections.Generic.List%601> obiektu. Po <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> metoda jest wywoływana, `StarInfo` obiekty są wyświetlane w kolejności ich odległości od ziemi.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="bigInteger.CompareTo obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania.</param>
        <summary>Porównuje to wystąpienie określonego obiektu i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejsza, równa lub większa niż wartość określonego obiektu.</summary>
        <returns>Liczba całkowita wskazująca relację bieżącego wystąpienia do <paramref name="obj" /> parametru, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość zwracana </term><description> opis </description></listheader><item><term> mniejsza niż zero </term><description> bieżące wystąpienie jest mniejsza niż <paramref name="obj" />.  </description></item><item><term> Zero </term><description> bieżące wystąpienie jest równe <paramref name="obj" />.  </description></item><item><term> Większa od zera </term><description> bieżącego wystąpienia jest większy niż <paramref name="obj" />, lub <paramref name="obj" /> parametr <see langword="null" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie <xref:System.Numerics.BigInteger.CompareTo%2A> implementuje metodę <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType> metody. Jest używana przez obiekty nieogólna kolekcja w celu uporządkowania elementów w kolekcji.  
  
 `obj` Parametr musi mieć jedną z następujących czynności:  
  
-   Obiekt o typie środowiska wykonawczego <xref:System.Numerics.BigInteger>.  
  
-   <xref:System.Object> Zmienna, której wartość jest `null`. Jeśli wartość `obj` parametr jest `null`, metoda zwraca wartość 1, co wskazuje, czy bieżące wystąpienie jest większa niż `obj`.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> metodę, aby porównać <xref:System.Numerics.BigInteger> wartość, przy czym każdy element w tablicy obiektu  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="obj" /> nie jest <see cref="T:System.Numerics.BigInteger" />.</exception>
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As ULong) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : uint64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">64-bitowa liczba całkowita bez znaku do porównania.</param>
        <summary>Porównuje to wystąpienie na liczbę całkowitą bez znaku 64-bitowych i zwraca wartość całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejsza, równa lub większa niż wartość Liczba całkowita bez znaku 64-bitowych.</summary>
        <returns>Liczby całkowitej ze znakiem, która wskazuje względną wartość tego wystąpienia i <paramref name="other" />, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość zwracana </term><description> opis </description></listheader><item><term> mniejsza niż zero </term><description> bieżące wystąpienie jest mniejsza niż <paramref name="other" />.  </description></item><item><term> Zero </term><description> bieżące wystąpienie jest równe <paramref name="other" />.  </description></item><item><term> Większa od zera </term><description> bieżącego wystąpienia jest większy niż <paramref name="other" />.  </description></item></list></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Divide (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Divide(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Divide(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Wartość do podzielenia.</param>
        <param name="divisor">Wartość do podzielenia przez.</param>
        <summary>Dzieli jedną <see cref="T:System.Numerics.BigInteger" /> wartość innym i zwraca wynik.</summary>
        <returns>Iloraz z dzielenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Divide%2A> Metoda wykonuje dzielenie liczby całkowitej; będącej wynikiem dzielenia reszta zostanie odrzucony. Aby wykonać dzielenie liczby całkowitej, zachowując przy tym resztę, należy wywołać <xref:System.Numerics.BigInteger.DivRem%2A> metody. Aby pobrać tylko resztę, należy wywołać <xref:System.Numerics.BigInteger.Remainder%2A> metody.  
  
 <xref:System.Numerics.BigInteger.Divide%2A> Metoda może być używana przez języki, które nie obsługują przeciążanie operatora. Jego zachowanie jest identyczne z dzielenia przy użyciu operator dzielenia.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę <xref:System.Numerics.BigInteger> wartości. Następnie używa każdy element jako iloraz w operacji dzielenia, który używa <xref:System.Numerics.BigInteger.Divide%2A> metoda, operator dzielenia (/) i <xref:System.Numerics.BigInteger.DivRem%2A> metody.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> to 0 (zero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger DivRem (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor, out System.Numerics.BigInteger remainder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger DivRem(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor, [out] valuetype System.Numerics.BigInteger&amp; remainder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (dividend As BigInteger, divisor As BigInteger, ByRef remainder As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger DivRem(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor, [Runtime::InteropServices::Out] System::Numerics::BigInteger % remainder);" />
      <MemberSignature Language="F#" Value="static member DivRem : System.Numerics.BigInteger * System.Numerics.BigInteger *  -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.DivRem (dividend, divisor, remainder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
        <Parameter Name="remainder" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="dividend">Wartość do podzielenia.</param>
        <param name="divisor">Wartość do podzielenia przez.</param>
        <param name="remainder">Po powrocie z tej metody zawiera <see cref="T:System.Numerics.BigInteger" /> wartość, która reprezentuje resztę z dzielenia. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Dzieli jedną <see cref="T:System.Numerics.BigInteger" /> wartość i zwraca wynik i zwraca resztę z dzielenia parametr danych wyjściowych.</summary>
        <returns>Iloraz z dzielenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia zachowanie zarówno iloraz i resztę, która wynika z dzielenia liczby całkowitej. Jeśli nie jesteś zainteresowany resztę, użyj <xref:System.Numerics.BigInteger.Divide%2A> metoda lub operator dzielenia; jeśli tylko są Państwo zainteresowani resztę, użyj <xref:System.Numerics.BigInteger.Remainder%2A> metody.  
  
 Znak zwracanego `remainder` wartość jest taka sama, jak znak `dividend` parametru.  
  
 Zachowanie <xref:System.Numerics.BigInteger.DivRem%2A> metody jest taka sama jak w przypadku <xref:System.Math.DivRem%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę <xref:System.Numerics.BigInteger> wartości. Następnie używa każdy element jako iloraz w operacji dzielenia, który używa <xref:System.Numerics.BigInteger.Divide%2A> metoda, operator dzielenia (/) i <xref:System.Numerics.BigInteger.DivRem%2A> metody.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> to 0 (zero).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy dwie wartości liczbowe są takie same.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(long other);" />
      <MemberSignature Language="F#" Value="override this.Equals : int64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">Wartość całkowita 64-bitowa do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy bieżące wystąpienie i całkowita 64-bitowa mają taką samą wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli całkowita 64-bitowa i bieżące wystąpienie ma tę samą wartość; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `other` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość po wywołaniu metody.  
  
 Aby określić relację między dwoma obiektami, a nie tylko testowanie pod kątem równości, należy wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Numerics.BigInteger> obiekt z każdym typem integralnym oprócz <xref:System.UInt64>. Następnie wywołuje <xref:System.Numerics.BigInteger.Equals%28System.Int64%29> metodę, aby porównać <xref:System.Numerics.BigInteger> wartość z oryginalnym wartość całkowitą, która została przekazana do <xref:System.Numerics.BigInteger> konstruktora. Dane wyjściowe pokazują, wartości są równe, w każdym przypadku.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals.cpp#1)]
 [!code-csharp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.BigInteger -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy bieżące wystąpienie oraz określony <see cref="T:System.Numerics.BigInteger" /> obiekt ma taką samą wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli ten <see cref="T:System.Numerics.BigInteger" /> obiektu i <paramref name="other" /> mają taką samą wartość; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda implementuje <xref:System.IEquatable%601> interfejs i wykonuje nieco lepiej niż <xref:System.Numerics.BigInteger.Equals%28System.Object%29> , ponieważ nie trzeba przekonwertować `other` parametr <xref:System.Numerics.BigInteger> obiektu.  
  
 Aby określić relacji między tymi dwoma <xref:System.Numerics.BigInteger> obiekty zamiast tylko testowanie pod kątem równości, wywołaj <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 W poniższym przykładzie porównano przybliżony odległość kilka gwiazdy z ziemi z odległość Wskazywan Epsilon z ziemi, aby ustalić, czy są równe. W przykładzie użyto każdego przeciążenia <xref:System.Numerics.BigInteger.Equals%2A> metody do testowania pod kątem równości.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="bigInteger.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy bieżące wystąpienie oraz określony obiekt ma taką samą wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="obj" /> argument jest <see cref="T:System.Numerics.BigInteger" /> obiekt i jego wartość jest równa wartości bieżącego <see cref="T:System.Numerics.BigInteger" /> wystąpienia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `obj` argument nie jest <xref:System.Numerics.BigInteger> wartości, metoda zwraca `false`. Metoda ta zwraca `true` tylko wtedy, gdy `obj` jest <xref:System.Numerics.BigInteger> wystąpienie, którego wartość jest równa bieżącego wystąpienia.  
  
 Aby określić relację między dwoma obiektami, a nie tylko testowanie pod kątem równości, należy wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> metody.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano równoległych <xref:System.Object> i <xref:System.Numerics.BigInteger> tablic. Każdy element tablicy ma taką samą wartość jak odpowiadający mu element druga tablica. Jak wynika z w przykładzie przedstawiono wystąpienia w <xref:System.Numerics.BigInteger> tablicy jest uważany za równy instancji na listę <xref:System.Object> tablicy tylko wtedy, gdy jest on <xref:System.Numerics.BigInteger> i ich wartości są równe.  
  
 [!code-csharp[System.Numerics.BigInteger.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/Equals_Obj1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/Equals_Obj1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="override this.Equals : uint64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">64-bitowa liczba całkowita bez znaku do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy bieżące wystąpienie i liczbą całkowitą bez znaku 64-bitowych mają taką samą wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżące wystąpienie i liczba całkowita bez znaku 64-bitowych mają taką samą wartość; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić relację między dwoma obiektami, a nie tylko testowanie pod kątem równości, należy wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 W poniższym przykładzie porównano przybliżony odległość kilka gwiazdy z ziemi z odległość Wskazywan Epsilon z ziemi, aby ustalić, czy są równe. W przykładzie użyto każdego przeciążenia <xref:System.Numerics.BigInteger.Equals%2A> metody do testowania pod kątem równości.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (bool isUnsigned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(bool isUnsigned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetByteCount(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (Optional isUnsigned As Boolean = false) As Integer" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : bool -&gt; int" Usage="bigInteger.GetByteCount isUnsigned" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="bigInteger.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreatestCommonDivisor">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger GreatestCommonDivisor (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger GreatestCommonDivisor(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreatestCommonDivisor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger GreatestCommonDivisor(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member GreatestCommonDivisor : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.GreatestCommonDivisor (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość.</param>
        <param name="right">Druga wartość.</param>
        <summary>Umożliwia znalezienie największy wspólny dzielnik dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Największy wspólny dzielnik <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Największy wspólny dzielnik jest największą liczbę, w której dwa <xref:System.Numerics.BigInteger> wartości mogą zostać podzielone bez reszty powrotu.  
  
 Jeśli `left` i `right` parametry są liczbami różna od zera, metoda zawsze zwraca co najmniej wartość 1, ponieważ wszystkie numery można podzielić o 1. Jeśli albo parametru wynosi zero, metoda zwraca wartość bezwzględną parametru różna od zera. Jeśli obie wartości zero, metoda zwraca wartość zero.  
  
> [!NOTE]
>  Przetwarzanie największy wspólny dzielnik bardzo dużych wartości `left` i `right` może być bardzo czasochłonnym operacją.  
  
 Wartość zwrócona przez obiekt <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> metody zawsze jest dodatnia, niezależnie od jej znaku `left` i `right` parametrów.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wywołanie <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> metody i obsługi konieczne zawierają przydatne informacje dotyczące wyjątków <xref:System.ArgumentOutOfRangeException>. Wynik wskazuje, że największy wspólny dzielnik tych dwóch liczb wynosi 1.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#10)]
 [!code-vb[System.Numeric.BigInteger.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEven">
      <MemberSignature Language="C#" Value="public bool IsEven { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEven" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsEven" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEven As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEven { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEven : bool" Usage="System.Numerics.BigInteger.IsEven" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy wartości bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu jest liczbą parzystą.</summary>
        <value>
          <see langword="true" /> Jeśli wartość <see cref="T:System.Numerics.BigInteger" /> obiektu jest liczbą parzystą; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest funkcją wygody, która wskazuje, czy <xref:System.Numerics.BigInteger> wartość podzielny przez dwa. Jest to równoważne używając następującego wyrażenia:  
  
```csharp   
value % 2 == 0;  
```  
  
```vb  
value Mod 2 = 0  
```  
  
 Jeśli wartość bieżącego <xref:System.Numerics.BigInteger> obiekt jest <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>, zwraca właściwości `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOne">
      <MemberSignature Language="C#" Value="public bool IsOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsOne" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOne As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOne { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOne : bool" Usage="System.Numerics.BigInteger.IsOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy wartości bieżącego <see cref="T:System.Numerics.BigInteger" /> obiekt jest <see cref="P:System.Numerics.BigInteger.One" />.</summary>
        <value>
          <see langword="true" /> Jeśli wartość <see cref="T:System.Numerics.BigInteger" /> obiekt jest <see cref="P:System.Numerics.BigInteger.One" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zapewnia znacznie lepszą wydajność niż pozostałych porównań, przy użyciu jednego, takich jak `thisBigInteger.Equals(BigInteger.One)`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
      </Docs>
    </Member>
    <Member MemberName="IsPowerOfTwo">
      <MemberSignature Language="C#" Value="public bool IsPowerOfTwo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPowerOfTwo" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPowerOfTwo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPowerOfTwo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPowerOfTwo : bool" Usage="System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy wartości bieżącego <see cref="T:System.Numerics.BigInteger" /> obiekt jest potęgą liczby dwa.</summary>
        <value>
          <see langword="true" /> Jeśli wartość <see cref="T:System.Numerics.BigInteger" /> obiekt jest potęgą liczby dwa; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość określa, czy <xref:System.Numerics.BigInteger> wartość zawiera pojedynczy niezerowy bit zestawu. Oznacza to, że zwraca `true` Jeśli wartość bieżącego <xref:System.Numerics.BigInteger> obiektu ma wartość 1 (2 oznacza to,<sup>0</sup>) lub dowolnego większa potęgą liczby dwa. Zwraca `false` Jeśli wartość bieżącego <xref:System.Numerics.BigInteger> obiektu wynosi 0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsZero">
      <MemberSignature Language="C#" Value="public bool IsZero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsZero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsZero" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsZero As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsZero { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsZero : bool" Usage="System.Numerics.BigInteger.IsZero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy wartości bieżącego <see cref="T:System.Numerics.BigInteger" /> obiekt jest <see cref="P:System.Numerics.BigInteger.Zero" />.</summary>
        <value>
          <see langword="true" /> Jeśli wartość <see cref="T:System.Numerics.BigInteger" /> obiekt jest <see cref="P:System.Numerics.BigInteger.Zero" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zapewnia znacznie lepszą wydajność niż `BigInteger.Equals(BigInteger.Zero)`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość logarytmu określonej liczby.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Liczba, której logarytm ma zostać znaleziona.</param>
        <summary>Zwraca fizyczna (podstawowy <see langword="e" />) logarytmu określonej liczby.</summary>
        <returns>Fizyczna (podstawowy <see langword="e" />) logarytm <paramref name="value" />, jak pokazano w tabeli w sekcji uwag.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` Parametr jest określony jako podstawowy numer 10.  
  
 Dokładne zwracać wartość przez tę metodę jest zależny od jej znaku `value`, jak pokazano w poniższej tabeli.  
  
|Zaloguj się z `value` parametru|Wartość zwracana|  
|-------------------------------|------------------|  
|Dodatnie|Logarytm naturalny `value`; oznacza to, ln `value`, lub dziennika e`value`.|  
|Zero|<xref:System.Double.NegativeInfinity>.|  
|Ujemne|<xref:System.Double.NaN>.|  
  
 Aby obliczyć logarytm 10 z <xref:System.Numerics.BigInteger> wartość, należy wywołać <xref:System.Numerics.BigInteger.Log10%2A> metody. Aby obliczyć logarytm liczby w podstawowym innego, należy wywołać <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29> metody.  
  
 Możesz znaleźć pierwiastek kwadratowy z liczby, wywołując <xref:System.Numerics.BigInteger.Log%2A> metoda wraz z <xref:System.Math.Exp%2A?displayProperty=nameWithType> metody. Należy zauważyć, że wynik <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> Jeśli wynik jest większa niż <xref:System.Double.MaxValue?displayProperty=nameWithType>. W poniższym przykładzie oblicza pierwiastek kwadratowy z każdego elementu w tablicy <xref:System.Numerics.BigInteger> wartości.  
  
 [!code-csharp[System.Numerics.BigInteger.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.biginteger.log/cs/log1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.biginteger.log/vb/log1.vb#1)]
  
 Ta metoda odnosi się do <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> metodę pierwotnych typów liczbowych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Logarytmu naturalnego <paramref name="value" /> jest poza zakresem <see cref="T:System.Double" /> typu danych.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger, baseValue As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger * double -&gt; double" Usage="System.Numerics.BigInteger.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Liczba, której logarytm ma zostać znaleziona.</param>
        <param name="baseValue">Podstawa logarytmu.</param>
        <summary>Zwraca wartość logarytmu określonej liczby, w określonej bazie.</summary>
        <returns>Podstawa <paramref name="baseValue" /> logarytm <paramref name="value" />, jak pokazano w tabeli w sekcji uwag.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` i `baseValue` parametrów są określone jako podstawowa 10 kolejnych liczb.  
  
 Dokładne zwracają wartość metody zależy od jej znaku `value` znak i wartość `baseValue`, jak pokazano w poniższej tabeli.  
  
|`value` Parametr|`baseValue` Parametr|Wartość zwracana|  
|-----------------------|---------------------------|------------------|  
|`value` > 0|(0 < `baseValue` < 1) - lub -(`baseValue` > 1)|logbaseValue (`value`)|  
|`value` < 0|(dowolna wartość)|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(dowolna wartość)|`baseValue` < 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(dowolna wartość)|`baseValue` = <xref:System.Double.NaN?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(dowolna wartość)|`baseValue` = 1|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` = 0|0 < `baseValue` < 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 0|`baseValue` > 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 1|`baseValue` = 0|0|  
|`value` = 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|0|  
  
 Aby obliczyć logarytm 10 z <xref:System.Numerics.BigInteger> wartość, należy wywołać <xref:System.Numerics.BigInteger.Log10%2A> metody. Aby obliczyć logarytm naturalny liczby, należy wywołać <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29> metody.  
  
 Ta metoda odnosi się do <xref:System.Math.Log%2A?displayProperty=nameWithType> metodę pierwotnych typów liczbowych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">W dzienniku <paramref name="value" /> jest poza zakresem <see cref="T:System.Double" /> typu danych.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log10(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Liczba, której logarytm ma zostać znaleziona.</param>
        <summary>Zwraca logarytm 10 określoną liczbę.</summary>
        <returns>10 logarytm o <paramref name="value" />, jak pokazano w tabeli w sekcji uwag.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` Parametr jest określony jako podstawowy numer 10.  
  
 Dokładne zwracają wartość metody zależy od jej znaku `value`, jak pokazano w poniższej tabeli.  
  
|Znak parametru wartości|Wartość zwracana|  
|-----------------------------|------------------|  
|Dodatnie|Dziennik podstawowy 10 `value`; czyli log10`value`.|  
|Zero|<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.|  
|Ujemne|<xref:System.Double.NaN?displayProperty=nameWithType>.|  
  
 Aby obliczyć logarytm naturalny <xref:System.Numerics.BigInteger> wartość, należy wywołać <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metody. Aby obliczyć logarytm liczby w podstawowym innego, należy wywołać <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=nameWithType> metody.  
  
 Ta metoda odnosi się do <xref:System.Math.Log10%2A?displayProperty=nameWithType> metodę pierwotnych typów liczbowych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Dziennik podstawowy 10 <paramref name="value" /> jest poza zakresem <see cref="T:System.Double" /> typu danych.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Max (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Max(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Max(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Max : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Max (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca większy z dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>
          <paramref name="left" /> Lub <paramref name="right" /> parametru, która kwota jest większa.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odnosi się do <xref:System.Math.Max%2A?displayProperty=nameWithType> metodę pierwotnych typów liczbowych.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.Max%2A> metodę, aby wybrać największa liczba w tablicy <xref:System.Numerics.BigInteger> wartości.  
  
 [!code-csharp[System.Numerics.BigInteger.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/cs/Max1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/vb/Max1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Min (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Min(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Min(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Min : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Min (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca mniejszy z dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>
          <paramref name="left" /> Lub <paramref name="right" /> parametru, która kwota jest mniejsza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odnosi się do <xref:System.Math.Min%2A?displayProperty=nameWithType> metodę pierwotnych typów liczbowych.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.Min%2A> metodę, aby wybrać najmniejszą liczbę, tablicę <xref:System.Numerics.BigInteger> wartości.  
  
 [!code-csharp[System.Numerics.BigInteger.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/cs/Min1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/vb/Min1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="MinusOne">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger MinusOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger MinusOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.MinusOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MinusOne As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger MinusOne { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.MinusOne : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.MinusOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która reprezentuje liczbę ujemną (-1).</summary>
        <value>Liczba całkowita, którego wartość jest ujemna (-1).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.MinusOne%2A> Właściwość jest używana do porównania <xref:System.Numerics.BigInteger> wartość -1 lub -1, aby przypisać <xref:System.Numerics.BigInteger> obiektu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
      </Docs>
    </Member>
    <Member MemberName="ModPow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger ModPow (System.Numerics.BigInteger value, System.Numerics.BigInteger exponent, System.Numerics.BigInteger modulus);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger ModPow(valuetype System.Numerics.BigInteger value, valuetype System.Numerics.BigInteger exponent, valuetype System.Numerics.BigInteger modulus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModPow (value As BigInteger, exponent As BigInteger, modulus As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger ModPow(System::Numerics::BigInteger value, System::Numerics::BigInteger exponent, System::Numerics::BigInteger modulus);" />
      <MemberSignature Language="F#" Value="static member ModPow : System.Numerics.BigInteger * System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.ModPow (value, exponent, modulus)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Numerics.BigInteger" />
        <Parameter Name="modulus" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Liczbę, aby podnieść do <c>wykładnik</c> zasilania.</param>
        <param name="exponent">Wykładnik, aby podnieść <c>wartość</c> przez.</param>
        <param name="modulus">Liczba, przez którą chcesz podzielić <c>wartość</c> podniesioną do <c>wykładnik</c> zasilania.</param>
        <summary>Wykonuje dzielenie modulo na liczbę podniesioną do potęgi równej innej liczbie.</summary>
        <returns>Resztę po podzieleniu <paramref name="value" /><sup>wykładnik</sup> przez <paramref name="modulus" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ModPow%2A> Metoda oblicza następujące wyrażenie:  
  
 (baseValue ^ wykładnik) Mod modulo  
  
 Aby wykonać potęgowania na <xref:System.Numerics.BigInteger> użyć wartości bez dzielenie modulo <xref:System.Numerics.BigInteger.Pow%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono prosty ilustracja wywoływania <xref:System.Numerics.BigInteger.ModPow%2A> metody.  
  
 [!code-csharp[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/cs/ModPow1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/vb/ModPow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="modulus" /> wynosi zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="exponent" /> ma wartość ujemną.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Multiply (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Multiply(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy numer do pomnożenia.</param>
        <param name="right">Druga liczba do pomnożenia.</param>
        <summary>Zwraca iloczyn dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Iloczyn <paramref name="left" /> i <paramref name="right" /> parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Multiply%2A> Metoda jest implementowana dla języków, które nie obsługują przeciążanie operatora. Jego zachowanie jest identyczne z mnożenia przy użyciu operator mnożenia. Ponadto <xref:System.Numerics.BigInteger.Multiply%2A> metoda jest przydatna zastępują operator mnożenia, podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> zmiennej, przypisując go produktu, który jest wynikiem mnożenie, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#1)]  
  
 Jeśli to konieczne, ta metoda automatycznie wykonuje niejawnej konwersji wartości innych typów całkowitych <xref:System.Numerics.BigInteger> obiektów. Jest to zilustrowane w przykładzie w następnej sekcji, gdzie <xref:System.Numerics.BigInteger.Multiply%2A> metoda przechodzi przez dwa <xref:System.Int64> wartości.  
  
   
  
## Examples  
 Poniższy przykład próbuje wykonać mnożenie przy użyciu dwóch długich liczb całkowitych. Ponieważ w wyniku przekracza zakres długich liczb całkowitych <xref:System.OverflowException> jest generowany i <xref:System.Numerics.BigInteger.Multiply%2A> metoda jest wywoływana w celu obsługi mnożenia. Pamiętaj, że C# wymaga użycia albo `checked` — słowo kluczowe (jak w poniższym przykładzie) lub `/checked+` opcję kompilatora, aby upewnić się, wyjątek jest generowany na przepełnienie liczbowe.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#7)]
 [!code-vb[System.Numeric.BigInteger.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Negate (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Negate(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Negate(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do wskazania ujemnej.</param>
        <summary>Neguje określonego <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>Wynik <paramref name="value" /> parametru pomnożona przez wartość ujemną (-1).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Negacja uzyskuje odwrotność dodatku liczby. Odwrotne dodatku liczby jest liczbą, która generuje wartość zero, gdy jest ona dodawana do liczby.  
  
 <xref:System.Numerics.BigInteger.Negate%2A> Metoda jest implementowana dla języków, które nie obsługują operatorów niestandardowych. Jego zachowanie jest identyczne negacji przy użyciu Jednoargumentowy operator negacji. Ponadto <xref:System.Numerics.BigInteger.Negate%2A> metoda jest przydatna zastępują operator negacji podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> zmiennej, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#4)]  
  
   
  
## Examples  
 Poniższy przykład przedstawia trzy sposoby, aby odwrócić wartość <xref:System.Numerics.BigInteger> obiektu.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger One" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property One As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger One { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.One : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.One" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która reprezentuje numer jeden (1).</summary>
        <value>Obiekt, którego wartość jest jeden (1).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.One%2A> Jest zazwyczaj używana do porównania <xref:System.Numerics.BigInteger> wartość 1 lub 1, aby przypisać <xref:System.Numerics.BigInteger> obiektu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
        <altmember cref="P:System.Numerics.BigInteger.MinusOne" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Addition(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do dodania.</param>
        <param name="right">Druga wartość do dodania.</param>
        <summary>Dodaje wartości z dwóch określonych <see cref="T:System.Numerics.BigInteger" /> obiektów.</summary>
        <returns>Suma <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Addition%2A> Metoda definiuje operacja dodawania dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#12)]
 [!code-vb[System.Numeric.BigInteger.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#12)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Add%2A> metody zamiast tego.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseAnd">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &amp; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseAnd(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator And (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &amp;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &amp;&amp;&amp; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left &amp;&amp;&amp; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość.</param>
        <param name="right">Druga wartość.</param>
        <summary>Wykonuje bitową operację <see langword="And" /> operacji na dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Wynik zadania poziomu bitowego <see langword="And" /> operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> Metoda określa operatora testu koniunkcji `And` operacji <xref:System.Numerics.BigInteger> wartości. Operatora testu koniunkcji `And` operacji Ustawia wynik bitowy tylko wtedy, gdy odpowiednich bitów w `left` i `right` również są ustawione, jak pokazano w poniższej tabeli.  
  
|Bit w `left`|Bit w `right`|Bit w wyniku|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|0|  
|1|1|1|  
|0|1|0|  
  
 <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> Metoda umożliwia następującego kodu:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#1)]  
  
 <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> Metoda wykonuje operatora testu koniunkcji `And` operacji na dwóch <xref:System.Numerics.BigInteger> wartości tak, jakby były one zarówno w dwójki uzupełnienie reprezentacji z rozszerzeniem wirtualnego logowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator | (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Or (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator |(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ||| ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ||| right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość.</param>
        <param name="right">Druga wartość.</param>
        <summary>Wykonuje bitową operację <see langword="Or" /> operacji na dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Wynik zadania poziomu bitowego <see langword="Or" /> operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> Metoda określa operatora testu koniunkcji `Or` operacji <xref:System.Numerics.BigInteger> wartości. Operatora testu koniunkcji `Or` operacja służy do ustawiania wynik bitowy tylko wtedy, gdy jeden lub oba odpowiednich bitów w `left` i `right` są ustawione, jak pokazano w poniższej tabeli.  
  
|Bit w `left`|Bit w `right`|Bit w wyniku|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|1|  
|1|1|1|  
|0|1|1|  
  
 <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> Metoda umożliwia następującego kodu:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#2)]  
  
 <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> Metoda wykonuje operatora testu koniunkcji `Or` operacji na dwóch <xref:System.Numerics.BigInteger> wartości tak, jakby były one zarówno w dwójki uzupełnienie reprezentacji z rozszerzeniem wirtualnego logowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator -- (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Decrement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Decrement (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator --(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Decrement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Decrement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość, aby zmniejszyć.</param>
        <summary>Dekrementuje <see cref="T:System.Numerics.BigInteger" /> wartość o 1.</summary>
        <returns>Wartość <paramref name="value" /> parametru zmniejszona o 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Decrement%2A> Metoda definiuje operacja dekrementacji dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#17)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Subtract%2A> metody zamiast tego. Na przykład:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Operators#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#3)]  
  
 Ponieważ <xref:System.Numerics.BigInteger> obiekty są niezmienne, <xref:System.Numerics.BigInteger.op_Decrement%2A> operator tworzy nową <xref:System.Numerics.BigInteger> obiektu, którego wartość jest jeden mniejsza niż <xref:System.Numerics.BigInteger> obiektu reprezentowanego przez `value`. Oznacza to, że wielokrotne wywołania <xref:System.Numerics.BigInteger.op_Decrement%2A> może być kosztowne.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator / (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Division(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator /(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend / divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Wartość do podzielenia.</param>
        <param name="divisor">Wartość do podzielenia przez.</param>
        <summary>Dzieli określony <see cref="T:System.Numerics.BigInteger" /> wartość przez inny określony <see cref="T:System.Numerics.BigInteger" /> wartości za pomocą dzielenie liczby całkowitej.</summary>
        <returns>Całkowite wyniku podziału.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Division%2A> Metoda definiuje operacji dzielenia dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#13)]
 [!code-vb[System.Numeric.BigInteger.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#13)]  
  
 Języki, które nie obsługują operatorów niestandardowych i przeciążanie operatorów może wywołać <xref:System.Numerics.BigInteger.Divide%2A> metody zamiast tego.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy przykład tworzy tablicę <xref:System.Numerics.BigInteger> wartości. Następnie używa każdy element jako iloraz w operacji dzielenia, który używa <xref:System.Numerics.BigInteger.Divide%2A> metoda, operator dzielenia (/) i <xref:System.Numerics.BigInteger.DivRem%2A> metody.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> to 0 (zero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Equality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy dwie wartości są równe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy wartość liczby całkowitej ze znakiem długie i a <see cref="T:System.Numerics.BigInteger" /> wartości są równe.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> parametry mają taką samą wartość; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29> Metoda definiuje operacji porównania równości dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Operators#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#4)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> metodę wystąpienia, zamiast tego.  
  
 Jeśli `left` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość, gdy operacja jest wykonywana.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartości i wartości liczby całkowitej ze znakiem długie są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> parametry mają taką samą wartość; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29> Metoda definiuje operacji porównania równości dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Operators#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#5)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> metodę wystąpienia, zamiast tego.  
  
 Jeśli `right` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość, gdy operacja jest wykonywana.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy wartości dwóch <see cref="T:System.Numerics.BigInteger" /> obiekty są sobie równe.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> parametry mają taką samą wartość; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> Metoda definiuje operacji operatora równości dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#19)]
 [!code-vb[System.Numeric.BigInteger.Class#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#19)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metodę wystąpienia, zamiast tego.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.Equals" />
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartości i niepodpisane długa liczba całkowita wartości są równe.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> parametry mają taką samą wartość; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29> Metoda definiuje operacji porównania równości dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Operators#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#6)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> metodę wystąpienia, zamiast tego.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy wartością niepodpisane długa liczba całkowita, a jeśli tak, to a <see cref="T:System.Numerics.BigInteger" /> wartości są równe.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> parametry mają taką samą wartość; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29> Metoda definiuje operacji porównania równości dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#7)]
 [!code-vb[System.Numerics.BigInteger.Operators#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#7)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> metodę wystąpienia, zamiast tego.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ^ (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_ExclusiveOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Xor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ^(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ^^^ ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ^^^ right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość.</param>
        <param name="right">Druga wartość.</param>
        <summary>Wykonuje wyłączny sumy bitowej <see langword="Or" /> (<see langword="XOr" />) operacja na dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Wynik zadania poziomu bitowego <see langword="Or" /> operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wynik wyłączny sumy bitowej `Or` operacji `true` w przypadku różnych; w przeciwnym razie wartości dwa bity jest `false`. W poniższej tabeli przedstawiono jedynego `Or` operacji.  
  
|Bit x `left`|Bit x `right`|Wartość zwracana|  
|---------------------|----------------------|------------------|  
|0|0|0|  
|0|1|1|  
|1|0|1|  
|1|1|0|  
  
 <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> Metoda umożliwia następującego kodu:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#8)]
 [!code-vb[System.Numerics.BigInteger.Operators#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#8)]  
  
 <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> Metoda wykonuje wyłączny sumy bitowej `Or` operacji na dwóch <xref:System.Numerics.BigInteger> wartości tak, jakby były one zarówno w dwójki uzupełnienie reprezentacji z rozszerzeniem wirtualnego logowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiuje jawnej konwersji między <see cref="T:System.Numerics.BigInteger" /> obiektu i innego typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Decimal" /> obiekt <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie części ułamkowej `value` parametr został obcięty przed dokonaniem konwersji.

 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt. Ponieważ konwersja z <xref:System.Decimal> do <xref:System.Numerics.BigInteger> może obejmować obcinanie dowolnej części ułamkowej `value`, Kompilatory języka automatycznie nie wykonuj tę konwersję. Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` w języku Visual Basic) jest używany. W przeciwnym razie są wyświetlane błędu kompilatora.   

 W przypadku języków, które nie obsługują operatorów niestandardowych jest alternatywną metodą <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29?displayProperty=nameWithType>.


## Examples
 Poniższy przykład konwertuje poszczególnych elementów w tablicy <xref:System.Decimal> wartości <xref:System.Numerics.BigInteger> obiektów, a następnie wyświetla wynik każdego konwersji. Należy pamiętać, że wszelkie ułamkową część <xref:System.Decimal> wartość zostanie obcięta podczas konwersji.   

 [!code-csharp[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#1)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Double) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(double value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : double -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Double" /> wartość <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie części ułamkowej `value` parametr został obcięty przed dokonaniem konwersji.

 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt. Ponieważ konwersja z <xref:System.Double> do <xref:System.Numerics.BigInteger> może obejmować obcinanie dowolnej części ułamkowej `value`, Kompilatory języka automatycznie nie wykonuj tę konwersję. Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` w języku Visual Basic) jest używany. W przeciwnym razie są wyświetlane błędu kompilatora.

 W przypadku języków, które nie obsługują operatorów niestandardowych jest alternatywną metodą <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29?displayProperty=nameWithType>.


## Examples
 Poniższy przykład konwertuje poszczególnych elementów w tablicy <xref:System.Double> wartości <xref:System.Numerics.BigInteger> obiektów, a następnie wyświetla wynik każdego konwersji. Należy pamiętać, że wszelkie ułamkową część <xref:System.Double> wartość zostanie obcięta podczas konwersji.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#2)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#2)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość <paramref name="value" /> jest <see cref="F:System.Double.NaN" />.  - lub - wartość <paramref name="value" /> jest <see cref="F:System.Double.PositiveInfinity" />.
 - lub - wartość <paramref name="value" /> jest <see cref="F:System.Double.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator byte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Byte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; byte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Byte" />.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu do wartości bajtu bez znaku.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt. Kompilatory języka nie wykonać tę konwersję automatycznie, ponieważ może pociągać za sobą utratę danych. Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CByte` w języku Visual Basic) jest używany. W przeciwnym razie są wyświetlane błędu kompilatora.   

 Ponieważ ta operacja definiuje konwersją zawężającą, może ona zgłosić <xref:System.OverflowException> w czasie wykonywania przypadku <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Byte> typu danych. Bez utraty dokładności w wynikowym <xref:System.Byte> wartość, jeśli konwersja zakończy się pomyślnie.

## Examples
 W poniższym przykładzie pokazano konwersji <xref:System.Numerics.BigInteger> do <xref:System.Byte> wartości. Umożliwia on również obsługę <xref:System.OverflowException> , jest generowany, ponieważ <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Byte> typu danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#1)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.Byte.MinValue" />.  - lub - wartość <paramref name="value" /> jest większa niż <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; decimal" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Decimal" />.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiekt <see cref="T:System.Decimal" /> wartość.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt. Kompilatory języka nie wykonać tę konwersję automatycznie, ponieważ może pociągać za sobą utratę danych. Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CDec` w języku Visual Basic) jest używany.   

 Ponieważ ta operacja definiuje konwersją zawężającą, może ona zgłosić <xref:System.OverflowException> w czasie wykonywania przypadku <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Decimal> typu danych. 

## Examples
 W poniższym przykładzie pokazano konwersji <xref:System.Numerics.BigInteger> do <xref:System.Decimal> wartości. Umożliwia on również obsługę <xref:System.OverflowException> , jest generowany, ponieważ <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Decimal> typu danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.Decimal.MinValue" />.  - lub - wartość <paramref name="value" /> jest większa niż <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator double(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Double" />.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiekt <see cref="T:System.Double" /> wartość.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt. Kompilatory języka nie wykonać tę konwersję automatycznie, ponieważ może pociągać za sobą utratę danych. Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CDbl` w języku Visual Basic) jest używany.   

 Ponieważ <xref:System.Numerics.BigInteger> wartość może być poza zakresem <xref:System.Double> typ danych, ta operacja jest konwersją zawężającą. Jeśli konwersja nie powiedzie się, nie zostanie zgłoszony <xref:System.OverflowException>. Zamiast tego Jeśli <xref:System.Numerics.BigInteger> wartość jest mniejsza niż <xref:System.Double.MinValue?displayProperty=nameWithType>, wynikowy <xref:System.Double> wartość <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>. Jeśli <xref:System.Numerics.BigInteger> wartość jest większa niż <xref:System.Double.MaxValue?displayProperty=nameWithType>, wynikowy <xref:System.Double> wartość <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.
 
 Konwersja <xref:System.Numerics.BigInteger> do <xref:System.Double> może pociągać za sobą utratę dokładności. W niektórych przypadkach utratę dokładności może spowodować operacji rzutowania lub konwersja powiedzie się nawet wtedy, gdy <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Double> typu danych. Poniższy przykład stanowi ilustrację. Przypisuje wartość maksymalna <xref:System.Double> dwóch <xref:System.Numerics.BigInteger> zmiennych, w przyrostach co <xref:System.Numerics.BigInteger> zmiennej 9.999e291 i testuje dwie zmienne pod kątem równości. Zgodnie z oczekiwaniami, wywołanie <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metoda ma pokazać, że są nierówne. Jednak konwersja większy <xref:System.Numerics.BigInteger> wartość z powrotem na <xref:System.Double> zakończy się powodzeniem, mimo że <xref:System.Numerics.BigInteger> teraz przekracza wartość <xref:System.Double.MaxValue?displayProperty=nameWithType>.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#4)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#4)]   



## Examples
 W poniższym przykładzie pokazano konwersji <xref:System.Numerics.BigInteger> do <xref:System.Double> wartości.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator short (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator short(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na całkowita 16-bitowych.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiekt do 16-bitową liczbę całkowitą.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt. Kompilatory języka nie wykonać tę konwersję automatycznie, ponieważ może pociągać za sobą utratę danych. Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CShort` w języku Visual Basic) jest używany. W przeciwnym razie są wyświetlane błędu kompilatora.   

 Ponieważ ta operacja definiuje konwersją zawężającą, może ona zgłosić <xref:System.OverflowException> w czasie wykonywania przypadku <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Int16> typu danych. Bez utraty dokładności w wynikowym <xref:System.Int16> wartość, jeśli konwersja zakończy się pomyślnie.

## Examples
 W poniższym przykładzie pokazano konwersji <xref:System.Numerics.BigInteger> do <xref:System.Int16> wartości. Umożliwia on również obsługę <xref:System.OverflowException> , jest generowany, ponieważ <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Int16> typu danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#4)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.Int16.MinValue" />.  - lub - wartość <paramref name="value" /> jest większa niż <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na całkowita 32-bitowych.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu do wartości liczby całkowitej ze znakiem 32-bitowych.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt. Kompilatory języka nie wykonać tę konwersję automatycznie, ponieważ może pociągać za sobą utratę danych. Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CInt` w języku Visual Basic) jest używany. W przeciwnym razie są wyświetlane błędu kompilatora.   

 Ponieważ ta operacja definiuje konwersją zawężającą, może ona zgłosić <xref:System.OverflowException> w czasie wykonywania przypadku <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Int32> typu danych. Bez utraty dokładności w wynikowym <xref:System.Int16> wartość, jeśli konwersja zakończy się pomyślnie.

## Examples
 W poniższym przykładzie pokazano konwersji <xref:System.Numerics.BigInteger> do <xref:System.Int32> wartości. Umożliwia on również obsługę <xref:System.OverflowException> , jest generowany, ponieważ <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Int32> typu danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#5)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.Int32.MinValue" />.  - lub - wartość <paramref name="value" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na całkowita 64-bitowych.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu na wartość 64-bitową.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt. Kompilatory języka nie wykonać tę konwersję automatycznie, ponieważ może pociągać za sobą utratę danych. Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CLng` w języku Visual Basic) jest używany. W przeciwnym razie są wyświetlane błędu kompilatora.  

 Ponieważ ta operacja definiuje konwersją zawężającą, może ona zgłosić <xref:System.OverflowException> w czasie wykonywania przypadku <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Int64> typu danych. 

## Examples
 W poniższym przykładzie pokazano konwersji <xref:System.Numerics.BigInteger> do <xref:System.Int64> wartości. Umożliwia on również obsługę <xref:System.OverflowException> , jest generowany, ponieważ <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Int64> typu danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#6)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.Int64.MinValue" />.  - lub - wartość <paramref name="value" /> jest większa niż <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator sbyte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::SByte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; sbyte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na wartość ze znakiem 8-bitowych.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu podpisem wartości 8-bitowych.  Ten interfejs API nie jest zgodny ze specyfikacją CLS. Alternatywa zgodna ze standardem jest <see cref="T:System.Int16" />.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt. Kompilatory języka nie wykonać tę konwersję automatycznie, ponieważ może pociągać za sobą utratę danych. Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CSByte` w języku Visual Basic) jest używany. W przeciwnym razie są wyświetlane błędu kompilatora.  

 Ponieważ ta operacja definiuje konwersją zawężającą, może ona zgłosić <xref:System.OverflowException> w czasie wykonywania przypadku <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.SByte> typu danych. Bez utraty dokładności w wynikowym <xref:System.SByte> wartość, jeśli konwersja zakończy się pomyślnie.

## Examples
 W poniższym przykładzie pokazano konwersji <xref:System.Numerics.BigInteger> do <xref:System.SByte> wartości. Umożliwia on również obsługę <xref:System.OverflowException> , jest generowany, ponieważ <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.SByte> typu danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#7)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.SByte.MinValue" />.  - lub - wartość <paramref name="value" /> jest większa niż <see cref="F:System.SByte.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator float(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; single" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na wartość zmiennoprzecinkową pojedynczej precyzji.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu na wartość zmiennoprzecinkową pojedynczej precyzji.</summary>
        <returns>Obiekt, który zawiera najbliższego możliwa reprezentacja <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt. Kompilatory języka nie wykonać tę konwersję automatycznie, ponieważ może obejmować, utraty danych lub utratę dokładności. Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CSng` w języku Visual Basic) jest używany. W przeciwnym razie są wyświetlane błędu kompilatora.    

 Ponieważ <xref:System.Numerics.BigInteger> wartość może być poza zakresem <xref:System.Single> typ danych, ta operacja jest konwersją zawężającą. Jeśli konwersja nie powiedzie się, nie zostanie zgłoszony <xref:System.OverflowException>. Zamiast tego Jeśli <xref:System.Numerics.BigInteger> wartość jest mniejsza niż <xref:System.Single.MinValue?displayProperty=nameWithType>, wynikowy <xref:System.Single> wartość <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>. Jeśli <xref:System.Numerics.BigInteger> wartość jest większa niż <xref:System.Single.MaxValue?displayProperty=nameWithType>, wynikowy <xref:System.Single> wartość <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>.

 Konwersja <xref:System.Numerics.BigInteger> do <xref:System.Single> może pociągać za sobą utratę dokładności. W niektórych przypadkach utratę dokładności może spowodować operacji rzutowania lub konwersja powiedzie się nawet wtedy, gdy <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Single> typu danych. Poniższy przykład stanowi ilustrację. Przypisuje wartość maksymalna <xref:System.Single> dwóch <xref:System.Numerics.BigInteger> zmiennych, w przyrostach co <xref:System.Numerics.BigInteger> zmiennej 9.999e291 i testuje dwie zmienne pod kątem równości. Zgodnie z oczekiwaniami, wywołanie <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metoda ma pokazać, że są nierówne. Jednak konwersja większy <xref:System.Numerics.BigInteger> wartość z powrotem na <xref:System.Single> zakończy się powodzeniem, mimo że <xref:System.Numerics.BigInteger> teraz przekracza wartość <xref:System.Single.MaxValue?displayProperty=nameWithType>.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#5)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#5)]   



## Examples
 W poniższym przykładzie pokazano konwersji <xref:System.Numerics.BigInteger> do <xref:System.Single> wartości.   
     
 [!code-csharp[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ushort (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt16(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę całkowitą bez znaku 16-bitowych.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu nieoznaczoną 16-bitową wartość całkowitą.  Ten interfejs API nie jest zgodny ze specyfikacją CLS. Alternatywa zgodna ze standardem jest <see cref="T:System.Int32" />.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt. Kompilatory języka nie wykonać tę konwersję automatycznie, ponieważ może pociągać za sobą utratę danych. Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CUShort` w języku Visual Basic) jest używany. W przeciwnym razie są wyświetlane błędu kompilatora.    

 Ponieważ ta operacja definiuje konwersją zawężającą, może ona zgłosić <xref:System.OverflowException> w czasie wykonywania przypadku <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.UInt16> typu danych. Bez utraty dokładności w wynikowym <xref:System.UInt16> wartość, jeśli konwersja zakończy się pomyślnie.

## Examples
 W poniższym przykładzie pokazano konwersji <xref:System.Numerics.BigInteger> do <xref:System.UInt16> wartości. Umożliwia on również obsługę <xref:System.OverflowException> , jest generowany, ponieważ <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.UInt16> typu danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#9)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#9)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.UInt16.MinValue" />.  - lub - wartość <paramref name="value" /> jest większa niż <see cref="F:System.UInt16.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt32(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint32" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę całkowitą bez znaku 32-bitowych.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu nieoznaczoną 32-bitowa wartość całkowitą.  Ten interfejs API nie jest zgodny ze specyfikacją CLS. Alternatywa zgodna ze standardem jest <see cref="T:System.Int64" />.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt. Kompilatory języka nie wykonać tę konwersję automatycznie, ponieważ może pociągać za sobą utratę danych. Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CUInt` w języku Visual Basic) jest używany. W przeciwnym razie są wyświetlane błędu kompilatora.    

 Ponieważ ta operacja definiuje konwersją zawężającą, może ona zgłosić <xref:System.OverflowException> w czasie wykonywania przypadku <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.UInt32> typu danych. Bez utraty dokładności w wynikowym <xref:System.UInt32> wartość, jeśli konwersja zakończy się pomyślnie.

## Examples
 W poniższym przykładzie pokazano konwersji <xref:System.Numerics.BigInteger> do <xref:System.UInt32> wartości. Umożliwia on również obsługę <xref:System.OverflowException> , jest generowany, ponieważ <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.UInt32> typu danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#10)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#10)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.UInt32.MinValue" />.  - lub - wartość <paramref name="value" /> jest większa niż <see cref="F:System.UInt32.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt64(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę całkowitą bez znaku 64-bitowych.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu na nieoznaczoną 64-bitowych wartość całkowitą.  Ten interfejs API nie jest zgodny ze specyfikacją CLS. Alternatywa zgodna ze standardem jest <see cref="T:System.Double" />.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt. Kompilatory języka nie wykonać tę konwersję automatycznie, ponieważ może pociągać za sobą utratę danych. Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CULng` w języku Visual Basic) jest używany. W przeciwnym razie są wyświetlane błędu kompilatora.    

 Ponieważ ta operacja definiuje konwersją zawężającą, może ona zgłosić <xref:System.OverflowException> w czasie wykonywania przypadku <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.UInt64> typu danych. Bez utraty dokładności w wynikowym <xref:System.UInt64> wartość, jeśli konwersja zakończy się pomyślnie.

## Examples
 W poniższym przykładzie pokazano konwersji <xref:System.Numerics.BigInteger> do <xref:System.UInt64> wartości. Umożliwia on również obsługę <xref:System.OverflowException> , jest generowany, ponieważ <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.UInt64> typu danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#11)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#11)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.UInt64.MinValue" />.  - lub - wartość <paramref name="value" /> jest większa niż <see cref="F:System.UInt64.MaxValue" />.</exception>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Single) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(float value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : single -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Single" /> wartość <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie części ułamkowej `value` parametr został obcięty przed dokonaniem konwersji.
 
 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt. Ponieważ konwersja z <xref:System.Single> do <xref:System.Numerics.BigInteger> może obejmować obcinanie dowolnej części ułamkowej `value`, Kompilatory języka automatycznie nie wykonuj tę konwersję. Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` w języku Visual Basic) jest używany. W przeciwnym razie są wyświetlane błędu kompilatora.

 W przypadku języków, które nie obsługują operatorów niestandardowych jest alternatywną metodą <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29?displayProperty=nameWithType>.


## Examples
 Poniższy przykład konwertuje poszczególnych elementów w tablicy <xref:System.Single> wartości <xref:System.Numerics.BigInteger> obiektów, a następnie wyświetla wynik każdego konwersji. Należy pamiętać, że wszelkie ułamkową część <xref:System.Single> wartość zostanie obcięta podczas konwersji.
 
 [!code-csharp[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#3)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#3)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość <paramref name="value" /> jest <see cref="F:System.Single.NaN" />.  - lub - wartość <paramref name="value" /> jest <see cref="F:System.Single.PositiveInfinity" />.
 - lub - wartość <paramref name="value" /> jest <see cref="F:System.Single.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy określona wartość jest większy niż inny określona wartość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy całkowita 64-bitowych jest większy niż <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Metoda definiuje działania wyższa niż operator <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#9)]
 [!code-vb[System.Numerics.BigInteger.Operators#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#9)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodę wystąpienia, zamiast tego. Niektóre języki można również wywołać <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29> metoda bezpośrednio w poniższym przykładzie pokazano.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#10)]  
  
 Jeśli `left` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość, gdy operacja jest wykonywana.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> jest większa niż wartość 64-bitową.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Metoda definiuje działania wyższa niż operator <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#11)]
 [!code-vb[System.Numerics.BigInteger.Operators#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#11)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego. Niektóre języki można również wywołać <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29> metoda bezpośrednio w poniższym przykładzie pokazano.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#12)]  
  
 Jeśli `right` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość, gdy operacja jest wykonywana.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa niż inny <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Metoda definiuje działania wyższa niż operator <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#20)]
 [!code-vb[System.Numeric.BigInteger.Class#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#20)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType> metody zamiast tego. Można również wywołać <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metoda bezpośrednio w poniższym przykładzie pokazano.  
  
 [!code-vb[System.Numeric.BigInteger.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#21)]  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa niż 64-bitowej nieoznaczonej liczby całkowitej.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Metoda definiuje działania wyższa niż operator <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#13)]
 [!code-vb[System.Numerics.BigInteger.Operators#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#13)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego. Niektóre języki można również wywołać <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> metoda bezpośrednio w poniższym przykładzie pokazano.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa niż 64-bitowej nieoznaczonej liczby całkowitej.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Metoda definiuje działania wyższa niż operator <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#15)]
 [!code-vb[System.Numerics.BigInteger.Operators#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#15)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego. Niektóre języki można również wywołać <xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> metoda bezpośrednio w poniższym przykładzie pokazano.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy określona wartość jest większa niż lub równe drugiemu określona wartość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy całkowita 64-bitowych jest większa niż lub równa <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Metoda definiuje działania większa lub równa operator <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#17)]
 [!code-vb[System.Numerics.BigInteger.Operators#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#17)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego. Niektóre języki można również wywołać <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> metoda bezpośrednio w poniższym przykładzie pokazano.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#18)]  
  
 Jeśli `left` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość, gdy operacja jest wykonywana.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa niż lub równa wartości liczby całkowitej ze znakiem 64-bitowych.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Metoda definiuje działania większa lub równa operator <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#19)]
 [!code-vb[System.Numerics.BigInteger.Operators#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#19)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego. Niektóre języki można również wywołać <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> metoda bezpośrednio w poniższym przykładzie pokazano.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#20)]  
  
 Jeśli `right` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość, gdy operacja jest wykonywana.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa niż lub równy innemu <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Metoda definiuje działania większa lub równa operator <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#22)]
 [!code-vb[System.Numeric.BigInteger.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#22)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> metody zamiast tego. Niektóre języki można również wywołać <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metoda bezpośrednio w poniższym przykładzie pokazano.  
  
 [!code-vb[System.Numeric.BigInteger.Class#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#23)]  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa niż lub równa wartości 64-bitowej nieoznaczonej liczby całkowitej.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Metoda definiuje działania większa lub równa operator <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#21)]
 [!code-vb[System.Numerics.BigInteger.Operators#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#21)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego. Niektóre języki można również wywołać <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> metoda bezpośrednio w poniższym przykładzie pokazano.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#22)]  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy 64-bitowa liczba całkowita bez znaku jest większa niż lub równa <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Metoda definiuje działania większa lub równa operator <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#23)]
 [!code-vb[System.Numerics.BigInteger.Operators#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#23)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego. Niektóre języki można również wywołać <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> metoda bezpośrednio w poniższym przykładzie pokazano.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#24)]  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiuje niejawna konwersja między <see cref="T:System.Numerics.BigInteger" /> obiektu i innego typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje niejawnej konwersji wartości bajtu bez znaku do <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie części ułamkowej `value` parametr został obcięty przed dokonaniem konwersji.

 W przypadku języków, które nie obsługują niejawne operatory jest alternatywną metodą <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Przeciążenia <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody definiowania typów, do którego lub które kompilator może automatycznie konwertować <xref:System.Numerics.BigInteger> wartości bez jawnego operatora rzutowania (w języku C#) lub wywołać funkcję konwersji (w języku Visual Basic). Są one poszerzeniem konwersji, nie obejmują strat danych, które nie zgłaszają wyjątków <xref:System.OverflowException>. To przeciążenie umożliwia kompilatorowi obsługi konwersji z <xref:System.Byte> wartość <xref:System.Numerics.BigInteger> wartość, jak w poniższym przykładzie pokazano.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje niejawną konwersję podpisem 16-bitową liczbę całkowitą do <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku języków, które nie obsługują niejawne operatory jest alternatywną metodą <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Przeciążenia <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody definiowania typów, do którego lub które kompilator może automatycznie konwertować <xref:System.Numerics.BigInteger> wartości bez jawnego operatora rzutowania (w języku C#) lub wywołać funkcję konwersji (w języku Visual Basic). Są one poszerzeniem konwersji, nie obejmują strat danych, które nie zgłaszają wyjątków <xref:System.OverflowException>. To przeciążenie umożliwia kompilatorowi obsługi konwersji z <xref:System.Int16> wartość <xref:System.Numerics.BigInteger> wartość, jak w poniższym przykładzie pokazano.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#2)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje niejawną konwersję całkowita 32-bitowego do <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku języków, które nie obsługują niejawne operatory jest alternatywną metodą <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.  

 Przeciążenia <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody definiowania typów, do którego lub które kompilator może automatycznie konwertować <xref:System.Numerics.BigInteger> wartości bez jawnego operatora rzutowania (w języku C#) lub wywołać funkcję konwersji (w języku Visual Basic). Są one poszerzeniem konwersji, nie obejmują strat danych, które nie zgłaszają wyjątków <xref:System.OverflowException>. To przeciążenie umożliwia kompilatorowi obsługi konwersji z <xref:System.Int32> wartość <xref:System.Numerics.BigInteger> wartość, jak w poniższym przykładzie pokazano.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje niejawną konwersję całkowita 64-bitowego do <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku języków, które nie obsługują niejawne operatory jest alternatywną metodą <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29?displayProperty=nameWithType>.   
 
 Przeciążenia <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody definiowania typów, do którego lub które kompilator może automatycznie konwertować <xref:System.Numerics.BigInteger> wartości bez jawnego operatora rzutowania (w języku C#) lub wywołać funkcję konwersji (w języku Visual Basic). Są one poszerzeniem konwersji, nie obejmują strat danych, które nie zgłaszają wyjątków <xref:System.OverflowException>. To przeciążenie umożliwia kompilatorowi obsługi konwersji z <xref:System.Int64> wartość <xref:System.Numerics.BigInteger> wartość, jak w poniższym przykładzie pokazano.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje niejawnej konwersji wartości 8-bitowa liczba całkowita podpisem do <see cref="T:System.Numerics.BigInteger" /> wartości.  Ten interfejs API nie jest zgodny ze specyfikacją CLS. Alternatywa zgodna ze standardem jest <see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku języków, które nie obsługują niejawne operatory jest alternatywną metodą <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Przeciążenia <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody definiowania typów, do którego lub które kompilator może automatycznie konwertować <xref:System.Numerics.BigInteger> wartości bez jawnego operatora rzutowania (w języku C#) lub wywołać funkcję konwersji (w języku Visual Basic). Są one poszerzeniem konwersji, nie obejmują strat danych, które nie zgłaszają wyjątków <xref:System.OverflowException>. To przeciążenie umożliwia kompilatorowi obsługi konwersji z <xref:System.SByte> wartość <xref:System.Numerics.BigInteger> wartość, jak w poniższym przykładzie pokazano.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#5)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje niejawnej konwersji wartości 16-bitowej nieoznaczonej liczby całkowitej do <see cref="T:System.Numerics.BigInteger" /> wartości.  Ten interfejs API nie jest zgodny ze specyfikacją CLS. Alternatywa zgodna ze standardem jest <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku języków, które nie obsługują niejawne operatory jest alternatywną metodą <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.   

 Przeciążenia <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody definiowania typów, do którego lub które kompilator może automatycznie konwertować <xref:System.Numerics.BigInteger> wartości bez jawnego operatora rzutowania (w języku C#) lub wywołać funkcję konwersji (w języku Visual Basic). Są one poszerzeniem konwersji, nie obejmują strat danych, które nie zgłaszają wyjątków <xref:System.OverflowException>. To przeciążenie umożliwia kompilatorowi obsługi konwersji z <xref:System.UInt16> wartość <xref:System.Numerics.BigInteger> wartość, jak w poniższym przykładzie pokazano.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#6)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje niejawna konwersja 32-bitowej nieoznaczonej liczby całkowitej do <see cref="T:System.Numerics.BigInteger" /> wartości.  Ten interfejs API nie jest zgodny ze specyfikacją CLS. Alternatywa zgodna ze standardem jest <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku języków, które nie obsługują niejawne operatory jest alternatywną metodą <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.   

 Przeciążenia <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody definiowania typów, do którego lub które kompilator może automatycznie konwertować <xref:System.Numerics.BigInteger> wartości bez jawnego operatora rzutowania (w języku C#) lub wywołać funkcję konwersji (w języku Visual Basic). Są one poszerzeniem konwersji, nie obejmują strat danych, które nie zgłaszają wyjątków <xref:System.OverflowException>. To przeciążenie umożliwia kompilatorowi obsługi konwersji z <xref:System.UInt32> wartość <xref:System.Numerics.BigInteger> wartość, jak w poniższym przykładzie pokazano.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#7)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje niejawną konwersję 64-bitowej nieoznaczonej liczby całkowitej do <see cref="T:System.Numerics.BigInteger" /> wartości.  Ten interfejs API nie jest zgodny ze specyfikacją CLS. Alternatywa zgodna ze standardem jest <see cref="T:System.Double" />.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku języków, które nie obsługują niejawne operatory jest alternatywną metodą <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29?displayProperty=nameWithType>.   

 Przeciążenia <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody definiowania typów, do którego lub które kompilator może automatycznie konwertować <xref:System.Numerics.BigInteger> wartości bez jawnego operatora rzutowania (w języku C#) lub wywołać funkcję konwersji (w języku Visual Basic). Są one poszerzeniem konwersji, nie obejmują strat danych, które nie zgłaszają wyjątków <xref:System.OverflowException>. To przeciążenie umożliwia kompilatorowi obsługi konwersji z <xref:System.UInt64> wartość <xref:System.Numerics.BigInteger> wartość, jak w poniższym przykładzie pokazano.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#8)]   

 ]]></format>
        </remarks>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ++ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Increment(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Increment (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ++(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Increment : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Increment value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zwiększenia.</param>
        <summary>Zwiększa <see cref="T:System.Numerics.BigInteger" /> wartość o 1.</summary>
        <returns>Wartość <paramref name="value" /> parametru zwiększane o 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Increment%2A> Metoda definiuje operacja zwiększenia wartości <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#24)]  
  
 Niektóre języki (takie jak Visual Basic), które nie mają operatora inkrementacji lub nie obsługują przeciążanie operatora może wywołać <xref:System.Numerics.BigInteger.op_Increment%2A> metoda bezpośrednio w poniższym przykładzie pokazano.  
  
 [!code-vb[System.Numeric.BigInteger.Class#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#25)]  
  
 Ponieważ <xref:System.Numerics.BigInteger> obiekty są niezmienne, <xref:System.Numerics.BigInteger.op_Increment%2A> operator tworzy nową <xref:System.Numerics.BigInteger> obiektu, którego wartość jest jeden więcej niż <xref:System.Numerics.BigInteger> obiektu reprezentowanego przez `value`. W związku z tym, wielokrotne wywołania <xref:System.Numerics.BigInteger.op_Increment%2A> może być kosztowne.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Inequality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy dwie wartości liczbowe nie są równe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : int64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość, która wskazuje, czy całkowita 64-bitowym a <see cref="T:System.Numerics.BigInteger" /> wartości nie są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> nie są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A> Metoda definiuje operacji operator nierówności dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#25)]
 [!code-vb[System.Numerics.BigInteger.Operators#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#25)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można sprawdzić pod kątem nierówności przy użyciu jednej z następujących technik:  
  
-   Wywoływanie <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> wystąpienia metody, która określa relację pomiędzy <xref:System.Numerics.BigInteger> i wartość podpisem liczba całkowita typu long.  
  
-   Wywoływanie <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> wystąpienia metody i cofania jej wartość.  
  
 Jeśli `left` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość, gdy operacja jest wykonywana.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * int64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość i całkowita 64-bitowe nie są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> nie są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A> Metoda definiuje operacji operator nierówności dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#26)]
 [!code-vb[System.Numerics.BigInteger.Operators#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#26)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można sprawdzić pod kątem nierówności przy użyciu jednej z następujących technik:  
  
-   Wywoływanie <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody, która określa relację pomiędzy <xref:System.Numerics.BigInteger> i wartość podpisem liczba całkowita typu long.  
  
-   Wywoływanie <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> metody i cofania jej wartość.  
  
 Jeśli `right` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość, gdy operacja jest wykonywana.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy dwa <see cref="T:System.Numerics.BigInteger" /> obiekty mają różne wartości.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> nie są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A> Metoda definiuje operacji operator nierówności dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#26)]
 [!code-vb[System.Numeric.BigInteger.Class#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#26)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można sprawdzić pod kątem nierówności przy użyciu jednej z następujących technik:  
  
-   Wywoływanie <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> metody, która określa relację między dwiema <xref:System.Numerics.BigInteger> obiektów.  
  
-   Wywoływanie <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metody i cofania jej wartość.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> nie są takie same wartości i 64-bitowej nieoznaczonej liczby całkowitej.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> nie są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A> Metoda definiuje operacji operator nierówności dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#27)]
 [!code-vb[System.Numerics.BigInteger.Operators#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#27)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można sprawdzić pod kątem nierówności przy użyciu jednej z następujących technik:  
  
-   Wywoływanie <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody, która określa relację pomiędzy <xref:System.Numerics.BigInteger> i wartość niepodpisane długa liczba całkowita.  
  
-   Wywoływanie <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> metody i cofania jej wartość.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy 64-bitowej nieoznaczonej liczby całkowitej, a jeśli tak, to a <see cref="T:System.Numerics.BigInteger" /> wartości nie są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> nie są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A> Metoda definiuje operacji operator nierówności dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#28)]
 [!code-vb[System.Numerics.BigInteger.Operators#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#28)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można sprawdzić pod kątem nierówności przy użyciu jednej z następujących technik:  
  
-   Wywoływanie <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody, która określa relację pomiędzy <xref:System.Numerics.BigInteger> i wartość niepodpisane długa liczba całkowita.  
  
-   Wywoływanie <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> metody i cofania jej wartość.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_LeftShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &lt;&lt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_LeftShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;&lt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &lt;&lt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &lt;&lt;&lt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &lt;&lt;&lt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość, w których bity są lekkie.</param>
        <param name="shift">Liczba bitów, aby przenieść <c>wartość</c> po lewej stronie.</param>
        <summary>Przesunięcia <see cref="T:System.Numerics.BigInteger" /> wartość określoną liczbę bitów w lewo.</summary>
        <returns>Wartość, która ma zostać przesunięty po lewej stronie przez określoną liczbę bitów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LeftShift%2A> Metoda definiuje operacji bitowy operator przesunięcia w lewo, aby uzyskać <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#29)]
 [!code-vb[System.Numerics.BigInteger.Operators#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#29)]  
  
> [!NOTE]
>  W odróżnieniu od bitowe operacji przesunięcia w lewo przy użyciu podstawowych całkowitą <xref:System.Numerics.BigInteger.op_LeftShift%2A> metody zachowuje znak oryginalny <xref:System.Numerics.BigInteger> wartość.  
  
 Języki, które nie obsługują operatorów niestandardowych, można wykonać operacji przesunięcia w lewo na poziomie bitowym przez pomnożenie `value` przez `BigInteger.Pow(2, shift)`. Poniższy przykład pokazuje, że wyniki są takie same jak wyniki użycia tego operatora.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#30)]
 [!code-vb[System.Numerics.BigInteger.Operators#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#30)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy określona wartość jest mniejsza niż druga określona wartość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy jest całkowita 64-bitowych, mniej niż a <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A> Metoda definiuje less than-operator dla działania <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#31)]
 [!code-vb[System.Numerics.BigInteger.Operators#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#31)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego. Niektóre języki można również wywołać <xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29> metoda bezpośrednio w poniższym przykładzie pokazano.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#32)]  
  
 Jeśli `left` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość, gdy operacja jest wykonywana.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż całkowita 64-bitowych.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A> Metoda definiuje less than-operator dla działania <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#33)]
 [!code-vb[System.Numerics.BigInteger.Operators#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#33)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego. Niektóre języki można również wywołać <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29> metoda bezpośrednio w poniższym przykładzie pokazano.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#34)]  
  
 Jeśli `right` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość, gdy operacja jest wykonywana.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejszy niż inny <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A> Metoda definiuje less than-operator dla działania <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#27)]
 [!code-vb[System.Numeric.BigInteger.Class#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#27)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> metody zamiast tego. Niektóre języki można również wywołać <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metoda bezpośrednio w poniższym przykładzie pokazano.  
  
 [!code-vb[System.Numeric.BigInteger.Class#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#28)]  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż 64-bitowej nieoznaczonej liczby całkowitej.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A> Metoda definiuje less than-operator dla działania <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#35)]
 [!code-vb[System.Numerics.BigInteger.Operators#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#35)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego. Można również wywołać <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> metoda bezpośrednio w poniższym przykładzie pokazano.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#36)]  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy jest 64-bitowej nieoznaczonej liczby całkowitej, mniej niż a <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A> Metoda definiuje less than-operator dla działania <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#37)]
 [!code-vb[System.Numerics.BigInteger.Operators#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#37)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego. Można również wywołać <xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> metoda bezpośrednio w poniższym przykładzie pokazano.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#38)]  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy określona wartość jest mniejsza niż lub równe inną określoną wartość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy całkowita 64-bitowych jest mniejsza niż lub równa <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż lub równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Metoda określa operację mniejszą lub równą operatora dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#39)]
 [!code-vb[System.Numerics.BigInteger.Operators#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#39)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego. Można również wywołać <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> metoda bezpośrednio w poniższym przykładzie pokazano.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#40)]  
  
 Jeśli `left` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość, gdy operacja jest wykonywana.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż całkowita 64-bitowych.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż lub równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Metoda określa operację mniejszą lub równą operatora dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#41)]
 [!code-vb[System.Numerics.BigInteger.Operators#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#41)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego. Można również wywołać <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> metoda bezpośrednio w poniższym przykładzie pokazano.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#42)]  
  
 Jeśli `right` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość, gdy operacja jest wykonywana.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż lub równy innemu <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż lub równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Metoda określa operację mniejszą lub równą operatora dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#29)]
 [!code-vb[System.Numeric.BigInteger.Class#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#29)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Compare%2A> metody zamiast tego. Można również wywołać <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metoda bezpośrednio w poniższym przykładzie pokazano.  
  
 [!code-vb[System.Numeric.BigInteger.Class#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#30)]  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż lub równe 64-bitowej nieoznaczonej liczby całkowitej.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż lub równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Metoda określa operację mniejszą lub równą operatora dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#43)]
 [!code-vb[System.Numerics.BigInteger.Operators#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#43)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego. Można również wywołać <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> metoda bezpośrednio w poniższym przykładzie pokazano.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#44)]  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy 64-bitowej nieoznaczonej liczby całkowitej jest mniejsza niż lub równa <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż lub równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Metoda określa operację mniejszą lub równą operatora dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#45)]
 [!code-vb[System.Numerics.BigInteger.Operators#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#45)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego. Można również wywołać <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> metoda bezpośrednio w poniższym przykładzie pokazano.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#46)]  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_Modulus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator % (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Modulus(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Mod (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator %(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( % ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend % divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Wartość do podzielenia.</param>
        <param name="divisor">Wartość do podzielenia przez.</param>
        <summary>Zwraca resztę, która wynika z podziału przy użyciu dwóch określonych <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Resztę, która wynika z podziału.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Modulus%2A> Metoda definiuje operacji operator modulo <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#31)]
 [!code-vb[System.Numeric.BigInteger.Class#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#31)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=nameWithType> metody zamiast tego.  
  
 Znak wartości zwróconej przez operacji modulo zależy od jej znaku `dividend`: Jeśli `dividend` jest dodatnia, operacji modulo zwraca wynik dodatni; Jeśli jest ujemna, Operacja modulo zwraca wynik ujemny. Zachowanie operacji modulo z <xref:System.Numerics.BigInteger> wartości jest taka sama jak operacja wyznaczania modułu przy użyciu innych typów całkowitych.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> to 0 (zero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator * (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator *(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do pomnożenia.</param>
        <param name="right">Druga wartość do pomnożenia.</param>
        <summary>Mnoży dwie określone <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Iloczyn <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Multiply%2A> Metoda definiuje operacji operator mnożenia dla <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#11)]
 [!code-vb[System.Numeric.BigInteger.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#11)]  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ~ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_OnesComplement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Not (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ~(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_OnesComplement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_OnesComplement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość całkowitą.</param>
        <summary>Zwraca operatora testu koniunkcji, jeden w uzupełniają z <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Bitowe jednego użytkownika uzupełniają z <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_OnesComplement%2A> Metoda określa operację bitowy operator dopełnienia jednostkowego dla <xref:System.Numerics.BigInteger> wartości. Bitowy operator dopełnienia jednostkowego odwraca każdy bit w wartość liczbową. Oznacza to, że usługa bits w `value` , które są 0 są ustawione na 1, w wyniku i bity, które są 1 są ustawione na 0 w wyniku. <xref:System.Numerics.BigInteger.op_OnesComplement%2A> Metoda umożliwia następującego kodu:  
  
 [!code-csharp[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/cs/OnesComplement1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/OnesComplement1.vb#1)]  
  
 Języki, które nie obsługują operatorów niestandardowych mogą mieć możliwość wywoływania <xref:System.Numerics.BigInteger.op_OnesComplement%2A> metoda bezpośrednio do wykonania bitowej, jednostkowego uzupełniają operacji. Na przykład:  
  
 [!code-vb[System.Numerics.BigInteger.OnesComplement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/onescomplement2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_RightShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &gt;&gt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_RightShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;&gt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &gt;&gt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &gt;&gt;&gt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &gt;&gt;&gt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość, w których bity są lekkie.</param>
        <param name="shift">Liczba bitów, aby przenieść <c>wartość</c> po prawej stronie.</param>
        <summary>Przesunięcia <see cref="T:System.Numerics.BigInteger" /> wartość określoną liczbę bitów w prawo.</summary>
        <returns>Wartość, która ma zostać przesunięty po prawej stronie przez określoną liczbę bitów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_RightShift%2A> Metoda definiuje operacji bitowy operator przesunięcia w prawo, aby uzyskać <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#47)]
 [!code-vb[System.Numerics.BigInteger.Operators#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#47)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wykonać operacji przesunięcia w prawo na poziomie bitowym przez podzielenie `value` przez `BigInteger.Pow(2, shift)` i odejmowanie 1 razy `shift` dla wartości ujemnych. Poniższy przykład pokazuje, że wyniki są takie same jak wyniki użycia tego operatora.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#48)]
 [!code-vb[System.Numerics.BigInteger.Operators#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#48)]  
  
 Jeśli `shift` jest większa niż lub równa liczbie bitów dodatnią <xref:System.Numerics.BigInteger> , wynik operacji przesunięcia w prawo wartość <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>. Jeśli `shift` jest większa niż liczba bitów ujemnych <xref:System.Numerics.BigInteger> , wynik operacji przesunięcia w prawo wartość <xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Subtraction(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Wartość do odjęcia od (odjemna).</param>
        <param name="right">Wartość do odjęcia (odjemnik).</param>
        <summary>Odejmuje <see cref="T:System.Numerics.BigInteger" /> wartości z innej <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>Wynik odejmowania <paramref name="right" /> z <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Subtraction%2A> Metoda definiuje operacji operator odejmowania <xref:System.Numerics.BigInteger> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#14)]
 [!code-vb[System.Numeric.BigInteger.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#14)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=nameWithType> metody zamiast tego.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryNegation(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do wskazania ujemnej.</param>
        <summary>Neguje określoną wartość duża liczba całkowita.</summary>
        <returns>Wynik <paramref name="value" /> parametru pomnożona przez wartość ujemną (-1).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_UnaryNegation%2A> Metoda określa operację Jednoargumentowy operator negacji (lub operator odwrotność dodatku) dla <xref:System.Numerics.BigInteger> wartości. Operacja generują wartość, która skutkuje 0 (zero), gdy jest ona dodawana do liczby. Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Negate%2A> metody zamiast tego.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy przykład przedstawia trzy różne sposoby, aby odwrócić wartość <xref:System.Numerics.BigInteger> obiektu.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryPlus(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~+ ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="+ value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość całkowitą.</param>
        <summary>Zwraca wartość <see cref="T:System.Numerics.BigInteger" /> operand. (Znak argumentu operacji jest bez zmian).</summary>
        <returns>Wartość <paramref name="value" /> operand.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_UnaryPlus%2A> Metoda definiuje operacji jednoargumentowej dodatnią dla <xref:System.Numerics.BigInteger> wartości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje ciąg reprezentujący liczbę na jego <see cref="T:System.Numerics.BigInteger" /> równoważne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg zawierający liczbę, którą należy przekształcić.</param>
        <summary>Konwertuje ciąg reprezentujący liczbę na jego <see cref="T:System.Numerics.BigInteger" /> równoważne.</summary>
        <returns>Wartość, która odpowiada liczbie określonej w <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` Parametr powinien być ciąg reprezentujący numer w następującej postaci.  
  
 [*ws*] [*logowania*]*cyfr*[*ws*]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Opcjonalny odstęp.|  
|*sign*|Opcjonalny znak. Prawidłowe są określane przez <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> i <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> właściwości bieżącej kultury.|  
|*cyfry*|Sekwencja cyfr od 0 do 9. Wszystkie zera wiodące są ignorowane.|  
  
> [!NOTE]
>  Ciąg określony przez `value` parametr jest interpretowany przy użyciu <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> stylu. Nie może zawierać żadnych separatorów grup ani separatorów dziesiętnych, a także mieć części dziesiętnej.  
  
 `value` Parametru jest analizowany przy użyciu informacje o formatowaniu w <xref:System.Globalization.NumberFormatInfo?displayProperty=nameWithType> inicjowanym dla bieżącej kultury systemu. Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Aby przeanalizować ciąg przy użyciu informacje o formatowaniu określonej kultury, należy użyć <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> metody.  
  
> [!IMPORTANT]
>  Jeśli używasz <xref:System.Numerics.BigInteger.Parse%2A> metody dwustronnej konwersji ciągu reprezentującego z <xref:System.Numerics.BigInteger> wartość, która została generowane przez <xref:System.Numerics.BigInteger.ToString%2A> metody, należy użyć <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metody przy użyciu specyfikatora formatu "R", aby wygenerować reprezentacji w postaci ciągu <xref:System.Numerics.BigInteger> wartość. W przeciwnym razie reprezentację ciągu <xref:System.Numerics.BigInteger> zachowuje tylko 50 najbardziej istotnych cyfr części oryginalnej wartości, a dane mogą zostać utracone, gdy używasz <xref:System.Numerics.BigInteger.Parse%2A> metoda przywracania <xref:System.Numerics.BigInteger> wartość.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.Parse%28System.String%29> metodę, aby utworzyć dwa wystąpienia <xref:System.Numerics.BigInteger> obiektów. Mnoży każdy obiekt przez inną liczbę, a następnie wywołuje <xref:System.Numerics.BigInteger.Compare%2A> metodę pozwala ustalić relacji między dwiema wartościami.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> nie jest w poprawnym formacie.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg zawierający liczbę, którą należy przekształcić.</param>
        <param name="style">Bitowa kombinacja wartości wyliczenia, które określają dozwolony format parametru <c>wartość</c>.</param>
        <summary>Konwertuje ciąg reprezentujący numer w określony styl do jego <see cref="T:System.Numerics.BigInteger" /> równoważne.</summary>
        <returns>Wartość, która odpowiada liczbie określonej w <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `style` Parametru definiuje elementy stylu (takie jak biały znak, symbol znaku dodatniego lub ujemnego, symbol separatora grupy lub symbol separatora dziesiętnego), które są dozwolone w `value` parametr jako warunek powodzenia operacji analizy. `styles` musi być kombinacją kombinacja flag bitowych z <xref:System.Globalization.NumberStyles> wyliczenia. `style` Parametru sprawia, że ta metoda przeciążenia przydatne, gdy `value` zawiera ciąg reprezentujący wartość szesnastkową, gdy system numer (dziesiętnych lub szesnastkowych) reprezentowany przez `value` jest znana dopiero w czasie wykonywania, lub gdy użytkownik Aby uniemożliwić biały znak lub symbol znaku w `value`.  
  
 W zależności od wartości `style`, `value` parametru może zawierać następujące elementy:  
  
 [*ws*] [*$*] [*logowania*] [*cyfr*,]*cyfr*[.* cyfry_ułamkowe*] [E [*logowania*]*cyfry_szesnastkowe*] [*ws*]  
  
 Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, `value` parametru może zawierać następujące elementy:  
  
 [*ws*]*cyfry_szesnastkowe*[*ws*]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Opcjonalny odstęp. Odstęp może występować na początku `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flagę która może znajdować się na końcu `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flagi.|  
|*$*|Symbol waluty specyficzny dla kultury. Jego pozycja w ciągu jest definiowana przez <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> i <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> właściwości bieżącej kultury. Symbol waluty bieżącej kultury może znajdować się w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flagi.|  
|*sign*|Opcjonalny znak. Znak może występować na początku `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flagę która może znajdować się na końcu `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flagi. Nawiasy mogą być używane w `value` do wskazania wartości ujemnej, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flagi.|  
|*cyfry*<br /><br /> *cyfry_ułamkowe*<br /><br /> *cyfry_szesnastkowe*|Sekwencja cyfr od 0 do 9. Aby uzyskać *cyfry_ułamkowe*należy korzystać tylko z cyfr 0 jest prawidłowy.|  
|*,*|Symbol separatora grupy specyficzny dla kultury. Separator grupy bieżącej kultury może znajdować się w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flagi.|  
|*.*|Symbol dziesiętny specyficzny dla kultury. Symbol separatora dziesiętnego bieżącej kultury może znajdować się w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flagi. Może występować tylko cyfry od 0, wyświetlaną cyfrą ułamkową operacja analizy się powiodła Jeśli *cyfry_ułamkowe* zawiera jakąkolwiek inną cyfrę, <xref:System.FormatException> zgłaszany.|  
|E|Znak „e” lub „E”, który wskazuje, że wartość jest reprezentowana w zapisie wykładniczym (naukowym). `value` Parametr może reprezentować liczbę w zapisie wykładniczym, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flagi.|  
|*cyfry_szesnastkowe*|Sekwencja cyfr szesnastkowych od 0 do f lub od 0 do F.|  
  
 Ciąg zawierający tylko cyfry (co odpowiada <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> styl) zawsze przeanalizowany pomyślnie. Większość pozostałych <xref:System.Globalization.NumberStyles> składowych kontroluje elementy, które mogą być obecne, ale nie muszą być obecne w ciągu wejściowym. Poniższa tabela wskazuje, jak poszczególne <xref:System.Globalization.NumberStyles> członków wpływają na elementy, które mogą być obecne w `value`.  
  
|`NumberStyles` Wartość|Elementy dozwolone w parametrze `value` poza cyframi|  
|--------------------------|---------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*Cyfr* tylko element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Separatora dziesiętnego (.) i *cyfr ułamkowych, jaka* elementów.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E" lub znak "E", co oznacza zapis wykładniczy, razem z *cyfry_szesnastkowe*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws* element na początku `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws* element na końcu `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*Logowania* element na początku `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*Logowania* element na końcu `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*Logowania* elementu w postaci nawiasów obejmujących wartość liczbową.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Element separatora grupy (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Element określający walutę ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Wszystkie elementy. Jednak `value` nie może reprezentować liczby szesnastkowej ani liczby w zapisie wykładniczym.|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws* element na początku lub końcu `value`, *logowania* na początku `value`i separator dziesiętny (*.*) symbol. `value` Parametru można również użyć notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`, `sign`, Separator grupy (*,*) i separator dziesiętny (*.*) elementów.|  
|<xref:System.Globalization.NumberStyles.Any>|Wszystkie elementy. Jednak `value` nie może reprezentować liczby szesnastkowej.|  
  
> [!IMPORTANT]
>  Jeśli używasz <xref:System.Numerics.BigInteger.Parse%2A> metody dwustronnej konwersji ciągu reprezentującego z <xref:System.Numerics.BigInteger> wartość, która została generowane przez <xref:System.Numerics.BigInteger.ToString%2A> metody, należy użyć <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metody przy użyciu specyfikatora formatu "R", aby wygenerować reprezentacji w postaci ciągu <xref:System.Numerics.BigInteger> wartość. W przeciwnym razie reprezentację ciągu <xref:System.Numerics.BigInteger> zachowuje tylko 50 najbardziej istotnych cyfr części oryginalnej wartości, a dane mogą zostać utracone, gdy używasz <xref:System.Numerics.BigInteger.Parse%2A> metoda przywracania <xref:System.Numerics.BigInteger> wartość.  
  
 W odróżnieniu od innych <xref:System.Globalization.NumberStyles> wartości, które umożliwiają, ale nie wymagają obecności elementów konkretnego stylu w `value`, <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> wartość stylu oznacza, że poszczególne znaki numeryczne w `value` są zawsze interpretowane jako znaki szesnastkowe. Prawidłowe znaki szesnastkowe to 0-9, A-F i a-f. Jedyne inne flagi, które mogą być łączone z `style` parametru są <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> i <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. ( <xref:System.Globalization.NumberStyles> Wyliczenia zawiera kompozytowy styl <xref:System.Globalization.NumberStyles.HexNumber>, który zawiera obie flagi odstępu.)  
  
> [!NOTE]
>  Jeśli `value` jest ciąg reprezentujący liczbę szesnastkową, nie może być poprzedzony żadnym uzupełnieniem (takie jak `0x` lub `&h`) które odróżnia go jako liczbę szesnastkową. To powoduje niepowodzenie konwersji.  
  
 Jeśli `value` jest ciąg szesnastkowy <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> interpretuje metoda `value` jako liczba ujemna przechowywane przy użyciu reprezentacji uzupełnienie dwójki, jeśli jego pierwsze dwie cyfry szesnastkowe są większe niż lub równa `0x80`. Innymi słowy, metoda interpretuje bitu najwyższego rzędu pierwszego bajtu w `value` jako bitu znaku. Aby upewnić się, że ciąg szesnastkowy poprawnie jest interpretowana jako liczba dodatnia, pierwsza cyfra w `value` musi mieć wartość zero. Na przykład metoda interpretuje `0x80` zgodnie z wartością ujemną, ale interpretuje albo `0x080` lub `0x0080` jako wartości dodatniej. Poniższy przykład ilustruje różnicę między ciągów szesnastkowych, które reprezentują wartości ujemny i dodatni.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 `value` Parametru jest analizowany przy użyciu informacje o formatowaniu w <xref:System.Globalization.NumberFormatInfo> inicjowanym dla bieżącej kultury systemu. Aby określić kulturę, której informacje o formatowaniu jest używany dla udanej operacji, należy wywołać <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> przeciążenia.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób wywołania <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> metody za pomocą kilku możliwych wartości dla `style` parametru. Przedstawia on sposób zinterpretować ciąg jako wartość szesnastkową oraz uniemożliwić miejsca do magazynowania i podpisać symboli.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#5)]
 [!code-vb[System.Numeric.BigInteger.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> nie jest <see cref="T:System.Globalization.NumberStyles" /> wartość.  - lub - <paramref name="style" /> obejmuje <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> lub <see cref="F:System.Globalization.NumberStyles.HexNumber" /> flagi wraz z inną wartością.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> nie jest zgodny z wzorca danych wejściowych, określony przez <see cref="T:System.Globalization.NumberStyles" />.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg zawierający liczbę, którą należy przekształcić.</param>
        <param name="provider">Obiekt, który zawiera informacje o formatowaniu specyficzne dla kultury na temat <c>wartość</c>.</param>
        <summary>Konwertuje ciąg reprezentujący numer w określonym formacie specyficzne dla kultury, aby jego <see cref="T:System.Numerics.BigInteger" /> równoważne.</summary>
        <returns>Wartość, która odpowiada liczbie określonej w <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` Parametr powinien być ciąg reprezentujący numer w następującej postaci:  
  
 [*ws*] [*logowania*]*cyfr*[*ws*]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Opcjonalny odstęp.|  
|*sign*|Opcjonalny znak. Prawidłowe są określane przez <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> i <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> właściwości <xref:System.Globalization.NumberFormatInfo> obiektu, który jest zwracany przez `provider` obiektu <xref:System.IFormatProvider.GetFormat%2A> metody.|  
|*cyfry*|Sekwencja cyfr od 0 do 9. Wszystkie zera wiodące są ignorowane.|  
  
> [!NOTE]
>  Ciąg określony przez `value` parametr jest interpretowany przy użyciu <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> stylu. Nie może zawierać żadnych separatorów grup ani separatorów dziesiętnych, a także mieć części dziesiętnej.  
  
> [!IMPORTANT]
>  Jeśli używasz <xref:System.Numerics.BigInteger.Parse%2A> metody dwustronnej konwersji ciągu reprezentującego z <xref:System.Numerics.BigInteger> wartość, która została generowane przez <xref:System.Numerics.BigInteger.ToString%2A> metody, należy użyć <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metody przy użyciu specyfikatora formatu "R", aby wygenerować reprezentacji w postaci ciągu <xref:System.Numerics.BigInteger> wartość. W przeciwnym razie reprezentację ciągu <xref:System.Numerics.BigInteger> zachowuje tylko 50 najbardziej istotnych cyfr części oryginalnej wartości, a dane mogą zostać utracone, gdy używasz <xref:System.Numerics.BigInteger.Parse%2A> metoda przywracania <xref:System.Numerics.BigInteger> wartość.  
  
 `provider` Parametr jest <xref:System.IFormatProvider> implementacji którego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury. Gdy <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> metoda jest wywoływana, wywołuje `provider` parametru <xref:System.IFormatProvider.GetFormat%2A> metody i przekazuje je <xref:System.Type> obiekt, który reprezentuje <xref:System.Globalization.NumberFormatInfo> typu. <xref:System.IFormatProvider.GetFormat%2A> Następnie metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje o formacie parametru `value` parametru. Istnieją trzy sposoby na wykorzystanie `provider` parametru jako źródła informacji o niestandardowym formatowaniu do operacji analizy:  
  
-   Możesz przekazać <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kulturę dostarczającą informacje o formatowaniu. Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje o formatowaniu liczb dla tej kultury.  
  
-   Można przekazać faktyczny <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje o formatowaniu liczb. (Jego implementacja obiektu <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> zwraca samą siebie.)  
  
-   Można przekazać niestandardowy obiekt, który implementuje <xref:System.IFormatProvider>. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda tworzy i zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który dostarcza informacje o formatowaniu.  
  
 Jeśli `provider` jest `null`, formatowanie `value` jest interpretowany na podstawie <xref:System.Globalization.NumberFormatInfo> obiekt bieżącej kultury.  
  
   
  
## Examples  
 W poniższych przykładach pokazano dwa sposoby definiowania tyldy (~) jako znaku ujemnego formatowania <xref:System.Numerics.BigInteger> wartości. Należy pamiętać, że do wyświetlenia <xref:System.Numerics.BigInteger> wartości w tym samym formacie co oryginalny ciągów, kod musi wywoływać <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metody i przekazać go <xref:System.Globalization.NumberFormatInfo> obiekt, który dostarcza informacje o formatowaniu.  
  
 W pierwszym przykładzie zdefiniowano klasę, która implementuje <xref:System.IFormatProvider> i używa <xref:System.IFormatProvider.GetFormat%2A> metodę, aby zwrócić <xref:System.Globalization.NumberFormatInfo> obiekt, który dostarcza informacje o formatowaniu.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#2)]  
  
 Element <xref:System.Numerics.BigInteger> obiektu następnie mogą być utworzone z następującym kodem:  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#3)]
 [!code-vb[System.Numeric.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#3)]  
  
 Drugi przykład jest bardziej bezpośredni. Przekazuje ono <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje o formatowaniu `provider` parametru.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#4)]
 [!code-vb[System.Numeric.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> nie jest w poprawnym formacie.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As BigInteger" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg zawierający liczbę, którą należy przekształcić.</param>
        <param name="style">Bitowa kombinacja wartości wyliczenia, które określają dozwolony format parametru <c>wartość</c>.</param>
        <param name="provider">Obiekt, który zawiera informacje o formatowaniu specyficzne dla kultury na temat <c>wartość</c>.</param>
        <summary>Konwertuje ciąg reprezentujący numer w określony styl i formatowanie specyficzne dla kultury do jego <see cref="T:System.Numerics.BigInteger" /> równoważne.</summary>
        <returns>Wartość, która odpowiada liczbie określonej w <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `style` Parametru definiuje elementy stylu (takie jak biały znak, symbol znaku dodatniego lub ujemnego, symbol separatora grupy lub symbol separatora dziesiętnego), które są dozwolone w `value` parametr jako warunek powodzenia operacji analizy. `styles` musi być kombinacją kombinacja flag bitowych z <xref:System.Globalization.NumberStyles> wyliczenia. `style` Parametru sprawia, że ta metoda przeciążenia przydatne, gdy `value` zawiera ciąg reprezentujący wartość szesnastkową, gdy system numer (dziesiętnych lub szesnastkowych) reprezentowany przez `value` jest znana dopiero w czasie wykonywania, lub gdy użytkownik Aby uniemożliwić biały znak lub symbol znaku w `value`.  
  
 W zależności od wartości `style`, `value` parametru może zawierać następujące elementy:  
  
 [*ws*][*$*][*sign*][*digits*,]*digits*[*.fractional_digits*][E[*sign*]*exponential_digits*][*ws*]  
  
 Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, `value` parametru może zawierać następujące elementy:  
  
 [*ws*]*cyfry_szesnastkowe*[*ws*]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Opcjonalny odstęp. Odstęp może występować na początku `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flagę która może znajdować się na końcu `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flagi.|  
|*$*|Symbol waluty specyficzny dla kultury. Jego pozycja w ciągu jest definiowana przez <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> i <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> właściwości kultury wskazywanym przez `provider` parametru. Symbol waluty bieżącej kultury może znajdować się w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flagi.|  
|*sign*|Opcjonalny znak. Znak może występować na początku `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flagę która może znajdować się na końcu `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flagi. Nawiasy mogą być używane w `value` do wskazania wartości ujemnej, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flagi.|  
|*cyfry*<br /><br /> *cyfry_ułamkowe*<br /><br /> *cyfry_szesnastkowe*|Sekwencja cyfr od 0 do 9. Aby uzyskać *cyfry_ułamkowe*należy korzystać tylko z cyfr 0 jest prawidłowy.|  
|*,*|Symbol separatora grupy specyficzny dla kultury. Symbol separatora grupy kultury określonej parametrem `provider` może znajdować się w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flagi.|  
|*.*|Symbol dziesiętny specyficzny dla kultury. Symbol separatora dziesiętnego kultury wyznaczonym przez `provider` może znajdować się w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flagi. Może występować tylko cyfry od 0, wyświetlaną cyfrą ułamkową operacja analizy się powiodła Jeśli *cyfry_ułamkowe* zawiera jakąkolwiek inną cyfrę, <xref:System.FormatException> zgłaszany.|  
|E|Znak „e” lub „E”, który wskazuje, że wartość jest reprezentowana w zapisie wykładniczym (naukowym). `value` Parametr może reprezentować liczbę w zapisie wykładniczym, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flagi.|  
|*cyfry_szesnastkowe*|Sekwencja cyfr szesnastkowych od 0 do f lub od 0 do F.|  
  
 Ciąg zawierający tylko cyfry (co odpowiada <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> styl) zawsze przeanalizowany pomyślnie. Większość pozostałych <xref:System.Globalization.NumberStyles> składowych kontroluje elementy, które mogą być obecne, ale nie muszą być obecne w ciągu wejściowym. Poniższa tabela wskazuje, jak poszczególne <xref:System.Globalization.NumberStyles> członków wpływają na elementy, które mogą być obecne w `value`.  
  
|Wartość wyliczenia NumberStyles|Dodatkowe (poza cyframi) elementy dozwolone w wartości|  
|------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*Cyfr* tylko element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Separatora dziesiętnego (.) i *cyfr ułamkowych, jaka* elementów.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Znak „e” lub znak „E”, co oznacza zapis wykładniczy. wraz z *cyfry_szesnastkowe*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws* element na początku `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws* element na końcu `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*Logowania* element na początku `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*Logowania* element na końcu `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*Logowania* elementu w postaci nawiasów obejmujących wartość liczbową.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Element separatora grupy (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Element określający walutę ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Wszystkie elementy. Jednak `value` nie może reprezentować liczby szesnastkowej ani liczby w zapisie wykładniczym.|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws* element na początku lub końcu `value`, *logowania* na początku `value`oraz symbol separatora dziesiętnego (.). `value` Parametru można również użyć notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`, `sign`, Separator grupy (,) i elementy przecinka dziesiętnego (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Wszystkie elementy. Jednak `value` nie może reprezentować liczby szesnastkowej.|  
  
> [!IMPORTANT]
>  Jeśli używasz <xref:System.Numerics.BigInteger.Parse%2A> metody dwustronnej konwersji ciągu reprezentującego z <xref:System.Numerics.BigInteger> wartość, która została generowane przez <xref:System.Numerics.BigInteger.ToString%2A> metody, należy użyć <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metody przy użyciu specyfikatora formatu "R", aby wygenerować reprezentacji w postaci ciągu <xref:System.Numerics.BigInteger> wartość. W przeciwnym razie reprezentację ciągu <xref:System.Numerics.BigInteger> zachowuje tylko 50 najbardziej istotnych cyfr części oryginalnej wartości, a dane mogą zostać utracone, gdy używasz <xref:System.Numerics.BigInteger.Parse%2A> metoda przywracania <xref:System.Numerics.BigInteger> wartość.  
  
 W odróżnieniu od innych <xref:System.Globalization.NumberStyles> wartości, które umożliwiają, ale nie wymagają obecności elementów konkretnego stylu w `value`, <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> wartość stylu oznacza, że poszczególne znaki numeryczne w `value` są zawsze interpretowane jako znaki szesnastkowe. Prawidłowe znaki szesnastkowe to 0-9, A-F i a-f. Jedyne inne flagi, które mogą być łączone z `style` parametru są <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> i <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. ( <xref:System.Globalization.NumberStyles> Wyliczenia zawiera kompozytowy styl <xref:System.Globalization.NumberStyles.HexNumber>, który zawiera obie flagi odstępu.)  
  
> [!NOTE]
>  Jeśli `value` jest ciąg reprezentujący liczbę szesnastkową, nie może być poprzedzony żadnym uzupełnieniem (takie jak `0x` lub `&h`) które odróżnia go jako liczbę szesnastkową. To powoduje niepowodzenie konwersji.  
  
 Jeśli `value` jest ciąg szesnastkowy <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> interpretuje metoda `value` jako liczba ujemna przechowywane przy użyciu reprezentacji uzupełnienie dwójki, jeśli jego pierwsze dwie cyfry szesnastkowe są większe niż lub równa `0x80`. Innymi słowy, metoda interpretuje bitu najwyższego rzędu pierwszego bajtu w `value` jako bitu znaku. Aby upewnić się, że ciąg szesnastkowy poprawnie jest interpretowana jako liczba dodatnia, pierwsza cyfra w `value` musi mieć wartość zero. Na przykład metoda interpretuje `0x80` zgodnie z wartością ujemną, ale interpretuje albo `0x080` lub `0x0080` jako wartości dodatniej. Poniższy przykład ilustruje różnicę między ciągów szesnastkowych, które reprezentują wartości ujemny i dodatni.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 `provider` Parametr <xref:System.IFormatProvider> implementacji. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje specyficzne dla kultury o formacie parametru `value`. Zazwyczaj `provider` może być jednym z następujących czynności:  
  
-   Element <xref:System.Globalization.CultureInfo> obiektu, który reprezentuje kulturę, która zapewnia informacje o formatowaniu liczb. Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje o formatowaniu liczb.  
  
-   Element <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje o formatowaniu. (Jego implementacja obiektu <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> zwraca samą siebie.)  
  
-   Niestandardowy obiekt, który implementuje <xref:System.IFormatProvider> i używa <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> metodę, aby tworzyć wystąpienie i zwracać <xref:System.Globalization.NumberFormatInfo> obiekt, który dostarcza informacje o formatowaniu.  
  
 Jeśli `provider` jest `null`, <xref:System.Globalization.NumberFormatInfo> obiekt bieżącej kultury jest używane.  
  
   
  
## Examples  
 Poniższy przykład wykonuje kilka wywołań do <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> metody przy użyciu różnych kombinacji wartości dla `style` i `provider` parametrów.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#2)]  
  
 Liczba poszczególnych wywołań dla <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> metoda Przekaż wystąpienie następujących `BigIntegerFormatProvider` klasy, która definiuje tyldy (~) jako znaku ujemnego.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> nie jest <see cref="T:System.Globalization.NumberStyles" /> wartość.  - lub - <paramref name="style" /> obejmuje <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> lub <see cref="F:System.Globalization.NumberStyles.HexNumber" /> flagi wraz z inną wartością.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> nie jest zgodny z wzorca danych wejściowych, określony przez <paramref name="style" />.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Pow (System.Numerics.BigInteger value, int exponent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Pow(valuetype System.Numerics.BigInteger value, int32 exponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As BigInteger, exponent As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Pow(System::Numerics::BigInteger value, int exponent);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Pow (value, exponent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Liczbę, aby podnieść do <c>wykładnik</c> zasilania.</param>
        <param name="exponent">Wykładnik, aby podnieść <c>wartość</c> przez.</param>
        <summary>Wywołuje <see cref="T:System.Numerics.BigInteger" /> wartości do potęgi określonej wartości.</summary>
        <returns>Wynik wywoływania <paramref name="value" /> do <paramref name="exponent" /> zasilania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Pow%2A> Metoda zwraca wartość 1, jeśli wartość wykładnika parametru jest 0, lub wartości obu `value` i `exponent` parametry są równe 0. Jeśli `exponent` wynosi 1, <xref:System.Numerics.BigInteger.Pow%2A> metoda zwraca `value`. Jeśli `value` jest ujemna, metoda zwraca wynik ujemny.  
  
 Ta metoda odnosi się do <xref:System.Math.Pow%2A?displayProperty=nameWithType> metodę pierwotnych typów liczbowych.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie potęgowania <xref:System.Numerics.BigInteger> wartość i wykładnik, którego wartość zakresu od 0 do 10.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#32)]
 [!code-vb[System.Numeric.BigInteger.Class#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="exponent" /> parametr jest liczbą ujemną.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remainder">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Remainder (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Remainder(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remainder (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Remainder(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Remainder : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Remainder (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Wartość do podzielenia.</param>
        <param name="divisor">Wartość do podzielenia przez.</param>
        <summary>Wykonuje dzielenie liczby całkowitej na dwóch <see cref="T:System.Numerics.BigInteger" /> wartości i zwraca resztę z dzielenia.</summary>
        <returns>Resztę po podzieleniu <paramref name="dividend" /> przez <paramref name="divisor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znak reszta jest znak `dividend` parametru.  
  
 <xref:System.Numerics.BigInteger.Remainder%2A> Metoda jest implementowana dla języków, które nie obsługują operatorów niestandardowych. Jego zachowanie jest identyczne z dzielenia przy użyciu operator modulo.  
  
 Jeśli to konieczne, metoda automatycznie przeprowadza niejawnej konwersji wartości innych typów całkowitych <xref:System.Numerics.BigInteger> obiektów przed wykonaniem operacji modulo.  
  
   
  
## Examples  
 W poniższym przykładzie porównano reszty z <xref:System.Numerics.BigInteger.DivRem%2A> metody za pomocą pozostałej zwrócony przez <xref:System.Numerics.BigInteger.Remainder%2A> metody do ustalenia, czy dwie metody obliczanie reszt identyczne.  
  
 [!code-csharp[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/cs/Remainder1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/vb/Remainder1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> to 0 (zero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public int Sign { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Sign" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Sign" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Sign As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Sign { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Sign : int" Usage="System.Numerics.BigInteger.Sign" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę, która określa znak (ujemny i dodatni, lub wartość zero) bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu.</summary>
        <value>Liczba, która określa znak <see cref="T:System.Numerics.BigInteger" /> obiektu, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Liczba </term><description> opis </description></listheader><item><term> -1 </term><description> wartość tego obiektu jest ujemna.  </description></item><item><term> 0 </term><description> wartość tego obiektu jest 0 (zero).  </description></item><item><term> 1 </term><description> wartość tego obiektu jest dodatni.  </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Sign%2A> Właściwość jest równoważna <xref:System.Math.Sign%2A?displayProperty=nameWithType> metodę pierwotnych typów liczbowych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Subtract (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Subtract(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Subtract(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Wartość do odjęcia od (odjemna).</param>
        <param name="right">Wartość do odjęcia (odjemnik).</param>
        <summary>Odejmuje jeden <see cref="T:System.Numerics.BigInteger" /> wartości z innego i zwraca wynik.</summary>
        <returns>Wynik odejmowania <paramref name="right" /> z <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można używać języków, które nie obsługują operatorów niestandardowych <xref:System.Numerics.BigInteger.Subtract%2A> metodę, aby wykonać za pomocą odejmowania <xref:System.Numerics.BigInteger> wartości.  
  
 <xref:System.Numerics.BigInteger.Subtract%2A> Metoda jest przydatna zastępują operator odejmowania, podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> zmiennej, przypisując go różnica, który jest wynikiem odejmowania, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ToByteArray();" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : unit -&gt; byte[]" Usage="bigInteger.ToByteArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje <see cref="T:System.Numerics.BigInteger" /> wartości do tablicy typu byte.</summary>
        <returns>Wartość bieżącego <see cref="T:System.Numerics.BigInteger" /> obiekt jest konwertowany na tablicę bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poszczególne bajty w tablicy zwracanej przez tę metodę są wyświetlane w kolejności little-endian. Oznacza to, że wartość w bajtach niższego rzędu poprzedzać bajtów wyższego rzędu. Pierwszy bajt tablicy odzwierciedla pierwsze osiem bitów <xref:System.Numerics.BigInteger> wartość, drugi bajt odzwierciedla dalej osiem bitów i tak dalej. Na przykład wartość 1024 lub 0x0400, są przechowywane jako tablica następujące dwa bajty:  
  
|Element|Wartość bajtu|  
|-------------|----------------|  
|0|0x00|  
|1|0x04|  
  
 Wartości ujemne są zapisywane do tablicy przy użyciu reprezentacji uzupełnienie dwójki w najbardziej zwięzłą możliwe formularza. Na przykład, wartość -1 jest reprezentowany jako jednobajtowych, którego wartością jest `0xFF` zamiast jako tablicę z wieloma elementami, takich jak `0xFF`, `0xFF` lub `0xFF`, `0xFF`, `0xFF`, `0xFF`.  
  
 Ponieważ dwójki uzupełniają reprezentacji zawsze interpretuje bitu najwyższego rzędu ostatniego bajtu w tablicy (bajt na pozycji <xref:System.Array.Length%2A?displayProperty=nameWithType> `- 1`) jako bitu znaku, Metoda ta zwraca tablicę bajtów z dodatkowy element, którego wartość jest równa zero do odróżnić wartości dodatnich, które w przeciwnym razie może zostać zinterpretowane jako posiadające bitów ich logowania. Na przykład, wartość 120 lub `0x78` jest reprezentowany jako tablica jednobajtowe: `0x78`. Jednakże, jest to 128, lub `0x80`, jest reprezentowana w postaci tablicy bajtów dwa: `0x80`, `0x00`.  
  
 Możesz Rundy <xref:System.Numerics.BigInteger> wartość przez zapisanie go do tablicy typu byte, a następnie przywróceniu go za pomocą <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> konstruktora.  
  
> [!CAUTION]
>  Jeżeli kod modyfikuje wartość pojedynczych bajtów w tablicy zwracanej przez tę metodę, przed jego przywraca wartość, upewnij się, że nie przypadkowo zmienić bitu znaku. Na przykład jeśli modyfikacje zwiększyć wartość dodatnią, dzięki czemu najwyższego rzędu bit w ostatnim elemencie tablicy bajtowej staje się ustawić, można dodać nowego typu byte, którego wartość jest równa zero do końca tablicy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak niektóre <xref:System.Numerics.BigInteger> wartości są reprezentowane w tablice typu byte.  
  
 [!code-csharp[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/cs/ToByteArray1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/vb/ToByteArray1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray (bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray(bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray (Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Byte()" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : bool * bool -&gt; byte[]" Usage="bigInteger.ToByteArray (isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość liczbową bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu na jego reprezentację ciągu równoważnego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="bigInteger.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość liczbową bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu na jego reprezentację ciągu równoważnego.</summary>
        <returns>Reprezentacja ciągu bieżącego <see cref="T:System.Numerics.BigInteger" /> wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ToString> Formaty metoda <xref:System.Numerics.BigInteger> wartości w "R" lub przesyłania danych, format bieżącej kultury. Jeśli chcesz określić inny format lub kultury, należy używać innych przeciążeń <xref:System.Numerics.BigInteger.ToString%2A> metody w następujący sposób:  
  
|Aby użyć formatu|Dla kultury|Użyj przeciążenia|  
|-------------------|-----------------|----------------------|  
|Round-trip ("R") format|Określonej kultury|<xref:System.Numerics.BigInteger.ToString%2A>|  
|Określony format|(Domyślne bieżącej) kultury|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Określony format|Określonej kultury|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Reprezentacja ciągu <xref:System.Numerics.BigInteger> wartość zawiera znak ujemny, jeśli jego wartość jest ujemna i sekwencję cyfr od 0 do 9, bez zer wiodących. Znak ujemny jest definiowany przez <xref:System.Globalization.NumberFormatInfo> obiektu dla bieżącej kultury.  
  
   
  
## Examples  
 Poniższy przykład wyświetla <xref:System.Numerics.BigInteger> wartość przy użyciu domyślnej <xref:System.Numerics.BigInteger.ToString> metody. Wyświetla również ciągów reprezentujących <xref:System.Numerics.BigInteger> wartość będącą wynikiem przy użyciu niektóre specyfikatory formatu standardowego. W przykładach jest używana konwencja formatowania kultury en-US.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="bigInteger.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość liczbową bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu na jego reprezentację ciągu równoważnego przy użyciu określonego specyficzne dla kultury informacje o formatowaniu.</summary>
        <returns>Reprezentacja ciągu bieżącego <see cref="T:System.Numerics.BigInteger" /> wartość w formacie określonym przez <paramref name="provider" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> Formaty metoda <xref:System.Numerics.BigInteger> wartość "R" lub Rundy formatowania za pomocą <xref:System.Globalization.NumberFormatInfo> obiektu określonej kultury. Jeśli chcesz określić inny format lub bieżącej kultury, należy używać innych przeciążeń <xref:System.Numerics.BigInteger.ToString%2A> metody w następujący sposób:  
  
|Aby użyć formatu|Dla kultury|Użyj przeciążenia|  
|-------------------|-----------------|----------------------|  
|Round-trip ("R") format|(Domyślne bieżącej) kultury|<xref:System.Numerics.BigInteger.ToString>|  
|Określony format|(Domyślne bieżącej) kultury|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Określony format|Określonej kultury|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 `provider` Parametr <xref:System.IFormatProvider> implementacji. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje specyficzne dla kultury o formacie ciągu zwracanego przez tę metodę. Jeśli `provider` jest `null`, <xref:System.Numerics.BigInteger> wartość jest formatowana przy użyciu <xref:System.Globalization.NumberFormatInfo> obiekt bieżącej kultury. Tylko właściwości <xref:System.Globalization.NumberFormatInfo> obiekt, który kontroluje reprezentację ciągu <xref:System.Numerics.BigInteger> jest wartość przy użyciu specyfikatora formatu ogólnego <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, która określa znak, który reprezentuje znak ujemny.  
  
 `provider` Parametr może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kulturę dostarczającą informacje o formatowaniu.  
  
-   <xref:System.Globalization.NumberFormatInfo> Obiekt, który dostarcza informacje o formatowaniu.  
  
-   Niestandardowy obiekt, który implementuje <xref:System.IFormatProvider>. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który dostarcza informacje o formatowaniu.  
  
   
  
## Examples  
 Poniższy przykład tworzy niestandardowy <xref:System.Globalization.NumberFormatInfo> obiekt, który definiuje tyldy (~) jako znaku ujemnego. <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> Metoda następnie używa niestandardowego <xref:System.Globalization.NumberFormatInfo> obiektu, aby wyświetlić ujemnych <xref:System.Numerics.BigInteger> wartość.  
  
 [!code-csharp[System.Numeric.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/cs/System.Numeric.BigInteger.ToString.cs#1)]
 [!code-vb[System.Numeric.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/vb/System.Numeric.BigInteger.ToString.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="bigInteger.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Standardowy lub niestandardowy ciąg formatu liczbowego.</param>
        <summary>Konwertuje wartość liczbową bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu na jego reprezentację ciągu równoważnego przy użyciu określonego formatu.</summary>
        <returns>Reprezentacja ciągu bieżącego <see cref="T:System.Numerics.BigInteger" /> wartość w formacie określonym przez <paramref name="format" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ToString%28System.String%29> Formaty metoda <xref:System.Numerics.BigInteger> wartości w określonym formacie za pomocą <xref:System.Globalization.NumberFormatInfo> obiekt, który reprezentuje konwencje bieżącej kultury. Jeśli chcesz użyć "R" lub dwustronnej konwersji formatu lub określić inną kulturę, używać innych przeciążeń <xref:System.Numerics.BigInteger.ToString%2A> metody w następujący sposób:  
  
|Aby użyć formatu|Dla kultury|Użyj przeciążenia|  
|-------------------|-----------------|----------------------|  
|Round-trip ("R") format|(Domyślne bieżącej) kultury|<xref:System.Numerics.BigInteger.ToString>|  
|Round-trip ("R") format|Określonej kultury|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Określony format|Określonej kultury|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 `format` Parametr może być dowolne, prawidłowe [standardowego ciągu numerycznego](~/docs/standard/base-types/standard-numeric-format-strings.md), lub dowolnej kombinacji [ciągi niestandardowego formatu liczb](~/docs/standard/base-types/custom-numeric-format-strings.md). Jeśli `format` jest równa <xref:System.String.Empty?displayProperty=nameWithType> lub `null`, zwracana wartość bieżącej <xref:System.Numerics.BigInteger> obiektu jest formatowana przy użyciu specyfikatora formatu Rundy ("R"). Jeśli `format` ma jakąkolwiek inną wartość, metoda zgłasza wyjątek <xref:System.FormatException>.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat obsługi formatowania w programie .NET Framework, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 Format zwracanego ciągu jest określany przez <xref:System.Globalization.NumberFormatInfo> obiektu dla bieżącej kultury. W zależności od `format` parametr, ten obiekt kontroluje symbole takie jak znak ujemny, separator grupy i symbol seperatora dziesiętnego w ciągu wyjściowym. Aby podać informacje o formatowaniu dla języków innych niż bieżącej kultury, należy wywołać <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> przeciążenia.  
  
   
  
## Examples  
 Poniższy przykład inicjuje <xref:System.Numerics.BigInteger> wartość i wyświetla je przy użyciu każdego ciągu formatu standardowego i niektóre ciągi formatu niestandardowego.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> nie jest ciągiem nieprawidłowy format.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="bigInteger.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Standardowy lub niestandardowy ciąg formatu liczbowego.</param>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość liczbową bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu na jego reprezentację ciągu równoważnego przy użyciu podanego formatu i informacji o formacie specyficzne dla kultury.</summary>
        <returns>Reprezentacja ciągu bieżącego <see cref="T:System.Numerics.BigInteger" /> wartość określoną przez <paramref name="format" /> i <paramref name="provider" /> parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> Formaty metoda <xref:System.Numerics.BigInteger> wartości w określonym formacie za pomocą <xref:System.Globalization.NumberFormatInfo> obiektu określonej kultury. Jeśli chcesz użyć formatu obustronne lub domyślne ustawienia kultury, należy używać innych przeciążeń <xref:System.Numerics.BigInteger.ToString%2A> metody w następujący sposób:  
  
|Aby użyć formatu|Dla kultury|Użyj przeciążenia|  
|-------------------|-----------------|----------------------|  
|Round-trip ("R") format|(Domyślne bieżącej) kultury|<xref:System.Numerics.BigInteger.ToString>|  
|Round-trip ("R") format|Określonej kultury|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Określony format|(Domyślne bieżącej) kultury|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
  
 `format` Parametr może być dowolne, prawidłowe [standardowego ciągu numerycznego](~/docs/standard/base-types/standard-numeric-format-strings.md), lub dowolnej kombinacji [ciągi niestandardowego formatu liczb](~/docs/standard/base-types/custom-numeric-format-strings.md). Jeśli `format` jest równa <xref:System.String.Empty?displayProperty=nameWithType> lub `null`, zwracana wartość bieżącej <xref:System.Numerics.BigInteger> obiektu jest formatowana przy użyciu specyfikatora formatu Rundy ("R"). Jeśli `format` ma jakąkolwiek inną wartość, metoda zgłasza wyjątek <xref:System.FormatException>.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat obsługi formatowania w programie .NET Framework, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 `provider` Parametr <xref:System.IFormatProvider> implementacji. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje specyficzne dla kultury o formacie ciągu zwracanego przez tę metodę. Gdy <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> metoda jest wywoływana, wywołuje `provider` parametru <xref:System.IFormatProvider.GetFormat%2A> metody i przekazuje je <xref:System.Type> obiekt, który reprezentuje <xref:System.Globalization.NumberFormatInfo> typu. <xref:System.IFormatProvider.GetFormat%2A> Następnie metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który zawiera informacje o formatowaniu `value` parametru, takie jak symbol znaku ujemnego, symbol separatora grupy lub symbol separatora dziesiętnego. Istnieją trzy sposoby na wykorzystanie `provider` parametru, aby podać informacje o formatowaniu <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> metody:  
  
-   Możesz przekazać <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kulturę dostarczającą informacje o formatowaniu. Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje o formatowaniu liczb dla tej kultury.  
  
-   Można przekazać faktyczny <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje o formatowaniu liczb. (Jego implementacja obiektu <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> zwraca samą siebie.)  
  
-   Można przekazać niestandardowy obiekt, który implementuje <xref:System.IFormatProvider>. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda tworzy i zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który dostarcza informacje o formatowaniu.  
  
 Jeśli `provider` jest `null`, formatowaniem zwracanego ciągu jest oparty na <xref:System.Globalization.NumberFormatInfo> obiekt bieżącej kultury.  
  
   
  
## Examples  
 Poniższy przykład inicjuje <xref:System.Numerics.BigInteger> wartości i wyświetla go w konsoli przy użyciu ciągu formatu standardowego i <xref:System.Globalization.NumberFormatInfo> obiekt, który definiuje tyldy (~) jako znaku ujemnego.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> nie jest ciągiem nieprawidłowy format.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="bigInteger.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Próbuje przekonwertować ciąg reprezentujący liczbę na jego <see cref="T:System.Numerics.BigInteger" /> równoważne i zwraca wartość wskazującą, czy konwersja powiodła się.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg reprezentujący liczbę.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.Numerics.BigInteger" /> równoważna liczbie zawartej w <c>wartość</c>, lub wartość zero (0), jeśli konwersja nie powiedzie się. Jeśli konwersja nie powiedzie się <c>wartość</c> parametr <see langword="null" /> albo nie jest w poprawnym formacie. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Próbuje przekonwertować ciąg reprezentujący liczbę na jego <see cref="T:System.Numerics.BigInteger" /> równoważne i zwraca wartość wskazującą, czy konwersja powiodła się.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> został przekonwertowany pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> Metoda przypomina <xref:System.Numerics.BigInteger.Parse%28System.String%29> metody, z wyjątkiem, że nie zgłosi wyjątek, jeśli konwersja nie powiedzie się. Ta metoda eliminuje potrzebę używania wyjątków do testowania <xref:System.FormatException> Jeśli `value` jest nieprawidłowy i nie można pomyślnie przeanalizować.  
  
 `value` Parametr powinien być ciąg reprezentujący liczbę dziesiętną w następującej postaci:  
  
 [*ws*] [*logowania*]*cyfr*[*ws*]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Opcjonalny odstęp.|  
|*sign*|Opcjonalny znak. Prawidłowe są określane przez <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> i <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> właściwości bieżącej kultury.|  
|*cyfry*|Sekwencja cyfr dziesiętnych od 0 do 9.|  
  
> [!NOTE]
>  Ciąg określony przez `value` parametr nie może zawierać żadnych separatorów grup ani separatorów dziesiętnych i nie może mieć części dziesiętnych.  
  
 `value` Parametr jest interpretowany przy użyciu <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> stylu. Poza cyframi dziesiętnymi dopuszcza się tylko spacje początkowe i końcowe z wiodącym znakiem. Jawnie definiuje elementy stylu dla kultury informacje formatowania, które mogą być obecne w `value`, wywołaj <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> metody.  
  
 `value` Parametru jest analizowany przy użyciu informacje o formatowaniu w <xref:System.Globalization.NumberFormatInfo> obiektu dla bieżącej kultury. Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>.  
  
 To przeciążenie interpretuje wszystkie cyfry w `value` parametru jako cyfry dziesiętne. Aby przeanalizować ciąg reprezentujący liczbę szesnastkową, należy wywołać <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> zamiast tego przeciążenia.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> metodę, aby utworzyć dwa wystąpienia <xref:System.Numerics.BigInteger> obiektów. Jeśli konwersja powiodła się, mnoży każdy obiekt przez inną liczbę, a następnie wywołuje <xref:System.Numerics.BigInteger.Compare%2A> metodę pozwala ustalić relacji między dwoma obiektami.  
  
 [!code-csharp[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/cs/System.Numeric.BigInteger.TryParse.cs#1)]
 [!code-vb[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/vb/System.Numeric.BigInteger.TryParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg reprezentujący liczbę. Ten ciąg jest interpretowany przy użyciu stylu określonego parametrem <c>styl</c>.</param>
        <param name="style">Bitowa kombinacja wartości wyliczenia wskazująca elementy stylu, które mogą być obecne w <c>wartość</c>. To typowa wartość do określenia <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">Obiekt, który dostarcza specyficzne dla kultury informacje o formatowaniu <c>wartość</c>.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.Numerics.BigInteger" /> równoważna liczbie zawartej w <c>wartość</c>, lub <see cref="P:System.Numerics.BigInteger.Zero" /> Jeśli konwersja nie powiodła się. Jeśli konwersja nie powiedzie się <c>wartość</c> parametr jest <see langword="null" /> lub nie jest w formacie, który jest zgodny ze <c>styl</c>. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Próbuje przekonwertować ciąg reprezentujący numer w określony styl i formatowanie specyficzne dla kultury do jego <see cref="T:System.Numerics.BigInteger" /> równoważne i zwraca wartość wskazującą, czy konwersja powiodła się.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> parametr został przekonwertowany pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> Metoda przypomina <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> metody, z wyjątkiem, że nie zgłosi wyjątek, jeśli konwersja nie powiedzie się. Ta metoda eliminuje potrzebę używania wyjątków do testowania <xref:System.FormatException> Jeśli `value` jest nieprawidłowy i nie może zostać przeanalizowany pomyślnie.  
  
 `style` Parametru definiuje elementy stylu (takie jak odstępy czy znak dodatnia lub ujemna), które są dozwolone w `value` parametr jako warunek powodzenia operacji analizy. Musi być kombinacją flag bitowych z <xref:System.Globalization.NumberStyles> wyliczenia. W zależności od wartości `style`, `value` parametru może zawierać następujące elementy:  
  
 [*ws*] [*$*] [*logowania*] [*cyfr*,]*cyfr*[.* cyfry_ułamkowe*] [E [*logowania*]*cyfry_szesnastkowe*] [*ws*]  
  
 Jeśli `style` zawiera parametr <xref:System.Globalization.NumberStyles.AllowHexSpecifier>, `value` parametru może zawierać następujące elementy:  
  
 [*ws*]*cyfry_szesnastkowe*[*ws*]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Opcjonalny odstęp. Odstęp może występować na początku `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flagi, lub na końcu `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flagi.|  
|*$*|Symbol waluty specyficzny dla kultury. Jego pozycja w ciągu jest definiowana przez <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A> właściwość <xref:System.Globalization.NumberFormatInfo> obiektu zwróconego przez <xref:System.IFormatProvider.GetFormat%2A> metody `provider` parametru. Symbol waluty może znajdować się w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flagi.|  
|*sign*|Opcjonalny znak. Znak może występować na początku `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flagę która może znajdować się na końcu `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flagi. Nawiasy mogą być używane w `value` do wskazania wartości ujemnej, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flagi.|  
|*cyfry*|Sekwencja cyfr od 0 do 9.|  
|*,*|Separator grupy specyficzny dla kultury. Separator grupy kultury określonej parametrem `provider` może znajdować się w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flagi.|  
|*.*|Symbol dziesiętny specyficzny dla kultury. Symbol separatora dziesiętnego kultury określonej przez `provider` może znajdować się w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flagi.|  
|*cyfry_ułamkowe*|Jedno lub więcej wystąpień cyfry 0. Cyfry ułamkowe mogą pojawiać się w `value` tylko wtedy, gdy `style` obejmuje <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flagi.|  
|E|Znak „e” lub „E”, który wskazuje, że wartość jest reprezentowana w zapisie wykładniczym (naukowym). `value` Parametr może reprezentować liczbę w zapisie wykładniczym, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flagi.|  
|*cyfry_szesnastkowe*|Sekwencja cyfr od 0 do 9. `value` Parametr może reprezentować liczbę w zapisie wykładniczym, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flagi.|  
|*cyfry_szesnastkowe*|Sekwencja cyfr szesnastkowych od 0 do f lub od 0 do F.|  
  
 Ciąg zawierający tylko cyfry dziesiętne (co odpowiada <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> flagi) zawsze przeanalizowany pomyślnie. Większość pozostałych <xref:System.Globalization.NumberStyles> składowych kontroluje elementy, które mogą być obecne, ale nie muszą być obecne w tym ciągu wejściowym. Poniższa tabela wskazuje, jak poszczególne <xref:System.Globalization.NumberStyles> członków wpływają na elementy, które mogą być obecne w `value`.  
  
|Niezłożone `NumberStyles` wartości|Dodatkowe (poza cyframi) elementy dozwolone w wartości|  
|------------------------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Tylko cyfry dziesiętne.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Punkt dziesiętny (*.*) i *cyfry_ułamkowe* elementów. Jednak *cyfry_ułamkowe* musi zawierać wyłącznie jedną lub więcej cyfr 0, metoda zwraca `false`.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E" lub znak "E", co oznacza zapis wykładniczy, razem z *cyfry_szesnastkowe*. Jeśli `value` reprezentuje liczbę w zapisie wykładniczym nie ma składnika różna od zera, ułamkowe.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws* element na początku `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws* element na końcu `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*Logowania* przed elementem *cyfr*.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*Logowania* elementu po *cyfr*.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*Logowania* elementu w postaci nawiasów obejmujących wartość liczbową.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Separator grupy (*,*) elementu.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Waluta (*$*) elementu.|  
|<xref:System.Globalization.NumberStyles.Currency>|Wszystkie elementy. Jednak `value` nie może reprezentować liczby szesnastkowej ani liczby w zapisie wykładniczym.|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws* element na początku lub końcu `value`, *logowania* na początku `value`i separator dziesiętny (*.*) symbol. `value` Parametru można również użyć notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Number>|*Ws*, *logowania*, separator grupy (*,*) i separator dziesiętny (*.*) elementów.|  
|<xref:System.Globalization.NumberStyles.Any>|Wszystkie elementy. Jednak `value` nie może reprezentować liczby szesnastkowej.|  
  
> [!IMPORTANT]
>  Jeśli używasz <xref:System.Numerics.BigInteger.TryParse%2A> metody dwustronnej konwersji ciągu reprezentującego z <xref:System.Numerics.BigInteger> wartość, która została generowane przez <xref:System.Numerics.BigInteger.ToString%2A> metody, należy użyć <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metody przy użyciu specyfikatora formatu "R", aby wygenerować reprezentacji w postaci ciągu <xref:System.Numerics.BigInteger> wartość. W przeciwnym razie reprezentację ciągu <xref:System.Numerics.BigInteger> zachowuje tylko 50 najbardziej istotnych cyfr części oryginalnej wartości, a dane mogą zostać utracone, gdy używasz <xref:System.Numerics.BigInteger.TryParse%2A> metoda przywracania <xref:System.Numerics.BigInteger> wartość.  
  
 Jeśli <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> flaga jest używana, `value` musi mieć wartość szesnastkową. Jedyne inne flagi, które mogą być obecne w `style` są <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> i <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. ( <xref:System.Globalization.NumberStyles> Wyliczenie ma styl kompozytowy <xref:System.Globalization.NumberStyles.HexNumber>, który zawiera obie flagi odstępu.)  
  
> [!NOTE]
>  Jeśli `value` jest ciąg reprezentujący liczbę szesnastkową, nie może być poprzedzony żadnym uzupełnieniem (takie jak `0x` lub `&h`) które odróżnia go jako liczbę szesnastkową. To powoduje niepowodzenie konwersji.  
  
 Jeśli `value` jest ciąg szesnastkowy <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> interpretuje metoda `value` jako liczba ujemna przechowywane przy użyciu reprezentacji uzupełnienie dwójki, jeśli jego pierwsze dwie cyfry szesnastkowe są większe niż lub równa `0x80`. Innymi słowy, metoda interpretuje bitu najwyższego rzędu pierwszego bajtu w `value` jako bitu znaku. Aby upewnić się, że ciąg szesnastkowy poprawnie jest interpretowana jako liczba dodatnia, pierwsza cyfra w `value` musi mieć wartość zero. Na przykład metoda interpretuje `0x80` zgodnie z wartością ujemną, ale interpretuje albo `0x080` lub `0x0080` jako wartości dodatniej. Poniższy przykład ilustruje różnicę między ciągów szesnastkowych, które reprezentują wartości ujemny i dodatni.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParseHex1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParseHex1.vb#1)]  
  
 `provider` Parametr <xref:System.IFormatProvider> implementacji. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje specyficzne dla kultury o formacie parametru `value`. `provider` Parametru może być jednym z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kulturę dostarczającą informacje o formatowaniu. Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje o formatowaniu liczb dla tej kultury.  
  
-   Element <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje o formatowaniu liczb. (Jego implementacja obiektu <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> zwraca samą siebie.)  
  
-   Niestandardowy obiekt, który implementuje <xref:System.IFormatProvider>. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda tworzy i zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który dostarcza informacje o formatowaniu.  
  
 Jeśli `provider` jest `null`, <xref:System.Globalization.NumberFormatInfo> obiekt bieżącej kultury jest używane.  
  
   
  
## Examples  
 Poniższy przykład wykonuje kilka wywołań <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> metody przy użyciu różnych kombinacji wartości dla `style` i `provider` parametrów.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#2)]  
  
 Liczba poszczególnych wywołań dla <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> metoda Przekaż wystąpienie następujących `BigIntegerFormatProvider` klasy, która definiuje tyldy (~) jako znaku ujemnego.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> nie jest <see cref="T:System.Globalization.NumberStyles" /> wartość.  - lub - <paramref name="style" /> obejmuje <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> lub <see cref="F:System.Globalization.NumberStyles.HexNumber" /> flagi wraz z inną wartością.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryWriteBytes(System.Span{System.Byte},System.Int32@,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer, Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryWriteBytes : Span&lt;byte&gt; *  * bool * bool -&gt; bool" Usage="bigInteger.TryWriteBytes (destination, bytesWritten, isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger Zero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Zero As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger Zero { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.Zero : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Zero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która reprezentuje numer 0 (zero).</summary>
        <value>Liczba całkowita, którego wartość jest równa 0 (zero).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger> Obiektu zwróconego przez tę właściwość udostępnia wygodne źródło wartość zero dla przypisania i porównań.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsZero" />
      </Docs>
    </Member>
  </Members>
</Type>